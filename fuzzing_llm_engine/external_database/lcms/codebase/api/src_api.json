{
  "src": {
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/threaded/src/threaded_core.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nDWORD WINAPI thread_adaptor(LPVOID p)\n{\n    thread_adaptor_param* ap = (thread_adaptor_param*)p;\n    _cmsWorkSlice* s = ap->param;\n\n    ap->worker(s->CMMcargo, s->InputBuffer, s->OutputBuffer, \n               s->PixelsPerLine, s->LineCount, s->Stride);\n    _cmsFree(0, p);\n    return 0;\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              50,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "thread_adaptor",
            "parameters": {
              "p": "LPVOID"
            },
            "return_type": "DWORD"
          }
        },
        {
          "fn_code": "cmsHANDLE _cmsThrCreateWorker(cmsContext ContextID, _cmsTransform2Fn worker, _cmsWorkSlice* param)\n{\n    DWORD ThreadID;\n    thread_adaptor_param* p;\n    HANDLE handle;\n\n    p = (thread_adaptor_param*)_cmsMalloc(0, sizeof(thread_adaptor_param));\n    if (p == NULL) return NULL;\n\n    p->worker = worker;\n    p->param = param;\n\n    handle  = CreateThread(NULL, 0, thread_adaptor, (LPVOID) p, 0, &ThreadID);\n    if (handle == NULL)\n    {\n        cmsSignalError(ContextID, cmsERROR_UNDEFINED, \"Cannot create thread\");\n    }\n\n    return (cmsHANDLE)handle;\n}",
          "fn_code_pos": [
            [
              54,
              0
            ],
            [
              73,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsThrCreateWorker",
            "parameters": {
              "ContextID": "cmsContext",
              "worker": "_cmsTransform2Fn",
              "param": "_cmsWorkSlice"
            },
            "return_type": "cmsHANDLE"
          }
        },
        {
          "fn_code": "void _cmsThrJoinWorker(cmsContext ContextID, cmsHANDLE hWorker)\n{\n    if (WaitForSingleObject((HANDLE)hWorker, INFINITE) != WAIT_OBJECT_0)\n    {\n        cmsSignalError(ContextID, cmsERROR_UNDEFINED, \"Cannot join thread\");\n    }\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsThrJoinWorker",
            "parameters": {
              "ContextID": "cmsContext",
              "hWorker": "cmsHANDLE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsInt32Number _cmsThrIdealThreadCount(void)\n{\n    SYSTEM_INFO sysinfo;\n\n    GetSystemInfo(&sysinfo);\n    return sysinfo.dwNumberOfProcessors; //Returns the number of processors in the system.\n}",
          "fn_code_pos": [
            [
              85,
              0
            ],
            [
              91,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsThrIdealThreadCount",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid* thread_adaptor(void* p)\n{\n    thread_adaptor_param* ap = (thread_adaptor_param*)p;\n    _cmsWorkSlice* s = ap->param;\n\n    ap->worker(s->CMMcargo, s->InputBuffer, s->OutputBuffer,\n               s->PixelsPerLine, s->LineCount, s->Stride);\n    _cmsFree(0, p);\n\n    return NULL;\n}",
          "fn_code_pos": [
            [
              109,
              0
            ],
            [
              120,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "thread_adaptor",
            "parameters": {
              "p": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsHANDLE _cmsThrCreateWorker(cmsContext ContextID, _cmsTransform2Fn worker, _cmsWorkSlice* param)\n{\n    pthread_t threadId;\n    thread_adaptor_param* p;\n\n    p = (thread_adaptor_param*)_cmsMalloc(0, sizeof(thread_adaptor_param));\n    if (p == NULL) return NULL;\n\n    p->worker = worker;\n    p->param = param;\n\n    int err = pthread_create(&threadId, NULL, thread_adaptor, p);\n    if (err != 0)\n    {\n        cmsSignalError(ContextID, cmsERROR_UNDEFINED, \"Cannot create thread [pthread error %d]\", err);\n        return NULL;\n    }\n    else\n        return (cmsHANDLE) threadId;\n}",
          "fn_code_pos": [
            [
              124,
              0
            ],
            [
              143,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsThrCreateWorker",
            "parameters": {
              "ContextID": "cmsContext",
              "worker": "_cmsTransform2Fn",
              "param": "_cmsWorkSlice"
            },
            "return_type": "cmsHANDLE"
          }
        },
        {
          "fn_code": "void _cmsThrJoinWorker(cmsContext ContextID, cmsHANDLE hWorker)\n{\n    int err = pthread_join((pthread_t)hWorker, NULL);\n    if (err != 0)\n    {\n        cmsSignalError(ContextID, cmsERROR_UNDEFINED, \"Cannot join thread [pthread error %d]\", err); \n    }\n}",
          "fn_code_pos": [
            [
              146,
              0
            ],
            [
              153,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsThrJoinWorker",
            "parameters": {
              "ContextID": "cmsContext",
              "hWorker": "cmsHANDLE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsInt32Number _cmsThrIdealThreadCount(void)\n{    \n    long cores = sysconf(_SC_NPROCESSORS_ONLN);\n    if (cores == -1L)\n        return 1;\n    else\n        return (cmsInt32Number)cores;\n}",
          "fn_code_pos": [
            [
              155,
              0
            ],
            [
              162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsThrIdealThreadCount",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "thread_adaptor(void* p)",
          "fn_dec_pos": [
            [
              110,
              6
            ],
            [
              110,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "thread_adaptor",
            "parameters": {
              "p": "void"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct\n{\n    _cmsTransform2Fn worker;\n    _cmsWorkSlice* param;\n\n} thread_adaptor_param;",
          {
            "worker": "_cmsTransform2Fn",
            "* param": "_cmsWorkSlice"
          },
          "thread_adaptor_param",
          [
            31,
            0
          ],
          [
            36,
            23
          ]
        ],
        [
          "typedef struct\n{\n    _cmsTransform2Fn worker;\n    _cmsWorkSlice* param;\n\n} thread_adaptor_param;",
          {
            "worker": "_cmsTransform2Fn",
            "* param": "_cmsWorkSlice"
          },
          "thread_adaptor_param",
          [
            100,
            0
          ],
          [
            105,
            23
          ]
        ],
        [
          "typedef struct\n{\n    _cmsTransform2Fn worker;\n    _cmsWorkSlice* param;\n\n} thread_adaptor_param;",
          {
            "worker": "_cmsTransform2Fn",
            "* param": "_cmsWorkSlice"
          },
          "thread_adaptor_param",
          [
            31,
            0
          ],
          [
            36,
            23
          ]
        ],
        [
          "typedef struct\n{\n    _cmsTransform2Fn worker;\n    _cmsWorkSlice* param;\n\n} thread_adaptor_param;",
          {
            "worker": "_cmsTransform2Fn",
            "* param": "_cmsWorkSlice"
          },
          "thread_adaptor_param",
          [
            100,
            0
          ],
          [
            105,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"threaded_internal.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include <windows.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <pthread.h>\n",
          [
            96,
            0
          ],
          [
            97,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            97,
            0
          ],
          [
            98,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/threaded/src/threaded_scheduler.c": {
      "fn_def_list": [
        {
          "fn_code": "void  _cmsThrScheduler(struct _cmstransform_struct* CMMcargo,\n                       const void* InputBuffer,\n                       void* OutputBuffer,\n                       cmsUInt32Number PixelsPerLine,\n                       cmsUInt32Number LineCount,\n                       const cmsStride* Stride)\n{\n    cmsContext ContextID = cmsGetTransformContextID(CMMcargo);\n    _cmsTransform2Fn worker = _cmsGetTransformWorker(CMMcargo);\n    cmsInt32Number   MaxWorkers = _cmsGetTransformMaxWorkers(CMMcargo);\n\n    // flags are not actually being used\n    // cmsUInt32Number  flags = _cmsGetTransformWorkerFlags(CMMcargo);\n\n    _cmsWorkSlice master;\n    _cmsWorkSlice* slices;\n    cmsStride FixedStride = *Stride;\n    cmsHANDLE* handles;\n\n    //  Count the number of threads needed for this job. MaxWorkers is the upper limit or -1 to auto\n    cmsUInt32Number nSlices = _cmsThrCountSlices(CMMcargo, MaxWorkers, PixelsPerLine, LineCount, &FixedStride);\n    \n    // Abort early if no threaded code\n    if (nSlices <= 1) {\n\n        worker(CMMcargo, InputBuffer, OutputBuffer, PixelsPerLine, LineCount, Stride);\n        return;\n    }\n\n    // Setup master thread\n    master.CMMcargo = CMMcargo;\n    master.InputBuffer = InputBuffer;\n    master.OutputBuffer = OutputBuffer;\n    master.PixelsPerLine = PixelsPerLine;\n    master.LineCount = LineCount;\n    master.Stride = &FixedStride;\n\n    // Create memory for the slices\n    slices  = (_cmsWorkSlice*)_cmsCalloc(ContextID, nSlices, sizeof(_cmsWorkSlice));\n    handles = (cmsHANDLE*) _cmsCalloc(ContextID, nSlices, sizeof(cmsHANDLE));\n\n    if (slices == NULL || handles == NULL)\n    {\n        if (slices)  _cmsFree(ContextID, slices);\n        if (handles) _cmsFree(ContextID, handles);\n\n        // Out of memory in this case only can come from a corruption, but we do the work anyway\n        worker(CMMcargo, InputBuffer, OutputBuffer, PixelsPerLine, LineCount, Stride);\n        return;\n    }\n\n    // All seems ok so far\n    if (_cmsThrSplitWork(&master, nSlices, slices))\n    {\n        // Work is split. Create threads\n        cmsUInt32Number i;\n\n        for (i = 1; i < nSlices; i++)\n        {\n            handles[i] = _cmsThrCreateWorker(ContextID, worker, &slices[i]);\n        }\n\n        // Do our portion of work \n        worker(CMMcargo, slices[0].InputBuffer, slices[0].OutputBuffer, \n            slices[0].PixelsPerLine, slices[0].LineCount, slices[0].Stride);\n\n        // Wait until all threads are finished\n        for (i = 1; i < nSlices; i++)\n        {\n            _cmsThrJoinWorker(ContextID, handles[i]);\n        }\n    }\n    else\n    {\n        // Not able to split the work, so don't thread\n        worker(CMMcargo, InputBuffer, OutputBuffer, PixelsPerLine, LineCount, Stride);\n    }\n\n    _cmsFree(ContextID, slices);\n    _cmsFree(ContextID, handles);\n}",
          "fn_code_pos": [
            [
              26,
              0
            ],
            [
              106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsThrScheduler",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "InputBuffer": "void",
              "OutputBuffer": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            26,
            23
          ],
          [
            26,
            50
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"threaded_internal.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/threaded/src/threaded_main.c": {
      "fn_def_list": [
        {
          "fn_code": "void* CMSEXPORT cmsThreadedExtensions(cmsInt32Number max_threads, cmsUInt32Number flags)\n{\n    Plugin.MaxWorkers = max_threads;\n    Plugin.WorkerFlags = flags;\n\n    return (void*)&Plugin;\n}",
          "fn_code_pos": [
            [
              35,
              0
            ],
            [
              41,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsThreadedExtensions",
            "parameters": {
              "max_threads": "cmsInt32Number",
              "flags": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "cmsThreadedExtensions(cmsInt32Number max_threads, cmsUInt32Number flags)",
          "fn_dec_pos": [
            [
              35,
              16
            ],
            [
              35,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsThreadedExtensions",
            "parameters": {
              "max_threads": "cmsInt32Number",
              "flags": "cmsUInt32Number"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"threaded_internal.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/threaded/src/threaded_split.c": {
      "fn_def_list": [
        {
          "fn_code": "cmsINLINE cmsUInt32Number ComponentSize(cmsUInt32Number format)\n{\n    cmsUInt32Number BytesPerComponent = T_BYTES(format);\n\n    // For double, the T_BYTES field is zero\n    if (BytesPerComponent == 0)\n        BytesPerComponent = sizeof(cmsUInt64Number);\n\n    return BytesPerComponent;\n}",
          "fn_code_pos": [
            [
              26,
              0
            ],
            [
              35,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsUInt32Number ComponentSize",
            "parameters": {
              "format": "cmsUInt32Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE cmsUInt32Number PixelSpacing(cmsUInt32Number format)\n{\n    if (T_PLANAR(format))\n        return ComponentSize(format);\n    else\n        return ComponentSize(format) * (T_CHANNELS(format) + T_EXTRA(format));\n}",
          "fn_code_pos": [
            [
              38,
              0
            ],
            [
              44,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsUInt32Number PixelSpacing",
            "parameters": {
              "format": "cmsUInt32Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE cmsUInt32Number minimum(cmsUInt32Number a, cmsUInt32Number b)\n{\n    return a < b ? a : b;\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              50,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsUInt32Number minimum",
            "parameters": {
              "a": "cmsUInt32Number",
              "b": "cmsUInt32Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number MemSize(cmsUInt32Number format, \n                        cmsUInt32Number PixelsPerLine, \n                        cmsUInt32Number LineCount, \n                        cmsUInt32Number* BytesPerLine,\n                        cmsUInt32Number BytesPerPlane)\n{\n    if (T_PLANAR(format)) {\n\n        if (*BytesPerLine == 0) {\n            \n            *BytesPerLine = ComponentSize(format) * PixelsPerLine;\n        }\n\n        return (T_CHANNELS(format) + T_EXTRA(format)) * BytesPerPlane;\n    }\n    else\n    {\n        if (*BytesPerLine == 0) {\n\n            *BytesPerLine = ComponentSize(format) * (T_CHANNELS(format) + T_EXTRA(format)) * PixelsPerLine;\n        }\n\n        return LineCount * *BytesPerLine;\n    }\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MemSize",
            "parameters": {
              "format": "cmsUInt32Number",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "BytesPerLine": "cmsUInt32Number",
              "BytesPerPlane": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number _cmsThrCountSlices(struct _cmstransform_struct* CMMcargo, cmsInt32Number MaxWorkers,\n                                   cmsUInt32Number PixelsPerLine, cmsUInt32Number LineCount, \n                                   cmsStride* Stride)\n{\t    \n    cmsInt32Number MaxInputMem,  MaxOutputMem;\n    cmsInt32Number WorkerCount;\n\n    cmsInt32Number MaxCPUs = _cmsThrIdealThreadCount();\n\n    if (MaxWorkers == CMS_THREADED_GUESS_MAX_THREADS) {\n        MaxWorkers = MaxCPUs;\n    }\n    else\n    {\n        // We allow large number of threads, but this is not going to work well. Warn it. \n        if (MaxWorkers > MaxCPUs) {\n            cmsSignalError(NULL, cmsERROR_RANGE,\n                \"Warning: too many threads for actual processor (CPUs=%d, asked=%d)\", MaxCPUs, MaxWorkers);\n        }\n    }\n\n    MaxInputMem = MemSize(cmsGetTransformInputFormat((cmsHTRANSFORM)CMMcargo),\n                         PixelsPerLine, LineCount, &Stride->BytesPerLineIn, Stride->BytesPerPlaneIn);                         \n\n    MaxOutputMem = MemSize(cmsGetTransformOutputFormat((cmsHTRANSFORM)CMMcargo),\n                         PixelsPerLine, LineCount, &Stride->BytesPerLineOut, Stride->BytesPerPlaneOut);\n    \n    // Each thread takes 128K at least\n    WorkerCount = (MaxInputMem + MaxOutputMem) / (128 * 1024);\n\n    if (WorkerCount < 1)\n        WorkerCount = 1;\n    else\n        if (WorkerCount > MaxWorkers)\n            WorkerCount = MaxWorkers;\n\n    return WorkerCount;\n}",
          "fn_code_pos": [
            [
              85,
              0
            ],
            [
              122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsThrCountSlices",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "MaxWorkers": "cmsInt32Number",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid SlicePerLines(const _cmsWorkSlice* master, cmsInt32Number nslices, \n                            cmsInt32Number LinesPerSlice, _cmsWorkSlice slices[])\n{\n    cmsInt32Number i;\n    cmsInt32Number TotalLines = master ->LineCount;\n\n    for (i = 0; i < nslices; i++) {\n\n        const cmsUInt8Number* PtrInput = master->InputBuffer;\n        cmsUInt8Number* PtrOutput = master->OutputBuffer;\n\n        cmsInt32Number  lines = minimum(LinesPerSlice, TotalLines);\n\n        memcpy(&slices[i], master, sizeof(_cmsWorkSlice));\n\n        slices[i].InputBuffer  = PtrInput + i * LinesPerSlice * master->Stride->BytesPerLineIn;\n        slices[i].OutputBuffer = PtrOutput + i * LinesPerSlice * master->Stride->BytesPerLineOut;\n\n        slices[i].LineCount = lines;\n        TotalLines -= lines;\n    }\n\n    // Add left lines because rounding\n    if (slices > 0) slices[nslices - 1].LineCount += TotalLines;\n}",
          "fn_code_pos": [
            [
              125,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SlicePerLines",
            "parameters": {
              "master": "_cmsWorkSlice",
              "nslices": "cmsInt32Number",
              "LinesPerSlice": "cmsInt32Number",
              "slices": "_cmsWorkSlice"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid SlicePerPixels(const _cmsWorkSlice* master, cmsInt32Number nslices,\n                    cmsInt32Number PixelsPerSlice, _cmsWorkSlice slices[])\n{\n    cmsInt32Number i;\n    cmsInt32Number TotalPixels = master->PixelsPerLine; // As this works on one line only\n\n    cmsUInt32Number PixelSpacingIn = PixelSpacing(cmsGetTransformInputFormat((cmsHTRANSFORM)master->CMMcargo));\n    cmsUInt32Number PixelSpacingOut = PixelSpacing(cmsGetTransformOutputFormat((cmsHTRANSFORM)master->CMMcargo));\n\n    for (i = 0; i < nslices; i++) {\n\n        const cmsUInt8Number* PtrInput = master->InputBuffer;\n        cmsUInt8Number* PtrOutput = master->OutputBuffer;\n\n        cmsInt32Number pixels = minimum(PixelsPerSlice, TotalPixels);\n\n        memcpy(&slices[i], master, sizeof(_cmsWorkSlice));\n\n        slices[i].InputBuffer = PtrInput + i * PixelsPerSlice * PixelSpacingIn;\n        slices[i].OutputBuffer = PtrOutput + i * PixelsPerSlice * PixelSpacingOut;\n        slices[i].PixelsPerLine = pixels;\n\n        TotalPixels -= pixels;\n    }\n\n    // Add left pixels because rounding\n    if (slices > 0) slices[nslices - 1].PixelsPerLine += TotalPixels;\n}",
          "fn_code_pos": [
            [
              153,
              0
            ],
            [
              181,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SlicePerPixels",
            "parameters": {
              "master": "_cmsWorkSlice",
              "nslices": "cmsInt32Number",
              "PixelsPerSlice": "cmsInt32Number",
              "slices": "_cmsWorkSlice"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool _cmsThrSplitWork(const _cmsWorkSlice* master, cmsInt32Number nslices, _cmsWorkSlice slices[])\n{\n    \n    // Check parameters\n    if (master->PixelsPerLine == 0 ||\n        master->Stride->BytesPerLineIn == 0 ||\n        master->Stride->BytesPerLineOut == 0) return FALSE;\n\n    // Do the splitting depending on lines\n    if (master->LineCount <= 1) {\n\n        cmsInt32Number PixelsPerWorker = master->PixelsPerLine / nslices;\n\n        if (PixelsPerWorker <= 0) \n            return FALSE;\n        else\n            SlicePerPixels(master, nslices, PixelsPerWorker, slices);\n    }\n    else {\n        \n        cmsInt32Number LinesPerWorker = master->LineCount / nslices;\n        \n        if (LinesPerWorker <= 0)\n            return FALSE;\n        else\n            SlicePerLines(master, nslices, LinesPerWorker, slices);\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              186,
              0
            ],
            [
              215,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsThrSplitWork",
            "parameters": {
              "master": "_cmsWorkSlice",
              "nslices": "cmsInt32Number",
              "slices": "_cmsWorkSlice"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            85,
            35
          ],
          [
            85,
            62
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"threaded_internal.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/fast_float/src/fast_float_15bits.c": {
      "fn_def_list": [
        {
          "fn_code": "cmsINLINE cmsUInt16Number From16To15(cmsUInt16Number x16)\n{\n       cmsUInt64Number r64 = (((cmsUInt64Number)x16 << 15)) / 0xFFFFL;\n       return (cmsUInt16Number)r64;\n}",
          "fn_code_pos": [
            [
              43,
              0
            ],
            [
              47,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsUInt16Number From16To15",
            "parameters": {
              "x16": "cmsUInt16Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE cmsUInt16Number From15To16(cmsUInt16Number x15)\n{\n       cmsUInt64Number r64 = ((cmsUInt64Number) x15 * 0xFFFF + 0x4000L) >> 15;\n       return (cmsUInt16Number)r64;\n}",
          "fn_code_pos": [
            [
              50,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsUInt16Number From15To16",
            "parameters": {
              "x15": "cmsUInt16Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll15bitsGray(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                 CMSREGISTER cmsUInt16Number Values[],\n                                 CMSREGISTER cmsUInt8Number*  Buffer,\n                                 CMSREGISTER cmsUInt32Number  Stride)\n{\n       UNUSED_PARAMETER(CMMcargo);\n       UNUSED_PARAMETER(Stride);\n\n       Values[0] = From15To16(*(cmsUInt16Number*)Buffer);\n\n       return Buffer + 2;\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              69,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll15bitsGray",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack15bitsGray(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                               CMSREGISTER cmsUInt16Number Values[],\n                               CMSREGISTER cmsUInt8Number*  Buffer,\n                               CMSREGISTER cmsUInt32Number  Stride)\n{\n       UNUSED_PARAMETER(CMMcargo);\n       UNUSED_PARAMETER(Stride);\n\n       *(cmsUInt16Number*)Buffer = From16To15(Values[0]);\n       return Buffer + 2;\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              83,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack15bitsGray",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll15bitsRGB(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                   CMSREGISTER cmsUInt16Number Values[],\n                                   CMSREGISTER cmsUInt8Number*  Buffer,\n                                   CMSREGISTER cmsUInt32Number  Stride)\n{\n       UNUSED_PARAMETER(CMMcargo);\n       UNUSED_PARAMETER(Stride);\n\n       Values[0] = From15To16(*(cmsUInt16Number*)Buffer);\n       Buffer += 2;\n       Values[1] = From15To16(*(cmsUInt16Number*)Buffer);\n       Buffer += 2;\n       Values[2] = From15To16(*(cmsUInt16Number*)Buffer);\n   \n       return Buffer + 2;\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              102,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll15bitsRGB",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack15bitsRGB(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                               CMSREGISTER cmsUInt16Number Values[],\n                               CMSREGISTER cmsUInt8Number*  Buffer,\n                               CMSREGISTER cmsUInt32Number  Stride)\n{\n       UNUSED_PARAMETER(CMMcargo);\n       UNUSED_PARAMETER(Stride);\n\n       *(cmsUInt16Number*)Buffer = From16To15(Values[0]);\n       Buffer += 2;\n       *(cmsUInt16Number*)Buffer = From16To15(Values[1]);\n       Buffer += 2;\n       *(cmsUInt16Number*)Buffer = From16To15(Values[2]);\n\n       return Buffer + 2;\n}",
          "fn_code_pos": [
            [
              105,
              0
            ],
            [
              121,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack15bitsRGB",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll15bitsRGBA(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                   CMSREGISTER cmsUInt16Number Values[],\n                                   CMSREGISTER cmsUInt8Number*  Buffer,\n                                   CMSREGISTER cmsUInt32Number  Stride)\n{\n       UNUSED_PARAMETER(CMMcargo);\n       UNUSED_PARAMETER(Stride);\n\n       Values[0] = From15To16(*(cmsUInt16Number*)Buffer);\n       Buffer += 2;\n       Values[1] = From15To16(*(cmsUInt16Number*)Buffer);\n       Buffer += 2;\n       Values[2] = From15To16(*(cmsUInt16Number*)Buffer);\n   \n       return Buffer + 4;\n}",
          "fn_code_pos": [
            [
              124,
              0
            ],
            [
              140,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll15bitsRGBA",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack15bitsRGBA(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                               CMSREGISTER cmsUInt16Number Values[],\n                               CMSREGISTER cmsUInt8Number*  Buffer,\n                               CMSREGISTER cmsUInt32Number  Stride)\n{\n       UNUSED_PARAMETER(CMMcargo);\n       UNUSED_PARAMETER(Stride);\n\n       *(cmsUInt16Number*)Buffer = From16To15(Values[0]);\n       Buffer += 2;\n       *(cmsUInt16Number*)Buffer = From16To15(Values[1]);\n       Buffer += 2;\n       *(cmsUInt16Number*)Buffer = From16To15(Values[2]);\n\n       return Buffer + 4;\n}",
          "fn_code_pos": [
            [
              143,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack15bitsRGBA",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll15bitsBGR(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                   CMSREGISTER cmsUInt16Number Values[],\n                                   CMSREGISTER cmsUInt8Number*  Buffer,\n                                   CMSREGISTER cmsUInt32Number  Stride)\n{\n       UNUSED_PARAMETER(CMMcargo);\n       UNUSED_PARAMETER(Stride);\n\n       Values[2] = From15To16(*(cmsUInt16Number*)Buffer);\n       Buffer += 2;\n       Values[1] = From15To16(*(cmsUInt16Number*)Buffer);\n       Buffer += 2;\n       Values[0] = From15To16(*(cmsUInt16Number*)Buffer);\n\n       return Buffer + 2;\n}",
          "fn_code_pos": [
            [
              163,
              0
            ],
            [
              179,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll15bitsBGR",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack15bitsBGR(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                   CMSREGISTER cmsUInt16Number Values[],\n                                   CMSREGISTER cmsUInt8Number*  Buffer,\n                                   CMSREGISTER cmsUInt32Number  Stride)\n{\n       UNUSED_PARAMETER(CMMcargo);\n       UNUSED_PARAMETER(Stride);\n\n       *(cmsUInt16Number*)Buffer = From16To15(Values[2]);\n       Buffer += 2;\n       *(cmsUInt16Number*)Buffer = From16To15(Values[1]);\n       Buffer += 2;\n       *(cmsUInt16Number*)Buffer = From16To15(Values[0]);\n\n       return Buffer+2;\n}",
          "fn_code_pos": [
            [
              182,
              0
            ],
            [
              198,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack15bitsBGR",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll15bitsCMYK(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                   CMSREGISTER cmsUInt16Number Values[],\n                                   CMSREGISTER cmsUInt8Number*  Buffer,\n                                   CMSREGISTER cmsUInt32Number  Stride)\n{\n       UNUSED_PARAMETER(CMMcargo);\n       UNUSED_PARAMETER(Stride);\n\n       Values[0] = From15To16(0x8000 - *(cmsUInt16Number*)Buffer);\n       Buffer += 2;\n       Values[1] = From15To16(0x8000 - *(cmsUInt16Number*)Buffer);\n       Buffer += 2;\n       Values[2] = From15To16(0x8000 - *(cmsUInt16Number*)Buffer);\n       Buffer += 2;\n       Values[3] = From15To16(0x8000 - *(cmsUInt16Number*)Buffer);\n\n       return Buffer + 2;\n}",
          "fn_code_pos": [
            [
              201,
              0
            ],
            [
              219,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll15bitsCMYK",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack15bitsCMYK(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                               CMSREGISTER cmsUInt16Number Values[],\n                               CMSREGISTER cmsUInt8Number*  Buffer,\n                               CMSREGISTER cmsUInt32Number  Stride)\n{\n       UNUSED_PARAMETER(CMMcargo);\n       UNUSED_PARAMETER(Stride);\n\n       *(cmsUInt16Number*)Buffer = 0x8000U - From16To15(Values[0]);\n       Buffer += 2;\n       *(cmsUInt16Number*)Buffer = 0x8000U - From16To15(Values[1]);\n       Buffer += 2;\n       *(cmsUInt16Number*)Buffer = 0x8000U - From16To15(Values[2]);\n       Buffer += 2;\n       *(cmsUInt16Number*)Buffer = 0x8000U - From16To15(Values[3]);\n\n       return Buffer + 2;\n}",
          "fn_code_pos": [
            [
              221,
              0
            ],
            [
              239,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack15bitsCMYK",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "cmsINLINE cmsUInt16Number UnrollOne(cmsUInt16Number x, cmsBool Reverse, cmsBool SwapEndian)\n{\n       if (SwapEndian)\n              x = (x << 8) | (x >> 8);\n\n       if (Reverse)\n              x = 0xffff - x;\n\n       return From15To16(x);\n}",
          "fn_code_pos": [
            [
              243,
              0
            ],
            [
              252,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsUInt16Number UnrollOne",
            "parameters": {
              "x": "cmsUInt16Number",
              "Reverse": "cmsBool",
              "SwapEndian": "cmsBool"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE cmsUInt16Number PackOne(cmsUInt16Number x, cmsBool Reverse, cmsBool SwapEndian)\n{\n       x = From16To15(x);\n\n       if (Reverse)\n              x = 0xffff - x;\n\n       if (SwapEndian)\n              x = (x << 8) | (x >> 8);\n\n       return x;\n}",
          "fn_code_pos": [
            [
              254,
              0
            ],
            [
              265,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsUInt16Number PackOne",
            "parameters": {
              "x": "cmsUInt16Number",
              "Reverse": "cmsBool",
              "SwapEndian": "cmsBool"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll15bitsPlanar(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                   CMSREGISTER cmsUInt16Number wIn[],\n                                   CMSREGISTER cmsUInt8Number* accum,\n                                   CMSREGISTER cmsUInt32Number Stride)\n{\n       _xform_head* head = (_xform_head*) CMMcargo;\n       int nChan      = T_CHANNELS(head->InputFormat);\n       int DoSwap     = T_DOSWAP(head->InputFormat);\n       int Reverse    = T_FLAVOR(head->InputFormat);\n       int SwapEndian = T_ENDIAN16(head->InputFormat);\n       int i;\n       cmsUInt8Number* Init = accum;\n\n       UNUSED_PARAMETER(Stride);\n\n       if (DoSwap) {\n              accum += T_EXTRA(head->InputFormat) * Stride * 2;\n       }\n\n       for (i = 0; i < nChan; i++) {\n\n              int index = DoSwap ? (nChan - i - 1) : i;\n        \n              wIn[index] = UnrollOne(*(cmsUInt16Number*)accum, Reverse, SwapEndian);\n\n              accum += Stride * 2;\n       }\n\n       return (Init + 2);\n}",
          "fn_code_pos": [
            [
              268,
              0
            ],
            [
              298,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll15bitsPlanar",
            "parameters": {
              "struct": "CMSREGISTER",
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack15bitsPlanar(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                 CMSREGISTER cmsUInt16Number wOut[],\n                                 CMSREGISTER cmsUInt8Number* output,\n                                 CMSREGISTER cmsUInt32Number Stride)\n{\n       _xform_head* head = (_xform_head*)CMMcargo;\n       int nChan = T_CHANNELS(head->OutputFormat);\n       int DoSwap = T_DOSWAP(head->OutputFormat);\n       int Reverse = T_FLAVOR(head->OutputFormat);\n       int SwapEndian = T_ENDIAN16(head->OutputFormat);\n       CMSREGISTER int i;\n       cmsUInt8Number* Init = output;\n\n\n       if (DoSwap) {\n              output += T_EXTRA(head->OutputFormat) * Stride * 2;\n       }\n\n       for (i = 0; i < nChan; i++) {\n\n              int index = DoSwap ? (nChan - i - 1) : i;\n\n              *(cmsUInt16Number*)output = PackOne(wOut[index], Reverse, SwapEndian);\n              output += (Stride * sizeof(cmsUInt16Number));\n       }\n\n       return (Init + sizeof(cmsUInt16Number));\n}",
          "fn_code_pos": [
            [
              301,
              0
            ],
            [
              329,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack15bitsPlanar",
            "parameters": {
              "struct": "CMSREGISTER",
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll15bitsChunky(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                   CMSREGISTER cmsUInt16Number Values[],\n                                   CMSREGISTER cmsUInt8Number*  Buffer,\n                                   CMSREGISTER cmsUInt32Number  Stride)\n{\n       _xform_head* head = (_xform_head*) CMMcargo;\n\n       int nChan = T_CHANNELS(head->InputFormat);\n       int DoSwap = T_DOSWAP(head->InputFormat);\n       int Reverse = T_FLAVOR(head->InputFormat);\n       int SwapEndian = T_ENDIAN16(head->InputFormat);\n\n\tCMSREGISTER int i;\n\n       UNUSED_PARAMETER(Stride);\n\n       if (DoSwap) {\n              Buffer += T_EXTRA(head->OutputFormat) * 2;\n       }\n\n\tfor (i = 0; i < nChan; i++) {\n\n              int index = DoSwap ? (nChan - i - 1) : i;\n\n              Values[index] = UnrollOne(*(cmsUInt16Number*)Buffer, Reverse, SwapEndian);\n\n              Buffer += 2;\n\t}\n\n\n       return Buffer;\n}",
          "fn_code_pos": [
            [
              334,
              0
            ],
            [
              366,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll15bitsChunky",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack15bitsChunky(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                           CMSREGISTER cmsUInt16Number Values[],\n                           CMSREGISTER cmsUInt8Number*  Buffer,\n                           CMSREGISTER cmsUInt32Number  Stride)\n{\n       _xform_head* head = (_xform_head*)CMMcargo;\n\n       int nChan = T_CHANNELS(head->OutputFormat);\n       int DoSwap = T_DOSWAP(head->OutputFormat);\n       int Reverse = T_FLAVOR(head->OutputFormat);\n       int SwapEndian = T_ENDIAN16(head->OutputFormat);\n\n       CMSREGISTER int i;\n\n       UNUSED_PARAMETER(Stride);\n\n       if (DoSwap) {\n              Buffer += T_EXTRA(head->OutputFormat) * 2;\n       }\n\n       for (i = 0; i < nChan; i++) {\n\n              int index = DoSwap ? (nChan - i - 1) : i;\n  \n              *(cmsUInt16Number*)Buffer = PackOne(Values[index], Reverse, SwapEndian);\n\n              Buffer += 2;\n       }\n\n       return Buffer;\n}",
          "fn_code_pos": [
            [
              369,
              0
            ],
            [
              400,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack15bitsChunky",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number*  PackNBytesDither(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                   CMSREGISTER cmsUInt16Number Values[],\n                                   CMSREGISTER cmsUInt8Number*  Buffer,\n                                   CMSREGISTER cmsUInt32Number  Stride)\n{\n       _xform_head* info = (_xform_head*)CMMcargo;\n\n       int nChan = T_CHANNELS(info->OutputFormat);\n       CMSREGISTER int i;\n       unsigned int n, pe, pf;\n\n       UNUSED_PARAMETER(Stride);\n\n       for (i = 0; i < nChan; i++) {\n\n              n = Values[i] + err[i]; // Value\n\n              pe = (n / 257);       // Whole part\n              pf = (n % 257);       // Fractional part\n\n              err[i] = pf;          // Store it for next pixel\n\n              *Buffer++ = (cmsUInt8Number) pe;\n       }\n\n       return Buffer + T_EXTRA(info->OutputFormat);\n}",
          "fn_code_pos": [
            [
              407,
              0
            ],
            [
              434,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackNBytesDither",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number*  PackNBytesSwapDither(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                          CMSREGISTER cmsUInt16Number Values[],\n                                          CMSREGISTER cmsUInt8Number*  Buffer,\n                                          CMSREGISTER cmsUInt32Number  Stride)\n{\n       _xform_head* info = (_xform_head*)CMMcargo;\n\n       int nChan = T_CHANNELS(info->OutputFormat);\n       CMSREGISTER int i;\n       unsigned int n, pe, pf;\n\n       UNUSED_PARAMETER(Stride);\n\n       for (i = nChan - 1; i >= 0; --i) {\n\n              n = Values[i] + err[i];   // Value\n\n              pe = (n / 257);           // Whole part\n              pf = (n % 257);           // Fractional part\n\n              err[i] = pf;              // Store it for next pixel\n\n              *Buffer++ = (cmsUInt8Number)pe;\n       }\n\n\n       return Buffer + T_EXTRA(info->OutputFormat);\n}",
          "fn_code_pos": [
            [
              437,
              0
            ],
            [
              465,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackNBytesSwapDither",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "CMSCHECKPOINT cmsFormatter CMSEXPORT Formatter_15Bit_Factory(cmsUInt32Number Type,\n                                                             cmsFormatterDirection Dir,\n                                                             cmsUInt32Number dwFlags)\n{\n       cmsFormatter Result = { NULL };\n\n\t   UNUSED_PARAMETER(dwFlags);\n\n       switch (Type) {\n\n       // Simple Gray \n       case TYPE_GRAY_15:\n              Result.Fmt16 = (Dir == cmsFormatterInput) ? Unroll15bitsGray : Pack15bitsGray;\n              break;\n\n       // 3 channels\n       case TYPE_CMY_15:\n       case TYPE_RGB_15:\n              Result.Fmt16 = (Dir == cmsFormatterInput) ? Unroll15bitsRGB : Pack15bitsRGB;\n              break;\n\n       // 3 channels reversed\n       case TYPE_YMC_15:\n       case TYPE_BGR_15:\n              Result.Fmt16 = (Dir == cmsFormatterInput) ? Unroll15bitsBGR : Pack15bitsBGR;\n              break;\n\n       // 3 Channels plus one alpha\n       case TYPE_RGBA_15:\n              Result.Fmt16 = (Dir == cmsFormatterInput) ? Unroll15bitsRGBA : Pack15bitsRGBA;\n              break;\n\n       // 4 channels\n       case TYPE_CMYK_15:\n              Result.Fmt16 = (Dir == cmsFormatterInput) ? Unroll15bitsCMYK : Pack15bitsCMYK;\n              break;\n  \n       // Planar versions\n       case TYPE_GRAYA_15_PLANAR:\n       case TYPE_RGB_15_PLANAR:\n       case TYPE_BGR_15_PLANAR:\n       case TYPE_RGBA_15_PLANAR:\n       case TYPE_ABGR_15_PLANAR:\n       case TYPE_CMY_15_PLANAR:\n       case TYPE_CMYK_15_PLANAR:\n              Result.Fmt16 = (Dir == cmsFormatterInput) ? Unroll15bitsPlanar : Pack15bitsPlanar;\n              break;\n\n       // Fallthrough for remaining (corner) cases\n       case TYPE_GRAY_15_REV:\n       case TYPE_GRAY_15_SE:\n       case TYPE_GRAYA_15:\n       case TYPE_GRAYA_15_SE:\n       case TYPE_RGB_15_SE:\n       case TYPE_BGR_15_SE:\n       case TYPE_RGBA_15_SE:\n       case TYPE_ARGB_15:\n       case TYPE_ABGR_15:\n       case TYPE_ABGR_15_SE:\n       case TYPE_BGRA_15:\n       case TYPE_BGRA_15_SE:\n       case TYPE_CMY_15_SE:      \n       case TYPE_CMYK_15_REV:\n       case TYPE_CMYK_15_SE:\n       case TYPE_KYMC_15:\n       case TYPE_KYMC_15_SE:\n       case TYPE_KCMY_15:\n       case TYPE_KCMY_15_REV:\n       case TYPE_KCMY_15_SE:\n              Result.Fmt16 = (Dir == cmsFormatterInput) ? Unroll15bitsChunky : Pack15bitsChunky;\n              break;\n\n       case TYPE_GRAY_8_DITHER:\n       case TYPE_RGB_8_DITHER:\n       case TYPE_RGBA_8_DITHER:\n       case TYPE_CMYK_8_DITHER: \n              if (Dir == cmsFormatterOutput) {\n                     Result.Fmt16 = PackNBytesDither;\n              }\n              break;\n       \n       case TYPE_ABGR_8_DITHER:\n       case TYPE_BGR_8_DITHER:\n       case TYPE_KYMC_8_DITHER:\n              if (Dir == cmsFormatterOutput) {\n                     Result.Fmt16 = PackNBytesSwapDither;\n              }\n              break;\n\n       default:;\n       }\n\n       return Result;\n}",
          "fn_code_pos": [
            [
              471,
              0
            ],
            [
              564,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Formatter_15Bit_Factory",
            "parameters": {
              "Type": "cmsUInt32Number",
              "Dir": "cmsFormatterDirection",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSCHECKPOINT"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "Unroll15bitsGray(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                 CMSREGISTER cmsUInt16Number Values[],\n                                 CMSREGISTER cmsUInt8Number*  Buffer,\n                                 CMSREGISTER cmsUInt32Number  Stride)",
          "fn_dec_pos": [
            [
              58,
              16
            ],
            [
              61,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll15bitsGray",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack15bitsGray(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                               CMSREGISTER cmsUInt16Number Values[],\n                               CMSREGISTER cmsUInt8Number*  Buffer,\n                               CMSREGISTER cmsUInt32Number  Stride)",
          "fn_dec_pos": [
            [
              73,
              16
            ],
            [
              76,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack15bitsGray",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll15bitsRGB(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                   CMSREGISTER cmsUInt16Number Values[],\n                                   CMSREGISTER cmsUInt8Number*  Buffer,\n                                   CMSREGISTER cmsUInt32Number  Stride)",
          "fn_dec_pos": [
            [
              87,
              16
            ],
            [
              90,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll15bitsRGB",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack15bitsRGB(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                               CMSREGISTER cmsUInt16Number Values[],\n                               CMSREGISTER cmsUInt8Number*  Buffer,\n                               CMSREGISTER cmsUInt32Number  Stride)",
          "fn_dec_pos": [
            [
              106,
              16
            ],
            [
              109,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack15bitsRGB",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll15bitsRGBA(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                   CMSREGISTER cmsUInt16Number Values[],\n                                   CMSREGISTER cmsUInt8Number*  Buffer,\n                                   CMSREGISTER cmsUInt32Number  Stride)",
          "fn_dec_pos": [
            [
              125,
              16
            ],
            [
              128,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll15bitsRGBA",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack15bitsRGBA(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                               CMSREGISTER cmsUInt16Number Values[],\n                               CMSREGISTER cmsUInt8Number*  Buffer,\n                               CMSREGISTER cmsUInt32Number  Stride)",
          "fn_dec_pos": [
            [
              144,
              16
            ],
            [
              147,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack15bitsRGBA",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll15bitsBGR(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                   CMSREGISTER cmsUInt16Number Values[],\n                                   CMSREGISTER cmsUInt8Number*  Buffer,\n                                   CMSREGISTER cmsUInt32Number  Stride)",
          "fn_dec_pos": [
            [
              164,
              16
            ],
            [
              167,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll15bitsBGR",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack15bitsBGR(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                   CMSREGISTER cmsUInt16Number Values[],\n                                   CMSREGISTER cmsUInt8Number*  Buffer,\n                                   CMSREGISTER cmsUInt32Number  Stride)",
          "fn_dec_pos": [
            [
              183,
              16
            ],
            [
              186,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack15bitsBGR",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll15bitsCMYK(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                   CMSREGISTER cmsUInt16Number Values[],\n                                   CMSREGISTER cmsUInt8Number*  Buffer,\n                                   CMSREGISTER cmsUInt32Number  Stride)",
          "fn_dec_pos": [
            [
              202,
              16
            ],
            [
              205,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll15bitsCMYK",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack15bitsCMYK(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                               CMSREGISTER cmsUInt16Number Values[],\n                               CMSREGISTER cmsUInt8Number*  Buffer,\n                               CMSREGISTER cmsUInt32Number  Stride)",
          "fn_dec_pos": [
            [
              222,
              16
            ],
            [
              225,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack15bitsCMYK",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll15bitsPlanar(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                   CMSREGISTER cmsUInt16Number wIn[],\n                                   CMSREGISTER cmsUInt8Number* accum,\n                                   CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              269,
              16
            ],
            [
              272,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll15bitsPlanar",
            "parameters": {
              "struct": "CMSREGISTER",
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack15bitsPlanar(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                 CMSREGISTER cmsUInt16Number wOut[],\n                                 CMSREGISTER cmsUInt8Number* output,\n                                 CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              302,
              16
            ],
            [
              305,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack15bitsPlanar",
            "parameters": {
              "struct": "CMSREGISTER",
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll15bitsChunky(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                   CMSREGISTER cmsUInt16Number Values[],\n                                   CMSREGISTER cmsUInt8Number*  Buffer,\n                                   CMSREGISTER cmsUInt32Number  Stride)",
          "fn_dec_pos": [
            [
              335,
              16
            ],
            [
              338,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll15bitsChunky",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack15bitsChunky(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                           CMSREGISTER cmsUInt16Number Values[],\n                           CMSREGISTER cmsUInt8Number*  Buffer,\n                           CMSREGISTER cmsUInt32Number  Stride)",
          "fn_dec_pos": [
            [
              370,
              16
            ],
            [
              373,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack15bitsChunky",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackNBytesDither(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                   CMSREGISTER cmsUInt16Number Values[],\n                                   CMSREGISTER cmsUInt8Number*  Buffer,\n                                   CMSREGISTER cmsUInt32Number  Stride)",
          "fn_dec_pos": [
            [
              408,
              17
            ],
            [
              411,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackNBytesDither",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackNBytesSwapDither(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                          CMSREGISTER cmsUInt16Number Values[],\n                                          CMSREGISTER cmsUInt8Number*  Buffer,\n                                          CMSREGISTER cmsUInt32Number  Stride)",
          "fn_dec_pos": [
            [
              438,
              17
            ],
            [
              441,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackNBytesSwapDither",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"fast_float_internal.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/fast_float/src/fast_float_15mats.c": {
      "fn_def_list": [
        {
          "fn_code": "static XMatShaperData* malloc_aligned(cmsContext ContextID)\n{\n       cmsUInt8Number* real_ptr = (cmsUInt8Number*)_cmsMallocZero(ContextID, sizeof(XMatShaperData) + 32);\n       cmsUInt8Number* aligned = (cmsUInt8Number*)(((uintptr_t)real_ptr + 16) & ~0xf);\n       XMatShaperData* p = (XMatShaperData*)aligned;\n\n       p->real_ptr = real_ptr;\n       p->ContextID = ContextID;\n       return p;\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              71,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "malloc_aligned",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "XMatShaperData"
          }
        },
        {
          "fn_code": "static\nvoid  FreeMatShaper(cmsContext ContextID, void* Data)\n{\n\n       XMatShaperData* p = (XMatShaperData*)Data;\n       if (p != NULL)\n              _cmsFree(ContextID, p->real_ptr);\t\n}",
          "fn_code_pos": [
            [
              75,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FreeMatShaper",
            "parameters": {
              "ContextID": "cmsContext",
              "Data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid FillShaper(cmsUInt16Number* Table, cmsToneCurve* Curve)\n{\n       int i;\n       cmsFloat32Number R, y;\n\n       for (i = 0; i < MAX_NODES_IN_CURVE; i++) {\n\n              R = (cmsFloat32Number)i / (cmsFloat32Number) (MAX_NODES_IN_CURVE - 1);\n              y = cmsEvalToneCurveFloat(Curve, R);\n\n              Table[i] = (cmsUInt16Number) DOUBLE_TO_1FIXED15(y);\n       }\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              99,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FillShaper",
            "parameters": {
              "Table": "cmsUInt16Number",
              "Curve": "cmsToneCurve"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nXMatShaperData* SetMatShaper(cmsContext ContextID, cmsToneCurve* Curve1[3], cmsMAT3* Mat, cmsVEC3* Off, cmsToneCurve* Curve2[3], cmsBool IdentityMat)\n{\n       XMatShaperData* p;\n       int i, j;\n\n       // Allocate a big chuck of memory to store precomputed tables\n       p = malloc_aligned(ContextID);\n       if (p == NULL) return FALSE;\n\n       p->ContextID = ContextID;\n\n       p->IdentityMat = IdentityMat;\n      \n       // Precompute tables\n       FillShaper(p->Shaper1R, Curve1[0]);\n       FillShaper(p->Shaper1G, Curve1[1]);\n       FillShaper(p->Shaper1B, Curve1[2]);\n\n       FillShaper(p->Shaper2R, Curve2[0]);\n       FillShaper(p->Shaper2G, Curve2[1]);\n       FillShaper(p->Shaper2B, Curve2[2]);\n\n       // Convert matrix to nFixed14. Note that those values may take more than 16 bits if negative\n       for (i = 0; i < 3; i++) {\n              for (j = 0; j < 3; j++) {\n\n                     p->Mat[i][j] = DOUBLE_TO_1FIXED15(Mat->v[i].n[j]);\n              }\n       }\n\n\n       for (i = 0; i < 3; i++) {\n\n              if (Off == NULL) {\n\n                     p->Off[i] = 0x4000;\n\n              }\n              else {\n                     p->Off[i] = DOUBLE_TO_1FIXED15(Off->n[i]) + 0x4000;\n\n              }\n       }\n\n\n       return p;\n}",
          "fn_code_pos": [
            [
              103,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetMatShaper",
            "parameters": {
              "ContextID": "cmsContext",
              "Curve1": "cmsToneCurve",
              "Mat": "cmsMAT3",
              "Off": "cmsVEC3",
              "Curve2": "cmsToneCurve",
              "IdentityMat": "cmsBool"
            },
            "return_type": "XMatShaperData"
          }
        },
        {
          "fn_code": "static\nvoid MatShaperXform(struct _cmstransform_struct *CMMcargo,\n                    const void* Input,\n                    void* Output,\n                    cmsUInt32Number PixelsPerLine,\n                    cmsUInt32Number LineCount,\n                    const cmsStride* Stride)\n{\n       XMatShaperData* p = (XMatShaperData*)_cmsGetTransformUserData(CMMcargo);\n\n       cmsS1Fixed15Number l1, l2, l3;\n\n       cmsS1Fixed15Number r, g, b;\n       cmsUInt32Number ri, gi, bi;\n       cmsUInt32Number i, ii;\n       cmsUInt32Number SourceStartingOrder[cmsMAXCHANNELS];\n       cmsUInt32Number SourceIncrements[cmsMAXCHANNELS];\n       cmsUInt32Number DestStartingOrder[cmsMAXCHANNELS];\n       cmsUInt32Number DestIncrements[cmsMAXCHANNELS];\n\n       const cmsUInt8Number* rin;\n       const cmsUInt8Number* gin;\n       const cmsUInt8Number* bin;\n       const cmsUInt8Number* ain = NULL;\n\n       cmsUInt8Number* rout;\n       cmsUInt8Number* gout;\n       cmsUInt8Number* bout;\n       cmsUInt8Number* aout = NULL;\n\n       cmsUInt32Number nalpha;\n       size_t strideIn, strideOut;\n\n       _cmsComputeComponentIncrements(cmsGetTransformInputFormat((cmsHTRANSFORM)CMMcargo), Stride->BytesPerPlaneIn, NULL, &nalpha, SourceStartingOrder, SourceIncrements);\n       _cmsComputeComponentIncrements(cmsGetTransformOutputFormat((cmsHTRANSFORM)CMMcargo), Stride->BytesPerPlaneOut, NULL, &nalpha, DestStartingOrder, DestIncrements);\n\n       if (!(_cmsGetTransformFlags((cmsHTRANSFORM)CMMcargo) & cmsFLAGS_COPY_ALPHA))\n           nalpha = 0;\n\n       strideIn = strideOut = 0;\n       for (i = 0; i < LineCount; i++) {\n\n              rin = (const cmsUInt8Number*)Input + SourceStartingOrder[0] + strideIn;\n              gin = (const cmsUInt8Number*)Input + SourceStartingOrder[1] + strideIn;\n              bin = (const cmsUInt8Number*)Input + SourceStartingOrder[2] + strideIn;\n              if (nalpha)\n                     ain = (const cmsUInt8Number*)Input + SourceStartingOrder[3] + strideIn;\n\n\n              rout = (cmsUInt8Number*)Output + DestStartingOrder[0] + strideOut;\n              gout = (cmsUInt8Number*)Output + DestStartingOrder[1] + strideOut;\n              bout = (cmsUInt8Number*)Output + DestStartingOrder[2] + strideOut;\n              if (nalpha)\n                     aout = (cmsUInt8Number*)Output + DestStartingOrder[3] + strideOut;\n\n\n              for (ii = 0; ii < PixelsPerLine; ii++) {\n\n                     // Across first shaper, which also converts to 1.15 fixed point. \n                     r = p->Shaper1R[*(cmsUInt16Number*)rin];\n                     g = p->Shaper1G[*(cmsUInt16Number*)gin];\n                     b = p->Shaper1B[*(cmsUInt16Number*)bin];\n\n                     if (p->IdentityMat)\n                     {\n                            l1 = r; l2 = g; l3 = b;\n                     }\n                     else\n                     {\n                            // Evaluate the matrix in 1.14 fixed point\n                            l1 = (p->Mat[0][0] * r + p->Mat[0][1] * g + p->Mat[0][2] * b + p->Off[0]) >> 15;\n                            l2 = (p->Mat[1][0] * r + p->Mat[1][1] * g + p->Mat[1][2] * b + p->Off[1]) >> 15;\n                            l3 = (p->Mat[2][0] * r + p->Mat[2][1] * g + p->Mat[2][2] * b + p->Off[2]) >> 15;\n                     }\n\n                     // Now we have to clip to 0..1.0 range \n                     ri = (l1 < 0) ? 0 : ((l1 > 0x8000) ? 0x8000 : l1);\n                     gi = (l2 < 0) ? 0 : ((l2 > 0x8000) ? 0x8000 : l2);\n                     bi = (l3 < 0) ? 0 : ((l3 > 0x8000) ? 0x8000 : l3);\n\n\n                     // And across second shaper, \n                     *(cmsUInt16Number*)rout = p->Shaper2R[ri];\n                     *(cmsUInt16Number*)gout = p->Shaper2G[gi];\n                     *(cmsUInt16Number*)bout = p->Shaper2B[bi];\n\n\n                     // Handle alpha\n                     if (ain) {\n                            memmove(aout, ain, 2);                            \n                     }\n\n                     rin += SourceIncrements[0];\n                     gin += SourceIncrements[1];\n                     bin += SourceIncrements[2];\n                     if (ain) ain += SourceIncrements[3];\n\n                     rout += DestIncrements[0];\n                     gout += DestIncrements[1];\n                     bout += DestIncrements[2];\n                     if (aout) aout += DestIncrements[3];\n              }\n\n              strideIn += Stride->BytesPerLineIn;\n              strideOut += Stride->BytesPerLineOut;\n       }\n}",
          "fn_code_pos": [
            [
              153,
              0
            ],
            [
              259,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MatShaperXform",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "Input": "void",
              "Output": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool OptimizeMatrixShaper15(_cmsTransform2Fn* TransformFn,\n                                   void** UserData,\n                                   _cmsFreeUserDataFn* FreeUserData,\n                                   cmsPipeline** Lut,\n                                   cmsUInt32Number* InputFormat,\n                                   cmsUInt32Number* OutputFormat,\n                                   cmsUInt32Number* dwFlags)\n{\n       cmsStage* Curve1, *Curve2;\n       cmsStage* Matrix1, *Matrix2;\n       _cmsStageMatrixData* Data1;\n       _cmsStageMatrixData* Data2;\n       cmsMAT3 res;\n       cmsBool IdentityMat = FALSE;\n       cmsPipeline* Dest, *Src;\n       cmsContext ContextID;\n       cmsUInt32Number nChans;\n       \n       // Only works on RGB to RGB and gray\n\n       if (!(T_CHANNELS(*InputFormat) == 3 && T_CHANNELS(*OutputFormat) == 3)) return FALSE;\n\n       // Only works on 15 bit to 15 bit\n       if (T_BYTES(*InputFormat) != 2 || T_BYTES(*OutputFormat) != 2 || \n              T_BIT15(*InputFormat) == 0 || T_BIT15(*OutputFormat) == 0) return FALSE;\n\n       // Seems suitable, proceed\n       Src = *Lut;\n\n       // Check for shaper-matrix-matrix-shaper structure, that is what this optimizer stands for\n       if (!cmsPipelineCheckAndRetreiveStages(Src, 4,\n              cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType,\n              &Curve1, &Matrix1, &Matrix2, &Curve2)) return FALSE;\n\n       ContextID = cmsGetPipelineContextID(Src);\n       nChans = T_CHANNELS(*InputFormat);\n\n       // Get both matrices, which are 3x3\n       Data1 = (_cmsStageMatrixData*)cmsStageData(Matrix1);\n       Data2 = (_cmsStageMatrixData*)cmsStageData(Matrix2);\n\n       // Input offset should be zero\n       if (Data1->Offset != NULL) return FALSE;\n\n       // Multiply both matrices to get the result\n       _cmsMAT3per(&res, (cmsMAT3*)Data2->Double, (cmsMAT3*)Data1->Double);\n\n       // Now the result is in res + Data2 -> Offset. Maybe is a plain identity?\n       IdentityMat = FALSE;\n       if (_cmsMAT3isIdentity(&res) && Data2->Offset == NULL) {\n\n              // We can get rid of full matrix\n              IdentityMat = TRUE;\n       }\n\n\n       // Allocate an empty LUT \n       Dest = cmsPipelineAlloc(ContextID, nChans, nChans);\n       if (!Dest) return FALSE;\n\n       // Assamble the new LUT\n       cmsPipelineInsertStage(Dest, cmsAT_BEGIN, cmsStageDup(Curve1));\n\n       if (!IdentityMat) {\n\n              cmsPipelineInsertStage(Dest, cmsAT_END,\n                     cmsStageAllocMatrix(ContextID, 3, 3, (const cmsFloat64Number*)&res, Data2->Offset));\n       }\n\n       cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageDup(Curve2));\n       \n       {\n              _cmsStageToneCurvesData* mpeC1 = (_cmsStageToneCurvesData*)cmsStageData(Curve1);\n              _cmsStageToneCurvesData* mpeC2 = (_cmsStageToneCurvesData*)cmsStageData(Curve2);\n\n              // In this particular optimization, cache does not help as it takes more time to deal with \n              // the cache than with the pixel handling\n              *dwFlags |= cmsFLAGS_NOCACHE;\n\n              // Setup the optimizarion routines\n              *UserData = SetMatShaper(ContextID, mpeC1->TheCurves, &res, (cmsVEC3*)Data2->Offset, mpeC2->TheCurves, IdentityMat);\n              *FreeUserData = FreeMatShaper;\n\n              *TransformFn = MatShaperXform;\n       }\n       \n\n       cmsPipelineFree(Src);\n       *dwFlags &= ~cmsFLAGS_CAN_CHANGE_FORMATTER;\n       *Lut = Dest;\n       return TRUE;\n}",
          "fn_code_pos": [
            [
              264,
              0
            ],
            [
              355,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OptimizeMatrixShaper15",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeUserData": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "malloc_aligned(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              62,
              23
            ],
            [
              62,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "malloc_aligned",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "SetMatShaper(cmsContext ContextID, cmsToneCurve* Curve1[3], cmsMAT3* Mat, cmsVEC3* Off, cmsToneCurve* Curve2[3], cmsBool IdentityMat)",
          "fn_dec_pos": [
            [
              104,
              16
            ],
            [
              104,
              149
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetMatShaper",
            "parameters": {
              "ContextID": "cmsContext",
              "Curve1": "cmsToneCurve",
              "Mat": "cmsMAT3",
              "Off": "cmsVEC3",
              "Curve2": "cmsToneCurve",
              "IdentityMat": "cmsBool"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\n       cmsS1Fixed15Number Mat[3][3];\n       cmsS1Fixed15Number Off[3];\n       \n       // Precalculated tables for first shaper (375 Kb in total of both shapers)\n       cmsUInt16Number Shaper1R[MAX_NODES_IN_CURVE];\n       cmsUInt16Number Shaper1G[MAX_NODES_IN_CURVE];\n       cmsUInt16Number Shaper1B[MAX_NODES_IN_CURVE];\n\n       // Second shaper\n       cmsUInt16Number Shaper2R[MAX_NODES_IN_CURVE];\n       cmsUInt16Number Shaper2G[MAX_NODES_IN_CURVE];\n       cmsUInt16Number Shaper2B[MAX_NODES_IN_CURVE];\n\n       // A flag for fast operation if identity\n       cmsBool IdentityMat;\n\n       // The context\n       cmsContext ContextID;\n\n       // Points to the raw, unaligned memory\n       void * real_ptr;\n\n\n} XMatShaperData;",
          {
            "Mat[3][3]": "cmsS1Fixed15Number",
            "Off[3]": "cmsS1Fixed15Number",
            "Shaper1R[MAX_NODES_IN_CURVE]": "cmsUInt16Number",
            "Shaper1G[MAX_NODES_IN_CURVE]": "cmsUInt16Number",
            "Shaper1B[MAX_NODES_IN_CURVE]": "cmsUInt16Number",
            "Shaper2R[MAX_NODES_IN_CURVE]": "cmsUInt16Number",
            "Shaper2G[MAX_NODES_IN_CURVE]": "cmsUInt16Number",
            "Shaper2B[MAX_NODES_IN_CURVE]": "cmsUInt16Number",
            "IdentityMat": "cmsBool",
            "ContextID": "cmsContext",
            "* real_ptr": "void"
          },
          "XMatShaperData",
          [
            33,
            0
          ],
          [
            58,
            17
          ]
        ],
        [
          "typedef struct {\n\n       cmsS1Fixed15Number Mat[3][3];\n       cmsS1Fixed15Number Off[3];\n       \n       // Precalculated tables for first shaper (375 Kb in total of both shapers)\n       cmsUInt16Number Shaper1R[MAX_NODES_IN_CURVE];\n       cmsUInt16Number Shaper1G[MAX_NODES_IN_CURVE];\n       cmsUInt16Number Shaper1B[MAX_NODES_IN_CURVE];\n\n       // Second shaper\n       cmsUInt16Number Shaper2R[MAX_NODES_IN_CURVE];\n       cmsUInt16Number Shaper2G[MAX_NODES_IN_CURVE];\n       cmsUInt16Number Shaper2B[MAX_NODES_IN_CURVE];\n\n       // A flag for fast operation if identity\n       cmsBool IdentityMat;\n\n       // The context\n       cmsContext ContextID;\n\n       // Points to the raw, unaligned memory\n       void * real_ptr;\n\n\n} XMatShaperData;",
          {
            "Mat[3][3]": "cmsS1Fixed15Number",
            "Off[3]": "cmsS1Fixed15Number",
            "Shaper1R[MAX_NODES_IN_CURVE]": "cmsUInt16Number",
            "Shaper1G[MAX_NODES_IN_CURVE]": "cmsUInt16Number",
            "Shaper1B[MAX_NODES_IN_CURVE]": "cmsUInt16Number",
            "Shaper2R[MAX_NODES_IN_CURVE]": "cmsUInt16Number",
            "Shaper2G[MAX_NODES_IN_CURVE]": "cmsUInt16Number",
            "Shaper2B[MAX_NODES_IN_CURVE]": "cmsUInt16Number",
            "IdentityMat": "cmsBool",
            "ContextID": "cmsContext",
            "* real_ptr": "void"
          },
          "XMatShaperData",
          [
            33,
            0
          ],
          [
            58,
            17
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            154,
            20
          ],
          [
            154,
            47
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"fast_float_internal.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/fast_float/src/fast_float_sup.c": {
      "fn_def_list": [
        {
          "fn_code": "static\ncmsBool Floating_Point_Transforms_Dispatcher(_cmsTransform2Fn* TransformFn,\n                                  void** UserData,\n                                  _cmsFreeUserDataFn* FreeUserData,\n                                  cmsPipeline** Lut, \n                                  cmsUInt32Number* InputFormat, \n                                  cmsUInt32Number* OutputFormat, \n                                  cmsUInt32Number* dwFlags) \n{\n    // Softproofing & gamut check does not use plugin, both are activated via following flag.\n    if (*dwFlags & cmsFLAGS_SOFTPROOFING) return FALSE;\n\n    // Special flags for reversing are not supported\n    if (T_FLAVOR(*InputFormat) || T_FLAVOR(*OutputFormat)) return FALSE;\n\n    // Check consistency for alpha channel copy\n    if (*dwFlags & cmsFLAGS_COPY_ALPHA)\n    {\n        if ((T_EXTRA(*InputFormat) != T_EXTRA(*OutputFormat))) return FALSE;\n        if (T_PREMUL(*InputFormat) || T_PREMUL(*OutputFormat)) return FALSE;\n    }\n\n    // Try to optimize as a set of curves plus a matrix plus a set of curves\n    if (OptimizeMatrixShaper15(TransformFn, UserData, FreeUserData, Lut, InputFormat, OutputFormat, dwFlags)) return TRUE;\n\n    // Try to optimize by joining curves\n    if (Optimize8ByJoiningCurves(TransformFn, UserData, FreeUserData, Lut, InputFormat, OutputFormat, dwFlags)) return TRUE;\n\n#ifndef CMS_DONT_USE_SSE2\n    // Try to use SSE2 to optimize as a set of curves plus a matrix plus a set of curves\n    if (Optimize8MatrixShaperSSE(TransformFn, UserData, FreeUserData, Lut, InputFormat, OutputFormat, dwFlags)) return TRUE;\n#endif\n    // Try to optimize as a set of curves plus a matrix plus a set of curves\n    if (Optimize8MatrixShaper(TransformFn, UserData, FreeUserData, Lut, InputFormat, OutputFormat, dwFlags)) return TRUE;\n\n    // Try to optimize by joining curves\n    if (OptimizeFloatByJoiningCurves(TransformFn, UserData, FreeUserData, Lut, InputFormat, OutputFormat, dwFlags)) return TRUE;\n\n    // Try to optimize as a set of curves plus a matrix plus a set of curves\n    if (OptimizeFloatMatrixShaper(TransformFn, UserData, FreeUserData, Lut, InputFormat, OutputFormat, dwFlags)) return TRUE;\n\n    // Try to optimize using prelinearization plus tetrahedral\n    if (Optimize8BitRGBTransform(TransformFn, UserData, FreeUserData, Lut, InputFormat, OutputFormat, dwFlags)) return TRUE;\n\n    // Try to optimize using prelinearization plus tetrahedral\n    if (Optimize16BitRGBTransform(TransformFn, UserData, FreeUserData, Lut, InputFormat, OutputFormat, dwFlags)) return TRUE;\n\n    // Try to optimize using prelinearization plus tetrahedral\n    if (OptimizeCLUTRGBTransform(TransformFn, UserData, FreeUserData, Lut, InputFormat, OutputFormat, dwFlags)) return TRUE;\n\n    // Try to optimize using prelinearization plus tetrahedral\n    if (OptimizeCLUTCMYKTransform(TransformFn, UserData, FreeUserData, Lut, InputFormat, OutputFormat, dwFlags)) return TRUE;\n\n    // Try to optimize for Lab float as input\n    if (OptimizeCLUTLabTransform(TransformFn, UserData, FreeUserData, Lut, InputFormat, OutputFormat, dwFlags)) return TRUE;\n\n    // Cannot optimize, use lcms normal process \n    return FALSE;\n}",
          "fn_code_pos": [
            [
              25,
              0
            ],
            [
              83,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Floating_Point_Transforms_Dispatcher",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeUserData": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "void* CMSEXPORT cmsFastFloatExtensions(void)\n{\n       return (void*)&PluginList;\n}",
          "fn_code_pos": [
            [
              104,
              0
            ],
            [
              107,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFastFloatExtensions",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "cmsFastFloatExtensions(void)",
          "fn_dec_pos": [
            [
              104,
              16
            ],
            [
              104,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFastFloatExtensions",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"fast_float_internal.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/fast_float/src/fast_float_lab.c": {
      "fn_def_list": [
        {
          "fn_code": "cmsINLINE cmsFloat32Number LinLerp1D(cmsFloat32Number Value, const cmsFloat32Number* LutTable)\n{\n    if (Value >= 1.0f)\n    {\n        return LutTable[SIGMOID_POINTS - 1];\n    }\n    else\n        if (Value <= 0)\n        {\n            return LutTable[0];\n        }\n        else\n        {\n            cmsFloat32Number y1, y0;\n            cmsFloat32Number rest;\n            int cell0, cell1;\n\n            Value *= (SIGMOID_POINTS - 1);\n\n            cell0 = _cmsQuickFloor(Value);\n            cell1 = cell0 + 1;\n\n            rest = Value - cell0;\n\n            y0 = LutTable[cell0];\n            y1 = LutTable[cell1];\n\n            return y0 + (y1 - y0) * rest;\n        }\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              81,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFloat32Number LinLerp1D",
            "parameters": {
              "Value": "cmsFloat32Number",
              "LutTable": "cmsFloat32Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "static\nvoid tabulateSigmoid(cmsContext ContextID, cmsInt32Number type, cmsFloat32Number table[], cmsInt32Number tablePoints)\n{\n    const cmsFloat64Number sigmoidal_slope = 2.5;\n    cmsToneCurve* original;\n    cmsInt32Number i;\n    \n    memset(table, 0, sizeof(cmsFloat32Number) * tablePoints);\n    original = cmsBuildParametricToneCurve(ContextID, type, &sigmoidal_slope);\n    if (original != NULL)\n    {\n        for (i = 0; i < tablePoints; i++)\n        {\n            cmsFloat32Number v = (cmsFloat32Number)i / (cmsFloat32Number)(tablePoints - 1);\n\n            table[i] = fclamp(cmsEvalToneCurveFloat(original, v));\n        }\n     \n        cmsFreeToneCurve(original);\n    }\n}",
          "fn_code_pos": [
            [
              83,
              0
            ],
            [
              103,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tabulateSigmoid",
            "parameters": {
              "ContextID": "cmsContext",
              "type": "cmsInt32Number",
              "table": "cmsFloat32Number",
              "tablePoints": "cmsInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nLabCLUTdata* LabCLUTAlloc(cmsContext ContextID, const cmsInterpParams* p)\n{\n    LabCLUTdata* fd;\n    \n    fd = (LabCLUTdata*) _cmsMallocZero(ContextID, sizeof(LabCLUTdata));\n    if (fd == NULL) return NULL;\n    \n    fd ->ContextID = ContextID;\n    fd ->p = p;\n    \n    tabulateSigmoid(ContextID, +TYPE_SIGMOID, fd->sigmoidIn, SIGMOID_POINTS);     \n    tabulateSigmoid(ContextID, -TYPE_SIGMOID, fd->sigmoidOut, SIGMOID_POINTS);    \n\n    return fd;\n}",
          "fn_code_pos": [
            [
              107,
              0
            ],
            [
              122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LabCLUTAlloc",
            "parameters": {
              "ContextID": "cmsContext",
              "p": "cmsInterpParams"
            },
            "return_type": "LabCLUTdata"
          }
        },
        {
          "fn_code": "static\nvoid LabCLUTFree(cmsContext ContextID, void* v)\n{    \n    _cmsFree(ContextID, v);\n}",
          "fn_code_pos": [
            [
              124,
              0
            ],
            [
              128,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LabCLUTFree",
            "parameters": {
              "ContextID": "cmsContext",
              "v": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nint XFormSampler(CMSREGISTER const cmsFloat32Number In[], CMSREGISTER cmsFloat32Number Out[], CMSREGISTER void* Cargo)\n{\n    ResamplingContainer* container = (ResamplingContainer*)Cargo;\n    cmsFloat32Number linearized[3];\n\n    // Apply inverse sigmoid\n    linearized[0] = In[0];\n    linearized[1] = LinLerp1D(In[1], container->data->sigmoidOut);\n    linearized[2] = LinLerp1D(In[2], container->data->sigmoidOut);\n\n    cmsPipelineEvalFloat(linearized, Out, container->original);    \n    return TRUE;\n}",
          "fn_code_pos": [
            [
              131,
              0
            ],
            [
              144,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "XFormSampler",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "cmsINLINE cmsFloat32Number fclamp128(cmsFloat32Number v)\n{\n    return ((v < -128) || isnan(v)) ? -128.0f : (v > 128.0f ? 128.0f : v);\n}",
          "fn_code_pos": [
            [
              148,
              0
            ],
            [
              151,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFloat32Number fclamp128",
            "parameters": {
              "v": "cmsFloat32Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE cmsFloat32Number fclamp100(cmsFloat32Number v)\n{\n    return ((v < 1.0e-9f) || isnan(v)) ? 0.0f : (v > 100.0f ? 100.0f : v);\n}",
          "fn_code_pos": [
            [
              153,
              0
            ],
            [
              156,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFloat32Number fclamp100",
            "parameters": {
              "v": "cmsFloat32Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "static\nvoid LabCLUTEval(struct _cmstransform_struct* CMMcargo,\n                        const void* Input,\n                        void* Output,\n                        cmsUInt32Number PixelsPerLine,\n                        cmsUInt32Number LineCount,\n                        const cmsStride* Stride)\n\n{\n\n    LabCLUTdata* pfloat = (LabCLUTdata*)_cmsGetTransformUserData(CMMcargo);\n\n    cmsFloat32Number        l, a, b;\n    cmsFloat32Number        px, py, pz;\n    int                     x0, y0, z0;\n    int                     X0, Y0, Z0, X1, Y1, Z1;\n    cmsFloat32Number        rx, ry, rz;\n    cmsFloat32Number        c0, c1 = 0, c2 = 0, c3 = 0;\n    cmsUInt32Number         OutChan;\n\n    const cmsInterpParams* p = pfloat->p;\n    cmsUInt32Number        TotalOut = p->nOutputs;\n    cmsUInt32Number        TotalPlusAlpha;\n    const cmsFloat32Number* LutTable = (const cmsFloat32Number*)p->Table;\n\n    cmsUInt32Number       i, ii;\n    const cmsUInt8Number* lin;\n    const cmsUInt8Number* ain;\n    const cmsUInt8Number* bin;\n    const cmsUInt8Number* xin = NULL;\n\n    cmsUInt8Number* out[cmsMAXCHANNELS];\n    cmsUInt32Number SourceStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number SourceIncrements[cmsMAXCHANNELS];\n    cmsUInt32Number DestStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number DestIncrements[cmsMAXCHANNELS];\n\n    cmsUInt32Number InputFormat = cmsGetTransformInputFormat((cmsHTRANSFORM)CMMcargo);\n    cmsUInt32Number OutputFormat = cmsGetTransformOutputFormat((cmsHTRANSFORM)CMMcargo);\n\n    cmsUInt32Number nchans, nalpha;\n    size_t strideIn, strideOut;\n                                                        \n    _cmsComputeComponentIncrements(InputFormat, Stride->BytesPerPlaneIn, &nchans, &nalpha, SourceStartingOrder, SourceIncrements);\n    _cmsComputeComponentIncrements(OutputFormat, Stride->BytesPerPlaneOut, &nchans, &nalpha, DestStartingOrder, DestIncrements);\n\n    if (!(_cmsGetTransformFlags((cmsHTRANSFORM)CMMcargo) & cmsFLAGS_COPY_ALPHA))\n        nalpha = 0;\n\n    strideIn = strideOut = 0;\n    for (i = 0; i < LineCount; i++) {\n\n        lin = (const cmsUInt8Number*)Input + SourceStartingOrder[0] + strideIn;\n        ain = (const cmsUInt8Number*)Input + SourceStartingOrder[1] + strideIn;\n        bin = (const cmsUInt8Number*)Input + SourceStartingOrder[2] + strideIn;\n\n        if (nalpha)\n            xin = (const cmsUInt8Number*)Input + SourceStartingOrder[3] + strideIn;\n\n        TotalPlusAlpha = TotalOut;\n        if (xin) TotalPlusAlpha++;\n\n        for (ii = 0; ii < TotalPlusAlpha; ii++)\n            out[ii] = (cmsUInt8Number*)Output + DestStartingOrder[ii] + strideOut;\n\n        for (ii = 0; ii < PixelsPerLine; ii++) {\n\n            // Decode Lab and go across sigmoids on a*/b*\n            l = fclamp100( *(cmsFloat32Number*)lin ) / 100.0f;\n\n            a = LinLerp1D((( fclamp128( *(cmsFloat32Number*)ain)) + 128.0f) / 255.0f, pfloat->sigmoidIn);\n            b = LinLerp1D((( fclamp128( *(cmsFloat32Number*)bin)) + 128.0f) / 255.0f, pfloat->sigmoidIn);\n\n            lin += SourceIncrements[0];\n            ain += SourceIncrements[1];\n            bin += SourceIncrements[2];\n\n            px = l * p->Domain[0];\n            py = a * p->Domain[1];\n            pz = b * p->Domain[2];\n            \n            x0 = _cmsQuickFloor(px); rx = (px - (cmsFloat32Number)x0);\n            y0 = _cmsQuickFloor(py); ry = (py - (cmsFloat32Number)y0);\n            z0 = _cmsQuickFloor(pz); rz = (pz - (cmsFloat32Number)z0);\n            \n            X0 = p->opta[2] * x0;\n            X1 = X0 + (l >= 1.0f ? 0 : p->opta[2]);\n\n            Y0 = p->opta[1] * y0;\n            Y1 = Y0 + (a >= 1.0f ? 0 : p->opta[1]);\n\n            Z0 = p->opta[0] * z0;\n            Z1 = Z0 + (b >= 1.0f ? 0 : p->opta[0]);\n\n            for (OutChan = 0; OutChan < TotalOut; OutChan++) {\n\n                // These are the 6 Tetrahedral\n\n                c0 = DENS(X0, Y0, Z0);\n\n                if (rx >= ry && ry >= rz) {\n\n                    c1 = DENS(X1, Y0, Z0) - c0;\n                    c2 = DENS(X1, Y1, Z0) - DENS(X1, Y0, Z0);\n                    c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);\n\n                }\n                else\n                    if (rx >= rz && rz >= ry) {\n\n                        c1 = DENS(X1, Y0, Z0) - c0;\n                        c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);\n                        c3 = DENS(X1, Y0, Z1) - DENS(X1, Y0, Z0);\n\n                    }\n                    else\n                        if (rz >= rx && rx >= ry) {\n\n                            c1 = DENS(X1, Y0, Z1) - DENS(X0, Y0, Z1);\n                            c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);\n                            c3 = DENS(X0, Y0, Z1) - c0;\n\n                        }\n                        else\n                            if (ry >= rx && rx >= rz) {\n\n                                c1 = DENS(X1, Y1, Z0) - DENS(X0, Y1, Z0);\n                                c2 = DENS(X0, Y1, Z0) - c0;\n                                c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);\n\n                            }\n                            else\n                                if (ry >= rz && rz >= rx) {\n\n                                    c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);\n                                    c2 = DENS(X0, Y1, Z0) - c0;\n                                    c3 = DENS(X0, Y1, Z1) - DENS(X0, Y1, Z0);\n\n                                }\n                                else\n                                    if (rz >= ry && ry >= rx) {\n\n                                        c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);\n                                        c2 = DENS(X0, Y1, Z1) - DENS(X0, Y0, Z1);\n                                        c3 = DENS(X0, Y0, Z1) - c0;\n\n                                    }\n                                    else {\n                                        c1 = c2 = c3 = 0;\n                                    }\n\n                *(cmsFloat32Number*)(out[OutChan]) = c0 + c1 * rx + c2 * ry + c3 * rz;\n\n                out[OutChan] += DestIncrements[OutChan];\n            }\n\n            if (xin)\n            {\n                *(cmsFloat32Number*) (out[TotalOut]) = *(cmsFloat32Number*)xin;\n                xin += SourceIncrements[3];\n                out[TotalOut] += DestIncrements[TotalOut];\n            }\n        }\n\n        strideIn  += Stride->BytesPerLineIn;\n        strideOut += Stride->BytesPerLineOut;\n    }\n}",
          "fn_code_pos": [
            [
              161,
              0
            ],
            [
              328,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LabCLUTEval",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "Input": "void",
              "Output": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nint GetGridpoints(cmsUInt32Number dwFlags)\n{\n    // Already specified?\n    if (dwFlags & 0x00FF0000) {\n        return (dwFlags >> 16) & 0xFF;\n    }\n\n    // HighResPrecalc is maximum resolution\n    if (dwFlags & cmsFLAGS_HIGHRESPRECALC) {\n        return 66;\n    }\n    else\n        // LowResPrecal is lower resolution\n        if (dwFlags & cmsFLAGS_LOWRESPRECALC) {\n            return 33;\n        }\n        else \n            return 51;\n\n}",
          "fn_code_pos": [
            [
              336,
              0
            ],
            [
              356,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetGridpoints",
            "parameters": {
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "cmsBool OptimizeCLUTLabTransform(_cmsTransform2Fn* TransformFn,\n                                  void** UserData,\n                                  _cmsFreeUserDataFn* FreeDataFn,\n                                  cmsPipeline** Lut, \n                                  cmsUInt32Number* InputFormat, \n                                  cmsUInt32Number* OutputFormat, \n                                  cmsUInt32Number* dwFlags)      \n{\n    cmsPipeline* OriginalLut;\n    int nGridPoints;    \n    cmsPipeline* OptimizedLUT = NULL;    \n    cmsStage* OptimizedCLUTmpe;\n    LabCLUTdata* pfloat;\n    cmsContext ContextID;\n    _cmsStageCLutData* data;\n    ResamplingContainer container;\n\n\n    // For empty transforms, do nothing\n    if (*Lut == NULL) return FALSE;\n\n    // Check for floating point only\n    if (!T_FLOAT(*InputFormat) || !T_FLOAT(*OutputFormat)) return FALSE;\n\n    // Only on floats\n    if (T_BYTES(*InputFormat) != sizeof(cmsFloat32Number) ||\n        T_BYTES(*OutputFormat) != sizeof(cmsFloat32Number)) return FALSE;\n\n    if (T_COLORSPACE(*InputFormat) != PT_Lab) return FALSE;\n\n    OriginalLut = *Lut;\n    \n    ContextID = cmsGetPipelineContextID(OriginalLut);\n    nGridPoints = GetGridpoints(*dwFlags);\n             \n    // Create the result LUT\n    OptimizedLUT = cmsPipelineAlloc(cmsGetPipelineContextID(OriginalLut), 3, cmsPipelineOutputChannels(OriginalLut));\n    if (OptimizedLUT == NULL) goto Error;\n    \n    // Allocate the CLUT for result\n    OptimizedCLUTmpe = cmsStageAllocCLutFloat(ContextID, nGridPoints, 3, cmsPipelineOutputChannels(OriginalLut), NULL);\n\n    // Add the CLUT to the destination LUT\n    cmsPipelineInsertStage(OptimizedLUT, cmsAT_BEGIN, OptimizedCLUTmpe);\n    \n    // Set the evaluator, copy parameters   \n    data = (_cmsStageCLutData*) cmsStageData(OptimizedCLUTmpe);\n\n    // Allocate data\n    pfloat = LabCLUTAlloc(ContextID, data ->Params);\n    if (pfloat == NULL) return FALSE;   \n\n    container.data = pfloat;\n    container.original = OriginalLut;\n\n    // Resample the LUT\n    if (!cmsStageSampleCLutFloat(OptimizedCLUTmpe, XFormSampler, (void*)&container, 0)) goto Error;\n\n    // And return the obtained LUT\n    cmsPipelineFree(OriginalLut);\n\n    *Lut = OptimizedLUT;\n    *TransformFn = LabCLUTEval;\n    *UserData   = pfloat;\n    *FreeDataFn = LabCLUTFree;\n    *dwFlags &= ~cmsFLAGS_CAN_CHANGE_FORMATTER;\n    return TRUE;\n\nError:\n      \n    if (OptimizedLUT != NULL) cmsPipelineFree(OptimizedLUT);\n\n    return FALSE;    \n}",
          "fn_code_pos": [
            [
              360,
              0
            ],
            [
              433,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OptimizeCLUTLabTransform",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeDataFn": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "LabCLUTAlloc(cmsContext ContextID, const cmsInterpParams* p)",
          "fn_dec_pos": [
            [
              108,
              13
            ],
            [
              108,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LabCLUTAlloc",
            "parameters": {
              "ContextID": "cmsContext",
              "p": "cmsInterpParams"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\n    cmsContext ContextID;\n    const cmsInterpParams* p;   // Tetrahedrical interpolation parameters. This is a not-owned pointer.\n\n    cmsFloat32Number sigmoidIn[SIGMOID_POINTS];   // to apply to a*/b* axis on indexing\n    cmsFloat32Number sigmoidOut[SIGMOID_POINTS];  // the curve above, inverted.\n\n} LabCLUTdata;",
          {
            "ContextID": "cmsContext",
            "cmsInterpParams": "const",
            "sigmoidIn[SIGMOID_POINTS]": "cmsFloat32Number",
            "sigmoidOut[SIGMOID_POINTS]": "cmsFloat32Number"
          },
          "LabCLUTdata",
          [
            27,
            0
          ],
          [
            35,
            14
          ]
        ],
        [
          "typedef struct {\n\n    LabCLUTdata* data;\n    cmsPipeline* original;\n\n} ResamplingContainer;",
          {
            "* data": "LabCLUTdata",
            "* original": "cmsPipeline"
          },
          "ResamplingContainer",
          [
            38,
            0
          ],
          [
            43,
            22
          ]
        ],
        [
          "typedef struct {\n\n    cmsContext ContextID;\n    const cmsInterpParams* p;   // Tetrahedrical interpolation parameters. This is a not-owned pointer.\n\n    cmsFloat32Number sigmoidIn[SIGMOID_POINTS];   // to apply to a*/b* axis on indexing\n    cmsFloat32Number sigmoidOut[SIGMOID_POINTS];  // the curve above, inverted.\n\n} LabCLUTdata;",
          {
            "ContextID": "cmsContext",
            "cmsInterpParams": "const",
            "sigmoidIn[SIGMOID_POINTS]": "cmsFloat32Number",
            "sigmoidOut[SIGMOID_POINTS]": "cmsFloat32Number"
          },
          "LabCLUTdata",
          [
            27,
            0
          ],
          [
            35,
            14
          ]
        ],
        [
          "typedef struct {\n\n    LabCLUTdata* data;\n    cmsPipeline* original;\n\n} ResamplingContainer;",
          {
            "* data": "LabCLUTdata",
            "* original": "cmsPipeline"
          },
          "ResamplingContainer",
          [
            38,
            0
          ],
          [
            43,
            22
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            162,
            17
          ],
          [
            162,
            44
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"fast_float_internal.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/fast_float/src/fast_16_tethra.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nPerformance16Data* Performance16alloc(cmsContext ContextID, const cmsInterpParams* p)\n{\n    Performance16Data* p16;\n\n    p16 = (Performance16Data*) _cmsMallocZero(ContextID, sizeof(Performance16Data));\n    if (p16 == NULL) return NULL;\n    \n    p16 ->ContextID = ContextID;\n    p16 ->p = p;\n\n    return p16;\n}",
          "fn_code_pos": [
            [
              43,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Performance16alloc",
            "parameters": {
              "ContextID": "cmsContext",
              "p": "cmsInterpParams"
            },
            "return_type": "Performance16Data"
          }
        },
        {
          "fn_code": "static\nvoid Performance16free(cmsContext ContextID, void* ptr)\n{   \n    _cmsFree(ContextID, ptr);\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              61,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Performance16free",
            "parameters": {
              "ContextID": "cmsContext",
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid PerformanceEval16(struct _cmstransform_struct *CMMcargo,\n                      const void* Input,\n                      void* Output,\n                      cmsUInt32Number PixelsPerLine,\n                      cmsUInt32Number LineCount,\n                      const cmsStride* Stride)\n{\n\n       cmsUInt16Number        r, g, b;\n       int                    x0, y0, z0;\n       cmsS15Fixed16Number    rx, ry, rz;\n       cmsS15Fixed16Number    fx, fy, fz;\n       cmsS15Fixed16Number    c0, c1, c2, c3, Rest;\n       cmsUInt32Number        OutChan, TotalPlusAlpha;\n       cmsS15Fixed16Number    X0, X1, Y0, Y1, Z0, Z1;\n       Performance16Data*     p16 = (Performance16Data*)_cmsGetTransformUserData(CMMcargo);\n       const cmsInterpParams* p = p16->p;\n       cmsUInt32Number        TotalOut = p->nOutputs;\n       const cmsUInt16Number* BaseTable = (const cmsUInt16Number*)p->Table;\n       const cmsUInt16Number* LutTable;\n\n       cmsUInt8Number* out[cmsMAXCHANNELS];\n       cmsUInt16Number res16;\n\n       cmsUInt32Number i, ii;\n\n       cmsUInt32Number SourceStartingOrder[cmsMAXCHANNELS];\n       cmsUInt32Number SourceIncrements[cmsMAXCHANNELS];\n       cmsUInt32Number DestStartingOrder[cmsMAXCHANNELS];\n       cmsUInt32Number DestIncrements[cmsMAXCHANNELS];\n\n       const cmsUInt8Number* rin;\n       const cmsUInt8Number* gin;\n       const cmsUInt8Number* bin;\n       const cmsUInt8Number* ain = NULL;\n\n       int    in16, out16;  // Used by macros!\n\n       cmsUInt32Number nalpha;\n       size_t strideIn, strideOut;\n          \n       cmsUInt32Number dwInFormat = cmsGetTransformInputFormat((cmsHTRANSFORM)CMMcargo);\n       cmsUInt32Number dwOutFormat = cmsGetTransformOutputFormat((cmsHTRANSFORM)CMMcargo);\n       \n       _cmsComputeComponentIncrements(dwInFormat, Stride->BytesPerPlaneIn, NULL, &nalpha, SourceStartingOrder, SourceIncrements);\n       _cmsComputeComponentIncrements(dwOutFormat, Stride->BytesPerPlaneOut, NULL, &nalpha, DestStartingOrder, DestIncrements);\n\n       in16  = (T_BYTES(dwInFormat) == 2);\n       out16 = (T_BYTES(dwOutFormat) == 2);\n\n       if (!(_cmsGetTransformFlags((cmsHTRANSFORM)CMMcargo) & cmsFLAGS_COPY_ALPHA))\n           nalpha = 0;\n\n       strideIn = strideOut = 0;\n       for (i = 0; i < LineCount; i++) {\n\n              rin = (const cmsUInt8Number*)Input + SourceStartingOrder[0] + strideIn;\n              gin = (const cmsUInt8Number*)Input + SourceStartingOrder[1] + strideIn;\n              bin = (const cmsUInt8Number*)Input + SourceStartingOrder[2] + strideIn;\n              if (nalpha)\n                     ain = (const cmsUInt8Number*)Input + SourceStartingOrder[3] + strideIn;\n\n              TotalPlusAlpha = TotalOut;\n              if (ain) TotalPlusAlpha++;\n\n              for (OutChan = 0; OutChan < TotalPlusAlpha; OutChan++) {\n                     out[OutChan] = (cmsUInt8Number*)Output + DestStartingOrder[OutChan] + strideOut;\n              }\n\n\n              for (ii = 0; ii < PixelsPerLine; ii++) {\n\n                  r = FROM_INPUT(rin); \n                  g = FROM_INPUT(gin);\n                  b = FROM_INPUT(bin);\n\n                  rin += SourceIncrements[0];\n                  gin += SourceIncrements[1];\n                  bin += SourceIncrements[2];\n\n                  fx = _cmsToFixedDomain((int)r * p->Domain[0]);\n                  fy = _cmsToFixedDomain((int)g * p->Domain[1]);\n                  fz = _cmsToFixedDomain((int)b * p->Domain[2]);\n\n                  x0 = FIXED_TO_INT(fx);\n                  y0 = FIXED_TO_INT(fy);\n                  z0 = FIXED_TO_INT(fz);\n\n                  rx = FIXED_REST_TO_INT(fx);\n                  ry = FIXED_REST_TO_INT(fy);\n                  rz = FIXED_REST_TO_INT(fz);\n\n                  X0 = p->opta[2] * x0;\n                  X1 = (r == 0xFFFFU ? 0 : p->opta[2]);\n\n                  Y0 = p->opta[1] * y0;\n                  Y1 = (g == 0xFFFFU ? 0 : p->opta[1]);\n\n                  Z0 = p->opta[0] * z0;\n                  Z1 = (b == 0xFFFFU ? 0 : p->opta[0]);\n\n\n                  LutTable = &BaseTable[X0 + Y0 + Z0];\n\n                  // Output should be computed as x = ROUND_FIXED_TO_INT(_cmsToFixedDomain(Rest))\n                  // which expands as: x = (Rest + ((Rest+0x7fff)/0xFFFF) + 0x8000)>>16\n                  // This can be replaced by: t = Rest+0x8001, x = (t + (t>>16))>>16\n                  // at the cost of being off by one at 7fff and 17ffe.\n\n                  if (rx >= ry) {\n                      if (ry >= rz) {\n                          Y1 += X1;\n                          Z1 += Y1;\n                          for (OutChan = 0; OutChan < TotalOut; OutChan++) {\n                              c1 = LutTable[X1];\n                              c2 = LutTable[Y1];\n                              c3 = LutTable[Z1];\n                              c0 = *LutTable++;\n                              c3 -= c2;\n                              c2 -= c1;\n                              c1 -= c0;\n                              Rest = c1 * rx + c2 * ry + c3 * rz + 0x8001;\n                              res16 = (cmsUInt16Number)c0 + ((Rest + (Rest >> 16)) >> 16);\n                              TO_OUTPUT(out[OutChan], res16);\n                              out[OutChan] += DestIncrements[OutChan];\n                          }\n                      }\n                      else if (rz >= rx) {\n                          X1 += Z1;\n                          Y1 += X1;\n                          for (OutChan = 0; OutChan < TotalOut; OutChan++) {\n                              c1 = LutTable[X1];\n                              c2 = LutTable[Y1];\n                              c3 = LutTable[Z1];\n                              c0 = *LutTable++;\n                              c2 -= c1;\n                              c1 -= c3;\n                              c3 -= c0;\n                              Rest = c1 * rx + c2 * ry + c3 * rz + 0x8001;\n                              res16 = (cmsUInt16Number)c0 + ((Rest + (Rest >> 16)) >> 16);\n                              TO_OUTPUT(out[OutChan], res16);\n                              out[OutChan] += DestIncrements[OutChan];\n                          }\n                      }\n                      else {\n                          Z1 += X1;\n                          Y1 += Z1;\n                          for (OutChan = 0; OutChan < TotalOut; OutChan++) {\n                              c1 = LutTable[X1];\n                              c2 = LutTable[Y1];\n                              c3 = LutTable[Z1];\n                              c0 = *LutTable++;\n                              c2 -= c3;\n                              c3 -= c1;\n                              c1 -= c0;\n                              Rest = c1 * rx + c2 * ry + c3 * rz + 0x8001;\n                              res16 = (cmsUInt16Number)c0 + ((Rest + (Rest >> 16)) >> 16);\n                              TO_OUTPUT(out[OutChan], res16);\n                              out[OutChan] += DestIncrements[OutChan];\n                          }\n                      }\n                  }\n                  else {\n                      if (rx >= rz) {\n                          X1 += Y1;\n                          Z1 += X1;\n                          for (OutChan = 0; OutChan < TotalOut; OutChan++) {\n                              c1 = LutTable[X1];\n                              c2 = LutTable[Y1];\n                              c3 = LutTable[Z1];\n                              c0 = *LutTable++;\n                              c3 -= c1;\n                              c1 -= c2;\n                              c2 -= c0;\n                              Rest = c1 * rx + c2 * ry + c3 * rz + 0x8001;\n                              res16 = (cmsUInt16Number)c0 + ((Rest + (Rest >> 16)) >> 16);\n                              TO_OUTPUT(out[OutChan], res16);\n                              out[OutChan] += DestIncrements[OutChan];\n                          }\n                      }\n                      else if (ry >= rz) {\n                          Z1 += Y1;\n                          X1 += Z1;\n                          for (OutChan = 0; OutChan < TotalOut; OutChan++) {\n                              c1 = LutTable[X1];\n                              c2 = LutTable[Y1];\n                              c3 = LutTable[Z1];\n                              c0 = *LutTable++;\n                              c1 -= c3;\n                              c3 -= c2;\n                              c2 -= c0;\n                              Rest = c1 * rx + c2 * ry + c3 * rz + 0x8001;\n                              res16 = (cmsUInt16Number)c0 + ((Rest + (Rest >> 16)) >> 16);\n                              TO_OUTPUT(out[OutChan], res16);\n                              out[OutChan] += DestIncrements[OutChan];\n                          }\n                      }\n                      else {\n                          Y1 += Z1;\n                          X1 += Y1;\n                          for (OutChan = 0; OutChan < TotalOut; OutChan++) {\n                              c1 = LutTable[X1];\n                              c2 = LutTable[Y1];\n                              c3 = LutTable[Z1];\n                              c0 = *LutTable++;\n                              c1 -= c2;\n                              c2 -= c3;\n                              c3 -= c0;\n                              Rest = c1 * rx + c2 * ry + c3 * rz + 0x8001;                              \n                              res16 = (cmsUInt16Number)c0 + ((Rest + (Rest >> 16)) >> 16);\n                              TO_OUTPUT(out[OutChan], res16);\n                              out[OutChan] += DestIncrements[OutChan];\n                          }\n                      }\n                  }\n\n                  if (ain)\n                  {\n                      res16 = *(const cmsUInt16Number*)ain;\n                      TO_OUTPUT(out[TotalOut], res16);\n                      ain += SourceIncrements[3];\n                      out[TotalOut] += DestIncrements[TotalOut];\n                  }\n\n              }\n\n              strideIn += Stride->BytesPerLineIn;\n              strideOut += Stride->BytesPerLineOut;\n       }\n}",
          "fn_code_pos": [
            [
              75,
              0
            ],
            [
              305,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PerformanceEval16",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "Input": "void",
              "Output": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool Optimize16BitRGBTransform(_cmsTransform2Fn* TransformFn,\n                                  void** UserData,\n                                  _cmsFreeUserDataFn* FreeDataFn,\n                                  cmsPipeline** Lut, \n                                  cmsUInt32Number* InputFormat, \n                                  cmsUInt32Number* OutputFormat, \n                                  cmsUInt32Number* dwFlags)      \n{\n    Performance16Data* p16;\n    cmsContext ContextID;\n    _cmsStageCLutData* data;\n    cmsUInt32Number newFlags;\n    cmsStage* OptimizedCLUTmpe;\n\n\n    // For empty transforms, do nothing\n    if (*Lut == NULL) return FALSE;\n\n    // This is a lossy optimization! does not apply in floating-point cases\n    if (T_FLOAT(*InputFormat) || T_FLOAT(*OutputFormat)) return FALSE;\n\n    // Only on 16-bit\n    if (T_BYTES(*InputFormat) != 2 || T_BYTES(*OutputFormat) != 2) return FALSE;\n\n    // Only real 16 bits\n    if (T_BIT15(*InputFormat) != 0 || T_BIT15(*OutputFormat) != 0) return FALSE;\n\n\t// Swap endian is not supported\n    if (T_ENDIAN16(*InputFormat) != 0 || T_ENDIAN16(*OutputFormat) != 0) return FALSE;\n\n    // Only on input RGB\n    if (T_COLORSPACE(*InputFormat)  != PT_RGB) return FALSE;\n    \n\n    // If this is a matrix-shaper, the default does already a good job\n    if (cmsPipelineCheckAndRetreiveStages(*Lut, 4,\n        cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType,\n        NULL, NULL, NULL, NULL)) return FALSE;\n\n    if (cmsPipelineCheckAndRetreiveStages(*Lut, 2,\n        cmsSigCurveSetElemType, cmsSigCurveSetElemType,\n        NULL, NULL)) return FALSE;\n\n   \n    ContextID = cmsGetPipelineContextID(*Lut);\n    newFlags = *dwFlags | cmsFLAGS_FORCE_CLUT;\n\n    if (!_cmsOptimizePipeline(ContextID,\n                               Lut,\n                               INTENT_PERCEPTUAL,  // Dont care\n                               InputFormat,\n                               OutputFormat,\n                               &newFlags)) return FALSE;\n\n    OptimizedCLUTmpe = cmsPipelineGetPtrToFirstStage(*Lut);\n\n    // Set the evaluator   \n    data = (_cmsStageCLutData*)cmsStageData(OptimizedCLUTmpe);\n\n    p16 = Performance16alloc(ContextID, data->Params);\n    if (p16 == NULL) return FALSE;\n\n    *TransformFn = PerformanceEval16;\n    *UserData   = p16;\n    *FreeDataFn = Performance16free;\n    *InputFormat  |= 0x02000000;\n    *OutputFormat |= 0x02000000;\n    *dwFlags |= cmsFLAGS_CAN_CHANGE_FORMATTER;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              313,
              0
            ],
            [
              383,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Optimize16BitRGBTransform",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeDataFn": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "_cmsOptimizePipeline(cmsContext ContextID,\n                              cmsPipeline** Lut,\n                              cmsUInt32Number  Intent,\n                              cmsUInt32Number* InputFormat,\n                              cmsUInt32Number* OutputFormat,\n                              cmsUInt32Number* dwFlags)",
          "fn_dec_pos": [
            [
              24,
              26
            ],
            [
              29,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsOptimizePipeline",
            "parameters": {
              "ContextID": "cmsContext",
              "Lut": "cmsPipeline",
              "Intent": "cmsUInt32Number",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "Performance16alloc(cmsContext ContextID, const cmsInterpParams* p)",
          "fn_dec_pos": [
            [
              44,
              19
            ],
            [
              44,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Performance16alloc",
            "parameters": {
              "ContextID": "cmsContext",
              "p": "cmsInterpParams"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\n    cmsContext ContextID;\n\n    const cmsInterpParams* p;   // Tetrahedrical interpolation parameters. This is a not-owned pointer.    \n\n} Performance16Data;",
          {
            "ContextID": "cmsContext",
            "cmsInterpParams": "const"
          },
          "Performance16Data",
          [
            33,
            0
          ],
          [
            39,
            20
          ]
        ],
        [
          "typedef struct {\n\n    cmsContext ContextID;\n\n    const cmsInterpParams* p;   // Tetrahedrical interpolation parameters. This is a not-owned pointer.    \n\n} Performance16Data;",
          {
            "ContextID": "cmsContext",
            "cmsInterpParams": "const"
          },
          "Performance16Data",
          [
            33,
            0
          ],
          [
            39,
            20
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            76,
            23
          ],
          [
            76,
            50
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"fast_float_internal.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/fast_float/src/fast_float_cmyk.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nFloatCMYKData* FloatCMYKAlloc(cmsContext ContextID, const cmsInterpParams* p)\n{\n    FloatCMYKData* fd;\n\n    fd = (FloatCMYKData*) _cmsMallocZero(ContextID, sizeof(FloatCMYKData));\n    if (fd == NULL) return NULL;\n    \n    fd ->ContextID = ContextID;\n    fd ->p = p;\n    return fd;\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              45,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FloatCMYKAlloc",
            "parameters": {
              "ContextID": "cmsContext",
              "p": "cmsInterpParams"
            },
            "return_type": "FloatCMYKData"
          }
        },
        {
          "fn_code": "static\nint XFormSampler(CMSREGISTER const cmsFloat32Number In[], CMSREGISTER cmsFloat32Number Out[], CMSREGISTER void* Cargo)\n{\n    // Evaluate in 16 bits\n    cmsPipelineEvalFloat(In, Out, (cmsPipeline*) Cargo);\n\n    // Always succeed\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              56,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "XFormSampler",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "cmsINLINE cmsFloat32Number LinearInterpInt(cmsFloat32Number a, cmsFloat32Number l, cmsFloat32Number h)\n{\n       return (h - l) * a + l;       \n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              61,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFloat32Number LinearInterpInt",
            "parameters": {
              "a": "cmsFloat32Number",
              "l": "cmsFloat32Number",
              "h": "cmsFloat32Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE cmsFloat32Number fclamp100(cmsFloat32Number v)\n{\n       return ((v < 1.0e-9f) || isnan(v)) ? 0.0f : (v > 100.0f ? 100.0f : v);       \n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFloat32Number fclamp100",
            "parameters": {
              "v": "cmsFloat32Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "static\nvoid FloatCMYKCLUTEval(struct _cmstransform_struct *CMMcargo,\n                      const void* Input,\n                      void* Output,\n                      cmsUInt32Number PixelsPerLine,\n                      cmsUInt32Number LineCount,\n                      const cmsStride* Stride)\n{\n    \n    cmsFloat32Number        c, m, y, k;\n    cmsFloat32Number        px, py, pz, pk;\n    int                     x0, y0, z0, k0;\n    int                     X0, Y0, Z0, K0, X1, Y1, Z1, K1;\n    cmsFloat32Number        rx, ry, rz, rk;\n    cmsFloat32Number        c0, c1 = 0, c2 = 0, c3 = 0;\n\n    cmsUInt32Number         OutChan;\n    FloatCMYKData*          pcmyk = (FloatCMYKData*) _cmsGetTransformUserData(CMMcargo);\n\n    const cmsInterpParams*  p = pcmyk ->p;\n    cmsUInt32Number        TotalOut = p -> nOutputs;\n    cmsUInt32Number        TotalPlusAlpha;\n    const cmsFloat32Number* LutTable = (const cmsFloat32Number*)p->Table;\n    cmsUInt32Number        i, ii;\n    const cmsUInt8Number*  cin;\n    const cmsUInt8Number*  min;\n    const cmsUInt8Number*  yin;\n    const cmsUInt8Number*  kin;\n    const cmsUInt8Number*  ain = NULL;\n\n    cmsFloat32Number        Tmp1[cmsMAXCHANNELS], Tmp2[cmsMAXCHANNELS];\n\n    cmsUInt8Number* out[cmsMAXCHANNELS];\n    cmsUInt32Number SourceStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number SourceIncrements[cmsMAXCHANNELS];\n    cmsUInt32Number DestStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number DestIncrements[cmsMAXCHANNELS];\n\n    cmsUInt32Number InputFormat  = cmsGetTransformInputFormat((cmsHTRANSFORM) CMMcargo);\n    cmsUInt32Number OutputFormat = cmsGetTransformOutputFormat((cmsHTRANSFORM) CMMcargo);\n\n    cmsUInt32Number nchans, nalpha;\n    size_t strideIn, strideOut;\n\n    _cmsComputeComponentIncrements(InputFormat, Stride->BytesPerPlaneIn, &nchans, &nalpha, SourceStartingOrder, SourceIncrements);\n    _cmsComputeComponentIncrements(OutputFormat, Stride->BytesPerPlaneOut, &nchans, &nalpha, DestStartingOrder, DestIncrements);\n\n    if (!(_cmsGetTransformFlags((cmsHTRANSFORM)CMMcargo) & cmsFLAGS_COPY_ALPHA))\n        nalpha = 0;\n\n    strideIn = strideOut = 0;\n    for (i = 0; i < LineCount; i++) {\n\n        cin = (const cmsUInt8Number*)Input + SourceStartingOrder[0] + strideIn;\n        min = (const cmsUInt8Number*)Input + SourceStartingOrder[1] + strideIn;\n        yin = (const cmsUInt8Number*)Input + SourceStartingOrder[2] + strideIn;\n        kin = (const cmsUInt8Number*)Input + SourceStartingOrder[3] + strideIn;\n\n        if (nalpha)\n            ain = (const cmsUInt8Number*)Input + SourceStartingOrder[4] + strideIn;\n\n        TotalPlusAlpha = TotalOut;\n        if (ain) TotalPlusAlpha++;\n\n        for (ii = 0; ii < TotalPlusAlpha; ii++)\n            out[ii] = (cmsUInt8Number*)Output + DestStartingOrder[ii] + strideOut;\n\n        for (ii = 0; ii < PixelsPerLine; ii++) {\n\n            c = fclamp100(*(cmsFloat32Number*)cin) / 100.0f;\n            m = fclamp100(*(cmsFloat32Number*)min) / 100.0f;\n            y = fclamp100(*(cmsFloat32Number*)yin) / 100.0f;\n            k = fclamp100(*(cmsFloat32Number*)kin) / 100.0f;\n\n            cin += SourceIncrements[0];\n            min += SourceIncrements[1];\n            yin += SourceIncrements[2];\n            kin += SourceIncrements[3];\n\n            pk = c * p->Domain[0];  // C\n            px = m * p->Domain[1];  // M \n            py = y * p->Domain[2];  // Y \n            pz = k * p->Domain[3];  // K\n\n\n            k0 = (int)_cmsQuickFloor(pk); rk = (pk - (cmsFloat32Number)k0);\n            x0 = (int)_cmsQuickFloor(px); rx = (px - (cmsFloat32Number)x0);\n            y0 = (int)_cmsQuickFloor(py); ry = (py - (cmsFloat32Number)y0);\n            z0 = (int)_cmsQuickFloor(pz); rz = (pz - (cmsFloat32Number)z0);\n\n\n            K0 = p->opta[3] * k0;\n            K1 = K0 + (c >= 1.0 ? 0 : p->opta[3]);\n\n            X0 = p->opta[2] * x0;\n            X1 = X0 + (m >= 1.0 ? 0 : p->opta[2]);\n\n            Y0 = p->opta[1] * y0;\n            Y1 = Y0 + (y >= 1.0 ? 0 : p->opta[1]);\n\n            Z0 = p->opta[0] * z0;\n            Z1 = Z0 + (k >= 1.0 ? 0 : p->opta[0]);\n\n            for (OutChan = 0; OutChan < TotalOut; OutChan++) {\n\n                c0 = DENS(X0, Y0, Z0);\n\n                if (rx >= ry && ry >= rz) {\n\n                    c1 = DENS(X1, Y0, Z0) - c0;\n                    c2 = DENS(X1, Y1, Z0) - DENS(X1, Y0, Z0);\n                    c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);\n\n                }\n                else\n                    if (rx >= rz && rz >= ry) {\n\n                        c1 = DENS(X1, Y0, Z0) - c0;\n                        c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);\n                        c3 = DENS(X1, Y0, Z1) - DENS(X1, Y0, Z0);\n\n                    }\n                    else\n                        if (rz >= rx && rx >= ry) {\n\n                            c1 = DENS(X1, Y0, Z1) - DENS(X0, Y0, Z1);\n                            c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);\n                            c3 = DENS(X0, Y0, Z1) - c0;\n\n                        }\n                        else\n                            if (ry >= rx && rx >= rz) {\n\n                                c1 = DENS(X1, Y1, Z0) - DENS(X0, Y1, Z0);\n                                c2 = DENS(X0, Y1, Z0) - c0;\n                                c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);\n\n                            }\n                            else\n                                if (ry >= rz && rz >= rx) {\n\n                                    c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);\n                                    c2 = DENS(X0, Y1, Z0) - c0;\n                                    c3 = DENS(X0, Y1, Z1) - DENS(X0, Y1, Z0);\n\n                                }\n                                else\n                                    if (rz >= ry && ry >= rx) {\n\n                                        c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);\n                                        c2 = DENS(X0, Y1, Z1) - DENS(X0, Y0, Z1);\n                                        c3 = DENS(X0, Y0, Z1) - c0;\n\n                                    }\n                                    else {\n                                        c1 = c2 = c3 = 0;\n                                    }\n\n\n                Tmp1[OutChan] = c0 + c1 * rx + c2 * ry + c3 * rz;\n\n            }\n\n\n            LutTable = (cmsFloat32Number*)p->Table;\n            LutTable += K1;\n\n            for (OutChan = 0; OutChan < p->nOutputs; OutChan++) {\n\n                c0 = DENS(X0, Y0, Z0);\n\n                if (rx >= ry && ry >= rz) {\n\n                    c1 = DENS(X1, Y0, Z0) - c0;\n                    c2 = DENS(X1, Y1, Z0) - DENS(X1, Y0, Z0);\n                    c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);\n\n                }\n                else\n                    if (rx >= rz && rz >= ry) {\n\n                        c1 = DENS(X1, Y0, Z0) - c0;\n                        c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);\n                        c3 = DENS(X1, Y0, Z1) - DENS(X1, Y0, Z0);\n\n                    }\n                    else\n                        if (rz >= rx && rx >= ry) {\n\n                            c1 = DENS(X1, Y0, Z1) - DENS(X0, Y0, Z1);\n                            c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);\n                            c3 = DENS(X0, Y0, Z1) - c0;\n\n                        }\n                        else\n                            if (ry >= rx && rx >= rz) {\n\n                                c1 = DENS(X1, Y1, Z0) - DENS(X0, Y1, Z0);\n                                c2 = DENS(X0, Y1, Z0) - c0;\n                                c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);\n\n                            }\n                            else\n                                if (ry >= rz && rz >= rx) {\n\n                                    c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);\n                                    c2 = DENS(X0, Y1, Z0) - c0;\n                                    c3 = DENS(X0, Y1, Z1) - DENS(X0, Y1, Z0);\n\n                                }\n                                else\n                                    if (rz >= ry && ry >= rx) {\n\n                                        c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);\n                                        c2 = DENS(X0, Y1, Z1) - DENS(X0, Y0, Z1);\n                                        c3 = DENS(X0, Y0, Z1) - c0;\n\n                                    }\n                                    else {\n                                        c1 = c2 = c3 = 0;\n                                    }\n\n                Tmp2[OutChan] = c0 + c1 * rx + c2 * ry + c3 * rz;\n            }\n\n\n            for (OutChan = 0; OutChan < p->nOutputs; OutChan++) {\n\n                *(cmsFloat32Number*)(out[OutChan]) = LinearInterpInt(rk, Tmp1[OutChan], Tmp2[OutChan]);\n                out[OutChan] += DestIncrements[OutChan];\n            }\n\n            if (ain) {\n                *(cmsFloat32Number*)(out[TotalOut]) = *(cmsFloat32Number*)ain;\n                ain += SourceIncrements[4];\n                out[TotalOut] += DestIncrements[TotalOut];\n            }\n        }\n\n        strideIn += Stride->BytesPerLineIn;\n        strideOut += Stride->BytesPerLineOut;\n    }\n}",
          "fn_code_pos": [
            [
              73,
              0
            ],
            [
              315,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FloatCMYKCLUTEval",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "Input": "void",
              "Output": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool OptimizeCLUTCMYKTransform(_cmsTransform2Fn* TransformFn,\n                                  void** UserData,\n                                  _cmsFreeUserDataFn* FreeDataFn,\n                                  cmsPipeline** Lut, \n                                  cmsUInt32Number* InputFormat, \n                                  cmsUInt32Number* OutputFormat, \n                                  cmsUInt32Number* dwFlags)      \n{\n    cmsPipeline* OriginalLut;\n    int nGridPoints;    \n    cmsPipeline* OptimizedLUT = NULL;    \n    cmsStage* OptimizedCLUTmpe;\n    FloatCMYKData* pcmyk;\n    cmsContext ContextID;\n    _cmsStageCLutData* data;\n\n    // For empty transforms, do nothing\n    if (*Lut == NULL) return FALSE;\n\n    // This is a lossy optimization! does not apply in floating-point cases\n    if (!T_FLOAT(*InputFormat) || !T_FLOAT(*OutputFormat)) return FALSE;\n\n    // Only on 8-bit\n    if (T_BYTES(*InputFormat) != 4 || T_BYTES(*OutputFormat) != 4) return FALSE;\n\n    // Only on CMYK\n    if (T_COLORSPACE(*InputFormat)  != PT_CMYK) return FALSE;\n   \n    OriginalLut = *Lut;\n   \n    ContextID = cmsGetPipelineContextID(OriginalLut);\n    nGridPoints = _cmsReasonableGridpointsByColorspace(cmsSigRgbData, *dwFlags);\n             \n    // Create the result LUT\n    OptimizedLUT = cmsPipelineAlloc(cmsGetPipelineContextID(OriginalLut), 4, cmsPipelineOutputChannels(OriginalLut));\n    if (OptimizedLUT == NULL) goto Error;\n\n    \n    // Allocate the CLUT for result\n    OptimizedCLUTmpe = cmsStageAllocCLutFloat(ContextID, nGridPoints, 4, cmsPipelineOutputChannels(OriginalLut), NULL);\n\n    // Add the CLUT to the destination LUT\n    cmsPipelineInsertStage(OptimizedLUT, cmsAT_BEGIN, OptimizedCLUTmpe);\n\n    // Resample the LUT\n    if (!cmsStageSampleCLutFloat(OptimizedCLUTmpe, XFormSampler, (void*)OriginalLut, 0)) goto Error;\n\n    // Set the evaluator, copy parameters   \n    data = (_cmsStageCLutData*) cmsStageData(OptimizedCLUTmpe);\n\n    pcmyk = FloatCMYKAlloc(ContextID, data ->Params);\n    if (pcmyk == NULL) return FALSE;   \n\n    // And return the obtained LUT\n    cmsPipelineFree(OriginalLut);\n\n    *Lut = OptimizedLUT;\n    *TransformFn = FloatCMYKCLUTEval;\n    *UserData   = pcmyk;\n    *FreeDataFn = _cmsFree;\n    *dwFlags &= ~cmsFLAGS_CAN_CHANGE_FORMATTER;\n    return TRUE;\n\nError:\n      \n    if (OptimizedLUT != NULL) cmsPipelineFree(OptimizedLUT);\n\n    return FALSE;    \n}",
          "fn_code_pos": [
            [
              323,
              0
            ],
            [
              391,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OptimizeCLUTCMYKTransform",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeDataFn": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "FloatCMYKAlloc(cmsContext ContextID, const cmsInterpParams* p)",
          "fn_dec_pos": [
            [
              35,
              15
            ],
            [
              35,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FloatCMYKAlloc",
            "parameters": {
              "ContextID": "cmsContext",
              "p": "cmsInterpParams"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\n    cmsContext ContextID;\n    const cmsInterpParams* p;   // Tetrahedrical interpolation parameters. This is a not-owned pointer.\n\n} FloatCMYKData;",
          {
            "ContextID": "cmsContext",
            "cmsInterpParams": "const"
          },
          "FloatCMYKData",
          [
            24,
            0
          ],
          [
            29,
            16
          ]
        ],
        [
          "typedef struct {\n\n    cmsContext ContextID;\n    const cmsInterpParams* p;   // Tetrahedrical interpolation parameters. This is a not-owned pointer.\n\n} FloatCMYKData;",
          {
            "ContextID": "cmsContext",
            "cmsInterpParams": "const"
          },
          "FloatCMYKData",
          [
            24,
            0
          ],
          [
            29,
            16
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            74,
            23
          ],
          [
            74,
            50
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"fast_float_internal.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/fast_float/src/fast_8_curves.c": {
      "fn_def_list": [
        {
          "fn_code": "static void FastEvaluateRGBCurves8(struct _cmstransform_struct *CMMcargo,\n                                   const void* Input,\n                                   void* Output,\n                                   cmsUInt32Number PixelsPerLine,\n                                   cmsUInt32Number LineCount,\n                                   const cmsStride* Stride)\n{\n       cmsUInt32Number i, ii;\n\n       cmsUInt32Number SourceStartingOrder[cmsMAXCHANNELS];\n       cmsUInt32Number SourceIncrements[cmsMAXCHANNELS];\n       cmsUInt32Number DestStartingOrder[cmsMAXCHANNELS];\n       cmsUInt32Number DestIncrements[cmsMAXCHANNELS];\n\n       const cmsUInt8Number* rin;\n       const cmsUInt8Number* gin;\n       const cmsUInt8Number* bin;\n       const cmsUInt8Number* ain = NULL;\n\n       cmsUInt8Number* rout;\n       cmsUInt8Number* gout;\n       cmsUInt8Number* bout;\n       cmsUInt8Number* aout = NULL;\n\n       cmsUInt32Number nalpha;\n       size_t strideIn, strideOut;\n\n       Curves8Data* Data = (Curves8Data*)_cmsGetTransformUserData(CMMcargo);\n\n       _cmsComputeComponentIncrements(cmsGetTransformInputFormat((cmsHTRANSFORM)CMMcargo), Stride->BytesPerPlaneIn, NULL, &nalpha, SourceStartingOrder, SourceIncrements);\n       _cmsComputeComponentIncrements(cmsGetTransformOutputFormat((cmsHTRANSFORM)CMMcargo), Stride->BytesPerPlaneOut, NULL, &nalpha, DestStartingOrder, DestIncrements);\n\n       if (!(_cmsGetTransformFlags((cmsHTRANSFORM)CMMcargo) & cmsFLAGS_COPY_ALPHA))\n           nalpha = 0;\n\n       strideIn = strideOut = 0;\n       for (i = 0; i < LineCount; i++) {\n\n              rin = (const cmsUInt8Number*)Input + SourceStartingOrder[0] + strideIn;\n              gin = (const cmsUInt8Number*)Input + SourceStartingOrder[1] + strideIn;\n              bin = (const cmsUInt8Number*)Input + SourceStartingOrder[2] + strideIn;\n              if (nalpha)\n                     ain = (const cmsUInt8Number*)Input + SourceStartingOrder[3] + strideIn;\n\n              rout = (cmsUInt8Number*)Output + DestStartingOrder[0] + strideOut;\n              gout = (cmsUInt8Number*)Output + DestStartingOrder[1] + strideOut;\n              bout = (cmsUInt8Number*)Output + DestStartingOrder[2] + strideOut;\n              if (nalpha)\n                     aout = (cmsUInt8Number*)Output + DestStartingOrder[3] + strideOut;\n\n              for (ii = 0; ii < PixelsPerLine; ii++) {\n\n\n                     *rout = Data->Curves[0][*rin];\n                     *gout = Data->Curves[1][*gin];\n                     *bout = Data->Curves[2][*bin];\n\n                     // Handle alpha\n                     if (ain) {\n                           *aout = *ain;\n                     }\n\n                     rin += SourceIncrements[0];\n                     gin += SourceIncrements[1];\n                     bin += SourceIncrements[2];\n                     if (ain) ain += SourceIncrements[3];\n\n                     rout += DestIncrements[0];\n                     gout += DestIncrements[1];\n                     bout += DestIncrements[2];\n                     if (aout) aout += DestIncrements[3];\n              }\n\n              strideIn += Stride->BytesPerLineIn;\n              strideOut += Stride->BytesPerLineOut;\n       }\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              110,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FastEvaluateRGBCurves8",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "Input": "void",
              "Output": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void FastRGBIdentity8(struct _cmstransform_struct *CMMcargo,\n                             const void* Input,\n                             void* Output,\n                             cmsUInt32Number PixelsPerLine,\n                             cmsUInt32Number LineCount,\n                             const cmsStride* Stride)\n{\n       cmsUInt32Number i, ii;\n\n       cmsUInt32Number SourceStartingOrder[cmsMAXCHANNELS];\n       cmsUInt32Number SourceIncrements[cmsMAXCHANNELS];\n       cmsUInt32Number DestStartingOrder[cmsMAXCHANNELS];\n       cmsUInt32Number DestIncrements[cmsMAXCHANNELS];\n\n       const cmsUInt8Number* rin;\n       const cmsUInt8Number* gin;\n       const cmsUInt8Number* bin;\n       const cmsUInt8Number* ain = NULL;\n\n       cmsUInt8Number* rout;\n       cmsUInt8Number* gout;\n       cmsUInt8Number* bout;\n       cmsUInt8Number* aout = NULL;\n\n       cmsUInt32Number nalpha;\n       size_t strideIn, strideOut;\n    \n       _cmsComputeComponentIncrements(cmsGetTransformInputFormat((cmsHTRANSFORM)CMMcargo), Stride->BytesPerPlaneIn, NULL, &nalpha, SourceStartingOrder, SourceIncrements);\n       _cmsComputeComponentIncrements(cmsGetTransformOutputFormat((cmsHTRANSFORM)CMMcargo), Stride->BytesPerPlaneOut, NULL, &nalpha, DestStartingOrder, DestIncrements);\n\n       if (!(_cmsGetTransformFlags((cmsHTRANSFORM)CMMcargo) & cmsFLAGS_COPY_ALPHA))\n           nalpha = 0;\n\n       strideIn = strideOut = 0;\n       for (i = 0; i < LineCount; i++) {\n\n              rin = (const cmsUInt8Number*)Input + SourceStartingOrder[0] + strideIn;\n              gin = (const cmsUInt8Number*)Input + SourceStartingOrder[1] + strideIn;\n              bin = (const cmsUInt8Number*)Input + SourceStartingOrder[2] + strideIn;\n              if (nalpha)\n                     ain = (const cmsUInt8Number*)Input + SourceStartingOrder[3] + strideIn;\n\n              rout = (cmsUInt8Number*)Output + DestStartingOrder[0] + strideOut;\n              gout = (cmsUInt8Number*)Output + DestStartingOrder[1] + strideOut;\n              bout = (cmsUInt8Number*)Output + DestStartingOrder[2] + strideOut;\n              if (nalpha)\n                     aout = (cmsUInt8Number*)Output + DestStartingOrder[3] + strideOut;\n\n              for (ii = 0; ii < PixelsPerLine; ii++) {\n\n\n                     *rout = *rin;\n                     *gout = *gin;\n                     *bout = *bin;\n\n                     // Handle alpha\n                     if (ain) {\n                            *aout = *ain;\n                     }\n\n                     rin += SourceIncrements[0];\n                     gin += SourceIncrements[1];\n                     bin += SourceIncrements[2];\n                     if (ain) ain += SourceIncrements[3];\n\n                     rout += DestIncrements[0];\n                     gout += DestIncrements[1];\n                     bout += DestIncrements[2];\n                     if (aout) aout += DestIncrements[3];\n              }\n\n              strideIn += Stride->BytesPerLineIn;\n              strideOut += Stride->BytesPerLineOut;\n       }\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              188,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FastRGBIdentity8",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "Input": "void",
              "Output": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void FastEvaluateGrayCurves8(struct _cmstransform_struct *CMMcargo,\n                                    const void* Input,\n                                    void* Output,\n                                    cmsUInt32Number PixelsPerLine,\n                                    cmsUInt32Number LineCount,\n                                    const cmsStride* Stride)\n{ \n       cmsUInt32Number i, ii;\n\n       cmsUInt32Number SourceStartingOrder[cmsMAXCHANNELS];\n       cmsUInt32Number SourceIncrements[cmsMAXCHANNELS];\n       cmsUInt32Number DestStartingOrder[cmsMAXCHANNELS];\n       cmsUInt32Number DestIncrements[cmsMAXCHANNELS];\n\n       const cmsUInt8Number* gin;\n       const cmsUInt8Number* ain = NULL;\n\n       cmsUInt8Number* gout;\n       cmsUInt8Number* aout = NULL;\n\n       cmsUInt32Number nalpha;\n       size_t strideIn, strideOut;\n\n       Curves8Data* Data = (Curves8Data*)_cmsGetTransformUserData(CMMcargo);\n\n       _cmsComputeComponentIncrements(cmsGetTransformInputFormat((cmsHTRANSFORM)CMMcargo), Stride->BytesPerPlaneIn, NULL, &nalpha, SourceStartingOrder, SourceIncrements);\n       _cmsComputeComponentIncrements(cmsGetTransformOutputFormat((cmsHTRANSFORM)CMMcargo), Stride->BytesPerPlaneOut, NULL, &nalpha, DestStartingOrder, DestIncrements);\n\n       if (!(_cmsGetTransformFlags((cmsHTRANSFORM)CMMcargo) & cmsFLAGS_COPY_ALPHA))\n           nalpha = 0;\n\n       strideIn = strideOut = 0;\n       for (i = 0; i < LineCount; i++) {\n             \n              gin = (const cmsUInt8Number*)Input + SourceStartingOrder[0] + strideIn;\n              if (nalpha)\n                     ain = (const cmsUInt8Number*)Input + SourceStartingOrder[1] + strideIn;\n              \n              gout = (cmsUInt8Number*)Output + DestStartingOrder[0] + strideOut;              \n              if (nalpha)\n                     aout = (cmsUInt8Number*)Output + DestStartingOrder[1] + strideOut;\n\n              for (ii = 0; ii < PixelsPerLine; ii++) {\n                     \n                     *gout = Data->Curves[0][*gin];\n                     \n                     // Handle alpha\n                     if (ain) {\n                            *aout = *ain;\n                     }\n                     \n                     gin += SourceIncrements[0];\n                     \n                     if (ain) ain += SourceIncrements[1];\n                     \n                     gout += DestIncrements[0];\n                     \n                     if (aout) aout += DestIncrements[1];\n              }\n\n              strideIn += Stride->BytesPerLineIn;\n              strideOut += Stride->BytesPerLineOut;\n       }\n}",
          "fn_code_pos": [
            [
              193,
              0
            ],
            [
              256,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FastEvaluateGrayCurves8",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "Input": "void",
              "Output": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void FastGrayIdentity8(struct _cmstransform_struct *CMMcargo,\n                             const void* Input,\n                             void* Output,\n                             cmsUInt32Number PixelsPerLine,\n                             cmsUInt32Number LineCount,\n                             const cmsStride* Stride)\n{\n       cmsUInt32Number i, ii;\n\n       cmsUInt32Number SourceStartingOrder[cmsMAXCHANNELS];\n       cmsUInt32Number SourceIncrements[cmsMAXCHANNELS];\n       cmsUInt32Number DestStartingOrder[cmsMAXCHANNELS];\n       cmsUInt32Number DestIncrements[cmsMAXCHANNELS];\n\n       const cmsUInt8Number* gin;\n       const cmsUInt8Number* ain = NULL;\n\n       cmsUInt8Number* gout;\n       cmsUInt8Number* aout = NULL;\n\n       cmsUInt32Number nalpha;\n       size_t strideIn, strideOut;\n       \n       _cmsComputeComponentIncrements(cmsGetTransformInputFormat((cmsHTRANSFORM)CMMcargo), Stride->BytesPerPlaneIn, NULL, &nalpha, SourceStartingOrder, SourceIncrements);\n       _cmsComputeComponentIncrements(cmsGetTransformOutputFormat((cmsHTRANSFORM)CMMcargo), Stride->BytesPerPlaneOut, NULL, &nalpha, DestStartingOrder, DestIncrements);\n\n       if (!(_cmsGetTransformFlags((cmsHTRANSFORM)CMMcargo) & cmsFLAGS_COPY_ALPHA))\n           nalpha = 0;\n\n       strideIn = strideOut = 0;\n       for (i = 0; i < LineCount; i++) {\n\n              gin = (const cmsUInt8Number*)Input + SourceStartingOrder[0] + strideIn;\n              if (nalpha)\n                     ain = (const cmsUInt8Number*)Input + SourceStartingOrder[1] + strideIn;\n\n              gout = (cmsUInt8Number*)Output + DestStartingOrder[0] + strideOut;\n              if (nalpha)\n                     aout = (cmsUInt8Number*)Output + DestStartingOrder[1] + strideOut;\n\n              for (ii = 0; ii < PixelsPerLine; ii++) {\n\n                     *gout = *gin;\n\n                     // Handle alpha\n                     if (ain) {\n                            *aout = *ain;\n                     }\n\n                     gin += SourceIncrements[0];\n\n                     if (ain) ain += SourceIncrements[1];\n\n                     gout += DestIncrements[0];\n\n                     if (aout) aout += DestIncrements[1];\n              }\n\n              strideIn += Stride->BytesPerLineIn;\n              strideOut += Stride->BytesPerLineOut;\n       }\n}",
          "fn_code_pos": [
            [
              259,
              0
            ],
            [
              320,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FastGrayIdentity8",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "Input": "void",
              "Output": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool AllCurvesAreLinear(Curves8Data* data)\n{\n    int i, j;\n\n    for (i=0; i < 3; i++) {\n        for (j = 0; j < 256; j++) {\n            if (data ->Curves[i][j] != j) return FALSE;\n        }\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              327,
              0
            ],
            [
              339,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllCurvesAreLinear",
            "parameters": {
              "data": "Curves8Data"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nCurves8Data* ComputeCompositeCurves(cmsUInt32Number nChan,  cmsPipeline* Src)\n{\n    cmsUInt32Number i, j;\n    cmsFloat32Number InFloat[3], OutFloat[3];\n\n    Curves8Data* Data = (Curves8Data*) _cmsMallocZero(cmsGetPipelineContextID(Src), sizeof(Curves8Data));\n    if (Data == NULL) return NULL;\n\n    // Create target curves\n    for (i=0; i < 256; i++) {\n\n        for (j=0; j <nChan; j++) \n            InFloat[j] = (cmsFloat32Number) ((cmsFloat64Number) i / 255.0);\n\n        cmsPipelineEvalFloat(InFloat, OutFloat, Src);\n\n        for (j=0; j < nChan; j++)\n            Data -> Curves[j][i] = FROM_16_TO_8(_cmsSaturateWord(OutFloat[j] * 65535.0));\n    }\n\n    return Data;\n}",
          "fn_code_pos": [
            [
              342,
              0
            ],
            [
              364,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComputeCompositeCurves",
            "parameters": {
              "nChan": "cmsUInt32Number",
              "Src": "cmsPipeline"
            },
            "return_type": "Curves8Data"
          }
        },
        {
          "fn_code": "cmsBool Optimize8ByJoiningCurves(_cmsTransform2Fn* TransformFn,                                  \n                                 void** UserData,\n                                 _cmsFreeUserDataFn* FreeUserData,\n                                 cmsPipeline** Lut, \n                                 cmsUInt32Number* InputFormat, \n                                 cmsUInt32Number* OutputFormat, \n                                 cmsUInt32Number* dwFlags)    \n{\n \n    cmsPipeline* Src = *Lut;\n    cmsStage* mpe;   \n    Curves8Data* Data;\n    cmsUInt32Number nChans;\n\n    // This is a lossy optimization! does not apply in floating-point cases\n    if (T_FLOAT(*InputFormat) || T_FLOAT(*OutputFormat)) return FALSE;\n\n    // Only on 8-bit\n    if (T_BYTES(*InputFormat) != 1 ||  T_BYTES(*OutputFormat) != 1) return FALSE;\n\n    // Curves need same channels on input and output (despite extra channels may differ)\n    nChans = T_CHANNELS(*InputFormat);\n    if (nChans != T_CHANNELS(*OutputFormat)) return FALSE;\n\n    // gray and RGB \n    if (nChans != 1 && nChans != 3) return FALSE;\n   \n    //  Only curves in this LUT?\n    for (mpe = cmsPipelineGetPtrToFirstStage(Src);\n        mpe != NULL;\n        mpe = cmsStageNext(mpe)) {\n\n            if (cmsStageType(mpe) != cmsSigCurveSetElemType) return FALSE;\n    }\n   \n    Data = ComputeCompositeCurves(nChans, Src);\n    \n    *dwFlags |= cmsFLAGS_NOCACHE;\n    *dwFlags &= ~cmsFLAGS_CAN_CHANGE_FORMATTER;\n    *UserData = Data;\n    *FreeUserData = _cmsFree;\n\n    // Maybe the curves are linear at the end\n    if (nChans == 1)\n        *TransformFn = (AllCurvesAreLinear(Data) ? FastGrayIdentity8 : FastEvaluateGrayCurves8);\n    else\n        *TransformFn = (AllCurvesAreLinear(Data) ? FastRGBIdentity8 : FastEvaluateRGBCurves8);\n\n    return TRUE;\n\n}",
          "fn_code_pos": [
            [
              370,
              0
            ],
            [
              420,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Optimize8ByJoiningCurves",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeUserData": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ComputeCompositeCurves(cmsUInt32Number nChan,  cmsPipeline* Src)",
          "fn_dec_pos": [
            [
              343,
              13
            ],
            [
              343,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComputeCompositeCurves",
            "parameters": {
              "nChan": "cmsUInt32Number",
              "Src": "cmsPipeline"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\n    cmsContext ContextID;\n    int nCurves;\n    cmsUInt8Number Curves[cmsMAXCHANNELS][256];    \n\n} Curves8Data;",
          {
            "ContextID": "cmsContext",
            "nCurves": "int",
            "Curves[cmsMAXCHANNELS][256]": "cmsUInt8Number"
          },
          "Curves8Data",
          [
            24,
            0
          ],
          [
            30,
            14
          ]
        ],
        [
          "typedef struct {\n\n    cmsContext ContextID;\n    int nCurves;\n    cmsUInt8Number Curves[cmsMAXCHANNELS][256];    \n\n} Curves8Data;",
          {
            "ContextID": "cmsContext",
            "nCurves": "int",
            "Curves[cmsMAXCHANNELS][256]": "cmsUInt8Number"
          },
          "Curves8Data",
          [
            24,
            0
          ],
          [
            30,
            14
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            34,
            35
          ],
          [
            34,
            62
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            114,
            29
          ],
          [
            114,
            56
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            193,
            36
          ],
          [
            193,
            63
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            259,
            30
          ],
          [
            259,
            57
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"fast_float_internal.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/fast_float/src/fast_float_matsh.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nVXMatShaperFloatData* malloc_aligned(cmsContext ContextID)\n{\n    cmsUInt8Number* real_ptr = (cmsUInt8Number*) _cmsMallocZero(ContextID, sizeof(VXMatShaperFloatData) + 32);\n    cmsUInt8Number* aligned = (cmsUInt8Number*) (((uintptr_t)real_ptr + 16) & ~0xf);\n    VXMatShaperFloatData* p = (VXMatShaperFloatData*) aligned;\n\n    p ->real_ptr = real_ptr;\n    return p;\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              57,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "malloc_aligned",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "VXMatShaperFloatData"
          }
        },
        {
          "fn_code": "static\nvoid  FreeMatShaper(cmsContext ContextID, void* Data)\n{\n       VXMatShaperFloatData* d = (VXMatShaperFloatData*)Data;\n    \n       if (d != NULL) \n              _cmsFree(ContextID, d->real_ptr);\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              69,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FreeMatShaper",
            "parameters": {
              "ContextID": "cmsContext",
              "Data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid FillShaper(cmsFloat32Number* Table, cmsToneCurve* Curve)\n{\n    int i;\n    cmsFloat32Number R;\n\n    for (i = 0; i < MAX_NODES_IN_CURVE; i++) {\n        \n           R = (cmsFloat32Number) i / (cmsFloat32Number) (MAX_NODES_IN_CURVE - 1);\n\n        Table[i] = cmsEvalToneCurveFloat(Curve, R);\n    }\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FillShaper",
            "parameters": {
              "Table": "cmsFloat32Number",
              "Curve": "cmsToneCurve"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nVXMatShaperFloatData* SetMatShaper(cmsContext ContextID, cmsToneCurve* Curve1[3], cmsMAT3* Mat, cmsVEC3* Off, cmsToneCurve* Curve2[3])\n{\n    VXMatShaperFloatData* p;\n    int i, j;\n\n    // Allocate a big chuck of memory to store precomputed tables\n    p = malloc_aligned(ContextID);\n    if (p == NULL) return FALSE;\n\n\n    // Precompute tables\n    FillShaper(p->Shaper1R, Curve1[0]);\n    FillShaper(p->Shaper1G, Curve1[1]);\n    FillShaper(p->Shaper1B, Curve1[2]);\n\n    FillShaper(p->Shaper2R, Curve2[0]);\n    FillShaper(p->Shaper2G, Curve2[1]);\n    FillShaper(p->Shaper2B, Curve2[2]);\n \n        \n    for (i=0; i < 3; i++) {\n        for (j=0; j < 3; j++) {                     \n               p->Mat[i][j] = (cmsFloat32Number) Mat->v[i].n[j];\n        }        \n    }\n    \n  \n    for (i = 0; i < 3; i++) {\n\n           if (Off == NULL) {\n\n                  p->UseOff = FALSE;\n                  p->Off[i] = 0.0;\n           }\n           else {\n                  p->UseOff = TRUE;\n                  p->Off[i] = (cmsFloat32Number)Off->n[i];\n\n           }\n    }\n\n \n    return p;\n}",
          "fn_code_pos": [
            [
              88,
              0
            ],
            [
              132,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetMatShaper",
            "parameters": {
              "ContextID": "cmsContext",
              "Curve1": "cmsToneCurve",
              "Mat": "cmsMAT3",
              "Off": "cmsVEC3",
              "Curve2": "cmsToneCurve"
            },
            "return_type": "VXMatShaperFloatData"
          }
        },
        {
          "fn_code": "static\nvoid MatShaperFloat(struct _cmstransform_struct* CMMcargo,\n                        const void* Input,\n                        void* Output,\n                        cmsUInt32Number PixelsPerLine,\n                        cmsUInt32Number LineCount,\n                        const cmsStride* Stride)\n{    \n    VXMatShaperFloatData* p = (VXMatShaperFloatData*) _cmsGetTransformUserData(CMMcargo);\n    cmsFloat32Number l1, l2, l3;\n    cmsFloat32Number r, g, b;\n    cmsUInt32Number i, ii;\n    cmsUInt32Number SourceStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number SourceIncrements[cmsMAXCHANNELS];\n    cmsUInt32Number DestStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number DestIncrements[cmsMAXCHANNELS];\n\n    const cmsUInt8Number* rin;\n    const cmsUInt8Number* gin;\n    const cmsUInt8Number* bin;\n    const cmsUInt8Number* ain = NULL;\n\n    cmsUInt8Number* rout;\n    cmsUInt8Number* gout;\n    cmsUInt8Number* bout;\n    cmsUInt8Number* aout = NULL;\n    \n    cmsUInt32Number nchans, nalpha;\n    size_t strideIn, strideOut;\n\n    _cmsComputeComponentIncrements(cmsGetTransformInputFormat((cmsHTRANSFORM)CMMcargo), Stride->BytesPerPlaneIn, &nchans, &nalpha, SourceStartingOrder, SourceIncrements);\n    _cmsComputeComponentIncrements(cmsGetTransformOutputFormat((cmsHTRANSFORM)CMMcargo), Stride->BytesPerPlaneOut, &nchans, &nalpha, DestStartingOrder, DestIncrements);\n\n    if (!(_cmsGetTransformFlags((cmsHTRANSFORM)CMMcargo) & cmsFLAGS_COPY_ALPHA))\n        nalpha = 0;\n\n    strideIn = strideOut = 0;\n    for (i = 0; i < LineCount; i++) {\n\n        rin = (const cmsUInt8Number*)Input + SourceStartingOrder[0] + strideIn;\n        gin = (const cmsUInt8Number*)Input + SourceStartingOrder[1] + strideIn;\n        bin = (const cmsUInt8Number*)Input + SourceStartingOrder[2] + strideIn;\n\n        if (nalpha)\n            ain = (const cmsUInt8Number*)Input + SourceStartingOrder[3] + strideIn;\n\n        rout = (cmsUInt8Number*)Output + DestStartingOrder[0] + strideOut;\n        gout = (cmsUInt8Number*)Output + DestStartingOrder[1] + strideOut;\n        bout = (cmsUInt8Number*)Output + DestStartingOrder[2] + strideOut;\n\n        if (nalpha)\n            aout = (cmsUInt8Number*)Output + DestStartingOrder[3] + strideOut;\n\n        for (ii = 0; ii < PixelsPerLine; ii++) {\n\n            r = flerp(p->Shaper1R, *(cmsFloat32Number*)rin);\n            g = flerp(p->Shaper1G, *(cmsFloat32Number*)gin);\n            b = flerp(p->Shaper1B, *(cmsFloat32Number*)bin);\n\n            l1 = p->Mat[0][0] * r + p->Mat[0][1] * g + p->Mat[0][2] * b;\n            l2 = p->Mat[1][0] * r + p->Mat[1][1] * g + p->Mat[1][2] * b;\n            l3 = p->Mat[2][0] * r + p->Mat[2][1] * g + p->Mat[2][2] * b;\n\n            if (p->UseOff) {\n\n                l1 += p->Off[0];\n                l2 += p->Off[1];\n                l3 += p->Off[2];\n            }\n\n            *(cmsFloat32Number*)rout = flerp(p->Shaper2R, l1);\n            *(cmsFloat32Number*)gout = flerp(p->Shaper2G, l2);\n            *(cmsFloat32Number*)bout = flerp(p->Shaper2B, l3);\n\n            rin += SourceIncrements[0];\n            gin += SourceIncrements[1];\n            bin += SourceIncrements[2];\n\n            rout += DestIncrements[0];\n            gout += DestIncrements[1];\n            bout += DestIncrements[2];\n\n            if (ain)\n            {\n                *(cmsFloat32Number*)aout = *(cmsFloat32Number*)ain;\n                ain += SourceIncrements[3];\n                aout += DestIncrements[3];\n            }\n        }\n\n        strideIn += Stride->BytesPerLineIn;\n        strideOut += Stride->BytesPerLineOut;\n    }\n}",
          "fn_code_pos": [
            [
              137,
              0
            ],
            [
              230,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MatShaperFloat",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "Input": "void",
              "Output": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool OptimizeFloatMatrixShaper(_cmsTransform2Fn* TransformFn,                                  \n                                  void** UserData,\n                                  _cmsFreeUserDataFn* FreeUserData,\n                                  cmsPipeline** Lut, \n                                  cmsUInt32Number* InputFormat, \n                                  cmsUInt32Number* OutputFormat, \n                                  cmsUInt32Number* dwFlags)    \n{\n    cmsStage* Curve1, *Curve2;\n    cmsStage* Matrix1, *Matrix2;\n    _cmsStageMatrixData* Data1;\n    _cmsStageMatrixData* Data2;\n    cmsMAT3 res;\n    cmsBool IdentityMat = FALSE;\n    cmsPipeline* Dest, *Src;\n    cmsContext ContextID;\n    cmsUInt32Number nChans;\n    cmsFloat64Number factor = 1.0;\n\n\n    // Apply only to floating-point cases\n    if (!T_FLOAT(*InputFormat) || !T_FLOAT(*OutputFormat)) return FALSE;\n\n    // Only works on RGB to RGB and gray to gray \n    if ( !( (T_CHANNELS(*InputFormat) == 3 && T_CHANNELS(*OutputFormat) == 3))  &&\n         !( (T_CHANNELS(*InputFormat) == 1 && T_CHANNELS(*OutputFormat) == 1))) return FALSE;\n                   \n    // Only works on float \n    if (T_BYTES(*InputFormat) != 4 || T_BYTES(*OutputFormat) != 4) return FALSE;\n\n    // Seems suitable, proceed\n    Src = *Lut;\n\n    // Check for shaper-matrix-matrix-shaper structure, that is what this optimizer stands for\n    if (!cmsPipelineCheckAndRetreiveStages(Src, 4, \n        cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType, \n        &Curve1, &Matrix1, &Matrix2, &Curve2)) return FALSE;\n\n    ContextID = cmsGetPipelineContextID(Src);\n    nChans    = T_CHANNELS(*InputFormat);\n\n    // Get both matrices, which are 3x3\n    Data1 = (_cmsStageMatrixData*) cmsStageData(Matrix1);\n    Data2 = (_cmsStageMatrixData*) cmsStageData(Matrix2);\n\n    // Input offset should be zero\n    if (Data1 ->Offset != NULL) return FALSE;\n\n    if (cmsStageInputChannels(Matrix1) == 1 && cmsStageOutputChannels(Matrix2) == 1)\n    {\n        // This is a gray to gray. Just multiply    \n         factor = Data1->Double[0]*Data2->Double[0] + \n                  Data1->Double[1]*Data2->Double[1] + \n                  Data1->Double[2]*Data2->Double[2];\n\n        if (fabs(1 - factor) < (1.0 / 65535.0)) IdentityMat = TRUE;\n    }\n    else\n    {            \n        // Multiply both matrices to get the result\n        _cmsMAT3per(&res, (cmsMAT3*) Data2 ->Double, (cmsMAT3*) Data1 ->Double);\n\n        // Now the result is in res + Data2 -> Offset. Maybe is a plain identity?\n        IdentityMat = FALSE;\n        if (_cmsMAT3isIdentity(&res) && Data2 ->Offset == NULL) {\n\n            // We can get rid of full matrix\n            IdentityMat = TRUE;\n        }\n    }\n\n    // Allocate an empty LUT \n    Dest =  cmsPipelineAlloc(ContextID, nChans, nChans);\n    if (!Dest) return FALSE;\n\n    // Assemble the new LUT\n    cmsPipelineInsertStage(Dest, cmsAT_BEGIN, cmsStageDup(Curve1));\n    \n    if (!IdentityMat) {\n\n        if (nChans == 1)\n             cmsPipelineInsertStage(Dest, cmsAT_END, \n                    cmsStageAllocMatrix(ContextID, 1, 1, (const cmsFloat64Number*) &factor, Data2->Offset));\n        else\n            cmsPipelineInsertStage(Dest, cmsAT_END, \n                    cmsStageAllocMatrix(ContextID, 3, 3, (const cmsFloat64Number*) &res, Data2 ->Offset));\n    } \n\n\n    cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageDup(Curve2));\n\n    // If identity on matrix, we can further optimize the curves, so call the join curves routine\n    if (IdentityMat) {\n\n           OptimizeFloatByJoiningCurves(TransformFn, UserData, FreeUserData, &Dest, InputFormat, OutputFormat, dwFlags);\n    }\n    else {\n        _cmsStageToneCurvesData* mpeC1 = (_cmsStageToneCurvesData*) cmsStageData(Curve1);\n        _cmsStageToneCurvesData* mpeC2 = (_cmsStageToneCurvesData*) cmsStageData(Curve2);\n\n        // In this particular optimization, cache does not help as it takes more time to deal with\n        // the cache than with the pixel handling\n        *dwFlags |= cmsFLAGS_NOCACHE;\n\n        // Setup the optimization routines\n        *UserData = SetMatShaper(ContextID, mpeC1 ->TheCurves, &res, (cmsVEC3*) Data2 ->Offset, mpeC2->TheCurves);\n        *FreeUserData = FreeMatShaper; \n\n        *TransformFn = MatShaperFloat;         \n    }\n\n    *dwFlags &= ~cmsFLAGS_CAN_CHANGE_FORMATTER;\n    cmsPipelineFree(Src);\n    *Lut = Dest;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              234,
              0
            ],
            [
              349,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OptimizeFloatMatrixShaper",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeUserData": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "malloc_aligned(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              49,
              22
            ],
            [
              49,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "malloc_aligned",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "SetMatShaper(cmsContext ContextID, cmsToneCurve* Curve1[3], cmsMAT3* Mat, cmsVEC3* Off, cmsToneCurve* Curve2[3])",
          "fn_dec_pos": [
            [
              89,
              22
            ],
            [
              89,
              134
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetMatShaper",
            "parameters": {
              "ContextID": "cmsContext",
              "Curve1": "cmsToneCurve",
              "Mat": "cmsMAT3",
              "Off": "cmsVEC3",
              "Curve2": "cmsToneCurve"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\n   \n    cmsFloat32Number Mat[3][3];     \n    cmsFloat32Number Off[3];\n\n    cmsFloat32Number Shaper1R[MAX_NODES_IN_CURVE]; \n    cmsFloat32Number Shaper1G[MAX_NODES_IN_CURVE];\n    cmsFloat32Number Shaper1B[MAX_NODES_IN_CURVE];\n\n    cmsFloat32Number Shaper2R[MAX_NODES_IN_CURVE];    \n    cmsFloat32Number Shaper2G[MAX_NODES_IN_CURVE];\n    cmsFloat32Number Shaper2B[MAX_NODES_IN_CURVE];\n\n    cmsBool UseOff;\n\n    void * real_ptr;\n\n} VXMatShaperFloatData;",
          {
            "Mat[3][3]": "cmsFloat32Number",
            "Off[3]": "cmsFloat32Number",
            "Shaper1R[MAX_NODES_IN_CURVE]": "cmsFloat32Number",
            "Shaper1G[MAX_NODES_IN_CURVE]": "cmsFloat32Number",
            "Shaper1B[MAX_NODES_IN_CURVE]": "cmsFloat32Number",
            "Shaper2R[MAX_NODES_IN_CURVE]": "cmsFloat32Number",
            "Shaper2G[MAX_NODES_IN_CURVE]": "cmsFloat32Number",
            "Shaper2B[MAX_NODES_IN_CURVE]": "cmsFloat32Number",
            "UseOff": "cmsBool",
            "* real_ptr": "void"
          },
          "VXMatShaperFloatData",
          [
            27,
            0
          ],
          [
            45,
            23
          ]
        ],
        [
          "typedef struct {\n\n   \n    cmsFloat32Number Mat[3][3];     \n    cmsFloat32Number Off[3];\n\n    cmsFloat32Number Shaper1R[MAX_NODES_IN_CURVE]; \n    cmsFloat32Number Shaper1G[MAX_NODES_IN_CURVE];\n    cmsFloat32Number Shaper1B[MAX_NODES_IN_CURVE];\n\n    cmsFloat32Number Shaper2R[MAX_NODES_IN_CURVE];    \n    cmsFloat32Number Shaper2G[MAX_NODES_IN_CURVE];\n    cmsFloat32Number Shaper2B[MAX_NODES_IN_CURVE];\n\n    cmsBool UseOff;\n\n    void * real_ptr;\n\n} VXMatShaperFloatData;",
          {
            "Mat[3][3]": "cmsFloat32Number",
            "Off[3]": "cmsFloat32Number",
            "Shaper1R[MAX_NODES_IN_CURVE]": "cmsFloat32Number",
            "Shaper1G[MAX_NODES_IN_CURVE]": "cmsFloat32Number",
            "Shaper1B[MAX_NODES_IN_CURVE]": "cmsFloat32Number",
            "Shaper2R[MAX_NODES_IN_CURVE]": "cmsFloat32Number",
            "Shaper2G[MAX_NODES_IN_CURVE]": "cmsFloat32Number",
            "Shaper2B[MAX_NODES_IN_CURVE]": "cmsFloat32Number",
            "UseOff": "cmsBool",
            "* real_ptr": "void"
          },
          "VXMatShaperFloatData",
          [
            27,
            0
          ],
          [
            45,
            23
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            138,
            20
          ],
          [
            138,
            47
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"fast_float_internal.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/fast_float/src/fast_float_separate.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nint trueBytesSize(cmsUInt32Number Format)\n{\n       int fmt_bytes = T_BYTES(Format);\n\n       // For double, the T_BYTES field returns zero\n       if (fmt_bytes == 0)\n              return sizeof(double);\n\n       // Otherwise, it is already correct for all formats\n       return fmt_bytes;\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              59,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "trueBytesSize",
            "parameters": {
              "Format": "cmsUInt32Number"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nvoid ComputeIncrementsForChunky(cmsUInt32Number Format, \n                                cmsUInt32Number BytesPerPlane,\n                                cmsUInt32Number* nChannels,\n                                cmsUInt32Number* nAlpha,\n                                cmsUInt32Number ComponentStartingOrder[], \n                                cmsUInt32Number ComponentPointerIncrements[])\n{\n       int extra = T_EXTRA(Format);\n       int channels = T_CHANNELS(Format);\n       int total_chans = channels + extra;\n       int i;       \n       int channelSize = trueBytesSize(Format);\n       int pixelSize = channelSize * total_chans;\n       \n       UNUSED_PARAMETER(BytesPerPlane);\n\n       // Setup the counts\n       if (nChannels != NULL)\n              *nChannels = channels;\n\n       if (nAlpha != NULL)\n              *nAlpha = extra;\n\n       // Separation is independent of starting point and only depends on channel size\n       for (i = 0; i < total_chans; i++)\n              ComponentPointerIncrements[i] = pixelSize;\n\n       // Handle do swap\n       for (i = 0; i < total_chans; i++)\n       {\n              if (T_DOSWAP(Format)) {\n                     ComponentStartingOrder[i] = total_chans - i - 1;\n              }\n              else {\n                     ComponentStartingOrder[i] = i;\n              }\n       }\n\n       // Handle swap first (ROL of positions), example CMYK -> KCMY | 0123 -> 3012\n       if (T_SWAPFIRST(Format)) {\n              \n              cmsUInt32Number tmp = ComponentStartingOrder[0];\n              for (i = 0; i < total_chans-1; i++)\n                     ComponentStartingOrder[i] = ComponentStartingOrder[i + 1];\n\n              ComponentStartingOrder[total_chans - 1] = tmp;\n       }\n\n       // Handle size\n       if (channelSize > 1)\n              for (i = 0; i < total_chans; i++) {\n                     ComponentStartingOrder[i] *= channelSize;\n              }\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              121,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComputeIncrementsForChunky",
            "parameters": {
              "Format": "cmsUInt32Number",
              "BytesPerPlane": "cmsUInt32Number",
              "nChannels": "cmsUInt32Number",
              "nAlpha": "cmsUInt32Number",
              "ComponentStartingOrder": "cmsUInt32Number",
              "ComponentPointerIncrements": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid ComputeIncrementsForPlanar(cmsUInt32Number Format, \n                                cmsUInt32Number BytesPerPlane,\n                                cmsUInt32Number* nChannels,\n                                cmsUInt32Number* nAlpha,\n                                cmsUInt32Number ComponentStartingOrder[], \n                                cmsUInt32Number ComponentPointerIncrements[])\n{\n       int extra = T_EXTRA(Format);\n       int channels = T_CHANNELS(Format);\n       int total_chans = channels + extra;\n       int i;\n       int channelSize = trueBytesSize(Format);\n       \n       // Setup the counts\n       if (nChannels != NULL) \n              *nChannels = channels;\n\n       if (nAlpha != NULL) \n              *nAlpha = extra;\n\n       // Separation is independent of starting point and only depends on channel size\n       for (i = 0; i < total_chans; i++)\n              ComponentPointerIncrements[i] = channelSize;\n\n       // Handle do swap\n       for (i = 0; i < total_chans; i++)\n       {\n              if (T_DOSWAP(Format)) {\n                     ComponentStartingOrder[i] = total_chans - i - 1;\n              }\n              else {\n                     ComponentStartingOrder[i] = i;\n              }\n       }\n\n       // Handle swap first (ROL of positions), example CMYK -> KCMY | 0123 -> 3012\n       if (T_SWAPFIRST(Format)) {\n\n              cmsUInt32Number tmp = ComponentStartingOrder[0];\n              for (i = 0; i < total_chans - 1; i++)\n                     ComponentStartingOrder[i] = ComponentStartingOrder[i + 1];\n\n              ComponentStartingOrder[total_chans - 1] = tmp;\n       }\n\n       // Handle size\n       for (i = 0; i < total_chans; i++) {\n              ComponentStartingOrder[i] *= BytesPerPlane;\n       }\n}",
          "fn_code_pos": [
            [
              126,
              0
            ],
            [
              176,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComputeIncrementsForPlanar",
            "parameters": {
              "Format": "cmsUInt32Number",
              "BytesPerPlane": "cmsUInt32Number",
              "nChannels": "cmsUInt32Number",
              "nAlpha": "cmsUInt32Number",
              "ComponentStartingOrder": "cmsUInt32Number",
              "ComponentPointerIncrements": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "CMSCHECKPOINT void  CMSEXPORT _cmsComputeComponentIncrements(cmsUInt32Number Format,\n                                     cmsUInt32Number BytesPerPlane,\n                                     cmsUInt32Number* nChannels,\n                                     cmsUInt32Number* nAlpha,\n                                     cmsUInt32Number ComponentStartingOrder[], \n                                     cmsUInt32Number ComponentPointerIncrements[])\n{\n       if (T_PLANAR(Format)) {\n\n              ComputeIncrementsForPlanar(Format,  BytesPerPlane, nChannels, nAlpha, ComponentStartingOrder, ComponentPointerIncrements);\n       }\n       else {\n              ComputeIncrementsForChunky(Format,  BytesPerPlane, nChannels, nAlpha, ComponentStartingOrder, ComponentPointerIncrements);\n       }\n\n}",
          "fn_code_pos": [
            [
              181,
              0
            ],
            [
              196,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsComputeComponentIncrements",
            "parameters": {
              "Format": "cmsUInt32Number",
              "BytesPerPlane": "cmsUInt32Number",
              "nChannels": "cmsUInt32Number",
              "nAlpha": "cmsUInt32Number",
              "ComponentStartingOrder": "cmsUInt32Number",
              "ComponentPointerIncrements": "cmsUInt32Number"
            },
            "return_type": "CMSCHECKPOINT"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"fast_float_internal.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/fast_float/src/fast_8_matsh_sse.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nXMatShaper8Data* malloc_aligned(cmsContext ContextID)\n{\n    cmsUInt8Number* real_ptr = (cmsUInt8Number*) _cmsMallocZero(ContextID, sizeof(XMatShaper8Data) + 32);\n    cmsUInt8Number* aligned = (cmsUInt8Number*) (((uintptr_t)real_ptr + 16) & ~0xf);\n    XMatShaper8Data* p = (XMatShaper8Data*) aligned;\n\n    p ->real_ptr = real_ptr;\n    return p;\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              69,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "malloc_aligned",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "XMatShaper8Data"
          }
        },
        {
          "fn_code": "static\nvoid free_aligned(XMatShaper8Data* a)\n{\n    _cmsFree(a->ContextID, a->real_ptr);\n}",
          "fn_code_pos": [
            [
              71,
              0
            ],
            [
              75,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "free_aligned",
            "parameters": {
              "a": "XMatShaper8Data"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid FreeMatShaper(cmsContext ContextID, void* Data)\n{\n    UNUSED_PARAMETER(ContextID);\n\n    if (Data != NULL) free_aligned((XMatShaper8Data*) Data);\n}",
          "fn_code_pos": [
            [
              79,
              0
            ],
            [
              85,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FreeMatShaper",
            "parameters": {
              "ContextID": "cmsContext",
              "Data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid FillFirstShaper(cmsFloat32Number* Table, cmsToneCurve* Curve)\n{\n    cmsInt32Number i;\n    cmsFloat32Number R;\n\n    for (i = 0; i < 256; i++) {\n\n        R = (cmsFloat32Number)(i / 255.0);\n        Table[i] = cmsEvalToneCurveFloat(Curve, R);\n    }\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              100,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FillFirstShaper",
            "parameters": {
              "Table": "cmsFloat32Number",
              "Curve": "cmsToneCurve"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid FillSecondShaper(cmsUInt8Number* Table, cmsToneCurve* Curve)\n{\n    int i;\n    cmsFloat32Number R, Val;\n    cmsInt32Number w;\n\n    for (i=0; i < 0x4001; i++) {\n\n        R   = (cmsFloat32Number) (i / 16384.0f);\n        Val = cmsEvalToneCurveFloat(Curve, R);    \n        w = (cmsInt32Number) (Val * 255.0f + 0.5f);\n        if (w < 0) w = 0;\n        if (w > 255) w = 255;\n\n        Table[i] = (cmsInt8Number) w;\n\n    }\n}",
          "fn_code_pos": [
            [
              104,
              0
            ],
            [
              122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FillSecondShaper",
            "parameters": {
              "Table": "cmsUInt8Number",
              "Curve": "cmsToneCurve"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nXMatShaper8Data* SetMatShaper(cmsContext ContextID, cmsToneCurve* Curve1[3], cmsMAT3* Mat, cmsVEC3* Off, cmsToneCurve* Curve2[3])\n{\n    XMatShaper8Data* p;\n    int i, j;\n\n    // Allocate a big chuck of memory to store precomputed tables\n    p = malloc_aligned(ContextID);\n    if (p == NULL) return FALSE;\n\n    p -> ContextID = ContextID;\n\n    // Precompute tables\n    FillFirstShaper(p ->Shaper1R, Curve1[0]);\n    FillFirstShaper(p ->Shaper1G, Curve1[1]);\n    FillFirstShaper(p ->Shaper1B, Curve1[2]);\n\n    FillSecondShaper(p ->Shaper2R, Curve2[0]);\n    FillSecondShaper(p ->Shaper2G, Curve2[1]);\n    FillSecondShaper(p ->Shaper2B, Curve2[2]);\n \n        \n    // Convert matrix to float\n    for (i=0; i < 3; i++) {\n        for (j=0; j < 3; j++) {         \n            p ->Mat[j][i] = (cmsFloat32Number) Mat->v[i].n[j];\n        }        \n    }\n      \n    // Roundoff\n    for (i=0; i < 3; i++) {\n\n        if (Off == NULL) {   \n            \n            p->Mat[3][i] = 0.0f;\n        }\n        else {                              \n            p->Mat[3][i] = (cmsFloat32Number)Off->n[i];\n        }\n    }\n\n \n    return p;\n}",
          "fn_code_pos": [
            [
              125,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetMatShaper",
            "parameters": {
              "ContextID": "cmsContext",
              "Curve1": "cmsToneCurve",
              "Mat": "cmsMAT3",
              "Off": "cmsVEC3",
              "Curve2": "cmsToneCurve"
            },
            "return_type": "XMatShaper8Data"
          }
        },
        {
          "fn_code": "static\nvoid MatShaperXform8SSE(struct _cmstransform_struct *CMMcargo,\n                     const void* Input,\n                     void* Output,\n                     cmsUInt32Number PixelsPerLine,\n                     cmsUInt32Number LineCount,\n                     const cmsStride* Stride)\n{    \n    XMatShaper8Data* p = (XMatShaper8Data*) _cmsGetTransformUserData(CMMcargo);\n\n    cmsUInt32Number i, ii;\n\n    cmsUInt32Number SourceStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number SourceIncrements[cmsMAXCHANNELS];\n    cmsUInt32Number DestStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number DestIncrements[cmsMAXCHANNELS];\n\n    const cmsUInt8Number* rin;\n    const cmsUInt8Number* gin;\n    const cmsUInt8Number* bin;\n    const cmsUInt8Number* ain = NULL;\n\n    cmsUInt8Number* rout;\n    cmsUInt8Number* gout;\n    cmsUInt8Number* bout;\n    cmsUInt8Number* aout = NULL;\n\n    cmsUInt32Number nalpha;\n    size_t strideIn, strideOut;\n \n \n    __m128 mat0 = _mm_load_ps(p->Mat[0]);\n    __m128 mat1 = _mm_load_ps(p->Mat[1]);\n    __m128 mat2 = _mm_load_ps(p->Mat[2]);\n    __m128 mat3 = _mm_load_ps(p->Mat[3]);\n\n    __m128 zero = _mm_setzero_ps();\n    __m128 one = _mm_set1_ps(1.0f);\n    __m128 scale = _mm_set1_ps((cmsFloat32Number)0x4000);\n\n    cmsUInt8Number buffer[32];\n    cmsUInt32Number* output_index = (cmsUInt32Number*)(((uintptr_t)buffer + 16) & ~0xf);\n\n\n    _cmsComputeComponentIncrements(cmsGetTransformInputFormat((cmsHTRANSFORM)CMMcargo), Stride->BytesPerPlaneIn, NULL, &nalpha, SourceStartingOrder, SourceIncrements);\n    _cmsComputeComponentIncrements(cmsGetTransformOutputFormat((cmsHTRANSFORM)CMMcargo), Stride->BytesPerPlaneOut, NULL, &nalpha, DestStartingOrder, DestIncrements);\n\n    if (!(_cmsGetTransformFlags((cmsHTRANSFORM)CMMcargo) & cmsFLAGS_COPY_ALPHA))\n        nalpha = 0;\n\n    strideIn = strideOut = 0;\n    for (i = 0; i < LineCount; i++) {\n\n           rin = (const cmsUInt8Number*)Input + SourceStartingOrder[0] + strideIn;\n           gin = (const cmsUInt8Number*)Input + SourceStartingOrder[1] + strideIn;\n           bin = (const cmsUInt8Number*)Input + SourceStartingOrder[2] + strideIn;\n           if (nalpha)\n                  ain = (const cmsUInt8Number*)Input + SourceStartingOrder[3] + strideIn;\n\n\n           rout = (cmsUInt8Number*)Output + DestStartingOrder[0] + strideOut;\n           gout = (cmsUInt8Number*)Output + DestStartingOrder[1] + strideOut;\n           bout = (cmsUInt8Number*)Output + DestStartingOrder[2] + strideOut;\n           if (nalpha)\n                  aout = (cmsUInt8Number*)Output + DestStartingOrder[3] + strideOut;\n           \n           /**\n           * Prefetch\n           */\n           __m128 rvector = _mm_set1_ps(p->Shaper1R[*rin]);\n           __m128 gvector = _mm_set1_ps(p->Shaper1G[*gin]);\n           __m128 bvector = _mm_set1_ps(p->Shaper1B[*bin]);\n        \n           for (ii = 0; ii < PixelsPerLine; ii++) {\n                                        \n               __m128 el1 = _mm_mul_ps(rvector, mat0);\n               __m128 el2 = _mm_mul_ps(gvector, mat1);\n               __m128 el3 = _mm_mul_ps(bvector, mat2);\n               \n               __m128 sum = _mm_add_ps(el1, _mm_add_ps(el2, _mm_add_ps(el3, mat3)));\n\n               __m128 out = _mm_min_ps(_mm_max_ps(sum, zero), one);\n\n               out = _mm_mul_ps(out, scale);\n\n               /**\n               * Rounding and converting to index. \n               * Actually this is a costly instruction that may be blocking performance\n               */\n               _mm_store_si128((__m128i*)output_index, _mm_cvtps_epi32(out));\n\n           \n               // Handle alpha\n               if (ain) {\n                   *aout = *ain;\n               }\n\n               rin += SourceIncrements[0];\n               gin += SourceIncrements[1];\n               bin += SourceIncrements[2];\n               if (ain) ain += SourceIncrements[3];\n\n               /**\n               * Take next value whilst store is being performed\n               */\n               if (ii < PixelsPerLine - 1)\n               {\n                   rvector = _mm_set1_ps(p->Shaper1R[*rin]);\n                   gvector = _mm_set1_ps(p->Shaper1G[*gin]);\n                   bvector = _mm_set1_ps(p->Shaper1B[*bin]);\n               }\n\n               *rout = p->Shaper2R[output_index[0]];\n               *gout = p->Shaper2G[output_index[1]];\n               *bout = p->Shaper2B[output_index[2]];\n\n               rout += DestIncrements[0];\n               gout += DestIncrements[1];\n               bout += DestIncrements[2];\n               if (aout) aout += DestIncrements[3];\n           }\n\n           strideIn += Stride->BytesPerLineIn;\n           strideOut += Stride->BytesPerLineOut;\n    }\n}",
          "fn_code_pos": [
            [
              172,
              0
            ],
            [
              297,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MatShaperXform8SSE",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "Input": "void",
              "Output": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool IsSSE2Available(void)\n{\n#ifdef _MSC_VER\n    int cpuinfo[4];\n\n    __cpuid(cpuinfo, 1);\n    if (!(cpuinfo[3] & (1 << 26))) return FALSE;\n    return TRUE;\n\n#else\n  unsigned int level = 1u;\n  unsigned int eax, ebx, ecx, edx;\n  unsigned int bits = (1u << 26);\n  unsigned int max = __get_cpuid_max(0, NULL);\n  if (level > max) {\n    return FALSE;\n  }\n  __cpuid_count(level, 0, eax, ebx, ecx, edx);\n  return (edx & bits) == bits;\n#endif\n}",
          "fn_code_pos": [
            [
              300,
              0
            ],
            [
              321,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsSSE2Available",
            "parameters": {},
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool Optimize8MatrixShaperSSE(_cmsTransform2Fn* TransformFn,                                  \n                                  void** UserData,\n                                  _cmsFreeUserDataFn* FreeUserData,\n                                  cmsPipeline** Lut, \n                                  cmsUInt32Number* InputFormat, \n                                  cmsUInt32Number* OutputFormat, \n                                  cmsUInt32Number* dwFlags)    \n{\n    cmsStage* Curve1, *Curve2;\n    cmsStage* Matrix1, *Matrix2;\n    _cmsStageMatrixData* Data1;\n    _cmsStageMatrixData* Data2;\n    cmsMAT3 res;\n    cmsBool IdentityMat = FALSE;\n    cmsPipeline* Dest, *Src;\n    cmsContext ContextID;\n    cmsUInt32Number nChans;\n    \n    // Check for SSE2 support\n    if (!(IsSSE2Available())) return FALSE;\n\n    // Only works on 3 to 3, probably RGB \n    if ( !( (T_CHANNELS(*InputFormat) == 3 && T_CHANNELS(*OutputFormat) == 3) ) ) return FALSE;\n                   \n    // Only works on 8 bit input\n    if (T_BYTES(*InputFormat) != 1 || T_BYTES(*OutputFormat) != 1) return FALSE;\n\n    // Seems suitable, proceed\n    Src = *Lut;\n\n    // Check for shaper-matrix-matrix-shaper structure, that is what this optimizer stands for\n    if (!cmsPipelineCheckAndRetreiveStages(Src, 4, \n        cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType, \n        &Curve1, &Matrix1, &Matrix2, &Curve2)) return FALSE;\n\n    ContextID = cmsGetPipelineContextID(Src);\n    nChans    = T_CHANNELS(*InputFormat);\n\n    // Get both matrices, which are 3x3\n    Data1 = (_cmsStageMatrixData*) cmsStageData(Matrix1);\n    Data2 = (_cmsStageMatrixData*) cmsStageData(Matrix2);\n\n    // Input offset should be zero\n    if (Data1->Offset != NULL) return FALSE;\n\n    // Multiply both matrices to get the result\n    _cmsMAT3per(&res, (cmsMAT3*)Data2->Double, (cmsMAT3*)Data1->Double);\n\n    // Now the result is in res + Data2 -> Offset. Maybe is a plain identity?\n    IdentityMat = FALSE;\n    if (_cmsMAT3isIdentity(&res) && Data2->Offset == NULL) {\n\n        // We can get rid of full matrix\n        IdentityMat = TRUE;\n    }\n\n    // Allocate an empty LUT \n    Dest =  cmsPipelineAlloc(ContextID, nChans, nChans);\n    if (!Dest) return FALSE;\n\n    // Assamble the new LUT\n    cmsPipelineInsertStage(Dest, cmsAT_BEGIN, cmsStageDup(Curve1));\n    \n    if (!IdentityMat) {\n\n        cmsPipelineInsertStage(Dest, cmsAT_END,\n                    cmsStageAllocMatrix(ContextID, 3, 3, (const cmsFloat64Number*) &res, Data2 ->Offset));\n    } \n\n\n    cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageDup(Curve2));\n\n    // If identity on matrix, we can further optimize the curves, so call the join curves routine\n    if (IdentityMat) {\n\n      Optimize8ByJoiningCurves(TransformFn, UserData, FreeUserData, &Dest, InputFormat, OutputFormat, dwFlags);\n    }\n    else {\n        _cmsStageToneCurvesData* mpeC1 = (_cmsStageToneCurvesData*) cmsStageData(Curve1);\n        _cmsStageToneCurvesData* mpeC2 = (_cmsStageToneCurvesData*) cmsStageData(Curve2);\n                \n        // In this particular optimization, cache does not help as it takes more time to deal with \n        // the cache than with the pixel handling\n        *dwFlags |= cmsFLAGS_NOCACHE;\n  \n\n        // Setup the optimizarion routines\n        *UserData = SetMatShaper(ContextID, mpeC1 ->TheCurves, &res, (cmsVEC3*) Data2 ->Offset, mpeC2->TheCurves);\n        *FreeUserData = FreeMatShaper; \n\n        *TransformFn = MatShaperXform8SSE;         \n    }\n\n    *dwFlags &= ~cmsFLAGS_CAN_CHANGE_FORMATTER;\n    cmsPipelineFree(Src);\n    *Lut = Dest;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              325,
              0
            ],
            [
              422,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Optimize8MatrixShaperSSE",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeUserData": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "malloc_aligned(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              61,
              17
            ],
            [
              61,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "malloc_aligned",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "SetMatShaper(cmsContext ContextID, cmsToneCurve* Curve1[3], cmsMAT3* Mat, cmsVEC3* Off, cmsToneCurve* Curve2[3])",
          "fn_dec_pos": [
            [
              126,
              17
            ],
            [
              126,
              129
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetMatShaper",
            "parameters": {
              "ContextID": "cmsContext",
              "Curve1": "cmsToneCurve",
              "Mat": "cmsMAT3",
              "Off": "cmsVEC3",
              "Curve2": "cmsToneCurve"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\n    // This is for SSE, MUST be aligned at 16 bit boundary\n    \n    cmsFloat32Number Mat[4][4];     // n.14 to n.14 (needs a saturation after that)\n\n    void * real_ptr;\n    \n    cmsContext ContextID;\n\n    cmsFloat32Number Shaper1R[256];  // from 0..255 to 1.14  (0.0...1.0)\n    cmsFloat32Number Shaper1G[256];\n    cmsFloat32Number Shaper1B[256];\n    \n    cmsUInt8Number Shaper2R[0x4001];    // 1.14 to 0..255 \n    cmsUInt8Number Shaper2G[0x4001];\n    cmsUInt8Number Shaper2B[0x4001];    \n\n} XMatShaper8Data;",
          {
            "Mat[4][4]": "cmsFloat32Number",
            "* real_ptr": "void",
            "ContextID": "cmsContext",
            "Shaper1R[256]": "cmsFloat32Number",
            "Shaper1G[256]": "cmsFloat32Number",
            "Shaper1B[256]": "cmsFloat32Number",
            "Shaper2R[0x4001]": "cmsUInt8Number",
            "Shaper2G[0x4001]": "cmsUInt8Number",
            "Shaper2B[0x4001]": "cmsUInt8Number"
          },
          "XMatShaper8Data",
          [
            39,
            0
          ],
          [
            57,
            18
          ]
        ],
        [
          "typedef struct {\n\n    // This is for SSE, MUST be aligned at 16 bit boundary\n    \n    cmsFloat32Number Mat[4][4];     // n.14 to n.14 (needs a saturation after that)\n\n    void * real_ptr;\n    \n    cmsContext ContextID;\n\n    cmsFloat32Number Shaper1R[256];  // from 0..255 to 1.14  (0.0...1.0)\n    cmsFloat32Number Shaper1G[256];\n    cmsFloat32Number Shaper1B[256];\n    \n    cmsUInt8Number Shaper2R[0x4001];    // 1.14 to 0..255 \n    cmsUInt8Number Shaper2G[0x4001];\n    cmsUInt8Number Shaper2B[0x4001];    \n\n} XMatShaper8Data;",
          {
            "Mat[4][4]": "cmsFloat32Number",
            "* real_ptr": "void",
            "ContextID": "cmsContext",
            "Shaper1R[256]": "cmsFloat32Number",
            "Shaper1G[256]": "cmsFloat32Number",
            "Shaper1B[256]": "cmsFloat32Number",
            "Shaper2R[0x4001]": "cmsUInt8Number",
            "Shaper2G[0x4001]": "cmsUInt8Number",
            "Shaper2B[0x4001]": "cmsUInt8Number"
          },
          "XMatShaper8Data",
          [
            39,
            0
          ],
          [
            57,
            18
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            173,
            24
          ],
          [
            173,
            51
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"fast_float_internal.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <intrin.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <x86intrin.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <cpuid.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <emmintrin.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/fast_float/src/fast_float_tethra.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nFloatCLUTData* FloatCLUTAlloc(cmsContext ContextID, const cmsInterpParams* p)\n{\n    FloatCLUTData* fd;\n\n    fd = (FloatCLUTData*) _cmsMallocZero(ContextID, sizeof(FloatCLUTData));\n    if (fd == NULL) return NULL;\n    \n    fd ->ContextID = ContextID;\n    fd ->p = p;\n    \n    return fd;\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              44,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FloatCLUTAlloc",
            "parameters": {
              "ContextID": "cmsContext",
              "p": "cmsInterpParams"
            },
            "return_type": "FloatCLUTData"
          }
        },
        {
          "fn_code": "static\nint XFormSampler(CMSREGISTER const cmsFloat32Number In[], CMSREGISTER cmsFloat32Number Out[], CMSREGISTER void* Cargo)\n{    \n    cmsPipelineEvalFloat(In, Out, (cmsPipeline*) Cargo);\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              53,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "XFormSampler",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nvoid FloatCLUTEval(struct _cmstransform_struct* CMMcargo,\n                        const void* Input,\n                        void* Output,\n                        cmsUInt32Number PixelsPerLine,\n                        cmsUInt32Number LineCount,\n                        const cmsStride* Stride)\n\n{\n\n    FloatCLUTData* pfloat = (FloatCLUTData*)_cmsGetTransformUserData(CMMcargo);\n\n    cmsFloat32Number        r, g, b;\n    cmsFloat32Number        px, py, pz;\n    int                     x0, y0, z0;\n    int                     X0, Y0, Z0, X1, Y1, Z1;\n    cmsFloat32Number        rx, ry, rz;\n    cmsFloat32Number        c0, c1 = 0, c2 = 0, c3 = 0;\n    cmsUInt32Number         OutChan;\n\n    const cmsInterpParams* p = pfloat->p;\n    cmsUInt32Number        TotalOut = p->nOutputs;\n    cmsUInt32Number        TotalPlusAlpha;\n    const cmsFloat32Number* LutTable = (const cmsFloat32Number*)p->Table;\n\n    cmsUInt32Number       i, ii;\n    const cmsUInt8Number* rin;\n    const cmsUInt8Number* gin;\n    const cmsUInt8Number* bin;\n    const cmsUInt8Number* ain = NULL;\n\n    cmsUInt8Number* out[cmsMAXCHANNELS];\n    cmsUInt32Number SourceStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number SourceIncrements[cmsMAXCHANNELS];\n    cmsUInt32Number DestStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number DestIncrements[cmsMAXCHANNELS];\n\n    cmsUInt32Number InputFormat = cmsGetTransformInputFormat((cmsHTRANSFORM)CMMcargo);\n    cmsUInt32Number OutputFormat = cmsGetTransformOutputFormat((cmsHTRANSFORM)CMMcargo);\n\n    cmsUInt32Number nchans, nalpha;\n    size_t strideIn, strideOut;\n                                                        \n    _cmsComputeComponentIncrements(InputFormat, Stride->BytesPerPlaneIn, &nchans, &nalpha, SourceStartingOrder, SourceIncrements);\n    _cmsComputeComponentIncrements(OutputFormat, Stride->BytesPerPlaneOut, &nchans, &nalpha, DestStartingOrder, DestIncrements);\n\n    if (!(_cmsGetTransformFlags((cmsHTRANSFORM)CMMcargo) & cmsFLAGS_COPY_ALPHA))\n        nalpha = 0;\n\n    strideIn = strideOut = 0;\n    for (i = 0; i < LineCount; i++) {\n\n        rin = (const cmsUInt8Number*)Input + SourceStartingOrder[0] + strideIn;\n        gin = (const cmsUInt8Number*)Input + SourceStartingOrder[1] + strideIn;\n        bin = (const cmsUInt8Number*)Input + SourceStartingOrder[2] + strideIn;\n        if (nalpha)\n            ain = (const cmsUInt8Number*)Input + SourceStartingOrder[3] + strideIn;\n\n        TotalPlusAlpha = TotalOut;\n        if (ain) TotalPlusAlpha++;\n\n        for (ii = 0; ii < TotalPlusAlpha; ii++)\n            out[ii] = (cmsUInt8Number*)Output + DestStartingOrder[ii] + strideOut;\n\n        for (ii = 0; ii < PixelsPerLine; ii++) {\n\n            r = fclamp(*(cmsFloat32Number*)rin);\n            g = fclamp(*(cmsFloat32Number*)gin);\n            b = fclamp(*(cmsFloat32Number*)bin);\n\n            rin += SourceIncrements[0];\n            gin += SourceIncrements[1];\n            bin += SourceIncrements[2];\n\n            px = r * p->Domain[0];\n            py = g * p->Domain[1];\n            pz = b * p->Domain[2];\n            \n            x0 = (int) floorf(px); rx = (px - (cmsFloat32Number)x0);\n            y0 = (int) floorf(py); ry = (py - (cmsFloat32Number)y0);\n            z0 = (int) floorf(pz); rz = (pz - (cmsFloat32Number)z0);\n            \n\n            X0 = p->opta[2] * x0;\n            X1 = X0 + (r >= 1.0 ? 0 : p->opta[2]);\n\n            Y0 = p->opta[1] * y0;\n            Y1 = Y0 + (g >= 1.0 ? 0 : p->opta[1]);\n\n            Z0 = p->opta[0] * z0;\n            Z1 = Z0 + (b >= 1.0 ? 0 : p->opta[0]);\n\n            for (OutChan = 0; OutChan < TotalOut; OutChan++) {\n\n                // These are the 6 Tetrahedral\n\n                c0 = DENS(X0, Y0, Z0);\n\n                if (rx >= ry && ry >= rz) {\n\n                    c1 = DENS(X1, Y0, Z0) - c0;\n                    c2 = DENS(X1, Y1, Z0) - DENS(X1, Y0, Z0);\n                    c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);\n\n                }\n                else\n                    if (rx >= rz && rz >= ry) {\n\n                        c1 = DENS(X1, Y0, Z0) - c0;\n                        c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);\n                        c3 = DENS(X1, Y0, Z1) - DENS(X1, Y0, Z0);\n\n                    }\n                    else\n                        if (rz >= rx && rx >= ry) {\n\n                            c1 = DENS(X1, Y0, Z1) - DENS(X0, Y0, Z1);\n                            c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);\n                            c3 = DENS(X0, Y0, Z1) - c0;\n\n                        }\n                        else\n                            if (ry >= rx && rx >= rz) {\n\n                                c1 = DENS(X1, Y1, Z0) - DENS(X0, Y1, Z0);\n                                c2 = DENS(X0, Y1, Z0) - c0;\n                                c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);\n\n                            }\n                            else\n                                if (ry >= rz && rz >= rx) {\n\n                                    c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);\n                                    c2 = DENS(X0, Y1, Z0) - c0;\n                                    c3 = DENS(X0, Y1, Z1) - DENS(X0, Y1, Z0);\n\n                                }\n                                else\n                                    if (rz >= ry && ry >= rx) {\n\n                                        c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);\n                                        c2 = DENS(X0, Y1, Z1) - DENS(X0, Y0, Z1);\n                                        c3 = DENS(X0, Y0, Z1) - c0;\n\n                                    }\n                                    else {\n                                        c1 = c2 = c3 = 0;\n                                    }\n\n                *(cmsFloat32Number*)(out[OutChan]) = c0 + c1 * rx + c2 * ry + c3 * rz;\n\n                out[OutChan] += DestIncrements[OutChan];\n            }\n\n            if (ain) {\n                *(cmsFloat32Number*)(out[TotalOut]) = *(cmsFloat32Number*)ain;\n                ain += SourceIncrements[3];\n                out[TotalOut] += DestIncrements[TotalOut];\n            }\n        }\n\n        strideIn  += Stride->BytesPerLineIn;\n        strideOut += Stride->BytesPerLineOut;\n    }\n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              222,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FloatCLUTEval",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "Input": "void",
              "Output": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool OptimizeCLUTRGBTransform(_cmsTransform2Fn* TransformFn,\n                                  void** UserData,\n                                  _cmsFreeUserDataFn* FreeDataFn,\n                                  cmsPipeline** Lut, \n                                  cmsUInt32Number* InputFormat, \n                                  cmsUInt32Number* OutputFormat, \n                                  cmsUInt32Number* dwFlags)      \n{\n    cmsPipeline* OriginalLut;\n    int nGridPoints;    \n    cmsPipeline* OptimizedLUT = NULL;    \n    cmsStage* OptimizedCLUTmpe;\n    FloatCLUTData* pfloat;\n    cmsContext ContextID;\n    _cmsStageCLutData* data;\n\n    // For empty transforms, do nothing\n    if (*Lut == NULL) return FALSE;\n\n    // Check for floating point only\n    if (!T_FLOAT(*InputFormat) || !T_FLOAT(*OutputFormat)) return FALSE;\n\n    // Only on floats\n    if (T_BYTES(*InputFormat) != sizeof(cmsFloat32Number) || \n        T_BYTES(*OutputFormat) != sizeof(cmsFloat32Number)) return FALSE;\n\n    // Input has to be RGB\n    if (T_COLORSPACE(*InputFormat) != PT_RGB) return FALSE;\n   \n    OriginalLut = *Lut;\n   \n    ContextID        = cmsGetPipelineContextID(OriginalLut);\n    nGridPoints      = _cmsReasonableGridpointsByColorspace(cmsSigRgbData, *dwFlags);\n             \n    // Create the result LUT\n    OptimizedLUT = cmsPipelineAlloc(cmsGetPipelineContextID(OriginalLut), 3, cmsPipelineOutputChannels(OriginalLut));\n    if (OptimizedLUT == NULL) goto Error;\n    \n    // Allocate the CLUT for result\n    OptimizedCLUTmpe = cmsStageAllocCLutFloat(ContextID, nGridPoints, 3, cmsPipelineOutputChannels(OriginalLut), NULL);\n\n    // Add the CLUT to the destination LUT\n    cmsPipelineInsertStage(OptimizedLUT, cmsAT_BEGIN, OptimizedCLUTmpe);\n\n    // If output is CMYK, add a conversion stage to get %   \n    if (T_COLORSPACE(*OutputFormat) == PT_CMYK) {\n\n        static const cmsFloat64Number mat[] = { 100.0,   0,     0,     0,\n                                                  0,   100.0,   0,     0,\n                                                  0,     0,   100.0,   0,\n                                                  0,     0,     0,   100.0 };\n\n        cmsStage* percent = cmsStageAllocMatrix(ContextID, 4, 4, mat, NULL);\n        if (percent == NULL) goto Error;\n\n        cmsPipelineInsertStage(OriginalLut, cmsAT_END, percent);\n    }\n    else\n        // If output is Lab, add a conversion stage to get Lab values\n        if (T_COLORSPACE(*OutputFormat) == PT_Lab) {\n\n            static const cmsFloat64Number mat[] = { 100.0,   0,    0,\n                                                      0,  255.0,   0,\n                                                      0,     0,   255.0 };\n\n            static const cmsFloat64Number off[] = { 0,   -128.0,     -128.0 };\n\n            cmsStage* lab_fix = cmsStageAllocMatrix(ContextID, 3, 3, mat, off);\n            if (lab_fix == NULL) goto Error;\n\n            cmsPipelineInsertStage(OriginalLut, cmsAT_END, lab_fix);\n        }\n        else {\n            if (T_COLORSPACE(*OutputFormat) != PT_GRAY &&\n                T_COLORSPACE(*OutputFormat) != PT_RGB) return FALSE;\n        }\n\n\n    // Resample the LUT\n    if (!cmsStageSampleCLutFloat(OptimizedCLUTmpe, XFormSampler, (void*)OriginalLut, 0)) goto Error;\n\n    \n    if (T_COLORSPACE(*OutputFormat) == PT_CMYK) {\n\n        cmsPipelineUnlinkStage(OriginalLut, cmsAT_END, NULL);\n    }\n\n    // Set the evaluator, copy parameters   \n    data = (_cmsStageCLutData*) cmsStageData(OptimizedCLUTmpe);\n\n    pfloat = FloatCLUTAlloc(ContextID, data ->Params);\n    if (pfloat == NULL) return FALSE;   \n\n    // And return the obtained LUT\n    cmsPipelineFree(OriginalLut);\n\n    *Lut = OptimizedLUT;\n    *TransformFn = FloatCLUTEval;\n    *UserData   = pfloat;\n    *FreeDataFn = _cmsFree;\n    *dwFlags &= ~cmsFLAGS_CAN_CHANGE_FORMATTER;\n    return TRUE;\n\nError:\n      \n    if (OptimizedLUT != NULL) cmsPipelineFree(OptimizedLUT);\n\n    return FALSE;    \n}",
          "fn_code_pos": [
            [
              230,
              0
            ],
            [
              338,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OptimizeCLUTRGBTransform",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeDataFn": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "FloatCLUTAlloc(cmsContext ContextID, const cmsInterpParams* p)",
          "fn_dec_pos": [
            [
              33,
              15
            ],
            [
              33,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FloatCLUTAlloc",
            "parameters": {
              "ContextID": "cmsContext",
              "p": "cmsInterpParams"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\n    cmsContext ContextID;\n    const cmsInterpParams* p;   // Tetrahedrical interpolation parameters. This is a not-owned pointer.\n\n} FloatCLUTData;",
          {
            "ContextID": "cmsContext",
            "cmsInterpParams": "const"
          },
          "FloatCLUTData",
          [
            24,
            0
          ],
          [
            29,
            16
          ]
        ],
        [
          "typedef struct {\n\n    cmsContext ContextID;\n    const cmsInterpParams* p;   // Tetrahedrical interpolation parameters. This is a not-owned pointer.\n\n} FloatCLUTData;",
          {
            "ContextID": "cmsContext",
            "cmsInterpParams": "const"
          },
          "FloatCLUTData",
          [
            24,
            0
          ],
          [
            29,
            16
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            59,
            19
          ],
          [
            59,
            46
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"fast_float_internal.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/fast_float/src/fast_8_tethra.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nPerformance8Data* Performance8alloc(cmsContext ContextID, const cmsInterpParams* p, cmsToneCurve* G[3])\n{\n    int i;\n    cmsUInt16Number Input[3];\n    cmsS15Fixed16Number v1, v2, v3;\n    Performance8Data* p8;\n\n    p8 = (Performance8Data*) _cmsMallocZero(ContextID, sizeof(Performance8Data));\n    if (p8 == NULL) return NULL;\n    \n    // Since this only works for 8 bit input, values comes always as x * 257, \n    // we can safely take msb byte (x << 8 + x)\n    for (i=0; i < 256; i++) {\n\n        if (G != NULL) {\n\n            // Get 16-bit representation\n            Input[0] = cmsEvalToneCurve16(G[0], FROM_8_TO_16(i));\n            Input[1] = cmsEvalToneCurve16(G[1], FROM_8_TO_16(i));\n            Input[2] = cmsEvalToneCurve16(G[2], FROM_8_TO_16(i));\n        }\n        else {\n            Input[0] = FROM_8_TO_16(i);\n            Input[1] = FROM_8_TO_16(i);\n            Input[2] = FROM_8_TO_16(i);\n        }\n\n        // Move to 0..1.0 in fixed domain\n        v1 = _cmsToFixedDomain(Input[0] * p -> Domain[0]);\n        v2 = _cmsToFixedDomain(Input[1] * p -> Domain[1]);\n        v3 = _cmsToFixedDomain(Input[2] * p -> Domain[2]);\n\n        // Store the precalculated table of nodes\n        p8 ->X0[i] = (p->opta[2] * FIXED_TO_INT(v1));\n        p8 ->Y0[i] = (p->opta[1] * FIXED_TO_INT(v2));\n        p8 ->Z0[i] = (p->opta[0] * FIXED_TO_INT(v3));\n\n        // Store the precalculated table of offsets\n        p8 ->rx[i] = (cmsUInt16Number) FIXED_REST_TO_INT(v1);\n        p8 ->ry[i] = (cmsUInt16Number) FIXED_REST_TO_INT(v2);\n        p8 ->rz[i] = (cmsUInt16Number) FIXED_REST_TO_INT(v3);\n    }\n\n\n    p8 ->ContextID = ContextID;\n    p8 ->p = p;\n\n    return p8;\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              89,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Performance8alloc",
            "parameters": {
              "ContextID": "cmsContext",
              "p": "cmsInterpParams",
              "G": "cmsToneCurve"
            },
            "return_type": "Performance8Data"
          }
        },
        {
          "fn_code": "static\nvoid Performance8free(cmsContext ContextID, void* ptr)\n{   \n    _cmsFree(ContextID, ptr);\n}",
          "fn_code_pos": [
            [
              91,
              0
            ],
            [
              95,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Performance8free",
            "parameters": {
              "ContextID": "cmsContext",
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nint XFormSampler16(CMSREGISTER const cmsUInt16Number In[], CMSREGISTER cmsUInt16Number Out[], CMSREGISTER void* Cargo)\n{\n    // Evaluate in 16 bits\n    cmsPipelineEval16(In, Out, (cmsPipeline*) Cargo);\n\n    // Always succeed\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              100,
              0
            ],
            [
              108,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "XFormSampler16",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nvoid PerformanceEval8(struct _cmstransform_struct *CMMcargo,\n                      const void* Input,\n                      void* Output,\n                      cmsUInt32Number PixelsPerLine,\n                      cmsUInt32Number LineCount,\n                      const cmsStride* Stride)\n{\n\n    cmsUInt8Number         r, g, b;\n    cmsS15Fixed16Number    rx, ry, rz;\n    cmsS15Fixed16Number    c0, c1, c2, c3, Rest;\n    cmsUInt32Number        OutChan, TotalPlusAlpha;\n    cmsS15Fixed16Number    X0, X1, Y0, Y1, Z0, Z1;\n    Performance8Data*      p8 = (Performance8Data*)_cmsGetTransformUserData(CMMcargo);\n    const cmsInterpParams* p = p8->p;\n    cmsUInt32Number        TotalOut = p->nOutputs;\n    const cmsUInt16Number* LutTable = (const cmsUInt16Number*)p->Table;\n\n    cmsUInt8Number* out[cmsMAXCHANNELS];\n    cmsUInt16Number res16;\n\n    cmsUInt32Number i, ii;\n\n    cmsUInt32Number SourceStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number SourceIncrements[cmsMAXCHANNELS];\n    cmsUInt32Number DestStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number DestIncrements[cmsMAXCHANNELS];\n\n    const cmsUInt8Number* rin;\n    const cmsUInt8Number* gin;\n    const cmsUInt8Number* bin;\n    const cmsUInt8Number* ain = NULL;\n\n    cmsUInt32Number nalpha;\n    size_t strideIn, strideOut;\n\n    _cmsComputeComponentIncrements(cmsGetTransformInputFormat((cmsHTRANSFORM)CMMcargo), Stride->BytesPerPlaneIn, NULL, &nalpha, SourceStartingOrder, SourceIncrements);\n    _cmsComputeComponentIncrements(cmsGetTransformOutputFormat((cmsHTRANSFORM)CMMcargo), Stride->BytesPerPlaneOut, NULL, &nalpha, DestStartingOrder, DestIncrements);\n\n    if (!(_cmsGetTransformFlags((cmsHTRANSFORM)CMMcargo) & cmsFLAGS_COPY_ALPHA))\n        nalpha = 0;\n\n    strideIn = strideOut = 0;\n    for (i = 0; i < LineCount; i++) {\n\n        rin = (const cmsUInt8Number*)Input + SourceStartingOrder[0] + strideIn;\n        gin = (const cmsUInt8Number*)Input + SourceStartingOrder[1] + strideIn;\n        bin = (const cmsUInt8Number*)Input + SourceStartingOrder[2] + strideIn;\n        if (nalpha)\n            ain = (const cmsUInt8Number*)Input + SourceStartingOrder[3] + strideIn;\n\n        TotalPlusAlpha = TotalOut;\n        if (ain) TotalPlusAlpha++;\n\n        for (OutChan = 0; OutChan < TotalPlusAlpha; OutChan++) {\n            out[OutChan] = (cmsUInt8Number*)Output + DestStartingOrder[OutChan] + strideOut;\n        }\n\n\n        for (ii = 0; ii < PixelsPerLine; ii++) {\n\n            r = *rin; g = *gin; b = *bin;\n\n            rin += SourceIncrements[0];\n            gin += SourceIncrements[1];\n            bin += SourceIncrements[2];\n\n            X0 = X1 = p8->X0[r];\n            Y0 = Y1 = p8->Y0[g];\n            Z0 = Z1 = p8->Z0[b];\n\n            rx = p8->rx[r];\n            ry = p8->ry[g];\n            rz = p8->rz[b];\n\n            X1 = X0 + ((rx == 0) ? 0 : p->opta[2]);\n            Y1 = Y0 + ((ry == 0) ? 0 : p->opta[1]);\n            Z1 = Z0 + ((rz == 0) ? 0 : p->opta[0]);\n\n\n            // These are the 6 Tetrahedral\n            for (OutChan = 0; OutChan < TotalOut; OutChan++) {\n\n                c0 = DENS(X0, Y0, Z0);\n\n                if (rx >= ry && ry >= rz)\n                {\n                    c1 = DENS(X1, Y0, Z0) - c0;\n                    c2 = DENS(X1, Y1, Z0) - DENS(X1, Y0, Z0);\n                    c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);\n                }\n                else\n                    if (rx >= rz && rz >= ry)\n                    {\n                        c1 = DENS(X1, Y0, Z0) - c0;\n                        c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);\n                        c3 = DENS(X1, Y0, Z1) - DENS(X1, Y0, Z0);\n                    }\n                    else\n                        if (rz >= rx && rx >= ry)\n                        {\n                            c1 = DENS(X1, Y0, Z1) - DENS(X0, Y0, Z1);\n                            c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);\n                            c3 = DENS(X0, Y0, Z1) - c0;\n                        }\n                        else\n                            if (ry >= rx && rx >= rz)\n                            {\n                                c1 = DENS(X1, Y1, Z0) - DENS(X0, Y1, Z0);\n                                c2 = DENS(X0, Y1, Z0) - c0;\n                                c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);\n                            }\n                            else\n                                if (ry >= rz && rz >= rx)\n                                {\n                                    c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);\n                                    c2 = DENS(X0, Y1, Z0) - c0;\n                                    c3 = DENS(X0, Y1, Z1) - DENS(X0, Y1, Z0);\n                                }\n                                else\n                                    if (rz >= ry && ry >= rx)\n                                    {\n                                        c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);\n                                        c2 = DENS(X0, Y1, Z1) - DENS(X0, Y0, Z1);\n                                        c3 = DENS(X0, Y0, Z1) - c0;\n                                    }\n                                    else {\n                                        c1 = c2 = c3 = 0;\n                                    }\n\n\n                Rest = c1 * rx + c2 * ry + c3 * rz + 0x8001;\n                res16 = (cmsUInt16Number)c0 + ((Rest + (Rest >> 16)) >> 16);\n\n                *out[OutChan] = FROM_16_TO_8(res16);\n                out[OutChan] += DestIncrements[OutChan];\n\n            }\n\n            if (ain) {\n                *out[TotalOut] = *ain;\n                ain += SourceIncrements[3];\n                out[TotalOut] += DestIncrements[TotalOut];\n            }\n\n        }\n\n        strideIn += Stride->BytesPerLineIn;\n        strideOut += Stride->BytesPerLineOut;\n    }\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              265,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PerformanceEval8",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "Input": "void",
              "Output": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool IsDegenerated(const cmsToneCurve* g)\n{\n    int i, Zeros = 0, Poles = 0;\n    int nEntries = cmsGetToneCurveEstimatedTableEntries(g);\n    const cmsUInt16Number* Table16 = cmsGetToneCurveEstimatedTable(g);\n\n    for (i=0; i < nEntries; i++) {\n\n        if (Table16[i] == 0x0000) Zeros++;\n        if (Table16[i] == 0xffff) Poles++;\n    }\n\n    if (Zeros == 1 && Poles == 1) return FALSE;  // For linear tables\n    if (Zeros > (nEntries / 4)) return TRUE;  // Degenerated, mostly zeros\n    if (Poles > (nEntries / 4)) return TRUE;  // Degenerated, mostly poles\n\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              271,
              0
            ],
            [
              289,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsDegenerated",
            "parameters": {
              "g": "cmsToneCurve"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid SlopeLimiting(cmsUInt16Number* Table16, int nEntries)\n{\n    int BeginVal, EndVal;\n   \n    int AtBegin = (int) floor((cmsFloat64Number)nEntries * 0.02 + 0.5);   // Cutoff at 2%\n    int AtEnd   = nEntries - AtBegin - 1;                                  // And 98%\n    cmsFloat64Number Val, Slope, beta;\n    int i;\n    \n\n    if (Table16[0] > Table16[nEntries-1]) {\n        BeginVal = 0xffff; EndVal = 0;\n    }\n    else {\n        BeginVal = 0; EndVal = 0xffff;\n    }\n\n    // Compute slope and offset for begin of curve\n    Val   = Table16[AtBegin];\n    Slope = (Val - BeginVal) / AtBegin;\n    beta  = Val - Slope * AtBegin;\n\n    for (i=0; i < AtBegin; i++)\n        Table16[i] = _cmsSaturateWord(i * Slope + beta);\n\n    // Compute slope and offset for the end\n    Val   = Table16[AtEnd];\n    Slope = (EndVal - Val) / AtBegin;   // AtBegin holds the X interval, which is same in both cases\n    beta  = Val - Slope * AtEnd;\n\n    for (i = AtEnd; i < (int) nEntries; i++) \n        Table16[i] = _cmsSaturateWord(i * Slope + beta);\n}",
          "fn_code_pos": [
            [
              295,
              0
            ],
            [
              328,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SlopeLimiting",
            "parameters": {
              "Table16": "cmsUInt16Number",
              "nEntries": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool Optimize8BitRGBTransform(_cmsTransform2Fn* TransformFn,\n                                  void** UserData,\n                                  _cmsFreeUserDataFn* FreeDataFn,\n                                  cmsPipeline** Lut, \n                                  cmsUInt32Number* InputFormat, \n                                  cmsUInt32Number* OutputFormat, \n                                  cmsUInt32Number* dwFlags)      \n{\n    cmsPipeline* OriginalLut;\n    int nGridPoints;\n    cmsToneCurve *Trans[cmsMAXCHANNELS], *TransReverse[cmsMAXCHANNELS];\n    cmsUInt32Number t, i, j;  \n    cmsFloat32Number v, In[cmsMAXCHANNELS], Out[cmsMAXCHANNELS];\n    cmsBool lIsSuitable;\n    cmsPipeline* OptimizedLUT = NULL, *LutPlusCurves = NULL;    \n    cmsStage* OptimizedCLUTmpe;\n    cmsStage* OptimizedPrelinMpe;\n    Performance8Data* p8;\n    cmsUInt16Number* MyTable[3];\n    cmsContext ContextID;\n    _cmsStageCLutData* data;\n\n    // For empty transforms, do nothing\n    if (*Lut == NULL) return FALSE;\n\n    // This is a lossy optimization! does not apply in floating-point cases\n    if (T_FLOAT(*InputFormat) || T_FLOAT(*OutputFormat)) return FALSE;\n\n    // Only on 8-bit\n    if (T_BYTES(*InputFormat) != 1 || T_BYTES(*OutputFormat) != 1) return FALSE;\n\n    // Only on RGB\n    if (T_COLORSPACE(*InputFormat)  != PT_RGB) return FALSE;\n   \n    // This optimization only works on RGB8->RGB8\n    if (T_COLORSPACE(*OutputFormat) != PT_RGB) return FALSE;\n\n    OriginalLut = *Lut;\n   \n    ContextID = cmsGetPipelineContextID(OriginalLut);\n    nGridPoints      = _cmsReasonableGridpointsByColorspace(cmsSigRgbData, *dwFlags);\n\n    // Empty gamma containers\n    memset(Trans, 0, sizeof(Trans));\n    memset(TransReverse, 0, sizeof(TransReverse));\n\n    MyTable[0] = (cmsUInt16Number*) _cmsMallocZero(ContextID, sizeof(cmsUInt16Number) * PRELINEARIZATION_POINTS);\n    MyTable[1] = (cmsUInt16Number*) _cmsMallocZero(ContextID, sizeof(cmsUInt16Number) * PRELINEARIZATION_POINTS);\n    MyTable[2] = (cmsUInt16Number*) _cmsMallocZero(ContextID, sizeof(cmsUInt16Number) * PRELINEARIZATION_POINTS);\n    \n    if (MyTable[0] == NULL || MyTable[1] == NULL || MyTable[2] == NULL) goto Error;\n\n    // Populate the curves\n\n    for (i=0; i < PRELINEARIZATION_POINTS; i++) {\n\n        v = (cmsFloat32Number) ((cmsFloat64Number) i / (PRELINEARIZATION_POINTS - 1));\n\n        // Feed input with a gray ramp\n        for (j=0; j < 3; j++)\n            In[j] = v;\n\n        // Evaluate the gray value\n        cmsPipelineEvalFloat(In, Out, OriginalLut);\n\n        // Store result in curve\n        for (j=0; j < 3; j++)\n            MyTable[j][i] = _cmsSaturateWord(Out[j] * 65535.0);\n    }\n\n    for (t=0; t < 3; t++) {\n\n        SlopeLimiting(MyTable[t], PRELINEARIZATION_POINTS);\n\n        Trans[t] = cmsBuildTabulatedToneCurve16(ContextID, PRELINEARIZATION_POINTS, MyTable[t]);\n        if (Trans[t] == NULL) goto Error;\n\n        _cmsFree(cmsGetPipelineContextID(OriginalLut), MyTable[t]);\n    }\n\n    // Check for validity\n    lIsSuitable = TRUE;\n    for (t=0; (lIsSuitable && (t < 3)); t++) {\n        \n        if (IsDegenerated(Trans[t]))\n            lIsSuitable = FALSE;\n    }\n\n    // If it is not suitable, just quit\n    if (!lIsSuitable) goto Error;\n\n    // Invert curves if possible\n    for (t = 0; t < cmsPipelineInputChannels(OriginalLut); t++) {\n        TransReverse[t] = cmsReverseToneCurveEx(PRELINEARIZATION_POINTS, Trans[t]);\n        if (TransReverse[t] == NULL) goto Error;\n    }\n\n    // Now insert the reversed curves at the begin of transform\n    LutPlusCurves = cmsPipelineDup(OriginalLut);\n    if (LutPlusCurves == NULL) goto Error;\n\n    cmsPipelineInsertStage(LutPlusCurves, cmsAT_BEGIN, cmsStageAllocToneCurves(ContextID, 3, TransReverse));\n\n    // Create the result LUT\n    OptimizedLUT = cmsPipelineAlloc(cmsGetPipelineContextID(OriginalLut), 3, cmsPipelineOutputChannels(OriginalLut));\n    if (OptimizedLUT == NULL) goto Error;\n\n    OptimizedPrelinMpe = cmsStageAllocToneCurves(ContextID, 3, Trans);\n\n    // Create and insert the curves at the beginning    \n    cmsPipelineInsertStage(OptimizedLUT, cmsAT_BEGIN, OptimizedPrelinMpe);\n\n    // Allocate the CLUT for result\n    OptimizedCLUTmpe = cmsStageAllocCLut16bit(ContextID, nGridPoints, 3, cmsPipelineOutputChannels(OriginalLut), NULL);\n\n    // Add the CLUT to the destination LUT\n    cmsPipelineInsertStage(OptimizedLUT, cmsAT_END, OptimizedCLUTmpe);\n\n    // Resample the LUT\n    if (!cmsStageSampleCLut16bit(OptimizedCLUTmpe, XFormSampler16, (void*) LutPlusCurves, 0)) goto Error;\n\n    // Set the evaluator   \n    data = (_cmsStageCLutData*) cmsStageData(OptimizedCLUTmpe);\n\n    p8 = Performance8alloc(ContextID, data ->Params, Trans);\n    if (p8 == NULL) return FALSE;\n\n    // Free resources\n    for (t = 0; t <3; t++) {\n\n        if (Trans[t]) cmsFreeToneCurve(Trans[t]);\n        if (TransReverse[t]) cmsFreeToneCurve(TransReverse[t]);\n    }\n\n    cmsPipelineFree(LutPlusCurves);\n\n    // And return the obtained LUT\n    cmsPipelineFree(OriginalLut);\n\n    *dwFlags &= ~cmsFLAGS_CAN_CHANGE_FORMATTER;\n    *Lut = OptimizedLUT;\n    *TransformFn = PerformanceEval8;\n    *UserData   = p8;\n    *FreeDataFn = Performance8free;\n\n    return TRUE;\n\nError:\n\n    for (t = 0; t < 3; t++) {\n\n        if (Trans[t]) cmsFreeToneCurve(Trans[t]);\n        if (TransReverse[t]) cmsFreeToneCurve(TransReverse[t]);\n    }\n\n    if (LutPlusCurves != NULL) cmsPipelineFree(LutPlusCurves);   \n    if (OptimizedLUT != NULL) cmsPipelineFree(OptimizedLUT);\n\n    return FALSE;    \n}",
          "fn_code_pos": [
            [
              333,
              0
            ],
            [
              492,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Optimize8BitRGBTransform",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeDataFn": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "Performance8alloc(cmsContext ContextID, const cmsInterpParams* p, cmsToneCurve* G[3])",
          "fn_dec_pos": [
            [
              41,
              18
            ],
            [
              41,
              103
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Performance8alloc",
            "parameters": {
              "ContextID": "cmsContext",
              "p": "cmsInterpParams",
              "G": "cmsToneCurve"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\n    cmsContext ContextID;\n\n    const cmsInterpParams* p;   // Tetrahedrical interpolation parameters. This is a not-owned pointer.\n\n    cmsUInt16Number rx[256], ry[256], rz[256];\n    cmsUInt32Number X0[256], Y0[256], Z0[256];  // Precomputed nodes and offsets for 8-bit input data\n       \n\n} Performance8Data;",
          {
            "ContextID": "cmsContext",
            "cmsInterpParams": "const",
            "rx[256]": "cmsUInt16Number",
            "X0[256]": "cmsUInt32Number"
          },
          "Performance8Data",
          [
            26,
            0
          ],
          [
            36,
            19
          ]
        ],
        [
          "typedef struct {\n\n    cmsContext ContextID;\n\n    const cmsInterpParams* p;   // Tetrahedrical interpolation parameters. This is a not-owned pointer.\n\n    cmsUInt16Number rx[256], ry[256], rz[256];\n    cmsUInt32Number X0[256], Y0[256], Z0[256];  // Precomputed nodes and offsets for 8-bit input data\n       \n\n} Performance8Data;",
          {
            "ContextID": "cmsContext",
            "cmsInterpParams": "const",
            "rx[256]": "cmsUInt16Number",
            "X0[256]": "cmsUInt32Number"
          },
          "Performance8Data",
          [
            26,
            0
          ],
          [
            36,
            19
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            115,
            22
          ],
          [
            115,
            49
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"fast_float_internal.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/fast_float/src/fast_float_curves.c": {
      "fn_def_list": [
        {
          "fn_code": "static CurvesFloatData* malloc_aligned(cmsContext ContextID)\n{\n       cmsUInt8Number* real_ptr = (cmsUInt8Number*)_cmsMallocZero(ContextID, sizeof(CurvesFloatData) + 32);\n       cmsUInt8Number* aligned = (cmsUInt8Number*)(((uintptr_t)real_ptr + 16) & ~0xf);\n       CurvesFloatData* p = (CurvesFloatData*)aligned;\n\n       p->real_ptr = real_ptr;\n       \n       return p;\n}",
          "fn_code_pos": [
            [
              38,
              0
            ],
            [
              47,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "malloc_aligned",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "CurvesFloatData"
          }
        },
        {
          "fn_code": "static void free_aligned(cmsContext ContextID, void* Data)\n{\n       CurvesFloatData* p = (CurvesFloatData*)Data;\n       if (p != NULL)\n              _cmsFree(ContextID, p->real_ptr);\n}",
          "fn_code_pos": [
            [
              50,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "free_aligned",
            "parameters": {
              "ContextID": "cmsContext",
              "Data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void FastEvaluateFloatRGBCurves(struct _cmstransform_struct *CMMcargo,\n                                        const void* Input,\n                                        void* Output,\n                                        cmsUInt32Number PixelsPerLine,\n                                        cmsUInt32Number LineCount,\n                                        const cmsStride* Stride)\n{   \n    cmsUInt32Number i, ii;\n\tcmsUInt32Number SourceStartingOrder[cmsMAXCHANNELS];\n\tcmsUInt32Number SourceIncrements[cmsMAXCHANNELS];\n\tcmsUInt32Number DestStartingOrder[cmsMAXCHANNELS];\n\tcmsUInt32Number DestIncrements[cmsMAXCHANNELS];\n\n    const cmsUInt8Number* rin;\n    const cmsUInt8Number* gin;\n    const cmsUInt8Number* bin;\n    const cmsUInt8Number* ain = NULL;\n\n    cmsUInt8Number* rout;\n    cmsUInt8Number* gout;\n    cmsUInt8Number* bout;\n    cmsUInt8Number* aout = NULL;\n\n    cmsUInt32Number InputFormat  = cmsGetTransformInputFormat((cmsHTRANSFORM) CMMcargo);\n    cmsUInt32Number OutputFormat = cmsGetTransformOutputFormat((cmsHTRANSFORM) CMMcargo);\n\n    CurvesFloatData* Data = (CurvesFloatData*)  _cmsGetTransformUserData(CMMcargo);\n\n    cmsUInt32Number nchans, nalpha;\n    size_t strideIn, strideOut;\n\n    _cmsComputeComponentIncrements(InputFormat,  Stride->BytesPerPlaneIn, &nchans, &nalpha, SourceStartingOrder, SourceIncrements);\n    _cmsComputeComponentIncrements(OutputFormat, Stride->BytesPerPlaneOut, &nchans, &nalpha, DestStartingOrder, DestIncrements);\n\n    if (!(_cmsGetTransformFlags((cmsHTRANSFORM)CMMcargo) & cmsFLAGS_COPY_ALPHA))\n        nalpha = 0;\n\n\n    strideIn = strideOut = 0;\n    for (i = 0; i < LineCount; i++) {\n\n        rin = (const cmsUInt8Number*)Input + SourceStartingOrder[0] + strideIn;\n        gin = (const cmsUInt8Number*)Input + SourceStartingOrder[1] + strideIn;\n        bin = (const cmsUInt8Number*)Input + SourceStartingOrder[2] + strideIn;\n\n        if (nalpha)\n            ain = (const cmsUInt8Number*)Input + SourceStartingOrder[3] + strideIn;\n\n        rout = (cmsUInt8Number*)Output + DestStartingOrder[0] + strideOut;\n        gout = (cmsUInt8Number*)Output + DestStartingOrder[1] + strideOut;\n        bout = (cmsUInt8Number*)Output + DestStartingOrder[2] + strideOut;\n\n        if (nalpha)\n            aout = (cmsUInt8Number*)Output + DestStartingOrder[3] + strideOut;\n\n\n        for (ii = 0; ii < PixelsPerLine; ii++) {\n\n            *(cmsFloat32Number*)rout = flerp(Data->CurveR, *(cmsFloat32Number*)rin);\n            *(cmsFloat32Number*)gout = flerp(Data->CurveG, *(cmsFloat32Number*)gin);\n            *(cmsFloat32Number*)bout = flerp(Data->CurveB, *(cmsFloat32Number*)bin);\n\n            rin += SourceIncrements[0];\n            gin += SourceIncrements[1];\n            bin += SourceIncrements[2];\n\n            rout += DestIncrements[0];\n            gout += DestIncrements[1];\n            bout += DestIncrements[2];\n\n            if (ain)\n            {\n                *(cmsFloat32Number*)aout = *(cmsFloat32Number*)ain;\n                ain += SourceIncrements[3];\n                aout += DestIncrements[3];\n            }\n        }\n\n        strideIn += Stride->BytesPerLineIn;\n        strideOut += Stride->BytesPerLineOut;\n    }\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              140,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FastEvaluateFloatRGBCurves",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "Input": "void",
              "Output": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void FastFloatRGBIdentity(struct _cmstransform_struct *CMMcargo,\n                                        const void* Input,\n                                        void* Output,\n                                        cmsUInt32Number PixelsPerLine,\n                                        cmsUInt32Number LineCount,\n                                        const cmsStride* Stride)\n{   \n    cmsUInt32Number i, ii;\n\tcmsUInt32Number SourceStartingOrder[cmsMAXCHANNELS];\n\tcmsUInt32Number SourceIncrements[cmsMAXCHANNELS];\n    cmsUInt32Number DestStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number DestIncrements[cmsMAXCHANNELS];\n    const cmsUInt8Number* rin;\n    const cmsUInt8Number* gin;\n    const cmsUInt8Number* bin;\n    const cmsUInt8Number* ain = NULL;\n    cmsUInt8Number* rout;\n    cmsUInt8Number* gout;\n    cmsUInt8Number* bout;\n    cmsUInt8Number* aout = NULL;\n\n    cmsUInt32Number InputFormat  = cmsGetTransformInputFormat((cmsHTRANSFORM) CMMcargo);\n    cmsUInt32Number OutputFormat = cmsGetTransformOutputFormat((cmsHTRANSFORM) CMMcargo);\n  \n    cmsUInt32Number nchans, nalpha;\n    size_t strideIn, strideOut;\n\n    _cmsComputeComponentIncrements(InputFormat,  Stride->BytesPerPlaneIn,  &nchans, &nalpha, SourceStartingOrder, SourceIncrements);\n    _cmsComputeComponentIncrements(OutputFormat, Stride->BytesPerPlaneOut, &nchans, &nalpha, DestStartingOrder, DestIncrements);\n\n    if (!(_cmsGetTransformFlags((cmsHTRANSFORM)CMMcargo) & cmsFLAGS_COPY_ALPHA))\n        nalpha = 0;\n\n    strideIn = strideOut = 0;\n    for (i = 0; i < LineCount; i++) {\n\n    rin = (const cmsUInt8Number*)Input + SourceStartingOrder[0] + strideIn;\n    gin = (const cmsUInt8Number*)Input + SourceStartingOrder[1] + strideIn;\n    bin = (const cmsUInt8Number*)Input + SourceStartingOrder[2] + strideIn;\n\n    if (nalpha)\n        ain = (const cmsUInt8Number*)Input + SourceStartingOrder[3] + strideIn;\n\n\n    rout = (cmsUInt8Number*)Output + DestStartingOrder[0] + strideOut;\n    gout = (cmsUInt8Number*)Output + DestStartingOrder[1] + strideOut;\n    bout = (cmsUInt8Number*)Output + DestStartingOrder[2] + strideOut;\n\n    if (nalpha)\n        aout = (cmsUInt8Number*)Output + DestStartingOrder[3] + strideOut;\n\n\n    for (ii=0; ii < PixelsPerLine; ii++) {\n\n        *(cmsFloat32Number*)rout = *(cmsFloat32Number*)rin;\n        *(cmsFloat32Number*)gout = *(cmsFloat32Number*)gin;\n        *(cmsFloat32Number*)bout = *(cmsFloat32Number*)bin;\n        \n        rin += SourceIncrements[0];\n        gin += SourceIncrements[1];\n        bin += SourceIncrements[2];\n\n        rout += DestIncrements[0];\n        gout += DestIncrements[1];\n        bout += DestIncrements[2];\n\n\n        if (ain)\n        {\n            *(cmsFloat32Number*)aout = *(cmsFloat32Number*)ain;\n            ain += SourceIncrements[3];\n            aout += DestIncrements[3];\n        }\n    }\n\n    strideIn += Stride->BytesPerLineIn;\n    strideOut += Stride->BytesPerLineOut;\n    }\n}",
          "fn_code_pos": [
            [
              143,
              0
            ],
            [
              221,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FastFloatRGBIdentity",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "Input": "void",
              "Output": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void FastEvaluateFloatGrayCurves(struct _cmstransform_struct* CMMcargo,\n                                        const void* Input,\n                                        void* Output,\n                                        cmsUInt32Number PixelsPerLine,\n                                        cmsUInt32Number LineCount,\n                                        const cmsStride* Stride)\n{\n    cmsUInt32Number i, ii;\n    cmsUInt32Number SourceStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number SourceIncrements[cmsMAXCHANNELS];\n    cmsUInt32Number DestStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number DestIncrements[cmsMAXCHANNELS];\n    const cmsUInt8Number* kin;\n    const cmsUInt8Number* ain = NULL;\n    cmsUInt8Number* kout;\n    cmsUInt8Number* aout = NULL;\n\n    cmsUInt32Number InputFormat = cmsGetTransformInputFormat((cmsHTRANSFORM)CMMcargo);\n    cmsUInt32Number OutputFormat = cmsGetTransformOutputFormat((cmsHTRANSFORM)CMMcargo);\n\n    CurvesFloatData* Data = (CurvesFloatData*)_cmsGetTransformUserData(CMMcargo);\n\n    cmsUInt32Number nchans, nalpha;\n    size_t strideIn, strideOut;\n\n    _cmsComputeComponentIncrements(InputFormat, Stride->BytesPerPlaneIn, &nchans, &nalpha, SourceStartingOrder, SourceIncrements);\n    _cmsComputeComponentIncrements(OutputFormat, Stride->BytesPerPlaneIn, &nchans, &nalpha, DestStartingOrder, DestIncrements);\n\n    if (!(_cmsGetTransformFlags((cmsHTRANSFORM)CMMcargo) & cmsFLAGS_COPY_ALPHA))\n        nalpha = 0;\n\n    strideIn = strideOut = 0;\n    for (i = 0; i < LineCount; i++) {\n\n        kin = (const cmsUInt8Number*)Input + SourceStartingOrder[0] + strideIn;\n        kout = (cmsUInt8Number*)Output + DestStartingOrder[0] + strideOut;\n\n        if (nalpha)\n        {\n            ain = (const cmsUInt8Number*)Input + SourceStartingOrder[1] + strideIn;\n            aout = (cmsUInt8Number*)Output + DestStartingOrder[1] + strideOut;\n        }\n\n        for (ii = 0; ii < PixelsPerLine; ii++) {\n\n            *(cmsFloat32Number*)kout = flerp(Data->CurveR, *(cmsFloat32Number*)kin);\n\n            kin += SourceIncrements[0];\n            kout += DestIncrements[0];\n\n            if (ain)\n            {\n                *(cmsFloat32Number*)aout = *(cmsFloat32Number*)ain;\n                ain += SourceIncrements[1];\n                aout += DestIncrements[1];\n            }\n        }\n\n        strideIn += Stride->BytesPerLineIn;\n        strideOut += Stride->BytesPerLineOut;\n    }\n}",
          "fn_code_pos": [
            [
              224,
              0
            ],
            [
              285,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FastEvaluateFloatGrayCurves",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "Input": "void",
              "Output": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void FastFloatGrayIdentity(struct _cmstransform_struct* CMMcargo,\n                                        const void* Input,\n                                        void* Output,\n                                        cmsUInt32Number PixelsPerLine,\n                                        cmsUInt32Number LineCount,\n                                        const cmsStride* Stride)\n{   \n    cmsUInt32Number i, ii;\n    cmsUInt32Number SourceStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number SourceIncrements[cmsMAXCHANNELS];\n    cmsUInt32Number DestStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number DestIncrements[cmsMAXCHANNELS];\n\n    const cmsUInt8Number* kin;\n    const cmsUInt8Number* ain = NULL;\n    cmsUInt8Number* kout;\n    cmsUInt8Number* aout = NULL;\n\n    cmsUInt32Number InputFormat = cmsGetTransformInputFormat((cmsHTRANSFORM)CMMcargo);\n    cmsUInt32Number OutputFormat = cmsGetTransformOutputFormat((cmsHTRANSFORM)CMMcargo);\n\n    cmsUInt32Number nchans, nalpha;\n    size_t strideIn, strideOut;\n\n    _cmsComputeComponentIncrements(InputFormat, Stride->BytesPerPlaneIn, &nchans, &nalpha, SourceStartingOrder, SourceIncrements);\n    _cmsComputeComponentIncrements(OutputFormat, Stride->BytesPerPlaneOut, &nchans, &nalpha, DestStartingOrder, DestIncrements);\n\n    if (!(_cmsGetTransformFlags((cmsHTRANSFORM)CMMcargo) & cmsFLAGS_COPY_ALPHA))\n        nalpha = 0;\n\n    strideIn = strideOut = 0;\n    for (i = 0; i < LineCount; i++) {\n\n\n        kin = (const cmsUInt8Number*)Input + SourceStartingOrder[0] + strideIn;\n        kout = (cmsUInt8Number*)Output + DestStartingOrder[0] + strideOut;\n\n        if (nalpha)\n        {\n            ain = (const cmsUInt8Number*)Input + SourceStartingOrder[1] + strideIn;\n            aout = (cmsUInt8Number*)Output + DestStartingOrder[1] + strideOut;\n        }\n\n\n        for (ii = 0; ii < PixelsPerLine; ii++) {\n\n            *(cmsFloat32Number*)kout = *(cmsFloat32Number*)kin;\n\n            kin += SourceIncrements[0];\n            kout += DestIncrements[0];\n\n            if (ain)\n            {\n                *(cmsFloat32Number*)aout = *(cmsFloat32Number*)ain;\n                ain += SourceIncrements[1];\n                aout += DestIncrements[1];\n            }\n        }\n        strideIn += Stride->BytesPerLineIn;\n        strideOut += Stride->BytesPerLineOut;\n    }\n}",
          "fn_code_pos": [
            [
              288,
              0
            ],
            [
              349,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FastFloatGrayIdentity",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "Input": "void",
              "Output": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool AllRGBCurvesAreLinear(CurvesFloatData* data)\n{\n       int j;\n       cmsFloat32Number expected;\n\n       for (j = 0; j < MAX_NODES_IN_CURVE; j++) {\n\n              expected = (cmsFloat32Number)j / (cmsFloat32Number)(MAX_NODES_IN_CURVE - 1);\n\n              if (fabsf(data->CurveR[j] - expected) > LINEAR_CURVES_EPSILON ||\n                     fabsf(data->CurveG[j] - expected) > LINEAR_CURVES_EPSILON ||\n                     fabsf(data->CurveB[j] - expected) > LINEAR_CURVES_EPSILON) {\n                     return FALSE;\n              }\n       }\n\n       return TRUE;\n}",
          "fn_code_pos": [
            [
              355,
              0
            ],
            [
              373,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllRGBCurvesAreLinear",
            "parameters": {
              "data": "CurvesFloatData"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool KCurveIsLinear(CurvesFloatData* data)\n{\n       int j;\n       cmsFloat32Number expected;\n\n       for (j = 0; j < MAX_NODES_IN_CURVE; j++) {\n              expected = (cmsFloat32Number)j / (cmsFloat32Number)(MAX_NODES_IN_CURVE - 1);\n\n              if (fabs(data->CurveR[j] - expected) > LINEAR_CURVES_EPSILON) return FALSE;\n       }\n\n\n       return TRUE;\n}",
          "fn_code_pos": [
            [
              375,
              0
            ],
            [
              389,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "KCurveIsLinear",
            "parameters": {
              "data": "CurvesFloatData"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nCurvesFloatData* ComputeCompositeCurves(cmsUInt32Number nChan,  cmsPipeline* Src)\n{\n    cmsUInt32Number i, j;\n    cmsFloat32Number InFloat[3], OutFloat[3];\n\n    CurvesFloatData* Data = malloc_aligned(cmsGetPipelineContextID(Src));\n    if (Data == NULL) return NULL;\n\n    // Create target curves\n    for (i = 0; i < MAX_NODES_IN_CURVE; i++) {\n\n        for (j=0; j <nChan; j++) \n               InFloat[j] = (cmsFloat32Number)i /  (cmsFloat32Number)(MAX_NODES_IN_CURVE-1);\n\n        cmsPipelineEvalFloat(InFloat, OutFloat, Src);\n\n        if (nChan == 1) {\n\n               Data->CurveR[i] = OutFloat[0];\n        }\n        else {\n               Data->CurveR[i] = OutFloat[0];\n               Data->CurveG[i] = OutFloat[1];\n               Data->CurveB[i] = OutFloat[2];\n        }\n        \n    }\n\n    return Data;\n}",
          "fn_code_pos": [
            [
              393,
              0
            ],
            [
              423,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComputeCompositeCurves",
            "parameters": {
              "nChan": "cmsUInt32Number",
              "Src": "cmsPipeline"
            },
            "return_type": "CurvesFloatData"
          }
        },
        {
          "fn_code": "cmsBool OptimizeFloatByJoiningCurves(_cmsTransform2Fn* TransformFn,                                  \n                                  void** UserData,\n                                  _cmsFreeUserDataFn* FreeUserData,\n                                  cmsPipeline** Lut, \n                                  cmsUInt32Number* InputFormat, \n                                  cmsUInt32Number* OutputFormat, \n                                  cmsUInt32Number* dwFlags)    \n{\n \n    cmsPipeline* Src = *Lut;\n    cmsStage* mpe;   \n    CurvesFloatData* Data;\n    cmsUInt32Number nChans;\n\n    // Apply only to floating-point cases\n    if (!T_FLOAT(*InputFormat) || !T_FLOAT(*OutputFormat)) return FALSE;\n\n    // Only on 8-bit\n    if (T_BYTES(*InputFormat) != 4 ||  T_BYTES(*OutputFormat) != 4) return FALSE;\n\n    // Curves need same channels on input and output (despite extra channels may differ)\n    nChans = T_CHANNELS(*InputFormat);\n    if (nChans != T_CHANNELS(*OutputFormat)) return FALSE;\n\n    // gray and RGB \n    if (nChans != 1 && nChans != 3) return FALSE;\n   \n    //  Only curves in this LUT?\n    for (mpe = cmsPipelineGetPtrToFirstStage(Src);\n        mpe != NULL;\n        mpe = cmsStageNext(mpe)) {\n\n            if (cmsStageType(mpe) != cmsSigCurveSetElemType) return FALSE;\n    }\n   \n    Data = ComputeCompositeCurves(nChans, Src);\n    \n    *dwFlags |= cmsFLAGS_NOCACHE;\n    *dwFlags &= ~cmsFLAGS_CAN_CHANGE_FORMATTER;\n    *UserData = Data;\n    *FreeUserData = free_aligned;\n\n    // Maybe the curves are linear at the end\n    if (nChans == 1)\n        *TransformFn = (KCurveIsLinear(Data) ? FastFloatGrayIdentity : FastEvaluateFloatGrayCurves);\n    else\n        *TransformFn = (AllRGBCurvesAreLinear(Data) ? FastFloatRGBIdentity : FastEvaluateFloatRGBCurves);\n\n    return TRUE;\n\n}",
          "fn_code_pos": [
            [
              428,
              0
            ],
            [
              478,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OptimizeFloatByJoiningCurves",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeUserData": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "malloc_aligned(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              38,
              24
            ],
            [
              38,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "malloc_aligned",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ComputeCompositeCurves(cmsUInt32Number nChan,  cmsPipeline* Src)",
          "fn_dec_pos": [
            [
              394,
              17
            ],
            [
              394,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComputeCompositeCurves",
            "parameters": {
              "nChan": "cmsUInt32Number",
              "Src": "cmsPipeline"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n   \n    cmsFloat32Number CurveR[MAX_NODES_IN_CURVE];\n    cmsFloat32Number CurveG[MAX_NODES_IN_CURVE];\n    cmsFloat32Number CurveB[MAX_NODES_IN_CURVE];\n\n    void* real_ptr;\n\n} CurvesFloatData;",
          {
            "CurveR[MAX_NODES_IN_CURVE]": "cmsFloat32Number",
            "CurveG[MAX_NODES_IN_CURVE]": "cmsFloat32Number",
            "CurveB[MAX_NODES_IN_CURVE]": "cmsFloat32Number",
            "* real_ptr": "void"
          },
          "CurvesFloatData",
          [
            24,
            0
          ],
          [
            32,
            18
          ]
        ],
        [
          "typedef struct {\n   \n    cmsFloat32Number CurveR[MAX_NODES_IN_CURVE];\n    cmsFloat32Number CurveG[MAX_NODES_IN_CURVE];\n    cmsFloat32Number CurveB[MAX_NODES_IN_CURVE];\n\n    void* real_ptr;\n\n} CurvesFloatData;",
          {
            "CurveR[MAX_NODES_IN_CURVE]": "cmsFloat32Number",
            "CurveG[MAX_NODES_IN_CURVE]": "cmsFloat32Number",
            "CurveB[MAX_NODES_IN_CURVE]": "cmsFloat32Number",
            "* real_ptr": "void"
          },
          "CurvesFloatData",
          [
            24,
            0
          ],
          [
            32,
            18
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            59,
            39
          ],
          [
            59,
            66
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            143,
            33
          ],
          [
            143,
            60
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            224,
            40
          ],
          [
            224,
            67
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            288,
            34
          ],
          [
            288,
            61
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"fast_float_internal.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/fast_float/src/fast_8_matsh.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nXMatShaper8Data* malloc_aligned(cmsContext ContextID)\n{\n    cmsUInt8Number* real_ptr = (cmsUInt8Number*) _cmsMallocZero(ContextID, sizeof(XMatShaper8Data) + 32);\n    cmsUInt8Number* aligned = (cmsUInt8Number*) (((uintptr_t)real_ptr + 16) & ~0xf);\n    XMatShaper8Data* p = (XMatShaper8Data*) aligned;\n\n    p ->real_ptr = real_ptr;\n    return p;\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "malloc_aligned",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "XMatShaper8Data"
          }
        },
        {
          "fn_code": "static\nvoid free_aligned(XMatShaper8Data* a)\n{\n    _cmsFree(a->ContextID, a->real_ptr);\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              66,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "free_aligned",
            "parameters": {
              "a": "XMatShaper8Data"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid  FreeMatShaper(cmsContext ContextID, void* Data)\n{\n    UNUSED_PARAMETER(ContextID);\n\n    if (Data != NULL) free_aligned((XMatShaper8Data*) Data);\n}",
          "fn_code_pos": [
            [
              70,
              0
            ],
            [
              76,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FreeMatShaper",
            "parameters": {
              "ContextID": "cmsContext",
              "Data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid FillFirstShaper(cmsS1Fixed14Number* Table, cmsToneCurve* Curve)\n{\n    int i;\n    cmsFloat32Number R, y;\n\n    for (i=0; i < 256; i++) {\n        \n        R   = (cmsFloat32Number) (i / 255.0);\n        y   = cmsEvalToneCurveFloat(Curve, R);        \n\n        Table[i] = DOUBLE_TO_1FIXED14(y);\n    }\n}",
          "fn_code_pos": [
            [
              80,
              0
            ],
            [
              93,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FillFirstShaper",
            "parameters": {
              "Table": "cmsS1Fixed14Number",
              "Curve": "cmsToneCurve"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid FillSecondShaper(cmsUInt8Number* Table, cmsToneCurve* Curve)\n{\n    int i;\n    cmsFloat32Number R, Val;\n    cmsInt32Number w;\n\n    for (i=0; i < 0x4001; i++) {\n\n        R   = (cmsFloat32Number) (i / 16384.0f);\n        Val = cmsEvalToneCurveFloat(Curve, R);    \n        w = (cmsInt32Number) (Val * 255.0f + 0.5f);\n        if (w < 0) w = 0;\n        if (w > 255) w = 255;\n\n        Table[i] = (cmsInt8Number) w;\n\n    }\n}",
          "fn_code_pos": [
            [
              97,
              0
            ],
            [
              115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FillSecondShaper",
            "parameters": {
              "Table": "cmsUInt8Number",
              "Curve": "cmsToneCurve"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nXMatShaper8Data* SetMatShaper(cmsContext ContextID, cmsToneCurve* Curve1[3], cmsMAT3* Mat, cmsVEC3* Off, cmsToneCurve* Curve2[3])\n{\n    XMatShaper8Data* p;\n    int i, j;\n\n    // Allocate a big chuck of memory to store precomputed tables\n    p = malloc_aligned(ContextID);\n    if (p == NULL) return FALSE;\n\n    p -> ContextID = ContextID;\n\n    // Precompute tables\n    FillFirstShaper(p ->Shaper1R, Curve1[0]);\n    FillFirstShaper(p ->Shaper1G, Curve1[1]);\n    FillFirstShaper(p ->Shaper1B, Curve1[2]);\n\n    FillSecondShaper(p ->Shaper2R, Curve2[0]);\n    FillSecondShaper(p ->Shaper2G, Curve2[1]);\n    FillSecondShaper(p ->Shaper2B, Curve2[2]);\n \n        \n    // Convert matrix to nFixed14. Note that those values may take more than 16 bits as\n    for (i=0; i < 3; i++) {\n        for (j=0; j < 3; j++) {         \n            p ->Mat[j][i] = DOUBLE_TO_1FIXED14(Mat->v[i].n[j]);            \n        }        \n    }\n      \n    for (i=0; i < 3; i++) {\n\n        if (Off == NULL) {   \n            \n            p->Mat[3][i] = DOUBLE_TO_1FIXED14(0.5);\n        }\n        else {                              \n            p->Mat[3][i] = DOUBLE_TO_1FIXED14(Off->n[i] + 0.5);\n        }\n    }\n\n \n    return p;\n}",
          "fn_code_pos": [
            [
              118,
              0
            ],
            [
              160,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetMatShaper",
            "parameters": {
              "ContextID": "cmsContext",
              "Curve1": "cmsToneCurve",
              "Mat": "cmsMAT3",
              "Off": "cmsVEC3",
              "Curve2": "cmsToneCurve"
            },
            "return_type": "XMatShaper8Data"
          }
        },
        {
          "fn_code": "static\nvoid MatShaperXform8(struct _cmstransform_struct *CMMcargo,\n                     const void* Input,\n                     void* Output,\n                     cmsUInt32Number PixelsPerLine,\n                     cmsUInt32Number LineCount,\n                     const cmsStride* Stride)\n{    \n    XMatShaper8Data* p = (XMatShaper8Data*) _cmsGetTransformUserData(CMMcargo);\n\n    cmsS1Fixed14Number l1, l2, l3;\n    cmsS1Fixed14Number r, g, b;\n    cmsUInt32Number ri, gi, bi;\n    cmsUInt32Number i, ii;\n\n    cmsUInt32Number SourceStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number SourceIncrements[cmsMAXCHANNELS];\n    cmsUInt32Number DestStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number DestIncrements[cmsMAXCHANNELS];\n\n    const cmsUInt8Number* rin;\n    const cmsUInt8Number* gin;\n    const cmsUInt8Number* bin;\n    const cmsUInt8Number* ain = NULL;\n\n    cmsUInt8Number* rout;\n    cmsUInt8Number* gout;\n    cmsUInt8Number* bout;\n    cmsUInt8Number* aout = NULL;\n\n    cmsUInt32Number nalpha;\n    size_t strideIn, strideOut;\n \n    _cmsComputeComponentIncrements(cmsGetTransformInputFormat((cmsHTRANSFORM)CMMcargo), Stride->BytesPerPlaneIn, NULL, &nalpha, SourceStartingOrder, SourceIncrements);\n    _cmsComputeComponentIncrements(cmsGetTransformOutputFormat((cmsHTRANSFORM)CMMcargo), Stride->BytesPerPlaneOut, NULL, &nalpha, DestStartingOrder, DestIncrements);\n\n    if (!(_cmsGetTransformFlags((cmsHTRANSFORM)CMMcargo) & cmsFLAGS_COPY_ALPHA))\n        nalpha = 0;\n\n    strideIn = strideOut = 0;\n    for (i = 0; i < LineCount; i++) {\n\n           rin = (const cmsUInt8Number*)Input + SourceStartingOrder[0] + strideIn;\n           gin = (const cmsUInt8Number*)Input + SourceStartingOrder[1] + strideIn;\n           bin = (const cmsUInt8Number*)Input + SourceStartingOrder[2] + strideIn;\n           if (nalpha)\n                  ain = (const cmsUInt8Number*)Input + SourceStartingOrder[3] + strideIn;\n\n\n           rout = (cmsUInt8Number*)Output + DestStartingOrder[0] + strideOut;\n           gout = (cmsUInt8Number*)Output + DestStartingOrder[1] + strideOut;\n           bout = (cmsUInt8Number*)Output + DestStartingOrder[2] + strideOut;\n           if (nalpha)\n                  aout = (cmsUInt8Number*)Output + DestStartingOrder[3] + strideOut;          \n\n           for (ii = 0; ii < PixelsPerLine; ii++) {\n                            \n                  // Across first shaper, which also converts to 1.14 fixed point. 16 bits guaranteed.\n                  r = p->Shaper1R[*rin];\n                  g = p->Shaper1G[*gin];\n                  b = p->Shaper1B[*bin];\n\n                  // Evaluate the matrix in 1.14 fixed point\n                  l1 = (p->Mat[0][0] * r + p->Mat[1][0] * g + p->Mat[2][0] * b + p->Mat[3][0]) >> 14;\n                  l2 = (p->Mat[0][1] * r + p->Mat[1][1] * g + p->Mat[2][1] * b + p->Mat[3][1]) >> 14;\n                  l3 = (p->Mat[0][2] * r + p->Mat[1][2] * g + p->Mat[2][2] * b + p->Mat[3][2]) >> 14;\n\n\n                  // Now we have to clip to 0..1.0 range \n                  ri = (l1 < 0) ? 0 : ((l1 > 0x4000) ? 0x4000 : l1);\n                  gi = (l2 < 0) ? 0 : ((l2 > 0x4000) ? 0x4000 : l2);\n                  bi = (l3 < 0) ? 0 : ((l3 > 0x4000) ? 0x4000 : l3);\n\n\n                  // And across second shaper, \n                  *rout = p->Shaper2R[ri];\n                  *gout = p->Shaper2G[gi];\n                  *bout = p->Shaper2B[bi];\n\n                  // Handle alpha\n                  if (ain) {\n                         *aout = *ain;\n                  }\n\n                  rin += SourceIncrements[0];\n                  gin += SourceIncrements[1];\n                  bin += SourceIncrements[2];\n                  if (ain) ain += SourceIncrements[3];\n\n                  rout += DestIncrements[0];\n                  gout += DestIncrements[1];\n                  bout += DestIncrements[2];\n                  if (aout) aout += DestIncrements[3];\n           }\n\n           strideIn += Stride->BytesPerLineIn;\n           strideOut += Stride->BytesPerLineOut;\n    }\n}",
          "fn_code_pos": [
            [
              166,
              0
            ],
            [
              264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MatShaperXform8",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "Input": "void",
              "Output": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool Optimize8MatrixShaper(_cmsTransform2Fn* TransformFn,                                  \n                                  void** UserData,\n                                  _cmsFreeUserDataFn* FreeUserData,\n                                  cmsPipeline** Lut, \n                                  cmsUInt32Number* InputFormat, \n                                  cmsUInt32Number* OutputFormat, \n                                  cmsUInt32Number* dwFlags)    \n{\n    cmsStage* Curve1, *Curve2;\n    cmsStage* Matrix1, *Matrix2;\n    _cmsStageMatrixData* Data1;\n    _cmsStageMatrixData* Data2;\n    cmsMAT3 res;\n    cmsBool IdentityMat = FALSE;\n    cmsPipeline* Dest, *Src;\n    cmsContext ContextID;\n    cmsUInt32Number nChans;\n    cmsFloat64Number factor = 1.0;\n\n    // Only works on RGB to RGB and gray to gray \n\n    if ( !( (T_CHANNELS(*InputFormat) == 3 && T_CHANNELS(*OutputFormat) == 3) ||\n            (T_CHANNELS(*InputFormat) == 1 && T_CHANNELS(*OutputFormat) == 1) )) return FALSE;\n                   \n    // Only works on 8 bit input\n    if (T_BYTES(*InputFormat) != 1 || T_BYTES(*OutputFormat) != 1) return FALSE;\n\n    // Seems suitable, proceed\n    Src = *Lut;\n\n    // Check for shaper-matrix-matrix-shaper structure, that is what this optimizer stands for\n    if (!cmsPipelineCheckAndRetreiveStages(Src, 4, \n        cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType, \n        &Curve1, &Matrix1, &Matrix2, &Curve2)) return FALSE;\n\n    ContextID = cmsGetPipelineContextID(Src);\n    nChans    = T_CHANNELS(*InputFormat);\n\n    // Get both matrices, which are 3x3\n    Data1 = (_cmsStageMatrixData*) cmsStageData(Matrix1);\n    Data2 = (_cmsStageMatrixData*) cmsStageData(Matrix2);\n\n    // Input offset should be zero\n    if (Data1 ->Offset != NULL) return FALSE;\n\n    if (cmsStageInputChannels(Matrix1) == 1 && cmsStageOutputChannels(Matrix2) == 1)\n    {\n        // This is a gray to gray. Just multiply    \n         factor = Data1->Double[0]*Data2->Double[0] +\n                  Data1->Double[1]*Data2->Double[1] +\n                  Data1->Double[2]*Data2->Double[2];\n\n        if (fabs(1 - factor) < (1.0 / 65535.0)) IdentityMat = TRUE;\n    }\n    else\n    {            \n        // Multiply both matrices to get the result\n        _cmsMAT3per(&res, (cmsMAT3*) Data2 ->Double, (cmsMAT3*) Data1 ->Double);\n\n        // Now the result is in res + Data2 -> Offset. Maybe is a plain identity?\n        IdentityMat = FALSE;\n        if (_cmsMAT3isIdentity(&res) && Data2 ->Offset == NULL) {\n\n            // We can get rid of full matrix\n            IdentityMat = TRUE;\n        }\n    }\n\n    // Allocate an empty LUT \n    Dest =  cmsPipelineAlloc(ContextID, nChans, nChans);\n    if (!Dest) return FALSE;\n\n    // Assemble the new LUT\n    cmsPipelineInsertStage(Dest, cmsAT_BEGIN, cmsStageDup(Curve1));\n    \n    if (!IdentityMat) {\n\n        if (nChans == 1)\n             cmsPipelineInsertStage(Dest, cmsAT_END, \n                    cmsStageAllocMatrix(ContextID, 1, 1, (const cmsFloat64Number*) &factor, Data2->Offset));\n        else\n            cmsPipelineInsertStage(Dest, cmsAT_END, \n                    cmsStageAllocMatrix(ContextID, 3, 3, (const cmsFloat64Number*) &res, Data2 ->Offset));\n    } \n\n\n    cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageDup(Curve2));\n\n    // If identity on matrix, we can further optimize the curves, so call the join curves routine\n    if (IdentityMat) {\n\n      Optimize8ByJoiningCurves(TransformFn, UserData, FreeUserData, &Dest, InputFormat, OutputFormat, dwFlags);\n    }\n    else {\n        _cmsStageToneCurvesData* mpeC1 = (_cmsStageToneCurvesData*) cmsStageData(Curve1);\n        _cmsStageToneCurvesData* mpeC2 = (_cmsStageToneCurvesData*) cmsStageData(Curve2);\n                \n        // In this particular optimization, cache does not help as it takes more time to deal with \n        // the cache than with the pixel handling\n        *dwFlags |= cmsFLAGS_NOCACHE;\n  \n\n        // Setup the optimization routines\n        *UserData = SetMatShaper(ContextID, mpeC1 ->TheCurves, &res, (cmsVEC3*) Data2 ->Offset, mpeC2->TheCurves);\n        *FreeUserData = FreeMatShaper; \n\n        *TransformFn =  MatShaperXform8;         \n    }\n\n    *dwFlags &= ~cmsFLAGS_CAN_CHANGE_FORMATTER;\n    cmsPipelineFree(Src);\n    *Lut = Dest;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              268,
              0
            ],
            [
              381,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Optimize8MatrixShaper",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeUserData": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "malloc_aligned(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              52,
              17
            ],
            [
              52,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "malloc_aligned",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "SetMatShaper(cmsContext ContextID, cmsToneCurve* Curve1[3], cmsMAT3* Mat, cmsVEC3* Off, cmsToneCurve* Curve2[3])",
          "fn_dec_pos": [
            [
              119,
              17
            ],
            [
              119,
              129
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetMatShaper",
            "parameters": {
              "ContextID": "cmsContext",
              "Curve1": "cmsToneCurve",
              "Mat": "cmsMAT3",
              "Off": "cmsVEC3",
              "Curve2": "cmsToneCurve"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\n    // Alignment makes it faster\n    \n    cmsS1Fixed14Number Mat[4][4];     // n.14 to n.14 (needs a saturation after that)\n\n    void * real_ptr;\n    \n    cmsContext ContextID;\n\n    cmsS1Fixed14Number Shaper1R[256];  // from 0..255 to 1.14  (0.0...1.0)\n    cmsS1Fixed14Number Shaper1G[256];\n    cmsS1Fixed14Number Shaper1B[256];\n    \n    cmsUInt8Number Shaper2R[0x4001];    // 1.14 to 0..255 \n    cmsUInt8Number Shaper2G[0x4001];\n    cmsUInt8Number Shaper2B[0x4001];    \n\n} XMatShaper8Data;",
          {
            "Mat[4][4]": "cmsS1Fixed14Number",
            "* real_ptr": "void",
            "ContextID": "cmsContext",
            "Shaper1R[256]": "cmsS1Fixed14Number",
            "Shaper1G[256]": "cmsS1Fixed14Number",
            "Shaper1B[256]": "cmsS1Fixed14Number",
            "Shaper2R[0x4001]": "cmsUInt8Number",
            "Shaper2G[0x4001]": "cmsUInt8Number",
            "Shaper2B[0x4001]": "cmsUInt8Number"
          },
          "XMatShaper8Data",
          [
            30,
            0
          ],
          [
            48,
            18
          ]
        ],
        [
          "typedef struct {\n\n    // Alignment makes it faster\n    \n    cmsS1Fixed14Number Mat[4][4];     // n.14 to n.14 (needs a saturation after that)\n\n    void * real_ptr;\n    \n    cmsContext ContextID;\n\n    cmsS1Fixed14Number Shaper1R[256];  // from 0..255 to 1.14  (0.0...1.0)\n    cmsS1Fixed14Number Shaper1G[256];\n    cmsS1Fixed14Number Shaper1B[256];\n    \n    cmsUInt8Number Shaper2R[0x4001];    // 1.14 to 0..255 \n    cmsUInt8Number Shaper2G[0x4001];\n    cmsUInt8Number Shaper2B[0x4001];    \n\n} XMatShaper8Data;",
          {
            "Mat[4][4]": "cmsS1Fixed14Number",
            "* real_ptr": "void",
            "ContextID": "cmsContext",
            "Shaper1R[256]": "cmsS1Fixed14Number",
            "Shaper1G[256]": "cmsS1Fixed14Number",
            "Shaper1B[256]": "cmsS1Fixed14Number",
            "Shaper2R[0x4001]": "cmsUInt8Number",
            "Shaper2G[0x4001]": "cmsUInt8Number",
            "Shaper2B[0x4001]": "cmsUInt8Number"
          },
          "XMatShaper8Data",
          [
            30,
            0
          ],
          [
            48,
            18
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            167,
            21
          ],
          [
            167,
            48
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"fast_float_internal.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/fast_float/testbed/demo_cmyk.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nvoid Fail(const char* frm, ...)\n{\n    va_list args;\n\n    va_start(args, frm);\n    vprintf(frm, args);\n    va_end(args);\n    exit(1);\n}",
          "fn_code_pos": [
            [
              26,
              0
            ],
            [
              35,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fail",
            "parameters": {
              "frm": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* make_image(size_t size_x, size_t size_y, cmsBool fill_rgb, cmsUInt32Number* stride_x)\n{\n    cmsUInt32Number size_x_aligned = ALIGNED_SIZE(16, size_x);\n    cmsUInt32Number line_size_in_bytes = size_x_aligned * sizeof(cmsUInt32Number); // RGBA\n\n    cmsUInt8Number* ptr_image = (cmsUInt8Number*) calloc(size_y, line_size_in_bytes);\n    \n    if (ptr_image == NULL) Fail(\"Couldn't allocate memory for image\");\n\n    if (fill_rgb)\n    {\n        size_t line;\n\n        for (line = 0; line < size_y; line++)\n        {\n            cmsUInt32Number* ptr_line = (cmsUInt32Number*)(ptr_image + line_size_in_bytes * line);          \n            cmsUInt32Number argb = 0;\n            int col;\n\n            for (col = 0; col < size_x; col++)\n                *ptr_line++ = argb++;\n                \n        }\n    }\n\n    *stride_x = line_size_in_bytes;\n    return (void*) ptr_image;\n}",
          "fn_code_pos": [
            [
              42,
              0
            ],
            [
              70,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "make_image",
            "parameters": {
              "size_x": "size_t",
              "size_y": "size_t",
              "fill_rgb": "cmsBool",
              "stride_x": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number MPixSec(cmsFloat64Number diff)\n{\n    cmsFloat64Number seconds = (cmsFloat64Number)diff / (cmsFloat64Number)CLOCKS_PER_SEC;\n    return (SIZE_X * SIZE_Y) / (1024.0 * 1024.0 * seconds);\n}",
          "fn_code_pos": [
            [
              75,
              0
            ],
            [
              80,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MPixSec",
            "parameters": {
              "diff": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number speed_test(void)\n{\n    clock_t atime;\n    cmsFloat64Number diff;\n    cmsHPROFILE hProfileIn;\n    cmsHPROFILE hProfileOut;   \n    cmsHTRANSFORM xform;\n    void* image_in;\n    void* image_out;\n    cmsUInt32Number stride_rgb_x, stride_cmyk_x;\n\n\n    hProfileIn = cmsOpenProfileFromFile(\"sRGB Color Space Profile.icm\", \"r\");\n    hProfileOut = cmsOpenProfileFromFile(\"USWebCoatedSWOP.icc\", \"r\");\n\n    if (hProfileIn == NULL || hProfileOut == NULL)\n        Fail(\"Unable to open profiles\");\n\n    xform = cmsCreateTransform(hProfileIn, TYPE_RGBA_8, hProfileOut, TYPE_CMYK_8, INTENT_PERCEPTUAL, 0);\n    cmsCloseProfile(hProfileIn);\n    cmsCloseProfile(hProfileOut);\n\n    \n    image_in = make_image(SIZE_X, SIZE_Y, TRUE, &stride_rgb_x);\n    image_out = make_image(SIZE_X, SIZE_Y, FALSE, &stride_cmyk_x);\n\n    atime = clock();\n\n    cmsDoTransformLineStride(xform, image_in, image_out, SIZE_X, SIZE_Y, stride_rgb_x, stride_cmyk_x, 0, 0);\n    \n    diff = clock() - atime;\n\n    free(image_in);\n    free(image_out);\n\n    cmsDeleteTransform(xform);\n    return MPixSec(diff);\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "speed_test",
            "parameters": {},
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "int main(void)\n{\n    cmsFloat64Number without_plugin;\n    cmsFloat64Number with_plugin;\n    \n    fprintf(stdout, \"DEMO of littleCMS fast float plugin: RGBA -> CMYK in Megapixels per second\\n\");  fflush(stdout);\n\n    // filling cache\n    fprintf(stdout, \"Wait CPU cache to stabilize: \");  fflush(stdout);\n    speed_test();\n    fprintf(stdout, \"Ok\\n\");\n\n    fprintf(stdout, \"Without plugin: \");  fflush(stdout);\n    without_plugin = speed_test();\n    fprintf(stdout, \"%.2f\\n\", without_plugin); fflush(stdout);\n\n    cmsPlugin(cmsFastFloatExtensions());\n\n    fprintf(stdout, \"With plugin: \");  fflush(stdout);\n    with_plugin = speed_test();\n    fprintf(stdout, \"%.2f\\n\", with_plugin); fflush(stdout);\n    \n    fprintf(stdout, \"x %2.2f\\n\", (with_plugin/without_plugin)); fflush(stdout);\n\n    return 0;    \n}",
          "fn_code_pos": [
            [
              125,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "make_image(size_t size_x, size_t size_y, cmsBool fill_rgb, cmsUInt32Number* stride_x)",
          "fn_dec_pos": [
            [
              43,
              6
            ],
            [
              43,
              91
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "make_image",
            "parameters": {
              "size_x": "size_t",
              "size_y": "size_t",
              "fill_rgb": "cmsBool",
              "stride_x": "cmsUInt32Number"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"lcms2_fast_float.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <memory.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/utils/linkicc/linkicc.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nint Help(int level)\n{\n    UTILS_UNUSED_PARAMETER(level);\n\n    fprintf(stderr, \"\\nlinkicc: Links profiles into a single devicelink.\\n\");\n\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"usage: linkicc [flags] <profiles>\\n\\n\");\n    fprintf(stderr, \"flags:\\n\\n\");\n    fprintf(stderr, \"-o<profile> - Output devicelink profile. [defaults to 'devicelink.icc']\\n\");\n\n    PrintRenderingIntents();\n\n    fprintf(stderr, \"-c<0,1,2> - Precision (0=LowRes, 1=Normal, 2=Hi-res) [defaults to 1]\\n\");\n    fprintf(stderr, \"-n<gridpoints> - Alternate way to set precision, number of CLUT points\\n\");\n    fprintf(stderr, \"-d<description> - description text (quotes can be used)\\n\");\n    fprintf(stderr, \"-y<copyright> - copyright notice (quotes can be used)\\n\");\n\n    fprintf(stderr, \"\\n-k<0..400> - Ink-limiting in %% (CMYK only)\\n\");\n    fprintf(stderr, \"-8 - Creates 8-bit devicelink\\n\");\n    fprintf(stderr, \"-x - Creatively, guess deviceclass of resulting profile.\\n\");\n    fprintf(stderr, \"-b - Black point compensation\\n\");\n    fprintf(stderr, \"-a<0..1> - Observer adaptation state (abs.col. only)\\n\\n\");\n    fprintf(stderr, \"-l - Use linearization curves (may affect accuracy)\\n\");\n    fprintf(stderr, \"-r<v.r> - Profile version. (CAUTION: may change the profile implementation)\\n\");\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"Colorspaces must be paired except Lab/XYZ, that can be interchanged.\\n\\n\");\n\n    PrintBuiltins();\n\n    fprintf(stderr, \"\\nExamples:\\n\\n\"\n        \"To create 'devicelink.icm' from a.icc to b.icc:\\n\"\n        \"\\tlinkicc a.icc b.icc\\n\\n\"\n        \"To create 'out.icc' from sRGB to cmyk.icc:\\n\"\n        \"\\tlinkicc -o out.icc *sRGB cmyk.icc\\n\\n\"\n        \"To create a sRGB input profile working in Lab:\\n\"\n        \"\\tlinkicc -x -o sRGBLab.icc *sRGB *Lab\\n\\n\"\n        \"To create a XYZ -> sRGB output profile:\\n\"\n        \"\\tlinkicc -x -o sRGBLab.icc *XYZ *sRGB\\n\\n\"\n        \"To create a abstract profile doing softproof for cmyk.icc:\\n\"\n        \"\\tlinkicc -t1 -x -o softproof.icc *Lab cmyk.icc cmyk.icc *Lab\\n\\n\"\n        \"To create a 'grayer' sRGB input profile:\\n\"\n        \"\\tlinkicc -x -o grayer.icc *sRGB gray.icc gray.icc *Lab\\n\\n\"\n        \"To embed ink limiting into a cmyk output profile:\\n\"\n        \"\\tlinkicc -x -o cmyklimited.icc -k 250 cmyk.icc *Lab\\n\\n\");\n\n    fprintf(stderr, \"This program is intended to be a demo of the Little CMS\\n\"\n                    \"color engine. Both lcms and this program are open source.\\n\"\n                    \"You can obtain both in source code at https://www.littlecms.com\\n\"\n                    \"For suggestions, comments, bug reports etc. send mail to\\n\"\n                    \"info@littlecms.com\\n\\n\");\n\n    exit(0);\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              102,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Help",
            "parameters": {
              "level": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nvoid HandleSwitches(int argc, char *argv[])\n{\n    int s;\n\n    while ((s = xgetopt(argc,argv,\"a:A:BbC:c:D:d:h:H:k:K:lLn:N:O:o:r:R:T:t:V:v:xX8y:Y:-:\")) != EOF) {\n\n    switch (s) {\n\n    case '-':\n        if (strcmp(xoptarg, \"help\") == 0)\n        {\n            Help(0);\n        }\n        else\n        {\n            FatalError(\"Unknown option - run without args to see valid ones.\\n\");\n        }\n        break;\n\n    case 'a':\n    case 'A':\n        ObserverAdaptationState = atof(xoptarg);\n        if (ObserverAdaptationState < 0 ||\n            ObserverAdaptationState > 1.0)\n            FatalError(\"Adaptation state should be 0..1\");\n        break;\n\n    case 'b':\n    case 'B':\n        BlackPointCompensation = TRUE;\n        break;\n\n    case 'c':\n    case 'C':\n        PrecalcMode = atoi(xoptarg);\n        if (PrecalcMode < 0 || PrecalcMode > 2) {\n            FatalError(\"Unknown precalc mode '%d'\", PrecalcMode);\n        }\n        break;\n\n    case 'd':\n    case 'D':\n        // Doing that is correct and safe: Description points to memory allocated in the command line.\n        // same for Copyright and output devicelink.\n        Description = xoptarg;\n        break;\n\n    case 'h':\n    case 'H':\n        Help(atoi(xoptarg));\n        return;\n\n    case 'k':\n    case 'K':\n        InkLimit = atof(xoptarg);\n        if (InkLimit < 0.0 || InkLimit > 400.0) {\n            FatalError(\"Ink limit must be 0%%..400%%\");\n        }\n        break;\n\n\n    case 'l':\n    case 'L': KeepLinearization = TRUE;\n        break;\n\n    case 'n':\n    case 'N':\n        if (PrecalcMode != 1) {\n            FatalError(\"Precalc mode already specified\");\n        }\n        NumOfGridPoints = atoi(xoptarg);\n        break;\n\n    case 'o':\n    case 'O':\n        cOutProf = xoptarg;\n        break;\n\n\n    case 'r':\n    case 'R':\n        Version = atof(xoptarg);\n        if (Version < 2.0 || Version > 4.3) {\n            fprintf(stderr, \"WARNING: lcms was not aware of this version, tag types may be wrong!\\n\");\n        }\n        break;\n\n    case 't':\n    case 'T':\n        Intent = atoi(xoptarg);  // Will be validated latter on\n        break;\n\n    case 'V':\n    case 'v':\n        Verbose = atoi(xoptarg);\n        if (Verbose < 0 || Verbose > 3) {\n            FatalError(\"Unknown verbosity level '%d'\", Verbose);\n        }\n        break;\n\n    case '8':\n        lUse8bits = TRUE;\n        break;\n\n\n\n    case 'y':\n    case 'Y':\n        Copyright = xoptarg;\n        break;\n\n\n\n    case 'x':\n    case 'X': TagResult = TRUE;\n        break;\n\n\n    default:\n\n        FatalError(\"Unknown option - run without args to see valid ones.\\n\");\n    }\n    }\n}",
          "fn_code_pos": [
            [
              105,
              0
            ],
            [
              229,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HandleSwitches",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool SetTextTags(cmsHPROFILE hProfile)\n{\n    cmsMLU *DescriptionMLU, *CopyrightMLU;\n    cmsBool  rc = FALSE;\n    cmsContext ContextID = cmsGetProfileContextID(hProfile);\n\n    DescriptionMLU  = cmsMLUalloc(ContextID, 1);\n    CopyrightMLU    = cmsMLUalloc(ContextID, 1);\n\n    if (DescriptionMLU == NULL || CopyrightMLU == NULL) goto Error;\n\n    if (!cmsMLUsetASCII(DescriptionMLU,  \"en\", \"US\", Description)) goto Error;\n    if (!cmsMLUsetASCII(CopyrightMLU,    \"en\", \"US\", Copyright)) goto Error;\n\n    if (!cmsWriteTag(hProfile, cmsSigProfileDescriptionTag,  DescriptionMLU)) goto Error;\n    if (!cmsWriteTag(hProfile, cmsSigCopyrightTag,           CopyrightMLU)) goto Error;     \n\n    rc = TRUE;\n\nError:\n\n    if (DescriptionMLU)\n        cmsMLUfree(DescriptionMLU);\n    if (CopyrightMLU)\n        cmsMLUfree(CopyrightMLU);\n    return rc;\n}",
          "fn_code_pos": [
            [
              232,
              0
            ],
            [
              259,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetTextTags",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "int main(int argc, char *argv[])\n{\n    int i, nargs, rc;\n    cmsHPROFILE Profiles[257];\n    cmsHPROFILE hProfile;\n    cmsUInt32Number dwFlags;\n    cmsHTRANSFORM hTransform = NULL;\n\n    // Here we are\n    fprintf(stderr, \"Little CMS ICC device link generator - v3.2 [LittleCMS %2.2f]\\n\", cmsGetEncodedCMMversion() / 1000.0);\n    fprintf(stderr, \"Copyright (c) 1998-2024 Marti Maria Saguer. See COPYING file for details.\\n\");\n    fflush(stderr);\n\n    // Initialize\n    InitUtils(\"linkicc\");\n    rc = 0;\n    \n    // Get the options\n    HandleSwitches(argc, argv);\n\n    // How many profiles to link?\n    nargs = (argc - xoptind);\n    if (nargs < 1)\n        return Help(0); \n\n    if (nargs > 255) {\n        FatalError(\"Holy profile! what are you trying to do with so many profiles!?\");\n        goto Cleanup;\n    }\n\n    // Open all profiles\n    memset(Profiles, 0, sizeof(Profiles));\n    for (i=0; i < nargs; i++) {\n\n        Profiles[i] = OpenStockProfile(0, argv[i + xoptind]);\n        if (Profiles[i] == NULL) goto Cleanup;      \n\n        if (Verbose >= 1) {\n            PrintProfileInformation(Profiles[i]);\n        }\n    }\n\n    // Ink limiting\n    if (InkLimit != 400.0) {        \n        cmsColorSpaceSignature EndingColorSpace = cmsGetColorSpace(Profiles[nargs-1]);\n        Profiles[nargs++] = cmsCreateInkLimitingDeviceLink(EndingColorSpace, InkLimit);\n    }\n\n    // Set the flags\n    dwFlags = cmsFLAGS_KEEP_SEQUENCE;\n    switch (PrecalcMode) {\n\n        case 0: dwFlags |= cmsFLAGS_LOWRESPRECALC; break;\n        case 2: dwFlags |= cmsFLAGS_HIGHRESPRECALC; break;\n        case 1: \n            if (NumOfGridPoints > 0)\n                dwFlags |= cmsFLAGS_GRIDPOINTS(NumOfGridPoints);\n            break;\n\n        default: \n            {\n                FatalError(\"Unknown precalculation mode '%d'\", PrecalcMode);\n                goto Cleanup;\n            }\n    }\n\n    if (BlackPointCompensation)\n        dwFlags |= cmsFLAGS_BLACKPOINTCOMPENSATION;\n\n    if (TagResult)\n        dwFlags |= cmsFLAGS_GUESSDEVICECLASS;\n\n    if (KeepLinearization)\n        dwFlags |= cmsFLAGS_CLUT_PRE_LINEARIZATION|cmsFLAGS_CLUT_POST_LINEARIZATION;\n\n    if (lUse8bits) dwFlags |= cmsFLAGS_8BITS_DEVICELINK;\n\n     cmsSetAdaptationState(ObserverAdaptationState);\n     \n    // Create the color transform. Specify 0 for the format is safe as the transform \n    // is intended to be used only for the devicelink.\n    hTransform = cmsCreateMultiprofileTransform(Profiles, nargs, 0, 0, Intent, dwFlags|cmsFLAGS_NOOPTIMIZE);\n    if (hTransform == NULL) {\n        FatalError(\"Transform creation failed\");\n        goto Cleanup;\n    }\n\n    hProfile =  cmsTransform2DeviceLink(hTransform, Version, dwFlags);\n    if (hProfile == NULL) {\n        FatalError(\"Devicelink creation failed\");\n        goto Cleanup;\n    }\n\n    SetTextTags(hProfile);\n    cmsSetHeaderRenderingIntent(hProfile, Intent);\n\n    if (cmsSaveProfileToFile(hProfile, cOutProf)) {\n\n        if (Verbose > 0) \n            fprintf(stderr, \"Ok\");\n    }\n    else \n        FatalError(\"Error saving file!\");\n\n    cmsCloseProfile(hProfile);\n\n\nCleanup:\n\n    if (hTransform != NULL) cmsDeleteTransform(hTransform);\n    for (i=0; i < nargs; i++) {\n\n        if (Profiles[i] != NULL) cmsCloseProfile(Profiles[i]);\n    }\n\n    return rc;     \n}",
          "fn_code_pos": [
            [
              263,
              0
            ],
            [
              379,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"utils.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/utils/psicc/psicc.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nvoid Help(void)\n{\n    fprintf(stderr, \"usage: psicc [flags] [<Output file>]\\n\\n\");\n\n    fprintf(stderr, \"flags:\\n\\n\");\n\n    fprintf(stderr, \"-i<profile> - Input profile: Generates Color Space Array (CSA)\\n\");\n    fprintf(stderr, \"-o<profile> - Output profile: Generates Color Rendering Dictionary(CRD)\\n\");\n\n    fprintf(stderr, \"-t<0,1,2,3> - Intent (0=Perceptual, 1=Colorimetric, 2=Saturation, 3=Absolute)\\n\");\n\n    fprintf(stderr, \"-b - Black point compensation (CRD only)\\n\");\n    fprintf(stderr, \"-u - Do NOT generate resource name on CRD\\n\");\n    fprintf(stderr, \"-c<0,1,2> - Precision (0=LowRes, 1=Normal (default), 2=Hi-res) (CRD only)\\n\");\n    fprintf(stderr, \"-n<gridpoints> - Alternate way to set precision, number of CLUT points (CRD only)\\n\");\n\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"If no output file is specified, output goes to stdout.\\n\\n\");\n    fprintf(stderr, \"This program is intended to be a demo of the little cms\\n\"\n        \"engine. Both lcms and this program are freeware. You can\\n\"\n        \"obtain both in source code at https://www.littlecms.com\\n\"\n        \"For suggestions, comments, bug reports etc. send mail to\\n\"\n        \"info@littlecms.com\\n\\n\");\n\n    exit(0);\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              66,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Help",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid HandleSwitches(int argc, char *argv[])\n{\n       int s;\n      \n       while ((s = xgetopt(argc,argv,\"uUbBI:i:O:o:T:t:c:C:n:N:-:\")) != EOF) {\n\n       switch (s) \n       {\n\n       case '-':\n           if (strcmp(xoptarg, \"help\") == 0)\n           {\n               Help();\n           }\n           else\n           {\n               FatalError(\"Unknown option - run without args to see valid ones.\\n\");\n           }\n           break;\n\t \n       case 'i':\n       case 'I':\n            cInProf = xoptarg;\n            break;\n\n       case 'o':\n       case 'O':\n           cOutProf = xoptarg;\n            break;\n\n       case 'b':\n       case 'B': BlackPointCompensation =TRUE;\n            break;\n\n\n       case 't':\n       case 'T':\n            Intent = atoi(xoptarg);\n            if (Intent > 3) Intent = 3;\n            if (Intent < 0) Intent = 0;\n            break;\n     \n       case 'U':\n       case 'u':\n            Undecorated = TRUE;\n            break;\n\n       case 'c':\n       case 'C':\n            PrecalcMode = atoi(xoptarg);\n            if (PrecalcMode < 0 || PrecalcMode > 2)\n                    FatalError(\"ERROR: Unknown precalc mode '%d'\", PrecalcMode);\n            break;\n\n\n       case 'n':\n       case 'N':\n                if (PrecalcMode != 1)\n                    FatalError(\"Precalc mode already specified\");\n                NumOfGridPoints = atoi(xoptarg);\n                break;\n\n\n  default:\n\n       FatalError(\"Unknown option - run without args to see valid ones.\\n\");\n    }       \n    }\n}",
          "fn_code_pos": [
            [
              70,
              0
            ],
            [
              139,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HandleSwitches",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid GenerateCSA(void)\n{\n\tcmsHPROFILE hProfile = OpenStockProfile(0, cInProf);\n\tsize_t n;\n\tchar* Buffer;\n\n\tif (hProfile == NULL) return;\n\n\tn = cmsGetPostScriptCSA(0, hProfile, Intent, 0, NULL, 0);\n\tif (n == 0) return;\n\n    Buffer = (char*) malloc(n + 1);\n    if (Buffer != NULL) {\n\n        cmsGetPostScriptCSA(0, hProfile, Intent, 0, Buffer, (cmsUInt32Number) n);\n        Buffer[n] = 0;\n\n        fprintf(OutFile, \"%s\", Buffer);\t\n\n        free(Buffer);\n    }\n\n\tcmsCloseProfile(hProfile);\n}",
          "fn_code_pos": [
            [
              144,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GenerateCSA",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid GenerateCRD(void)\n{\n\tcmsHPROFILE hProfile = OpenStockProfile(0, cOutProf);\n\tsize_t n;\n\tchar* Buffer;\n    cmsUInt32Number dwFlags = 0;\n    \n\tif (hProfile == NULL) return;\n\n    if (BlackPointCompensation) dwFlags |= cmsFLAGS_BLACKPOINTCOMPENSATION;\n    if (Undecorated)            dwFlags |= cmsFLAGS_NODEFAULTRESOURCEDEF;\n\n    switch (PrecalcMode) {\n           \t\n\t    case 0: dwFlags |= cmsFLAGS_LOWRESPRECALC; break;\n\t\tcase 2: dwFlags |= cmsFLAGS_HIGHRESPRECALC; break;\n\t\tcase 1: \n            if (NumOfGridPoints > 0)\n                dwFlags |= cmsFLAGS_GRIDPOINTS(NumOfGridPoints);\n            break;\n\n\t\tdefault: FatalError(\"ERROR: Unknown precalculation mode '%d'\", PrecalcMode);\n\t }\n\n\tn = cmsGetPostScriptCRD(0, hProfile, Intent, dwFlags, NULL, 0);\n\tif (n == 0) return;\n\n\tBuffer = (char*) malloc(n + 1);\n\tif (Buffer == NULL) return;\n        cmsGetPostScriptCRD(0, hProfile, Intent, dwFlags, Buffer, (cmsUInt32Number) n);\n\tBuffer[n] = 0;\n\n\tfprintf(OutFile, \"%s\", Buffer);\t\t\t\n\tfree(Buffer);\n\tcmsCloseProfile(hProfile);\n}",
          "fn_code_pos": [
            [
              171,
              0
            ],
            [
              207,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GenerateCRD",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(int argc, char *argv[])\n{\n\tint nargs;\n\n    fprintf(stderr, \"Little CMS ICC PostScript generator - v2.1 [LittleCMS %2.2f]\\n\", cmsGetEncodedCMMversion() / 1000.0);\n    fprintf(stderr, \"Copyright (c) 1998-2024 Marti Maria Saguer. See COPYING file for details.\\n\");\n    fflush(stderr);\n\n\t// Initialize\n\tInitUtils(\"psicc\");\n\n\t HandleSwitches(argc, argv);\n\n     nargs = (argc - xoptind);\n\t if (nargs != 0 && nargs != 1)\n\t\t\t\tHelp();            \n\t\n    if (cInProf == NULL && cOutProf == NULL)\n        Help();\n\n\t if (nargs == 0) \n\t\t\tOutFile = stdout;\n\t else\n\t\t\tOutFile = fopen(argv[xoptind], \"wt\");\n\t   \t\t\n\t  if (cInProf != NULL)\n\t\t\tGenerateCSA();\n\t\t  \n\t  if (cOutProf != NULL)\n\t\t\tGenerateCRD();\n\t\t\n\t  if (nargs == 1) {\n\t\t  fclose(OutFile);\n\t  }\n\n      return 0;     \n}",
          "fn_code_pos": [
            [
              210,
              0
            ],
            [
              246,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"utils.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/utils/transicc/transicc.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nvoid Help(void)\n{           \n\n    fprintf(stderr, \"usage: transicc [flags] [CGATS input] [CGATS output]\\n\\n\");\n\n    fprintf(stderr, \"flags:\\n\\n\");\n    fprintf(stderr, \"-v<0..3> - Verbosity level\\n\"); \n\n    fprintf(stderr, \"-e[op] - Encoded representation of numbers\\n\");\n    fprintf(stderr, \"\\t-w - use 16 bits\\n\");     \n    fprintf(stderr, \"\\t-x - Hexadecimal\\n\\n\");\n\n    fprintf(stderr, \"-s - bounded mode (clip negatives and highlights)\\n\");\n    fprintf(stderr, \"-q - Quantize (round decimals)\\n\\n\");\n\n    fprintf(stderr, \"-i<profile> - Input profile (defaults to sRGB)\\n\");\n    fprintf(stderr, \"-o<profile> - Output profile (defaults to sRGB)\\n\");   \n    fprintf(stderr, \"-l<profile> - Transform by device-link profile\\n\");   \n   \n    PrintBuiltins();\n\n    PrintRenderingIntents();\n\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"-d<0..1> - Observer adaptation state (abs.col. only)\\n\\n\");\n\n    fprintf(stderr, \"-b - Black point compensation\\n\");\n\n    fprintf(stderr, \"-c<0,1,2,3> Precalculates transform (0=Off, 1=Normal, 2=Hi-res, 3=LoRes)\\n\\n\");     \n    fprintf(stderr, \"-n - Terse output, intended for pipe usage\\n\");\n\n    fprintf(stderr, \"-p<profile> - Soft proof profile\\n\");\n    fprintf(stderr, \"-m<0,1,2,3> - Soft proof intent\\n\");\n    fprintf(stderr, \"-g - Marks out-of-gamut colors on softproof\\n\\n\");\n\n\n\n    fprintf(stderr, \"This program is intended to be a demo of the Little CMS\\n\"\n        \"color engine. Both lcms and this program are open source.\\n\"\n        \"You can obtain both in source code at https://www.littlecms.com\\n\"\n        \"For suggestions, comments, bug reports etc. send mail to\\n\"\n        \"info@littlecms.com\\n\\n\");\n\n}",
          "fn_code_pos": [
            [
              91,
              0
            ],
            [
              136,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Help",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid HandleSwitches(int argc, char *argv[])\n{\n    int s;\n\n    while ((s = xgetopt(argc, argv,\n        \"bBC:c:d:D:eEgGI:i:L:l:m:M:nNO:o:p:P:QqSsT:t:V:v:WwxX!:-:\")) != EOF) {\n\n    switch (s){\n\n        case '-':\n            if (strcmp(xoptarg, \"help\") == 0)\n            {\n                Help();\n                exit(0);\n            }\n            else\n            {\n                FatalError(\"Unknown option - run without args to see valid ones.\\n\");\n            }\n            break;\n            \n        case '!': \n            IncludePart = xoptarg;\n            break;\n\n        case 'b':\n        case 'B': \n            BlackPointCompensation = TRUE;\n            break;\n\n        case 'c':\n        case 'C':\n            PrecalcMode = atoi(xoptarg);\n            if (PrecalcMode < 0 || PrecalcMode > 3)\n                FatalError(\"Unknown precalc mode '%d'\", PrecalcMode);\n            break;\n\n        case 'd':\n        case 'D': {\n            cmsFloat64Number ObserverAdaptationState = atof(xoptarg);\n            if (ObserverAdaptationState < 0 || \n                ObserverAdaptationState > 1.0)\n                FatalError(\"Adaptation states should be between 0 and 1\");\n\n            cmsSetAdaptationState(ObserverAdaptationState);\n                  }\n                  break;\n\n        case 'e':\n        case 'E': \n            lIsFloat = FALSE;\n            break;\n\n        case 'g':\n        case 'G':\n            GamutCheck = TRUE;\n            break;\n\n        case 'i':\n        case 'I':\n            if (lIsDeviceLink)\n                FatalError(\"icctrans: Device-link already specified\");\n\n            cInProf = xoptarg;\n            break;  \n\n        case 'l':\n        case 'L': \n            cInProf = xoptarg;\n            lIsDeviceLink = TRUE;\n            break;\n\n            // No extra intents for proofing\n        case 'm':\n        case 'M':\n            ProofingIntent = atoi(xoptarg);\n            if (ProofingIntent > 3)\n                FatalError(\"Unknown Proofing Intent '%d'\", ProofingIntent);        \n            break;      \n\n            // For compatibility\n        case 'n':\n        case 'N':\n            Verbose = 0;\n            break;\n\n            // Output profile        \n        case 'o':\n        case 'O':\n            if (lIsDeviceLink)\n                FatalError(\"icctrans: Device-link already specified\"); \n            cOutProf = xoptarg;\n            break;\n\n            // Proofing profile\n        case 'p':\n        case 'P':\n            cProofing = xoptarg;\n            break;      \n\n            // Quantize (get rid of decimals)\n        case 'q':\n        case 'Q': \n            lQuantize = TRUE;\n            break;\n\n            // Inhibit unbounded mode\n        case 's':\n        case 'S':\n               lUnbounded = FALSE;\n               break;\n\n            // The intent\n        case 't':\n        case 'T':\n            Intent = atoi(xoptarg);            \n            break;\n\n            // Verbosity level\n        case 'V':\n        case 'v':\n            Verbose = atoi(xoptarg);\n            if (Verbose < 0 || Verbose > 3) {\n                FatalError(\"Unknown verbosity level '%d'\", Verbose);\n            }\n            break;\n\n            // Wide (16 bits)\n        case 'W':\n        case 'w':\n            Width16 = TRUE;\n            break;\n\n            // Hexadecimal        \n        case 'x':\n        case 'X':\n            InHexa = TRUE;\n            break;\n\n        default:            \n            FatalError(\"Unknown option - run without args to see valid ones.\\n\");\n            }       \n    }\n\n\n    // If output CGATS involved, switch to float\n    if ((argc - xoptind) > 2) {\n        lIsFloat = TRUE;\n    }\n}",
          "fn_code_pos": [
            [
              142,
              0
            ],
            [
              292,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HandleSwitches",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid SetRange(cmsFloat64Number range, cmsBool IsInput)\n{\n    if (IsInput)\n        InputRange = range;\n    else\n        OutputRange = range;\n}",
          "fn_code_pos": [
            [
              296,
              0
            ],
            [
              303,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetRange",
            "parameters": {
              "range": "cmsFloat64Number",
              "IsInput": "cmsBool"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsNAMEDCOLORLIST* ComponentNames(cmsColorSpaceSignature space, cmsBool IsInput)\n{\n    cmsNAMEDCOLORLIST* out;\n    int i, n;\n    char Buffer[cmsMAX_PATH];\n\n    out = cmsAllocNamedColorList(0, 12, cmsMAXCHANNELS, \"\", \"\");\n    if (out == NULL) return NULL;\n\n    switch (space) {\n\n    case cmsSigXYZData:\n        SetRange(100, IsInput);\n        cmsAppendNamedColor(out, \"X\", NULL, NULL);\n        cmsAppendNamedColor(out, \"Y\", NULL, NULL);\n        cmsAppendNamedColor(out, \"Z\", NULL, NULL);\n        break;\n\n    case cmsSigLabData:\n        SetRange(1, IsInput);\n        cmsAppendNamedColor(out, \"L*\", NULL, NULL);\n        cmsAppendNamedColor(out, \"a*\", NULL, NULL);\n        cmsAppendNamedColor(out, \"b*\", NULL, NULL);\n        break;\n\n    case cmsSigLuvData:\n        SetRange(1, IsInput);\n        cmsAppendNamedColor(out, \"L\", NULL, NULL);\n        cmsAppendNamedColor(out, \"u\", NULL, NULL);\n        cmsAppendNamedColor(out, \"v\", NULL, NULL);\n        break;\n\n    case cmsSigYCbCrData:\n        SetRange(255, IsInput);\n        cmsAppendNamedColor(out, \"Y\", NULL, NULL );\n        cmsAppendNamedColor(out, \"Cb\", NULL, NULL);\n        cmsAppendNamedColor(out, \"Cr\", NULL, NULL);\n        break;\n\n\n    case cmsSigYxyData:\n        SetRange(1, IsInput);\n        cmsAppendNamedColor(out, \"Y\", NULL, NULL);\n        cmsAppendNamedColor(out, \"x\", NULL, NULL);\n        cmsAppendNamedColor(out, \"y\", NULL, NULL);\n        break;\n\n    case cmsSigRgbData:\n        SetRange(255, IsInput);\n        cmsAppendNamedColor(out, \"R\", NULL, NULL);\n        cmsAppendNamedColor(out, \"G\", NULL, NULL);\n        cmsAppendNamedColor(out, \"B\", NULL, NULL);\n        break;\n\n    case cmsSigGrayData:\n        SetRange(255, IsInput);\n        cmsAppendNamedColor(out, \"G\", NULL, NULL);      \n        break;\n\n    case cmsSigHsvData:\n        SetRange(255, IsInput);\n        cmsAppendNamedColor(out, \"H\", NULL, NULL);\n        cmsAppendNamedColor(out, \"s\", NULL, NULL);\n        cmsAppendNamedColor(out, \"v\", NULL, NULL);\n        break;\n\n    case cmsSigHlsData:\n        SetRange(255, IsInput);\n        cmsAppendNamedColor(out, \"H\", NULL, NULL);\n        cmsAppendNamedColor(out, \"l\", NULL, NULL);\n        cmsAppendNamedColor(out, \"s\", NULL, NULL);\n        break;\n\n    case cmsSigCmykData:\n        SetRange(1, IsInput);\n        cmsAppendNamedColor(out, \"C\", NULL, NULL);\n        cmsAppendNamedColor(out, \"M\", NULL, NULL);\n        cmsAppendNamedColor(out, \"Y\", NULL, NULL);                     \n        cmsAppendNamedColor(out, \"K\", NULL, NULL);\n        break;\n\n    case cmsSigCmyData:\n        SetRange(1, IsInput);\n        cmsAppendNamedColor(out, \"C\", NULL, NULL);\n        cmsAppendNamedColor(out, \"M\", NULL, NULL);\n        cmsAppendNamedColor(out, \"Y\", NULL, NULL);\n        break;\n\n    default:\n\n        SetRange(1, IsInput);\n\n        n = cmsChannelsOfColorSpace(space);\n\n        for (i=0; i < n; i++) {\n\n            sprintf(Buffer, \"Channel #%d\", i + 1);\n            cmsAppendNamedColor(out, Buffer, NULL, NULL);\n        }\n    }\n\n    return out;\n\n}",
          "fn_code_pos": [
            [
              308,
              0
            ],
            [
              412,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComponentNames",
            "parameters": {
              "space": "cmsColorSpaceSignature",
              "IsInput": "cmsBool"
            },
            "return_type": "cmsNAMEDCOLORLIST"
          }
        },
        {
          "fn_code": "static\ncmsBool OpenTransforms(void)\n{\n    cmsHPROFILE hInput, hOutput, hProof;\n    cmsUInt32Number dwIn, dwOut, dwFlags;\n    cmsNAMEDCOLORLIST* List;\n    int i;\n\n    // We don't need cache\n    dwFlags = cmsFLAGS_NOCACHE;\n\n    if (lIsDeviceLink) {\n\n        hInput  = OpenStockProfile(0, cInProf);\n        if (hInput == NULL) return FALSE; \n        hOutput = NULL;\n        hProof  = NULL;\n\n        if (cmsGetDeviceClass(hInput) == cmsSigNamedColorClass) {\n            OutputColorSpace  = cmsGetColorSpace(hInput);\n            InputColorSpace = cmsGetPCS(hInput);\n        }\n        else {\n            InputColorSpace  = cmsGetColorSpace(hInput);\n            OutputColorSpace = cmsGetPCS(hInput);\n        }\n\n        // Read colorant tables if present\n        if (cmsIsTag(hInput, cmsSigColorantTableTag)) {\n            List = cmsReadTag(hInput, cmsSigColorantTableTag);\n            InputColorant = cmsDupNamedColorList(List);\n            InputRange = 1;\n        }\n        else InputColorant = ComponentNames(InputColorSpace, TRUE);\n\n        if (cmsIsTag(hInput, cmsSigColorantTableOutTag)){\n\n            List = cmsReadTag(hInput, cmsSigColorantTableOutTag);\n            OutputColorant = cmsDupNamedColorList(List);\n            OutputRange = 1;\n        }\n        else OutputColorant = ComponentNames(OutputColorSpace, FALSE);\n\n    }\n    else {\n\n        hInput  = OpenStockProfile(0, cInProf);\n        if (hInput == NULL) return FALSE;\n\n        hOutput = OpenStockProfile(0, cOutProf);    \n        if (hOutput == NULL) return FALSE;\n        hProof  = NULL;\n\n\n        if (cmsGetDeviceClass(hInput) == cmsSigLinkClass ||\n            cmsGetDeviceClass(hOutput) == cmsSigLinkClass)   \n            FatalError(\"Use -l flag for devicelink profiles!\\n\");\n\n\n        InputColorSpace   = cmsGetColorSpace(hInput);\n        OutputColorSpace  = cmsGetColorSpace(hOutput);\n\n        // Read colorant tables if present\n        if (cmsIsTag(hInput, cmsSigColorantTableTag)) {\n            List = cmsReadTag(hInput, cmsSigColorantTableTag);\n            InputColorant = cmsDupNamedColorList(List);\n            if (cmsNamedColorCount(InputColorant) <= 3) \n                SetRange(255, TRUE);\n            else\n                SetRange(1, TRUE);  // Inks are already divided by 100 in the formatter\n\n        }\n        else InputColorant = ComponentNames(InputColorSpace, TRUE);\n\n        if (cmsIsTag(hOutput, cmsSigColorantTableTag)){\n\n            List = cmsReadTag(hOutput, cmsSigColorantTableTag);\n            OutputColorant = cmsDupNamedColorList(List);\n            if (cmsNamedColorCount(OutputColorant) <= 3) \n                SetRange(255, FALSE);\n            else\n                SetRange(1, FALSE);  // Inks are already divided by 100 in the formatter\n        }\n        else OutputColorant = ComponentNames(OutputColorSpace, FALSE);\n\n\n        if (cProofing != NULL) {\n\n            hProof = OpenStockProfile(0, cProofing);\n            if (hProof == NULL) return FALSE;\n            dwFlags |= cmsFLAGS_SOFTPROOFING;\n        }\n    }\n\n    // Print information on profiles\n    if (Verbose > 2) {\n\n        printf(\"Profile:\\n\");\n        PrintProfileInformation(hInput);\n\n        if (hOutput) {\n\n            printf(\"Output profile:\\n\");\n            PrintProfileInformation(hOutput);\n        }  \n\n        if (hProof != NULL) {\n            printf(\"Proofing profile:\\n\");\n            PrintProfileInformation(hProof);\n        }\n    }\n\n\n    // Input is always in floating point\n    dwIn  = cmsFormatterForColorspaceOfProfile(hInput, 0, TRUE);\n\n    if (lIsDeviceLink) {\n\n        dwOut = cmsFormatterForPCSOfProfile(hInput, lIsFloat ? 0 : 2, lIsFloat);\n    }\n    else {\n\n        // 16 bits or floating point (only on output)   \n        dwOut = cmsFormatterForColorspaceOfProfile(hOutput, lIsFloat ? 0 : 2, lIsFloat);\n    }\n\n    // For named color, there is a specialized formatter\n    if (cmsGetDeviceClass(hInput) == cmsSigNamedColorClass) {\n        \n        dwIn = TYPE_NAMED_COLOR_INDEX;\n        InputNamedColor = TRUE;\n    }\n\n    // Precision mode\n    switch (PrecalcMode) {\n\n       case 0: dwFlags |= cmsFLAGS_NOOPTIMIZE; break;\n       case 2: dwFlags |= cmsFLAGS_HIGHRESPRECALC; break;\n       case 3: dwFlags |= cmsFLAGS_LOWRESPRECALC; break;\n       case 1: break;\n\n       default: \n           FatalError(\"Unknown precalculation mode '%d'\", PrecalcMode);\n    }\n\n\n    if (BlackPointCompensation) \n        dwFlags |= cmsFLAGS_BLACKPOINTCOMPENSATION;\n\n\n    if (GamutCheck) {\n\n        cmsUInt16Number Alarm[cmsMAXCHANNELS];\n\n        if (hProof == NULL)\n            FatalError(\"I need proofing profile -p for gamut checking!\");\n\n        for (i=0; i < cmsMAXCHANNELS; i++)\n            Alarm[i] = 0xFFFF;\n\n        cmsSetAlarmCodes(Alarm);\n        dwFlags |= cmsFLAGS_GAMUTCHECK;            \n    }\n\n\n    // The main transform\n    hTrans = cmsCreateProofingTransform(hInput,  dwIn, hOutput, dwOut, hProof, Intent, ProofingIntent, dwFlags);\n\n    if (hProof) cmsCloseProfile(hProof);\n\n    if (hTrans == NULL) return FALSE;\n\n\n    // PCS Dump if requested\n    hTransXYZ = NULL; hTransLab = NULL;\n\n    if (hOutput && Verbose > 1) {\n\n        cmsHPROFILE hXYZ = cmsCreateXYZProfile();\n        cmsHPROFILE hLab = cmsCreateLab4Profile(NULL);\n\n        hTransXYZ = cmsCreateTransform(hInput, dwIn, hXYZ,  lIsFloat ? TYPE_XYZ_DBL : TYPE_XYZ_16, Intent, cmsFLAGS_NOCACHE);        \n        if (hTransXYZ == NULL) return FALSE;\n\n        hTransLab = cmsCreateTransform(hInput, dwIn, hLab,  lIsFloat? TYPE_Lab_DBL : TYPE_Lab_16, Intent, cmsFLAGS_NOCACHE);    \n        if (hTransLab == NULL) return FALSE;\n\n        cmsCloseProfile(hXYZ);\n        cmsCloseProfile(hLab);\n    } \n\n    if (hInput) cmsCloseProfile(hInput);\n    if (hOutput) cmsCloseProfile(hOutput); \n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              416,
              0
            ],
            [
              611,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OpenTransforms",
            "parameters": {},
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid CloseTransforms(void)\n{\n    if (InputColorant) cmsFreeNamedColorList(InputColorant);\n    if (OutputColorant) cmsFreeNamedColorList(OutputColorant);\n\n    if (hTrans) cmsDeleteTransform(hTrans);\n    if (hTransLab) cmsDeleteTransform(hTransLab);\n    if (hTransXYZ) cmsDeleteTransform(hTransXYZ);\n\n}",
          "fn_code_pos": [
            [
              615,
              0
            ],
            [
              625,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CloseTransforms",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid GetLine(char* Buffer, const char* frm, ...)\n{    \n    int res;\n    va_list args;\n\n    va_start(args, frm);\n\n    do {\n        if (xisatty(stdin)) \n            vfprintf(stderr, frm, args);\n\n        res = scanf(\"%4095s\", Buffer);        \n        // Reported codeQL bug: 'The result of scanf is only checked against 0, but it can also return EOF.'\n        // It is not obviously \"only checked against 0\", but it happens that C99 requires EOF to be negative\n        if (res < 0 || toupper(Buffer[0]) == 'Q') { // Quit?\n\n            CloseTransforms();\n\n            if (xisatty(stdin))  \n                fprintf(stderr, \"Done.\\n\");\n\n            exit(0);        \n        }\n    } while (res == 0);\n\n    va_end(args);  \n}",
          "fn_code_pos": [
            [
              630,
              0
            ],
            [
              657,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetLine",
            "parameters": {
              "Buffer": "char",
              "frm": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid PrintFloatResults(cmsFloat64Number Value[])\n{\n    cmsUInt32Number i, n;\n    char ChannelName[cmsMAX_PATH];\n    cmsFloat64Number v;\n\n    n = cmsChannelsOfColorSpace(OutputColorSpace);\n    for (i=0; i < n; i++) {\n\n        if (OutputColorant != NULL) {\n\n            cmsNamedColorInfo(OutputColorant, i, ChannelName, NULL, NULL, NULL, NULL);         \n        }\n        else {\n            OutputRange = 1;\n            sprintf(ChannelName, \"Channel #%u\", i + 1);\n        }\n\n        v = (cmsFloat64Number) Value[i]* OutputRange;\n\n        if (lQuantize) \n            v = floor(v + 0.5);\n\n        if (!lUnbounded) {\n\n               if (v < 0)\n                      v = 0;\n               if (v > OutputRange)\n                      v = OutputRange;\n        }\n\n        if (Verbose <= 0)\n            printf(\"%.4f \", v);\n        else\n            printf(\"%s=%.4f \", ChannelName, v);\n    }   \n\n    printf(\"\\n\");\n}",
          "fn_code_pos": [
            [
              661,
              0
            ],
            [
              700,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintFloatResults",
            "parameters": {
              "Value": "cmsFloat64Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsUInt16Number GetIndex(void)\n{\n    char Buffer[4096], Name[cmsMAX_PATH], Prefix[40], Suffix[40];\n    int index, max;\n    const cmsNAMEDCOLORLIST* NamedColorList;\n    \n    NamedColorList = cmsGetNamedColorList(hTrans);\n    if (NamedColorList == NULL) return 0;\n\n    max = cmsNamedColorCount(NamedColorList)-1;\n\n    GetLine(Buffer, \"Color index (0..%d)? \", max);\n    index = atoi(Buffer);\n\n    if (index > max)\n        FatalError(\"Named color %d out of range!\", index);\n\n    cmsNamedColorInfo(NamedColorList, index, Name, Prefix, Suffix, NULL, NULL);\n\n    printf(\"\\n%s %s %s\\n\", Prefix, Name, Suffix);\n\n    return (cmsUInt16Number) index;\n}",
          "fn_code_pos": [
            [
              704,
              0
            ],
            [
              727,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetIndex",
            "parameters": {},
            "return_type": "cmsUInt16Number"
          }
        },
        {
          "fn_code": "static\nvoid TakeFloatValues(cmsFloat64Number Float[])\n{\n    cmsUInt32Number i, n;\n    char ChannelName[cmsMAX_PATH];\n    char Buffer[4096];\n\n    if (xisatty(stdin))\n        fprintf(stderr, \"\\nEnter values, 'q' to quit\\n\");\n\n    if (InputNamedColor) {\n\n        // This is named color index, which is always cmsUInt16Number\n        cmsUInt16Number index = GetIndex();\n        memcpy(Float, &index, sizeof(cmsUInt16Number));\n        return;\n    }\n\n    n = cmsChannelsOfColorSpace(InputColorSpace);\n    for (i=0; i < n; i++) {\n\n        if (InputColorant) {\n            cmsNamedColorInfo(InputColorant, i, ChannelName, NULL, NULL, NULL, NULL);          \n        }\n        else {\n            InputRange = 1;\n            sprintf(ChannelName, \"Channel #%u\", i+1);\n        }\n\n        GetLine(Buffer, \"%s? \", ChannelName);\n\n        Float[i] = (cmsFloat64Number) atof(Buffer) / InputRange;\n    }       \n\n    if (xisatty(stdin))\n        fprintf(stderr, \"\\n\");\n}",
          "fn_code_pos": [
            [
              730,
              0
            ],
            [
              766,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TakeFloatValues",
            "parameters": {
              "Float": "cmsFloat64Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid PrintPCSFloat(cmsFloat64Number Input[])\n{\n    if (Verbose > 1 && hTransXYZ && hTransLab) {\n\n        cmsCIEXYZ XYZ = { 0, 0, 0 };\n        cmsCIELab Lab = { 0, 0, 0 };\n\n        if (hTransXYZ) cmsDoTransform(hTransXYZ, Input, &XYZ, 1);\n        if (hTransLab) cmsDoTransform(hTransLab, Input, &Lab, 1);\n\n        printf(\"[PCS] Lab=(%.4f,%.4f,%.4f) XYZ=(%.4f,%.4f,%.4f)\\n\", Lab.L, Lab.a, Lab.b, \n            XYZ.X * 100.0, XYZ.Y * 100.0, XYZ.Z * 100.0);\n\n    }\n}",
          "fn_code_pos": [
            [
              768,
              0
            ],
            [
              783,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintPCSFloat",
            "parameters": {
              "Input": "cmsFloat64Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid PrintEncodedResults(cmsUInt16Number Encoded[])\n{\n    cmsUInt32Number i, n;\n    char ChannelName[cmsMAX_PATH];\n    cmsUInt32Number v;\n\n    n = cmsChannelsOfColorSpace(OutputColorSpace);\n    for (i=0; i < n; i++) {\n\n        if (OutputColorant != NULL) {\n\n            cmsNamedColorInfo(OutputColorant, i, ChannelName, NULL, NULL, NULL, NULL);          \n        }\n        else {          \n            sprintf(ChannelName, \"Channel #%u\", i + 1);\n        }\n\n        if (Verbose > 0)\n            printf(\"%s=\", ChannelName);\n\n        v = Encoded[i];\n\n        if (InHexa) {\n\n            if (Width16)\n                printf(\"0x%04X \", (int) floor(v + .5));\n            else\n                printf(\"0x%02X \", (int) floor(v / 257. + .5));\n\n        } else {\n\n            if (Width16)\n                printf(\"%d \", (int) floor(v + .5));\n            else\n                printf(\"%d \", (int) floor(v / 257. + .5));\n        }\n\n    }   \n\n    printf(\"\\n\");\n}",
          "fn_code_pos": [
            [
              790,
              0
            ],
            [
              831,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintEncodedResults",
            "parameters": {
              "Encoded": "cmsUInt16Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid PrintPCSEncoded(cmsFloat64Number Input[])\n{\n    if (Verbose > 1 && hTransXYZ && hTransLab) {\n\n        cmsUInt16Number XYZ[3], Lab[3];\n\n        if (hTransXYZ) cmsDoTransform(hTransXYZ, Input, XYZ, 1);\n        if (hTransLab) cmsDoTransform(hTransLab, Input, Lab, 1);\n\n        printf(\"[PCS] Lab=(0x%04X,0x%04X,0x%04X) XYZ=(0x%04X,0x%04X,0x%04X)\\n\", Lab[0], Lab[1], Lab[2], \n            XYZ[0], XYZ[1], XYZ[2]);\n\n    }\n}",
          "fn_code_pos": [
            [
              835,
              0
            ],
            [
              849,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintPCSEncoded",
            "parameters": {
              "Input": "cmsFloat64Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number GetIT8Val(const char* Name, cmsFloat64Number Max)\n{\n    const char* Val = cmsIT8GetData(hIT8in, CGATSPatch, Name);\n\n    if (Val == NULL) \n        FatalError(\"Field '%s' not found\", Name);\n\n    return atof(Val) / Max;\n\n}",
          "fn_code_pos": [
            [
              858,
              0
            ],
            [
              868,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetIT8Val",
            "parameters": {
              "Name": "char",
              "Max": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\nvoid TakeCGATSValues(int nPatch, cmsFloat64Number Float[])\n{\n\n    // At first take the name if SAMPLE_ID is present\n    if (cmsIT8GetPatchName(hIT8in, nPatch, CGATSPatch) == NULL) {\n        FatalError(\"Sorry, I need 'SAMPLE_ID' on input CGATS to operate.\");\n    }\n\n\n    // Special handling for named color profiles. \n    // Lookup the name in the names database (the transform)\n\n    if (InputNamedColor) {\n\n        const cmsNAMEDCOLORLIST* NamedColorList;\n        int index;\n\n        NamedColorList = cmsGetNamedColorList(hTrans);\n        if (NamedColorList == NULL) \n            FatalError(\"Malformed named color profile\");\n\n        index = cmsNamedColorIndex(NamedColorList, CGATSPatch);\n        if (index < 0) \n            FatalError(\"Named color '%s' not found in the profile\", CGATSPatch); \n\n        Float[0] = index;\n        return;\n    }\n\n    // Color is not a spot color, proceed.\n\n    switch (InputColorSpace) {\n\n        // Encoding should follow CGATS specification.\n\n    case cmsSigXYZData:\n        Float[0] = cmsIT8GetDataDbl(hIT8in, CGATSPatch, \"XYZ_X\") / 100.0;\n        Float[1] = cmsIT8GetDataDbl(hIT8in, CGATSPatch, \"XYZ_Y\") / 100.0;\n        Float[2] = cmsIT8GetDataDbl(hIT8in, CGATSPatch, \"XYZ_Z\") / 100.0;        \n        break;\n\n    case cmsSigLabData:\n        Float[0] = cmsIT8GetDataDbl(hIT8in, CGATSPatch, \"LAB_L\");\n        Float[1] = cmsIT8GetDataDbl(hIT8in, CGATSPatch, \"LAB_A\");\n        Float[2] = cmsIT8GetDataDbl(hIT8in, CGATSPatch, \"LAB_B\");        \n        break;\n\n\n    case cmsSigRgbData:\n        Float[0] = GetIT8Val(\"RGB_R\", 255.0);\n        Float[1] = GetIT8Val(\"RGB_G\", 255.0);\n        Float[2] = GetIT8Val(\"RGB_B\", 255.0);\n        break;\n\n    case cmsSigGrayData:\n        Float[0] = GetIT8Val(\"GRAY\", 255.0);\n        break;\n\n    case cmsSigCmykData:\n        Float[0] = GetIT8Val(\"CMYK_C\", 1.0);\n        Float[1] = GetIT8Val(\"CMYK_M\", 1.0);\n        Float[2] = GetIT8Val(\"CMYK_Y\", 1.0);\n        Float[3] = GetIT8Val(\"CMYK_K\", 1.0);\n        break;\n\n    case cmsSigCmyData:                        \n        Float[0] = GetIT8Val(\"CMY_C\", 1.0);\n        Float[1] = GetIT8Val(\"CMY_M\", 1.0);\n        Float[2] = GetIT8Val(\"CMY_Y\", 1.0);\n        break;\n\n    case cmsSig1colorData:\n    case cmsSig2colorData:\n    case cmsSig3colorData:\n    case cmsSig4colorData:\n    case cmsSig5colorData:\n    case cmsSig6colorData:\n    case cmsSig7colorData:\n    case cmsSig8colorData:\n    case cmsSig9colorData:\n    case cmsSig10colorData:\n    case cmsSig11colorData:\n    case cmsSig12colorData:\n    case cmsSig13colorData:\n    case cmsSig14colorData:\n    case cmsSig15colorData:\n        {\n            cmsUInt32Number i, n;\n\n            n = cmsChannelsOfColorSpace(InputColorSpace);\n            for (i=0; i < n; i++) { \n\n                char Buffer[255];\n\n                sprintf(Buffer, \"%uCLR_%u\", n, i+1);\n                Float[i] = GetIT8Val(Buffer, 100.0);\n            }\n\n        }\n        break;\n\n    default: \n        {\n            cmsUInt32Number i, n;\n\n            n = cmsChannelsOfColorSpace(InputColorSpace);\n            for (i=0; i < n; i++) { \n\n                char Buffer[255];\n\n                sprintf(Buffer, \"CHAN_%u\", i+1);\n                Float[i] = GetIT8Val(Buffer, 1.0);\n            }\n\n        }\n    }\n\n}",
          "fn_code_pos": [
            [
              873,
              0
            ],
            [
              991,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TakeCGATSValues",
            "parameters": {
              "nPatch": "int",
              "Float": "cmsFloat64Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid SetCGATSfld(const char* Col, cmsFloat64Number Val)\n{\n    if (lQuantize) \n        Val = floor(Val + 0.5);\n\n    if (!cmsIT8SetDataDbl(hIT8out, CGATSPatch, Col, Val)) {\n        FatalError(\"couldn't set '%s' on output cgats '%s'\", Col, CGATSoutFilename);\n    }\n}",
          "fn_code_pos": [
            [
              993,
              0
            ],
            [
              1002,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetCGATSfld",
            "parameters": {
              "Col": "char",
              "Val": "cmsFloat64Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid PutCGATSValues(cmsFloat64Number Float[])\n{   \n    cmsIT8SetData(hIT8out, CGATSPatch, \"SAMPLE_ID\", CGATSPatch);\n    switch (OutputColorSpace) {\n\n\n    // Encoding should follow CGATS specification.\n\n    case cmsSigXYZData:\n\n        SetCGATSfld(\"XYZ_X\", Float[0] * 100.0);\n        SetCGATSfld(\"XYZ_Y\", Float[1] * 100.0);\n        SetCGATSfld(\"XYZ_Z\", Float[2] * 100.0);                    \n        break;\n\n    case cmsSigLabData:\n\n        SetCGATSfld(\"LAB_L\", Float[0]);\n        SetCGATSfld(\"LAB_A\", Float[1]);\n        SetCGATSfld(\"LAB_B\", Float[2]);                    \n        break;\n\n\n    case cmsSigRgbData:\n        SetCGATSfld(\"RGB_R\", Float[0] * 255.0);\n        SetCGATSfld(\"RGB_G\", Float[1] * 255.0);\n        SetCGATSfld(\"RGB_B\", Float[2] * 255.0);\n        break;\n\n    case cmsSigGrayData:\n        SetCGATSfld(\"GRAY\", Float[0] * 255.0);                    \n        break;\n\n    case cmsSigCmykData:\n        SetCGATSfld(\"CMYK_C\", Float[0]);\n        SetCGATSfld(\"CMYK_M\", Float[1]);\n        SetCGATSfld(\"CMYK_Y\", Float[2]);\n        SetCGATSfld(\"CMYK_K\", Float[3]);\n        break;\n\n    case cmsSigCmyData:\n        SetCGATSfld(\"CMY_C\", Float[0]);\n        SetCGATSfld(\"CMY_M\", Float[1]);\n        SetCGATSfld(\"CMY_Y\", Float[2]);                 \n        break;\n\n    case cmsSig1colorData:\n    case cmsSig2colorData:\n    case cmsSig3colorData:\n    case cmsSig4colorData:\n    case cmsSig5colorData:\n    case cmsSig6colorData:\n    case cmsSig7colorData:\n    case cmsSig8colorData:\n    case cmsSig9colorData:\n    case cmsSig10colorData:\n    case cmsSig11colorData:\n    case cmsSig12colorData:\n    case cmsSig13colorData:\n    case cmsSig14colorData:\n    case cmsSig15colorData:\n        {\n\n            cmsInt32Number i, n;\n\n            n = cmsChannelsOfColorSpace(InputColorSpace);\n            for (i=0; i < n; i++) { \n\n                char Buffer[255];\n\n                sprintf(Buffer, \"%uCLR_%u\", n, i+1);\n\n                SetCGATSfld(Buffer, Float[i] * 100.0);\n            }\n        }\n        break;\n\n    default: \n        {\n\n            cmsInt32Number i, n;\n\n            n = cmsChannelsOfColorSpace(InputColorSpace);\n            for (i=0; i < n; i++) { \n\n                char Buffer[255];\n\n                sprintf(Buffer, \"CHAN_%u\", i+1);\n\n                SetCGATSfld(Buffer, Float[i]);\n            }\n        }\n    }\n}",
          "fn_code_pos": [
            [
              1006,
              0
            ],
            [
              1100,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PutCGATSValues",
            "parameters": {
              "Float": "cmsFloat64Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid SetOutputDataFormat(void) \n{\n    cmsIT8DefineDblFormat(hIT8out, \"%.4g\");\n    cmsIT8SetPropertyStr(hIT8out, \"ORIGINATOR\", \"icctrans\");\n\n    if (IncludePart != NULL) \n        cmsIT8SetPropertyStr(hIT8out, \".INCLUDE\", IncludePart);\n\n    cmsIT8SetComment(hIT8out, \"Data follows\");\n    cmsIT8SetPropertyDbl(hIT8out, \"NUMBER_OF_SETS\", nMaxPatches);\n\n\n    switch (OutputColorSpace) {\n\n\n        // Encoding should follow CGATS specification.\n\n    case cmsSigXYZData:\n        cmsIT8SetPropertyDbl(hIT8out, \"NUMBER_OF_FIELDS\", 4);\n        cmsIT8SetDataFormat(hIT8out, 0, \"SAMPLE_ID\");\n        cmsIT8SetDataFormat(hIT8out, 1, \"XYZ_X\");\n        cmsIT8SetDataFormat(hIT8out, 2, \"XYZ_Y\");\n        cmsIT8SetDataFormat(hIT8out, 3, \"XYZ_Z\");\n        break;\n\n    case cmsSigLabData:\n        cmsIT8SetPropertyDbl(hIT8out, \"NUMBER_OF_FIELDS\", 4);\n        cmsIT8SetDataFormat(hIT8out, 0, \"SAMPLE_ID\");\n        cmsIT8SetDataFormat(hIT8out, 1, \"LAB_L\");\n        cmsIT8SetDataFormat(hIT8out, 2, \"LAB_A\");\n        cmsIT8SetDataFormat(hIT8out, 3, \"LAB_B\");\n        break;\n\n\n    case cmsSigRgbData:\n        cmsIT8SetPropertyDbl(hIT8out, \"NUMBER_OF_FIELDS\", 4);\n        cmsIT8SetDataFormat(hIT8out, 0, \"SAMPLE_ID\");\n        cmsIT8SetDataFormat(hIT8out, 1, \"RGB_R\");\n        cmsIT8SetDataFormat(hIT8out, 2, \"RGB_G\");\n        cmsIT8SetDataFormat(hIT8out, 3, \"RGB_B\");\n        break;\n\n    case cmsSigGrayData:                \n        cmsIT8SetPropertyDbl(hIT8out, \"NUMBER_OF_FIELDS\", 2);\n        cmsIT8SetDataFormat(hIT8out, 0, \"SAMPLE_ID\");\n        cmsIT8SetDataFormat(hIT8out, 1, \"GRAY\");\n        break;\n\n    case cmsSigCmykData:\n        cmsIT8SetPropertyDbl(hIT8out, \"NUMBER_OF_FIELDS\", 5);\n        cmsIT8SetDataFormat(hIT8out, 0, \"SAMPLE_ID\");\n        cmsIT8SetDataFormat(hIT8out, 1, \"CMYK_C\");\n        cmsIT8SetDataFormat(hIT8out, 2, \"CMYK_M\");\n        cmsIT8SetDataFormat(hIT8out, 3, \"CMYK_Y\");\n        cmsIT8SetDataFormat(hIT8out, 4, \"CMYK_K\");\n        break;\n\n    case cmsSigCmyData:\n        cmsIT8SetPropertyDbl(hIT8out, \"NUMBER_OF_FIELDS\", 4);\n        cmsIT8SetDataFormat(hIT8out, 0, \"SAMPLE_ID\");\n        cmsIT8SetDataFormat(hIT8out, 1, \"CMY_C\");\n        cmsIT8SetDataFormat(hIT8out, 2, \"CMY_M\");\n        cmsIT8SetDataFormat(hIT8out, 3, \"CMY_Y\");                   \n        break;\n\n    case cmsSig1colorData:\n    case cmsSig2colorData:\n    case cmsSig3colorData:\n    case cmsSig4colorData:\n    case cmsSig5colorData:\n    case cmsSig6colorData:\n    case cmsSig7colorData:\n    case cmsSig8colorData:\n    case cmsSig9colorData:\n    case cmsSig10colorData:\n    case cmsSig11colorData:\n    case cmsSig12colorData:\n    case cmsSig13colorData:\n    case cmsSig14colorData:\n    case cmsSig15colorData:\n        {\n            int i, n;\n            char Buffer[255];\n\n            n = cmsChannelsOfColorSpace(OutputColorSpace);\n            cmsIT8SetPropertyDbl(hIT8out, \"NUMBER_OF_FIELDS\", n+1);\n            cmsIT8SetDataFormat(hIT8out, 0, \"SAMPLE_ID\");\n\n            for (i=1; i <= n; i++) {\n                sprintf(Buffer, \"%dCLR_%d\", n, i);\n                cmsIT8SetDataFormat(hIT8out, i, Buffer);\n            }\n        }\n        break;\n\n    default: {\n\n        int i, n;\n        char Buffer[255];\n\n        n = cmsChannelsOfColorSpace(OutputColorSpace);\n        cmsIT8SetPropertyDbl(hIT8out, \"NUMBER_OF_FIELDS\", n+1);\n        cmsIT8SetDataFormat(hIT8out, 0, \"SAMPLE_ID\");\n\n        for (i=1; i <= n; i++) {\n            sprintf(Buffer, \"CHAN_%d\", i);\n            cmsIT8SetDataFormat(hIT8out, i, Buffer);\n        }\n    }\n    }\n}",
          "fn_code_pos": [
            [
              1105,
              0
            ],
            [
              1216,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetOutputDataFormat",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid OpenCGATSFiles(int argc, char *argv[])\n{    \n    int nParams = argc - xoptind;\n\n    if (nParams >= 1)  {\n\n        hIT8in = cmsIT8LoadFromFile(0, argv[xoptind]);\n\n        if (hIT8in == NULL) \n            FatalError(\"'%s' is not recognized as a CGATS file\", argv[xoptind]);\n\n        nMaxPatches = (int) cmsIT8GetPropertyDbl(hIT8in, \"NUMBER_OF_SETS\");     \n    }\n\n    if (nParams == 2) {\n\n        hIT8out = cmsIT8Alloc(NULL);            \n        SetOutputDataFormat();\n        strncpy(CGATSoutFilename, argv[xoptind+1], cmsMAX_PATH-1);      \n    }\n\n    if (nParams > 2) FatalError(\"Too many CGATS files\");\n}",
          "fn_code_pos": [
            [
              1220,
              0
            ],
            [
              1243,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OpenCGATSFiles",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(int argc, char *argv[])\n{    \n    cmsUInt16Number Output[cmsMAXCHANNELS];\n    cmsFloat64Number OutputFloat[cmsMAXCHANNELS];\n    cmsFloat64Number InputFloat[cmsMAXCHANNELS];\n\n    int nPatch = 0;\n\n    fprintf(stderr, \"LittleCMS ColorSpace conversion calculator - 5.1 [LittleCMS %2.2f]\\n\", cmsGetEncodedCMMversion() / 1000.0);\n    fprintf(stderr, \"Copyright (c) 1998-2024 Marti Maria Saguer. See COPYING file for details.\\n\");\n    fflush(stderr);\n\n    InitUtils(\"transicc\");\n\n    Verbose = 1;\n\n    if (argc == 1) {\n\n        Help();              \n        return 0;\n    }\n\n    HandleSwitches(argc, argv);\n\n    // Open profiles, create transforms\n    if (!OpenTransforms()) return 1;\n\n    // Open CGATS input if specified\n    OpenCGATSFiles(argc, argv);\n\n    // Main loop: read all values and convert them\n    for(;;) {\n\n        if (hIT8in != NULL) {\n\n            if (nPatch >= nMaxPatches) break;\n            TakeCGATSValues(nPatch++, InputFloat);\n\n        } else {\n\n            if (feof(stdin)) break;         \n            TakeFloatValues(InputFloat);\n\n        }\n\n        if (lIsFloat) \n            cmsDoTransform(hTrans, InputFloat, OutputFloat, 1);\n        else\n            cmsDoTransform(hTrans, InputFloat, Output, 1);\n\n\n        if (hIT8out != NULL) {\n\n            PutCGATSValues(OutputFloat);\n        }\n        else {\n\n            if (lIsFloat) {\n                PrintFloatResults(OutputFloat); PrintPCSFloat(InputFloat);\n            }\n            else {\n                PrintEncodedResults(Output);   PrintPCSEncoded(InputFloat);      \n            }\n\n        }\n    }\n\n\n    // Cleanup\n    CloseTransforms();\n\n    if (hIT8in)\n        cmsIT8Free(hIT8in);\n\n    if (hIT8out) {      \n        cmsIT8SaveToFile(hIT8out, CGATSoutFilename);\n        cmsIT8Free(hIT8out);\n    }\n\n    // All is ok\n    return 0;     \n}",
          "fn_code_pos": [
            [
              1248,
              0
            ],
            [
              1329,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ComponentNames(cmsColorSpaceSignature space, cmsBool IsInput)",
          "fn_dec_pos": [
            [
              309,
              19
            ],
            [
              309,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComponentNames",
            "parameters": {
              "space": "cmsColorSpaceSignature",
              "IsInput": "cmsBool"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"utils.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#    include <unistd.h>",
          [
            29,
            0
          ],
          [
            29,
            23
          ]
        ],
        [
          "#    include <io.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/utils/samples/mktiff8.c": {
      "fn_def_list": [
        {
          "fn_code": "static\ndouble DecodeAbTIFF(double ab)\n{\n\tif (ab <= 128.)\n\t\tab += 127.;\n\telse\n\t\tab -= 127.;\n\n\treturn ab;\n}",
          "fn_code_pos": [
            [
              28,
              0
            ],
            [
              37,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DecodeAbTIFF",
            "parameters": {
              "ab": "double"
            },
            "return_type": "double"
          }
        },
        {
          "fn_code": "static\ncmsToneCurve* CreateStep(void)\n{\n\tcmsToneCurve* Gamma;\n\tcmsUInt16Number* Table;\n\tint i;\n\tdouble a;\n\n\tTable = calloc(4096, sizeof(cmsUInt16Number));\n\tif (Table == NULL) return NULL;\n\n\tfor (i=0; i < 4096; i++) {\n\n\t\ta = (double) i * 255. / 4095.;\n\n\t\ta = DecodeAbTIFF(a);\n\n\t\tTable[i] = (cmsUInt16Number) floor(a * 257. + 0.5);\n\t}\n\n\tGamma = cmsBuildTabulatedToneCurve16(0, 4096, Table);\n\tfree(Table);\n\n\treturn Gamma;\n}",
          "fn_code_pos": [
            [
              39,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CreateStep",
            "parameters": {},
            "return_type": "cmsToneCurve"
          }
        },
        {
          "fn_code": "static\ncmsToneCurve* CreateLinear(void)\n{\n\tcmsUInt16Number Linear[2] = { 0, 0xffff };\n\n\treturn cmsBuildTabulatedToneCurve16(0, 2, Linear);          \n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              72,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CreateLinear",
            "parameters": {},
            "return_type": "cmsToneCurve"
          }
        },
        {
          "fn_code": "static\ncmsBool SetTextTags(cmsHPROFILE hProfile)\n{\n    cmsMLU *DescriptionMLU, *CopyrightMLU;\n    cmsBool  rc = FALSE;\n  \n    DescriptionMLU  = cmsMLUalloc(0, 1);\n    CopyrightMLU    = cmsMLUalloc(0, 1);\n\n    if (DescriptionMLU == NULL || CopyrightMLU == NULL) goto Error;\n\n    if (!cmsMLUsetASCII(DescriptionMLU,  \"en\", \"US\", \"Little cms Tiff8 CIELab\")) goto Error;\n    if (!cmsMLUsetASCII(CopyrightMLU,    \"en\", \"US\", \"Copyright (c) Marti Maria, 2010. All rights reserved.\")) goto Error;\n\n    if (!cmsWriteTag(hProfile, cmsSigProfileDescriptionTag,  DescriptionMLU)) goto Error;\n    if (!cmsWriteTag(hProfile, cmsSigCopyrightTag,           CopyrightMLU)) goto Error;     \n\n    rc = TRUE;\n\nError:\n\n    if (DescriptionMLU)\n        cmsMLUfree(DescriptionMLU);\n    if (CopyrightMLU)\n        cmsMLUfree(CopyrightMLU);\n    return rc;\n}",
          "fn_code_pos": [
            [
              77,
              0
            ],
            [
              103,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetTextTags",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "int main(int argc, char *argv[])\n{\n\tcmsHPROFILE hProfile;\n\tcmsPipeline *AToB0;\n\tcmsToneCurve* PreLinear[3];\n\tcmsToneCurve *Lin, *Step;\n\n\tfprintf(stderr, \"Creating lcmstiff8.icm...\");\n    \n    remove(\"lcmstiff8.icm\");\n\thProfile = cmsOpenProfileFromFile(\"lcmstiff8.icm\", \"w\");\n\n\t// Create linearization\n\tLin  = CreateLinear();\n\tStep = CreateStep();\n\n\tPreLinear[0] = Lin;\n\tPreLinear[1] = Step;\n\tPreLinear[2] = Step;\n\n    AToB0 = cmsPipelineAlloc(0, 3, 3);\n\n\tcmsPipelineInsertStage(AToB0, \n\t\tcmsAT_BEGIN, cmsStageAllocToneCurves(0, 3, PreLinear));\n\n\tcmsSetColorSpace(hProfile, cmsSigLabData);\n\tcmsSetPCS(hProfile, cmsSigLabData);\n\tcmsSetDeviceClass(hProfile, cmsSigLinkClass);\n\tcmsSetProfileVersion(hProfile, 4.2);\n\n    cmsWriteTag(hProfile, cmsSigAToB0Tag, AToB0);\n\t\n    SetTextTags(hProfile);\n\n\tcmsCloseProfile(hProfile);\n\n\tcmsFreeToneCurve(Lin);\n\tcmsFreeToneCurve(Step);\n\tcmsPipelineFree(AToB0);\n\t\t\n\tfprintf(stderr, \"Done.\\n\");\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              106,
              0
            ],
            [
              149,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "CreateStep(void)",
          "fn_dec_pos": [
            [
              40,
              14
            ],
            [
              40,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CreateStep",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CreateLinear(void)",
          "fn_dec_pos": [
            [
              67,
              14
            ],
            [
              67,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CreateLinear",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"lcms2.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/utils/samples/roundtrip.c": {
      "fn_def_list": [
        {
          "fn_code": "static\ndouble VecDist(cmsUInt8Number bin[3], cmsUInt8Number bout[3])\n{\n       double rdist, gdist, bdist;\n\n       rdist = fabs((double) bout[0] - bin[0]);\n       gdist = fabs((double) bout[1] - bin[1]);\n       bdist = fabs((double) bout[2] - bin[2]);\n\n       return (sqrt((rdist*rdist + gdist*gdist + bdist*bdist)));\n}",
          "fn_code_pos": [
            [
              26,
              0
            ],
            [
              36,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VecDist",
            "parameters": {
              "bin": "cmsUInt8Number",
              "bout": "cmsUInt8Number"
            },
            "return_type": "double"
          }
        },
        {
          "fn_code": "int main(int  argc, char* argv[])\n{\n\n    int r, g, b;\n    cmsUInt8Number RGB[3], RGB_OUT[3];\n    cmsHTRANSFORM xform;\n    cmsHPROFILE hProfile;\n    double err, SumX=0, SumX2=0, Peak = 0, n = 0;\n\n\n    if (argc != 2) {\n        printf(\"roundtrip <RGB icc profile>\\n\");\n        return 1;\n    }\n\n    hProfile = cmsOpenProfileFromFile(argv[1], \"r\");\n    if (hProfile == NULL)\n    {\n        printf(\"invalid profile\\n\");\n        return 1;\n    }\n\n    xform = cmsCreateTransform(hProfile,TYPE_RGB_8, hProfile, TYPE_RGB_8, INTENT_RELATIVE_COLORIMETRIC, cmsFLAGS_NOOPTIMIZE);\n    if (xform == NULL)\n    {\n        printf(\"Not a valid RGB profile\\n\");\n        return 1;\n    }\n\n    for (r=0; r< 256; r++) {\n        printf(\"%d  \\r\", r);\n        for (g=0; g < 256; g++) {\n            for (b=0; b < 256; b++) {\n\n                RGB[0] = r;\n                RGB[1] = g;\n                RGB[2] = b;\n\n                cmsDoTransform(xform, RGB, RGB_OUT, 1);\n\n                err = VecDist(RGB, RGB_OUT);\n\n                SumX  += err;\n                SumX2 += err * err;\n                n += 1.0;\n                if (err > Peak)\n                    Peak = err;\n\n            }\n        }\n    }\n\n    printf(\"Average %g\\n\", SumX / n);\n    printf(\"Max %g\\n\", Peak);\n    printf(\"Std  %g\\n\", sqrt((n*SumX2 - SumX * SumX) / (n*(n-1))));\n    cmsCloseProfile(hProfile);\n    cmsDeleteTransform(xform);\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              39,
              0
            ],
            [
              98,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"lcms2.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/utils/samples/mkcmy.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nint Forward(register WORD In[], register WORD Out[], register LPVOID Cargo)\n{\t\n\tLPCARGO C = (LPCARGO) Cargo;\t\n\tWORD RGB[3];\n    cmsCIELab Lab;\n\n    cmsLabEncoded2Float(&Lab, In);\n\n\tprintf(\"%g %g %g\\n\", Lab.L, Lab.a, Lab.b);\n\n\tcmsDoTransform(C ->Lab2RGB, In, &RGB, 1);\n\n\n\tOut[0] = 0xFFFF - RGB[0]; // Our CMY is negative of RGB\n\tOut[1] = 0xFFFF - RGB[1]; \n\tOut[2] = 0xFFFF - RGB[2]; \n\t\n\t\n\treturn TRUE;\n\n}",
          "fn_code_pos": [
            [
              45,
              0
            ],
            [
              66,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Forward",
            "parameters": {
              "In": "WORD",
              "Out": "WORD",
              "Cargo": "LPVOID"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint Reverse(register WORD In[], register WORD Out[], register LPVOID Cargo)\n{\t\n\n\tLPCARGO C = (LPCARGO) Cargo;\t\n\tWORD RGB[3];\n  \n\tRGB[0] = 0xFFFF - In[0];\n\tRGB[1] = 0xFFFF - In[1];\n\tRGB[2] = 0xFFFF - In[2];\n\n\tcmsDoTransform(C ->RGB2Lab, &RGB, Out, 1);\n\t\n\treturn TRUE;\n\n}",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Reverse",
            "parameters": {
              "In": "WORD",
              "Out": "WORD",
              "Cargo": "LPVOID"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nvoid InitCargo(LPCARGO Cargo)\n{\n\t\n\n\tCargo -> hLab = cmsCreateLabProfile(NULL);\n\tCargo -> hRGB = cmsCreate_sRGBProfile();  \n\t\n\tCargo->Lab2RGB = cmsCreateTransform(Cargo->hLab, TYPE_Lab_16, \n\t\t\t\t\t\t\t\t\t    Cargo ->hRGB, TYPE_RGB_16,\n\t\t\t\t\t\t\t\t\t\tINTENT_RELATIVE_COLORIMETRIC, \n\t\t\t\t\t\t\t\t\t\tcmsFLAGS_NOTPRECALC);\n\n\tCargo->RGB2Lab = cmsCreateTransform(Cargo ->hRGB, TYPE_RGB_16, \n\t\t\t\t\t\t\t\t\t\tCargo ->hLab, TYPE_Lab_16, \n\t\t\t\t\t\t\t\t\t\tINTENT_RELATIVE_COLORIMETRIC, \n\t\t\t\t\t\t\t\t\t\tcmsFLAGS_NOTPRECALC);\n}",
          "fn_code_pos": [
            [
              88,
              0
            ],
            [
              105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "InitCargo",
            "parameters": {
              "Cargo": "LPCARGO"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid FreeCargo(LPCARGO Cargo)\n{\n\tcmsDeleteTransform(Cargo ->Lab2RGB);\n\tcmsDeleteTransform(Cargo ->RGB2Lab);\n\tcmsCloseProfile(Cargo ->hLab);\n\tcmsCloseProfile(Cargo ->hRGB);\n}",
          "fn_code_pos": [
            [
              110,
              0
            ],
            [
              117,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FreeCargo",
            "parameters": {
              "Cargo": "LPCARGO"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(void)\n{\n\tLPLUT AToB0, BToA0;\t\n\tCARGO Cargo;\n\tcmsHPROFILE hProfile;\n\t\n\tfprintf(stderr, \"Creating lcmscmy.icm...\");\t\n\t\n\tInitCargo(&Cargo);\n\n\thProfile = cmsCreateLabProfile(NULL);\n\t\n\n    AToB0 = cmsAllocLUT();\n\tBToA0 = cmsAllocLUT();\n\n\tcmsAlloc3DGrid(AToB0, 25, 3, 3);\n\tcmsAlloc3DGrid(BToA0, 25, 3, 3);\n\t\n\t\n\tcmsSample3DGrid(AToB0, Reverse, &Cargo, 0);\n\tcmsSample3DGrid(BToA0, Forward, &Cargo, 0);\n\t\n\t\n    cmsAddTag(hProfile, icSigAToB0Tag, AToB0);\n\tcmsAddTag(hProfile, icSigBToA0Tag, BToA0);\n\n\tcmsSetColorSpace(hProfile, icSigCmyData);\n\tcmsSetDeviceClass(hProfile, icSigOutputClass);\n\n\tcmsAddTag(hProfile, icSigProfileDescriptionTag, \"CMY \");\n    cmsAddTag(hProfile, icSigCopyrightTag,          \"Copyright (c) HP, 2007. All rights reserved.\");\n    cmsAddTag(hProfile, icSigDeviceMfgDescTag,      \"Little cms\");    \n    cmsAddTag(hProfile, icSigDeviceModelDescTag,    \"CMY space\");\n\n\t_cmsSaveProfile(hProfile, \"lcmscmy.icm\");\n\t\n\t\n\tcmsFreeLUT(AToB0);\n\tcmsFreeLUT(BToA0);\n\tcmsCloseProfile(hProfile);\t\n\tFreeCargo(&Cargo);\n\tfprintf(stderr, \"Done.\\n\");\n\n\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              122,
              0
            ],
            [
              169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\t\t\t\tcmsHPROFILE   hLab;\n\t\t\t\tcmsHPROFILE   hRGB;\n\t\t\t\tcmsHTRANSFORM Lab2RGB;\n\t\t\t\tcmsHTRANSFORM RGB2Lab;\n\n\t\t\t\t} CARGO, FAR* LPCARGO;",
          {
            "hLab": "cmsHPROFILE",
            "hRGB": "cmsHPROFILE",
            "Lab2RGB": "cmsHTRANSFORM",
            "RGB2Lab": "cmsHTRANSFORM"
          },
          "CARGO",
          [
            31,
            0
          ],
          [
            37,
            26
          ]
        ],
        [
          "typedef struct {\n\t\t\t\tcmsHPROFILE   hLab;\n\t\t\t\tcmsHPROFILE   hRGB;\n\t\t\t\tcmsHTRANSFORM Lab2RGB;\n\t\t\t\tcmsHTRANSFORM RGB2Lab;\n\n\t\t\t\t} CARGO, FAR* LPCARGO;",
          {
            "hLab": "cmsHPROFILE",
            "hRGB": "cmsHPROFILE",
            "Lab2RGB": "cmsHTRANSFORM",
            "RGB2Lab": "cmsHTRANSFORM"
          },
          "FAR",
          [
            31,
            0
          ],
          [
            37,
            26
          ]
        ],
        [
          "typedef struct {\n\t\t\t\tcmsHPROFILE   hLab;\n\t\t\t\tcmsHPROFILE   hRGB;\n\t\t\t\tcmsHTRANSFORM Lab2RGB;\n\t\t\t\tcmsHTRANSFORM RGB2Lab;\n\n\t\t\t\t} CARGO, FAR* LPCARGO;",
          {
            "hLab": "cmsHPROFILE",
            "hRGB": "cmsHPROFILE",
            "Lab2RGB": "cmsHTRANSFORM",
            "RGB2Lab": "cmsHTRANSFORM"
          },
          "LPCARGO",
          [
            31,
            0
          ],
          [
            37,
            26
          ]
        ],
        [
          "typedef struct {\n\t\t\t\tcmsHPROFILE   hLab;\n\t\t\t\tcmsHPROFILE   hRGB;\n\t\t\t\tcmsHTRANSFORM Lab2RGB;\n\t\t\t\tcmsHTRANSFORM RGB2Lab;\n\n\t\t\t\t} CARGO, FAR* LPCARGO;",
          {
            "hLab": "cmsHPROFILE",
            "hRGB": "cmsHPROFILE",
            "Lab2RGB": "cmsHTRANSFORM",
            "RGB2Lab": "cmsHTRANSFORM"
          },
          "CARGO",
          [
            31,
            0
          ],
          [
            37,
            26
          ]
        ],
        [
          "typedef struct {\n\t\t\t\tcmsHPROFILE   hLab;\n\t\t\t\tcmsHPROFILE   hRGB;\n\t\t\t\tcmsHTRANSFORM Lab2RGB;\n\t\t\t\tcmsHTRANSFORM RGB2Lab;\n\n\t\t\t\t} CARGO, FAR* LPCARGO;",
          {
            "hLab": "cmsHPROFILE",
            "hRGB": "cmsHPROFILE",
            "Lab2RGB": "cmsHTRANSFORM",
            "RGB2Lab": "cmsHTRANSFORM"
          },
          "FAR",
          [
            31,
            0
          ],
          [
            37,
            26
          ]
        ],
        [
          "typedef struct {\n\t\t\t\tcmsHPROFILE   hLab;\n\t\t\t\tcmsHPROFILE   hRGB;\n\t\t\t\tcmsHTRANSFORM Lab2RGB;\n\t\t\t\tcmsHTRANSFORM RGB2Lab;\n\n\t\t\t\t} CARGO, FAR* LPCARGO;",
          {
            "hLab": "cmsHPROFILE",
            "hRGB": "cmsHPROFILE",
            "Lab2RGB": "cmsHTRANSFORM",
            "RGB2Lab": "cmsHTRANSFORM"
          },
          "LPCARGO",
          [
            31,
            0
          ],
          [
            37,
            26
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/utils/samples/vericc.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nint PrintUsage(void)\n{\n\tfprintf(stderr, \"Sets profile version\\n\\nUsage: vericc --r<version> iccprofile.icc\\n\"); \n\treturn 0; \n}",
          "fn_code_pos": [
            [
              30,
              0
            ],
            [
              35,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintUsage",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int main(int argc, char *argv[])\n{\n       cmsHPROFILE hProfile;\n\t   char* ptr;\n\t   cmsFloat64Number Version;\n\n\t   if (argc != 3)  return PrintUsage();\n\n\t   ptr = argv[1];\n\t   if (strncmp(ptr, \"--r\", 3) != 0) return PrintUsage();\n\t   ptr += 3;\n\t   if (!*ptr) { fprintf(stderr, \"Wrong version number\\n\"); return 1; }\n\n\t   Version = atof(ptr); \n\n\t   hProfile = cmsOpenProfileFromFile(argv[2], \"r\");\n\t   if (hProfile == NULL) { fprintf(stderr, \"'%s': cannot open\\n\", argv[2]); return 1; }\n\n\t   cmsSetProfileVersion(hProfile, Version);\n\t   cmsSaveProfileToFile(hProfile, \"$$tmp.icc\");\n\t   cmsCloseProfile(hProfile);\n\n\t   remove(argv[2]);\n\t   rename(\"$$tmp.icc\", argv[2]);\n\t   return 0;\n\n\n}",
          "fn_code_pos": [
            [
              37,
              0
            ],
            [
              64,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"lcms2.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/utils/samples/wtpt.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nvoid HandleSwitches(int argc, char *argv[])\n{\n       int s;\n\n       while ((s = xgetopt(argc, argv, \"lcx\")) != EOF) {\n\n              switch (s){\n\n\n              case 'l':\n                     lShowLab = TRUE;\n                     break;\n\n              case 'c':\n                     lShowLCh = TRUE;\n                     break;\n\n              case 'x':\n                     lShowXYZ = FALSE;\n                     break;\n\n              default:\n\n                     FatalError(\"Unknown option - run without args to see valid ones.\\n\");\n              }\n       }\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HandleSwitches",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Help(void)\n{\n       fprintf(stderr, \"little CMS ICC white point utility - v3 [LittleCMS %2.2f]\\n\", LCMS_VERSION / 1000.0);\n\n       fprintf(stderr, \"usage: wtpt [flags] [<ICC profile>]\\n\\n\");\n\n       fprintf(stderr, \"flags:\\n\\n\");\n       \n       fprintf(stderr, \"%cl - CIE Lab\\n\", SW);\n       fprintf(stderr, \"%cc - CIE LCh\\n\", SW);\n       fprintf(stderr, \"%cx - Don't show XYZ\\n\", SW);\n\n       fprintf(stderr, \"\\nIf no parameters are given, then this program will\\n\");\n       fprintf(stderr, \"ask for XYZ value of media white. If parameter given, it must be\\n\");\n       fprintf(stderr, \"the profile to inspect.\\n\\n\");\n\n       fprintf(stderr, \"This program is intended to be a demo of the little cms\\n\"\n              \"engine. Both lcms and this program are freeware. You can\\n\"\n              \"obtain both in source code at http://www.littlecms.com\\n\"\n              \"For suggestions, comments, bug reports etc. send mail to\\n\"\n              \"info@littlecms.com\\n\\n\");\n       exit(0);\n}",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              92,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Help",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid ShowWhitePoint(cmsCIEXYZ* WtPt)\n{\n       cmsCIELab Lab;\n       cmsCIELCh LCh;\n       cmsCIExyY xyY;\n\n\n       cmsXYZ2Lab(NULL, &Lab, WtPt);\n       cmsLab2LCh(&LCh, &Lab);\n       cmsXYZ2xyY(&xyY, WtPt);\n\n\n       if (lShowXYZ) printf(\"XYZ=(%3.1f, %3.1f, %3.1f)\\n\", WtPt->X, WtPt->Y, WtPt->Z);\n       if (lShowLab) printf(\"Lab=(%3.3f, %3.3f, %3.3f)\\n\", Lab.L, Lab.a, Lab.b);\n       if (lShowLCh) printf(\"LCh=(%3.3f, %3.3f, %3.3f)\\n\", LCh.L, LCh.C, LCh.h);\n       {\n              double Ssens = (LCh.C * 100.0 )/ sqrt(LCh.C*LCh.C + LCh.L * LCh.L) ;\n              printf(\"Sens = %f\\n\", Ssens);\n       }\n\n}",
          "fn_code_pos": [
            [
              96,
              0
            ],
            [
              117,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ShowWhitePoint",
            "parameters": {
              "WtPt": "cmsCIEXYZ"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(int argc, char *argv[])\n{\n       int nargs;\n\n       InitUtils(\"wtpt\");\n       \n       HandleSwitches(argc, argv);\n\n       nargs = (argc - xoptind);\n\n       if (nargs != 1)\n              Help();\n\n       else {\n              cmsCIEXYZ* WtPt;\n              cmsHPROFILE hProfile = cmsOpenProfileFromFile(argv[xoptind], \"r\");  \n              if (hProfile == NULL) return 1;\n\n              WtPt = cmsReadTag(hProfile, cmsSigMediaWhitePointTag);\n              ShowWhitePoint(WtPt);\n              cmsCloseProfile(hProfile);\n       }\n       \n       return 0;\n}",
          "fn_code_pos": [
            [
              120,
              0
            ],
            [
              144,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"utils.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/utils/samples/itufax.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nvoid ITU2Lab(WORD In[3], LPcmsCIELab Lab)\n{\n   Lab -> L = (double) In[0] / 655.35;\n   Lab -> a = (double) 170.* (In[1] - 32768.) / 65535.;\n   Lab -> b = (double) 200.* (In[2] - 24576.) / 65535.;\n}",
          "fn_code_pos": [
            [
              38,
              0
            ],
            [
              44,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ITU2Lab",
            "parameters": {
              "In": "WORD",
              "Lab": "LPcmsCIELab"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Lab2ITU(LPcmsCIELab Lab, WORD Out[3])\n{\n\tOut[0] = (WORD) floor((double) (Lab -> L / 100.)* 65535. + 0.5);\n    Out[1] = (WORD) floor((double) (Lab -> a / 170.)* 65535. + 32768. + 0.5);\n    Out[2] = (WORD) floor((double) (Lab -> b / 200.)* 65535. + 24576. + 0.5);\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              53,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Lab2ITU",
            "parameters": {
              "Lab": "LPcmsCIELab",
              "Out": "WORD"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nint InputDirection(register WORD In[], register WORD Out[], register LPVOID Cargo)\n{\t   \n    cmsCIELab Lab;\n\n    cmsLabEncoded2Float(&Lab, In);    \n    cmsClampLab(&Lab, 85, -85, 125, -75);    // This function does the necessary gamut remapping  \n    Lab2ITU(&Lab, Out);\n\n\treturn TRUE;\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              76,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "InputDirection",
            "parameters": {
              "In": "WORD",
              "Out": "WORD",
              "Cargo": "LPVOID"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint OutputDirection(register WORD In[], register WORD Out[], register LPVOID Cargo)\n{\t\n\n\tcmsCIELab Lab;\n\n    ITU2Lab(In, &Lab);\n    cmsFloat2LabEncoded(Out, &Lab);    \n\n\treturn TRUE;\n}",
          "fn_code_pos": [
            [
              79,
              0
            ],
            [
              89,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OutputDirection",
            "parameters": {
              "In": "WORD",
              "Out": "WORD",
              "Cargo": "LPVOID"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int main(int argc, char *argv[])\n{\n\tLPLUT AToB0, BToA0;\n\tcmsHPROFILE hProfile;\n\n\tfprintf(stderr, \"Creating itufax.icm...\");\n\n\tunlink(\"itufax.icm\");\n\thProfile = cmsOpenProfileFromFile(\"itufax.icm\", \"w\");\n\t\n    AToB0 = cmsAllocLUT();\n\tBToA0 = cmsAllocLUT(); \n\n\tcmsAlloc3DGrid(AToB0, GRID_POINTS, 3, 3);\n\tcmsAlloc3DGrid(BToA0, GRID_POINTS, 3, 3);\n    \n\tcmsSample3DGrid(AToB0, InputDirection, NULL, 0);\n\tcmsSample3DGrid(BToA0, OutputDirection, NULL, 0);\n\t\t\n    cmsAddTag(hProfile, icSigAToB0Tag, AToB0);\n\tcmsAddTag(hProfile, icSigBToA0Tag, BToA0);\n\n                                \n\tcmsSetColorSpace(hProfile, icSigLabData);\n    cmsSetPCS(hProfile, icSigLabData);\n    cmsSetDeviceClass(hProfile, icSigColorSpaceClass);\n\n\tcmsAddTag(hProfile, icSigProfileDescriptionTag, \"ITU T.42/Fax JPEG CIEL*a*b*\");\n    cmsAddTag(hProfile, icSigCopyrightTag,          \"No Copyright, use freely.\");\n    cmsAddTag(hProfile, icSigDeviceMfgDescTag,      \"Little cms\");    \n    cmsAddTag(hProfile, icSigDeviceModelDescTag,    \"ITU T.42/Fax JPEG CIEL*a*b*\");\n\t\n\tcmsCloseProfile(hProfile);\n    \n\tcmsFreeLUT(AToB0);\n\tcmsFreeLUT(BToA0);\n\n\tfprintf(stderr, \"Done.\\n\");\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              97,
              0
            ],
            [
              137,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"lcms.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/utils/samples/mkgrayer.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nint Forward(register WORD In[], register WORD Out[], register LPVOID Cargo)\n{\t\n    cmsCIELab Lab;\n\n\n    cmsLabEncoded2Float(&Lab, In);\n\n\tif (fabs(Lab.a) < 3 && fabs(Lab.b) < 3) {\n\t\t\n\t\tdouble L_01 = Lab.L / 100.0;\n\t    WORD K;\n\n\t\tif (L_01 > 1) L_01 = 1;\n\t\tK = (WORD) floor(L_01* 65535.0 + 0.5);\n\n\t\tOut[0] = Out[1] = Out[2] = K; \n\t}\n\telse {\n\t\tOut[0] = 0xFFFF; Out[1] = 0; Out[2] = 0; \n\t}\n\n\treturn TRUE;\n}",
          "fn_code_pos": [
            [
              27,
              0
            ],
            [
              50,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Forward",
            "parameters": {
              "In": "WORD",
              "Out": "WORD",
              "Cargo": "LPVOID"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int main(int argc, char *argv[])\n{\n\tLPLUT BToA0;\n\tcmsHPROFILE hProfile;\n\n\tfprintf(stderr, \"Creating interpol2.icc...\");\n\n\tunlink(\"interpol2.icc\");\n\thProfile = cmsOpenProfileFromFile(\"interpol2.icc\", \"w8\");\n\n\n    BToA0 = cmsAllocLUT();\n\n\tcmsAlloc3DGrid(BToA0, 17, 3, 3);\n\t    \n\tcmsSample3DGrid(BToA0, Forward, NULL, 0);\n\t\t\t\n    cmsAddTag(hProfile, icSigBToA0Tag, BToA0);\n\t                                \n\tcmsSetColorSpace(hProfile, icSigRgbData);\n    cmsSetPCS(hProfile, icSigLabData);\n    cmsSetDeviceClass(hProfile, icSigOutputClass);\n\n\tcmsAddTag(hProfile, icSigProfileDescriptionTag, \"Interpolation test\");\n    cmsAddTag(hProfile, icSigCopyrightTag,          \"Copyright (c) HP 2007. All rights reserved.\");\n    cmsAddTag(hProfile, icSigDeviceMfgDescTag,      \"Little cms\");    \n    cmsAddTag(hProfile, icSigDeviceModelDescTag,    \"Interpolation test profile\");\n\n\t\n\tcmsCloseProfile(hProfile);\n    \n\tcmsFreeLUT(BToA0);\n\t\n\tfprintf(stderr, \"Done.\\n\");\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              92,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"lcms.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/utils/matlab/icctrans.c": {
      "fn_def_list": [
        {
          "fn_code": "static\ncmsBool FatalError(const char *frm, ...)\n{\n\tva_list args;\n\tchar Buffer[1024];\n\n\tva_start(args, frm);\n\tvsprintf(Buffer, frm, args);\n\tmexErrMsgTxt(Buffer);   \n\tva_end(args);\n\n\treturn FALSE;               \n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              78,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FatalError",
            "parameters": {
              "frm": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid MatLabErrorHandler(cmsContext ContextID, cmsUInt32Number ErrorCode, \n\t\t\t\t\t\tconst char *Text)\n{      \n\tmexErrMsgTxt(Text);    \n}",
          "fn_code_pos": [
            [
              82,
              0
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MatLabErrorHandler",
            "parameters": {
              "ContextID": "cmsContext",
              "ErrorCode": "cmsUInt32Number",
              "Text": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid xoptinit()\n{   \n\txoptind = 1;\n\txopterr = 0;\n\tletP = NULL;\n}",
          "fn_code_pos": [
            [
              92,
              0
            ],
            [
              98,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "xoptinit",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nint xgetopt(int argc, char *argv[], char *optionS)\n{\n\tunsigned char ch;\n\tchar *optP;\n\n\tif (SW == 0) {\n\t\tSW = '/';\n\t}\n\n\tif (argc > xoptind) {\n\t\tif (letP == NULL) {\n\t\t\tif ((letP = argv[xoptind]) == NULL ||\n\t\t\t\t*(letP++) != SW)  goto gopEOF;\n\t\t\tif (*letP == SW) {\n\t\t\t\txoptind++;  goto gopEOF;\n\t\t\t}\n\t\t}\n\t\tif (0 == (ch = *(letP++))) {\n\t\t\txoptind++;  goto gopEOF;\n\t\t}\n\t\tif (':' == ch  ||  (optP = strchr(optionS, ch)) == NULL)\n\t\t\tgoto gopError;\n\t\tif (':' == *(++optP)) {\n\t\t\txoptind++;\n\t\t\tif (0 == *letP) {\n\t\t\t\tif (argc <= xoptind)  goto  gopError;\n\t\t\t\tletP = argv[xoptind++];\n\t\t\t}\n\t\t\txoptarg = letP;\n\t\t\tletP = NULL;\n\t\t} else {\n\t\t\tif (0 == *letP) {\n\t\t\t\txoptind++;\n\t\t\t\tletP = NULL;\n\t\t\t}\n\t\t\txoptarg = NULL;\n\t\t}\n\t\treturn ch;\n\t}\ngopEOF:\n\txoptarg = letP = NULL;\n\treturn EOF;\n\ngopError:\n\txoptarg = NULL;    \n\tif (xopterr)\n\t\tFatalError (\"get command line option\");\n\treturn ('?');\n}",
          "fn_code_pos": [
            [
              101,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "xgetopt",
            "parameters": {
              "argc": "int",
              "argv": "char",
              "optionS": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nsize_t SizeOfArrayType(const mxArray *Array)\n{\n\n\tswitch (mxGetClassID(Array))  {\n\n\t case mxINT8_CLASS:   return 1;\n\t case mxUINT8_CLASS:  return 1;\n\t case mxINT16_CLASS:  return 2;\n\t case mxUINT16_CLASS: return 2;  \n\t case mxSINGLE_CLASS: return 4;\n\t case mxDOUBLE_CLASS: return 0; // Special case -- lcms handles double as size=0\n\n\n\t default:\n\t\t FatalError(\"Unsupported data type\");\n\t\t return 0;\n\t}\n}",
          "fn_code_pos": [
            [
              155,
              0
            ],
            [
              173,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SizeOfArrayType",
            "parameters": {
              "Array": "mxArray"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static\nsize_t GetNumberOfPixels(const mxArray* In)\n{\n\tint nDimensions  = mxGetNumberOfDimensions(In); \n\tconst int  *Dimensions   = mxGetDimensions(In);\n\n\tswitch (nDimensions) {\n\n\t\tcase 1: return 1;                            // It is just a spot color\n\t\tcase 2: return Dimensions[0];                // A scanline\n\t\tcase 3: return Dimensions[0]*Dimensions[1];  // A image\n\n\t\tdefault:\n\t\t\tFatalError(\"Unsupported array of %d dimensions\", nDimensions);\n\t\t\treturn 0;\n\t}\n}",
          "fn_code_pos": [
            [
              180,
              0
            ],
            [
              196,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetNumberOfPixels",
            "parameters": {
              "In": "mxArray"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static\nmxArray* AllocateOutputArray(const mxArray* In, int OutputChannels)\n{       \n\n\tmxArray*\tOut\t\t\t  = mxDuplicateArray(In);   // Make a \"deep copy\" of Input array \n\tint         nDimensions   = mxGetNumberOfDimensions(In);    \n\tconst int*\tDimensions    = mxGetDimensions(In);\n\tint         InputChannels = Dimensions[nDimensions-1];\n\n\n\t// Modify pixel size only if needed\n\n\tif (InputChannels != OutputChannels) {\n\n\n\t\tint i, NewSize;\n\t\tint *ModifiedDimensions = (int*) mxMalloc(nDimensions * sizeof(int));\n\n\n\t\tmemmove(ModifiedDimensions, Dimensions, nDimensions * sizeof(int));\n\t\tModifiedDimensions[nDimensions - 1] = OutputChannels;\n\n\t\tswitch (mxGetClassID(In))  {\n\n\t\tcase mxINT8_CLASS:   NewSize = sizeof(char); break;\n\t\tcase mxUINT8_CLASS:  NewSize = sizeof(unsigned char); break;\n\t\tcase mxINT16_CLASS:  NewSize = sizeof(short); break;\n\t\tcase mxUINT16_CLASS: NewSize = sizeof(unsigned short); break;\n\n\t\tdefault:\n\t\tcase mxDOUBLE_CLASS: NewSize = sizeof(double); break;\n\t\t}\n\n\n\t\t// NewSize = 1;\n\t\tfor (i=0; i < nDimensions; i++)\n\t\t\tNewSize *= ModifiedDimensions[i];\n\n\n\t\tmxSetDimensions(Out, ModifiedDimensions, nDimensions);\n\t\tmxFree(ModifiedDimensions);\n\n\t\tmxSetPr(Out, mxRealloc(mxGetPr(Out), NewSize));             \n\n\t}\n\n\n\treturn Out;\n}",
          "fn_code_pos": [
            [
              202,
              0
            ],
            [
              250,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllocateOutputArray",
            "parameters": {
              "In": "mxArray",
              "OutputChannels": "int"
            },
            "return_type": "mxArray"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number MakeFormatDescriptor(cmsColorSpaceSignature ColorSpace, int Bytes)\n{\n\tint IsFloat = (Bytes == 0 || Bytes == 4) ? 1 : 0;\n\tint Channels = cmsChannelsOf(ColorSpace);\n\treturn FLOAT_SH(IsFloat)|COLORSPACE_SH(_cmsLCMScolorSpace(ColorSpace))|BYTES_SH(Bytes)|CHANNELS_SH(Channels)|PLANAR_SH(1);\n}",
          "fn_code_pos": [
            [
              262,
              0
            ],
            [
              268,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MakeFormatDescriptor",
            "parameters": {
              "ColorSpace": "cmsColorSpaceSignature",
              "Bytes": "int"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsHPROFILE OpenProfile(const char* File)\n{   \n\n\tcmsContext ContextID = 0;\n\n\t   if (!File) \n            return cmsCreate_sRGBProfileTHR(ContextID);    \n\n       if (cmsstrcasecmp(File, \"*Lab2\") == 0)\n                return cmsCreateLab2ProfileTHR(ContextID, NULL);\n\n       if (cmsstrcasecmp(File, \"*Lab4\") == 0)\n                return cmsCreateLab4ProfileTHR(ContextID, NULL);\n\n       if (cmsstrcasecmp(File, \"*Lab\") == 0)\n                return cmsCreateLab4ProfileTHR(ContextID, NULL);\n       \n       if (cmsstrcasecmp(File, \"*LabD65\") == 0) {\n\n           cmsCIExyY D65xyY;\n           \n           cmsWhitePointFromTemp( &D65xyY, 6504);           \n           return cmsCreateLab4ProfileTHR(ContextID, &D65xyY);\n       }\n\n       if (cmsstrcasecmp(File, \"*XYZ\") == 0)\n                return cmsCreateXYZProfileTHR(ContextID);\n\n       if (cmsstrcasecmp(File, \"*Gray22\") == 0) {\n\n           cmsToneCurve* Curve = cmsBuildGamma(ContextID, 2.2);\n           cmsHPROFILE hProfile = cmsCreateGrayProfileTHR(ContextID, cmsD50_xyY(), Curve);\n           cmsFreeToneCurve(Curve);\n           return hProfile;\n       }\n\n        if (cmsstrcasecmp(File, \"*Gray30\") == 0) {\n\n           cmsToneCurve* Curve = cmsBuildGamma(ContextID, 3.0);\n           cmsHPROFILE hProfile = cmsCreateGrayProfileTHR(ContextID, cmsD50_xyY(), Curve);\n           cmsFreeToneCurve(Curve);\n           return hProfile;\n       }\n\n       if (cmsstrcasecmp(File, \"*srgb\") == 0)\n                return cmsCreate_sRGBProfileTHR(ContextID);\n\n       if (cmsstrcasecmp(File, \"*null\") == 0)\n                return cmsCreateNULLProfileTHR(ContextID);\n\n       \n       if (cmsstrcasecmp(File, \"*Lin2222\") == 0) {\n\n            cmsToneCurve*  Gamma = cmsBuildGamma(0, 2.2);\n            cmsToneCurve*  Gamma4[4];\n            cmsHPROFILE hProfile; \n\n            Gamma4[0] = Gamma4[1] = Gamma4[2] = Gamma4[3] = Gamma;\n            hProfile = cmsCreateLinearizationDeviceLink(cmsSigCmykData, Gamma4);\n            cmsFreeToneCurve(Gamma);\n            return hProfile;\n       }\n\n           \n        return cmsOpenProfileFromFileTHR(ContextID, File, \"r\");\n}",
          "fn_code_pos": [
            [
              273,
              0
            ],
            [
              339,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OpenProfile",
            "parameters": {
              "File": "char"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number GetFlags()\n{\n\tcmsUInt32Number dwFlags = 0; \n\n\tswitch (PrecalcMode) {\n\n\tcase 0: dwFlags = cmsFLAGS_NOOPTIMIZE; break;\n\tcase 2: dwFlags = cmsFLAGS_HIGHRESPRECALC; break;\n\tcase 3: dwFlags = cmsFLAGS_LOWRESPRECALC; break;\n\tcase 1: break;\n\n\tdefault: FatalError(\"Unknown precalculation mode '%d'\", PrecalcMode);\n\t}\n\n\tif (BlackPointCompensation) \n\t\tdwFlags |= cmsFLAGS_BLACKPOINTCOMPENSATION;\n\n\treturn dwFlags;\n}",
          "fn_code_pos": [
            [
              342,
              0
            ],
            [
              361,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetFlags",
            "parameters": {},
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid OpenTransforms(int argc, char *argv[])\n{\n\n\tcmsUInt32Number dwIn, dwOut, dwFlags;\n\n\n\tif (lMultiProfileChain) {\n\n\t\tint i;\n\t\tcmsHTRANSFORM hTmp;\n\n\n\t\tnProfiles = argc - xoptind;\n\t\tfor (i=0; i < nProfiles; i++) {\n\n\t\t\thProfiles[i] = OpenProfile(argv[i+xoptind]);\n\t\t}\n\n\n\t\t// Create a temporary devicelink \n\n\t\thTmp = cmsCreateMultiprofileTransform(hProfiles, nProfiles, \n\t\t\t0, 0, Intent, GetFlags());\n\n\t\thInput = cmsTransform2DeviceLink(hTmp, 4.2, 0);\n\t\thOutput = NULL;\n\t\tcmsDeleteTransform(hTmp);\n\n\t\tInputColorSpace  = cmsGetColorSpace(hInput);\n\t\tOutputColorSpace = cmsGetPCS(hInput);        \n\t\tlIsDeviceLink = TRUE;\n\n\t}\n\telse\n\t\tif (lIsDeviceLink) {\n\n\t\t\thInput  = cmsOpenProfileFromFile(cInProf, \"r\");\n\t\t\thOutput = NULL;\n\t\t\tInputColorSpace  = cmsGetColorSpace(hInput);\n\t\t\tOutputColorSpace = cmsGetPCS(hInput);\n\n\n\t\t}\n\t\telse {\n\n\t\t\thInput  = OpenProfile(cInProf);\n\t\t\thOutput = OpenProfile(cOutProf);    \n\n\t\t\tInputColorSpace   = cmsGetColorSpace(hInput);\n\t\t\tOutputColorSpace  = cmsGetColorSpace(hOutput);\n\n\t\t\tif (cmsGetDeviceClass(hInput) == cmsSigLinkClass ||\n\t\t\t\tcmsGetDeviceClass(hOutput) == cmsSigLinkClass)   \n\t\t\t\tFatalError(\"Use %cl flag for devicelink profiles!\\n\", SW);\n\n\t\t}\n\n\n\t\t/*\n\n\t\tif (Verbose) {\n\n\t\tmexPrintf(\"From: %s\\n\", cmsTakeProductName(hInput));\n\t\tif (hOutput) mexPrintf(\"To  : %s\\n\\n\", cmsTakeProductName(hOutput));\n\n\t\t}\n\t\t*/\n\n\n\t\tOutputChannels = cmsChannelsOf(OutputColorSpace);\n\t\tInputChannels  = cmsChannelsOf(InputColorSpace);\n\n\n\t\tdwIn  = MakeFormatDescriptor(InputColorSpace, nBytesDepth);\n\t\tdwOut = MakeFormatDescriptor(OutputColorSpace, nBytesDepth);\n\n\n\t\tdwFlags = GetFlags();\n\n\t\tif (cProofing != NULL) {\n\n\t\t\thProof = OpenProfile(cProofing);\n\t\t\tdwFlags |= cmsFLAGS_SOFTPROOFING;\n\t\t}\n\n\n\n\n\t\thColorTransform = cmsCreateProofingTransform(hInput, dwIn, \n\t\t\thOutput, dwOut, \n\t\t\thProof, Intent, \n\t\t\tProofingIntent, \n\t\t\tdwFlags);\n\n}",
          "fn_code_pos": [
            [
              365,
              0
            ],
            [
              460,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OpenTransforms",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid ApplyTransforms(const mxArray *In, mxArray *Out)\n{   \n\tdouble *Input  = mxGetPr(In); \n\tdouble *Output = mxGetPr(Out);    \n\tsize_t nPixels = GetNumberOfPixels(In);;\n\n\tcmsDoTransform(hColorTransform, Input, Output, nPixels );\n\n}",
          "fn_code_pos": [
            [
              464,
              0
            ],
            [
              473,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ApplyTransforms",
            "parameters": {
              "In": "mxArray",
              "Out": "mxArray"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid CloseTransforms(void)\n{\n\tint i;\n\n\tif (hColorTransform) cmsDeleteTransform(hColorTransform);\n\tif (hInput) cmsCloseProfile(hInput);\n\tif (hOutput) cmsCloseProfile(hOutput);             \n\tif (hProof) cmsCloseProfile(hProof);\n\n\tfor (i=0; i < nProfiles; i++)\n\t\tcmsCloseProfile(hProfiles[i]);\n\n\thColorTransform = NULL; hInput = NULL; hOutput = NULL; hProof = NULL;\n}",
          "fn_code_pos": [
            [
              476,
              0
            ],
            [
              490,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CloseTransforms",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid HandleSwitches(int argc, char *argv[])\n{\n\tint  s;\n\n\txoptinit();\n\n\twhile ((s = xgetopt(argc, argv,\"C:c:VvbBI:i:O:o:T:t:L:l:r:r:P:p:Mm\")) != EOF) {\n\n\n\t\tswitch (s){\n\n\t\tcase 'b':\n\t\tcase 'B': \n\t\t\tBlackPointCompensation = TRUE;\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\tcase 'C':\n\t\t\tPrecalcMode = atoi(xoptarg);\n\t\t\tif (PrecalcMode < 0 || PrecalcMode > 3)\n\t\t\t\tFatalError(\"Unknown precalc mode '%d'\", PrecalcMode);\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\tcase 'V':\n\t\t\tVerbose = TRUE;\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\tcase 'I':\n\t\t\tif (lIsDeviceLink)\n\t\t\t\tFatalError(\"Device-link already specified\");\n\t\t\tcInProf = xoptarg;\n\t\t\tbreak;\n\n\t\tcase 'o':\n\t\tcase 'O':\n\t\t\tif (lIsDeviceLink)\n\t\t\t\tFatalError(\"Device-link already specified\"); \n\t\t\tcOutProf = xoptarg;\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\tcase 'T':\n\t\t\tIntent = atoi(xoptarg);\n\t\t\t// if (Intent > 3) Intent = 3;\n\t\t\tif (Intent < 0) Intent = 0;\n\t\t\tbreak;\n\n\n\t\tcase 'l':\n\t\tcase 'L': \n\t\t\tcInProf = xoptarg;\n\t\t\tlIsDeviceLink = TRUE;\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\tcase 'P':\n\t\t\tcProofing = xoptarg;\n\t\t\tbreak;\n\n\n\n\t\tcase 'r':\n\t\tcase 'R':\n\t\t\tProofingIntent = atoi(xoptarg);\n\t\t\t// if (ProofingIntent > 3) ProofingIntent = 3;\n\t\t\tif (ProofingIntent < 0) ProofingIntent = 0;\n\t\t\tbreak;\n\n\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tlMultiProfileChain = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tFatalError(\"Unknown option.\");\n\t\t}\n\t}\n\n\t// For multiprofile, need to specify -m\n\n\tif (xoptind < argc) {\n\n\t\tif (!lMultiProfileChain)\n\t\t\tFatalError(\"Use %cm for multiprofile transforms\", SW);\n\t}\n\n}",
          "fn_code_pos": [
            [
              493,
              0
            ],
            [
              583,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HandleSwitches",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid PrintHelp(void)\n{\n\tmexPrintf(\"(MX) little cms ColorSpace conversion tool - v2.0\\n\\n\");\n\n\tmexPrintf(\"usage: icctrans (mVar, flags)\\n\\n\");\n\n\tmexPrintf(\"mVar : Matlab array.\\n\");\n\tmexPrintf(\"flags: a string containing one or more of following options.\\n\\n\");\n\tmexPrintf(\"\\t%cv - Verbose\\n\", SW);\n\tmexPrintf(\"\\t%ci<profile> - Input profile (defaults to sRGB)\\n\", SW);\n\tmexPrintf(\"\\t%co<profile> - Output profile (defaults to sRGB)\\n\", SW);   \n\tmexPrintf(\"\\t%cl<profile> - Transform by device-link profile\\n\", SW);      \n\tmexPrintf(\"\\t%cm<profiles> - Apply multiprofile chain\\n\", SW);      \n\n\tmexPrintf(\"\\t%ct<n> - Rendering intent\\n\", SW);    \n\n\tmexPrintf(\"\\t%cb - Black point compensation\\n\", SW);\n\tmexPrintf(\"\\t%cc<0,1,2,3> - Optimize transform (0=Off, 1=Normal, 2=Hi-res, 3=Lo-Res) [defaults to 1]\\n\", SW);     \n\n\tmexPrintf(\"\\t%cp<profile> - Soft proof profile\\n\", SW);\n\tmexPrintf(\"\\t%cr<0,1,2,3> - Soft proof intent\\n\", SW);\n\n\tmexPrintf(\"\\nYou can use following built-ins as profiles:\\n\\n\");\n\n\tmexPrintf(\"\\t*Lab2  -- D50-based v2 CIEL*a*b\\n\"\n\t\"\\t*Lab4  -- D50-based v4 CIEL*a*b\\n\"\n\t\"\\t*Lab   -- D50-based v4 CIEL*a*b\\n\"\n\t\"\\t*XYZ   -- CIE XYZ (PCS)\\n\"\n\t\"\\t*sRGB  -- IEC6 1996-2.1 sRGB color space\\n\" \n\t\"\\t*Gray22 - Monochrome of Gamma 2.2\\n\"\n\t\"\\t*Gray30 - Monochrome of Gamma 3.0\\n\"\n\t\"\\t*null   - Monochrome black for all input\\n\"\n\t\"\\t*Lin2222- CMYK linearization of gamma 2.2 on each channel\\n\\n\");\n\n\tmexPrintf(\"For suggestions, comments, bug reports etc. send mail to info@littlecms.com\\n\\n\");\n\n}",
          "fn_code_pos": [
            [
              588,
              0
            ],
            [
              625,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintHelp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void mexFunction(\n\t\t\t\t int nlhs,              // Number of left hand side (output) arguments\n\t\t\t\t mxArray *plhs[],       // Array of left hand side arguments\n\t\t\t\t int nrhs,              // Number of right hand side (input) arguments\n\t\t\t\t const mxArray *prhs[]  // Array of right hand side arguments\n)\n{\n\n\tchar CommandLine[4096+1];\n\tchar *pt, *argv[128];\n\tint argc = 1;\n\n\n\tif (nrhs != 2) {    \n\n\t\tPrintHelp();              \n\t\treturn;\n\t}\n\n\n\tif(nlhs > 1) {        \n\t\tFatalError(\"Too many output arguments.\");\n\t}\n\n\n\t// Setup error handler\n\n\tcmsSetLogErrorHandler(MatLabErrorHandler);\n\n\t// Defaults\n\n\tVerbose     = 0;\n\tcInProf     = NULL;\n\tcOutProf    = NULL;\n\tcProofing   = NULL;\n\n\tlMultiProfileChain = FALSE;\n\tnProfiles   = 0;\n\n\tIntent                  = INTENT_PERCEPTUAL;\n\tProofingIntent          = INTENT_ABSOLUTE_COLORIMETRIC;\n\tPrecalcMode = 1;\n\tBlackPointCompensation  = FALSE;\n\tlIsDeviceLink           = FALSE;\n\n\t// Check types. Fist parameter is array of values, second parameter is command line\n\n\tif (!mxIsNumeric(prhs[0]))\n\t\tFatalError(\"Type mismatch on argument 1 -- Must be numeric\");\n\n\tif (!mxIsChar(prhs[1]))\n\t\tFatalError(\"Type mismatch on argument 2 -- Must be string\");\n\n\n\n\n\t// Unpack string to command line buffer\n\n\tif (mxGetString(prhs[1], CommandLine, 4096))\n\t\tFatalError(\"Cannot unpack command string\");\n\n\t// Separate to argv[] convention\n\n\targv[0] = NULL;\n\tfor (pt = strtok(CommandLine, \" \");\n\t\tpt;\n\t\tpt = strtok(NULL, \" \")) {\n\n\t\t\targv[argc++] = pt;\n\t}\n\n\n\n\t// Parse arguments\n\tHandleSwitches(argc, argv);\n\n\n\tnBytesDepth = SizeOfArrayType(prhs[0]);\n\n\tOpenTransforms(argc, argv);\n\n\n\tplhs[0] = AllocateOutputArray(prhs[0], OutputChannels);\n\n\n\tApplyTransforms(prhs[0], plhs[0]);\n\n\tCloseTransforms();\n\n\t// Done!\n}",
          "fn_code_pos": [
            [
              631,
              0
            ],
            [
              721,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mexFunction",
            "parameters": {
              "nlhs": "int",
              "plhs": "mxArray",
              "nrhs": "int",
              "prhs": "mxArray"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "AllocateOutputArray(const mxArray* In, int OutputChannels)",
          "fn_dec_pos": [
            [
              203,
              9
            ],
            [
              203,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllocateOutputArray",
            "parameters": {
              "In": "mxArray",
              "OutputChannels": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"mex.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"lcms2.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"string.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"stdarg.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/utils/tificc/tifdiff.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nvoid ConsoleWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n        char e[512] = { '\\0' };\n        if (module != NULL)\n              strcat(strcpy(e, module), \": \");\n\n        vsprintf(e+strlen(e), fmt, ap);\n        strcat(e, \".\");\n        if (Verbose) {\n\n              fprintf(stderr, \"\\nWarning\");\n              fprintf(stderr, \" %s\\n\", e);\n              fflush(stderr);\n              }\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ConsoleWarningHandler",
            "parameters": {
              "module": "char",
              "fmt": "char",
              "ap": "va_list"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid ConsoleErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n       char e[512] = { '\\0' };\n\n       if (module != NULL)\n              strcat(strcpy(e, module), \": \");\n\n       vsprintf(e+strlen(e), fmt, ap);\n       strcat(e, \".\");\n       fprintf(stderr, \"\\nError\");\n       fprintf(stderr, \" %s\\n\", e);\n       fflush(stderr);\n}",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ConsoleErrorHandler",
            "parameters": {
              "module": "char",
              "fmt": "char",
              "ap": "va_list"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Help()\n{\n    fprintf(stderr, \"Little CMS TIFF compare utility. v1.1\\n\\n\");\n\n    fprintf(stderr, \"usage: tiffdiff [flags] input.tif output.tif\\n\");\n\n    fprintf(stderr, \"\\nflags:\\n\\n\");\n\n\n    fprintf(stderr, \"-o<tiff>   - Output TIFF file\\n\");   \n    fprintf(stderr, \"-g<CGATS>  - Output results in CGATS file\\n\");       \n    \n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"-v - Verbose (show warnings)\\n\");\n    fprintf(stderr, \"-h - This help\\n\");\n\n\n    fflush(stderr);\n    exit(0);\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              107,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Help",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid HandleSwitches(int argc, char *argv[])\n{\n       int s;\n      \n       while ((s=xgetopt(argc,argv,\"o:O:hHvVg:G:\")) != EOF) {\n\n       switch (s) {\n\n\n       case 'v':\n       case 'V':\n            Verbose = TRUE;\n            break;\n\n       case 'o':\n       case 'O':           \n           TiffDiffFilename  = xoptarg;\n           break;\n\n                \n        case 'H':\n        case 'h':             \n            Help();            \n            break;\n\n        case 'g':\n        case 'G':\n            CGATSout = xoptarg;\n            break;\n\n  default:\n\n       FatalError(\"Unknown option - run without args to see valid ones\");\n    }       \n    }\n}",
          "fn_code_pos": [
            [
              113,
              0
            ],
            [
              149,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HandleSwitches",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid ClearStatistics(LPSTAT st) \n{\n\n    st ->n = st ->x = st->x2 = st->Peak = 0;    \n    st ->Min = 1E10;     \n    \n}",
          "fn_code_pos": [
            [
              152,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ClearStatistics",
            "parameters": {
              "st": "LPSTAT"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid AddOnePixel(LPSTAT st, double dE) \n{ \n    \n    st-> x += dE; st ->x2 += (dE * dE); st->n  += 1.0; \n    if (dE > st ->Peak) st ->Peak = dE;\n    if (dE < st ->Min)  st ->Min= dE;    \n}",
          "fn_code_pos": [
            [
              162,
              0
            ],
            [
              169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddOnePixel",
            "parameters": {
              "st": "LPSTAT",
              "dE": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static    \ndouble Std(LPSTAT st)  \n{ \n    return sqrt((st->n * st->x2 - st->x * st->x) / (st->n*(st->n-1))); \n}",
          "fn_code_pos": [
            [
              171,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Std",
            "parameters": {
              "st": "LPSTAT"
            },
            "return_type": "double"
          }
        },
        {
          "fn_code": "static\ndouble Mean(LPSTAT st) \n{ \n    return st ->x/st ->n; \n}",
          "fn_code_pos": [
            [
              177,
              0
            ],
            [
              181,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Mean",
            "parameters": {
              "st": "LPSTAT"
            },
            "return_type": "double"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number GetInputPixelType(TIFF *Bank)\n{\n     uint16 Photometric, bps, spp, extra, PlanarConfig, *info;\n     uint16 Compression, reverse = 0;\n     int ColorChannels, IsPlanar = 0, pt = 0;\n\n     TIFFGetField(Bank,           TIFFTAG_PHOTOMETRIC,   &Photometric);\n     TIFFGetFieldDefaulted(Bank,  TIFFTAG_BITSPERSAMPLE, &bps);\n\n     if (bps == 1)\n       FatalError(\"Sorry, bilevel TIFFs has nothig to do with ICC profiles\");\n\n     if (bps != 8 && bps != 16)\n              FatalError(\"Sorry, 8 or 16 bits per sample only\");\n\n     TIFFGetFieldDefaulted(Bank, TIFFTAG_SAMPLESPERPIXEL, &spp);\n     TIFFGetFieldDefaulted(Bank, TIFFTAG_PLANARCONFIG, &PlanarConfig);\n\n     switch (PlanarConfig)\n     {\n     case PLANARCONFIG_CONTIG: IsPlanar = 0; break;\n     case PLANARCONFIG_SEPARATE: FatalError(\"Planar TIFF are not supported\");\n     default:\n\n     FatalError(\"Unsupported planar configuration (=%d) \", (int) PlanarConfig);\n     }\n\n     // If Samples per pixel == 1, PlanarConfiguration is irrelevant and need\n     // not to be included.\n\n     if (spp == 1) IsPlanar = 0;\n\n\n     // Any alpha?\n\n     TIFFGetFieldDefaulted(Bank, TIFFTAG_EXTRASAMPLES, &extra, &info);\n\n     \n     ColorChannels = spp - extra;\n\n     switch (Photometric) {\n\n     case PHOTOMETRIC_MINISWHITE:\n                                   \n            reverse = 1;\n\n     case PHOTOMETRIC_MINISBLACK:\n                                   \n            pt = PT_GRAY;                                \n            break;\n\n     case PHOTOMETRIC_RGB:\n                                   \n            pt = PT_RGB;\n            break;\n\n\n     case PHOTOMETRIC_PALETTE:\n                                             \n            FatalError(\"Sorry, palette images not supported (at least on this version)\"); \n\n     case PHOTOMETRIC_SEPARATED:\n           pt = PixelTypeFromChanCount(ColorChannels);\n           break;\n\n     case PHOTOMETRIC_YCBCR:\n           TIFFGetField(Bank, TIFFTAG_COMPRESSION, &Compression);\n           {\n                  uint16 subx, suby;\n\n                  pt = PT_YCbCr;\n                  TIFFGetFieldDefaulted(Bank, TIFFTAG_YCBCRSUBSAMPLING, &subx, &suby);\n                  if (subx != 1 || suby != 1)\n                         FatalError(\"Sorry, subsampled images not supported\");\n\n           }\n           break;\n\n     case 9:\n     case PHOTOMETRIC_CIELAB:\n           pt = PT_Lab;\n           break;\n\n    \n     case PHOTOMETRIC_LOGLUV:      /* CIE Log2(L) (u',v') */\n\n           TIFFSetField(Bank, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_16BIT);\n           pt = PT_YUV;             // *ICCSpace = icSigLuvData;\n           bps = 16;               // 16 bits forced by LibTiff\n           break;\n\n     default:\n           FatalError(\"Unsupported TIFF color space (Photometric %d)\", Photometric);\n     }\n\n     // Convert bits per sample to bytes per sample\n\n     bps >>= 3; \n\n     return (COLORSPACE_SH(pt)|PLANAR_SH(IsPlanar)|EXTRA_SH(extra)|CHANNELS_SH(ColorChannels)|BYTES_SH(bps)|FLAVOR_SH(reverse));\n}",
          "fn_code_pos": [
            [
              186,
              0
            ],
            [
              287,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetInputPixelType",
            "parameters": {
              "Bank": "TIFF"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number OpenEmbedded(TIFF* tiff, cmsHPROFILE* PtrProfile, cmsHTRANSFORM* PtrXform)\n{\n\n    cmsUInt32Number EmbedLen, dwFormat = 0;\n    cmsUInt8Number* EmbedBuffer;\n    \n    *PtrProfile = NULL;\n    *PtrXform   = NULL;\n\n    if (TIFFGetField(tiff, TIFFTAG_ICCPROFILE, &EmbedLen, &EmbedBuffer)) {\n\n              *PtrProfile = cmsOpenProfileFromMem(EmbedBuffer, EmbedLen);\n   \n              if (Verbose) {\n                  \n\t\t\t\t  fprintf(stdout, \"Embedded profile found:\\n\");                          \n\t\t\t\t  PrintProfileInformation(*PtrProfile);\n                  \n              }\n\n              dwFormat  = GetInputPixelType(tiff);\n              *PtrXform = cmsCreateTransform(*PtrProfile, dwFormat, \n                                          hLab, TYPE_Lab_DBL, INTENT_RELATIVE_COLORIMETRIC, 0);\n\n      }\n\n    return dwFormat;\n}",
          "fn_code_pos": [
            [
              291,
              0
            ],
            [
              319,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OpenEmbedded",
            "parameters": {
              "tiff": "TIFF",
              "PtrProfile": "cmsHPROFILE",
              "PtrXform": "cmsHTRANSFORM"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\nsize_t PixelSize(cmsUInt32Number dwFormat)\n{\n    return T_BYTES(dwFormat) * (T_CHANNELS(dwFormat) + T_EXTRA(dwFormat));\n}",
          "fn_code_pos": [
            [
              322,
              0
            ],
            [
              326,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixelSize",
            "parameters": {
              "dwFormat": "cmsUInt32Number"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static\nint CmpImages(TIFF* tiff1, TIFF* tiff2, TIFF* diff)\n{\n    cmsUInt8Number* buf1, *buf2, *buf3=NULL;\n    int row, cols, imagewidth = 0, imagelength = 0;\n    uint16   Photometric;\n    double dE = 0;    \n    double dR, dG, dB, dC, dM, dY, dK;\n    int rc = 0;\n    cmsHPROFILE hProfile1 = 0, hProfile2 = 0;\n    cmsHTRANSFORM xform1 = 0, xform2 = 0;\n    cmsUInt32Number dwFormat1, dwFormat2;\n    \n\n\n      TIFFGetField(tiff1, TIFFTAG_PHOTOMETRIC, &Photometric);\n      TIFFGetField(tiff1, TIFFTAG_IMAGEWIDTH,  &imagewidth);\n      TIFFGetField(tiff1, TIFFTAG_IMAGELENGTH, &imagelength);\n      TIFFGetField(tiff1, TIFFTAG_SAMPLESPERPIXEL, &Channels);\n      \n      dwFormat1 = OpenEmbedded(tiff1, &hProfile1, &xform1);\n      dwFormat2 = OpenEmbedded(tiff2, &hProfile2, &xform2);\n    \n      \n      \n      buf1 = (cmsUInt8Number*)_TIFFmalloc(TIFFScanlineSize(tiff1));\n      buf2 = (cmsUInt8Number*)_TIFFmalloc(TIFFScanlineSize(tiff2));\n    \n      if (diff) {\n                    \n           TIFFSetField(diff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n           TIFFSetField(diff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n           TIFFSetField(diff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); \n\n           TIFFSetField(diff, TIFFTAG_IMAGEWIDTH,  imagewidth);\n           TIFFSetField(diff, TIFFTAG_IMAGELENGTH, imagelength);\n\n           TIFFSetField(diff, TIFFTAG_SAMPLESPERPIXEL, 1);\n           TIFFSetField(diff, TIFFTAG_BITSPERSAMPLE, 8);\n                      \n           buf3 = (cmsUInt8Number*)_TIFFmalloc(TIFFScanlineSize(diff));                        \n      }\n      \n\n\n      for (row = 0; row < imagelength; row++) {\n\n        if (TIFFReadScanline(tiff1, buf1, row, 0) < 0) goto Error;\n        if (TIFFReadScanline(tiff2, buf2, row, 0) < 0) goto Error;                  \n\n                \n        for (cols = 0; cols < imagewidth; cols++) {\n\n              \n            switch (Photometric) {\n\n            case PHOTOMETRIC_MINISWHITE:\n            case PHOTOMETRIC_MINISBLACK:\n\n                    dE = fabs(buf2[cols] - buf1[cols]); \n                \n                    AddOnePixel(&ColorantStat[0], dE);\n                    AddOnePixel(&EuclideanStat, dE);\n                    break;\n\n            case PHOTOMETRIC_RGB:\n                \n                    {\n                        int index = 3 * cols;\n\n                        dR = fabs(buf2[index+0] - buf1[index+0]); \n                        dG = fabs(buf2[index+1] - buf1[index+1]); \n                        dB = fabs(buf2[index+2] - buf1[index+2]); \n\n                        dE = sqrt(dR * dR + dG * dG + dB * dB) / sqrt(3.);\n                    }\n\n                    AddOnePixel(&ColorantStat[0], dR);\n                    AddOnePixel(&ColorantStat[1], dG);\n                    AddOnePixel(&ColorantStat[2], dB);\n                    AddOnePixel(&EuclideanStat,   dE);\n                    break;\n\n            case PHOTOMETRIC_SEPARATED:\n                \n                {\n                        int index = 4 * cols;\n\n                        dC = fabs(buf2[index+0] - buf1[index+0]); \n                        dM = fabs(buf2[index+1] - buf1[index+1]); \n                        dY = fabs(buf2[index+2] - buf1[index+2]); \n                        dK = fabs(buf2[index+3] - buf1[index+3]); \n\n                        dE = sqrt(dC * dC + dM * dM + dY * dY + dK * dK) / 2.;\n                    }\n                    AddOnePixel(&ColorantStat[0], dC);\n                    AddOnePixel(&ColorantStat[1], dM);\n                    AddOnePixel(&ColorantStat[2], dY);\n                    AddOnePixel(&ColorantStat[3], dK);\n                    AddOnePixel(&EuclideanStat,   dE);\n                    break;\n            \n            default:\n                    FatalError(\"Unsupported channels: %d\", Channels);                 \n            }\n\n            \n            if (xform1 && xform2) {\n\n    \n                cmsCIELab Lab1, Lab2;\n                size_t index1 = cols * PixelSize(dwFormat1);\n                size_t index2 = cols * PixelSize(dwFormat2);\n\n                cmsDoTransform(xform1, &buf1[index1], &Lab1,  1);\n                cmsDoTransform(xform2, &buf2[index2], &Lab2,  1);\n\n                dE = cmsDeltaE(&Lab1, &Lab2);               \n                AddOnePixel(&ColorimetricStat, dE);\n            }\n\n\n            if (diff) {\n                buf3[cols] = (cmsUInt8Number) floor(dE + 0.5);\n        }\n\n        }\n\n        if (diff) {\n\n                if (TIFFWriteScanline(diff, buf3, row, 0) < 0) goto Error;\n        }\n        \n\n      }\n\n     rc = 1;\n\nError:\n         \n     if (hProfile1) cmsCloseProfile(hProfile1);\n     if (hProfile2) cmsCloseProfile(hProfile2);\n     if (xform1) cmsDeleteTransform(xform1);\n     if (xform2) cmsDeleteTransform(xform2);\n      _TIFFfree(buf1); _TIFFfree(buf2); \n      if (diff) {\n           TIFFWriteDirectory(diff);\n          if (buf3 != NULL) _TIFFfree(buf3);\n      }\n      return rc;\n}",
          "fn_code_pos": [
            [
              329,
              0
            ],
            [
              479,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CmpImages",
            "parameters": {
              "tiff1": "TIFF",
              "tiff2": "TIFF",
              "diff": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nvoid AssureShortTagIs(TIFF* tif1, TIFF* tiff2, int tag, int Val, const char* Error)\n{\n        uint16 v1;\n\n        \n        if (!TIFFGetField(tif1, tag, &v1)) goto Err;\n        if (v1 != Val) goto Err;\n\n        if (!TIFFGetField(tiff2, tag, &v1)) goto Err;\n        if (v1 != Val) goto Err;\n\n        return;\nErr:\n        FatalError(\"%s is not proper\", Error);\n}",
          "fn_code_pos": [
            [
              482,
              0
            ],
            [
              497,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AssureShortTagIs",
            "parameters": {
              "tif1": "TIFF",
              "tiff2": "TIFF",
              "tag": "int",
              "Val": "int",
              "Error": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nint CmpShortTag(TIFF* tif1, TIFF* tif2, int tag)\n{\n        uint16 v1, v2;\n\n        if (!TIFFGetField(tif1, tag, &v1)) return 0;\n        if (!TIFFGetField(tif2, tag, &v2)) return 0;\n\n        return v1 == v2;\n}",
          "fn_code_pos": [
            [
              500,
              0
            ],
            [
              509,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CmpShortTag",
            "parameters": {
              "tif1": "TIFF",
              "tif2": "TIFF",
              "tag": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint CmpLongTag(TIFF* tif1, TIFF* tif2, int tag)\n{\n        uint32 v1, v2;\n\n        if (!TIFFGetField(tif1, tag, &v1)) return 0;\n        if (!TIFFGetField(tif2, tag, &v2)) return 0;\n\n        return v1 == v2;\n}",
          "fn_code_pos": [
            [
              511,
              0
            ],
            [
              520,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CmpLongTag",
            "parameters": {
              "tif1": "TIFF",
              "tif2": "TIFF",
              "tag": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nvoid EqualShortTag(TIFF* tif1, TIFF* tif2, int tag, const char* Error)\n{\n    if (!CmpShortTag(tif1, tif2, tag))\n        FatalError(\"%s is different\", Error);\n}",
          "fn_code_pos": [
            [
              523,
              0
            ],
            [
              528,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EqualShortTag",
            "parameters": {
              "tif1": "TIFF",
              "tif2": "TIFF",
              "tag": "int",
              "Error": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid EqualLongTag(TIFF* tif1, TIFF* tif2, int tag, const char* Error)\n{\n    if (!CmpLongTag(tif1, tif2, tag))\n        FatalError(\"%s is different\", Error);\n}",
          "fn_code_pos": [
            [
              532,
              0
            ],
            [
              537,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EqualLongTag",
            "parameters": {
              "tif1": "TIFF",
              "tif2": "TIFF",
              "tag": "int",
              "Error": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid AddOneCGATSRow(cmsHANDLE hIT8, char *Name, LPSTAT st)\n{\n\n    double Per100 = 100.0 * ((255.0 - Mean(st)) / 255.0);\n\n    cmsIT8SetData(hIT8,    Name, \"SAMPLE_ID\", Name);\n    cmsIT8SetDataDbl(hIT8, Name, \"PER100_EQUAL\", Per100);\n    cmsIT8SetDataDbl(hIT8, Name, \"MEAN_DE\", Mean(st));\n    cmsIT8SetDataDbl(hIT8, Name, \"STDEV_DE\", Std(st));\n    cmsIT8SetDataDbl(hIT8, Name, \"MIN_DE\", st ->Min);\n    cmsIT8SetDataDbl(hIT8, Name, \"MAX_DE\", st ->Peak);\n\n}",
          "fn_code_pos": [
            [
              541,
              0
            ],
            [
              554,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddOneCGATSRow",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "Name": "char",
              "st": "LPSTAT"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid CreateCGATS(const char* TiffName1, const char* TiffName2)\n{\n    cmsHANDLE hIT8 = cmsIT8Alloc(0);\n    time_t ltime;\n    char Buffer[256];\n\n    cmsIT8SetSheetType(hIT8, \"TIFFDIFF\");\n    \n   \n    sprintf(Buffer, \"Differences between %s and %s\", TiffName1, TiffName2);\n  \n    cmsIT8SetComment(hIT8, Buffer);\n\n    cmsIT8SetPropertyStr(hIT8, \"ORIGINATOR\", \"TIFFDIFF\");\n    time( &ltime );\n    strcpy(Buffer, ctime(&ltime));\n    Buffer[strlen(Buffer)-1] = 0;     // Remove the nasty \"\\n\"\n\n    cmsIT8SetPropertyStr(hIT8, \"CREATED\", Buffer);\n\n    cmsIT8SetComment(hIT8, \" \");\n\n    cmsIT8SetPropertyDbl(hIT8, \"NUMBER_OF_FIELDS\", 6);\n    \n    \n    cmsIT8SetDataFormat(hIT8, 0, \"SAMPLE_ID\");\n    cmsIT8SetDataFormat(hIT8, 1, \"PER100_EQUAL\");\n    cmsIT8SetDataFormat(hIT8, 2, \"MEAN_DE\");\n    cmsIT8SetDataFormat(hIT8, 3, \"STDEV_DE\");\n    cmsIT8SetDataFormat(hIT8, 4, \"MIN_DE\");\n    cmsIT8SetDataFormat(hIT8, 5, \"MAX_DE\");\n\n       \n    switch (Channels) {\n\n    case 1:\n            cmsIT8SetPropertyDbl(hIT8, \"NUMBER_OF_SETS\", 3);\n            AddOneCGATSRow(hIT8, \"GRAY_PLANE\", &ColorantStat[0]);            \n            break;\n\n    case 3:\n            cmsIT8SetPropertyDbl(hIT8, \"NUMBER_OF_SETS\", 5);\n            AddOneCGATSRow(hIT8, \"R_PLANE\", &ColorantStat[0]);            \n            AddOneCGATSRow(hIT8, \"G_PLANE\", &ColorantStat[1]);            \n            AddOneCGATSRow(hIT8, \"B_PLANE\", &ColorantStat[2]);            \n            break;\n            \n            \n    case 4:\n            cmsIT8SetPropertyDbl(hIT8, \"NUMBER_OF_SETS\", 6);\n            AddOneCGATSRow(hIT8, \"C_PLANE\", &ColorantStat[0]);            \n            AddOneCGATSRow(hIT8, \"M_PLANE\", &ColorantStat[1]);            \n            AddOneCGATSRow(hIT8, \"Y_PLANE\", &ColorantStat[2]);            \n            AddOneCGATSRow(hIT8, \"K_PLANE\", &ColorantStat[3]);            \n            break;\n            \n    default: FatalError(\"Internal error: Bad ColorSpace\");\n\n    }\n\n    AddOneCGATSRow(hIT8, \"EUCLIDEAN\",    &EuclideanStat);    \n    AddOneCGATSRow(hIT8, \"COLORIMETRIC\", &ColorimetricStat);    \n\n    cmsIT8SaveToFile(hIT8, CGATSout);\n    cmsIT8Free(hIT8);\n}",
          "fn_code_pos": [
            [
              557,
              0
            ],
            [
              623,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CreateCGATS",
            "parameters": {
              "TiffName1": "char",
              "TiffName2": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(int argc, char* argv[])\n{\n      int i;\n\n      Tiff1 = Tiff2 = TiffDiff = NULL;\n\n\t  InitUtils(\"tiffdiff\");\n\n      HandleSwitches(argc, argv);\n\n      if ((argc - xoptind) != 2) {\n\n              Help();              \n              }\n            \n      TIFFSetErrorHandler(ConsoleErrorHandler);\n      TIFFSetWarningHandler(ConsoleWarningHandler);\n\n      Tiff1 = TIFFOpen(argv[xoptind], \"r\");\n      if (Tiff1 == NULL) FatalError(\"Unable to open '%s'\", argv[xoptind]);\n\n      Tiff2 = TIFFOpen(argv[xoptind+1], \"r\");\n      if (Tiff2 == NULL) FatalError(\"Unable to open '%s'\", argv[xoptind+1]);\n             \n      if (TiffDiffFilename) {\n\n          TiffDiff = TIFFOpen(TiffDiffFilename, \"w\");\n          if (TiffDiff == NULL) FatalError(\"Unable to create '%s'\", TiffDiffFilename);\n\n      }\n\n \n      AssureShortTagIs(Tiff1, Tiff2, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG, \"Planar Config\");\n      AssureShortTagIs(Tiff1, Tiff2, TIFFTAG_BITSPERSAMPLE, 8, \"8 bit per sample\");\n\n      EqualLongTag(Tiff1, Tiff2, TIFFTAG_IMAGEWIDTH,  \"Image width\");\n      EqualLongTag(Tiff1, Tiff2, TIFFTAG_IMAGELENGTH, \"Image length\");\n      \n      EqualShortTag(Tiff1, Tiff2, TIFFTAG_SAMPLESPERPIXEL, \"Samples per pixel\");\n\n\n      hLab = cmsCreateLab4Profile(NULL);\n\n      ClearStatistics(&EuclideanStat);\n      for (i=0; i < 4; i++)\n            ClearStatistics(&ColorantStat[i]);\n\n      if (!CmpImages(Tiff1, Tiff2, TiffDiff))\n                FatalError(\"Error comparing images\");\n\n      if (CGATSout) {\n            CreateCGATS(argv[xoptind], argv[xoptind+1]);\n      }\n      else {\n\n        double  Per100 = 100.0 * ((255.0 - Mean(&EuclideanStat)) / 255.0);\n\n        printf(\"Digital counts  %g%% equal. mean %g, min %g, max %g, Std %g\\n\", Per100, Mean(&EuclideanStat), \n                                                                                EuclideanStat.Min, \n                                                                                EuclideanStat.Peak, \n                                                                                Std(&EuclideanStat));\n\n        if (ColorimetricStat.n > 0) {\n\n            Per100 = 100.0 * ((255.0 - Mean(&ColorimetricStat)) / 255.0);\n\n            printf(\"dE Colorimetric %g%% equal. mean %g, min %g, max %g, Std %g\\n\", Per100, Mean(&ColorimetricStat), \n                                                                                    ColorimetricStat.Min, \n                                                                                    ColorimetricStat.Peak, \n                                                                                    Std(&ColorimetricStat));\n        }\n      \n      }\n\n      if (hLab)     cmsCloseProfile(hLab);\n      if (Tiff1)    TIFFClose(Tiff1);\n      if (Tiff2)    TIFFClose(Tiff2);      \n      if (TiffDiff) TIFFClose(TiffDiff);\n\n      return 0;\n}",
          "fn_code_pos": [
            [
              625,
              0
            ],
            [
              705,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n                double  n, x, x2;                    \n                double  Min, Peak;   \n\n    } STAT, *LPSTAT;",
          {
            "n": "double",
            "Min": "double"
          },
          "STAT",
          [
            36,
            0
          ],
          [
            40,
            20
          ]
        ],
        [
          "typedef struct {\n                double  n, x, x2;                    \n                double  Min, Peak;   \n\n    } STAT, *LPSTAT;",
          {
            "n": "double",
            "Min": "double"
          },
          "LPSTAT",
          [
            36,
            0
          ],
          [
            40,
            20
          ]
        ],
        [
          "typedef struct {\n                double  n, x, x2;                    \n                double  Min, Peak;   \n\n    } STAT, *LPSTAT;",
          {
            "n": "double",
            "Min": "double"
          },
          "STAT",
          [
            36,
            0
          ],
          [
            40,
            20
          ]
        ],
        [
          "typedef struct {\n                double  n, x, x2;                    \n                double  Min, Peak;   \n\n    } STAT, *LPSTAT;",
          {
            "n": "double",
            "Min": "double"
          },
          "LPSTAT",
          [
            36,
            0
          ],
          [
            40,
            20
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"utils.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/utils/tificc/tificc.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nvoid ConsoleWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    if (Verbose) {\n\n        fprintf(stderr, \"Warning: \");\n\n        if (module != NULL)\n            fprintf(stderr, \"[%s] \", module);\n\n        vfprintf(stderr, fmt, ap);\n        fprintf(stderr, \"\\n\");\n        fflush(stderr);\n    }\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              80,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ConsoleWarningHandler",
            "parameters": {
              "module": "char",
              "fmt": "char",
              "ap": "va_list"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid ConsoleErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    if (Verbose) {\n        \n        fprintf(stderr, \"Error: \");\n\n        if (module != NULL)\n            fprintf(stderr, \"[%s] \", module);\n      \n        vfprintf(stderr, fmt, ap);\n        fprintf(stderr, \"\\n\");\n        fflush(stderr);\n    }\n\n}",
          "fn_code_pos": [
            [
              82,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ConsoleErrorHandler",
            "parameters": {
              "module": "char",
              "fmt": "char",
              "ap": "va_list"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Warning(const char *frm, ...)\n{\n    va_list args;\n\n    va_start(args, frm);\n    ConsoleWarningHandler(\"tificc\", frm, args);\n    va_end(args);\n}",
          "fn_code_pos": [
            [
              101,
              0
            ],
            [
              109,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Warning",
            "parameters": {
              "frm": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid OutOfMem(cmsUInt32Number size)\n{\n    FatalError(\"Out of memory on allocating %d bytes.\", size);  \n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OutOfMem",
            "parameters": {
              "size": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static \nint FromLabV2ToLabV4(int x) \n{\n    int a;\n\n    a = ((x << 8) | x) >> 8;  // * 257 / 256\n    if ( a > 0xffff) return 0xffff;\n    return a;\n}",
          "fn_code_pos": [
            [
              130,
              0
            ],
            [
              138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FromLabV2ToLabV4",
            "parameters": {
              "x": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static \nint FromLabV4ToLabV2(int x) \n{\n    return ((x << 8) + 0x80) / 257;\n}",
          "fn_code_pos": [
            [
              141,
              0
            ],
            [
              145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FromLabV4ToLabV2",
            "parameters": {
              "x": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nunsigned char* UnrollTIFFLab8(struct _cmstransform_struct* CMMcargo,\n                              CMSREGISTER cmsUInt16Number wIn[], \n                              CMSREGISTER cmsUInt8Number* accum, \n                              CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[0] = (cmsUInt16Number) FromLabV2ToLabV4((accum[0]) << 8);\n    wIn[1] = (cmsUInt16Number) FromLabV2ToLabV4(((accum[1] > 127) ? (accum[1] - 128) : (accum[1] + 128)) << 8);\n    wIn[2] = (cmsUInt16Number) FromLabV2ToLabV4(((accum[2] > 127) ? (accum[2] - 128) : (accum[2] + 128)) << 8);\n\n    return accum + 3;\n\n    UTILS_UNUSED_PARAMETER(Stride);\n    UTILS_UNUSED_PARAMETER(CMMcargo);\n}",
          "fn_code_pos": [
            [
              149,
              0
            ],
            [
              163,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollTIFFLab8",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static\nunsigned char* UnrollTIFFLab16(struct _cmstransform_struct* CMMcargo,\n                              CMSREGISTER cmsUInt16Number wIn[],\n                              CMSREGISTER cmsUInt8Number* accum,\n                              CMSREGISTER cmsUInt32Number Stride )\n{\n    cmsUInt16Number* accum16 = (cmsUInt16Number*) accum;\n\n    wIn[0] = (cmsUInt16Number) FromLabV2ToLabV4(accum16[0]);\n    wIn[1] = (cmsUInt16Number) FromLabV2ToLabV4(((accum16[1] > 0x7f00) ? (accum16[1] - 0x8000) : (accum16[1] + 0x8000)) );\n    wIn[2] = (cmsUInt16Number) FromLabV2ToLabV4(((accum16[2] > 0x7f00) ? (accum16[2] - 0x8000) : (accum16[2] + 0x8000)) );\n\n    return accum + 3 * sizeof(cmsUInt16Number);\n\n    UTILS_UNUSED_PARAMETER(Stride);\n    UTILS_UNUSED_PARAMETER(CMMcargo);\n}",
          "fn_code_pos": [
            [
              166,
              0
            ],
            [
              182,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollTIFFLab16",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static\nunsigned char* PackTIFFLab8(struct _cmstransform_struct* CMMcargo, \n                            CMSREGISTER cmsUInt16Number wOut[], \n                            CMSREGISTER cmsUInt8Number* output, \n                            CMSREGISTER cmsUInt32Number Stride)\n{\n    int a, b;\n\n    *output++ = (cmsUInt8Number) (FromLabV4ToLabV2(wOut[0] + 0x0080) >> 8);\n\n    a = (FromLabV4ToLabV2(wOut[1]) + 0x0080) >> 8;\n    b = (FromLabV4ToLabV2(wOut[2]) + 0x0080) >> 8;\n\n    *output++ = (cmsUInt8Number) ((a < 128) ? (a + 128) : (a - 128));\n    *output++ = (cmsUInt8Number) ((b < 128) ? (b + 128) : (b - 128));\n    \n    return output;\n\n    UTILS_UNUSED_PARAMETER(Stride);\n    UTILS_UNUSED_PARAMETER(CMMcargo);\n}",
          "fn_code_pos": [
            [
              185,
              0
            ],
            [
              205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackTIFFLab8",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static\nunsigned char* PackTIFFLabA8(struct _cmstransform_struct* CMMcargo, \n                            CMSREGISTER cmsUInt16Number wOut[], \n                            CMSREGISTER cmsUInt8Number* output, \n                            CMSREGISTER cmsUInt32Number Stride)\n{\n    int a, b;\n\n    *output++ = (cmsUInt8Number) (FromLabV4ToLabV2(wOut[0] + 0x0080) >> 8);\n\n    a = (FromLabV4ToLabV2(wOut[1]) + 0x0080) >> 8;\n    b = (FromLabV4ToLabV2(wOut[2]) + 0x0080) >> 8;\n\n    *output++ = (cmsUInt8Number) ((a < 128) ? (a + 128) : (a - 128));\n    *output++ = (cmsUInt8Number) ((b < 128) ? (b + 128) : (b - 128));\n\n    output++; // Alpha\n\n    return output;\n\n    UTILS_UNUSED_PARAMETER(Stride);\n    UTILS_UNUSED_PARAMETER(CMMcargo);\n}",
          "fn_code_pos": [
            [
              208,
              0
            ],
            [
              230,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackTIFFLabA8",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static\nunsigned char* PackTIFFLab16(struct _cmstransform_struct* CMMcargo, \n                            CMSREGISTER cmsUInt16Number wOut[], \n                            CMSREGISTER cmsUInt8Number* output, \n                            CMSREGISTER cmsUInt32Number Stride)\n{\n    int a, b;\n    cmsUInt16Number* output16 = (cmsUInt16Number*) output;\n\n    *output16++ = (cmsUInt16Number) FromLabV4ToLabV2(wOut[0]);\n\n    a = FromLabV4ToLabV2(wOut[1]);\n    b = FromLabV4ToLabV2(wOut[2]);\n\n    *output16++ = (cmsUInt16Number) ((a < 0x7f00) ? (a + 0x8000) : (a - 0x8000));\n    *output16++ = (cmsUInt16Number) ((b < 0x7f00) ? (b + 0x8000) : (b - 0x8000));\n    \n    return (cmsUInt8Number*) output16;\n\n    UTILS_UNUSED_PARAMETER(Stride);\n    UTILS_UNUSED_PARAMETER(CMMcargo);\n}",
          "fn_code_pos": [
            [
              233,
              0
            ],
            [
              254,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackTIFFLab16",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static\nunsigned char* PackTIFFLabA16(struct _cmstransform_struct* CMMcargo, \n                            CMSREGISTER cmsUInt16Number wOut[], \n                            CMSREGISTER cmsUInt8Number* output, \n                            CMSREGISTER cmsUInt32Number Stride)\n{\n    int a, b;\n    cmsUInt16Number* output16 = (cmsUInt16Number*) output;\n\n    *output16++ = (cmsUInt16Number) FromLabV4ToLabV2(wOut[0]);\n\n    a = FromLabV4ToLabV2(wOut[1]);\n    b = FromLabV4ToLabV2(wOut[2]);\n\n    *output16++ = (cmsUInt16Number) ((a < 0x7f00) ? (a + 0x8000) : (a - 0x8000));\n    *output16++ = (cmsUInt16Number) ((b < 0x7f00) ? (b + 0x8000) : (b - 0x8000));\n\n    output16++; // Alpha\n\n    return (cmsUInt8Number*) output16;\n\n    UTILS_UNUSED_PARAMETER(Stride);\n    UTILS_UNUSED_PARAMETER(CMMcargo);\n}",
          "fn_code_pos": [
            [
              256,
              0
            ],
            [
              279,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackTIFFLabA16",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static\ncmsFormatter TiffFormatterFactory(cmsUInt32Number Type,\n                                  cmsFormatterDirection Dir,\n                                  cmsUInt32Number dwFlags)\n{\n    cmsFormatter Result = { NULL };\n    int bps           = T_BYTES(Type);\n    int IsTiffSpecial = T_LABTIFF(Type);\n\n    if (IsTiffSpecial && !(dwFlags & CMS_PACK_FLAGS_FLOAT))\n    {\n        if (Dir == cmsFormatterInput)\n        {\n            Result.Fmt16 = (bps == 1) ? UnrollTIFFLab8 : UnrollTIFFLab16;\n        }\n        else\n        {\n            if (T_EXTRA(Type) == 1)\n                Result.Fmt16 = (bps == 1) ? PackTIFFLabA8 : PackTIFFLabA16;\n            else\n                if (T_EXTRA(Type) == 0)\n                    Result.Fmt16 = (bps == 1) ? PackTIFFLab8 : PackTIFFLab16;\n        }\n    }\n\n    return Result;\n}",
          "fn_code_pos": [
            [
              282,
              0
            ],
            [
              308,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffFormatterFactory",
            "parameters": {
              "Type": "cmsUInt32Number",
              "Dir": "cmsFormatterDirection",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsFormatter"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number GetInputPixelType(TIFF *Bank)\n{\n    cmsUInt16Number Photometric, bps, spp, extra, PlanarConfig, *info;\n    cmsUInt16Number Compression;\n    int ColorChannels;\n    int IsPremul = FALSE, IsPlanar = FALSE, IsFlt = FALSE, IsReverse = FALSE;\n    int labTiffSpecial = FALSE;\n    int pt = PT_ANY;\n    \n    TIFFGetFieldDefaulted(Bank,  TIFFTAG_BITSPERSAMPLE, &bps);\n\n    if (bps == 1)\n        FatalError(\"Sorry, bilevel TIFFs has nothing to do with ICC profiles\");\n\n    if (bps != 8 && bps != 16 && bps != 32)\n        FatalError(\"Sorry, 8, 16 or 32 bits per sample only\");\n\n   \n    TIFFGetFieldDefaulted(Bank, TIFFTAG_PLANARCONFIG, &PlanarConfig);\n\n    switch (PlanarConfig) {\n\n     case PLANARCONFIG_CONTIG: IsPlanar = 0; break;\n     case PLANARCONFIG_SEPARATE: IsPlanar = 1; break;\n     default:\n\n         FatalError(\"Unsupported planar configuration (=%d) \", (int) PlanarConfig);\n    }\n\n    TIFFGetFieldDefaulted(Bank, TIFFTAG_SAMPLESPERPIXEL, &spp);\n\n    // If Samples per pixel == 1, PlanarConfiguration is irrelevant and need not to be included.\n    if (spp == 1) IsPlanar = 0;\n\n    // Any alpha?\n    TIFFGetFieldDefaulted(Bank, TIFFTAG_EXTRASAMPLES, &extra, &info);\n\n    // Read alpha channels as colorant?\n    if (StoreAsAlpha) {\n\n        ColorChannels = spp;\n        extra = 0;\n    }\n    else\n        ColorChannels = spp - extra;\n\n    // Is alpha premultiplied ? \n    IsPremul = ((extra == 1) && (info[0] == EXTRASAMPLE_ASSOCALPHA));\n\n\n    // Get photometric interpretation and proceed accordly\n    TIFFGetField(Bank, TIFFTAG_PHOTOMETRIC, &Photometric);\n\n    switch (Photometric) {\n\n    case PHOTOMETRIC_MINISWHITE:\n\n        IsReverse = 1;\n\n        // ... fall through ...\n\n    case PHOTOMETRIC_MINISBLACK:                                   \n        pt = PT_GRAY;                                \n        break;\n\n    case PHOTOMETRIC_RGB:                                   \n        pt = PT_RGB;\n        if (ColorChannels < 3)\n            FatalError(\"Sorry, RGB needs at least 3 samples per pixel\");\n        break;\n\n     case PHOTOMETRIC_PALETTE:                                             \n         FatalError(\"Sorry, palette images not supported\"); \n         break;\n\n     case PHOTOMETRIC_SEPARATED: \n         pt = PixelTypeFromChanCount(ColorChannels);\n         break;\n\n     case PHOTOMETRIC_YCBCR:\n         TIFFGetField(Bank, TIFFTAG_COMPRESSION, &Compression);\n         {\n             cmsUInt16Number subx, suby;\n\n             pt = PT_YCbCr;\n             TIFFGetFieldDefaulted(Bank, TIFFTAG_YCBCRSUBSAMPLING, &subx, &suby);\n             if (subx != 1 || suby != 1)\n                 FatalError(\"Sorry, subsampled images are not supported\");\n         }\n         break;\n\n     // Two Lab flavours\n     case PHOTOMETRIC_ITULAB:\n     case PHOTOMETRIC_ICCLAB:\n         pt = PT_Lab;         \n         break;\n\n     case PHOTOMETRIC_CIELAB:\n         pt = PT_Lab;\n         labTiffSpecial = TRUE;\n         break;\n\n    // CIE Log2(L) (u',v') \n     case PHOTOMETRIC_LOGLUV:     \n\n         TIFFSetField(Bank, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_16BIT);\n         pt = PT_YUV;             // *ICCSpace = icSigLuvData;\n         bps = 16;                // 16 bits forced by LibTiff\n         break;\n\n     default:\n         FatalError(\"Unsupported TIFF color space (Photometric %d)\", Photometric);\n    }\n\n    // Convert bits per sample to bytes per sample\n\n    bps >>= 3; \n    IsFlt = (bps == 0) || (bps == 4);\n\n    return (FLOAT_SH(IsFlt) | COLORSPACE_SH(pt) | PLANAR_SH(IsPlanar) | EXTRA_SH(extra) | PREMUL_SH(IsPremul) |\n           CHANNELS_SH(ColorChannels) | BYTES_SH(bps) | FLAVOR_SH(IsReverse) | LABTIFF_SH(labTiffSpecial));\n}",
          "fn_code_pos": [
            [
              315,
              0
            ],
            [
              437,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetInputPixelType",
            "parameters": {
              "Bank": "TIFF"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number ComputeOutputFormatDescriptor(cmsUInt32Number dwInput, int OutColorSpace, int bps)\n{\n    int IsPlanar  = T_PLANAR(dwInput);\n    int Channels  = ChanCountFromPixelType(OutColorSpace);\n    int IsFlt = (bps == 0) || (bps == 4);\n    int labTiffSpecial = FALSE;\n    int Extra = T_EXTRA(dwInput);\n    int IsPremul = T_PREMUL(dwInput);\n    \n    if (OutColorSpace == PT_Lab)\n        labTiffSpecial = TRUE;\n\n    return (FLOAT_SH(IsFlt) | COLORSPACE_SH(OutColorSpace) | PLANAR_SH(IsPlanar) |\n        CHANNELS_SH(Channels) | BYTES_SH(bps) | EXTRA_SH(Extra) | PREMUL_SH(IsPremul) |\n        LABTIFF_SH(labTiffSpecial));\n}",
          "fn_code_pos": [
            [
              442,
              0
            ],
            [
              458,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComputeOutputFormatDescriptor",
            "parameters": {
              "dwInput": "cmsUInt32Number",
              "OutColorSpace": "int",
              "bps": "int"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\nint TileBasedXform(cmsHTRANSFORM hXForm, TIFF* in, TIFF* out, int nPlanes)\n{\n    tsize_t BufSizeIn  = TIFFTileSize(in);\n    tsize_t BufSizeOut = TIFFTileSize(out);\n    unsigned char *BufferIn, *BufferOut;\n    ttile_t i, TileCount = TIFFNumberOfTiles(in) / nPlanes;\n    cmsUInt32Number tw, tl;\n    int PixelCount, j;\n\n    // Check for bad tiffs\n    if (BufSizeIn > INT_MAX || BufSizeOut > INT_MAX)\n        FatalError(\"Probably corrupted TIFF, tile too big.\");\n\n    TIFFGetFieldDefaulted(in, TIFFTAG_TILEWIDTH,  &tw);\n    TIFFGetFieldDefaulted(in, TIFFTAG_TILELENGTH, &tl);\n\n    PixelCount = (int) tw * tl;\n\n    BufferIn = (unsigned char *) _TIFFmalloc(BufSizeIn * nPlanes);\n    if (!BufferIn) OutOfMem((cmsUInt32Number) BufSizeIn * nPlanes);\n\n    BufferOut = (unsigned char *) _TIFFmalloc(BufSizeOut * nPlanes);\n    if (!BufferOut) OutOfMem((cmsUInt32Number) BufSizeOut * nPlanes);\n\n\n    for (i = 0; i < TileCount; i++) {\n\n        for (j=0; j < nPlanes; j++) {\n\n            if (TIFFReadEncodedTile(in, i + (j* TileCount), \n                BufferIn + (j*BufSizeIn), BufSizeIn) < 0)   goto cleanup;\n        }\n\n        if (PixelCount < 0)\n            FatalError(\"TIFF is corrupted\");\n\n        cmsDoTransform(hXForm, BufferIn, BufferOut, PixelCount);\n\n        for (j=0; j < nPlanes; j++) {\n\n            if (TIFFWriteEncodedTile(out, i + (j*TileCount),\n                BufferOut + (j*BufSizeOut), BufSizeOut) < 0) goto cleanup;\n        }\n    }\n\n    _TIFFfree(BufferIn);\n    _TIFFfree(BufferOut);\n    return 1;\n\n\ncleanup:\n\n    _TIFFfree(BufferIn);\n    _TIFFfree(BufferOut);\n    return 0;\n}",
          "fn_code_pos": [
            [
              463,
              0
            ],
            [
              519,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TileBasedXform",
            "parameters": {
              "hXForm": "cmsHTRANSFORM",
              "in": "TIFF",
              "out": "TIFF",
              "nPlanes": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint StripBasedXform(cmsHTRANSFORM hXForm, TIFF* in, TIFF* out, int nPlanes)\n{\n    tsize_t BufSizeIn  = TIFFStripSize(in);\n    tsize_t BufSizeOut = TIFFStripSize(out);\n    unsigned char *BufferIn, *BufferOut;\n    ttile_t i, StripCount = TIFFNumberOfStrips(in) / nPlanes;\n    cmsUInt32Number sw;\n    cmsUInt32Number sl;\n    cmsUInt32Number iml;\n    int j;\n    int PixelCount;\n\n    // Check for bad tiffs\n    if (BufSizeIn > INT_MAX || BufSizeOut > INT_MAX)\n        FatalError(\"Probably corrupted TIFF, strip too big.\");\n\n    TIFFGetFieldDefaulted(in, TIFFTAG_IMAGEWIDTH,  &sw);\n    TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &sl);\n    TIFFGetFieldDefaulted(in, TIFFTAG_IMAGELENGTH, &iml);\n\n    // It is possible to get infinite rows per strip\n    if (sl == 0 || sl > iml)\n        sl = iml;   // One strip for whole image\n\n    BufferIn = (unsigned char *) _TIFFmalloc(BufSizeIn * nPlanes);\n    if (!BufferIn) OutOfMem((cmsUInt32Number) BufSizeIn * nPlanes);\n\n    BufferOut = (unsigned char *) _TIFFmalloc(BufSizeOut * nPlanes);\n    if (!BufferOut) OutOfMem((cmsUInt32Number) BufSizeOut * nPlanes);\n\n\n    for (i = 0; i < StripCount; i++) {\n\n        for (j=0; j < nPlanes; j++) {\n\n            if (TIFFReadEncodedStrip(in, i + (j * StripCount), \n                BufferIn + (j * BufSizeIn), BufSizeIn) < 0)   goto cleanup;\n        }\n\n        PixelCount = (int) sw * (iml < sl ? iml : sl);\n        iml -= sl;\n\n        if (PixelCount < 0)\n            FatalError(\"TIFF is corrupted\");\n\n        cmsDoTransform(hXForm, BufferIn, BufferOut, PixelCount);\n\n        for (j=0; j < nPlanes; j++) {\n            if (TIFFWriteEncodedStrip(out, i + (j * StripCount), \n                BufferOut + j * BufSizeOut, BufSizeOut) < 0) goto cleanup;\n        }\n\n    }\n\n    _TIFFfree(BufferIn);\n    _TIFFfree(BufferOut);\n    return 1;\n\ncleanup:\n\n    _TIFFfree(BufferIn);\n    _TIFFfree(BufferOut);\n    return 0;\n}",
          "fn_code_pos": [
            [
              523,
              0
            ],
            [
              587,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "StripBasedXform",
            "parameters": {
              "hXForm": "cmsHTRANSFORM",
              "in": "TIFF",
              "out": "TIFF",
              "nPlanes": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nvoid fillArray(cmsInt16Number array[],  cmsInt16Number val, cmsUInt32Number size)\n{\n    cmsUInt32Number i;\n\n    size /= sizeof(cmsInt16Number);\n    for (i = 0; i < size; i++)\n        array[i] = val;\n\n}",
          "fn_code_pos": [
            [
              591,
              0
            ],
            [
              600,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fillArray",
            "parameters": {
              "array": "cmsInt16Number",
              "val": "cmsInt16Number",
              "size": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid WriteOutputTags(TIFF* out, int Colorspace, int BytesPerSample, int AlphaChannels, int IsPremul)\n{\n    int BitsPerSample = (8 * BytesPerSample);\n    int nChannels = ChanCountFromPixelType(Colorspace);\n\n   \n    TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, BitsPerSample);\n    TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, nChannels + AlphaChannels);\n\n    if (AlphaChannels > 0)\n    {\n        cmsInt16Number Extra[20];\n\n        if (IsPremul)\n            fillArray(Extra, EXTRASAMPLE_ASSOCALPHA, sizeof(Extra));\n        else\n            fillArray(Extra, EXTRASAMPLE_UNASSALPHA, sizeof(Extra));\n\n        TIFFSetField(out, TIFFTAG_EXTRASAMPLES, AlphaChannels, Extra);\n    }\n\n    switch (Colorspace) {\n\n    case PT_GRAY:\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\n        break;\n\n    case PT_RGB:\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        break;\n\n    case PT_CMY:\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED);\n        TIFFSetField(out, TIFFTAG_INKSET, INKSET_MULTIINK);\n        break;\n\n    case PT_CMYK:\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED);\n        TIFFSetField(out, TIFFTAG_INKSET, INKSET_CMYK);\n        break;\n\n    case PT_Lab:\n        if (BitsPerSample == 16)\n            TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CIELAB);\n        else\n            TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CIELAB);\n        break;\n\n\n        // Multi-ink separations\n    case PT_MCH2:\n    case PT_MCH3:\n    case PT_MCH4:\n    case PT_MCH5:\n    case PT_MCH6:\n    case PT_MCH7:\n    case PT_MCH8:\n    case PT_MCH9:\n    case PT_MCH10:\n    case PT_MCH11:\n    case PT_MCH12:\n    case PT_MCH13:\n    case PT_MCH14:\n    case PT_MCH15:\n\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED);\n\n        if (StoreAsAlpha && nChannels >= 4) {\n\n            cmsInt16Number Extra[20];\n\n            fillArray(Extra, EXTRASAMPLE_UNASSALPHA, sizeof(Extra));\n\n            // CMYK plus extra alpha\n            TIFFSetField(out, TIFFTAG_EXTRASAMPLES, nChannels - 4, Extra);\n            TIFFSetField(out, TIFFTAG_INKSET, INKSET_CMYK);\n            TIFFSetField(out, TIFFTAG_NUMBEROFINKS, 4);\n        }\n        else {\n            TIFFSetField(out, TIFFTAG_INKSET, INKSET_MULTIINK);\n            TIFFSetField(out, TIFFTAG_NUMBEROFINKS, nChannels);\n        }\n        break;\n\n\n    default:\n        FatalError(\"Unsupported output colorspace\");\n    }\n\n    if (PixelDepth == 32)\n        TIFFSetField(out, TIFFTAG_SAMPLEFORMAT, \n                          SAMPLEFORMAT_IEEEFP, \n                          SAMPLEFORMAT_IEEEFP, \n                          SAMPLEFORMAT_IEEEFP, \n                          SAMPLEFORMAT_IEEEFP);\n}",
          "fn_code_pos": [
            [
              603,
              0
            ],
            [
              700,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteOutputTags",
            "parameters": {
              "out": "TIFF",
              "Colorspace": "int",
              "BytesPerSample": "int",
              "AlphaChannels": "int",
              "IsPremul": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid CopyOtherTags(TIFF* in, TIFF* out)\n{\n#define CopyField(tag, v) \\\n    if (TIFFGetField(in, tag, &v)) TIFFSetField(out, tag, v)\n\n\n    short shortv;\n    unsigned short compression;\n    cmsUInt32Number ow, ol;\n    cmsFloat32Number floatv;\n    char *stringv;\n    cmsUInt32Number longv;\n\n    CopyField(TIFFTAG_SUBFILETYPE, longv);\n\n    TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &ow);\n    TIFFGetField(in, TIFFTAG_IMAGELENGTH, &ol);\n\n    TIFFSetField(out, TIFFTAG_IMAGEWIDTH, ow);\n    TIFFSetField(out, TIFFTAG_IMAGELENGTH, ol);\n\n    CopyField(TIFFTAG_PLANARCONFIG, shortv);\n    CopyField(TIFFTAG_COMPRESSION, compression);\n\n    // This is tricky, libtiff would access predictor in a wrong way \n    // if the codec is none of those\n    if (compression == COMPRESSION_LZW ||\n        compression == 34925 /*COMPRESSION_LZMA*/ ||\n        compression == COMPRESSION_PIXARLOG || \n        compression == COMPRESSION_DEFLATE ||\n        compression == COMPRESSION_ADOBE_DEFLATE ||\n        compression == 50000 /*COMPRESSION_ZSTD*/)\n    {\n        if (PixelDepth != 32)\n            CopyField(TIFFTAG_PREDICTOR, shortv);\n    }\n\n    CopyField(TIFFTAG_THRESHHOLDING, shortv);\n    CopyField(TIFFTAG_FILLORDER, shortv);\n    CopyField(TIFFTAG_ORIENTATION, shortv);\n    CopyField(TIFFTAG_MINSAMPLEVALUE, shortv);\n    CopyField(TIFFTAG_MAXSAMPLEVALUE, shortv);\n    CopyField(TIFFTAG_XRESOLUTION, floatv);\n    CopyField(TIFFTAG_YRESOLUTION, floatv);\n    CopyField(TIFFTAG_RESOLUTIONUNIT, shortv);\n    CopyField(TIFFTAG_ROWSPERSTRIP, longv);\n    CopyField(TIFFTAG_XPOSITION, floatv);\n    CopyField(TIFFTAG_YPOSITION, floatv);\n    CopyField(TIFFTAG_IMAGEDEPTH, longv);\n    CopyField(TIFFTAG_TILEDEPTH, longv);\n\n    CopyField(TIFFTAG_TILEWIDTH,  longv);\n    CopyField(TIFFTAG_TILELENGTH, longv);\n\n    CopyField(TIFFTAG_ARTIST, stringv);\n    CopyField(TIFFTAG_IMAGEDESCRIPTION, stringv);\n    CopyField(TIFFTAG_MAKE, stringv);\n    CopyField(TIFFTAG_MODEL, stringv);\n\n    CopyField(TIFFTAG_DATETIME, stringv);\n    CopyField(TIFFTAG_HOSTCOMPUTER, stringv);\n    CopyField(TIFFTAG_PAGENAME, stringv);\n    CopyField(TIFFTAG_DOCUMENTNAME, stringv);\n\n}",
          "fn_code_pos": [
            [
              705,
              0
            ],
            [
              770,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CopyOtherTags",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid DoEmbedProfile(TIFF* Out, const char* ProfileFile)\n{\n    FILE* f;\n    cmsInt32Number size;\n    cmsUInt32Number EmbedLen;\n    cmsUInt8Number* EmbedBuffer;\n\n    f = fopen(ProfileFile, \"rb\");\n    if (f == NULL) return;\n\n    size = cmsfilelength(f);\n    if (size < 0) return;\n\n    EmbedBuffer = (cmsUInt8Number*) malloc((size_t) size + 1);\n    if (EmbedBuffer == NULL) { \n        OutOfMem(size+1);\n        return;\n    }\n\n    EmbedLen = (cmsUInt32Number) fread(EmbedBuffer, 1, (size_t) size, f);\n\n    if (EmbedLen != (cmsUInt32Number) size) \n        FatalError(\"Cannot read %ld bytes to %s\", (long) size, ProfileFile);\n\n    fclose(f);\n    EmbedBuffer[EmbedLen] = 0;\n\n    TIFFSetField(Out, TIFFTAG_ICCPROFILE, EmbedLen, EmbedBuffer);\n    free(EmbedBuffer);\n}",
          "fn_code_pos": [
            [
              773,
              0
            ],
            [
              803,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DoEmbedProfile",
            "parameters": {
              "Out": "TIFF",
              "ProfileFile": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsHPROFILE GetTIFFProfile(TIFF* in)\n{    \n    cmsCIExyYTRIPLE Primaries;\n    cmsFloat32Number* chr;\n    cmsCIExyY WhitePoint;\n    cmsFloat32Number* wp;\n    int i;       \n    cmsToneCurve* Curve[3]; \n    cmsUInt16Number *gmr, *gmg, *gmb;\n    cmsHPROFILE hProfile;\n    cmsUInt32Number EmbedLen;\n    cmsUInt8Number* EmbedBuffer;\n\n    if (IgnoreEmbedded) return NULL;\n\n    if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &EmbedLen, &EmbedBuffer)) {\n\n        hProfile = cmsOpenProfileFromMem(EmbedBuffer, EmbedLen);\n\n        // Print description found in the profile\n        if (Verbose && (hProfile != NULL)) {\n\n            fprintf(stdout, \"\\n[Embedded profile]\\n\");\n            PrintProfileInformation(hProfile);                       \n            fflush(stdout);\n        }\n\n        if (hProfile != NULL && SaveEmbedded != NULL)\n            SaveMemoryBlock(EmbedBuffer, EmbedLen, SaveEmbedded);\n\n        if (hProfile) return hProfile;\n    }\n\n    // Try to see if \"colorimetric\" tiff\n    if (TIFFGetField(in, TIFFTAG_PRIMARYCHROMATICITIES, &chr)) {\n\n        Primaries.Red.x   =  chr[0];\n        Primaries.Red.y   =  chr[1];\n        Primaries.Green.x =  chr[2];\n        Primaries.Green.y =  chr[3];\n        Primaries.Blue.x  =  chr[4];\n        Primaries.Blue.y  =  chr[5];\n\n        Primaries.Red.Y = Primaries.Green.Y = Primaries.Blue.Y = 1.0;\n\n        if (TIFFGetField(in, TIFFTAG_WHITEPOINT, &wp)) {\n\n            WhitePoint.x = wp[0];\n            WhitePoint.y = wp[1];\n            WhitePoint.Y = 1.0;\n\n            // Transfer function is a bit harder....\n            TIFFGetFieldDefaulted(in, TIFFTAG_TRANSFERFUNCTION,\n                &gmr, \n                &gmg,\n                &gmb);\n\n            Curve[0] = cmsBuildTabulatedToneCurve16(NULL, 256, gmr);\n            Curve[1] = cmsBuildTabulatedToneCurve16(NULL, 256, gmg);\n            Curve[2] = cmsBuildTabulatedToneCurve16(NULL, 256, gmb);\n\n            hProfile = cmsCreateRGBProfileTHR(NULL, &WhitePoint, &Primaries, Curve);\n\n            for (i=0; i < 3; i++)\n                cmsFreeToneCurve(Curve[i]);\n\n            if (Verbose) {\n                fprintf(stdout, \"\\n[Colorimetric TIFF]\\n\");\n            }\n\n\n            return hProfile;\n        }\n    }\n\n    return NULL;\n}",
          "fn_code_pos": [
            [
              807,
              0
            ],
            [
              884,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetTIFFProfile",
            "parameters": {
              "in": "TIFF"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "static\nint TransformImage(TIFF* in, TIFF* out, const char *cDefInpProf)\n{\n    cmsHPROFILE hIn, hOut, hProof, hInkLimit = NULL;\n    cmsHTRANSFORM xform;\n    cmsUInt32Number wInput, wOutput;\n    int OutputColorSpace;\n    int BytesPerSample = PixelDepth / 8;\n    cmsUInt32Number dwFlags;        \n    int nPlanes;\n\n    // Default options\n    dwFlags = cmsFLAGS_COPY_ALPHA;\n\n    // Observer adaptation state (only meaningful on absolute colorimetric intent)\n    cmsSetAdaptationState(ObserverAdaptationState);\n\n    if (EmbedProfile && cOutProf) \n        DoEmbedProfile(out, cOutProf);\n\n    if (BlackWhiteCompensation) \n        dwFlags |= cmsFLAGS_BLACKPOINTCOMPENSATION;           \n\n    switch (PrecalcMode) {\n\n       case 0: dwFlags |= cmsFLAGS_NOOPTIMIZE; break;\n       case 2: dwFlags |= cmsFLAGS_HIGHRESPRECALC; break;\n       case 3: dwFlags |= cmsFLAGS_LOWRESPRECALC; break;\n       case 1: break;\n\n       default: FatalError(\"Unknown precalculation mode '%d'\", PrecalcMode);\n    }\n\n    if (GamutCheck)\n        dwFlags |= cmsFLAGS_GAMUTCHECK;\n\n    hProof = NULL;\n    hOut = NULL;\n\n    if (lIsDeviceLink) {\n\n        if (lIsCUBE)\n            hIn = cmsCreateDeviceLinkFromCubeFile(cDefInpProf);\n        else\n            hIn = cmsOpenProfileFromFile(cDefInpProf, \"r\");                  \n    }\n    else {\n\n        hIn =  GetTIFFProfile(in);\n\n        if (hIn == NULL)                    \n            hIn = OpenStockProfile(NULL, cDefInpProf);               \n\n        hOut = OpenStockProfile(NULL, cOutProf);\n\n        if (cProofing != NULL) {\n\n            hProof = OpenStockProfile(NULL, cProofing);\n            dwFlags |= cmsFLAGS_SOFTPROOFING;\n        }\n    }\n\n    // Take input color space\n    wInput = GetInputPixelType(in);\n\n    // Assure both, input profile and input TIFF are on same colorspace\n    if (_cmsLCMScolorSpace(cmsGetColorSpace(hIn)) != (int) T_COLORSPACE(wInput))\n        FatalError(\"Input profile is not operating in proper color space (%d)\", T_COLORSPACE(wInput));\n\n\n    if (!lIsDeviceLink) \n        OutputColorSpace = _cmsLCMScolorSpace(cmsGetColorSpace(hOut));\n    else \n        OutputColorSpace = _cmsLCMScolorSpace(cmsGetPCS(hIn));\n\n    wOutput  = ComputeOutputFormatDescriptor(wInput, OutputColorSpace, BytesPerSample);\n\n    WriteOutputTags(out, OutputColorSpace, BytesPerSample, T_EXTRA(wOutput), T_PREMUL(wOutput));\n    CopyOtherTags(in, out);\n\n    // Ink limit\n    if (InkLimit != 400.0 && \n        (OutputColorSpace == PT_CMYK || OutputColorSpace == PT_CMY)) {\n\n            cmsHPROFILE hProfiles[10];\n            int nProfiles = 0;\n\n            hInkLimit = cmsCreateInkLimitingDeviceLink(cmsGetColorSpace(hOut), InkLimit);\n\n            hProfiles[nProfiles++] = hIn;\n            if (hProof) {\n                hProfiles[nProfiles++] = hProof;\n                hProfiles[nProfiles++] = hProof;\n            }\n\n            hProfiles[nProfiles++] = hOut;\n            hProfiles[nProfiles++] = hInkLimit;\n\n            xform = cmsCreateMultiprofileTransform(hProfiles, nProfiles, \n                                                   wInput, wOutput, Intent, dwFlags);\n\n    }\n    else {\n\n        xform = cmsCreateProofingTransform(hIn, wInput, \n                                           hOut, wOutput, \n                                           hProof, Intent, \n                                           ProofingIntent, \n                                           dwFlags);\n    }\n\n    cmsCloseProfile(hIn);\n    cmsCloseProfile(hOut);\n\n    if (hInkLimit) \n        cmsCloseProfile(hInkLimit);\n    if (hProof) \n        cmsCloseProfile(hProof);\n\n    if (xform == NULL) return 0;\n\n    // Planar stuff\n    if (T_PLANAR(wInput)) \n        nPlanes = T_CHANNELS(wInput) + T_EXTRA(wInput);\n    else\n        nPlanes = 1;\n\n\n    // Handle tile by tile or strip by strip\n    if (TIFFIsTiled(in)) {\n\n        TileBasedXform(xform, in, out, nPlanes);\n    }\n    else {\n        StripBasedXform(xform, in, out, nPlanes);\n    }\n\n\n    cmsDeleteTransform(xform);\n\n    TIFFWriteDirectory(out);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              888,
              0
            ],
            [
              1031,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TransformImage",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF",
              "cDefInpProf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nvoid Help(int level)\n{\n    UTILS_UNUSED_PARAMETER(level);\n\n    fprintf(stderr, \"Little CMS ICC profile applier for TIFF - v8.0 [LittleCMS %2.2f]\\n\", cmsGetEncodedCMMversion() / 1000.0);\n    fprintf(stderr, \"Copyright (c) 1998-2024 Marti Maria Saguer. See COPYING file for details.\\n\");\n    fflush(stderr);\n\n    fprintf(stderr, \"usage: tificc [flags] input.tif output.tif\\n\");\n\n    fprintf(stderr, \"\\nflags:\\n\\n\");\n    fprintf(stderr, \"-v - Verbose\\n\");\n    fprintf(stderr, \"-i<profile> - Input profile (defaults to sRGB)\\n\");\n    fprintf(stderr, \"-o<profile> - Output profile (defaults to sRGB)\\n\");\n    fprintf(stderr, \"-l<profile> - Transform by device-link profile\\n\");\n    fprintf(stderr, \"-u<profile> - Transform by CUBE colormap\\n\");\n\n    PrintBuiltins();\n\n    PrintRenderingIntents();\n\n    fprintf(stderr, \"-b - Black point compensation\\n\");\n    fprintf(stderr, \"-d<0..1> - Observer adaptation state (abs.col. only)\\n\");\n\n    fprintf(stderr, \"-c<0,1,2,3> - Precalculates transform (0=Off, 1=Normal, 2=Hi-res, 3=LoRes)\\n\");\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"-w<8,16,32> - Output depth. Use 32 for floating-point\\n\\n\");\n    fprintf(stderr, \"-a - Handle channels > 4 as alpha\\n\");\n\n    fprintf(stderr, \"-n - Ignore embedded profile on input\\n\");\n    fprintf(stderr, \"-e - Embed destination profile\\n\");\n    fprintf(stderr, \"-s<new profile> - Save embedded profile as <new profile>\\n\");\n    fprintf(stderr, \"\\n\");\n\n\n    fprintf(stderr, \"-p<profile> - Soft proof profile\\n\");\n    fprintf(stderr, \"-m<n> - Soft proof intent\\n\");\n    fprintf(stderr, \"\\tThat is the intent used to translate the simulation to the output device.\\n\\tNote that the simulated intent is set by using -t not by -m\\n\");\n    fprintf(stderr, \"-g - Marks out-of-gamut colors on softproof\\n\");\n\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"-k<0..400> - Ink-limiting in %% (CMYK only)\\n\");\n    fprintf(stderr, \"\\n\");\n    \n\n    fprintf(stderr, \"Examples:\\n\\n\"\n        \"To color correct from scanner to sRGB:\\n\"\n        \"\\ttificc -iscanner.icm in.tif out.tif\\n\"\n        \"To convert from monitor1 to monitor2:\\n\"\n        \"\\ttificc -imon1.icm -omon2.icm in.tif out.tif\\n\"\n        \"To make a CMYK separation:\\n\"\n        \"\\ttificc -oprinter.icm inrgb.tif outcmyk.tif\\n\"\n        \"To recover sRGB from a CMYK separation:\\n\"\n        \"\\ttificc -iprinter.icm incmyk.tif outrgb.tif\\n\"\n        \"To soft-proof how behaves Probev1_ICCv4.icc on perceptual:\\n\"\n        \"\\ttifficc -t0 -p Probev1_ICCv4.icc -m1 infile.tif out.tif\\n\"\n        \"To convert from CIELab TIFF to sRGB\\n\"\n        \"\\ttificc -i*Lab in.tif out.tif\\n\\n\");\n\n\n    fprintf(stderr, \"This program is intended to be a demo of the Little CMS\\n\"\n        \"color engine. Both lcms and this program are open source.\\n\"\n        \"You can obtain both in source code at https://www.littlecms.com\\n\"\n        \"For suggestions, comments, bug reports etc. send mail to\\n\"\n        \"info@littlecms.com\\n\\n\");\n\n    exit(0);\n}",
          "fn_code_pos": [
            [
              1035,
              0
            ],
            [
              1105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Help",
            "parameters": {
              "level": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid HandleSwitches(int argc, char *argv[])\n{\n    int s;\n\n    while ((s=xgetopt(argc,argv,\"aAeEbBw:W:nNvVGgh:H:i:I:o:O:P:p:t:T:c:C:l:L:u:U:M:m:K:k:S:s:D:d:-:\")) != EOF) {\n\n        switch (s) {\n\n\n        case '-':\n            if (strcmp(xoptarg, \"help\") == 0)\n            {\n                Help(0);\n            }\n            else\n            {\n                FatalError(\"Unknown option - run without args to see valid ones.\\n\");\n            }\n            break;\n\n        case 'a':\n        case 'A':\n            StoreAsAlpha = TRUE;\n            break;\n        case 'b':\n        case 'B':\n            BlackWhiteCompensation = TRUE;\n            break;\n\n        case 'c':\n        case 'C':\n            PrecalcMode = atoi(xoptarg);\n            if (PrecalcMode < 0 || PrecalcMode > 3)\n                FatalError(\"Unknown precalc mode '%d'\", PrecalcMode);\n            break;\n\n        case 'd':\n        case 'D': ObserverAdaptationState = atof(xoptarg);\n            if (ObserverAdaptationState < 0 || \n                ObserverAdaptationState > 1.0)\n                Warning(\"Adaptation state should be 0..1\");\n            break;\n\n        case 'e':\n        case 'E':\n            EmbedProfile = TRUE;\n            break;\n\n        case 'g':\n        case 'G':\n            GamutCheck = TRUE;\n            break;\n\n        case 'v':\n        case 'V':\n            Verbose = TRUE;\n            break;\n\n        case 'i':\n        case 'I':\n            if (lIsDeviceLink)\n                FatalError(\"Device-link already specified\"); \n\n            cInpProf = xoptarg;\n            break;\n\n        case 'o':\n        case 'O':\n            if (lIsDeviceLink)\n                FatalError(\"Device-link already specified\"); \n\n            cOutProf = xoptarg;\n            break;\n\n        case 'l':\n        case 'L': \n            if (cInpProf != NULL || cOutProf != NULL) \n                FatalError(\"input/output profiles already specified\");\n\n            cInpProf = xoptarg;\n            lIsDeviceLink = TRUE;\n            lIsCUBE = FALSE;\n            break;\n\n        case 'u':\n        case 'U':\n            if (cInpProf != NULL || cOutProf != NULL)\n                FatalError(\"input/output profiles already specified\");\n\n            cInpProf = xoptarg;\n            lIsDeviceLink = TRUE;\n            lIsCUBE = TRUE;\n            break;\n\n        case 'p':\n        case 'P':\n            cProofing = xoptarg;\n            break;\n\n        case 't':\n        case 'T':\n            Intent = atoi(xoptarg);\n            break;\n\n        case 'm':\n        case 'M':\n            ProofingIntent = atoi(xoptarg);\n            break;\n\n        case 'N':\n        case 'n':\n            IgnoreEmbedded = TRUE;\n            break;\n\n        case 'W':\n        case 'w':\n            PixelDepth = atoi(xoptarg);\n            if (PixelDepth != 8 && PixelDepth != 16 && PixelDepth != 32)\n                FatalError(\"Only 8, 16 and 32 bps are supported\");\n            break;\n\n        case 'k':\n        case 'K':\n            InkLimit = atof(xoptarg);\n            if (InkLimit < 0.0 || InkLimit > 400.0)\n                FatalError(\"Ink limit must be 0%%..400%%\");\n            break;\n\n\n        case 's':\n        case 'S': SaveEmbedded = xoptarg;\n            break;\n\n        case 'H':\n        case 'h':  {\n\n            int a =  atoi(xoptarg);\n            Help(a); \n            }\n            break;\n\n        default:\n\n            FatalError(\"Unknown option - run without args to see valid ones\");\n        }\n\n    }\n}",
          "fn_code_pos": [
            [
              1110,
              0
            ],
            [
              1258,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HandleSwitches",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(int argc, char* argv[])\n{\n    TIFF *in, *out;\n   \n    cmsPlugin(&TiffLabPlugin);\n\n    InitUtils(\"tificc\");\n\n    HandleSwitches(argc, argv);\n\n    if ((argc - xoptind) != 2) {\n\n        Help(0);              \n    }\n   \n\n    TIFFSetErrorHandler(ConsoleErrorHandler);\n    TIFFSetWarningHandler(ConsoleWarningHandler);\n\n    in = TIFFOpen(argv[xoptind], \"r\");\n    if (in == NULL) FatalError(\"Unable to open '%s'\", argv[xoptind]);\n\n    out = TIFFOpen(argv[xoptind+1], \"w\");\n\n    if (out == NULL) {\n\n        TIFFClose(in);\n        FatalError(\"Unable to write '%s'\", argv[xoptind+1]);\n    }\n\n    do {\n\n        TransformImage(in, out, cInpProf);\n\n\n    } while (TIFFReadDirectory(in));\n\n\n    if (Verbose) { fprintf(stdout, \"\\n\"); fflush(stdout); }\n\n    TIFFClose(in);\n    TIFFClose(out);\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              1263,
              0
            ],
            [
              1307,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "UnrollTIFFLab8(struct _cmstransform_struct* CMMcargo,\n                              CMSREGISTER cmsUInt16Number wIn[], \n                              CMSREGISTER cmsUInt8Number* accum, \n                              CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              150,
              15
            ],
            [
              153,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollTIFFLab8",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollTIFFLab16(struct _cmstransform_struct* CMMcargo,\n                              CMSREGISTER cmsUInt16Number wIn[],\n                              CMSREGISTER cmsUInt8Number* accum,\n                              CMSREGISTER cmsUInt32Number Stride )",
          "fn_dec_pos": [
            [
              167,
              15
            ],
            [
              170,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollTIFFLab16",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackTIFFLab8(struct _cmstransform_struct* CMMcargo, \n                            CMSREGISTER cmsUInt16Number wOut[], \n                            CMSREGISTER cmsUInt8Number* output, \n                            CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              186,
              15
            ],
            [
              189,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackTIFFLab8",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackTIFFLabA8(struct _cmstransform_struct* CMMcargo, \n                            CMSREGISTER cmsUInt16Number wOut[], \n                            CMSREGISTER cmsUInt8Number* output, \n                            CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              209,
              15
            ],
            [
              212,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackTIFFLabA8",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackTIFFLab16(struct _cmstransform_struct* CMMcargo, \n                            CMSREGISTER cmsUInt16Number wOut[], \n                            CMSREGISTER cmsUInt8Number* output, \n                            CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              234,
              15
            ],
            [
              237,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackTIFFLab16",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackTIFFLabA16(struct _cmstransform_struct* CMMcargo, \n                            CMSREGISTER cmsUInt16Number wOut[], \n                            CMSREGISTER cmsUInt8Number* output, \n                            CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              257,
              15
            ],
            [
              260,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackTIFFLabA16",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            150,
            30
          ],
          [
            150,
            57
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            167,
            31
          ],
          [
            167,
            58
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            186,
            28
          ],
          [
            186,
            55
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            209,
            29
          ],
          [
            209,
            56
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            234,
            29
          ],
          [
            234,
            56
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            257,
            30
          ],
          [
            257,
            57
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_plugin.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"utils.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdint.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/utils/common/vprf.c": {
      "fn_def_list": [
        {
          "fn_code": "void FatalError(const char *frm, ...)\n{\n    va_list args;\n\n    va_start(args, frm);\n    fprintf(stderr, \"[%s fatal error]: \", ProgramName);\n    vfprintf(stderr, frm, args);\n    fprintf(stderr, \"\\n\");\n    va_end(args);\n\n    exit(1);\n}",
          "fn_code_pos": [
            [
              33,
              0
            ],
            [
              44,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FatalError",
            "parameters": {
              "frm": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid MyErrorLogHandler(cmsContext ContextID, cmsUInt32Number ErrorCode, const char *Text)\n{\n    if (Verbose >= 0)\n        fprintf(stderr, \"[%s]: %s\\n\", ProgramName, Text);\n\n    UTILS_UNUSED_PARAMETER(ErrorCode);\n    UTILS_UNUSED_PARAMETER(ContextID);\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MyErrorLogHandler",
            "parameters": {
              "ContextID": "cmsContext",
              "ErrorCode": "cmsUInt32Number",
              "Text": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void InitUtils(const char* PName)\n{\n      strncpy(ProgramName, PName, sizeof(ProgramName));\n      ProgramName[sizeof(ProgramName)-1] = 0;\n\n      cmsSetLogErrorHandler(MyErrorLogHandler);\n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              64,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "InitUtils",
            "parameters": {
              "PName": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsHPROFILE OpenStockProfile(cmsContext ContextID, const char* File)\n{\n       if (!File)\n            return cmsCreate_sRGBProfileTHR(ContextID);\n\n       if (cmsstrcasecmp(File, \"*Lab2\") == 0)\n                return cmsCreateLab2ProfileTHR(ContextID, NULL);\n\n       if (cmsstrcasecmp(File, \"*Lab4\") == 0)\n                return cmsCreateLab4ProfileTHR(ContextID, NULL);\n\n       if (cmsstrcasecmp(File, \"*Lab\") == 0)\n                return cmsCreateLab4ProfileTHR(ContextID, NULL);\n\n       if (cmsstrcasecmp(File, \"*LabD65\") == 0) {\n\n           cmsCIExyY D65xyY;\n\n           cmsWhitePointFromTemp( &D65xyY, 6504);\n           return cmsCreateLab4ProfileTHR(ContextID, &D65xyY);\n       }\n\n       if (cmsstrcasecmp(File, \"*XYZ\") == 0)\n                return cmsCreateXYZProfileTHR(ContextID);\n\n       if (cmsstrcasecmp(File, \"*Gray22\") == 0) {\n\n           cmsToneCurve* Curve = cmsBuildGamma(ContextID, 2.2);\n           cmsHPROFILE hProfile = cmsCreateGrayProfileTHR(ContextID, cmsD50_xyY(), Curve);\n           cmsFreeToneCurve(Curve);\n           return hProfile;\n       }\n\n        if (cmsstrcasecmp(File, \"*Gray30\") == 0) {\n\n           cmsToneCurve* Curve = cmsBuildGamma(ContextID, 3.0);\n           cmsHPROFILE hProfile = cmsCreateGrayProfileTHR(ContextID, cmsD50_xyY(), Curve);\n           cmsFreeToneCurve(Curve);\n           return hProfile;\n       }\n\n       if (cmsstrcasecmp(File, \"*srgb\") == 0)\n                return cmsCreate_sRGBProfileTHR(ContextID);\n\n       if (cmsstrcasecmp(File, \"*null\") == 0)\n                return cmsCreateNULLProfileTHR(ContextID);\n\n\n       if (cmsstrcasecmp(File, \"*Lin2222\") == 0) {\n\n            cmsToneCurve*  Gamma = cmsBuildGamma(0, 2.2);\n            cmsToneCurve*  Gamma4[4];\n            cmsHPROFILE hProfile;\n\n            Gamma4[0] = Gamma4[1] = Gamma4[2] = Gamma4[3] = Gamma;\n            hProfile = cmsCreateLinearizationDeviceLink(cmsSigCmykData, Gamma4);\n            cmsFreeToneCurve(Gamma);\n            return hProfile;\n       }\n\n\n        return cmsOpenProfileFromFileTHR(ContextID, File, \"r\");\n}",
          "fn_code_pos": [
            [
              68,
              0
            ],
            [
              130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OpenStockProfile",
            "parameters": {
              "ContextID": "cmsContext",
              "File": "char"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "void PrintBuiltins(void)\n{\n     fprintf(stderr, \"\\nBuilt-in profiles:\\n\\n\");\n     fprintf(stderr, \"\\t*Lab2  -- D50-based v2 CIEL*a*b\\n\"\n                     \"\\t*Lab4  -- D50-based v4 CIEL*a*b\\n\"\n                     \"\\t*Lab   -- D50-based v4 CIEL*a*b\\n\"\n                     \"\\t*XYZ   -- CIE XYZ (PCS)\\n\"\n                     \"\\t*sRGB  -- sRGB color space\\n\"\n                     \"\\t*Gray22 - Monochrome of Gamma 2.2\\n\"\n                     \"\\t*Gray30 - Monochrome of Gamma 3.0\\n\"\n                     \"\\t*null   - Monochrome black for all input\\n\"\n                     \"\\t*Lin2222- CMYK linearization of gamma 2.2 on each channel\\n\\n\");\n}",
          "fn_code_pos": [
            [
              133,
              0
            ],
            [
              145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintBuiltins",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid PrintInfo(cmsHPROFILE h, cmsInfoType Info)\n{\n    char* text;\n    int len;\n\n    len = cmsGetProfileInfoASCII(h, Info, \"en\", \"US\", NULL, 0);\n    if (len == 0) return;\n\n    text = (char*) malloc(len * sizeof(char));\n    if (text == NULL) return;\n\n    cmsGetProfileInfoASCII(h, Info, \"en\", \"US\", text, len);\n\n    if (strlen(text) > 0)\n        printf(\"%s\\n\", text);\n\n    free(text);\n}",
          "fn_code_pos": [
            [
              149,
              0
            ],
            [
              167,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintInfo",
            "parameters": {
              "h": "cmsHPROFILE",
              "Info": "cmsInfoType"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid PrintColorantTable(cmsHPROFILE hInput, cmsTagSignature Sig, const char* Title)\n{\n    cmsNAMEDCOLORLIST* list;\n    int i, n;\n\n    if (cmsIsTag(hInput, Sig)) {\n\n        printf(\"%s:\\n\", Title);\n\n        list = (cmsNAMEDCOLORLIST*) cmsReadTag(hInput, Sig);\n        if (list == NULL) {\n            printf(\"(Unavailable)\\n\");\n            return;\n        }\n\n        n = cmsNamedColorCount(list);\n        for (i=0; i < n; i++) {\n\n            char Name[cmsMAX_PATH];\n\n            cmsNamedColorInfo(list, i, Name, NULL, NULL, NULL, NULL);\n            printf(\"\\t%s\\n\", Name);\n        }\n\n        printf(\"\\n\");\n    }\n\n}",
          "fn_code_pos": [
            [
              172,
              0
            ],
            [
              200,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintColorantTable",
            "parameters": {
              "hInput": "cmsHPROFILE",
              "Sig": "cmsTagSignature",
              "Title": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void PrintProfileInformation(cmsHPROFILE hInput)\n{\n    if (hInput == NULL) {\n\t\t\tfprintf(stderr, \"*Wrong or corrupted profile*\\n\");\n            return;\n    }\n\n    PrintInfo(hInput, cmsInfoDescription);\n    PrintInfo(hInput, cmsInfoManufacturer);\n    PrintInfo(hInput, cmsInfoModel);\n    PrintInfo(hInput, cmsInfoCopyright);\n\n    if (Verbose > 2) {\n\n        PrintColorantTable(hInput, cmsSigColorantTableTag,    \"Input colorant table\");\n        PrintColorantTable(hInput, cmsSigColorantTableOutTag, \"Input colorant out table\");\n    }\n\n    printf(\"\\n\");\n}",
          "fn_code_pos": [
            [
              203,
              0
            ],
            [
              222,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintProfileInformation",
            "parameters": {
              "hInput": "cmsHPROFILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void PrintRenderingIntents(void)\n{\n    cmsUInt32Number Codes[200];\n    char* Descriptions[200];\n    cmsUInt32Number n, i;\n\n    fprintf(stderr, \"-t<n> rendering intent:\\n\\n\");\n\n    n = cmsGetSupportedIntents(200, Codes, Descriptions);\n\n    for (i=0; i < n; i++) {\n        fprintf(stderr, \"\\t%u - %s\\n\", Codes[i], Descriptions[i]);\n    }\n    fprintf(stderr, \"\\n\");\n}",
          "fn_code_pos": [
            [
              227,
              0
            ],
            [
              241,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintRenderingIntents",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool SaveMemoryBlock(const cmsUInt8Number* Buffer, cmsUInt32Number dwLen, const char* Filename)\n{\n    FILE* out = fopen(Filename, \"wb\");\n    if (out == NULL) {\n        FatalError(\"Cannot create '%s'\", Filename);\n        return FALSE;\n    }\n\n    if (fwrite(Buffer, 1, dwLen, out) != dwLen) {\n        FatalError(\"Cannot write %ld bytes to %s\", (long) dwLen, Filename);\n        return FALSE;\n    }\n\n    if (fclose(out) != 0) {\n        FatalError(\"Error flushing file '%s'\", Filename);\n        return FALSE;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              247,
              0
            ],
            [
              266,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SaveMemoryBlock",
            "parameters": {
              "Buffer": "cmsUInt8Number",
              "dwLen": "cmsUInt32Number",
              "Filename": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "int PixelTypeFromChanCount(int ColorChannels)\n{\n    switch (ColorChannels) {\n\n        case 1: return PT_GRAY;\n        case 2: return PT_MCH2;\n        case 3: return PT_MCH3;\n        case 4: return PT_CMYK;\n        case 5: return PT_MCH5;\n        case 6: return PT_MCH6;\n        case 7: return PT_MCH7;\n        case 8: return PT_MCH8;\n        case 9: return PT_MCH9;\n        case 10: return PT_MCH10;\n        case 11: return PT_MCH11;\n        case 12: return PT_MCH12;\n        case 13: return PT_MCH13;\n        case 14: return PT_MCH14;\n        case 15: return PT_MCH15;\n\n        default:\n\n            FatalError(\"What a weird separation of %d channels?!?!\", ColorChannels);\n            return -1;\n    }\n}",
          "fn_code_pos": [
            [
              271,
              0
            ],
            [
              296,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixelTypeFromChanCount",
            "parameters": {
              "ColorChannels": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ChanCountFromPixelType(int ColorChannels)\n{\n    switch (ColorChannels) {\n\n      case PT_GRAY: return 1;\n\n      case PT_RGB:\n      case PT_CMY:\n      case PT_Lab:\n      case PT_YUV:\n      case PT_YCbCr: return 3;\n\n      case PT_CMYK: return 4 ;\n      case PT_MCH2: return 2 ;\n      case PT_MCH3: return 3 ;\n      case PT_MCH4: return 4 ;\n      case PT_MCH5: return 5 ;\n      case PT_MCH6: return 6 ;\n      case PT_MCH7: return 7 ;\n      case PT_MCH8: return 8 ;\n      case PT_MCH9: return 9 ;\n      case PT_MCH10: return 10;\n      case PT_MCH11: return 11;\n      case PT_MCH12: return 12;\n      case PT_MCH13: return 12;\n      case PT_MCH14: return 14;\n      case PT_MCH15: return 15;\n\n      default:\n\n          FatalError(\"Unsupported color space of %d channels\", ColorChannels);\n          return -1;\n    }\n}",
          "fn_code_pos": [
            [
              302,
              0
            ],
            [
              335,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ChanCountFromPixelType",
            "parameters": {
              "ColorChannels": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"utils.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/utils/common/xgetopt.c": {
      "fn_def_list": [
        {
          "fn_code": "int xgetopt(int argc, char* argv[], char* optionS)\n{\n    unsigned char ch;\n    char* optP;\n\n    if (argc > xoptind)\n    {\n\n        if (nextArg == NULL)\n        {\n            if ((nextArg = argv[xoptind]) == NULL || *(nextArg++) != SW)  goto end_eof;\n        }\n\n        if ((ch = *(nextArg++)) == 0)\n        {\n            xoptind++;\n            goto end_eof;\n        }\n\n        if (ch == ':' || (optP = strchr(optionS, ch)) == NULL)\n            goto end_error;\n\n        if (*(++optP) == ':')\n        {\n            xoptind++;\n\n            if (*nextArg == 0)\n            {\n                if (argc <= xoptind)  goto  end_error;\n                nextArg = argv[xoptind++];\n            }\n\n            xoptarg = nextArg;\n            nextArg = NULL;\n\n        }\n        else\n        {\n            if (*nextArg == 0)\n            {\n                xoptind++;\n                nextArg = NULL;\n            }\n\n            xoptarg = NULL;\n        }\n\n        return ch;\n    }\n\nend_eof:\n    xoptarg = nextArg = NULL;\n    return EOF;\n\nend_error:\n    xoptarg = NULL;\n    return '?';\n}",
          "fn_code_pos": [
            [
              42,
              0
            ],
            [
              99,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "xgetopt",
            "parameters": {
              "argc": "int",
              "argv": "char",
              "optionS": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <string.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/utils/jpgicc/iccjpeg.c": {
      "fn_def_list": [
        {
          "fn_code": "void\nwrite_icc_profile (j_compress_ptr cinfo,\n\t\t   const JOCTET *icc_data_ptr,\n\t\t   unsigned int icc_data_len)\n{\n  unsigned int num_markers;\t/* total number of markers we'll write */\n  int cur_marker = 1;\t\t/* per spec, counting starts at 1 */\n  unsigned int length;\t\t/* number of bytes to write in this marker */\n\n  /* Calculate the number of markers we'll need, rounding up of course */\n  num_markers = icc_data_len / MAX_DATA_BYTES_IN_MARKER;\n  if (num_markers * MAX_DATA_BYTES_IN_MARKER != icc_data_len)\n    num_markers++;\n\n  while (icc_data_len > 0) {\n    /* length of profile to put in this marker */\n    length = icc_data_len;\n    if (length > MAX_DATA_BYTES_IN_MARKER)\n      length = MAX_DATA_BYTES_IN_MARKER;\n    icc_data_len -= length;\n\n    /* Write the JPEG marker header (APP2 code and marker length) */\n    jpeg_write_m_header(cinfo, ICC_MARKER,\n\t\t\t(unsigned int) (length + ICC_OVERHEAD_LEN));\n\n    /* Write the marker identifying string \"ICC_PROFILE\" (null-terminated).\n     * We code it in this less-than-transparent way so that the code works\n     * even if the local character set is not ASCII.\n     */\n    jpeg_write_m_byte(cinfo, 0x49);\n    jpeg_write_m_byte(cinfo, 0x43);\n    jpeg_write_m_byte(cinfo, 0x43);\n    jpeg_write_m_byte(cinfo, 0x5F);\n    jpeg_write_m_byte(cinfo, 0x50);\n    jpeg_write_m_byte(cinfo, 0x52);\n    jpeg_write_m_byte(cinfo, 0x4F);\n    jpeg_write_m_byte(cinfo, 0x46);\n    jpeg_write_m_byte(cinfo, 0x49);\n    jpeg_write_m_byte(cinfo, 0x4C);\n    jpeg_write_m_byte(cinfo, 0x45);\n    jpeg_write_m_byte(cinfo, 0x0);\n\n    /* Add the sequencing info */\n    jpeg_write_m_byte(cinfo, cur_marker);\n    jpeg_write_m_byte(cinfo, (int) num_markers);\n\n    /* Add the profile data */\n    while (length--) {\n      jpeg_write_m_byte(cinfo, *icc_data_ptr);\n      icc_data_ptr++;\n    }\n    cur_marker++;\n  }\n}",
          "fn_code_pos": [
            [
              50,
              0
            ],
            [
              103,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "write_icc_profile",
            "parameters": {
              "cinfo": "j_compress_ptr",
              "icc_data_ptr": "JOCTET",
              "icc_data_len": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nsetup_read_icc_profile (j_decompress_ptr cinfo)\n{\n  /* Tell the library to keep any APP2 data it may find */\n  jpeg_save_markers(cinfo, ICC_MARKER, 0xFFFF);\n}",
          "fn_code_pos": [
            [
              110,
              0
            ],
            [
              115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setup_read_icc_profile",
            "parameters": {
              "cinfo": "j_decompress_ptr"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static boolean\nmarker_is_icc (jpeg_saved_marker_ptr marker)\n{\n  return\n    marker->marker == ICC_MARKER &&\n    marker->data_length >= ICC_OVERHEAD_LEN &&\n    /* verify the identifying string */\n    GETJOCTET(marker->data[0]) == 0x49 &&\n    GETJOCTET(marker->data[1]) == 0x43 &&\n    GETJOCTET(marker->data[2]) == 0x43 &&\n    GETJOCTET(marker->data[3]) == 0x5F &&\n    GETJOCTET(marker->data[4]) == 0x50 &&\n    GETJOCTET(marker->data[5]) == 0x52 &&\n    GETJOCTET(marker->data[6]) == 0x4F &&\n    GETJOCTET(marker->data[7]) == 0x46 &&\n    GETJOCTET(marker->data[8]) == 0x49 &&\n    GETJOCTET(marker->data[9]) == 0x4C &&\n    GETJOCTET(marker->data[10]) == 0x45 &&\n    GETJOCTET(marker->data[11]) == 0x0;\n}",
          "fn_code_pos": [
            [
              122,
              0
            ],
            [
              141,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "marker_is_icc",
            "parameters": {
              "marker": "jpeg_saved_marker_ptr"
            },
            "return_type": "boolean"
          }
        },
        {
          "fn_code": "boolean\nread_icc_profile (j_decompress_ptr cinfo,\n\t\t  JOCTET **icc_data_ptr,\n\t\t  unsigned int *icc_data_len)\n{\n  jpeg_saved_marker_ptr marker;\n  int num_markers = 0;\n  int seq_no;\n  JOCTET *icc_data;\n  unsigned int total_length;\n#define MAX_SEQ_NO  255\t\t/* sufficient since marker numbers are bytes */\n  char marker_present[MAX_SEQ_NO+1];\t  /* 1 if marker found */\n  unsigned int data_length[MAX_SEQ_NO+1]; /* size of profile data in marker */\n  unsigned int data_offset[MAX_SEQ_NO+1]; /* offset for data in marker */\n\n  *icc_data_ptr = NULL;\t\t/* avoid confusion if FALSE return */\n  *icc_data_len = 0;\n\n  /* This first pass over the saved markers discovers whether there are\n   * any ICC markers and verifies the consistency of the marker numbering.\n   */\n\n  for (seq_no = 1; seq_no <= MAX_SEQ_NO; seq_no++)\n    marker_present[seq_no] = 0;\n\n  for (marker = cinfo->marker_list; marker != NULL; marker = marker->next) {\n    if (marker_is_icc(marker)) {\n      if (num_markers == 0)\n\tnum_markers = GETJOCTET(marker->data[13]);\n      else if (num_markers != GETJOCTET(marker->data[13]))\n\treturn FALSE;\t\t/* inconsistent num_markers fields */\n      seq_no = GETJOCTET(marker->data[12]);\n      if (seq_no <= 0 || seq_no > num_markers)\n\treturn FALSE;\t\t/* bogus sequence number */\n      if (marker_present[seq_no])\n\treturn FALSE;\t\t/* duplicate sequence numbers */\n      marker_present[seq_no] = 1;\n      data_length[seq_no] = marker->data_length - ICC_OVERHEAD_LEN;\n    }\n  }\n\n  if (num_markers == 0)\n    return FALSE;\n\n  /* Check for missing markers, count total space needed,\n   * compute offset of each marker's part of the data.\n   */\n\n  total_length = 0;\n  for (seq_no = 1; seq_no <= num_markers; seq_no++) {\n    if (marker_present[seq_no] == 0)\n      return FALSE;\t\t/* missing sequence number */\n    data_offset[seq_no] = total_length;\n    total_length += data_length[seq_no];\n  }\n\n  if (total_length == 0)\n    return FALSE;\t\t/* found only empty markers? */\n\n  /* Allocate space for assembled data */\n  icc_data = (JOCTET *) malloc(total_length * sizeof(JOCTET));\n  if (icc_data == NULL)\n    return FALSE;\t\t/* oops, out of memory */\n\n  /* and fill it in */\n  for (marker = cinfo->marker_list; marker != NULL; marker = marker->next) {\n    if (marker_is_icc(marker)) {\n      JOCTET FAR *src_ptr;\n      JOCTET *dst_ptr;\n      unsigned int length;\n      seq_no = GETJOCTET(marker->data[12]);\n      dst_ptr = icc_data + data_offset[seq_no];\n      src_ptr = marker->data + ICC_OVERHEAD_LEN;\n      length = data_length[seq_no];\n      while (length--) {\n\t*dst_ptr++ = *src_ptr++;\n      }\n    }\n  }\n\n  *icc_data_ptr = icc_data;\n  *icc_data_len = total_length;\n\n  return TRUE;\n}",
          "fn_code_pos": [
            [
              163,
              0
            ],
            [
              247,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_icc_profile",
            "parameters": {
              "cinfo": "j_decompress_ptr",
              "icc_data_ptr": "JOCTET",
              "icc_data_len": "unsigned int"
            },
            "return_type": "boolean"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"iccjpeg.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include <stdlib.h>\t\t\t/* define malloc() */\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/utils/jpgicc/jpgicc.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nvoid my_error_exit (j_common_ptr cinfo)\n{\n  char buffer[JMSG_LENGTH_MAX];\n\n  (*cinfo->err->format_message) (cinfo, buffer);\n  FatalError(buffer);\n}",
          "fn_code_pos": [
            [
              75,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "my_error_exit",
            "parameters": {
              "cinfo": "j_common_ptr"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool IsITUFax(jpeg_saved_marker_ptr ptr)\n{\n    while (ptr)\n    {\n        if (ptr -> marker == (JPEG_APP0 + 1) && ptr -> data_length > 5) {\n\n            const char* data = (const char*) ptr -> data;\n\n            if (strcmp(data, \"G3FAX\") == 0) return TRUE;\n        }\n\n        ptr = ptr -> next;\n    }\n\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              110,
              0
            ],
            [
              126,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsITUFax",
            "parameters": {
              "ptr": "jpeg_saved_marker_ptr"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid SetITUFax(j_compress_ptr cinfo)\n{\n    unsigned char Marker[] = \"G3FAX\\x00\\0x07\\xCA\\x00\\xC8\";\n\n    jpeg_write_marker(cinfo, (JPEG_APP0 + 1), Marker, 10);\n}",
          "fn_code_pos": [
            [
              129,
              0
            ],
            [
              135,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetITUFax",
            "parameters": {
              "cinfo": "j_compress_ptr"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid ITU2Lab(const cmsUInt16Number In[3], cmsCIELab* Lab)\n{\n    Lab -> L = (double) In[0] / 655.35;\n    Lab -> a = (double) 170.* (In[1] - 32768.) / 65535.;\n    Lab -> b = (double) 200.* (In[2] - 24576.) / 65535.;\n}",
          "fn_code_pos": [
            [
              151,
              0
            ],
            [
              157,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ITU2Lab",
            "parameters": {
              "In": "cmsUInt16Number",
              "Lab": "cmsCIELab"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Lab2ITU(const cmsCIELab* Lab, cmsUInt16Number Out[3])\n{\n    Out[0] = (cmsUInt16Number) floor((double) (Lab -> L / 100.)* 65535. );\n    Out[1] = (cmsUInt16Number) floor((double) (Lab -> a / 170.)* 65535. + 32768. );\n    Out[2] = (cmsUInt16Number) floor((double) (Lab -> b / 200.)* 65535. + 24576. );\n}",
          "fn_code_pos": [
            [
              159,
              0
            ],
            [
              165,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Lab2ITU",
            "parameters": {
              "Lab": "cmsCIELab",
              "Out": "cmsUInt16Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nint PCS2ITU(register const cmsUInt16Number In[], register cmsUInt16Number Out[], register void*  Cargo)\n{\n    cmsCIELab Lab;\n\n    cmsLabEncoded2Float(&Lab, In);\n    cmsDesaturateLab(&Lab, 85, -85, 125, -75);    // This function does the necessary gamut remapping\n    Lab2ITU(&Lab, Out);\n    return TRUE;\n\n    UTILS_UNUSED_PARAMETER(Cargo);\n}",
          "fn_code_pos": [
            [
              177,
              0
            ],
            [
              188,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCS2ITU",
            "parameters": {
              "In": "cmsUInt16Number",
              "Out": "cmsUInt16Number",
              "Cargo": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint ITU2PCS( register const cmsUInt16Number In[], register cmsUInt16Number Out[], register void*  Cargo)\n{\n    cmsCIELab Lab;\n\n    ITU2Lab(In, &Lab);\n    cmsFloat2LabEncoded(Out, &Lab);\n    return TRUE;\n\n    UTILS_UNUSED_PARAMETER(Cargo);\n}",
          "fn_code_pos": [
            [
              191,
              0
            ],
            [
              201,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ITU2PCS",
            "parameters": {
              "In": "cmsUInt16Number",
              "Out": "cmsUInt16Number",
              "Cargo": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\ncmsHPROFILE CreateITU2PCS_ICC(void)\n{\n    cmsHPROFILE hProfile;\n    cmsPipeline* AToB0;\n    cmsStage* ColorMap;\n\n    AToB0 = cmsPipelineAlloc(0, 3, 3);\n    if (AToB0 == NULL) return NULL;\n\n    ColorMap = cmsStageAllocCLut16bit(0, GRID_POINTS, 3, 3, NULL);\n    if (ColorMap == NULL) return NULL;\n\n    cmsPipelineInsertStage(AToB0, cmsAT_BEGIN, ColorMap);\n    cmsStageSampleCLut16bit(ColorMap, ITU2PCS, NULL, 0);\n\n    hProfile = cmsCreateProfilePlaceholder(0);\n    if (hProfile == NULL) {\n        cmsPipelineFree(AToB0);\n        return NULL;\n    }\n\n    cmsWriteTag(hProfile, cmsSigAToB0Tag, AToB0);\n    cmsSetColorSpace(hProfile, cmsSigLabData);\n    cmsSetPCS(hProfile, cmsSigLabData);\n    cmsSetDeviceClass(hProfile, cmsSigColorSpaceClass);\n    cmsPipelineFree(AToB0);\n\n    return hProfile;\n}",
          "fn_code_pos": [
            [
              204,
              0
            ],
            [
              233,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CreateITU2PCS_ICC",
            "parameters": {},
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "static\ncmsHPROFILE CreatePCS2ITU_ICC(void)\n{\n    cmsHPROFILE hProfile;\n    cmsPipeline* BToA0;\n    cmsStage* ColorMap;\n\n    BToA0 = cmsPipelineAlloc(0, 3, 3);\n    if (BToA0 == NULL) return NULL;\n\n    ColorMap = cmsStageAllocCLut16bit(0, GRID_POINTS, 3, 3, NULL);\n    if (ColorMap == NULL) return NULL;\n\n    cmsPipelineInsertStage(BToA0, cmsAT_BEGIN, ColorMap);\n    cmsStageSampleCLut16bit(ColorMap, PCS2ITU, NULL, 0);\n\n    hProfile = cmsCreateProfilePlaceholder(0);\n    if (hProfile == NULL) {\n        cmsPipelineFree(BToA0);\n        return NULL;\n    }\n\n    cmsWriteTag(hProfile, cmsSigBToA0Tag, BToA0);\n    cmsSetColorSpace(hProfile, cmsSigLabData);\n    cmsSetPCS(hProfile, cmsSigLabData);\n    cmsSetDeviceClass(hProfile, cmsSigColorSpaceClass);\n\n    cmsPipelineFree(BToA0);\n\n    return hProfile;\n}",
          "fn_code_pos": [
            [
              237,
              0
            ],
            [
              267,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CreatePCS2ITU_ICC",
            "parameters": {},
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "static\ncmsBool ProcessPhotoshopAPP13(JOCTET *data, int datalen)\n{\n    int i;\n\n    for (i = 14; i < datalen; )\n    {\n        long len;\n        unsigned int type;\n\n        if (!(GETJOCTET(data[i]  ) == 0x38 &&\n              GETJOCTET(data[i+1]) == 0x42 &&\n              GETJOCTET(data[i+2]) == 0x49 &&\n              GETJOCTET(data[i+3]) == 0x4D)) break; // Not recognized\n\n        i += 4; // identifying string\n\n        type = (unsigned int) (GETJOCTET(data[i]<<8) + GETJOCTET(data[i+1]));\n\n        i += 2; // resource type\n\n        i += GETJOCTET(data[i]) + ((GETJOCTET(data[i]) & 1) ? 1 : 2);   // resource name\n\n        len = ((((GETJOCTET(data[i]<<8) + GETJOCTET(data[i+1]))<<8) +\n                         GETJOCTET(data[i+2]))<<8) + GETJOCTET(data[i+3]);\n\n        if (len < 0) return FALSE; // Keep bug hunters away\n\n        i += 4; // Size\n\n        if (type == 0x03ED && len >= 16) {\n\n            Decompressor.X_density = (UINT16) PS_FIXED_TO_FLOAT(GETJOCTET(data[i]<<8) + GETJOCTET(data[i+1]),\n                                                 GETJOCTET(data[i+2]<<8) + GETJOCTET(data[i+3]));\n            Decompressor.Y_density = (UINT16) PS_FIXED_TO_FLOAT(GETJOCTET(data[i+8]<<8) + GETJOCTET(data[i+9]),\n                                                 GETJOCTET(data[i+10]<<8) + GETJOCTET(data[i+11]));\n\n            // Set the density unit to 1 since the\n            // Vertical and Horizontal resolutions\n            // are specified in Pixels per inch\n\n            Decompressor.density_unit = 0x01;\n            return TRUE;\n\n        }\n\n        i += len + ((len & 1) ? 1 : 0);   // Alignment\n    }\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              273,
              0
            ],
            [
              322,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ProcessPhotoshopAPP13",
            "parameters": {
              "data": "JOCTET",
              "datalen": "int"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool HandlePhotoshopAPP13(jpeg_saved_marker_ptr ptr)\n{\n    while (ptr) {\n\n        if (ptr -> marker == (JPEG_APP0 + 13) && ptr -> data_length > 9)\n        {\n            JOCTET* data = ptr -> data;\n\n            if(GETJOCTET(data[0]) == 0x50 &&\n               GETJOCTET(data[1]) == 0x68 &&\n               GETJOCTET(data[2]) == 0x6F &&\n               GETJOCTET(data[3]) == 0x74 &&\n               GETJOCTET(data[4]) == 0x6F &&\n               GETJOCTET(data[5]) == 0x73 &&\n               GETJOCTET(data[6]) == 0x68 &&\n               GETJOCTET(data[7]) == 0x6F &&\n               GETJOCTET(data[8]) == 0x70) {\n\n                ProcessPhotoshopAPP13(data, ptr -> data_length);\n                return TRUE;\n            }\n        }\n\n        ptr = ptr -> next;\n    }\n\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              325,
              0
            ],
            [
              353,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HandlePhotoshopAPP13",
            "parameters": {
              "ptr": "jpeg_saved_marker_ptr"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid craftedFile(void)\n{\n    FatalError(\"Corrupted EXIF data\");\n}",
          "fn_code_pos": [
            [
              366,
              0
            ],
            [
              370,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "craftedFile",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nuint16_t read16(uint8_t* arr, size_t pos,  int swapBytes, size_t max)\n{\n    if (pos + 2 >= max)\n    {\n        craftedFile();\n        return 0;\n    }\n    else\n    {\n        uint8_t b1 = arr[pos];\n        uint8_t b2 = arr[pos + 1];\n\n        return (swapBytes) ? ((b2 << 8) | b1) : ((b1 << 8) | b2);\n    }\n}",
          "fn_code_pos": [
            [
              373,
              0
            ],
            [
              388,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read16",
            "parameters": {
              "arr": "uint8_t",
              "pos": "size_t",
              "swapBytes": "int",
              "max": "size_t"
            },
            "return_type": "uint16_t"
          }
        },
        {
          "fn_code": "static\nuint32_t read32(uint8_t* arr, size_t pos, int swapBytes, size_t max)\n{\n\n    if (pos + 4 >= max)\n    {\n        craftedFile();\n        return 0;\n    }\n    else\n    {\n        if (!swapBytes) {\n\n            return (arr[pos] << 24) | (arr[pos + 1] << 16) | (arr[pos + 2] << 8) | arr[pos + 3];\n        }\n\n        return arr[pos] | (arr[pos + 1] << 8) | (arr[pos + 2] << 16) | (arr[pos + 3] << 24); \n    }\n}",
          "fn_code_pos": [
            [
              392,
              0
            ],
            [
              410,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read32",
            "parameters": {
              "arr": "uint8_t",
              "pos": "size_t",
              "swapBytes": "int",
              "max": "size_t"
            },
            "return_type": "uint32_t"
          }
        },
        {
          "fn_code": "static\nint read_tag(uint8_t* arr, int pos,  int swapBytes, void* dest, size_t max)\n{\n        // Format should be 5 over here (rational)\n    uint32_t format = read16(arr, pos + 2, swapBytes, max);\n    // Components should be 1\n    uint32_t components = read32(arr, pos + 4, swapBytes, max);\n    // Points to the value\n    uint32_t offset;\n\n    // sanity\n    if (components != 1) return 0;\n\n    if (format == 3)\n        offset = pos + 8;\n    else\n        offset =  read32(arr, pos + 8, swapBytes, max);\n\n    switch (format) {\n\n    case 5: // Rational\n          {\n          double num = read32(arr, offset, swapBytes, max);\n          double den = read32(arr, offset + 4, swapBytes, max);\n          *(double *) dest = num / den;\n          }\n          break;\n\n    case 3: // uint 16\n        *(int*) dest = read16(arr, offset, swapBytes, max);\n        break;\n\n    default:  return 0;\n    }\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              414,
              0
            ],
            [
              450,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_tag",
            "parameters": {
              "arr": "uint8_t",
              "pos": "int",
              "swapBytes": "int",
              "dest": "void",
              "max": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\ncmsBool HandleEXIF(struct jpeg_decompress_struct* cinfo)\n{\n    jpeg_saved_marker_ptr ptr;\n    uint32_t ifd_ofs;\n    int pos = 0, swapBytes = 0;\n    uint32_t i, numEntries;\n    double XRes = -1, YRes = -1;\n    int Unit = 2; // Inches\n    \n\n    for (ptr = cinfo ->marker_list; ptr; ptr = ptr ->next) {\n\n        if ((ptr ->marker == JPEG_APP0+1) && ptr ->data_length > 6) {\n\n            JOCTET* data = ptr -> data;\n            size_t max = ptr->data_length;\n\n            if (memcmp(data, \"Exif\\0\\0\", 6) == 0) {\n\n                data += 6; // Skip EXIF marker\n\n                // 8 byte TIFF header\n                // first two determine byte order\n                pos = 0;\n                if (read16(data, pos, 0, max) == INTEL_BYTE_ORDER) {\n                    swapBytes = 1;\n                }\n\n                pos += 2;\n\n                // next two bytes are always 0x002A (TIFF version)\n                pos += 2;\n\n                // offset to Image File Directory (includes the previous 8 bytes)\n                ifd_ofs = read32(data, pos, swapBytes, max);\n\n                // Search the directory for resolution tags\n                numEntries = read16(data, ifd_ofs, swapBytes, max);\n\n                for (i=0; i < numEntries; i++) {\n\n                    uint32_t entryOffset = ifd_ofs + 2 + (12 * i);\n                    uint32_t tag = read16(data, entryOffset, swapBytes, max);\n\n                    switch (tag) {\n\n                    case RESOLUTION_UNIT:\n                        if (!read_tag(data, entryOffset, swapBytes, &Unit, max)) return FALSE;\n                        break;\n\n                    case XRESOLUTION:\n                        if (!read_tag(data, entryOffset, swapBytes, &XRes, max)) return FALSE;\n                        break;\n\n                    case YRESOLUTION:\n                        if (!read_tag(data, entryOffset, swapBytes, &YRes, max)) return FALSE;\n                        break;\n\n                    default:;\n                    }\n\n                }\n\n                // Proceed if all found\n\n                if (XRes != -1 && YRes != -1)\n                {\n\n                    // 1 = None\n                    // 2 = inches\n                    // 3 = cm\n\n                    switch (Unit) {\n\n                    case 2:\n\n                        cinfo ->X_density = (UINT16) floor(XRes + 0.5);\n                        cinfo ->Y_density = (UINT16) floor(YRes + 0.5);\n                        break;\n\n                    case 1:\n\n                        cinfo ->X_density = (UINT16) floor(XRes * 2.54 + 0.5);\n                        cinfo ->Y_density = (UINT16) floor(YRes * 2.54 + 0.5);\n                        break;\n\n                    default: return FALSE;\n                    }\n\n                    cinfo ->density_unit = 1;  /* 1 for dots/inch, or 2 for dots/cm.*/\n\n                }\n\n\n            }\n        }\n    }\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              455,
              0
            ],
            [
              554,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HandleEXIF",
            "parameters": {
              "cinfo": "struct jpeg_decompress_struct"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool OpenInput(const char* FileName)\n{\n    int m;\n\n    lIsITUFax = FALSE;\n    InFile  = fopen(FileName, \"rb\");\n    if (InFile == NULL) {\n        FatalError(\"Cannot open '%s'\", FileName);\n    }\n\n    // Now we can initialize the JPEG decompression object.\n    Decompressor.err                 = jpeg_std_error(&ErrorHandler.pub);\n    ErrorHandler.pub.error_exit      = my_error_exit;\n    ErrorHandler.pub.output_message  = my_error_exit;\n\n    jpeg_create_decompress(&Decompressor);\n    jpeg_stdio_src(&Decompressor, InFile);\n\n    for (m = 0; m < 16; m++)\n        jpeg_save_markers(&Decompressor, JPEG_APP0 + m, 0xFFFF);\n\n    // setup_read_icc_profile(&Decompressor);\n\n    fseek(InFile, 0, SEEK_SET);\n    jpeg_read_header(&Decompressor, TRUE);\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              557,
              0
            ],
            [
              585,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OpenInput",
            "parameters": {
              "FileName": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool OpenOutput(const char* FileName)\n{\n\n    OutFile = fopen(FileName, \"wb\");\n    if (OutFile == NULL) {\n        FatalError(\"Cannot create '%s'\", FileName);\n\n    }\n\n    Compressor.err                   = jpeg_std_error(&ErrorHandler.pub);\n    ErrorHandler.pub.error_exit      = my_error_exit;\n    ErrorHandler.pub.output_message  = my_error_exit;\n\n    Compressor.input_components = Compressor.num_components = 4;\n\n    jpeg_create_compress(&Compressor);\n    jpeg_stdio_dest(&Compressor, OutFile);\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              588,
              0
            ],
            [
              607,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OpenOutput",
            "parameters": {
              "FileName": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool Done(void)\n{\n    jpeg_destroy_decompress(&Decompressor);\n    jpeg_destroy_compress(&Compressor);\n    return fclose(InFile) + fclose(OutFile);\n\n}",
          "fn_code_pos": [
            [
              609,
              0
            ],
            [
              616,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Done",
            "parameters": {},
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number GetInputPixelType(void)\n{\n     int space, bps, extra, ColorChannels, Flavor;\n\n     lIsITUFax         = IsITUFax(Decompressor.marker_list);\n     lIsPhotoshopApp13 = HandlePhotoshopAPP13(Decompressor.marker_list);\n     lIsEXIF           = HandleEXIF(&Decompressor);\n\n     ColorChannels = Decompressor.num_components;\n     extra  = 0;            // Alpha = None\n     bps    = 1;            // 8 bits\n     Flavor = 0;            // Vanilla\n\n     if (lIsITUFax) {\n\n        space = PT_Lab;\n        Decompressor.out_color_space = JCS_YCbCr;  // Fake to don't touch\n     }\n     else\n     switch (Decompressor.jpeg_color_space) {\n\n     case JCS_GRAYSCALE:        // monochrome\n              space = PT_GRAY;\n              Decompressor.out_color_space = JCS_GRAYSCALE;\n              break;\n\n     case JCS_RGB:             // red/green/blue\n              space = PT_RGB;\n              Decompressor.out_color_space = JCS_RGB;\n              break;\n\n     case JCS_YCbCr:               // Y/Cb/Cr (also known as YUV)\n              space = PT_RGB;      // Let IJG code to do the conversion\n              Decompressor.out_color_space = JCS_RGB;\n              break;\n\n     case JCS_CMYK:            // C/M/Y/K\n              space = PT_CMYK;\n              Decompressor.out_color_space = JCS_CMYK;\n              if (Decompressor.saw_Adobe_marker)            // Adobe keeps CMYK inverted, so change flavor\n                                Flavor = 1;                 // from vanilla to chocolate\n              break;\n\n     case JCS_YCCK:            // Y/Cb/Cr/K\n              space = PT_CMYK;\n              Decompressor.out_color_space = JCS_CMYK;\n              if (Decompressor.saw_Adobe_marker)            // ditto\n                                Flavor = 1;\n              break;\n\n     default:\n              FatalError(\"Unsupported color space (0x%x)\", Decompressor.jpeg_color_space);\n              return 0;\n     }\n\n     return (EXTRA_SH(extra)|CHANNELS_SH(ColorChannels)|BYTES_SH(bps)|COLORSPACE_SH(space)|FLAVOR_SH(Flavor));\n}",
          "fn_code_pos": [
            [
              621,
              0
            ],
            [
              678,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetInputPixelType",
            "parameters": {},
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number ComputeOutputFormatDescriptor(cmsUInt32Number dwInput, int OutColorSpace)\n{\n    int IsPlanar  = T_PLANAR(dwInput);\n    int Channels  = 0;\n    int Flavor    = 0;\n\n    switch (OutColorSpace) {\n\n   case PT_GRAY:\n       Channels = 1;\n       break;\n   case PT_RGB:\n   case PT_CMY:\n   case PT_Lab:\n   case PT_YUV:\n   case PT_YCbCr:\n       Channels = 3;\n       break;\n\n   case PT_CMYK:\n       if (Compressor.write_Adobe_marker)   // Adobe keeps CMYK inverted, so change flavor to chocolate\n           Flavor = 1;\n       Channels = 4;\n       break;\n   default:\n       FatalError(\"Unsupported output color space\");\n    }\n\n    return (COLORSPACE_SH(OutColorSpace)|PLANAR_SH(IsPlanar)|CHANNELS_SH(Channels)|BYTES_SH(1)|FLAVOR_SH(Flavor));\n}",
          "fn_code_pos": [
            [
              682,
              0
            ],
            [
              712,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComputeOutputFormatDescriptor",
            "parameters": {
              "dwInput": "cmsUInt32Number",
              "OutColorSpace": "int"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\nint GetProfileColorSpace(cmsHPROFILE hProfile)\n{\n    cmsColorSpaceSignature ProfileSpace = cmsGetColorSpace(hProfile);\n\n    return _cmsLCMScolorSpace(ProfileSpace);\n}",
          "fn_code_pos": [
            [
              716,
              0
            ],
            [
              722,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetProfileColorSpace",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint GetDevicelinkColorSpace(cmsHPROFILE hProfile)\n{\n    cmsColorSpaceSignature ProfileSpace = cmsGetPCS(hProfile);\n\n    return _cmsLCMScolorSpace(ProfileSpace);\n}",
          "fn_code_pos": [
            [
              724,
              0
            ],
            [
              730,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetDevicelinkColorSpace",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nvoid jcopy_markers_execute(j_decompress_ptr srcinfo, j_compress_ptr dstinfo)\n{\n  jpeg_saved_marker_ptr marker;\n\n  /* In the current implementation, we don't actually need to examine the\n   * option flag here; we just copy everything that got saved.\n   * But to avoid confusion, we do not output JFIF and Adobe APP14 markers\n   * if the encoder library already wrote one.\n   */\n  for (marker = srcinfo->marker_list; marker != NULL; marker = marker->next) {\n\n    if (dstinfo->write_JFIF_header &&\n        marker->marker == JPEG_APP0 &&\n        marker->data_length >= 5 &&\n        GETJOCTET(marker->data[0]) == 0x4A &&\n        GETJOCTET(marker->data[1]) == 0x46 &&\n        GETJOCTET(marker->data[2]) == 0x49 &&\n        GETJOCTET(marker->data[3]) == 0x46 &&\n        GETJOCTET(marker->data[4]) == 0)\n                          continue;         /* reject duplicate JFIF */\n\n    if (dstinfo->write_Adobe_marker &&\n        marker->marker == JPEG_APP0+14 &&\n        marker->data_length >= 5 &&\n        GETJOCTET(marker->data[0]) == 0x41 &&\n        GETJOCTET(marker->data[1]) == 0x64 &&\n        GETJOCTET(marker->data[2]) == 0x6F &&\n        GETJOCTET(marker->data[3]) == 0x62 &&\n        GETJOCTET(marker->data[4]) == 0x65)\n                         continue;         /* reject duplicate Adobe */\n\n     jpeg_write_marker(dstinfo, marker->marker,\n                       marker->data, marker->data_length);\n  }\n}",
          "fn_code_pos": [
            [
              735,
              0
            ],
            [
              770,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jcopy_markers_execute",
            "parameters": {
              "srcinfo": "j_decompress_ptr",
              "dstinfo": "j_compress_ptr"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid WriteOutputFields(int OutputColorSpace)\n{\n    J_COLOR_SPACE in_space, jpeg_space;\n    int components;\n\n    switch (OutputColorSpace) {\n\n    case PT_GRAY: in_space = jpeg_space = JCS_GRAYSCALE;\n                  components = 1;\n                  break;\n\n    case PT_RGB:  in_space = JCS_RGB;\n                  jpeg_space = JCS_YCbCr;\n                  components = 3;\n                  break;       // red/green/blue\n\n    case PT_YCbCr: in_space = jpeg_space = JCS_YCbCr;\n                   components = 3;\n                   break;               // Y/Cb/Cr (also known as YUV)\n\n    case PT_CMYK: in_space = JCS_CMYK;\n                  jpeg_space = JCS_YCCK;\n                  components = 4;\n                  break;      // C/M/Y/components\n\n    case PT_Lab:  in_space = jpeg_space = JCS_YCbCr;\n                  components = 3;\n                  break;                // Fake to don't touch\n    default:\n                 FatalError(\"Unsupported output color space\");\n                 return;\n    }\n\n\n    if (jpegQuality >= 100) {\n\n     // avoid destructive conversion when asking for lossless compression\n        jpeg_space = in_space;\n    }\n\n    Compressor.in_color_space =  in_space;\n    Compressor.jpeg_color_space = jpeg_space;\n    Compressor.input_components = Compressor.num_components = components;\n    jpeg_set_defaults(&Compressor);\n    jpeg_set_colorspace(&Compressor, jpeg_space);\n\n\n    // Make sure to pass resolution through\n    if (OutputColorSpace == PT_CMYK)\n        Compressor.write_JFIF_header = 1;\n\n    // Avoid subsampling on high quality factor\n    jpeg_set_quality(&Compressor, jpegQuality, 1);\n    if (jpegQuality >= 70) {\n\n      int i;\n      for(i=0; i < Compressor.num_components; i++) {\n\n            Compressor.comp_info[i].h_samp_factor = 1;\n            Compressor.comp_info[i].v_samp_factor = 1;\n      }\n\n    }\n\n}",
          "fn_code_pos": [
            [
              772,
              0
            ],
            [
              837,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteOutputFields",
            "parameters": {
              "OutputColorSpace": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid DoEmbedProfile(const char* ProfileFile)\n{\n    FILE* f;\n    size_t size, EmbedLen;\n    cmsUInt8Number* EmbedBuffer;\n\n        f = fopen(ProfileFile, \"rb\");\n        if (f == NULL) return;\n\n        size = cmsfilelength(f);\n        EmbedBuffer = (cmsUInt8Number*) malloc(size + 1);\n        EmbedLen = fread(EmbedBuffer, 1, size, f);\n        fclose(f);\n        EmbedBuffer[EmbedLen] = 0;\n\n        write_icc_profile (&Compressor, EmbedBuffer, (unsigned int) EmbedLen);\n        free(EmbedBuffer);\n}",
          "fn_code_pos": [
            [
              840,
              0
            ],
            [
              858,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DoEmbedProfile",
            "parameters": {
              "ProfileFile": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nint DoTransform(cmsHTRANSFORM hXForm, int OutputColorSpace)\n{\n    JSAMPROW ScanLineIn;\n    JSAMPROW ScanLineOut;\n\n\n       //Preserve resolution values from the original\n       // (Thanks to Robert Bergs for finding out this bug)\n       Compressor.density_unit = Decompressor.density_unit;\n       Compressor.X_density    = Decompressor.X_density;\n       Compressor.Y_density    = Decompressor.Y_density;\n\n      //  Compressor.write_JFIF_header = 1;\n\n       jpeg_start_decompress(&Decompressor);\n       jpeg_start_compress(&Compressor, TRUE);\n\n        if (OutputColorSpace == PT_Lab)\n            SetITUFax(&Compressor);\n\n       // Embed the profile if needed\n       if (EmbedProfile && cOutProf)\n           DoEmbedProfile(cOutProf);\n\n       ScanLineIn  = (JSAMPROW) malloc((size_t) Decompressor.output_width * Decompressor.num_components);\n       ScanLineOut = (JSAMPROW) malloc((size_t) Compressor.image_width * Compressor.num_components);\n\n       while (Decompressor.output_scanline <\n                            Decompressor.output_height) {\n\n       jpeg_read_scanlines(&Decompressor, &ScanLineIn, 1);\n\n       cmsDoTransform(hXForm, ScanLineIn, ScanLineOut, Decompressor.output_width);\n\n       jpeg_write_scanlines(&Compressor, &ScanLineOut, 1);\n       }\n\n       free(ScanLineIn);\n       free(ScanLineOut);\n\n       jpeg_finish_decompress(&Decompressor);\n       jpeg_finish_compress(&Compressor);\n\n       return TRUE;\n}",
          "fn_code_pos": [
            [
              862,
              0
            ],
            [
              907,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DoTransform",
            "parameters": {
              "hXForm": "cmsHTRANSFORM",
              "OutputColorSpace": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint TransformImage(char *cDefInpProf, char *cOutputProf)\n{\n       cmsHPROFILE hIn, hOut, hProof;\n       cmsHTRANSFORM xform;\n       cmsUInt32Number wInput, wOutput;\n       int OutputColorSpace;\n       cmsUInt32Number dwFlags = 0;\n       cmsUInt32Number EmbedLen;\n       cmsUInt8Number* EmbedBuffer;\n\n\n       cmsSetAdaptationState(ObserverAdaptationState);\n\n       if (BlackPointCompensation) {\n\n            dwFlags |= cmsFLAGS_BLACKPOINTCOMPENSATION;\n       }\n\n\n       switch (PrecalcMode) {\n\n       case 0: dwFlags |= cmsFLAGS_NOOPTIMIZE; break;\n       case 2: dwFlags |= cmsFLAGS_HIGHRESPRECALC; break;\n       case 3: dwFlags |= cmsFLAGS_LOWRESPRECALC; break;\n       default:;\n       }\n\n\n       if (GamutCheck) {\n            dwFlags |= cmsFLAGS_GAMUTCHECK;\n            cmsSetAlarmCodes(Alarm);\n       }\n\n       // Take input color space\n       wInput = GetInputPixelType();\n\n        if (lIsDeviceLink) {\n\n            hIn = cmsOpenProfileFromFile(cDefInpProf, \"r\");\n            hOut = NULL;\n            hProof = NULL;\n       }\n        else {\n\n        if (!IgnoreEmbedded && read_icc_profile(&Decompressor, &EmbedBuffer, &EmbedLen))\n        {\n              hIn = cmsOpenProfileFromMem(EmbedBuffer, EmbedLen);\n\n               if (Verbose) {\n\n                  fprintf(stdout, \" (Embedded profile found)\\n\");\n                  PrintProfileInformation(hIn);\n                  fflush(stdout);\n              }\n\n               if (hIn != NULL && SaveEmbedded != NULL)\n                          SaveMemoryBlock(EmbedBuffer, EmbedLen, SaveEmbedded);\n\n              free(EmbedBuffer);\n        }\n        else\n        {\n            // Default for ITU/Fax\n            if (cDefInpProf == NULL && T_COLORSPACE(wInput) == PT_Lab)\n                cDefInpProf = \"*Lab\";\n\n            if (cDefInpProf != NULL && cmsstrcasecmp(cDefInpProf, \"*lab\") == 0)\n                hIn = CreateITU2PCS_ICC();\n            else\n                hIn = OpenStockProfile(0, cDefInpProf);\n       }\n\n        if (cOutputProf != NULL && cmsstrcasecmp(cOutputProf, \"*lab\") == 0)\n            hOut = CreatePCS2ITU_ICC();\n        else\n        hOut = OpenStockProfile(0, cOutputProf);\n\n       hProof = NULL;\n       if (cProofing != NULL) {\n\n           hProof = OpenStockProfile(0, cProofing);\n           if (hProof == NULL) {\n            FatalError(\"Proofing profile couldn't be read.\");\n           }\n           dwFlags |= cmsFLAGS_SOFTPROOFING;\n          }\n       }\n\n        if (!hIn)\n            FatalError(\"Input profile couldn't be read.\");\n        if (!lIsDeviceLink && !hOut)\n            FatalError(\"Output profile couldn't be read.\");\n\n       // Assure both, input profile and input JPEG are on same colorspace\n       if (cmsGetColorSpace(hIn) != _cmsICCcolorSpace(T_COLORSPACE(wInput)))\n              FatalError(\"Input profile is not operating in proper color space\");\n\n\n       // Output colorspace is given by output profile\n\n        if (lIsDeviceLink) {\n            OutputColorSpace = GetDevicelinkColorSpace(hIn);\n        }\n        else {\n            OutputColorSpace = GetProfileColorSpace(hOut);\n        }\n\n       jpeg_copy_critical_parameters(&Decompressor, &Compressor);\n\n       WriteOutputFields(OutputColorSpace);\n\n       wOutput      = ComputeOutputFormatDescriptor(wInput, OutputColorSpace);\n\n\n       xform = cmsCreateProofingTransform(hIn, wInput,\n                                          hOut, wOutput,\n                                          hProof, Intent,\n                                          ProofingIntent, dwFlags);\n       if (xform == NULL)\n                 FatalError(\"Cannot transform by using the profiles\");\n\n       DoTransform(xform, OutputColorSpace);\n\n\n       jcopy_markers_execute(&Decompressor, &Compressor);\n\n       cmsDeleteTransform(xform);\n       cmsCloseProfile(hIn);\n       cmsCloseProfile(hOut);\n       if (hProof) cmsCloseProfile(hProof);\n\n       return 1;\n}",
          "fn_code_pos": [
            [
              913,
              0
            ],
            [
              1046,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TransformImage",
            "parameters": {
              "cDefInpProf": "char",
              "cOutputProf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nvoid Help(int level)\n{\n\n    UTILS_UNUSED_PARAMETER(level);\n\n    fprintf(stderr, \"usage: jpgicc [flags] input.jpg output.jpg\\n\");\n\n    fprintf(stderr, \"\\nflags:\\n\\n\");\n    fprintf(stderr, \"-v - Verbose\\n\");\n    fprintf(stderr, \"-i<profile> - Input profile (defaults to sRGB)\\n\");\n    fprintf(stderr, \"-o<profile> - Output profile (defaults to sRGB)\\n\");\n\n    PrintBuiltins();\n\n    PrintRenderingIntents();\n\n\n    fprintf(stderr, \"-b - Black point compensation\\n\");\n    fprintf(stderr, \"-d<0..1> - Observer adaptation state (abs.col. only)\\n\");\n    fprintf(stderr, \"-n - Ignore embedded profile\\n\");\n    fprintf(stderr, \"-e - Embed destination profile\\n\");\n    fprintf(stderr, \"-s<new profile> - Save embedded profile as <new profile>\\n\");\n\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"-c<0,1,2,3> - Precalculates transform (0=Off, 1=Normal, 2=Hi-res, 3=LoRes) [defaults to 1]\\n\");\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"-p<profile> - Soft proof profile\\n\");\n    fprintf(stderr, \"-m<0,1,2,3> - SoftProof intent\\n\");\n    fprintf(stderr, \"-g - Marks out-of-gamut colors on softproof\\n\");\n    fprintf(stderr, \"-!<r>,<g>,<b> - Out-of-gamut marker channel values\\n\");\n\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"-q<0..100> - Output JPEG quality\\n\");\n\n    fprintf(stderr, \"Examples:\\n\\n\"\n        \"To color correct from scanner to sRGB:\\n\"\n        \"\\tjpgicc -iscanner.icm in.jpg out.jpg\\n\"\n        \"To convert from monitor1 to monitor2:\\n\"\n        \"\\tjpgicc -imon1.icm -omon2.icm in.jpg out.jpg\\n\"\n        \"To make a CMYK separation:\\n\"\n        \"\\tjpgicc -oprinter.icm inrgb.jpg outcmyk.jpg\\n\"\n        \"To recover sRGB from a CMYK separation:\\n\"\n        \"\\tjpgicc -iprinter.icm incmyk.jpg outrgb.jpg\\n\"\n        \"To convert from CIELab ITU/Fax JPEG to sRGB\\n\"\n        \"\\tjpgicc in.jpg out.jpg\\n\\n\");\n\n\n    fprintf(stderr, \"This program is intended to be a demo of the Little CMS\\n\"\n        \"color engine. Both lcms and this program are open source.\\n\"\n        \"You can obtain both in source code at https://www.littlecms.com\\n\"\n        \"For suggestions, comments, bug reports etc. send mail to\\n\"\n        \"info@littlecms.com\\n\\n\");\n\n    exit(0);\n}",
          "fn_code_pos": [
            [
              1049,
              0
            ],
            [
              1106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Help",
            "parameters": {
              "level": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid HandleSwitches(int argc, char *argv[])\n{\n    int s;\n\n    while ((s=xgetopt(argc,argv,\"bBnNvVGgh:H:i:I:o:O:P:p:t:T:c:C:Q:q:M:m:L:l:eEs:S:!:D:d:-:\")) != EOF) {\n\n        switch (s)\n        {\n\n        case '-':\n            if (strcmp(xoptarg, \"help\") == 0)\n            {\n                Help(0);\n            }\n            else\n            {\n                FatalError(\"Unknown option - run without args to see valid ones.\\n\");\n            }\n            break;\n\n        case 'b':\n        case 'B':\n            BlackPointCompensation = TRUE;\n            break;\n\n        case 'd':\n        case 'D': ObserverAdaptationState = atof(xoptarg);\n            if (ObserverAdaptationState < 0 ||\n                ObserverAdaptationState > 1.0)\n                FatalError(\"Adaptation state should be 0..1\");\n            break;\n\n        case 'v':\n        case 'V':\n            Verbose = TRUE;\n            break;\n\n        case 'i':\n        case 'I':\n            if (lIsDeviceLink)\n                FatalError(\"Device-link already specified\");\n\n            cInpProf = xoptarg;\n            break;\n\n        case 'o':\n        case 'O':\n            if (lIsDeviceLink)\n                FatalError(\"Device-link already specified\");\n\n            cOutProf = xoptarg;\n            break;\n\n        case 'l':\n        case 'L':\n            if (cInpProf != NULL || cOutProf != NULL)\n                FatalError(\"input/output profiles already specified\");\n\n            cInpProf = xoptarg;\n            lIsDeviceLink = TRUE;\n            break;\n\n        case 'p':\n        case 'P':\n            cProofing = xoptarg;\n            break;\n\n        case 't':\n        case 'T':\n            Intent = atoi(xoptarg);\n            break;\n\n        case 'N':\n        case 'n':\n            IgnoreEmbedded = TRUE;\n            break;\n\n        case 'e':\n        case 'E':\n            EmbedProfile = TRUE;\n            break;\n\n\n        case 'g':\n        case 'G':\n            GamutCheck = TRUE;\n            break;\n\n        case 'c':\n        case 'C':\n            PrecalcMode = atoi(xoptarg);\n            if (PrecalcMode < 0 || PrecalcMode > 2)\n                FatalError(\"Unknown precalc mode '%d'\", PrecalcMode);\n            break;\n\n        case 'H':\n        case 'h':  {\n\n            int a =  atoi(xoptarg);\n            Help(a);\n                   }\n            break;\n\n        case 'q':\n        case 'Q':\n            jpegQuality = atoi(xoptarg);\n            if (jpegQuality > 100) jpegQuality = 100;\n            if (jpegQuality < 0)   jpegQuality = 0;\n            break;\n\n        case 'm':\n        case 'M':\n            ProofingIntent = atoi(xoptarg);\n            break;\n\n        case 's':\n        case 'S': SaveEmbedded = xoptarg;\n            break;\n\n        case '!':\n            if (sscanf(xoptarg, \"%hu,%hu,%hu\", &Alarm[0], &Alarm[1], &Alarm[2]) == 3) {\n                int i;\n                for (i=0; i < 3; i++) {\n                    Alarm[i] = (Alarm[i] << 8) | Alarm[i];\n                }\n            }\n            break;\n\n        default:\n\n            FatalError(\"Unknown option - run without args to see valid ones\");\n        }\n\n    }\n}",
          "fn_code_pos": [
            [
              1111,
              0
            ],
            [
              1246,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HandleSwitches",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(int argc, char* argv[])\n{\n\n    fprintf(stderr, \"Little CMS ICC profile applier for JPEG - v3.4 [LittleCMS %2.2f]\\n\\n\", cmsGetEncodedCMMversion() / 1000.0);\n    fprintf(stderr, \"Copyright (c) 1998-2024 Marti Maria Saguer. See COPYING file for details.\\n\");\n    fflush(stderr);\n\n    InitUtils(\"jpgicc\");\n\n    HandleSwitches(argc, argv);\n\n    if ((argc - xoptind) != 2) {\n        Help(0);\n    }\n\n    OpenInput(argv[xoptind]);\n    OpenOutput(argv[xoptind+1]);\n\n    TransformImage(cInpProf, cOutProf);\n\n\n    if (Verbose) { fprintf(stdout, \"\\n\"); fflush(stdout); }\n\n    Done();\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              1249,
              0
            ],
            [
              1275,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct my_error_mgr {\n\n    struct  jpeg_error_mgr pub;   // \"public\" fields\n    void*   Cargo;                // \"private\" fields\n\n}",
          {
            "pub": "struct  jpeg_error_mgr",
            "*   Cargo": "void"
          },
          "my_error_mgr",
          [
            64,
            7
          ],
          [
            69,
            1
          ]
        ],
        [
          "struct jpeg_decompress_struct",
          {},
          "",
          [
            60,
            7
          ],
          [
            60,
            36
          ]
        ],
        [
          "struct jpeg_compress_struct",
          {},
          "",
          [
            61,
            7
          ],
          [
            61,
            34
          ]
        ],
        [
          "struct my_error_mgr {\n\n    struct  jpeg_error_mgr pub;   // \"public\" fields\n    void*   Cargo;                // \"private\" fields\n\n}",
          {
            "pub": "struct  jpeg_error_mgr",
            "*   Cargo": "void"
          },
          "my_error_mgr",
          [
            64,
            7
          ],
          [
            69,
            1
          ]
        ],
        [
          "struct  jpeg_error_mgr",
          {},
          "",
          [
            66,
            4
          ],
          [
            66,
            26
          ]
        ],
        [
          "struct jpeg_decompress_struct",
          {},
          "",
          [
            456,
            19
          ],
          [
            456,
            48
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"utils.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"jpeglib.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"iccjpeg.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmscnvrt.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nvoid DupPluginIntentsList(struct _cmsContext_struct* ctx, \n                                               const struct _cmsContext_struct* src)\n{\n   _cmsIntentsPluginChunkType newHead = { NULL };\n   cmsIntentsList*  entry;\n   cmsIntentsList*  Anterior = NULL;\n   _cmsIntentsPluginChunkType* head = (_cmsIntentsPluginChunkType*) src->chunks[IntentPlugin];\n\n    // Walk the list copying all nodes\n   for (entry = head->Intents;\n        entry != NULL;\n        entry = entry ->Next) {\n\n            cmsIntentsList *newEntry = ( cmsIntentsList *) _cmsSubAllocDup(ctx ->MemPool, entry, sizeof(cmsIntentsList));\n   \n            if (newEntry == NULL) \n                return;\n\n            // We want to keep the linked list order, so this is a little bit tricky\n            newEntry -> Next = NULL;\n            if (Anterior)\n                Anterior -> Next = newEntry;\n     \n            Anterior = newEntry;\n\n            if (newHead.Intents == NULL)\n                newHead.Intents = newEntry;\n    }\n\n  ctx ->chunks[IntentPlugin] = _cmsSubAllocDup(ctx->MemPool, &newHead, sizeof(_cmsIntentsPluginChunkType));\n}",
          "fn_code_pos": [
            [
              100,
              0
            ],
            [
              131,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DupPluginIntentsList",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void  _cmsAllocIntentsPluginChunk(struct _cmsContext_struct* ctx, \n                                         const struct _cmsContext_struct* src)\n{\n    if (src != NULL) {\n\n        // Copy all linked list\n        DupPluginIntentsList(ctx, src);\n    }\n    else {\n        static _cmsIntentsPluginChunkType IntentsPluginChunkType = { NULL };\n        ctx ->chunks[IntentPlugin] = _cmsSubAllocDup(ctx ->MemPool, &IntentsPluginChunkType, sizeof(_cmsIntentsPluginChunkType));\n    }\n}",
          "fn_code_pos": [
            [
              133,
              0
            ],
            [
              145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocIntentsPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsIntentsList* SearchIntent(cmsContext ContextID, cmsUInt32Number Intent)\n{\n    _cmsIntentsPluginChunkType* ctx = ( _cmsIntentsPluginChunkType*) _cmsContextGetClientChunk(ContextID, IntentPlugin);\n    cmsIntentsList* pt;\n\n    for (pt = ctx -> Intents; pt != NULL; pt = pt -> Next)\n        if (pt ->Intent == Intent) return pt;\n\n    for (pt = DefaultIntents; pt != NULL; pt = pt -> Next)\n        if (pt ->Intent == Intent) return pt;\n\n    return NULL;\n}",
          "fn_code_pos": [
            [
              149,
              0
            ],
            [
              162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SearchIntent",
            "parameters": {
              "ContextID": "cmsContext",
              "Intent": "cmsUInt32Number"
            },
            "return_type": "cmsIntentsList"
          }
        },
        {
          "fn_code": "static\nvoid ComputeBlackPointCompensation(const cmsCIEXYZ* BlackPointIn,\n                                   const cmsCIEXYZ* BlackPointOut,\n                                   cmsMAT3* m, cmsVEC3* off)\n{\n  cmsFloat64Number ax, ay, az, bx, by, bz, tx, ty, tz;\n\n   // Now we need to compute a matrix plus an offset m and of such of\n   // [m]*bpin + off = bpout\n   // [m]*D50  + off = D50\n   //\n   // This is a linear scaling in the form ax+b, where\n   // a = (bpout - D50) / (bpin - D50)\n   // b = - D50* (bpout - bpin) / (bpin - D50)\n\n   tx = BlackPointIn->X - cmsD50_XYZ()->X;\n   ty = BlackPointIn->Y - cmsD50_XYZ()->Y;\n   tz = BlackPointIn->Z - cmsD50_XYZ()->Z;\n\n   ax = (BlackPointOut->X - cmsD50_XYZ()->X) / tx;\n   ay = (BlackPointOut->Y - cmsD50_XYZ()->Y) / ty;\n   az = (BlackPointOut->Z - cmsD50_XYZ()->Z) / tz;\n\n   bx = - cmsD50_XYZ()-> X * (BlackPointOut->X - BlackPointIn->X) / tx;\n   by = - cmsD50_XYZ()-> Y * (BlackPointOut->Y - BlackPointIn->Y) / ty;\n   bz = - cmsD50_XYZ()-> Z * (BlackPointOut->Z - BlackPointIn->Z) / tz;\n\n   _cmsVEC3init(&m ->v[0], ax, 0,  0);\n   _cmsVEC3init(&m ->v[1], 0, ay,  0);\n   _cmsVEC3init(&m ->v[2], 0,  0,  az);\n   _cmsVEC3init(off, bx, by, bz);\n\n}",
          "fn_code_pos": [
            [
              167,
              0
            ],
            [
              199,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComputeBlackPointCompensation",
            "parameters": {
              "BlackPointIn": "cmsCIEXYZ",
              "BlackPointOut": "cmsCIEXYZ",
              "m": "cmsMAT3",
              "off": "cmsVEC3"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number CHAD2Temp(const cmsMAT3* Chad)\n{\n    // Convert D50 across inverse CHAD to get the absolute white point\n    cmsVEC3 d, s;\n    cmsCIEXYZ Dest;\n    cmsCIExyY DestChromaticity;\n    cmsFloat64Number TempK;\n    cmsMAT3 m1, m2;\n\n    m1 = *Chad;\n    if (!_cmsMAT3inverse(&m1, &m2)) return FALSE;\n\n    s.n[VX] = cmsD50_XYZ() -> X;\n    s.n[VY] = cmsD50_XYZ() -> Y;\n    s.n[VZ] = cmsD50_XYZ() -> Z;\n\n    _cmsMAT3eval(&d, &m2, &s);\n\n    Dest.X = d.n[VX];\n    Dest.Y = d.n[VY];\n    Dest.Z = d.n[VZ];\n\n    cmsXYZ2xyY(&DestChromaticity, &Dest);\n\n    if (!cmsTempFromWhitePoint(&TempK, &DestChromaticity))\n        return -1.0;\n\n    return TempK;\n}",
          "fn_code_pos": [
            [
              203,
              0
            ],
            [
              232,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CHAD2Temp",
            "parameters": {
              "Chad": "cmsMAT3"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\nvoid Temp2CHAD(cmsMAT3* Chad, cmsFloat64Number Temp)\n{\n    cmsCIEXYZ White;\n    cmsCIExyY ChromaticityOfWhite;\n\n    cmsWhitePointFromTemp(&ChromaticityOfWhite, Temp);\n    cmsxyY2XYZ(&White, &ChromaticityOfWhite);\n    _cmsAdaptationMatrix(Chad, NULL, &White, cmsD50_XYZ());\n}",
          "fn_code_pos": [
            [
              235,
              0
            ],
            [
              244,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Temp2CHAD",
            "parameters": {
              "Chad": "cmsMAT3",
              "Temp": "cmsFloat64Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  ComputeAbsoluteIntent(cmsFloat64Number AdaptationState,\n                               const cmsCIEXYZ* WhitePointIn,\n                               const cmsMAT3* ChromaticAdaptationMatrixIn,\n                               const cmsCIEXYZ* WhitePointOut,\n                               const cmsMAT3* ChromaticAdaptationMatrixOut,\n                               cmsMAT3* m)\n{\n    cmsMAT3 Scale, m1, m2, m3, m4;\n\n    // TODO: Follow Marc Mahy's recommendation to check if CHAD is same by using M1*M2 == M2*M1. If so, do nothing.\n    // TODO: Add support for ArgyllArts tag\n\n    // Adaptation state\n    if (AdaptationState == 1.0) {\n\n        // Observer is fully adapted. Keep chromatic adaptation.\n        // That is the standard V4 behaviour\n        _cmsVEC3init(&m->v[0], WhitePointIn->X / WhitePointOut->X, 0, 0);\n        _cmsVEC3init(&m->v[1], 0, WhitePointIn->Y / WhitePointOut->Y, 0);\n        _cmsVEC3init(&m->v[2], 0, 0, WhitePointIn->Z / WhitePointOut->Z);\n\n    }\n    else  {\n\n        // Incomplete adaptation. This is an advanced feature.\n        _cmsVEC3init(&Scale.v[0], WhitePointIn->X / WhitePointOut->X, 0, 0);\n        _cmsVEC3init(&Scale.v[1], 0,  WhitePointIn->Y / WhitePointOut->Y, 0);\n        _cmsVEC3init(&Scale.v[2], 0, 0,  WhitePointIn->Z / WhitePointOut->Z);\n\n\n        if (AdaptationState == 0.0) {\n        \n            m1 = *ChromaticAdaptationMatrixOut;\n            _cmsMAT3per(&m2, &m1, &Scale);\n            // m2 holds CHAD from output white to D50 times abs. col. scaling\n\n            // Observer is not adapted, undo the chromatic adaptation\n            _cmsMAT3per(m, &m2, ChromaticAdaptationMatrixOut);\n\n            m3 = *ChromaticAdaptationMatrixIn;\n            if (!_cmsMAT3inverse(&m3, &m4)) return FALSE;\n            _cmsMAT3per(m, &m2, &m4);\n\n        } else {\n\n            cmsMAT3 MixedCHAD;\n            cmsFloat64Number TempSrc, TempDest, Temp;\n\n            m1 = *ChromaticAdaptationMatrixIn;\n            if (!_cmsMAT3inverse(&m1, &m2)) return FALSE;\n            _cmsMAT3per(&m3, &m2, &Scale);\n            // m3 holds CHAD from input white to D50 times abs. col. scaling\n\n            TempSrc  = CHAD2Temp(ChromaticAdaptationMatrixIn);\n            TempDest = CHAD2Temp(ChromaticAdaptationMatrixOut);\n\n            if (TempSrc < 0.0 || TempDest < 0.0) return FALSE; // Something went wrong\n\n            if (_cmsMAT3isIdentity(&Scale) && fabs(TempSrc - TempDest) < 0.01) {\n\n                _cmsMAT3identity(m);\n                return TRUE;\n            }\n\n            Temp = (1.0 - AdaptationState) * TempDest + AdaptationState * TempSrc;\n\n            // Get a CHAD from whatever output temperature to D50. This replaces output CHAD\n            Temp2CHAD(&MixedCHAD, Temp);\n\n            _cmsMAT3per(m, &m3, &MixedCHAD);\n        }\n\n    }\n    return TRUE;\n\n}",
          "fn_code_pos": [
            [
              248,
              0
            ],
            [
              324,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComputeAbsoluteIntent",
            "parameters": {
              "AdaptationState": "cmsFloat64Number",
              "WhitePointIn": "cmsCIEXYZ",
              "ChromaticAdaptationMatrixIn": "cmsMAT3",
              "WhitePointOut": "cmsCIEXYZ",
              "ChromaticAdaptationMatrixOut": "cmsMAT3",
              "m": "cmsMAT3"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool IsEmptyLayer(cmsMAT3* m, cmsVEC3* off)\n{\n    cmsFloat64Number diff = 0;\n    cmsMAT3 Ident;\n    int i;\n\n    if (m == NULL && off == NULL) return TRUE;  // NULL is allowed as an empty layer\n    if (m == NULL && off != NULL) return FALSE; // This is an internal error\n\n    _cmsMAT3identity(&Ident);\n\n    for (i=0; i < 3*3; i++)\n        diff += fabs(((cmsFloat64Number*)m)[i] - ((cmsFloat64Number*)&Ident)[i]);\n\n    for (i=0; i < 3; i++)\n        diff += fabs(((cmsFloat64Number*)off)[i]);\n\n\n    return (diff < 0.002);\n}",
          "fn_code_pos": [
            [
              327,
              0
            ],
            [
              347,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsEmptyLayer",
            "parameters": {
              "m": "cmsMAT3",
              "off": "cmsVEC3"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool ComputeConversion(cmsUInt32Number i, \n                          cmsHPROFILE hProfiles[],\n                          cmsUInt32Number Intent,\n                          cmsBool BPC,\n                          cmsFloat64Number AdaptationState,\n                          cmsMAT3* m, cmsVEC3* off)\n{\n\n    int k;\n\n    // m  and off are set to identity and this is detected latter on\n    _cmsMAT3identity(m);\n    _cmsVEC3init(off, 0, 0, 0);\n\n    // If intent is abs. colorimetric,\n    if (Intent == INTENT_ABSOLUTE_COLORIMETRIC) {\n\n        cmsCIEXYZ WhitePointIn, WhitePointOut;\n        cmsMAT3 ChromaticAdaptationMatrixIn, ChromaticAdaptationMatrixOut;\n\n        if (!_cmsReadMediaWhitePoint(&WhitePointIn, hProfiles[i - 1])) return FALSE;\n        if (!_cmsReadCHAD(&ChromaticAdaptationMatrixIn, hProfiles[i - 1])) return FALSE;\n\n        if (!_cmsReadMediaWhitePoint(&WhitePointOut, hProfiles[i])) return FALSE;\n        if (!_cmsReadCHAD(&ChromaticAdaptationMatrixOut, hProfiles[i])) return FALSE;\n\n        if (!ComputeAbsoluteIntent(AdaptationState,\n                                  &WhitePointIn,  &ChromaticAdaptationMatrixIn,\n                                  &WhitePointOut, &ChromaticAdaptationMatrixOut, m)) return FALSE;\n\n    }\n    else {\n        // Rest of intents may apply BPC.\n\n        if (BPC) {\n\n            cmsCIEXYZ BlackPointIn = { 0, 0, 0}, BlackPointOut = { 0, 0, 0 };\n\n            cmsDetectBlackPoint(&BlackPointIn,  hProfiles[i-1], Intent, 0);\n            cmsDetectDestinationBlackPoint(&BlackPointOut, hProfiles[i], Intent, 0);\n\n            // If black points are equal, then do nothing\n            if (BlackPointIn.X != BlackPointOut.X ||\n                BlackPointIn.Y != BlackPointOut.Y ||\n                BlackPointIn.Z != BlackPointOut.Z)\n                    ComputeBlackPointCompensation(&BlackPointIn, &BlackPointOut, m, off);\n        }\n    }\n\n    // Offset should be adjusted because the encoding. We encode XYZ normalized to 0..1.0,\n    // to do that, we divide by MAX_ENCODEABLE_XZY. The conversion stage goes XYZ -> XYZ so\n    // we have first to convert from encoded to XYZ and then convert back to encoded.\n    // y = Mx + Off\n    // x = x'c\n    // y = M x'c + Off\n    // y = y'c; y' = y / c\n    // y' = (Mx'c + Off) /c = Mx' + (Off / c)\n\n    for (k=0; k < 3; k++) {\n        off ->n[k] /= MAX_ENCODEABLE_XYZ;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              351,
              0
            ],
            [
              415,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComputeConversion",
            "parameters": {
              "i": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "BPC": "cmsBool",
              "AdaptationState": "cmsFloat64Number",
              "m": "cmsMAT3",
              "off": "cmsVEC3"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool AddConversion(cmsPipeline* Result, cmsColorSpaceSignature InPCS, cmsColorSpaceSignature OutPCS, cmsMAT3* m, cmsVEC3* off)\n{\n    cmsFloat64Number* m_as_dbl = (cmsFloat64Number*) m;\n    cmsFloat64Number* off_as_dbl = (cmsFloat64Number*) off;\n\n    // Handle PCS mismatches. A specialized stage is added to the LUT in such case\n    switch (InPCS) {\n\n    case cmsSigXYZData: // Input profile operates in XYZ\n\n        switch (OutPCS) {\n\n        case cmsSigXYZData:  // XYZ -> XYZ\n            if (!IsEmptyLayer(m, off) &&\n                !cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl)))\n                return FALSE;\n            break;\n\n        case cmsSigLabData:  // XYZ -> Lab\n            if (!IsEmptyLayer(m, off) &&\n                !cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl)))\n                return FALSE;\n            if (!cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocXYZ2Lab(Result ->ContextID)))\n                return FALSE;\n            break;\n\n        default:\n            return FALSE;   // Colorspace mismatch\n        }\n        break;\n\n    case cmsSigLabData: // Input profile operates in Lab\n\n        switch (OutPCS) {\n\n        case cmsSigXYZData:  // Lab -> XYZ\n\n            if (!cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocLab2XYZ(Result ->ContextID)))\n                return FALSE;\n            if (!IsEmptyLayer(m, off) &&\n                !cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl)))\n                return FALSE;\n            break;\n\n        case cmsSigLabData:  // Lab -> Lab\n\n            if (!IsEmptyLayer(m, off)) {\n                if (!cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocLab2XYZ(Result ->ContextID)) ||\n                    !cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl)) ||\n                    !cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocXYZ2Lab(Result ->ContextID)))\n                    return FALSE;\n            }\n            break;\n\n        default:\n            return FALSE;  // Mismatch\n        }\n        break;\n\n        // On colorspaces other than PCS, check for same space\n    default:\n        if (InPCS != OutPCS) return FALSE;\n        break;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              419,
              0
            ],
            [
              486,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddConversion",
            "parameters": {
              "Result": "cmsPipeline",
              "InPCS": "cmsColorSpaceSignature",
              "OutPCS": "cmsColorSpaceSignature",
              "m": "cmsMAT3",
              "off": "cmsVEC3"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool ColorSpaceIsCompatible(cmsColorSpaceSignature a, cmsColorSpaceSignature b)\n{\n    // If they are same, they are compatible.\n    if (a == b) return TRUE;\n\n    // Check for MCH4 substitution of CMYK\n    if ((a == cmsSig4colorData) && (b == cmsSigCmykData)) return TRUE;\n    if ((a == cmsSigCmykData) && (b == cmsSig4colorData)) return TRUE;\n\n    // Check for XYZ/Lab. Those spaces are interchangeable as they can be computed one from other.\n    if ((a == cmsSigXYZData) && (b == cmsSigLabData)) return TRUE;\n    if ((a == cmsSigLabData) && (b == cmsSigXYZData)) return TRUE;\n\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              490,
              0
            ],
            [
              505,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ColorSpaceIsCompatible",
            "parameters": {
              "a": "cmsColorSpaceSignature",
              "b": "cmsColorSpaceSignature"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsPipeline* DefaultICCintents(cmsContext       ContextID,\n                               cmsUInt32Number  nProfiles,\n                               cmsUInt32Number  TheIntents[],\n                               cmsHPROFILE      hProfiles[],\n                               cmsBool          BPC[],\n                               cmsFloat64Number AdaptationStates[],\n                               cmsUInt32Number  dwFlags)\n{\n    cmsPipeline* Lut = NULL;\n    cmsPipeline* Result;\n    cmsHPROFILE hProfile;\n    cmsMAT3 m;\n    cmsVEC3 off;\n    cmsColorSpaceSignature ColorSpaceIn, ColorSpaceOut = cmsSigLabData, CurrentColorSpace;\n    cmsProfileClassSignature ClassSig;\n    cmsUInt32Number  i, Intent;\n\n    // For safety\n    if (nProfiles == 0) return NULL;\n\n    // Allocate an empty LUT for holding the result. 0 as channel count means 'undefined'\n    Result = cmsPipelineAlloc(ContextID, 0, 0);\n    if (Result == NULL) return NULL;\n\n    CurrentColorSpace = cmsGetColorSpace(hProfiles[0]);\n\n    for (i=0; i < nProfiles; i++) {\n\n        cmsBool  lIsDeviceLink, lIsInput;\n\n        hProfile      = hProfiles[i];\n        ClassSig      = cmsGetDeviceClass(hProfile);\n        lIsDeviceLink = (ClassSig == cmsSigLinkClass || ClassSig == cmsSigAbstractClass );\n\n        // First profile is used as input unless devicelink or abstract\n        if ((i == 0) && !lIsDeviceLink) {\n            lIsInput = TRUE;\n        }\n        else {\n          // Else use profile in the input direction if current space is not PCS\n        lIsInput      = (CurrentColorSpace != cmsSigXYZData) &&\n                        (CurrentColorSpace != cmsSigLabData);\n        }\n\n        Intent        = TheIntents[i];\n\n        if (lIsInput || lIsDeviceLink) {\n\n            ColorSpaceIn    = cmsGetColorSpace(hProfile);\n            ColorSpaceOut   = cmsGetPCS(hProfile);\n        }\n        else {\n\n            ColorSpaceIn    = cmsGetPCS(hProfile);\n            ColorSpaceOut   = cmsGetColorSpace(hProfile);\n        }\n\n        if (!ColorSpaceIsCompatible(ColorSpaceIn, CurrentColorSpace)) {\n\n            cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, \"ColorSpace mismatch\");\n            goto Error;\n        }\n\n        // If devicelink is found, then no custom intent is allowed and we can\n        // read the LUT to be applied. Settings don't apply here.\n        if (lIsDeviceLink || ((ClassSig == cmsSigNamedColorClass) && (nProfiles == 1))) {\n\n            // Get the involved LUT from the profile\n            Lut = _cmsReadDevicelinkLUT(hProfile, Intent);\n            if (Lut == NULL) goto Error;\n\n            // What about abstract profiles?\n             if (ClassSig == cmsSigAbstractClass && i > 0) {\n                if (!ComputeConversion(i, hProfiles, Intent, BPC[i], AdaptationStates[i], &m, &off)) goto Error;\n             }\n             else {\n                _cmsMAT3identity(&m);\n                _cmsVEC3init(&off, 0, 0, 0);\n             }\n\n\n            if (!AddConversion(Result, CurrentColorSpace, ColorSpaceIn, &m, &off)) goto Error;\n\n        }\n        else {\n\n            if (lIsInput) {\n                // Input direction means non-pcs connection, so proceed like devicelinks\n                Lut = _cmsReadInputLUT(hProfile, Intent);\n                if (Lut == NULL) goto Error;\n            }\n            else {\n\n                // Output direction means PCS connection. Intent may apply here\n                Lut = _cmsReadOutputLUT(hProfile, Intent);\n                if (Lut == NULL) goto Error;\n\n\n                if (!ComputeConversion(i, hProfiles, Intent, BPC[i], AdaptationStates[i], &m, &off)) goto Error;\n                if (!AddConversion(Result, CurrentColorSpace, ColorSpaceIn, &m, &off)) goto Error;\n\n            }\n        }\n\n        // Concatenate to the output LUT\n        if (!cmsPipelineCat(Result, Lut))\n            goto Error;\n\n        cmsPipelineFree(Lut);\n        Lut = NULL;\n\n        // Update current space\n        CurrentColorSpace = ColorSpaceOut;\n    }\n\n    // Check for non-negatives clip\n    if (dwFlags & cmsFLAGS_NONEGATIVES) {\n\n           if (ColorSpaceOut == cmsSigGrayData ||\n                  ColorSpaceOut == cmsSigRgbData ||\n                  ColorSpaceOut == cmsSigCmykData) {\n\n                  cmsStage* clip = _cmsStageClipNegatives(Result->ContextID, cmsChannelsOfColorSpace(ColorSpaceOut));\n                  if (clip == NULL) goto Error;\n\n                  if (!cmsPipelineInsertStage(Result, cmsAT_END, clip))\n                         goto Error;\n           }\n\n    }\n\n    return Result;\n\nError:\n\n    if (Lut != NULL) cmsPipelineFree(Lut);\n    if (Result != NULL) cmsPipelineFree(Result);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(dwFlags);\n}",
          "fn_code_pos": [
            [
              509,
              0
            ],
            [
              650,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DefaultICCintents",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "TheIntents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsPipeline"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number TranslateNonICCIntents(cmsUInt32Number Intent)\n{\n    switch (Intent) {\n        case INTENT_PRESERVE_K_ONLY_PERCEPTUAL:\n        case INTENT_PRESERVE_K_PLANE_PERCEPTUAL:\n            return INTENT_PERCEPTUAL;\n\n        case INTENT_PRESERVE_K_ONLY_RELATIVE_COLORIMETRIC:\n        case INTENT_PRESERVE_K_PLANE_RELATIVE_COLORIMETRIC:\n            return INTENT_RELATIVE_COLORIMETRIC;\n\n        case INTENT_PRESERVE_K_ONLY_SATURATION:\n        case INTENT_PRESERVE_K_PLANE_SATURATION:\n            return INTENT_SATURATION;\n\n        default: return Intent;\n    }\n}",
          "fn_code_pos": [
            [
              668,
              0
            ],
            [
              686,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TranslateNonICCIntents",
            "parameters": {
              "Intent": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\nint BlackPreservingGrayOnlySampler(CMSREGISTER const cmsUInt16Number In[], CMSREGISTER cmsUInt16Number Out[], CMSREGISTER void* Cargo)\n{\n    GrayOnlyParams* bp = (GrayOnlyParams*) Cargo;\n\n    // If going across black only, keep black only\n    if (In[0] == 0 && In[1] == 0 && In[2] == 0) {\n\n        // TAC does not apply because it is black ink!\n        Out[0] = Out[1] = Out[2] = 0;\n        Out[3] = cmsEvalToneCurve16(bp->KTone, In[3]);\n        return TRUE;\n    }\n\n    // Keep normal transform for other colors\n    bp ->cmyk2cmyk ->Eval16Fn(In, Out, bp ->cmyk2cmyk->Data);\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              698,
              0
            ],
            [
              715,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BlackPreservingGrayOnlySampler",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\ncmsBool is_cmyk_devicelink(cmsHPROFILE hProfile)\n{\n    return cmsGetDeviceClass(hProfile) == cmsSigLinkClass &&            \n            cmsGetColorSpace(hProfile) == cmsSigCmykData;\n}",
          "fn_code_pos": [
            [
              719,
              0
            ],
            [
              724,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "is_cmyk_devicelink",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsPipeline*  BlackPreservingKOnlyIntents(cmsContext     ContextID,\n                                          cmsUInt32Number nProfiles,\n                                          cmsUInt32Number TheIntents[],\n                                          cmsHPROFILE     hProfiles[],\n                                          cmsBool         BPC[],\n                                          cmsFloat64Number AdaptationStates[],\n                                          cmsUInt32Number dwFlags)\n{\n    GrayOnlyParams  bp;\n    cmsPipeline*    Result;\n    cmsUInt32Number ICCIntents[256];\n    cmsStage*         CLUT;\n    cmsUInt32Number i, nGridPoints;\n    cmsUInt32Number lastProfilePos;\n    cmsUInt32Number preservationProfilesCount;\n    cmsHPROFILE hLastProfile;\n\n\n    // Sanity check\n    if (nProfiles < 1 || nProfiles > 255) return NULL;\n\n    // Translate black-preserving intents to ICC ones\n    for (i=0; i < nProfiles; i++)\n        ICCIntents[i] = TranslateNonICCIntents(TheIntents[i]);\n\n\n    // Trim all CMYK devicelinks at the end  \n    lastProfilePos = nProfiles - 1;\n    hLastProfile = hProfiles[lastProfilePos];\n\n    // Skip CMYK->CMYK devicelinks on ending\n    while (is_cmyk_devicelink(hLastProfile))\n    {\n        if (lastProfilePos < 2)\n            break;\n\n        hLastProfile = hProfiles[--lastProfilePos];\n    }\n\n\n    preservationProfilesCount = lastProfilePos + 1;\n\n    // Check for non-cmyk profiles\n    if (cmsGetColorSpace(hProfiles[0]) != cmsSigCmykData ||\n        !(cmsGetColorSpace(hLastProfile) == cmsSigCmykData ||\n        cmsGetDeviceClass(hLastProfile) == cmsSigOutputClass))\n           return DefaultICCintents(ContextID, nProfiles, ICCIntents, hProfiles, BPC, AdaptationStates, dwFlags);\n\n    // Allocate an empty LUT for holding the result\n    Result = cmsPipelineAlloc(ContextID, 4, 4);\n    if (Result == NULL) return NULL;\n\n    memset(&bp, 0, sizeof(bp));\n\n    // Create a LUT holding normal ICC transform\n    bp.cmyk2cmyk = DefaultICCintents(ContextID,\n        preservationProfilesCount,\n        ICCIntents,\n        hProfiles,\n        BPC,\n        AdaptationStates,\n        dwFlags);\n\n    if (bp.cmyk2cmyk == NULL) goto Error;\n\n    // Now, compute the tone curve\n    bp.KTone = _cmsBuildKToneCurve(ContextID,\n        4096,\n        preservationProfilesCount,\n        ICCIntents,\n        hProfiles,\n        BPC,\n        AdaptationStates,\n        dwFlags);\n\n    if (bp.KTone == NULL) goto Error;\n\n\n    // How many gridpoints are we going to use?\n    nGridPoints = _cmsReasonableGridpointsByColorspace(cmsSigCmykData, dwFlags);\n\n    // Create the CLUT. 16 bits\n    CLUT = cmsStageAllocCLut16bit(ContextID, nGridPoints, 4, 4, NULL);\n    if (CLUT == NULL) goto Error;\n\n    // This is the one and only MPE in this LUT\n    if (!cmsPipelineInsertStage(Result, cmsAT_BEGIN, CLUT))\n        goto Error;\n\n    // Sample it. We cannot afford pre/post linearization this time.\n    if (!cmsStageSampleCLut16bit(CLUT, BlackPreservingGrayOnlySampler, (void*) &bp, 0))\n        goto Error;\n\n    \n    // Insert possible devicelinks at the end\n    for (i = lastProfilePos + 1; i < nProfiles; i++)\n    {\n        cmsPipeline* devlink = _cmsReadDevicelinkLUT(hProfiles[i], ICCIntents[i]);\n        if (devlink == NULL)\n            goto Error;\n\n        if (!cmsPipelineCat(Result, devlink))\n            goto Error;\n    }\n\n\n    // Get rid of xform and tone curve\n    cmsPipelineFree(bp.cmyk2cmyk);\n    cmsFreeToneCurve(bp.KTone);\n\n    return Result;\n\nError:\n\n    if (bp.cmyk2cmyk != NULL) cmsPipelineFree(bp.cmyk2cmyk);\n    if (bp.KTone != NULL)  cmsFreeToneCurve(bp.KTone);\n    if (Result != NULL) cmsPipelineFree(Result);\n    return NULL;\n\n}",
          "fn_code_pos": [
            [
              727,
              0
            ],
            [
              847,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BlackPreservingKOnlyIntents",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "TheIntents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsPipeline"
          }
        },
        {
          "fn_code": "static\nint BlackPreservingSampler(CMSREGISTER const cmsUInt16Number In[], CMSREGISTER cmsUInt16Number Out[], CMSREGISTER void* Cargo)\n{\n    int i;\n    cmsFloat32Number Inf[4], Outf[4];\n    cmsFloat32Number LabK[4];\n    cmsFloat64Number SumCMY, SumCMYK, Error, Ratio;\n    cmsCIELab ColorimetricLab, BlackPreservingLab;\n    PreserveKPlaneParams* bp = (PreserveKPlaneParams*) Cargo;\n\n    // Convert from 16 bits to floating point\n    for (i=0; i < 4; i++)\n        Inf[i] = (cmsFloat32Number) (In[i] / 65535.0);\n\n    // Get the K across Tone curve\n    LabK[3] = cmsEvalToneCurveFloat(bp ->KTone, Inf[3]);\n\n    // If going across black only, keep black only\n    if (In[0] == 0 && In[1] == 0 && In[2] == 0) {\n\n        Out[0] = Out[1] = Out[2] = 0;\n        Out[3] = _cmsQuickSaturateWord(LabK[3] * 65535.0);\n        return TRUE;\n    }\n\n    // Try the original transform,\n    cmsPipelineEvalFloat(Inf, Outf, bp ->cmyk2cmyk);\n\n    // Store a copy of the floating point result into 16-bit\n    for (i=0; i < 4; i++)\n            Out[i] = _cmsQuickSaturateWord(Outf[i] * 65535.0);\n\n    // Maybe K is already ok (mostly on K=0)\n    if (fabsf(Outf[3] - LabK[3]) < (3.0 / 65535.0)) {\n        return TRUE;\n    }\n\n    // K differ, measure and keep Lab measurement for further usage\n    // this is done in relative colorimetric intent\n    cmsDoTransform(bp->hProofOutput, Out, &ColorimetricLab, 1);\n\n    // Is not black only and the transform doesn't keep black.\n    // Obtain the Lab of output CMYK. After that we have Lab + K\n    cmsDoTransform(bp ->cmyk2Lab, Outf, LabK, 1);\n\n    // Obtain the corresponding CMY using reverse interpolation\n    // (K is fixed in LabK[3])\n    if (!cmsPipelineEvalReverseFloat(LabK, Outf, Outf, bp ->LabK2cmyk)) {\n\n        // Cannot find a suitable value, so use colorimetric xform\n        // which is already stored in Out[]\n        return TRUE;\n    }\n\n    // Make sure to pass through K (which now is fixed)\n    Outf[3] = LabK[3];\n\n    // Apply TAC if needed\n    SumCMY   = (cmsFloat64Number) Outf[0]  + Outf[1] + Outf[2];\n    SumCMYK  = SumCMY + Outf[3];\n\n    if (SumCMYK > bp ->MaxTAC) {\n\n        Ratio = 1 - ((SumCMYK - bp->MaxTAC) / SumCMY);\n        if (Ratio < 0)\n            Ratio = 0;\n    }\n    else\n       Ratio = 1.0;\n\n    Out[0] = _cmsQuickSaturateWord(Outf[0] * Ratio * 65535.0);     // C\n    Out[1] = _cmsQuickSaturateWord(Outf[1] * Ratio * 65535.0);     // M\n    Out[2] = _cmsQuickSaturateWord(Outf[2] * Ratio * 65535.0);     // Y\n    Out[3] = _cmsQuickSaturateWord(Outf[3] * 65535.0);\n\n    // Estimate the error (this goes 16 bits to Lab DBL)\n    cmsDoTransform(bp->hProofOutput, Out, &BlackPreservingLab, 1);\n    Error = cmsDeltaE(&ColorimetricLab, &BlackPreservingLab);\n    if (Error > bp -> MaxError)\n        bp->MaxError = Error;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              868,
              0
            ],
            [
              950,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BlackPreservingSampler",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\ncmsPipeline* BlackPreservingKPlaneIntents(cmsContext     ContextID,\n                                          cmsUInt32Number nProfiles,\n                                          cmsUInt32Number TheIntents[],\n                                          cmsHPROFILE     hProfiles[],\n                                          cmsBool         BPC[],\n                                          cmsFloat64Number AdaptationStates[],\n                                          cmsUInt32Number dwFlags)\n{\n    PreserveKPlaneParams bp;\n\n    cmsPipeline*    Result = NULL;\n    cmsUInt32Number ICCIntents[256];\n    cmsStage*         CLUT;\n    cmsUInt32Number i, nGridPoints;\n    cmsUInt32Number lastProfilePos;\n    cmsUInt32Number preservationProfilesCount;\n    cmsHPROFILE hLastProfile;\n    cmsHPROFILE hLab;\n\n    // Sanity check\n    if (nProfiles < 1 || nProfiles > 255) return NULL;\n\n    // Translate black-preserving intents to ICC ones\n    for (i=0; i < nProfiles; i++)\n        ICCIntents[i] = TranslateNonICCIntents(TheIntents[i]);\n\n    // Trim all CMYK devicelinks at the end  \n    lastProfilePos = nProfiles - 1;\n    hLastProfile = hProfiles[lastProfilePos];\n\n    // Skip CMYK->CMYK devicelinks on ending\n    while (is_cmyk_devicelink(hLastProfile))\n    {\n        if (lastProfilePos < 2)\n            break;\n\n        hLastProfile = hProfiles[--lastProfilePos];\n    }\n\n    preservationProfilesCount = lastProfilePos + 1;\n\n    // Check for non-cmyk profiles\n    if (cmsGetColorSpace(hProfiles[0]) != cmsSigCmykData ||\n        !(cmsGetColorSpace(hLastProfile) == cmsSigCmykData ||\n        cmsGetDeviceClass(hLastProfile) == cmsSigOutputClass))\n           return  DefaultICCintents(ContextID, nProfiles, ICCIntents, hProfiles, BPC, AdaptationStates, dwFlags);\n\n    // Allocate an empty LUT for holding the result\n    Result = cmsPipelineAlloc(ContextID, 4, 4);\n    if (Result == NULL) return NULL;\n\n    memset(&bp, 0, sizeof(bp));\n\n    // We need the input LUT of the last profile, assuming this one is responsible of\n    // black generation. This LUT will be searched in inverse order.\n    bp.LabK2cmyk = _cmsReadInputLUT(hLastProfile, INTENT_RELATIVE_COLORIMETRIC);\n    if (bp.LabK2cmyk == NULL) goto Cleanup;\n\n    // Get total area coverage (in 0..1 domain)\n    bp.MaxTAC = cmsDetectTAC(hLastProfile) / 100.0;\n    if (bp.MaxTAC <= 0) goto Cleanup;\n\n\n    // Create a LUT holding normal ICC transform\n    bp.cmyk2cmyk = DefaultICCintents(ContextID,\n                                         preservationProfilesCount,\n                                         ICCIntents,\n                                         hProfiles,\n                                         BPC,\n                                         AdaptationStates,\n                                         dwFlags);\n    if (bp.cmyk2cmyk == NULL) goto Cleanup;\n\n    // Now the tone curve\n    bp.KTone = _cmsBuildKToneCurve(ContextID, 4096, preservationProfilesCount,\n                                   ICCIntents,\n                                   hProfiles,\n                                   BPC,\n                                   AdaptationStates,\n                                   dwFlags);\n    if (bp.KTone == NULL) goto Cleanup;\n\n    // To measure the output, Last profile to Lab\n    hLab = cmsCreateLab4ProfileTHR(ContextID, NULL);\n    bp.hProofOutput = cmsCreateTransformTHR(ContextID, hLastProfile,\n                                         CHANNELS_SH(4)|BYTES_SH(2), hLab, TYPE_Lab_DBL,\n                                         INTENT_RELATIVE_COLORIMETRIC,\n                                         cmsFLAGS_NOCACHE|cmsFLAGS_NOOPTIMIZE);\n    if ( bp.hProofOutput == NULL) goto Cleanup;\n\n    // Same as anterior, but lab in the 0..1 range\n    bp.cmyk2Lab = cmsCreateTransformTHR(ContextID, hLastProfile,\n                                         FLOAT_SH(1)|CHANNELS_SH(4)|BYTES_SH(4), hLab,\n                                         FLOAT_SH(1)|CHANNELS_SH(3)|BYTES_SH(4),\n                                         INTENT_RELATIVE_COLORIMETRIC,\n                                         cmsFLAGS_NOCACHE|cmsFLAGS_NOOPTIMIZE);\n    if (bp.cmyk2Lab == NULL) goto Cleanup;\n    cmsCloseProfile(hLab);\n\n    // Error estimation (for debug only)\n    bp.MaxError = 0;\n\n    // How many gridpoints are we going to use?\n    nGridPoints = _cmsReasonableGridpointsByColorspace(cmsSigCmykData, dwFlags);\n\n\n    CLUT = cmsStageAllocCLut16bit(ContextID, nGridPoints, 4, 4, NULL);\n    if (CLUT == NULL) goto Cleanup;\n\n    if (!cmsPipelineInsertStage(Result, cmsAT_BEGIN, CLUT))\n        goto Cleanup;\n\n    cmsStageSampleCLut16bit(CLUT, BlackPreservingSampler, (void*) &bp, 0);\n\n    // Insert possible devicelinks at the end    \n    for (i = lastProfilePos + 1; i < nProfiles; i++)\n    {        \n        cmsPipeline* devlink = _cmsReadDevicelinkLUT(hProfiles[i], ICCIntents[i]);\n        if (devlink == NULL)\n            goto Cleanup;\n\n        if (!cmsPipelineCat(Result, devlink))\n            goto Cleanup;\n    }\n\n\nCleanup:\n\n    if (bp.cmyk2cmyk) cmsPipelineFree(bp.cmyk2cmyk);\n    if (bp.cmyk2Lab) cmsDeleteTransform(bp.cmyk2Lab);\n    if (bp.hProofOutput) cmsDeleteTransform(bp.hProofOutput);\n\n    if (bp.KTone) cmsFreeToneCurve(bp.KTone);\n    if (bp.LabK2cmyk) cmsPipelineFree(bp.LabK2cmyk);\n\n    return Result;\n}",
          "fn_code_pos": [
            [
              955,
              0
            ],
            [
              1092,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BlackPreservingKPlaneIntents",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "TheIntents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsPipeline"
          }
        },
        {
          "fn_code": "cmsPipeline* _cmsLinkProfiles(cmsContext     ContextID,\n                              cmsUInt32Number nProfiles,\n                              cmsUInt32Number TheIntents[],\n                              cmsHPROFILE     hProfiles[],\n                              cmsBool         BPC[],\n                              cmsFloat64Number AdaptationStates[],\n                              cmsUInt32Number dwFlags)\n{\n    cmsUInt32Number i;\n    cmsIntentsList* Intent;\n\n    // Make sure a reasonable number of profiles is provided\n    if (nProfiles <= 0 || nProfiles > 255) {\n         cmsSignalError(ContextID, cmsERROR_RANGE, \"Couldn't link '%d' profiles\", nProfiles);\n        return NULL;\n    }\n\n    for (i=0; i < nProfiles; i++) {\n\n        // Check if black point is really needed or allowed. Note that\n        // following Adobe's document:\n        // BPC does not apply to devicelink profiles, nor to abs colorimetric,\n        // and applies always on V4 perceptual and saturation.\n\n        if (TheIntents[i] == INTENT_ABSOLUTE_COLORIMETRIC)\n            BPC[i] = FALSE;\n\n        if (TheIntents[i] == INTENT_PERCEPTUAL || TheIntents[i] == INTENT_SATURATION) {\n\n            // Force BPC for V4 profiles in perceptual and saturation\n            if (cmsGetEncodedICCversion(hProfiles[i]) >= 0x4000000)\n                BPC[i] = TRUE;\n        }\n    }\n\n    // Search for a handler. The first intent in the chain defines the handler. That would\n    // prevent using multiple custom intents in a multiintent chain, but the behaviour of\n    // this case would present some issues if the custom intent tries to do things like\n    // preserve primaries. This solution is not perfect, but works well on most cases.\n\n    Intent = SearchIntent(ContextID, TheIntents[0]);\n    if (Intent == NULL) {\n        cmsSignalError(ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported intent '%d'\", TheIntents[0]);\n        return NULL;\n    }\n\n    // Call the handler\n    return Intent ->Link(ContextID, nProfiles, TheIntents, hProfiles, BPC, AdaptationStates, dwFlags);\n}",
          "fn_code_pos": [
            [
              1101,
              0
            ],
            [
              1149,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsLinkProfiles",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "TheIntents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsPipeline"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsGetSupportedIntentsTHR(cmsContext ContextID, cmsUInt32Number nMax, cmsUInt32Number* Codes, char** Descriptions)\n{\n    _cmsIntentsPluginChunkType* ctx = ( _cmsIntentsPluginChunkType*) _cmsContextGetClientChunk(ContextID, IntentPlugin);\n    cmsIntentsList* pt;\n    cmsUInt32Number nIntents;\n\n    for (nIntents=0, pt = DefaultIntents; pt != NULL; pt = pt -> Next)\n    {\n        if (nIntents < nMax) {\n            if (Codes != NULL)\n                Codes[nIntents] = pt ->Intent;\n\n            if (Descriptions != NULL)\n                Descriptions[nIntents] = pt ->Description;\n        }\n\n        nIntents++;\n    }\n\n    for (pt = ctx->Intents; pt != NULL; pt = pt -> Next)\n    {\n        if (nIntents < nMax) {\n            if (Codes != NULL)\n                Codes[nIntents] = pt ->Intent;\n\n            if (Descriptions != NULL)\n                Descriptions[nIntents] = pt ->Description;\n        }\n\n        nIntents++;\n    }\n\n    return nIntents;\n}",
          "fn_code_pos": [
            [
              1156,
              0
            ],
            [
              1189,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetSupportedIntentsTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "nMax": "cmsUInt32Number",
              "Codes": "cmsUInt32Number",
              "Descriptions": "char"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsGetSupportedIntents(cmsUInt32Number nMax, cmsUInt32Number* Codes, char** Descriptions)\n{\n    return cmsGetSupportedIntentsTHR(NULL, nMax, Codes, Descriptions);\n}",
          "fn_code_pos": [
            [
              1191,
              0
            ],
            [
              1194,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetSupportedIntents",
            "parameters": {
              "nMax": "cmsUInt32Number",
              "Codes": "cmsUInt32Number",
              "Descriptions": "char"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsBool  _cmsRegisterRenderingIntentPlugin(cmsContext id, cmsPluginBase* Data)\n{\n    _cmsIntentsPluginChunkType* ctx = ( _cmsIntentsPluginChunkType*) _cmsContextGetClientChunk(id, IntentPlugin);\n    cmsPluginRenderingIntent* Plugin = (cmsPluginRenderingIntent*) Data;\n    cmsIntentsList* fl;\n\n    // Do we have to reset the custom intents?\n    if (Data == NULL) {\n\n        ctx->Intents = NULL;\n        return TRUE;\n    }\n\n    fl = (cmsIntentsList*) _cmsPluginMalloc(id, sizeof(cmsIntentsList));\n    if (fl == NULL) return FALSE;\n\n\n    fl ->Intent  = Plugin ->Intent;\n    strncpy(fl ->Description, Plugin ->Description, sizeof(fl ->Description)-1);\n    fl ->Description[sizeof(fl ->Description)-1] = 0;\n\n    fl ->Link    = Plugin ->Link;\n\n    fl ->Next = ctx ->Intents;\n    ctx ->Intents = fl;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1197,
              0
            ],
            [
              1224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterRenderingIntentPlugin",
            "parameters": {
              "id": "cmsContext",
              "Data": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "DefaultICCintents(cmsContext     ContextID,\n                               cmsUInt32Number nProfiles,\n                               cmsUInt32Number Intents[],\n                               cmsHPROFILE     hProfiles[],\n                               cmsBool         BPC[],\n                               cmsFloat64Number AdaptationStates[],\n                               cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              32,
              13
            ],
            [
              38,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DefaultICCintents",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "Intents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "BlackPreservingKOnlyIntents(cmsContext     ContextID,\n                                          cmsUInt32Number nProfiles,\n                                          cmsUInt32Number Intents[],\n                                          cmsHPROFILE     hProfiles[],\n                                          cmsBool         BPC[],\n                                          cmsFloat64Number AdaptationStates[],\n                                          cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              45,
              14
            ],
            [
              51,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BlackPreservingKOnlyIntents",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "Intents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "BlackPreservingKPlaneIntents(cmsContext     ContextID,\n                                           cmsUInt32Number nProfiles,\n                                           cmsUInt32Number Intents[],\n                                           cmsHPROFILE     hProfiles[],\n                                           cmsBool         BPC[],\n                                           cmsFloat64Number AdaptationStates[],\n                                           cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              58,
              14
            ],
            [
              64,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BlackPreservingKPlaneIntents",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "Intents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "SearchIntent(cmsContext ContextID, cmsUInt32Number Intent)",
          "fn_dec_pos": [
            [
              150,
              16
            ],
            [
              150,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SearchIntent",
            "parameters": {
              "ContextID": "cmsContext",
              "Intent": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DefaultICCintents(cmsContext       ContextID,\n                               cmsUInt32Number  nProfiles,\n                               cmsUInt32Number  TheIntents[],\n                               cmsHPROFILE      hProfiles[],\n                               cmsBool          BPC[],\n                               cmsFloat64Number AdaptationStates[],\n                               cmsUInt32Number  dwFlags)",
          "fn_dec_pos": [
            [
              510,
              13
            ],
            [
              516,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DefaultICCintents",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "TheIntents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "BlackPreservingKOnlyIntents(cmsContext     ContextID,\n                                          cmsUInt32Number nProfiles,\n                                          cmsUInt32Number TheIntents[],\n                                          cmsHPROFILE     hProfiles[],\n                                          cmsBool         BPC[],\n                                          cmsFloat64Number AdaptationStates[],\n                                          cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              728,
              14
            ],
            [
              734,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BlackPreservingKOnlyIntents",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "TheIntents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "BlackPreservingKPlaneIntents(cmsContext     ContextID,\n                                          cmsUInt32Number nProfiles,\n                                          cmsUInt32Number TheIntents[],\n                                          cmsHPROFILE     hProfiles[],\n                                          cmsBool         BPC[],\n                                          cmsFloat64Number AdaptationStates[],\n                                          cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              956,
              13
            ],
            [
              962,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BlackPreservingKPlaneIntents",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "TheIntents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsLinkProfiles(cmsContext     ContextID,\n                              cmsUInt32Number nProfiles,\n                              cmsUInt32Number TheIntents[],\n                              cmsHPROFILE     hProfiles[],\n                              cmsBool         BPC[],\n                              cmsFloat64Number AdaptationStates[],\n                              cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              1101,
              13
            ],
            [
              1107,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsLinkProfiles",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "TheIntents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct _cms_intents_list {\n\n    cmsUInt32Number Intent;\n    char            Description[256];\n    cmsIntentFn     Link;\n    struct _cms_intents_list*  Next;\n\n} cmsIntentsList;",
          {
            "Intent": "cmsUInt32Number",
            "Description[256]": "char",
            "Link": "cmsIntentFn",
            "*  Next": "struct _cms_intents_list"
          },
          "cmsIntentsList",
          [
            70,
            0
          ],
          [
            77,
            17
          ]
        ],
        [
          "typedef struct {\n    cmsPipeline*    cmyk2cmyk;      // The original transform\n    cmsToneCurve*   KTone;          // Black-to-black tone curve\n\n} GrayOnlyParams;",
          {
            "*    cmyk2cmyk": "cmsPipeline",
            "*   KTone": "cmsToneCurve"
          },
          "GrayOnlyParams",
          [
            690,
            0
          ],
          [
            694,
            17
          ]
        ],
        [
          "typedef struct {\n\n    cmsPipeline*     cmyk2cmyk;     // The original transform\n    cmsHTRANSFORM    hProofOutput;  // Output CMYK to Lab (last profile)\n    cmsHTRANSFORM    cmyk2Lab;      // The input chain\n    cmsToneCurve*    KTone;         // Black-to-black tone curve\n    cmsPipeline*     LabK2cmyk;     // The output profile\n    cmsFloat64Number MaxError;\n\n    cmsHTRANSFORM    hRoundTrip;\n    cmsFloat64Number MaxTAC;\n\n\n} PreserveKPlaneParams;",
          {
            "*     cmyk2cmyk": "cmsPipeline",
            "hProofOutput": "cmsHTRANSFORM",
            "cmyk2Lab": "cmsHTRANSFORM",
            "*    KTone": "cmsToneCurve",
            "*     LabK2cmyk": "cmsPipeline",
            "MaxError": "cmsFloat64Number",
            "hRoundTrip": "cmsHTRANSFORM",
            "MaxTAC": "cmsFloat64Number"
          },
          "PreserveKPlaneParams",
          [
            851,
            0
          ],
          [
            864,
            23
          ]
        ],
        [
          "typedef struct _cms_intents_list {\n\n    cmsUInt32Number Intent;\n    char            Description[256];\n    cmsIntentFn     Link;\n    struct _cms_intents_list*  Next;\n\n} cmsIntentsList;",
          {
            "Intent": "cmsUInt32Number",
            "Description[256]": "char",
            "Link": "cmsIntentFn",
            "*  Next": "struct _cms_intents_list"
          },
          "cmsIntentsList",
          [
            70,
            0
          ],
          [
            77,
            17
          ]
        ],
        [
          "struct _cms_intents_list",
          {},
          "",
          [
            75,
            4
          ],
          [
            75,
            28
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            101,
            26
          ],
          [
            101,
            51
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            102,
            53
          ],
          [
            102,
            78
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            133,
            34
          ],
          [
            133,
            59
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            134,
            47
          ],
          [
            134,
            72
          ]
        ],
        [
          "typedef struct {\n    cmsPipeline*    cmyk2cmyk;      // The original transform\n    cmsToneCurve*   KTone;          // Black-to-black tone curve\n\n} GrayOnlyParams;",
          {
            "*    cmyk2cmyk": "cmsPipeline",
            "*   KTone": "cmsToneCurve"
          },
          "GrayOnlyParams",
          [
            690,
            0
          ],
          [
            694,
            17
          ]
        ],
        [
          "typedef struct {\n\n    cmsPipeline*     cmyk2cmyk;     // The original transform\n    cmsHTRANSFORM    hProofOutput;  // Output CMYK to Lab (last profile)\n    cmsHTRANSFORM    cmyk2Lab;      // The input chain\n    cmsToneCurve*    KTone;         // Black-to-black tone curve\n    cmsPipeline*     LabK2cmyk;     // The output profile\n    cmsFloat64Number MaxError;\n\n    cmsHTRANSFORM    hRoundTrip;\n    cmsFloat64Number MaxTAC;\n\n\n} PreserveKPlaneParams;",
          {
            "*     cmyk2cmyk": "cmsPipeline",
            "hProofOutput": "cmsHTRANSFORM",
            "cmyk2Lab": "cmsHTRANSFORM",
            "*    KTone": "cmsToneCurve",
            "*     LabK2cmyk": "cmsPipeline",
            "MaxError": "cmsFloat64Number",
            "hRoundTrip": "cmsHTRANSFORM",
            "MaxTAC": "cmsFloat64Number"
          },
          "PreserveKPlaneParams",
          [
            851,
            0
          ],
          [
            864,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmserr.c": {
      "fn_def_list": [
        {
          "fn_code": "int CMSEXPORT cmsGetEncodedCMMversion(void)\n{\n       return LCMS_VERSION;\n}",
          "fn_code_pos": [
            [
              29,
              0
            ],
            [
              32,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetEncodedCMMversion",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int CMSEXPORT cmsstrcasecmp(const char* s1, const char* s2)\n{\n    CMSREGISTER const unsigned char *us1 = (const unsigned char *)s1,\n                                 *us2 = (const unsigned char *)s2;\n\n    while (toupper(*us1) == toupper(*us2++))\n        if (*us1++ == '\\0')\n            return 0;\n\n    return (toupper(*us1) - toupper(*--us2));\n}",
          "fn_code_pos": [
            [
              38,
              0
            ],
            [
              48,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsstrcasecmp",
            "parameters": {
              "s1": "char",
              "s2": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "long int CMSEXPORT cmsfilelength(FILE* f)\n{\n    long int p , n;\n\n    p = ftell(f); // register current file position\n    if (p == -1L) \n        return -1L;\n\n    if (fseek(f, 0, SEEK_END) != 0) {\n        return -1L;\n    }\n\n    n = ftell(f);\n    fseek(f, p, SEEK_SET); // file position restored\n\n    return n;\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsfilelength",
            "parameters": {
              "f": "FILE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static\nvoid* _cmsMallocDefaultFn(cmsContext ContextID, cmsUInt32Number size)\n{\n    // Never allow 0 or over maximum\n    if (size == 0 || size > MAX_MEMORY_FOR_ALLOC) return NULL;\n\n    return (void*) malloc(size);\n\n    cmsUNUSED_PARAMETER(ContextID);\n}",
          "fn_code_pos": [
            [
              91,
              0
            ],
            [
              100,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMallocDefaultFn",
            "parameters": {
              "ContextID": "cmsContext",
              "size": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* _cmsMallocZeroDefaultFn(cmsContext ContextID, cmsUInt32Number size)\n{\n    void *pt = _cmsMalloc(ContextID, size);\n    if (pt == NULL) return NULL;\n\n    memset(pt, 0, size);\n    return pt;\n}",
          "fn_code_pos": [
            [
              103,
              0
            ],
            [
              111,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMallocZeroDefaultFn",
            "parameters": {
              "ContextID": "cmsContext",
              "size": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid _cmsFreeDefaultFn(cmsContext ContextID, void *Ptr)\n{\n    // free(NULL) is defined a no-op by C99, therefore it is safe to\n    // avoid the check, but it is here just in case...\n\n    if (Ptr) free(Ptr);\n\n    cmsUNUSED_PARAMETER(ContextID);\n}",
          "fn_code_pos": [
            [
              115,
              0
            ],
            [
              124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsFreeDefaultFn",
            "parameters": {
              "ContextID": "cmsContext",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* _cmsReallocDefaultFn(cmsContext ContextID, void* Ptr, cmsUInt32Number size)\n{\n\n    if (size > MAX_MEMORY_FOR_ALLOC) return NULL;  // Never realloc over 512Mb\n\n    return realloc(Ptr, size);\n\n    cmsUNUSED_PARAMETER(ContextID);\n}",
          "fn_code_pos": [
            [
              128,
              0
            ],
            [
              137,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReallocDefaultFn",
            "parameters": {
              "ContextID": "cmsContext",
              "Ptr": "void",
              "size": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* _cmsCallocDefaultFn(cmsContext ContextID, cmsUInt32Number num, cmsUInt32Number size)\n{\n    cmsUInt32Number Total = num * size;\n\n    // Preserve calloc behaviour\n    if (Total == 0) return NULL;\n\n    // Safe check for overflow.\n    if (num >= UINT_MAX / size) return NULL;\n\n    // Check for overflow\n    if (Total < num || Total < size) {\n        return NULL;\n    }\n\n    if (Total > MAX_MEMORY_FOR_ALLOC) return NULL;  // Never alloc over 512Mb\n\n    return _cmsMallocZero(ContextID, Total);\n}",
          "fn_code_pos": [
            [
              142,
              0
            ],
            [
              161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsCallocDefaultFn",
            "parameters": {
              "ContextID": "cmsContext",
              "num": "cmsUInt32Number",
              "size": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* _cmsDupDefaultFn(cmsContext ContextID, const void* Org, cmsUInt32Number size)\n{\n    void* mem;\n\n    if (size > MAX_MEMORY_FOR_ALLOC) return NULL;  // Never dup over 512Mb\n\n    mem = _cmsMalloc(ContextID, size);\n\n    if (mem != NULL && Org != NULL)\n        memmove(mem, Org, size);\n\n    return mem;\n}",
          "fn_code_pos": [
            [
              164,
              0
            ],
            [
              177,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsDupDefaultFn",
            "parameters": {
              "ContextID": "cmsContext",
              "Org": "void",
              "size": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void _cmsAllocMemPluginChunk(struct _cmsContext_struct* ctx, const struct _cmsContext_struct* src)\n{\n    _cmsAssert(ctx != NULL);\n\n    if (src != NULL) {    \n\n        // Duplicate\n        ctx ->chunks[MemPlugin] = _cmsSubAllocDup(ctx ->MemPool, src ->chunks[MemPlugin], sizeof(_cmsMemPluginChunkType));  \n    }\n    else {\n\n        // To reset it, we use the default allocators, which cannot be overridden\n        ctx ->chunks[MemPlugin] = &ctx ->DefaultMemoryManager;\n    } \n}",
          "fn_code_pos": [
            [
              187,
              0
            ],
            [
              201,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocMemPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void _cmsInstallAllocFunctions(cmsPluginMemHandler* Plugin, _cmsMemPluginChunkType* ptr)\n{\n    if (Plugin == NULL) {\n\n        memcpy(ptr, &_cmsMemPluginChunk, sizeof(_cmsMemPluginChunk));\n    }\n    else {\n\n        ptr ->MallocPtr  = Plugin -> MallocPtr;\n        ptr ->FreePtr    = Plugin -> FreePtr;\n        ptr ->ReallocPtr = Plugin -> ReallocPtr;\n\n        // Make sure we revert to defaults\n        ptr ->MallocZeroPtr= _cmsMallocZeroDefaultFn;\n        ptr ->CallocPtr    = _cmsCallocDefaultFn;\n        ptr ->DupPtr       = _cmsDupDefaultFn;\n      \n        if (Plugin ->MallocZeroPtr != NULL) ptr ->MallocZeroPtr = Plugin -> MallocZeroPtr;\n        if (Plugin ->CallocPtr != NULL)     ptr ->CallocPtr     = Plugin -> CallocPtr;\n        if (Plugin ->DupPtr != NULL)        ptr ->DupPtr        = Plugin -> DupPtr;\n        \n    }\n}",
          "fn_code_pos": [
            [
              204,
              0
            ],
            [
              226,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsInstallAllocFunctions",
            "parameters": {
              "Plugin": "cmsPluginMemHandler",
              "ptr": "_cmsMemPluginChunkType"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool  _cmsRegisterMemHandlerPlugin(cmsContext ContextID, cmsPluginBase *Data)\n{\n    cmsPluginMemHandler* Plugin = (cmsPluginMemHandler*) Data;     \n    _cmsMemPluginChunkType* ptr;\n\n    // NULL forces to reset to defaults. In this special case, the defaults are stored in the context structure. \n    // Remaining plug-ins does NOT have any copy in the context structure, but this is somehow special as the\n    // context internal data should be malloc'ed by using those functions. \n    if (Data == NULL) {\n\n       struct _cmsContext_struct* ctx = ( struct _cmsContext_struct*) ContextID;\n\n       // Return to the default allocators\n        if (ContextID != NULL) {\n            ctx->chunks[MemPlugin] = (void*) &ctx->DefaultMemoryManager;\n        }\n        return TRUE;\n    }\n\n    // Check for required callbacks\n    if (Plugin -> MallocPtr == NULL ||\n        Plugin -> FreePtr == NULL ||\n        Plugin -> ReallocPtr == NULL) return FALSE;\n\n    // Set replacement functions\n    ptr = (_cmsMemPluginChunkType*) _cmsContextGetClientChunk(ContextID, MemPlugin);\n    if (ptr == NULL) \n        return FALSE;\n\n    _cmsInstallAllocFunctions(Plugin, ptr);\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              230,
              0
            ],
            [
              261,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterMemHandlerPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Data": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "void* CMSEXPORT _cmsMalloc(cmsContext ContextID, cmsUInt32Number size)\n{\n    _cmsMemPluginChunkType* ptr = (_cmsMemPluginChunkType*) _cmsContextGetClientChunk(ContextID, MemPlugin);\n    return ptr ->MallocPtr(ContextID, size);\n}",
          "fn_code_pos": [
            [
              264,
              0
            ],
            [
              268,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMalloc",
            "parameters": {
              "ContextID": "cmsContext",
              "size": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void* CMSEXPORT _cmsMallocZero(cmsContext ContextID, cmsUInt32Number size)\n{\n    _cmsMemPluginChunkType* ptr = (_cmsMemPluginChunkType*) _cmsContextGetClientChunk(ContextID, MemPlugin);\n    return ptr->MallocZeroPtr(ContextID, size);\n}",
          "fn_code_pos": [
            [
              271,
              0
            ],
            [
              275,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMallocZero",
            "parameters": {
              "ContextID": "cmsContext",
              "size": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void* CMSEXPORT _cmsCalloc(cmsContext ContextID, cmsUInt32Number num, cmsUInt32Number size)\n{\n    _cmsMemPluginChunkType* ptr = (_cmsMemPluginChunkType*) _cmsContextGetClientChunk(ContextID, MemPlugin);\n    return ptr->CallocPtr(ContextID, num, size);\n}",
          "fn_code_pos": [
            [
              278,
              0
            ],
            [
              282,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsCalloc",
            "parameters": {
              "ContextID": "cmsContext",
              "num": "cmsUInt32Number",
              "size": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void* CMSEXPORT _cmsRealloc(cmsContext ContextID, void* Ptr, cmsUInt32Number size)\n{\n    _cmsMemPluginChunkType* ptr = (_cmsMemPluginChunkType*) _cmsContextGetClientChunk(ContextID, MemPlugin);\n    return ptr->ReallocPtr(ContextID, Ptr, size);\n}",
          "fn_code_pos": [
            [
              285,
              0
            ],
            [
              289,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRealloc",
            "parameters": {
              "ContextID": "cmsContext",
              "Ptr": "void",
              "size": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT _cmsFree(cmsContext ContextID, void* Ptr)\n{\n    if (Ptr != NULL) {\n        _cmsMemPluginChunkType* ptr = (_cmsMemPluginChunkType*) _cmsContextGetClientChunk(ContextID, MemPlugin);\n        ptr ->FreePtr(ContextID, Ptr);\n    }\n}",
          "fn_code_pos": [
            [
              292,
              0
            ],
            [
              298,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsFree",
            "parameters": {
              "ContextID": "cmsContext",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void* CMSEXPORT _cmsDupMem(cmsContext ContextID, const void* Org, cmsUInt32Number size)\n{\n    _cmsMemPluginChunkType* ptr = (_cmsMemPluginChunkType*) _cmsContextGetClientChunk(ContextID, MemPlugin);\n    return ptr ->DupPtr(ContextID, Org, size);\n}",
          "fn_code_pos": [
            [
              301,
              0
            ],
            [
              305,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsDupMem",
            "parameters": {
              "ContextID": "cmsContext",
              "Org": "void",
              "size": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\n_cmsSubAllocator_chunk* _cmsCreateSubAllocChunk(cmsContext ContextID, cmsUInt32Number Initial)\n{\n    _cmsSubAllocator_chunk* chunk;\n\n    // 20K by default\n    if (Initial == 0)\n        Initial = 20*1024;\n\n    // Create the container\n    chunk = (_cmsSubAllocator_chunk*) _cmsMallocZero(ContextID, sizeof(_cmsSubAllocator_chunk));\n    if (chunk == NULL) return NULL;\n\n    // Initialize values\n    chunk ->Block     = (cmsUInt8Number*) _cmsMalloc(ContextID, Initial);\n    if (chunk ->Block == NULL) {\n\n        // Something went wrong\n        _cmsFree(ContextID, chunk);\n        return NULL;\n    }\n\n    chunk ->BlockSize = Initial;\n    chunk ->Used      = 0;\n    chunk ->next      = NULL;\n\n    return chunk;\n}",
          "fn_code_pos": [
            [
              313,
              0
            ],
            [
              340,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsCreateSubAllocChunk",
            "parameters": {
              "ContextID": "cmsContext",
              "Initial": "cmsUInt32Number"
            },
            "return_type": "_cmsSubAllocator_chunk"
          }
        },
        {
          "fn_code": "_cmsSubAllocator* _cmsCreateSubAlloc(cmsContext ContextID, cmsUInt32Number Initial)\n{\n    _cmsSubAllocator* sub;\n\n    // Create the container\n    sub = (_cmsSubAllocator*) _cmsMallocZero(ContextID, sizeof(_cmsSubAllocator));\n    if (sub == NULL) return NULL;\n\n    sub ->ContextID = ContextID;\n\n    sub ->h = _cmsCreateSubAllocChunk(ContextID, Initial);\n    if (sub ->h == NULL) {\n        _cmsFree(ContextID, sub);\n        return NULL;\n    }\n\n    return sub;\n}",
          "fn_code_pos": [
            [
              344,
              0
            ],
            [
              361,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsCreateSubAlloc",
            "parameters": {
              "ContextID": "cmsContext",
              "Initial": "cmsUInt32Number"
            },
            "return_type": "_cmsSubAllocator"
          }
        },
        {
          "fn_code": "void _cmsSubAllocDestroy(_cmsSubAllocator* sub)\n{\n    _cmsSubAllocator_chunk *chunk, *n;\n\n    for (chunk = sub ->h; chunk != NULL; chunk = n) {\n\n        n = chunk->next;\n        if (chunk->Block != NULL) _cmsFree(sub ->ContextID, chunk->Block);\n        _cmsFree(sub ->ContextID, chunk);\n    }\n\n    // Free the header\n    _cmsFree(sub ->ContextID, sub);\n}",
          "fn_code_pos": [
            [
              365,
              0
            ],
            [
              378,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsSubAllocDestroy",
            "parameters": {
              "sub": "_cmsSubAllocator"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void*  _cmsSubAlloc(_cmsSubAllocator* sub, cmsUInt32Number size)\n{\n    cmsUInt32Number Free = sub -> h ->BlockSize - sub -> h -> Used;\n    cmsUInt8Number* ptr;\n\n    size = _cmsALIGNMEM(size);\n\n    // Check for memory. If there is no room, allocate a new chunk of double memory size.\n    if (size > Free) {\n\n        _cmsSubAllocator_chunk* chunk;\n        cmsUInt32Number newSize;\n\n        newSize = sub -> h ->BlockSize * 2;\n        if (newSize < size) newSize = size;\n\n        chunk = _cmsCreateSubAllocChunk(sub -> ContextID, newSize);\n        if (chunk == NULL) return NULL;\n\n        // Link list\n        chunk ->next = sub ->h;\n        sub ->h    = chunk;\n\n    }\n\n    ptr =  sub -> h ->Block + sub -> h ->Used;\n    sub -> h -> Used += size;\n\n    return (void*) ptr;\n}",
          "fn_code_pos": [
            [
              382,
              0
            ],
            [
              411,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsSubAlloc",
            "parameters": {
              "sub": "_cmsSubAllocator",
              "size": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void* _cmsSubAllocDup(_cmsSubAllocator* s, const void *ptr, cmsUInt32Number size)\n{\n    void *NewPtr;\n    \n    // Dup of null pointer is also NULL\n    if (ptr == NULL)\n        return NULL;\n\n    NewPtr = _cmsSubAlloc(s, size);\n\n    if (ptr != NULL && NewPtr != NULL) {\n        memcpy(NewPtr, ptr, size);\n    }\n\n    return NewPtr;\n}",
          "fn_code_pos": [
            [
              414,
              0
            ],
            [
              429,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsSubAllocDup",
            "parameters": {
              "s": "_cmsSubAllocator",
              "ptr": "void",
              "size": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void _cmsAllocLogErrorChunk(struct _cmsContext_struct* ctx, \n                            const struct _cmsContext_struct* src)\n{    \n    static _cmsLogErrorChunkType LogErrorChunk = { DefaultLogErrorHandlerFunction };\n    void* from;\n     \n     if (src != NULL) {\n        from = src ->chunks[Logger];       \n    }\n    else {\n       from = &LogErrorChunk;\n    }\n    \n    ctx ->chunks[Logger] = _cmsSubAllocDup(ctx ->MemPool, from, sizeof(_cmsLogErrorChunkType));   \n}",
          "fn_code_pos": [
            [
              459,
              0
            ],
            [
              473,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocLogErrorChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid DefaultLogErrorHandlerFunction(cmsContext ContextID, cmsUInt32Number ErrorCode, const char *Text)\n{\n    // fprintf(stderr, \"[lcms]: %s\\n\", Text);\n    // fflush(stderr);\n\n     cmsUNUSED_PARAMETER(ContextID);\n     cmsUNUSED_PARAMETER(ErrorCode);\n     cmsUNUSED_PARAMETER(Text);\n}",
          "fn_code_pos": [
            [
              476,
              0
            ],
            [
              485,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DefaultLogErrorHandlerFunction",
            "parameters": {
              "ContextID": "cmsContext",
              "ErrorCode": "cmsUInt32Number",
              "Text": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsSetLogErrorHandlerTHR(cmsContext ContextID, cmsLogErrorHandlerFunction Fn)\n{\n    _cmsLogErrorChunkType* lhg = (_cmsLogErrorChunkType*) _cmsContextGetClientChunk(ContextID, Logger);\n\n    if (lhg != NULL) {\n\n        if (Fn == NULL)\n            lhg -> LogErrorHandler = DefaultLogErrorHandlerFunction;\n        else\n            lhg -> LogErrorHandler = Fn;\n    }\n}",
          "fn_code_pos": [
            [
              488,
              0
            ],
            [
              499,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetLogErrorHandlerTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "Fn": "cmsLogErrorHandlerFunction"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsSetLogErrorHandler(cmsLogErrorHandlerFunction Fn)\n{\n    cmsSetLogErrorHandlerTHR(NULL, Fn);    \n}",
          "fn_code_pos": [
            [
              502,
              0
            ],
            [
              505,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetLogErrorHandler",
            "parameters": {
              "Fn": "cmsLogErrorHandlerFunction"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsSignalError(cmsContext ContextID, cmsUInt32Number ErrorCode, const char *ErrorText, ...)\n{\n    va_list args;\n    char Buffer[MAX_ERROR_MESSAGE_LEN];\n    _cmsLogErrorChunkType* lhg;\n\n\n    va_start(args, ErrorText);\n    vsnprintf(Buffer, MAX_ERROR_MESSAGE_LEN-1, ErrorText, args);\n    va_end(args);\n\n    // Check for the context, if specified go there. If not, go for the global\n    lhg = (_cmsLogErrorChunkType*) _cmsContextGetClientChunk(ContextID, Logger);\n    if (lhg ->LogErrorHandler) {\n        lhg ->LogErrorHandler(ContextID, ErrorCode, Buffer);\n    }   \n}",
          "fn_code_pos": [
            [
              509,
              0
            ],
            [
              525,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSignalError",
            "parameters": {
              "ContextID": "cmsContext",
              "ErrorCode": "cmsUInt32Number",
              "ErrorText": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void _cmsTagSignature2String(char String[5], cmsTagSignature sig)\n{\n    cmsUInt32Number be;\n\n    // Convert to big endian\n    be = _cmsAdjustEndianess32((cmsUInt32Number) sig);\n\n    // Move chars\n    memmove(String, &be, 4);\n\n    // Make sure of terminator\n    String[4] = 0;\n}",
          "fn_code_pos": [
            [
              528,
              0
            ],
            [
              540,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsTagSignature2String",
            "parameters": {
              "String": "char",
              "sig": "cmsTagSignature"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* defMtxCreate(cmsContext id)\n{\n    _cmsMutex* ptr_mutex = (_cmsMutex*) _cmsMalloc(id, sizeof(_cmsMutex));\n    _cmsInitMutexPrimitive(ptr_mutex);\n    return (void*) ptr_mutex;   \n}",
          "fn_code_pos": [
            [
              545,
              0
            ],
            [
              551,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "defMtxCreate",
            "parameters": {
              "id": "cmsContext"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid defMtxDestroy(cmsContext id, void* mtx)\n{\n    _cmsDestroyMutexPrimitive((_cmsMutex *) mtx); \n    _cmsFree(id, mtx);\n}",
          "fn_code_pos": [
            [
              553,
              0
            ],
            [
              558,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "defMtxDestroy",
            "parameters": {
              "id": "cmsContext",
              "mtx": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool defMtxLock(cmsContext id, void* mtx)\n{\n    cmsUNUSED_PARAMETER(id);\n    return _cmsLockPrimitive((_cmsMutex *) mtx) == 0;     \n}",
          "fn_code_pos": [
            [
              560,
              0
            ],
            [
              565,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "defMtxLock",
            "parameters": {
              "id": "cmsContext",
              "mtx": "void"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid defMtxUnlock(cmsContext id, void* mtx)\n{\n    cmsUNUSED_PARAMETER(id);\n    _cmsUnlockPrimitive((_cmsMutex *) mtx); \n}",
          "fn_code_pos": [
            [
              567,
              0
            ],
            [
              572,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "defMtxUnlock",
            "parameters": {
              "id": "cmsContext",
              "mtx": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void _cmsAllocMutexPluginChunk(struct _cmsContext_struct* ctx, \n                                        const struct _cmsContext_struct* src)\n{\n    static _cmsMutexPluginChunkType MutexChunk = {defMtxCreate, defMtxDestroy, defMtxLock, defMtxUnlock };\n    void* from;\n     \n     if (src != NULL) {\n        from = src ->chunks[MutexPlugin];       \n    }\n    else {\n       from = &MutexChunk;\n    }\n    \n    ctx ->chunks[MutexPlugin] = _cmsSubAllocDup(ctx ->MemPool, from, sizeof(_cmsMutexPluginChunkType));   \n}",
          "fn_code_pos": [
            [
              580,
              0
            ],
            [
              594,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocMutexPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool  _cmsRegisterMutexPlugin(cmsContext ContextID, cmsPluginBase* Data)\n{\n    cmsPluginMutex* Plugin = (cmsPluginMutex*) Data;\n    _cmsMutexPluginChunkType* ctx = ( _cmsMutexPluginChunkType*) _cmsContextGetClientChunk(ContextID, MutexPlugin);\n\n    if (Data == NULL) {\n\n        // No lock routines\n        ctx->CreateMutexPtr = NULL; \n        ctx->DestroyMutexPtr = NULL; \n        ctx->LockMutexPtr = NULL;\n        ctx ->UnlockMutexPtr = NULL;\n        return TRUE;\n    }\n\n    // Factory callback is required\n    if (Plugin ->CreateMutexPtr == NULL || Plugin ->DestroyMutexPtr == NULL || \n        Plugin ->LockMutexPtr == NULL || Plugin ->UnlockMutexPtr == NULL) return FALSE;\n\n    ctx->CreateMutexPtr  = Plugin->CreateMutexPtr;\n    ctx->DestroyMutexPtr = Plugin ->DestroyMutexPtr;\n    ctx ->LockMutexPtr   = Plugin ->LockMutexPtr;\n    ctx ->UnlockMutexPtr = Plugin ->UnlockMutexPtr;\n\n    // All is ok\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              597,
              0
            ],
            [
              623,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterMutexPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Data": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "void* CMSEXPORT _cmsCreateMutex(cmsContext ContextID)\n{\n    _cmsMutexPluginChunkType* ptr = (_cmsMutexPluginChunkType*) _cmsContextGetClientChunk(ContextID, MutexPlugin);\n\n    if (ptr ->CreateMutexPtr == NULL) return NULL;\n\n    return ptr ->CreateMutexPtr(ContextID);\n}",
          "fn_code_pos": [
            [
              626,
              0
            ],
            [
              633,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsCreateMutex",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT _cmsDestroyMutex(cmsContext ContextID, void* mtx)\n{\n    _cmsMutexPluginChunkType* ptr = (_cmsMutexPluginChunkType*) _cmsContextGetClientChunk(ContextID, MutexPlugin);\n\n    if (ptr ->DestroyMutexPtr != NULL) {\n\n        ptr ->DestroyMutexPtr(ContextID, mtx);\n    }\n}",
          "fn_code_pos": [
            [
              635,
              0
            ],
            [
              643,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsDestroyMutex",
            "parameters": {
              "ContextID": "cmsContext",
              "mtx": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT _cmsLockMutex(cmsContext ContextID, void* mtx)\n{\n    _cmsMutexPluginChunkType* ptr = (_cmsMutexPluginChunkType*) _cmsContextGetClientChunk(ContextID, MutexPlugin);\n\n    if (ptr ->LockMutexPtr == NULL) return TRUE;\n\n    return ptr ->LockMutexPtr(ContextID, mtx);\n}",
          "fn_code_pos": [
            [
              645,
              0
            ],
            [
              652,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsLockMutex",
            "parameters": {
              "ContextID": "cmsContext",
              "mtx": "void"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "void CMSEXPORT _cmsUnlockMutex(cmsContext ContextID, void* mtx)\n{\n    _cmsMutexPluginChunkType* ptr = (_cmsMutexPluginChunkType*) _cmsContextGetClientChunk(ContextID, MutexPlugin);\n\n    if (ptr ->UnlockMutexPtr != NULL) {\n\n        ptr ->UnlockMutexPtr(ContextID, mtx);\n    }\n}",
          "fn_code_pos": [
            [
              654,
              0
            ],
            [
              662,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsUnlockMutex",
            "parameters": {
              "ContextID": "cmsContext",
              "mtx": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void _cmsAllocParallelizationPluginChunk(struct _cmsContext_struct* ctx,\n                                         const struct _cmsContext_struct* src)\n{    \n    if (src != NULL) {\n        void* from = src->chunks[ParallelizationPlugin];\n        ctx->chunks[ParallelizationPlugin] = _cmsSubAllocDup(ctx->MemPool, from, sizeof(_cmsParallelizationPluginChunkType));\n    }\n    else {        \n        _cmsParallelizationPluginChunkType ParallelizationPluginChunk = { 0 };\n        ctx->chunks[ParallelizationPlugin] = _cmsSubAllocDup(ctx->MemPool, &ParallelizationPluginChunk, sizeof(_cmsParallelizationPluginChunkType));\n    }         \n}",
          "fn_code_pos": [
            [
              668,
              0
            ],
            [
              679,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocParallelizationPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool _cmsRegisterParallelizationPlugin(cmsContext ContextID, cmsPluginBase* Data)\n{\n    cmsPluginParalellization* Plugin = (cmsPluginParalellization*)Data;\n    _cmsParallelizationPluginChunkType* ctx = (_cmsParallelizationPluginChunkType*)_cmsContextGetClientChunk(ContextID, ParallelizationPlugin);\n\n    if (Data == NULL) {\n\n        // No parallelization routines\n        ctx->MaxWorkers = 0;\n        ctx->WorkerFlags = 0;\n        ctx->SchedulerFn = NULL;        \n        return TRUE;\n    }\n\n    // callback is required\n    if (Plugin->SchedulerFn == NULL) return FALSE;\n\n    ctx->MaxWorkers = Plugin->MaxWorkers;\n    ctx->WorkerFlags = Plugin->WorkerFlags;\n    ctx->SchedulerFn = Plugin->SchedulerFn;\n    \n    // All is ok\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              682,
              0
            ],
            [
              705,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterParallelizationPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Data": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "_cmsRegisterMemHandlerPlugin(cmsContext ContextID, cmsPluginBase* Plugin)",
          "fn_dec_pos": [
            [
              85,
              10
            ],
            [
              85,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterMemHandlerPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Plugin": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsMallocDefaultFn(cmsContext ContextID, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              92,
              6
            ],
            [
              92,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMallocDefaultFn",
            "parameters": {
              "ContextID": "cmsContext",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsMallocZeroDefaultFn(cmsContext ContextID, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              104,
              6
            ],
            [
              104,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMallocZeroDefaultFn",
            "parameters": {
              "ContextID": "cmsContext",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsReallocDefaultFn(cmsContext ContextID, void* Ptr, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              129,
              6
            ],
            [
              129,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReallocDefaultFn",
            "parameters": {
              "ContextID": "cmsContext",
              "Ptr": "void",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsCallocDefaultFn(cmsContext ContextID, cmsUInt32Number num, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              143,
              6
            ],
            [
              143,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsCallocDefaultFn",
            "parameters": {
              "ContextID": "cmsContext",
              "num": "cmsUInt32Number",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsDupDefaultFn(cmsContext ContextID, const void* Org, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              165,
              6
            ],
            [
              165,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsDupDefaultFn",
            "parameters": {
              "ContextID": "cmsContext",
              "Org": "void",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsMalloc(cmsContext ContextID, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              264,
              16
            ],
            [
              264,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMalloc",
            "parameters": {
              "ContextID": "cmsContext",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsMallocZero(cmsContext ContextID, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              271,
              16
            ],
            [
              271,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMallocZero",
            "parameters": {
              "ContextID": "cmsContext",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsCalloc(cmsContext ContextID, cmsUInt32Number num, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              278,
              16
            ],
            [
              278,
              91
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsCalloc",
            "parameters": {
              "ContextID": "cmsContext",
              "num": "cmsUInt32Number",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsRealloc(cmsContext ContextID, void* Ptr, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              285,
              16
            ],
            [
              285,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRealloc",
            "parameters": {
              "ContextID": "cmsContext",
              "Ptr": "void",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsDupMem(cmsContext ContextID, const void* Org, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              301,
              16
            ],
            [
              301,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsDupMem",
            "parameters": {
              "ContextID": "cmsContext",
              "Org": "void",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsCreateSubAllocChunk(cmsContext ContextID, cmsUInt32Number Initial)",
          "fn_dec_pos": [
            [
              314,
              24
            ],
            [
              314,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsCreateSubAllocChunk",
            "parameters": {
              "ContextID": "cmsContext",
              "Initial": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsCreateSubAlloc(cmsContext ContextID, cmsUInt32Number Initial)",
          "fn_dec_pos": [
            [
              344,
              18
            ],
            [
              344,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsCreateSubAlloc",
            "parameters": {
              "ContextID": "cmsContext",
              "Initial": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsSubAlloc(_cmsSubAllocator* sub, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              382,
              7
            ],
            [
              382,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsSubAlloc",
            "parameters": {
              "sub": "_cmsSubAllocator",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsSubAllocDup(_cmsSubAllocator* s, const void *ptr, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              414,
              6
            ],
            [
              414,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsSubAllocDup",
            "parameters": {
              "s": "_cmsSubAllocator",
              "ptr": "void",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DefaultLogErrorHandlerFunction(cmsContext ContextID, cmsUInt32Number ErrorCode, const char *Text)",
          "fn_dec_pos": [
            [
              452,
              12
            ],
            [
              452,
              109
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DefaultLogErrorHandlerFunction",
            "parameters": {
              "ContextID": "cmsContext",
              "ErrorCode": "cmsUInt32Number",
              "Text": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "defMtxCreate(cmsContext id)",
          "fn_dec_pos": [
            [
              546,
              6
            ],
            [
              546,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "defMtxCreate",
            "parameters": {
              "id": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsCreateMutex(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              626,
              16
            ],
            [
              626,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsCreateMutex",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            187,
            29
          ],
          [
            187,
            54
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            187,
            67
          ],
          [
            187,
            92
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            240,
            7
          ],
          [
            240,
            32
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            240,
            42
          ],
          [
            240,
            67
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            459,
            28
          ],
          [
            459,
            53
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            460,
            34
          ],
          [
            460,
            59
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            580,
            31
          ],
          [
            580,
            56
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            581,
            46
          ],
          [
            581,
            71
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            668,
            41
          ],
          [
            668,
            66
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            669,
            47
          ],
          [
            669,
            72
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmstypes.c": {
      "fn_def_list": [
        {
          "fn_code": "static\ncmsBool RegisterTypesPlugin(cmsContext id, cmsPluginBase* Data, _cmsMemoryClient pos)\n{\n    cmsPluginTagType* Plugin = (cmsPluginTagType*) Data;\n    _cmsTagTypePluginChunkType* ctx = ( _cmsTagTypePluginChunkType*) _cmsContextGetClientChunk(id, pos);\n    _cmsTagTypeLinkedList *pt;\n\n    // Calling the function with NULL as plug-in would unregister the plug in.\n    if (Data == NULL) {\n\n        // There is no need to set free the memory, as pool is destroyed as a whole.\n        ctx ->TagTypes = NULL;\n        return TRUE;\n    }\n\n    // Registering happens in plug-in memory pool.\n    pt = (_cmsTagTypeLinkedList*) _cmsPluginMalloc(id, sizeof(_cmsTagTypeLinkedList));\n    if (pt == NULL) return FALSE;\n\n    pt ->Handler   = Plugin ->Handler;\n    pt ->Next      = ctx ->TagTypes;\n\n    ctx ->TagTypes = pt;\n     \n    return TRUE;\n}",
          "fn_code_pos": [
            [
              68,
              0
            ],
            [
              93,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RegisterTypesPlugin",
            "parameters": {
              "id": "cmsContext",
              "Data": "cmsPluginBase",
              "pos": "_cmsMemoryClient"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsTagTypeHandler* GetHandler(cmsTagTypeSignature sig, _cmsTagTypeLinkedList* PluginLinkedList, _cmsTagTypeLinkedList* DefaultLinkedList)\n{\n    _cmsTagTypeLinkedList* pt;\n\n    for (pt = PluginLinkedList;\n         pt != NULL;\n         pt = pt ->Next) {\n\n            if (sig == pt -> Handler.Signature) return &pt ->Handler;\n    }\n\n    for (pt = DefaultLinkedList;\n         pt != NULL;\n         pt = pt ->Next) {\n\n            if (sig == pt -> Handler.Signature) return &pt ->Handler;\n    }\n\n    return NULL;\n}",
          "fn_code_pos": [
            [
              97,
              0
            ],
            [
              117,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetHandler",
            "parameters": {
              "sig": "cmsTagTypeSignature",
              "PluginLinkedList": "_cmsTagTypeLinkedList",
              "DefaultLinkedList": "_cmsTagTypeLinkedList"
            },
            "return_type": "cmsTagTypeHandler"
          }
        },
        {
          "fn_code": "static\ncmsBool _cmsWriteWCharArray(cmsIOHANDLER* io, cmsUInt32Number n, const wchar_t* Array)\n{\n    cmsUInt32Number i;\n\n    _cmsAssert(io != NULL);\n    _cmsAssert(!(Array == NULL && n > 0));\n\n    for (i=0; i < n; i++) {\n        if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) Array[i])) return FALSE;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              134,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteWCharArray",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt32Number",
              "Array": "wchar_t"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsINLINE cmsBool is_surrogate(cmsUInt32Number uc) { return (uc - 0xd800u) < 2048u; }",
          "fn_code_pos": [
            [
              137,
              0
            ],
            [
              137,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "is_surrogate",
            "parameters": {
              "uc": "cmsUInt32Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE cmsBool is_high_surrogate(cmsUInt32Number uc) { return (uc & 0xfffffc00) == 0xd800; }",
          "fn_code_pos": [
            [
              138,
              0
            ],
            [
              138,
              95
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "is_high_surrogate",
            "parameters": {
              "uc": "cmsUInt32Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE cmsBool is_low_surrogate(cmsUInt32Number uc)  { return (uc & 0xfffffc00) == 0xdc00; }",
          "fn_code_pos": [
            [
              139,
              0
            ],
            [
              139,
              95
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "is_low_surrogate",
            "parameters": {
              "uc": "cmsUInt32Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE cmsUInt32Number surrogate_to_utf32(cmsUInt32Number high, cmsUInt32Number low)\n{\n    return (high << 10) + low - 0x35fdc00;\n}",
          "fn_code_pos": [
            [
              141,
              0
            ],
            [
              144,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsUInt32Number surrogate_to_utf32",
            "parameters": {
              "high": "cmsUInt32Number",
              "low": "cmsUInt32Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE cmsBool convert_utf16_to_utf32(cmsIOHANDLER* io, cmsInt32Number n, wchar_t* output)\n{\n    cmsUInt16Number uc;\n\n    while (n > 0)\n    {\n        if (!_cmsReadUInt16Number(io, &uc)) return FALSE;\n        n--;\n\n        if (!is_surrogate(uc))\n        {\n            *output++ = (wchar_t)uc;\n        }\n        else {\n\n            cmsUInt16Number low;\n\n            if (!_cmsReadUInt16Number(io, &low)) return FALSE;\n            n--;\n\n            if (is_high_surrogate(uc) && is_low_surrogate(low))\n                *output++ = (wchar_t)surrogate_to_utf32(uc, low);\n            else\n                return FALSE;   // Corrupted string, just ignore\n        }\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              146,
              0
            ],
            [
              174,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "convert_utf16_to_utf32",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsInt32Number",
              "output": "wchar_t"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "static\ncmsBool _cmsReadWCharArray(cmsIOHANDLER* io, cmsUInt32Number n, wchar_t* Array)\n{\n    cmsUInt32Number i;\n    cmsUInt16Number tmp;\n    cmsBool is32 = sizeof(wchar_t) > sizeof(cmsUInt16Number);\n\n    _cmsAssert(io != NULL);\n\n    if (is32 && Array != NULL)\n    {\n        return convert_utf16_to_utf32(io, n, Array);\n    }\n\n    for (i=0; i < n; i++) {\n\n        if (Array != NULL) {\n\n            if (!_cmsReadUInt16Number(io, &tmp)) return FALSE;\n            Array[i] = (wchar_t) tmp;\n        }\n        else {\n            if (!_cmsReadUInt16Number(io, NULL)) return FALSE;\n        }\n\n    }\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              178,
              0
            ],
            [
              205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadWCharArray",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt32Number",
              "Array": "wchar_t"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool ReadPositionTable(struct _cms_typehandler_struct* self,\n                              cmsIOHANDLER* io,\n                              cmsUInt32Number Count,\n                              cmsUInt32Number BaseOffset,\n                              void *Cargo,\n                              PositionTableEntryFn ElementFn)\n{\n    cmsUInt32Number i;\n    cmsUInt32Number *ElementOffsets = NULL, *ElementSizes = NULL;\n    cmsUInt32Number currentPosition;\n\n    currentPosition = io->Tell(io);\n\n    // Verify there is enough space left to read at least two cmsUInt32Number items for Count items.\n    if (((io->ReportedSize - currentPosition) / (2 * sizeof(cmsUInt32Number))) < Count)\n        return FALSE;\n\n    // Let's take the offsets to each element\n    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));\n    if (ElementOffsets == NULL) goto Error;\n\n    ElementSizes = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));\n    if (ElementSizes == NULL) goto Error;\n\n    for (i=0; i < Count; i++) {\n\n        if (!_cmsReadUInt32Number(io, &ElementOffsets[i])) goto Error;\n        if (!_cmsReadUInt32Number(io, &ElementSizes[i])) goto Error;\n\n        ElementOffsets[i] += BaseOffset;\n    }\n\n    // Seek to each element and read it\n    for (i=0; i < Count; i++) {\n\n        if (!io -> Seek(io, ElementOffsets[i])) goto Error;\n\n        // This is the reader callback\n        if (!ElementFn(self, io, Cargo, i, ElementSizes[i])) goto Error;\n    }\n\n    // Success\n    if (ElementOffsets != NULL) _cmsFree(io ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(io ->ContextID, ElementSizes);\n    return TRUE;\n\nError:\n    if (ElementOffsets != NULL) _cmsFree(io ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(io ->ContextID, ElementSizes);\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              217,
              0
            ],
            [
              268,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadPositionTable",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Count": "cmsUInt32Number",
              "BaseOffset": "cmsUInt32Number",
              "Cargo": "void",
              "ElementFn": "PositionTableEntryFn"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool WritePositionTable(struct _cms_typehandler_struct* self,\n                               cmsIOHANDLER* io,\n                               cmsUInt32Number SizeOfTag,\n                               cmsUInt32Number Count,\n                               cmsUInt32Number BaseOffset,\n                               void *Cargo,\n                               PositionTableEntryFn ElementFn)\n{\n    cmsUInt32Number i;\n    cmsUInt32Number DirectoryPos, CurrentPos, Before;\n    cmsUInt32Number *ElementOffsets = NULL, *ElementSizes = NULL;\n\n     // Create table\n    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));\n    if (ElementOffsets == NULL) goto Error;\n\n    ElementSizes = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));\n    if (ElementSizes == NULL) goto Error;\n\n    // Keep starting position of curve offsets\n    DirectoryPos = io ->Tell(io);\n  \n    // Write a fake directory to be filled latter on\n    for (i=0; i < Count; i++) {\n\n        if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // Offset\n        if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // size\n    }\n\n    // Write each element. Keep track of the size as well.\n    for (i=0; i < Count; i++) {\n\n        Before = io ->Tell(io);\n        ElementOffsets[i] = Before - BaseOffset;\n\n        // Callback to write...\n        if (!ElementFn(self, io, Cargo, i, SizeOfTag)) goto Error;\n\n        // Now the size\n        ElementSizes[i] = io ->Tell(io) - Before;\n    }\n\n    // Write the directory\n    CurrentPos = io ->Tell(io);\n    if (!io ->Seek(io, DirectoryPos)) goto Error;\n\n    for (i=0; i <  Count; i++) {\n        if (!_cmsWriteUInt32Number(io, ElementOffsets[i])) goto Error;\n        if (!_cmsWriteUInt32Number(io, ElementSizes[i])) goto Error;\n    }\n\n    if (!io ->Seek(io, CurrentPos)) goto Error;\n\n    if (ElementOffsets != NULL) _cmsFree(io ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(io ->ContextID, ElementSizes);\n    return TRUE;\n\nError:\n    if (ElementOffsets != NULL) _cmsFree(io ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(io ->ContextID, ElementSizes);\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              271,
              0
            ],
            [
              333,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WritePositionTable",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "SizeOfTag": "cmsUInt32Number",
              "Count": "cmsUInt32Number",
              "BaseOffset": "cmsUInt32Number",
              "Cargo": "void",
              "ElementFn": "PositionTableEntryFn"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid *Type_XYZ_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsCIEXYZ* xyz;\n\n    *nItems = 0;\n    xyz = (cmsCIEXYZ*) _cmsMallocZero(self ->ContextID, sizeof(cmsCIEXYZ));\n    if (xyz == NULL) return NULL;\n\n    if (!_cmsReadXYZNumber(io, xyz)) {\n        _cmsFree(self ->ContextID, xyz);\n        return NULL;\n    }\n\n    *nItems = 1;\n    return (void*) xyz;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              345,
              0
            ],
            [
              363,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_XYZ_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  Type_XYZ_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    return _cmsWriteXYZNumber(io, (cmsCIEXYZ*) Ptr);\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              365,
              0
            ],
            [
              372,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_XYZ_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_XYZ_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsCIEXYZ));\n\n    cmsUNUSED_PARAMETER(n);\n}",
          "fn_code_pos": [
            [
              374,
              0
            ],
            [
              380,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_XYZ_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_XYZ_Free(struct _cms_typehandler_struct* self, void *Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}",
          "fn_code_pos": [
            [
              382,
              0
            ],
            [
              386,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_XYZ_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsTagTypeSignature DecideXYZtype(cmsFloat64Number ICCVersion, const void *Data)\n{\n    return cmsSigXYZType;\n\n    cmsUNUSED_PARAMETER(ICCVersion);\n    cmsUNUSED_PARAMETER(Data);\n}",
          "fn_code_pos": [
            [
              389,
              0
            ],
            [
              396,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DecideXYZtype",
            "parameters": {
              "ICCVersion": "cmsFloat64Number",
              "Data": "void"
            },
            "return_type": "cmsTagTypeSignature"
          }
        },
        {
          "fn_code": "static\nvoid *Type_Chromaticity_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsCIExyYTRIPLE* chrm;\n    cmsUInt16Number nChans, Table;\n\n    *nItems = 0;\n    chrm =  (cmsCIExyYTRIPLE*) _cmsMallocZero(self ->ContextID, sizeof(cmsCIExyYTRIPLE));\n    if (chrm == NULL) return NULL;\n\n    if (!_cmsReadUInt16Number(io, &nChans)) goto Error;\n\n    // Let's recover from a bug introduced in early versions of lcms1\n    if (nChans == 0 && SizeOfTag == 32) {\n\n        if (!_cmsReadUInt16Number(io, NULL)) goto Error;\n        if (!_cmsReadUInt16Number(io, &nChans)) goto Error;\n    }\n\n    if (nChans != 3) goto Error;\n\n    if (!_cmsReadUInt16Number(io, &Table)) goto Error;\n\n    if (!_cmsRead15Fixed16Number(io, &chrm ->Red.x)) goto Error;\n    if (!_cmsRead15Fixed16Number(io, &chrm ->Red.y)) goto Error;\n\n    chrm ->Red.Y = 1.0;\n\n    if (!_cmsRead15Fixed16Number(io, &chrm ->Green.x)) goto Error;\n    if (!_cmsRead15Fixed16Number(io, &chrm ->Green.y)) goto Error;\n\n    chrm ->Green.Y = 1.0;\n\n    if (!_cmsRead15Fixed16Number(io, &chrm ->Blue.x)) goto Error;\n    if (!_cmsRead15Fixed16Number(io, &chrm ->Blue.y)) goto Error;\n\n    chrm ->Blue.Y = 1.0;\n\n    *nItems = 1;\n    return (void*) chrm;\n\nError:\n    _cmsFree(self ->ContextID, (void*) chrm);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              405,
              0
            ],
            [
              451,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Chromaticity_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  SaveOneChromaticity(cmsFloat64Number x, cmsFloat64Number y, cmsIOHANDLER* io)\n{\n    if (!_cmsWriteUInt32Number(io, (cmsUInt32Number) _cmsDoubleTo15Fixed16(x))) return FALSE;\n    if (!_cmsWriteUInt32Number(io, (cmsUInt32Number) _cmsDoubleTo15Fixed16(y))) return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              453,
              0
            ],
            [
              460,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SaveOneChromaticity",
            "parameters": {
              "x": "cmsFloat64Number",
              "y": "cmsFloat64Number",
              "io": "cmsIOHANDLER"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool  Type_Chromaticity_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsCIExyYTRIPLE* chrm = (cmsCIExyYTRIPLE*) Ptr;\n\n    if (!_cmsWriteUInt16Number(io, 3)) return FALSE;        // nChannels\n    if (!_cmsWriteUInt16Number(io, 0)) return FALSE;        // Table\n\n    if (!SaveOneChromaticity(chrm -> Red.x,   chrm -> Red.y, io)) return FALSE;\n    if (!SaveOneChromaticity(chrm -> Green.x, chrm -> Green.y, io)) return FALSE;\n    if (!SaveOneChromaticity(chrm -> Blue.x,  chrm -> Blue.y, io)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              462,
              0
            ],
            [
              478,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Chromaticity_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_Chromaticity_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsCIExyYTRIPLE));\n\n    cmsUNUSED_PARAMETER(n);\n}",
          "fn_code_pos": [
            [
              480,
              0
            ],
            [
              486,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Chromaticity_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_Chromaticity_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}",
          "fn_code_pos": [
            [
              488,
              0
            ],
            [
              492,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Chromaticity_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid *Type_ColorantOrderType_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt8Number* ColorantOrder;\n    cmsUInt32Number Count;\n\n    *nItems = 0;\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n    if (Count > cmsMAXCHANNELS) return NULL;\n\n    ColorantOrder = (cmsUInt8Number*) _cmsCalloc(self ->ContextID, cmsMAXCHANNELS, sizeof(cmsUInt8Number));\n    if (ColorantOrder == NULL) return NULL;\n\n    // We use FF as end marker\n    memset(ColorantOrder, 0xFF, cmsMAXCHANNELS * sizeof(cmsUInt8Number));\n\n    if (io ->Read(io, ColorantOrder, sizeof(cmsUInt8Number), Count) != Count) {\n\n        _cmsFree(self ->ContextID, (void*) ColorantOrder);\n        return NULL;\n    }\n\n    *nItems = 1;\n    return (void*) ColorantOrder;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              507,
              0
            ],
            [
              533,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ColorantOrderType_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_ColorantOrderType_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt8Number*  ColorantOrder = (cmsUInt8Number*) Ptr;\n    cmsUInt32Number i, sz, Count;\n\n    // Get the length\n    for (Count=i=0; i < cmsMAXCHANNELS; i++) {\n        if (ColorantOrder[i] != 0xFF) Count++;\n    }\n\n    if (!_cmsWriteUInt32Number(io, Count)) return FALSE;\n\n    sz = Count * sizeof(cmsUInt8Number);\n    if (!io -> Write(io, sz, ColorantOrder)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              535,
              0
            ],
            [
              555,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ColorantOrderType_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_ColorantOrderType_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, cmsMAXCHANNELS * sizeof(cmsUInt8Number));\n\n    cmsUNUSED_PARAMETER(n);\n}",
          "fn_code_pos": [
            [
              557,
              0
            ],
            [
              563,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ColorantOrderType_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_ColorantOrderType_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}",
          "fn_code_pos": [
            [
              566,
              0
            ],
            [
              570,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ColorantOrderType_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* Type_UInt8_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt8Number* array;\n    cmsUInt32Number i, n;\n\n    *nItems = 0;\n    n = SizeOfTag / sizeof(cmsUInt8Number);\n    array = (cmsUInt8Number*)_cmsCalloc(self->ContextID, n, sizeof(cmsUInt8Number));\n    if (array == NULL) return NULL;\n\n    for (i = 0; i < n; i++) {\n\n        if (!_cmsReadUInt8Number(io, &array[i])) {\n\n            _cmsFree(self->ContextID, array);\n            return NULL;\n        }\n    }\n\n    *nItems = n;\n    return (void*)array;\n}",
          "fn_code_pos": [
            [
              577,
              0
            ],
            [
              599,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UInt8_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_UInt8_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt8Number* Value = (cmsUInt8Number*)Ptr;\n    cmsUInt32Number i;\n\n    for (i = 0; i < nItems; i++) {\n\n        if (!_cmsWriteUInt8Number(io, Value[i])) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              601,
              0
            ],
            [
              615,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UInt8_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_UInt8_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self->ContextID, Ptr, n * sizeof(cmsUInt8Number));\n}",
          "fn_code_pos": [
            [
              617,
              0
            ],
            [
              621,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UInt8_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_UInt8_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self->ContextID, Ptr);\n}",
          "fn_code_pos": [
            [
              624,
              0
            ],
            [
              628,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UInt8_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* Type_UInt32_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt32Number* array;\n    cmsUInt32Number i, n;\n\n    *nItems = 0;\n    n = SizeOfTag / sizeof(cmsUInt32Number);\n    array = (cmsUInt32Number*)_cmsCalloc(self->ContextID, n, sizeof(cmsUInt32Number));\n    if (array == NULL) return NULL;\n\n    for (i = 0; i < n; i++) {\n\n        if (!_cmsReadUInt32Number(io, &array[i])) {\n\n            _cmsFree(self->ContextID, array);\n            return NULL;\n        }\n    }\n\n    *nItems = n;\n    return (void*)array;\n}",
          "fn_code_pos": [
            [
              634,
              0
            ],
            [
              656,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UInt32_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_UInt32_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt32Number* Value = (cmsUInt32Number*)Ptr;\n    cmsUInt32Number i;\n\n    for (i = 0; i < nItems; i++) {\n\n        if (!_cmsWriteUInt32Number(io, Value[i])) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              658,
              0
            ],
            [
              672,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UInt32_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_UInt32_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self->ContextID, Ptr, n * sizeof(cmsUInt32Number));\n}",
          "fn_code_pos": [
            [
              674,
              0
            ],
            [
              678,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UInt32_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_UInt32_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self->ContextID, Ptr);\n}",
          "fn_code_pos": [
            [
              681,
              0
            ],
            [
              685,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UInt32_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* Type_UInt64_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt64Number* array;\n    cmsUInt32Number i, n;\n\n    *nItems = 0;\n    n = SizeOfTag / sizeof(cmsUInt64Number);\n    array = (cmsUInt64Number*)_cmsCalloc(self->ContextID, n, sizeof(cmsUInt64Number));\n    if (array == NULL) return NULL;\n\n    for (i = 0; i < n; i++) {\n\n        if (!_cmsReadUInt64Number(io, &array[i])) {\n\n            _cmsFree(self->ContextID, array);\n            return NULL;\n        }\n    }\n\n    *nItems = n;\n    return (void*)array;\n}",
          "fn_code_pos": [
            [
              691,
              0
            ],
            [
              713,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UInt64_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_UInt64_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt64Number* Value = (cmsUInt64Number*)Ptr;\n    cmsUInt32Number i;\n\n    for (i = 0; i < nItems; i++) {\n\n        if (!_cmsWriteUInt64Number(io, &Value[i])) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              715,
              0
            ],
            [
              729,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UInt64_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_UInt64_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self->ContextID, Ptr, n * sizeof(cmsUInt64Number));\n}",
          "fn_code_pos": [
            [
              731,
              0
            ],
            [
              735,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UInt64_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_UInt64_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self->ContextID, Ptr);\n}",
          "fn_code_pos": [
            [
              738,
              0
            ],
            [
              742,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UInt64_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid *Type_S15Fixed16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsFloat64Number*  array_double;\n    cmsUInt32Number i, n;\n\n    *nItems = 0;\n    n = SizeOfTag / sizeof(cmsUInt32Number);\n    array_double = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, n, sizeof(cmsFloat64Number));\n    if (array_double == NULL) return NULL;\n\n    for (i=0; i < n; i++) {\n\n        if (!_cmsRead15Fixed16Number(io, &array_double[i])) {\n\n            _cmsFree(self ->ContextID, array_double);\n            return NULL;\n        }\n    }\n\n    *nItems = n;\n    return (void*) array_double;\n}",
          "fn_code_pos": [
            [
              750,
              0
            ],
            [
              772,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_S15Fixed16_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_S15Fixed16_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsFloat64Number* Value = (cmsFloat64Number*) Ptr;\n    cmsUInt32Number i;\n\n    for (i=0; i < nItems; i++) {\n\n        if (!_cmsWrite15Fixed16Number(io, Value[i])) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              774,
              0
            ],
            [
              788,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_S15Fixed16_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_S15Fixed16_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, n * sizeof(cmsFloat64Number));\n}",
          "fn_code_pos": [
            [
              790,
              0
            ],
            [
              794,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_S15Fixed16_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_S15Fixed16_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}",
          "fn_code_pos": [
            [
              797,
              0
            ],
            [
              801,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_S15Fixed16_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid *Type_U16Fixed16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsFloat64Number*  array_double;\n    cmsUInt32Number v;\n    cmsUInt32Number i, n;\n\n    *nItems = 0;\n    n = SizeOfTag / sizeof(cmsUInt32Number);\n    array_double = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, n, sizeof(cmsFloat64Number));\n    if (array_double == NULL) return NULL;\n\n    for (i=0; i < n; i++) {\n\n        if (!_cmsReadUInt32Number(io, &v)) {\n            _cmsFree(self ->ContextID, (void*) array_double);\n            return NULL;\n        }\n\n        // Convert to cmsFloat64Number\n        array_double[i] =  (cmsFloat64Number) (v / 65536.0);\n    }\n\n    *nItems = n;\n    return (void*) array_double;\n}",
          "fn_code_pos": [
            [
              810,
              0
            ],
            [
              835,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_U16Fixed16_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_U16Fixed16_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsFloat64Number* Value = (cmsFloat64Number*) Ptr;\n    cmsUInt32Number i;\n\n    for (i=0; i < nItems; i++) {\n\n        cmsUInt32Number v = (cmsUInt32Number) floor(Value[i]*65536.0 + 0.5);\n\n        if (!_cmsWriteUInt32Number(io, v)) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              837,
              0
            ],
            [
              853,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_U16Fixed16_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_U16Fixed16_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, n * sizeof(cmsFloat64Number));\n}",
          "fn_code_pos": [
            [
              856,
              0
            ],
            [
              860,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_U16Fixed16_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_U16Fixed16_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}",
          "fn_code_pos": [
            [
              862,
              0
            ],
            [
              866,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_U16Fixed16_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid *Type_Signature_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsSignature* SigPtr = (cmsSignature*) _cmsMalloc(self ->ContextID, sizeof(cmsSignature));\n    if (SigPtr == NULL) return NULL;\n\n     if (!_cmsReadUInt32Number(io, SigPtr)) return NULL;\n     *nItems = 1;\n\n     return SigPtr;\n\n     cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              877,
              0
            ],
            [
              889,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Signature_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  Type_Signature_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsSignature* SigPtr = (cmsSignature*) Ptr;\n\n    return _cmsWriteUInt32Number(io, *SigPtr);\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              891,
              0
            ],
            [
              900,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Signature_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_Signature_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, n * sizeof(cmsSignature));\n}",
          "fn_code_pos": [
            [
              902,
              0
            ],
            [
              906,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Signature_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_Signature_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}",
          "fn_code_pos": [
            [
              908,
              0
            ],
            [
              912,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Signature_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid *Type_Text_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    char* Text = NULL;\n    cmsMLU* mlu = NULL;\n\n    // Create a container\n    mlu = cmsMLUalloc(self ->ContextID, 1);\n    if (mlu == NULL) return NULL;\n\n    *nItems = 0;\n\n    // We need to store the \"\\0\" at the end, so +1\n    if (SizeOfTag == UINT_MAX) goto Error;\n\n    Text = (char*) _cmsMalloc(self ->ContextID, SizeOfTag + 1);\n    if (Text == NULL) goto Error;\n\n    if (io -> Read(io, Text, sizeof(char), SizeOfTag) != SizeOfTag) goto Error;\n\n    // Make sure text is properly ended\n    Text[SizeOfTag] = 0;\n    *nItems = 1;\n\n    // Keep the result\n    if (!cmsMLUsetASCII(mlu, cmsNoLanguage, cmsNoCountry, Text)) goto Error;\n\n    _cmsFree(self ->ContextID, Text);\n    return (void*) mlu;\n\nError:\n    if (mlu != NULL)\n        cmsMLUfree(mlu);\n    if (Text != NULL)\n        _cmsFree(self ->ContextID, Text);\n\n    return NULL;\n}",
          "fn_code_pos": [
            [
              923,
              0
            ],
            [
              960,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Text_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_Text_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsMLU* mlu = (cmsMLU*) Ptr;\n    cmsUInt32Number size;\n    cmsBool  rc;\n    char* Text;\n\n    // Get the size of the string. Note there is an extra \"\\0\" at the end\n    size = cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry, NULL, 0);\n    if (size == 0) return FALSE;       // Cannot be zero!\n\n    // Create memory\n    Text = (char*) _cmsMalloc(self ->ContextID, size);\n    if (Text == NULL) return FALSE;\n\n    cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry, Text, size);\n\n    // Write it, including separator\n    rc = io ->Write(io, size, Text);\n\n    _cmsFree(self ->ContextID, Text);\n    return rc;\n\n    cmsUNUSED_PARAMETER(nItems);\n}",
          "fn_code_pos": [
            [
              963,
              0
            ],
            [
              988,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Text_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_Text_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsMLUdup((cmsMLU*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              990,
              0
            ],
            [
              997,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Text_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_Text_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsMLU* mlu = (cmsMLU*) Ptr;\n    cmsMLUfree(mlu);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              1000,
              0
            ],
            [
              1008,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Text_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsTagTypeSignature DecideTextType(cmsFloat64Number ICCVersion, const void *Data)\n{\n    if (ICCVersion >= 4.0)\n        return cmsSigMultiLocalizedUnicodeType;\n\n    return cmsSigTextType;\n\n    cmsUNUSED_PARAMETER(Data);\n}",
          "fn_code_pos": [
            [
              1010,
              0
            ],
            [
              1019,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DecideTextType",
            "parameters": {
              "ICCVersion": "cmsFloat64Number",
              "Data": "void"
            },
            "return_type": "cmsTagTypeSignature"
          }
        },
        {
          "fn_code": "static\nvoid *Type_Data_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsICCData* BinData;\n    cmsUInt32Number LenOfData;\n\n    *nItems = 0;\n\n    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;\n\n    LenOfData = SizeOfTag - sizeof(cmsUInt32Number);\n    if (LenOfData > INT_MAX) return NULL;\n\n    BinData = (cmsICCData*) _cmsMalloc(self ->ContextID, sizeof(cmsICCData) + LenOfData - 1);\n    if (BinData == NULL) return NULL;\n\n    BinData ->len = LenOfData;\n    if (!_cmsReadUInt32Number(io, &BinData->flag)) {\n        _cmsFree(self ->ContextID, BinData);\n        return NULL;\n    }\n\n    if (io -> Read(io, BinData ->data, sizeof(cmsUInt8Number), LenOfData) != LenOfData) {\n\n        _cmsFree(self ->ContextID, BinData);\n        return NULL;\n    }\n\n    *nItems = 1;\n\n    return (void*) BinData;\n}",
          "fn_code_pos": [
            [
              1027,
              0
            ],
            [
              1058,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Data_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_Data_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n   cmsICCData* BinData = (cmsICCData*) Ptr;\n\n   if (!_cmsWriteUInt32Number(io, BinData ->flag)) return FALSE;\n\n   return io ->Write(io, BinData ->len, BinData ->data);\n\n   cmsUNUSED_PARAMETER(nItems);\n   cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              1061,
              0
            ],
            [
              1072,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Data_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_Data_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    cmsICCData* BinData = (cmsICCData*) Ptr;\n\n    return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsICCData) + BinData ->len - 1);\n\n    cmsUNUSED_PARAMETER(n);\n}",
          "fn_code_pos": [
            [
              1075,
              0
            ],
            [
              1083,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Data_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_Data_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}",
          "fn_code_pos": [
            [
              1085,
              0
            ],
            [
              1089,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Data_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid *Type_Text_Description_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    char* Text = NULL;\n    wchar_t* UnicodeString = NULL;\n    cmsMLU* mlu = NULL;\n    cmsUInt32Number  AsciiCount;\n    cmsUInt32Number  i, UnicodeCode, UnicodeCount;\n    cmsUInt16Number  ScriptCodeCode, Dummy;\n    cmsUInt8Number   ScriptCodeCount;\n\n    *nItems = 0;\n\n    //  One dword should be there\n    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;\n\n    // Read len of ASCII\n    if (!_cmsReadUInt32Number(io, &AsciiCount)) return NULL;\n    SizeOfTag -= sizeof(cmsUInt32Number);\n\n    // Check for size\n    if (SizeOfTag < AsciiCount) return NULL;\n\n    // All seems Ok, allocate the container\n    mlu = cmsMLUalloc(self ->ContextID, 2);\n    if (mlu == NULL) return NULL;\n\n    // As many memory as size of tag\n    Text = (char*) _cmsMalloc(self ->ContextID, AsciiCount + 1);\n    if (Text == NULL) goto Error;\n\n    // Read it\n    if (io ->Read(io, Text, sizeof(char), AsciiCount) != AsciiCount) goto Error;\n    SizeOfTag -= AsciiCount;\n\n    // Make sure there is a terminator\n    Text[AsciiCount] = 0;\n\n    // Set the MLU entry. From here we can be tolerant to wrong types\n    if (!cmsMLUsetASCII(mlu, cmsNoLanguage, cmsNoCountry, Text)) goto Error;\n    _cmsFree(self ->ContextID, (void*) Text);\n    Text = NULL;\n\n    // Skip Unicode code\n    if (SizeOfTag < 2* sizeof(cmsUInt32Number)) goto Done;\n    if (!_cmsReadUInt32Number(io, &UnicodeCode)) goto Done;\n    if (!_cmsReadUInt32Number(io, &UnicodeCount)) goto Done;\n    SizeOfTag -= 2* sizeof(cmsUInt32Number);\n\n    if (UnicodeCount == 0 || SizeOfTag < UnicodeCount*sizeof(cmsUInt16Number)) goto Done;\n\n    UnicodeString = (wchar_t*)_cmsMallocZero(self->ContextID, (UnicodeCount + 1) * sizeof(wchar_t));\n    if (UnicodeString == NULL) goto Done;\n\n    if (!_cmsReadWCharArray(io, UnicodeCount, UnicodeString)) {\n        _cmsFree(self->ContextID, (void*)UnicodeString);\n        goto Done;\n    }\n\n    UnicodeString[UnicodeCount] = 0;\n\n    if (!cmsMLUsetWide(mlu, cmsV2Unicode, cmsV2Unicode, UnicodeString)) {\n        _cmsFree(self->ContextID, (void*)UnicodeString);\n        goto Done;\n    }\n\n    _cmsFree(self->ContextID, (void*)UnicodeString);\n    UnicodeString = NULL;\n\n    SizeOfTag -= UnicodeCount*sizeof(cmsUInt16Number);\n\n    // Skip ScriptCode code if present. Some buggy profiles does have less\n    // data that strictly required. We need to skip it as this type may come\n    // embedded in other types.\n\n    if (SizeOfTag >= sizeof(cmsUInt16Number) + sizeof(cmsUInt8Number) + 67) {\n\n        if (!_cmsReadUInt16Number(io, &ScriptCodeCode)) goto Done;\n        if (!_cmsReadUInt8Number(io,  &ScriptCodeCount)) goto Done;\n\n        // Skip rest of tag\n        for (i=0; i < 67; i++) {\n            if (!io ->Read(io, &Dummy, sizeof(cmsUInt8Number), 1)) goto Error;\n        }\n    }\n\nDone:\n\n    *nItems = 1;\n    return mlu;\n\nError:\n    if (UnicodeString)  _cmsFree(self->ContextID, (void*)UnicodeString);\n    if (Text) _cmsFree(self ->ContextID, (void*) Text);\n    if (mlu) cmsMLUfree(mlu);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              1095,
              0
            ],
            [
              1191,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Text_Description_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  Type_Text_Description_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsMLU* mlu = (cmsMLU*) Ptr;\n    char *Text = NULL;\n    wchar_t *Wide = NULL;\n    cmsUInt32Number len, len_text, len_tag_requirement, len_aligned;\n    cmsBool  rc = FALSE;\n    char Filler[68];\n\n    // Used below for writing zeroes\n    memset(Filler, 0, sizeof(Filler));\n\n    // Get the len of string\n    len = cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry, NULL, 0);\n\n    // Specification ICC.1:2001-04 (v2.4.0): It has been found that textDescriptionType can contain misaligned data\n    //(see clause 4.1 for the definition of 'aligned'). Because the Unicode language\n    // code and Unicode count immediately follow the ASCII description, their\n    // alignment is not correct if the ASCII count is not a multiple of four. The\n    // ScriptCode code is misaligned when the ASCII count is odd. Profile reading and\n    // writing software must be written carefully in order to handle these alignment\n    // problems.\n    //\n    // The above last sentence suggest to handle alignment issues in the\n    // parser. The provided example (Table 69 on Page 60) makes this clear. \n    // The padding only in the ASCII count is not sufficient for a aligned tag\n    // size, with the same text size in ASCII and Unicode.\n\n    // Null strings\n    if (len <= 0) {\n\n        Text = (char*)    _cmsDupMem(self ->ContextID, \"\", sizeof(char));\n        Wide = (wchar_t*) _cmsDupMem(self ->ContextID, L\"\", sizeof(wchar_t));\n    }\n    else {\n        // Create independent buffers\n        Text = (char*) _cmsCalloc(self ->ContextID, len, sizeof(char));\n        if (Text == NULL) goto Error;\n\n        Wide = (wchar_t*) _cmsCalloc(self ->ContextID, len, sizeof(wchar_t));\n        if (Wide == NULL) goto Error;\n\n        // Get both representations.\n        cmsMLUgetASCII(mlu, cmsNoLanguage, cmsNoCountry,  Text, len * sizeof(char));\n        cmsMLUgetWide(mlu,  cmsV2Unicode,  cmsV2Unicode,  Wide, len * sizeof(wchar_t));\n    }\n\n    // Tell the real text len including the null terminator and padding\n    len_text = (cmsUInt32Number) strlen(Text) + 1;\n    // Compute an total tag size requirement\n    len_tag_requirement = (8+4+len_text+4+4+2*len_text+2+1+67);\n    len_aligned = _cmsALIGNLONG(len_tag_requirement);\n\n  // * cmsUInt32Number       count;          * Description length\n  // * cmsInt8Number         desc[count]     * NULL terminated ascii string\n  // * cmsUInt32Number       ucLangCode;     * UniCode language code\n  // * cmsUInt32Number       ucCount;        * UniCode description length\n  // * cmsInt16Number        ucDesc[ucCount];* The UniCode description\n  // * cmsUInt16Number       scCode;         * ScriptCode code\n  // * cmsUInt8Number        scCount;        * ScriptCode count\n  // * cmsInt8Number         scDesc[67];     * ScriptCode Description\n\n    if (!_cmsWriteUInt32Number(io, len_text)) goto Error;\n    if (!io ->Write(io, len_text, Text)) goto Error;\n\n    if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // ucLanguageCode\n\n    if (!_cmsWriteUInt32Number(io, len_text)) goto Error;\n    // Note that in some compilers sizeof(cmsUInt16Number) != sizeof(wchar_t)\n    if (!_cmsWriteWCharArray(io, len_text, Wide)) goto Error;\n\n    // ScriptCode Code & count (unused)\n    if (!_cmsWriteUInt16Number(io, 0)) goto Error;\n    if (!_cmsWriteUInt8Number(io, 0)) goto Error;\n\n    if (!io ->Write(io, 67, Filler)) goto Error;\n\n    // possibly add pad at the end of tag\n    if(len_aligned - len_tag_requirement > 0)\n      if (!io ->Write(io, len_aligned - len_tag_requirement, Filler)) goto Error;\n\n    rc = TRUE;\n\nError:\n    if (Text) _cmsFree(self ->ContextID, Text);\n    if (Wide) _cmsFree(self ->ContextID, Wide);\n\n    return rc;\n\n    cmsUNUSED_PARAMETER(nItems);\n}",
          "fn_code_pos": [
            [
              1195,
              0
            ],
            [
              1286,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Text_Description_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_Text_Description_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsMLUdup((cmsMLU*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              1289,
              0
            ],
            [
              1296,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Text_Description_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_Text_Description_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsMLU* mlu = (cmsMLU*) Ptr;\n\n    cmsMLUfree(mlu);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              1298,
              0
            ],
            [
              1307,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Text_Description_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsTagTypeSignature DecideTextDescType(cmsFloat64Number ICCVersion, const void *Data)\n{\n    if (ICCVersion >= 4.0)\n        return cmsSigMultiLocalizedUnicodeType;\n\n    return cmsSigTextDescriptionType;\n\n    cmsUNUSED_PARAMETER(Data);\n}",
          "fn_code_pos": [
            [
              1310,
              0
            ],
            [
              1319,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DecideTextDescType",
            "parameters": {
              "ICCVersion": "cmsFloat64Number",
              "Data": "void"
            },
            "return_type": "cmsTagTypeSignature"
          }
        },
        {
          "fn_code": "static\nvoid *Type_Curve_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt32Number Count;\n    cmsToneCurve* NewGamma;\n    \n    *nItems = 0;\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n\n    switch (Count) {\n\n           case 0:   // Linear.\n               {\n                   cmsFloat64Number SingleGamma = 1.0;\n\n                   NewGamma = cmsBuildParametricToneCurve(self ->ContextID, 1, &SingleGamma);\n                   if (!NewGamma) return NULL;\n                   *nItems = 1;\n                   return NewGamma;\n               }\n              \n           case 1:  // Specified as the exponent of gamma function\n               {\n                   cmsUInt16Number SingleGammaFixed;\n                   cmsFloat64Number SingleGamma;\n\n                   if (!_cmsReadUInt16Number(io, &SingleGammaFixed)) return NULL;\n                   SingleGamma = _cms8Fixed8toDouble(SingleGammaFixed);\n\n                   *nItems = 1;\n                   return cmsBuildParametricToneCurve(self ->ContextID, 1, &SingleGamma);\n               }\n\n           default:  // Curve\n\n               if (Count > 0x7FFF)\n                   return NULL; // This is to prevent bad guys for doing bad things\n\n               NewGamma = cmsBuildTabulatedToneCurve16(self ->ContextID, Count, NULL);\n               if (!NewGamma) return NULL;\n\n               if (!_cmsReadUInt16Array(io, Count, NewGamma -> Table16)) {\n                   cmsFreeToneCurve(NewGamma);\n                   return NULL;\n               }\n\n               *nItems = 1;\n               return NewGamma;\n    }\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              1326,
              0
            ],
            [
              1377,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Curve_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  Type_Curve_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsToneCurve* Curve = (cmsToneCurve*) Ptr;\n\n    if (Curve ->nSegments == 1 && Curve ->Segments[0].Type == 1) {\n\n            // Single gamma, preserve number\n            cmsUInt16Number SingleGammaFixed = _cmsDoubleTo8Fixed8(Curve ->Segments[0].Params[0]);\n\n            if (!_cmsWriteUInt32Number(io, 1)) return FALSE;\n            if (!_cmsWriteUInt16Number(io, SingleGammaFixed)) return FALSE;\n            return TRUE;\n\n    }\n\n    if (!_cmsWriteUInt32Number(io, Curve ->nEntries)) return FALSE;\n    return _cmsWriteUInt16Array(io, Curve ->nEntries, Curve ->Table16);\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              1380,
              0
            ],
            [
              1401,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Curve_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_Curve_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsDupToneCurve((cmsToneCurve*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              1404,
              0
            ],
            [
              1411,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Curve_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_Curve_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsToneCurve* gamma = (cmsToneCurve*) Ptr;\n\n    cmsFreeToneCurve(gamma);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              1413,
              0
            ],
            [
              1422,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Curve_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsTagTypeSignature DecideCurveType(cmsFloat64Number ICCVersion, const void *Data)\n{\n    cmsToneCurve* Curve = (cmsToneCurve*) Data;\n\n    if (ICCVersion < 4.0) return cmsSigCurveType;\n    if (Curve ->nSegments != 1) return cmsSigCurveType;          // Only 1-segment curves can be saved as parametric\n    if (Curve ->Segments[0].Type < 0) return cmsSigCurveType;    // Only non-inverted curves\n    if (Curve ->Segments[0].Type > 5) return cmsSigCurveType;    // Only ICC parametric curves\n\n    return cmsSigParametricCurveType;\n}",
          "fn_code_pos": [
            [
              1431,
              0
            ],
            [
              1442,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DecideCurveType",
            "parameters": {
              "ICCVersion": "cmsFloat64Number",
              "Data": "void"
            },
            "return_type": "cmsTagTypeSignature"
          }
        },
        {
          "fn_code": "static\nvoid *Type_ParametricCurve_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    static const int ParamsByType[] = { 1, 3, 4, 5, 7 };\n    cmsFloat64Number Params[10];\n    cmsUInt16Number Type;\n    int i, n;\n    cmsToneCurve* NewGamma;\n\n    if (!_cmsReadUInt16Number(io, &Type)) return NULL;\n    if (!_cmsReadUInt16Number(io, NULL)) return NULL;   // Reserved\n\n    if (Type > 4) {\n\n        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown parametric curve type '%d'\", Type);\n        return NULL;\n    }\n\n    memset(Params, 0, sizeof(Params));\n    n = ParamsByType[Type];\n\n    for (i=0; i < n; i++) {\n\n        if (!_cmsRead15Fixed16Number(io, &Params[i])) return NULL;\n    }\n\n    NewGamma = cmsBuildParametricToneCurve(self ->ContextID, Type+1, Params);\n\n    *nItems = 1;\n    return NewGamma;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              1444,
              0
            ],
            [
              1476,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ParametricCurve_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  Type_ParametricCurve_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsToneCurve* Curve = (cmsToneCurve*) Ptr;\n    int i, nParams, typen;\n    static const int ParamsByType[] = { 0, 1, 3, 4, 5, 7 };\n\n    typen = Curve -> Segments[0].Type;\n\n    if (Curve ->nSegments > 1 || typen < 1) {\n\n        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Multisegment or Inverted parametric curves cannot be written\");\n        return FALSE;\n    }\n\n    if (typen > 5) {\n        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported parametric curve\");\n        return FALSE;\n    }\n\n    nParams = ParamsByType[typen];\n\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) (Curve ->Segments[0].Type - 1))) return FALSE;\n    if (!_cmsWriteUInt16Number(io, 0)) return FALSE;        // Reserved\n\n    for (i=0; i < nParams; i++) {\n\n        if (!_cmsWrite15Fixed16Number(io, Curve -> Segments[0].Params[i])) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}",
          "fn_code_pos": [
            [
              1479,
              0
            ],
            [
              1512,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ParametricCurve_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_ParametricCurve_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsDupToneCurve((cmsToneCurve*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              1514,
              0
            ],
            [
              1521,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ParametricCurve_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_ParametricCurve_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsToneCurve* gamma = (cmsToneCurve*) Ptr;\n\n    cmsFreeToneCurve(gamma);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              1523,
              0
            ],
            [
              1532,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ParametricCurve_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid *Type_DateTime_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsDateTimeNumber timestamp;\n    struct tm * NewDateTime;\n\n    *nItems = 0;\n    NewDateTime = (struct tm*) _cmsMalloc(self ->ContextID, sizeof(struct tm));\n    if (NewDateTime == NULL) return NULL;\n\n    if (io->Read(io, &timestamp, sizeof(cmsDateTimeNumber), 1) != 1) return NULL;\n\n     _cmsDecodeDateTimeNumber(&timestamp, NewDateTime);\n\n     *nItems = 1;\n     return NewDateTime;\n\n     cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              1549,
              0
            ],
            [
              1567,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_DateTime_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  Type_DateTime_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    struct tm * DateTime = (struct tm*) Ptr;\n    cmsDateTimeNumber timestamp;\n\n    _cmsEncodeDateTimeNumber(&timestamp, DateTime);\n    if (!io ->Write(io, sizeof(cmsDateTimeNumber), &timestamp)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              1570,
              0
            ],
            [
              1583,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_DateTime_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_DateTime_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, sizeof(struct tm));\n\n    cmsUNUSED_PARAMETER(n);\n}",
          "fn_code_pos": [
            [
              1585,
              0
            ],
            [
              1591,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_DateTime_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_DateTime_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}",
          "fn_code_pos": [
            [
              1593,
              0
            ],
            [
              1597,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_DateTime_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid *Type_Measurement_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsICCMeasurementConditions mc;\n\n    \n    memset(&mc, 0, sizeof(mc));\n    \n    if (!_cmsReadUInt32Number(io, &mc.Observer)) return NULL;\n    if (!_cmsReadXYZNumber(io,    &mc.Backing)) return NULL;\n    if (!_cmsReadUInt32Number(io, &mc.Geometry)) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &mc.Flare)) return NULL;\n    if (!_cmsReadUInt32Number(io, &mc.IlluminantType)) return NULL;\n\n    *nItems = 1;\n    return _cmsDupMem(self ->ContextID, &mc, sizeof(cmsICCMeasurementConditions));\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              1611,
              0
            ],
            [
              1629,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Measurement_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  Type_Measurement_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsICCMeasurementConditions* mc =(cmsICCMeasurementConditions*) Ptr;\n\n    if (!_cmsWriteUInt32Number(io, mc->Observer)) return FALSE;\n    if (!_cmsWriteXYZNumber(io,    &mc->Backing)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, mc->Geometry)) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, mc->Flare)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, mc->IlluminantType)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              1632,
              0
            ],
            [
              1647,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Measurement_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_Measurement_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n     return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsICCMeasurementConditions));\n\n     cmsUNUSED_PARAMETER(n);\n}",
          "fn_code_pos": [
            [
              1649,
              0
            ],
            [
              1655,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Measurement_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_Measurement_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n   _cmsFree(self ->ContextID, Ptr);\n}",
          "fn_code_pos": [
            [
              1657,
              0
            ],
            [
              1661,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Measurement_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid *Type_MLU_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsMLU* mlu;\n    cmsUInt32Number Count, RecLen, NumOfWchar;\n    cmsUInt32Number SizeOfHeader;\n    cmsUInt32Number  Len, Offset;\n    cmsUInt32Number  i;\n    wchar_t*         Block;\n    cmsUInt32Number  BeginOfThisString, EndOfThisString, LargestPosition;\n\n    *nItems = 0;\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n    if (!_cmsReadUInt32Number(io, &RecLen)) return NULL;\n\n    if (RecLen != 12) {\n\n        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"multiLocalizedUnicodeType of len != 12 is not supported.\");\n        return NULL;\n    }\n\n    mlu = cmsMLUalloc(self ->ContextID, Count);\n    if (mlu == NULL) return NULL;\n\n    mlu ->UsedEntries = Count;\n\n    SizeOfHeader = 12 * Count + sizeof(_cmsTagBase);\n    LargestPosition = 0;\n\n    for (i=0; i < Count; i++) {\n\n        if (!_cmsReadUInt16Number(io, &mlu ->Entries[i].Language)) goto Error;\n        if (!_cmsReadUInt16Number(io, &mlu ->Entries[i].Country))  goto Error;\n\n        // Now deal with Len and offset.\n        if (!_cmsReadUInt32Number(io, &Len)) goto Error;\n        if (!_cmsReadUInt32Number(io, &Offset)) goto Error;\n\n        // Offset MUST be even because it indexes a block of utf16 chars. \n        // Tricky profiles that uses odd positions will not work anyway\n        // because the whole utf16 block is previously converted to wchar_t \n        // and sizeof this type may be of 4 bytes. On Linux systems, for example.\n        if (Offset & 1) goto Error;\n\n        // Check for overflow\n        if (Offset < (SizeOfHeader + 8)) goto Error;        \n        if (((Offset + Len) < Len) || ((Offset + Len) > SizeOfTag + 8)) goto Error;\n\n        // True begin of the string\n        BeginOfThisString = Offset - SizeOfHeader - 8;\n\n        // Adjust to wchar_t elements\n        mlu ->Entries[i].Len = (Len * sizeof(wchar_t)) / sizeof(cmsUInt16Number);\n        mlu ->Entries[i].StrW = (BeginOfThisString * sizeof(wchar_t)) / sizeof(cmsUInt16Number);\n\n        // To guess maximum size, add offset + len\n        EndOfThisString = BeginOfThisString + Len;\n        if (EndOfThisString > LargestPosition)\n            LargestPosition = EndOfThisString;\n    }\n\n    // Now read the remaining of tag and fill all strings. Subtract the directory\n    SizeOfTag   = (LargestPosition * sizeof(wchar_t)) / sizeof(cmsUInt16Number);\n    if (SizeOfTag == 0)\n    {\n        Block = NULL;\n    }\n    else\n    {\n        // Make sure this is an even utf16 size.\n        if (SizeOfTag & 1) goto Error;\n\n        Block = (wchar_t*) _cmsCalloc(self ->ContextID, 1, SizeOfTag);\n        if (Block == NULL) goto Error;\n       \n        NumOfWchar = SizeOfTag / sizeof(wchar_t);\n        if (!_cmsReadWCharArray(io, NumOfWchar, Block)) {\n            _cmsFree(self->ContextID, Block);\n            goto Error;\n        }\n    }\n\n    mlu ->MemPool  = Block;\n    mlu ->PoolSize = SizeOfTag;\n    mlu ->PoolUsed = SizeOfTag;\n\n    *nItems = 1;\n    return (void*) mlu;\n\nError:\n    if (mlu) cmsMLUfree(mlu);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              1673,
              0
            ],
            [
              1765,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MLU_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  Type_MLU_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsMLU* mlu =(cmsMLU*) Ptr;\n    cmsUInt32Number HeaderSize;\n    cmsUInt32Number  Len, Offset;\n    cmsUInt32Number i;\n\n    if (Ptr == NULL) {\n\n          // Empty placeholder\n          if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n          if (!_cmsWriteUInt32Number(io, 12)) return FALSE;\n          return TRUE;\n    }\n\n    if (!_cmsWriteUInt32Number(io, mlu ->UsedEntries)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 12)) return FALSE;\n\n    HeaderSize = 12 * mlu ->UsedEntries + sizeof(_cmsTagBase);\n\n    for (i=0; i < mlu ->UsedEntries; i++) {\n\n        Len    =  mlu ->Entries[i].Len;\n        Offset =  mlu ->Entries[i].StrW;\n\n        Len    = (Len * sizeof(cmsUInt16Number)) / sizeof(wchar_t);\n        Offset = (Offset * sizeof(cmsUInt16Number)) / sizeof(wchar_t) + HeaderSize + 8;\n\n        if (!_cmsWriteUInt16Number(io, mlu ->Entries[i].Language)) return FALSE;\n        if (!_cmsWriteUInt16Number(io, mlu ->Entries[i].Country))  return FALSE;\n        if (!_cmsWriteUInt32Number(io, Len)) return FALSE;\n        if (!_cmsWriteUInt32Number(io, Offset)) return FALSE;\n    }\n\n    if (!_cmsWriteWCharArray(io, mlu ->PoolUsed / sizeof(wchar_t), (wchar_t*)  mlu ->MemPool)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              1767,
              0
            ],
            [
              1808,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MLU_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_MLU_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsMLUdup((cmsMLU*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              1811,
              0
            ],
            [
              1818,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MLU_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_MLU_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsMLUfree((cmsMLU*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              1820,
              0
            ],
            [
              1827,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MLU_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsTagTypeSignature DecideLUTtypeA2B(cmsFloat64Number ICCVersion, const void *Data)\n{\n    cmsPipeline* Lut = (cmsPipeline*) Data;\n\n    if (ICCVersion < 4.0) {\n        if (Lut ->SaveAs8Bits) return cmsSigLut8Type;\n        return cmsSigLut16Type;\n    }\n    else {\n         return cmsSigLutAtoBType;\n    }\n}",
          "fn_code_pos": [
            [
              1835,
              0
            ],
            [
              1847,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DecideLUTtypeA2B",
            "parameters": {
              "ICCVersion": "cmsFloat64Number",
              "Data": "void"
            },
            "return_type": "cmsTagTypeSignature"
          }
        },
        {
          "fn_code": "static\ncmsTagTypeSignature DecideLUTtypeB2A(cmsFloat64Number ICCVersion, const void *Data)\n{\n    cmsPipeline* Lut = (cmsPipeline*) Data;\n\n    if (ICCVersion < 4.0) {\n        if (Lut ->SaveAs8Bits) return cmsSigLut8Type;\n        return cmsSigLut16Type;\n    }\n    else {\n         return cmsSigLutBtoAType;\n    }\n}",
          "fn_code_pos": [
            [
              1849,
              0
            ],
            [
              1861,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DecideLUTtypeB2A",
            "parameters": {
              "ICCVersion": "cmsFloat64Number",
              "Data": "void"
            },
            "return_type": "cmsTagTypeSignature"
          }
        },
        {
          "fn_code": "static\ncmsBool  Read8bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsPipeline* lut, cmsUInt32Number nChannels)\n{\n    cmsUInt8Number* Temp = NULL;\n    cmsUInt32Number i, j;\n    cmsToneCurve* Tables[cmsMAXCHANNELS];\n\n    if (nChannels > cmsMAXCHANNELS) return FALSE;\n    if (nChannels <= 0) return FALSE;\n\n    memset(Tables, 0, sizeof(Tables));\n\n    Temp = (cmsUInt8Number*) _cmsMalloc(ContextID, 256);\n    if (Temp == NULL) return FALSE;\n\n    for (i=0; i < nChannels; i++) {\n        Tables[i] = cmsBuildTabulatedToneCurve16(ContextID, 256, NULL);\n        if (Tables[i] == NULL) goto Error;\n    }\n\n    for (i=0; i < nChannels; i++) {\n\n        if (io ->Read(io, Temp, 256, 1) != 1) goto Error;\n\n        for (j=0; j < 256; j++)\n            Tables[i]->Table16[j] = (cmsUInt16Number) FROM_8_TO_16(Temp[j]);\n    }\n\n    _cmsFree(ContextID, Temp);\n    Temp = NULL;\n\n    if (!cmsPipelineInsertStage(lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, nChannels, Tables)))\n        goto Error;\n\n    for (i=0; i < nChannels; i++)\n        cmsFreeToneCurve(Tables[i]);\n\n    return TRUE;\n\nError:\n    for (i=0; i < nChannels; i++) {\n        if (Tables[i]) cmsFreeToneCurve(Tables[i]);\n    }\n\n    if (Temp) _cmsFree(ContextID, Temp);\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              1882,
              0
            ],
            [
              1928,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Read8bitTables",
            "parameters": {
              "ContextID": "cmsContext",
              "io": "cmsIOHANDLER",
              "lut": "cmsPipeline",
              "nChannels": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool Write8bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsUInt32Number n, _cmsStageToneCurvesData* Tables)\n{\n    int j;\n    cmsUInt32Number i;\n    cmsUInt8Number val;\n\n    for (i=0; i < n; i++) {\n\n        if (Tables) {\n\n            // Usual case of identity curves\n            if ((Tables ->TheCurves[i]->nEntries == 2) && \n                (Tables->TheCurves[i]->Table16[0] == 0) && \n                (Tables->TheCurves[i]->Table16[1] == 65535)) {\n\n                    for (j=0; j < 256; j++) {\n                        if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) j)) return FALSE;\n                    }\n            }\n            else \n                if (Tables ->TheCurves[i]->nEntries != 256) {\n                    cmsSignalError(ContextID, cmsERROR_RANGE, \"LUT8 needs 256 entries on prelinearization\");\n                    return FALSE;                \n                }\n                else\n                    for (j=0; j < 256; j++) {\n\n                        val = (cmsUInt8Number) FROM_16_TO_8(Tables->TheCurves[i]->Table16[j]);\n\n                        if (!_cmsWriteUInt8Number(io, val)) return FALSE;\n                    }\n        }\n    }\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1931,
              0
            ],
            [
              1966,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Write8bitTables",
            "parameters": {
              "ContextID": "cmsContext",
              "io": "cmsIOHANDLER",
              "n": "cmsUInt32Number",
              "Tables": "_cmsStageToneCurvesData"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number uipow(cmsUInt32Number n, cmsUInt32Number a, cmsUInt32Number b)\n{\n    cmsUInt32Number rv = 1, rc;\n\n    if (a == 0) return 0;\n    if (n == 0) return 0;\n\n    for (; b > 0; b--) {\n\n        rv *= a;\n\n        // Check for overflow\n        if (rv > UINT_MAX / a) return (cmsUInt32Number) -1;\n\n    }\n\n    rc = rv * n;\n\n    if (rv != rc / n) return (cmsUInt32Number) -1;\n    return rc;\n}",
          "fn_code_pos": [
            [
              1970,
              0
            ],
            [
              1991,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "uipow",
            "parameters": {
              "n": "cmsUInt32Number",
              "a": "cmsUInt32Number",
              "b": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid *Type_LUT8_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt8Number InputChannels, OutputChannels, CLUTpoints;\n    cmsUInt8Number* Temp = NULL;\n    cmsPipeline* NewLUT = NULL;\n    cmsUInt32Number nTabSize, i;\n    cmsFloat64Number Matrix[3*3];\n\n    *nItems = 0;\n\n    if (!_cmsReadUInt8Number(io, &InputChannels)) goto Error;\n    if (!_cmsReadUInt8Number(io, &OutputChannels)) goto Error;\n    if (!_cmsReadUInt8Number(io, &CLUTpoints)) goto Error;\n\n     if (CLUTpoints == 1) goto Error; // Impossible value, 0 for no CLUT and then 2 at least\n\n    // Padding\n    if (!_cmsReadUInt8Number(io, NULL)) goto Error;\n\n    // Do some checking\n    if (InputChannels == 0 || InputChannels > cmsMAXCHANNELS)  goto Error;\n    if (OutputChannels == 0 || OutputChannels > cmsMAXCHANNELS) goto Error;\n\n   // Allocates an empty Pipeline\n    NewLUT = cmsPipelineAlloc(self ->ContextID, InputChannels, OutputChannels);\n    if (NewLUT == NULL) goto Error;\n\n    // Read the Matrix\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[0])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[1])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[2])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[3])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[4])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[5])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[6])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[7])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[8])) goto Error;\n\n\n    // Only operates if not identity...\n    if ((InputChannels == 3) && !_cmsMAT3isIdentity((cmsMAT3*) Matrix)) {\n\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_BEGIN, cmsStageAllocMatrix(self ->ContextID, 3, 3, Matrix, NULL)))\n            goto Error;\n    }\n\n    // Get input tables\n    if (!Read8bitTables(self ->ContextID, io,  NewLUT, InputChannels)) goto Error;\n\n    // Get 3D CLUT. Check the overflow....\n    nTabSize = uipow(OutputChannels, CLUTpoints, InputChannels);\n    if (nTabSize == (cmsUInt32Number) -1) goto Error;\n    if (nTabSize > 0) {\n\n        cmsUInt16Number *PtrW, *T;\n       \n        PtrW = T  = (cmsUInt16Number*) _cmsCalloc(self ->ContextID, nTabSize, sizeof(cmsUInt16Number));\n        if (T  == NULL) goto Error;\n\n        Temp = (cmsUInt8Number*) _cmsMalloc(self ->ContextID, nTabSize);\n        if (Temp == NULL) {\n            _cmsFree(self ->ContextID, T);\n            goto Error;\n        }\n\n        if (io ->Read(io, Temp, nTabSize, 1) != 1) {\n            _cmsFree(self ->ContextID, T);\n            _cmsFree(self ->ContextID, Temp);\n            goto Error;\n        }\n\n        for (i = 0; i < nTabSize; i++) {\n\n            *PtrW++ = FROM_8_TO_16(Temp[i]);\n        }\n        _cmsFree(self ->ContextID, Temp);\n        Temp = NULL;\n\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, cmsStageAllocCLut16bit(self ->ContextID, CLUTpoints, InputChannels, OutputChannels, T))) {\n            _cmsFree(self ->ContextID, T);\n            goto Error;\n        }\n        _cmsFree(self ->ContextID, T);\n    }\n\n\n    // Get output tables\n    if (!Read8bitTables(self ->ContextID, io,  NewLUT, OutputChannels)) goto Error;\n\n    *nItems = 1;\n    return NewLUT;\n\nError:\n    if (NewLUT != NULL) cmsPipelineFree(NewLUT);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              1998,
              0
            ],
            [
              2096,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUT8_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_LUT8_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt32Number j, nTabSize, i;\n    cmsUInt8Number  val;\n    cmsPipeline* NewLUT = (cmsPipeline*) Ptr;\n    cmsStage* mpe;\n    _cmsStageToneCurvesData* PreMPE = NULL, *PostMPE = NULL;\n    _cmsStageMatrixData* MatMPE = NULL;\n    _cmsStageCLutData* clut = NULL;\n    cmsUInt32Number clutPoints;\n\n    // Disassemble the LUT into components.\n    mpe = NewLUT -> Elements;\n\n    if (mpe == NULL) {  // Should never be empty. Corrupted?\n        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"empty LUT8 is not supported\");\n        return FALSE;\n    }\n\n    if (mpe ->Type == cmsSigMatrixElemType) {\n\n        if (mpe->InputChannels != 3 || mpe->OutputChannels != 3) return FALSE;\n        MatMPE = (_cmsStageMatrixData*) mpe ->Data;\n        mpe = mpe -> Next;\n    }\n\n    if (mpe != NULL && mpe ->Type == cmsSigCurveSetElemType) {\n        PreMPE = (_cmsStageToneCurvesData*) mpe ->Data;\n        mpe = mpe -> Next;\n    }\n\n    if (mpe != NULL && mpe ->Type == cmsSigCLutElemType) {\n        clut  = (_cmsStageCLutData*) mpe -> Data;\n        mpe = mpe ->Next;\n    }\n\n    if (mpe != NULL && mpe ->Type == cmsSigCurveSetElemType) {\n        PostMPE = (_cmsStageToneCurvesData*) mpe ->Data;\n        mpe = mpe -> Next;\n    }\n\n    // That should be all\n    if (mpe != NULL) {\n        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"LUT is not suitable to be saved as LUT8\");\n        return FALSE;\n    }\n\n    if (clut == NULL)\n        clutPoints = 0;\n    else {\n        // Lut8 only allows same CLUT points in all dimensions        \n        clutPoints = clut->Params->nSamples[0];\n        for (i = 1; i < cmsPipelineInputChannels(NewLUT); i++) {\n            if (clut->Params->nSamples[i] != clutPoints) {\n                cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"LUT with different samples per dimension not suitable to be saved as LUT16\");\n                return FALSE;\n            }\n        }\n    }\n        \n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number)cmsPipelineInputChannels(NewLUT))) return FALSE;\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number)cmsPipelineOutputChannels(NewLUT))) return FALSE;\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) clutPoints)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, 0)) return FALSE; // Padding\n\n    if (MatMPE != NULL) {\n        \n        for (i = 0; i < 9; i++)\n        {\n            if (!_cmsWrite15Fixed16Number(io, MatMPE->Double[i])) return FALSE;\n        }\n    }\n    else {\n        \n        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;\n    }\n\n    // The prelinearization table\n    if (!Write8bitTables(self ->ContextID, io, NewLUT ->InputChannels, PreMPE)) return FALSE;\n\n    nTabSize = uipow(NewLUT->OutputChannels, clutPoints, NewLUT ->InputChannels);\n    if (nTabSize == (cmsUInt32Number) -1) return FALSE;\n    if (nTabSize > 0) {\n\n        // The 3D CLUT.\n        if (clut != NULL) {\n\n            for (j=0; j < nTabSize; j++) {\n\n                val = (cmsUInt8Number) FROM_16_TO_8(clut ->Tab.T[j]);\n                if (!_cmsWriteUInt8Number(io, val)) return FALSE;\n            }\n        }\n    }\n\n    // The postlinearization table\n    if (!Write8bitTables(self ->ContextID, io, NewLUT ->OutputChannels, PostMPE)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}",
          "fn_code_pos": [
            [
              2099,
              0
            ],
            [
              2209,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUT8_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_LUT8_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              2212,
              0
            ],
            [
              2219,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUT8_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_LUT8_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsPipelineFree((cmsPipeline*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              2221,
              0
            ],
            [
              2228,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUT8_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  Read16bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsPipeline* lut, \n                                    cmsUInt32Number nChannels, cmsUInt32Number nEntries)\n{\n    cmsUInt32Number i;\n    cmsToneCurve* Tables[cmsMAXCHANNELS];\n\n    // Maybe an empty table? (this is a lcms extension)\n    if (nEntries <= 0) return TRUE;\n\n    // Check for malicious profiles\n    if (nEntries < 2) return FALSE;\n    if (nChannels > cmsMAXCHANNELS) return FALSE;\n\n    // Init table to zero\n    memset(Tables, 0, sizeof(Tables));\n\n    for (i=0; i < nChannels; i++) {\n\n        Tables[i] = cmsBuildTabulatedToneCurve16(ContextID, nEntries, NULL);\n        if (Tables[i] == NULL) goto Error;\n\n        if (!_cmsReadUInt16Array(io, nEntries, Tables[i]->Table16)) goto Error;\n    }\n\n\n    // Add the table (which may certainly be an identity, but this is up to the optimizer, not the reading code)\n    if (!cmsPipelineInsertStage(lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, nChannels, Tables)))\n        goto Error;\n\n    for (i=0; i < nChannels; i++)\n        cmsFreeToneCurve(Tables[i]);\n\n    return TRUE;\n\nError:\n    for (i=0; i < nChannels; i++) {\n        if (Tables[i]) cmsFreeToneCurve(Tables[i]);\n    }\n\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              2235,
              0
            ],
            [
              2276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Read16bitTables",
            "parameters": {
              "ContextID": "cmsContext",
              "io": "cmsIOHANDLER",
              "lut": "cmsPipeline",
              "nChannels": "cmsUInt32Number",
              "nEntries": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool Write16bitTables(cmsContext ContextID, cmsIOHANDLER* io, _cmsStageToneCurvesData* Tables)\n{\n    cmsUInt32Number j;\n    cmsUInt32Number i;\n    cmsUInt16Number val;\n    cmsUInt32Number nEntries;\n\n    _cmsAssert(Tables != NULL);\n   \n    for (i=0; i < Tables ->nCurves; i++) {\n\n        nEntries = Tables->TheCurves[i]->nEntries;\n\n        for (j=0; j < nEntries; j++) {\n\n            val = Tables->TheCurves[i]->Table16[j];        \n            if (!_cmsWriteUInt16Number(io, val)) return FALSE;\n        }\n    }\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(ContextID);\n}",
          "fn_code_pos": [
            [
              2278,
              0
            ],
            [
              2301,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Write16bitTables",
            "parameters": {
              "ContextID": "cmsContext",
              "io": "cmsIOHANDLER",
              "Tables": "_cmsStageToneCurvesData"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid *Type_LUT16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt8Number InputChannels, OutputChannels, CLUTpoints;\n    cmsPipeline* NewLUT = NULL;\n    cmsUInt32Number nTabSize;\n    cmsFloat64Number Matrix[3*3];\n    cmsUInt16Number InputEntries, OutputEntries;\n\n    *nItems = 0;\n\n    if (!_cmsReadUInt8Number(io, &InputChannels)) return NULL;\n    if (!_cmsReadUInt8Number(io, &OutputChannels)) return NULL;\n    if (!_cmsReadUInt8Number(io, &CLUTpoints)) return NULL;   // 255 maximum\n\n    // Padding\n    if (!_cmsReadUInt8Number(io, NULL)) return NULL;\n\n    // Do some checking\n    if (InputChannels == 0 || InputChannels > cmsMAXCHANNELS)  goto Error;\n    if (OutputChannels == 0 || OutputChannels > cmsMAXCHANNELS) goto Error;\n\n    // Allocates an empty LUT\n    NewLUT = cmsPipelineAlloc(self ->ContextID, InputChannels, OutputChannels);\n    if (NewLUT == NULL) goto Error;\n\n    // Read the Matrix\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[0])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[1])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[2])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[3])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[4])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[5])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[6])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[7])) goto Error;\n    if (!_cmsRead15Fixed16Number(io,  &Matrix[8])) goto Error;\n\n\n    // Only operates on 3 channels\n    if ((InputChannels == 3) && !_cmsMAT3isIdentity((cmsMAT3*) Matrix)) {\n\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, cmsStageAllocMatrix(self ->ContextID, 3, 3, Matrix, NULL)))\n            goto Error;\n    }\n\n    if (!_cmsReadUInt16Number(io, &InputEntries)) goto Error;\n    if (!_cmsReadUInt16Number(io, &OutputEntries)) goto Error;\n\n    if (InputEntries > 0x7FFF || OutputEntries > 0x7FFF) goto Error;\n    if (CLUTpoints == 1) goto Error; // Impossible value, 0 for no CLUT and then 2 at least\n\n    // Get input tables\n    if (!Read16bitTables(self ->ContextID, io,  NewLUT, InputChannels, InputEntries)) goto Error;\n\n    // Get 3D CLUT\n    nTabSize = uipow(OutputChannels, CLUTpoints, InputChannels);\n    if (nTabSize == (cmsUInt32Number) -1) goto Error;\n    if (nTabSize > 0) {\n\n        cmsUInt16Number *T;\n\n        T  = (cmsUInt16Number*) _cmsCalloc(self ->ContextID, nTabSize, sizeof(cmsUInt16Number));\n        if (T  == NULL) goto Error;\n\n        if (!_cmsReadUInt16Array(io, nTabSize, T)) {\n            _cmsFree(self ->ContextID, T);\n            goto Error;\n        }\n\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, cmsStageAllocCLut16bit(self ->ContextID, CLUTpoints, InputChannels, OutputChannels, T))) {\n            _cmsFree(self ->ContextID, T);\n            goto Error;\n        }\n        _cmsFree(self ->ContextID, T);\n    }\n\n\n    // Get output tables\n    if (!Read16bitTables(self ->ContextID, io,  NewLUT, OutputChannels, OutputEntries)) goto Error;\n\n    *nItems = 1;\n    return NewLUT;\n\nError:\n    if (NewLUT != NULL) cmsPipelineFree(NewLUT);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              2303,
              0
            ],
            [
              2391,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUT16_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_LUT16_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt32Number nTabSize;\n    cmsPipeline* NewLUT = (cmsPipeline*) Ptr;\n    cmsStage* mpe;\n    _cmsStageToneCurvesData* PreMPE = NULL, *PostMPE = NULL;\n    _cmsStageMatrixData* MatMPE = NULL;\n    _cmsStageCLutData* clut = NULL;\n    cmsUInt32Number i, InputChannels, OutputChannels, clutPoints;\n\n    // Disassemble the LUT into components.\n    mpe = NewLUT -> Elements;\n    if (mpe != NULL && mpe ->Type == cmsSigMatrixElemType) {\n\n        MatMPE = (_cmsStageMatrixData*) mpe ->Data;\n        if (mpe->InputChannels != 3 || mpe->OutputChannels != 3) return FALSE;\n        mpe = mpe -> Next;\n    }\n\n\n    if (mpe != NULL && mpe ->Type == cmsSigCurveSetElemType) {\n        PreMPE = (_cmsStageToneCurvesData*) mpe ->Data;\n        mpe = mpe -> Next;\n    }\n\n    if (mpe != NULL && mpe ->Type == cmsSigCLutElemType) {\n        clut  = (_cmsStageCLutData*) mpe -> Data;\n        mpe = mpe ->Next;\n    }\n\n    if (mpe != NULL && mpe ->Type == cmsSigCurveSetElemType) {\n        PostMPE = (_cmsStageToneCurvesData*) mpe ->Data;\n        mpe = mpe -> Next;\n    }\n\n    // That should be all\n    if (mpe != NULL) {\n        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"LUT is not suitable to be saved as LUT16\");\n        return FALSE;\n    }\n\n    InputChannels  = cmsPipelineInputChannels(NewLUT);\n    OutputChannels = cmsPipelineOutputChannels(NewLUT);\n\n    if (clut == NULL)\n        clutPoints = 0;\n    else {\n        // Lut16 only allows same CLUT points in all dimensions        \n        clutPoints = clut->Params->nSamples[0];\n        for (i = 1; i < InputChannels; i++) {\n            if (clut->Params->nSamples[i] != clutPoints) {\n                cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"LUT with different samples per dimension not suitable to be saved as LUT16\");\n                return FALSE;\n            }\n        }\n    }\n\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) InputChannels)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) OutputChannels)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) clutPoints)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, 0)) return FALSE; // Padding\n    \n    if (MatMPE != NULL) {\n                \n        for (i = 0; i < 9; i++)\n        {\n            if (!_cmsWrite15Fixed16Number(io, MatMPE->Double[i])) return FALSE;\n        }\n      \n    }\n    else {\n        \n        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 1)) return FALSE;\n    }\n\n\n    if (PreMPE != NULL) {\n        if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) PreMPE ->TheCurves[0]->nEntries)) return FALSE;\n    } else {\n            if (!_cmsWriteUInt16Number(io, 2)) return FALSE;\n    }\n\n    if (PostMPE != NULL) {\n        if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) PostMPE ->TheCurves[0]->nEntries)) return FALSE;\n    } else {\n        if (!_cmsWriteUInt16Number(io, 2)) return FALSE;\n\n    }\n\n    // The prelinearization table\n\n    if (PreMPE != NULL) {\n        if (!Write16bitTables(self ->ContextID, io, PreMPE)) return FALSE;\n    }\n    else {\n        for (i=0; i < InputChannels; i++) {\n\n            if (!_cmsWriteUInt16Number(io, 0)) return FALSE;\n            if (!_cmsWriteUInt16Number(io, 0xffff)) return FALSE;\n        }\n    }\n\n    nTabSize = uipow(OutputChannels, clutPoints, InputChannels);\n    if (nTabSize == (cmsUInt32Number) -1) return FALSE;\n    if (nTabSize > 0) {\n        // The 3D CLUT.\n        if (clut != NULL) {\n            if (!_cmsWriteUInt16Array(io, nTabSize, clut->Tab.T)) return FALSE;\n        }\n    }\n\n    // The postlinearization table\n    if (PostMPE != NULL) {\n        if (!Write16bitTables(self ->ContextID, io, PostMPE)) return FALSE;\n    }\n    else {\n        for (i=0; i < OutputChannels; i++) {\n\n            if (!_cmsWriteUInt16Number(io, 0)) return FALSE;\n            if (!_cmsWriteUInt16Number(io, 0xffff)) return FALSE;\n        }\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}",
          "fn_code_pos": [
            [
              2396,
              0
            ],
            [
              2531,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUT16_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_LUT16_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              2533,
              0
            ],
            [
              2540,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUT16_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_LUT16_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsPipelineFree((cmsPipeline*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              2542,
              0
            ],
            [
              2549,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUT16_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsStage* ReadMatrix(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number Offset)\n{\n    cmsFloat64Number dMat[3*3];\n    cmsFloat64Number dOff[3];\n    cmsStage* Mat;\n\n    // Go to address\n    if (!io -> Seek(io, Offset)) return NULL;\n\n    // Read the Matrix\n    if (!_cmsRead15Fixed16Number(io, &dMat[0])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[1])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[2])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[3])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[4])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[5])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[6])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[7])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dMat[8])) return NULL;\n\n    if (!_cmsRead15Fixed16Number(io, &dOff[0])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dOff[1])) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &dOff[2])) return NULL;\n\n    Mat = cmsStageAllocMatrix(self ->ContextID, 3, 3, dMat, dOff);\n\n     return Mat;\n}",
          "fn_code_pos": [
            [
              2559,
              0
            ],
            [
              2587,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadMatrix",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Offset": "cmsUInt32Number"
            },
            "return_type": "cmsStage"
          }
        },
        {
          "fn_code": "static\ncmsStage* ReadCLUT(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, \n                   cmsUInt32Number Offset, cmsUInt32Number InputChannels, cmsUInt32Number OutputChannels)\n{\n    cmsUInt8Number  gridPoints8[cmsMAXCHANNELS]; // Number of grid points in each dimension.\n    cmsUInt32Number GridPoints[cmsMAXCHANNELS], i;\n    cmsUInt8Number  Precision;\n    cmsStage* CLUT;\n    _cmsStageCLutData* Data;\n\n    if (!io -> Seek(io, Offset)) return NULL;\n    if (io -> Read(io, gridPoints8, cmsMAXCHANNELS, 1) != 1) return NULL;\n\n\n    for (i=0; i < cmsMAXCHANNELS; i++) {\n\n        if (gridPoints8[i] == 1) return NULL; // Impossible value, 0 for no CLUT and then 2 at least\n        GridPoints[i] = gridPoints8[i];\n    }\n\n    if (!_cmsReadUInt8Number(io, &Precision)) return NULL;\n\n    if (!_cmsReadUInt8Number(io, NULL)) return NULL;\n    if (!_cmsReadUInt8Number(io, NULL)) return NULL;\n    if (!_cmsReadUInt8Number(io, NULL)) return NULL;\n\n    CLUT = cmsStageAllocCLut16bitGranular(self ->ContextID, GridPoints, InputChannels, OutputChannels, NULL);\n    if (CLUT == NULL) return NULL;\n\n    Data = (_cmsStageCLutData*) CLUT ->Data;\n\n    // Precision can be 1 or 2 bytes\n    if (Precision == 1) {\n\n        cmsUInt8Number  v;\n\n        for (i=0; i < Data ->nEntries; i++) {\n\n            if (io ->Read(io, &v, sizeof(cmsUInt8Number), 1) != 1) {\n                cmsStageFree(CLUT);\n                return NULL;\n            }\n            Data ->Tab.T[i] = FROM_8_TO_16(v);\n        }\n\n    }\n    else\n        if (Precision == 2) {\n\n            if (!_cmsReadUInt16Array(io, Data->nEntries, Data ->Tab.T)) {\n                cmsStageFree(CLUT);\n                return NULL;\n            }\n        }\n        else {\n            cmsStageFree(CLUT);\n            cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown precision of '%d'\", Precision);\n            return NULL;\n        }\n\n    return CLUT;\n}",
          "fn_code_pos": [
            [
              2594,
              0
            ],
            [
              2655,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadCLUT",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Offset": "cmsUInt32Number",
              "InputChannels": "cmsUInt32Number",
              "OutputChannels": "cmsUInt32Number"
            },
            "return_type": "cmsStage"
          }
        },
        {
          "fn_code": "static\ncmsToneCurve* ReadEmbeddedCurve(struct _cms_typehandler_struct* self, cmsIOHANDLER* io)\n{\n    cmsTagTypeSignature  BaseType;\n    cmsUInt32Number nItems;\n\n    BaseType = _cmsReadTypeBase(io);\n    switch (BaseType) {\n\n            case cmsSigCurveType:\n                return (cmsToneCurve*) Type_Curve_Read(self, io, &nItems, 0);\n\n            case cmsSigParametricCurveType:\n                return (cmsToneCurve*) Type_ParametricCurve_Read(self, io, &nItems, 0);\n\n            default:\n                {\n                    char String[5];\n\n                    _cmsTagSignature2String(String, (cmsTagSignature) BaseType);\n                    cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown curve type '%s'\", String);\n                }\n                return NULL;\n    }\n}",
          "fn_code_pos": [
            [
              2657,
              0
            ],
            [
              2681,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadEmbeddedCurve",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER"
            },
            "return_type": "cmsToneCurve"
          }
        },
        {
          "fn_code": "static\ncmsStage* ReadSetOfCurves(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number Offset, cmsUInt32Number nCurves)\n{\n    cmsToneCurve* Curves[cmsMAXCHANNELS];\n    cmsUInt32Number i;\n    cmsStage* Lin = NULL;\n\n    if (nCurves > cmsMAXCHANNELS) return FALSE;\n\n    if (!io -> Seek(io, Offset)) return FALSE;\n\n    for (i=0; i < nCurves; i++)\n        Curves[i] = NULL;\n\n    for (i=0; i < nCurves; i++) {\n\n        Curves[i] = ReadEmbeddedCurve(self, io);\n        if (Curves[i] == NULL) goto Error;\n        if (!_cmsReadAlignment(io)) goto Error;\n\n    }\n\n    Lin = cmsStageAllocToneCurves(self ->ContextID, nCurves, Curves);\n\nError:\n    for (i=0; i < nCurves; i++)\n        cmsFreeToneCurve(Curves[i]);\n\n    return Lin;\n}",
          "fn_code_pos": [
            [
              2685,
              0
            ],
            [
              2714,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadSetOfCurves",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Offset": "cmsUInt32Number",
              "nCurves": "cmsUInt32Number"
            },
            "return_type": "cmsStage"
          }
        },
        {
          "fn_code": "static\nvoid* Type_LUTA2B_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt32Number      BaseOffset;\n    cmsUInt8Number       inputChan;      // Number of input channels\n    cmsUInt8Number       outputChan;     // Number of output channels\n    cmsUInt32Number      offsetB;        // Offset to first \"B\" curve\n    cmsUInt32Number      offsetMat;      // Offset to matrix\n    cmsUInt32Number      offsetM;        // Offset to first \"M\" curve\n    cmsUInt32Number      offsetC;        // Offset to CLUT\n    cmsUInt32Number      offsetA;        // Offset to first \"A\" curve\n    cmsPipeline* NewLUT = NULL;\n\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    if (!_cmsReadUInt8Number(io, &inputChan)) return NULL;\n    if (!_cmsReadUInt8Number(io, &outputChan)) return NULL;\n\n    if (!_cmsReadUInt16Number(io, NULL)) return NULL;\n\n    if (!_cmsReadUInt32Number(io, &offsetB)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetMat)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetM)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetC)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetA)) return NULL;\n\n    if (inputChan == 0 || inputChan >= cmsMAXCHANNELS) return NULL;\n    if (outputChan == 0 || outputChan >= cmsMAXCHANNELS) return NULL;\n\n    // Allocates an empty LUT\n    NewLUT = cmsPipelineAlloc(self ->ContextID, inputChan, outputChan);\n    if (NewLUT == NULL) return NULL;\n\n    if (offsetA!= 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetA, inputChan)))\n            goto Error;\n    }\n\n    if (offsetC != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadCLUT(self, io, BaseOffset + offsetC, inputChan, outputChan)))\n            goto Error;\n    }\n\n    if (offsetM != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetM, outputChan)))\n            goto Error;\n    }\n\n    if (offsetMat != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadMatrix(self, io, BaseOffset + offsetMat)))\n            goto Error;\n    }\n\n    if (offsetB != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetB, outputChan)))\n            goto Error;\n    }\n\n    *nItems = 1;\n    return NewLUT;\nError:\n    cmsPipelineFree(NewLUT);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              2738,
              0
            ],
            [
              2804,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUTA2B_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  WriteMatrix(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsStage* mpe)\n{\n    cmsUInt32Number i, n;\n\n    _cmsStageMatrixData* m = (_cmsStageMatrixData*) mpe -> Data;\n\n    n = mpe->InputChannels * mpe->OutputChannels;\n\n    // Write the Matrix\n    for (i = 0; i < n; i++)\n    {\n        if (!_cmsWrite15Fixed16Number(io, m->Double[i])) return FALSE;\n    }\n\n    if (m->Offset != NULL) {\n\n        for (i = 0; i < mpe->OutputChannels; i++)\n        {\n            if (!_cmsWrite15Fixed16Number(io, m->Offset[i])) return FALSE;\n        }\n    }\n    else {\n        for (i = 0; i < mpe->OutputChannels; i++)\n        {\n            if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        }\n    }\n\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              2807,
              0
            ],
            [
              2840,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteMatrix",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "mpe": "cmsStage"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool WriteSetOfCurves(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsTagTypeSignature Type, cmsStage* mpe)\n{\n    cmsUInt32Number i, n;\n    cmsTagTypeSignature CurrentType;\n    cmsToneCurve** Curves;\n\n\n    n      = cmsStageOutputChannels(mpe);\n    Curves = _cmsStageGetPtrToCurveSet(mpe);\n\n    for (i=0; i < n; i++) {\n\n        // If this is a table-based curve, use curve type even on V4\n        CurrentType = Type;\n\n        if ((Curves[i] ->nSegments == 0) ||                                         // 16 bits tabulated\n            ((Curves[i]->nSegments == 3) && (Curves[i] ->Segments[1].Type == 0)) )  // Floating-point tabulated\n            CurrentType = cmsSigCurveType;\n        else\n        if (Curves[i] ->Segments[0].Type < 0)\n            CurrentType = cmsSigCurveType;\n\n        if (!_cmsWriteTypeBase(io, CurrentType)) return FALSE;\n\n        switch (CurrentType) {\n\n            case cmsSigCurveType:\n                if (!Type_Curve_Write(self, io, Curves[i], 1)) return FALSE;\n                break;\n\n            case cmsSigParametricCurveType:\n                if (!Type_ParametricCurve_Write(self, io, Curves[i], 1)) return FALSE;\n                break;\n\n            default:\n                {\n                    char String[5];\n\n                    _cmsTagSignature2String(String, (cmsTagSignature) Type);\n                    cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown curve type '%s'\", String);\n                }\n                return FALSE;\n        }\n\n        if (!_cmsWriteAlignment(io)) return FALSE;\n    }\n\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              2844,
              0
            ],
            [
              2894,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteSetOfCurves",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Type": "cmsTagTypeSignature",
              "mpe": "cmsStage"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool WriteCLUT(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt8Number  Precision, cmsStage* mpe)\n{\n    cmsUInt8Number  gridPoints[cmsMAXCHANNELS]; // Number of grid points in each dimension.\n    cmsUInt32Number i;\n    _cmsStageCLutData* CLUT = ( _cmsStageCLutData*) mpe -> Data;\n\n    if (CLUT ->HasFloatValues) {\n         cmsSignalError(self ->ContextID, cmsERROR_NOT_SUITABLE, \"Cannot save floating point data, CLUT are 8 or 16 bit only\");\n         return FALSE;\n    }\n\n    memset(gridPoints, 0, sizeof(gridPoints));\n    for (i=0; i < (cmsUInt32Number) CLUT ->Params ->nInputs; i++)\n        gridPoints[i] = (cmsUInt8Number) CLUT ->Params ->nSamples[i];\n\n    if (!io -> Write(io, cmsMAXCHANNELS*sizeof(cmsUInt8Number), gridPoints)) return FALSE;\n\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) Precision)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, 0)) return FALSE;\n\n    // Precision can be 1 or 2 bytes\n    if (Precision == 1) {\n\n        for (i=0; i < CLUT->nEntries; i++) {\n\n            if (!_cmsWriteUInt8Number(io, FROM_16_TO_8(CLUT->Tab.T[i]))) return FALSE;\n        }\n    }\n    else\n        if (Precision == 2) {\n\n            if (!_cmsWriteUInt16Array(io, CLUT->nEntries, CLUT ->Tab.T)) return FALSE;\n        }\n        else {\n             cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown precision of '%d'\", Precision);\n            return FALSE;\n        }\n\n    if (!_cmsWriteAlignment(io)) return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              2897,
              0
            ],
            [
              2941,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteCLUT",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Precision": "cmsUInt8Number",
              "mpe": "cmsStage"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_LUTA2B_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsPipeline* Lut = (cmsPipeline*) Ptr;\n    cmsUInt32Number inputChan, outputChan;\n    cmsStage *A = NULL, *B = NULL, *M = NULL;\n    cmsStage * Matrix = NULL;\n    cmsStage * CLUT = NULL;\n    cmsUInt32Number offsetB = 0, offsetMat = 0, offsetM = 0, offsetC = 0, offsetA = 0;\n    cmsUInt32Number BaseOffset, DirectoryPos, CurrentPos;\n\n    // Get the base for all offsets\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    if (Lut ->Elements != NULL)\n        if (!cmsPipelineCheckAndRetreiveStages(Lut, 1, cmsSigCurveSetElemType, &B))\n            if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType, &M, &Matrix, &B))\n                if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType, &A, &CLUT, &B))\n                    if (!cmsPipelineCheckAndRetreiveStages(Lut, 5, cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType,\n                        cmsSigMatrixElemType, cmsSigCurveSetElemType, &A, &CLUT, &M, &Matrix, &B)) {\n\n                            cmsSignalError(self->ContextID, cmsERROR_NOT_SUITABLE, \"LUT is not suitable to be saved as LutAToB\");\n                            return FALSE;\n                    }\n\n    // Get input, output channels\n    inputChan  = cmsPipelineInputChannels(Lut);\n    outputChan = cmsPipelineOutputChannels(Lut);\n\n    // Write channel count\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) inputChan)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) outputChan)) return FALSE;\n    if (!_cmsWriteUInt16Number(io, 0)) return FALSE;\n\n    // Keep directory to be filled latter\n    DirectoryPos = io ->Tell(io);\n\n    // Write the directory\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n\n    if (A != NULL) {\n\n        offsetA = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, A)) return FALSE;\n    }\n\n    if (CLUT != NULL) {\n        offsetC = io ->Tell(io) - BaseOffset;\n        if (!WriteCLUT(self, io, (Lut ->SaveAs8Bits ? 1U : 2U), CLUT)) return FALSE;\n\n    }\n    if (M != NULL) {\n\n        offsetM = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, M)) return FALSE;\n    }\n\n    if (Matrix != NULL) {\n        offsetMat = io ->Tell(io) - BaseOffset;\n        if (!WriteMatrix(self, io, Matrix)) return FALSE;\n    }\n\n    if (B != NULL) {\n\n        offsetB = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, B)) return FALSE;\n    }\n\n    CurrentPos = io ->Tell(io);\n\n    if (!io ->Seek(io, DirectoryPos)) return FALSE;\n\n    if (!_cmsWriteUInt32Number(io, offsetB)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetMat)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetM)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetC)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetA)) return FALSE;\n\n    if (!io ->Seek(io, CurrentPos)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}",
          "fn_code_pos": [
            [
              2946,
              0
            ],
            [
              3033,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUTA2B_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_LUTA2B_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              3036,
              0
            ],
            [
              3043,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUTA2B_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_LUTA2B_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsPipelineFree((cmsPipeline*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              3045,
              0
            ],
            [
              3052,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUTA2B_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* Type_LUTB2A_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt8Number       inputChan;      // Number of input channels\n    cmsUInt8Number       outputChan;     // Number of output channels\n    cmsUInt32Number      BaseOffset;     // Actual position in file\n    cmsUInt32Number      offsetB;        // Offset to first \"B\" curve\n    cmsUInt32Number      offsetMat;      // Offset to matrix\n    cmsUInt32Number      offsetM;        // Offset to first \"M\" curve\n    cmsUInt32Number      offsetC;        // Offset to CLUT\n    cmsUInt32Number      offsetA;        // Offset to first \"A\" curve\n    cmsPipeline* NewLUT = NULL;\n\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    if (!_cmsReadUInt8Number(io, &inputChan)) return NULL;\n    if (!_cmsReadUInt8Number(io, &outputChan)) return NULL;\n\n    if (inputChan == 0 || inputChan >= cmsMAXCHANNELS) return NULL;\n    if (outputChan == 0 || outputChan >= cmsMAXCHANNELS) return NULL;\n\n    // Padding\n    if (!_cmsReadUInt16Number(io, NULL)) return NULL;\n\n    if (!_cmsReadUInt32Number(io, &offsetB)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetMat)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetM)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetC)) return NULL;\n    if (!_cmsReadUInt32Number(io, &offsetA)) return NULL;\n\n    // Allocates an empty LUT\n    NewLUT = cmsPipelineAlloc(self ->ContextID, inputChan, outputChan);\n    if (NewLUT == NULL) return NULL;\n\n    if (offsetB != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetB, inputChan)))\n            goto Error;\n    }\n\n    if (offsetMat != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadMatrix(self, io, BaseOffset + offsetMat)))\n            goto Error;\n    }\n\n    if (offsetM != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetM, inputChan)))\n            goto Error;\n    }\n\n    if (offsetC != 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadCLUT(self, io, BaseOffset + offsetC, inputChan, outputChan)))\n            goto Error;\n    }\n\n    if (offsetA!= 0) {\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetA, outputChan)))\n            goto Error;\n    }\n\n    *nItems = 1;\n    return NewLUT;\nError:\n    cmsPipelineFree(NewLUT);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              3057,
              0
            ],
            [
              3124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUTB2A_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  Type_LUTB2A_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsPipeline* Lut = (cmsPipeline*) Ptr;\n    cmsUInt32Number inputChan, outputChan;\n    cmsStage *A = NULL, *B = NULL, *M = NULL;\n    cmsStage *Matrix = NULL;\n    cmsStage *CLUT = NULL;\n    cmsUInt32Number offsetB = 0, offsetMat = 0, offsetM = 0, offsetC = 0, offsetA = 0;\n    cmsUInt32Number BaseOffset, DirectoryPos, CurrentPos;\n\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    if (!cmsPipelineCheckAndRetreiveStages(Lut, 1, cmsSigCurveSetElemType, &B))\n        if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType, &B, &Matrix, &M))\n            if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType, &B, &CLUT, &A))\n                if (!cmsPipelineCheckAndRetreiveStages(Lut, 5, cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType,\n                    cmsSigCLutElemType, cmsSigCurveSetElemType, &B, &Matrix, &M, &CLUT, &A)) {\n                        cmsSignalError(self->ContextID, cmsERROR_NOT_SUITABLE, \"LUT is not suitable to be saved as LutBToA\");\n                        return FALSE;\n                }\n\n    inputChan  = cmsPipelineInputChannels(Lut);\n    outputChan = cmsPipelineOutputChannels(Lut);\n\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) inputChan)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) outputChan)) return FALSE;\n    if (!_cmsWriteUInt16Number(io, 0)) return FALSE;\n\n    DirectoryPos = io ->Tell(io);\n\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n\n    if (A != NULL) {\n\n        offsetA = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, A)) return FALSE;\n    }\n\n    if (CLUT != NULL) {\n        offsetC = io ->Tell(io) - BaseOffset;\n        if (!WriteCLUT(self, io, (Lut ->SaveAs8Bits ? 1U : 2U), CLUT)) return FALSE;\n\n    }\n    if (M != NULL) {\n\n        offsetM = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, M)) return FALSE;\n    }\n\n    if (Matrix != NULL) {\n        offsetMat = io ->Tell(io) - BaseOffset;\n        if (!WriteMatrix(self, io, Matrix)) return FALSE;\n    }\n\n    if (B != NULL) {\n\n        offsetB = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, B)) return FALSE;\n    }\n\n    CurrentPos = io ->Tell(io);\n\n    if (!io ->Seek(io, DirectoryPos)) return FALSE;\n\n    if (!_cmsWriteUInt32Number(io, offsetB)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetMat)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetM)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetC)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetA)) return FALSE;\n\n    if (!io ->Seek(io, CurrentPos)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}",
          "fn_code_pos": [
            [
              3134,
              0
            ],
            [
              3215,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUTB2A_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_LUTB2A_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              3219,
              0
            ],
            [
              3226,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUTB2A_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_LUTB2A_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsPipelineFree((cmsPipeline*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              3228,
              0
            ],
            [
              3235,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUTB2A_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid *Type_ColorantTable_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt32Number i, Count;\n    cmsNAMEDCOLORLIST* List;\n    char Name[34];\n    cmsUInt16Number PCS[3];\n\n\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n\n    if (Count > cmsMAXCHANNELS) {\n        cmsSignalError(self->ContextID, cmsERROR_RANGE, \"Too many colorants '%d'\", Count);\n        return NULL;\n    }\n\n    List = cmsAllocNamedColorList(self ->ContextID, Count, 0, \"\", \"\");\n    if (List == NULL)           \n        return NULL; \n        \n    for (i=0; i < Count; i++) {\n\n        if (io ->Read(io, Name, 32, 1) != 1) goto Error;\n        Name[32] = 0;\n\n        if (!_cmsReadUInt16Array(io, 3, PCS)) goto Error;\n\n        if (!cmsAppendNamedColor(List, Name, PCS, NULL)) goto Error;\n\n    }\n\n    *nItems = 1;\n    return List;\n\nError:\n    *nItems = 0;\n    cmsFreeNamedColorList(List);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              3250,
              0
            ],
            [
              3290,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ColorantTable_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  Type_ColorantTable_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsNAMEDCOLORLIST* NamedColorList = (cmsNAMEDCOLORLIST*) Ptr;\n    cmsUInt32Number i, nColors;\n\n    nColors = cmsNamedColorCount(NamedColorList);\n\n    if (!_cmsWriteUInt32Number(io, nColors)) return FALSE;\n\n    for (i=0; i < nColors; i++) {\n\n        char root[cmsMAX_PATH];\n        cmsUInt16Number PCS[3];\n\n        memset(root, 0, sizeof(root));\n\n        if (!cmsNamedColorInfo(NamedColorList, i, root, NULL, NULL, PCS, NULL)) return 0;\n        root[32] = 0;\n\n        if (!io ->Write(io, 32, root)) return FALSE;\n        if (!_cmsWriteUInt16Array(io, 3, PCS)) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              3295,
              0
            ],
            [
              3323,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ColorantTable_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_ColorantTable_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n{\n    cmsNAMEDCOLORLIST* nc = (cmsNAMEDCOLORLIST*) Ptr;\n    return (void*) cmsDupNamedColorList(nc);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              3326,
              0
            ],
            [
              3334,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ColorantTable_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_ColorantTable_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsFreeNamedColorList((cmsNAMEDCOLORLIST*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              3337,
              0
            ],
            [
              3344,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ColorantTable_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid *Type_NamedColor_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt32Number      vendorFlag;     // Bottom 16 bits for ICC use\n    cmsUInt32Number      count;          // Count of named colors\n    cmsUInt32Number      nDeviceCoords;  // Num of device coordinates\n    char                 prefix[32];     // Prefix for each color name\n    char                 suffix[32];     // Suffix for each color name\n    cmsNAMEDCOLORLIST*   v;\n    cmsUInt32Number      i;\n\n\n    *nItems = 0;\n    if (!_cmsReadUInt32Number(io, &vendorFlag)) return NULL;\n    if (!_cmsReadUInt32Number(io, &count)) return NULL;\n    if (!_cmsReadUInt32Number(io, &nDeviceCoords)) return NULL;\n\n    if (io -> Read(io, prefix, 32, 1) != 1) return NULL;\n    if (io -> Read(io, suffix, 32, 1) != 1) return NULL;\n\n    prefix[31] = suffix[31] = 0;\n\n    v = cmsAllocNamedColorList(self ->ContextID, count, nDeviceCoords, prefix, suffix);\n    if (v == NULL) {\n        cmsSignalError(self->ContextID, cmsERROR_RANGE, \"Too many named colors '%d'\", count);\n        return NULL;\n    }\n\n    if (nDeviceCoords > cmsMAXCHANNELS) {\n        cmsSignalError(self->ContextID, cmsERROR_RANGE, \"Too many device coordinates '%d'\", nDeviceCoords);\n        goto Error;\n    }\n    for (i=0; i < count; i++) {\n\n        cmsUInt16Number PCS[3];\n        cmsUInt16Number Colorant[cmsMAXCHANNELS];\n        char Root[33];\n\n        memset(Colorant, 0, sizeof(Colorant));\n        if (io -> Read(io, Root, 32, 1) != 1) goto Error;\n        Root[32] = 0;  // To prevent exploits\n\n        if (!_cmsReadUInt16Array(io, 3, PCS)) goto Error;\n        if (!_cmsReadUInt16Array(io, nDeviceCoords, Colorant)) goto Error;\n\n        if (!cmsAppendNamedColor(v, Root, PCS, Colorant)) goto Error;\n    }\n\n    *nItems = 1;\n    return (void*) v ;\n\nError:\n    cmsFreeNamedColorList(v);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              3362,
              0
            ],
            [
              3418,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_NamedColor_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_NamedColor_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsNAMEDCOLORLIST* NamedColorList = (cmsNAMEDCOLORLIST*) Ptr;\n    char                prefix[33];     // Prefix for each color name\n    char                suffix[33];     // Suffix for each color name\n    cmsUInt32Number     i, nColors;\n\n    nColors = cmsNamedColorCount(NamedColorList);\n\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, nColors)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, NamedColorList ->ColorantCount)) return FALSE;\n\n    memcpy(prefix, (const char*) NamedColorList->Prefix, sizeof(prefix));\n    memcpy(suffix, (const char*) NamedColorList->Suffix, sizeof(suffix));\n\n    suffix[32] = prefix[32] = 0;\n\n    if (!io ->Write(io, 32, prefix)) return FALSE;\n    if (!io ->Write(io, 32, suffix)) return FALSE;\n\n    for (i=0; i < nColors; i++) {\n\n       cmsUInt16Number PCS[3];\n       cmsUInt16Number Colorant[cmsMAXCHANNELS];\n       char Root[cmsMAX_PATH];\n\n       memset(Root, 0, sizeof(Root));\n       memset(PCS, 0, sizeof(PCS));\n       memset(Colorant, 0, sizeof(Colorant));\n\n        if (!cmsNamedColorInfo(NamedColorList, i, Root, NULL, NULL, PCS, Colorant)) return 0;\n        Root[32] = 0;\n        if (!io ->Write(io, 32 , Root)) return FALSE;\n        if (!_cmsWriteUInt16Array(io, 3, PCS)) return FALSE;\n        if (!_cmsWriteUInt16Array(io, NamedColorList ->ColorantCount, Colorant)) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              3422,
              0
            ],
            [
              3465,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_NamedColor_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_NamedColor_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n{\n    cmsNAMEDCOLORLIST* nc = (cmsNAMEDCOLORLIST*) Ptr;\n\n    return (void*) cmsDupNamedColorList(nc);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              3467,
              0
            ],
            [
              3476,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_NamedColor_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_NamedColor_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsFreeNamedColorList((cmsNAMEDCOLORLIST*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              3479,
              0
            ],
            [
              3486,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_NamedColor_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool ReadEmbeddedText(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU** mlu, cmsUInt32Number SizeOfTag)\n{\n    cmsTagTypeSignature  BaseType;\n    cmsUInt32Number nItems;\n\n    BaseType = _cmsReadTypeBase(io);\n\n    switch (BaseType) {\n\n       case cmsSigTextType:\n           if (*mlu) cmsMLUfree(*mlu);\n           *mlu = (cmsMLU*)Type_Text_Read(self, io, &nItems, SizeOfTag);\n           return (*mlu != NULL);\n\n       case cmsSigTextDescriptionType:\n           if (*mlu) cmsMLUfree(*mlu);\n           *mlu =  (cmsMLU*) Type_Text_Description_Read(self, io, &nItems, SizeOfTag);\n           return (*mlu != NULL);\n\n           /*\n           TBD: Size is needed for MLU, and we have no idea on which is the available size\n           */\n\n       case cmsSigMultiLocalizedUnicodeType:\n           if (*mlu) cmsMLUfree(*mlu);\n           *mlu =  (cmsMLU*) Type_MLU_Read(self, io, &nItems, SizeOfTag);\n           return (*mlu != NULL);\n\n       default: return FALSE;\n    }\n}",
          "fn_code_pos": [
            [
              3500,
              0
            ],
            [
              3531,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadEmbeddedText",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "mlu": "cmsMLU",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid *Type_ProfileSequenceDesc_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsSEQ* OutSeq;\n    cmsUInt32Number i, Count;\n\n    *nItems = 0;\n\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n\n    if (SizeOfTag < sizeof(cmsUInt32Number)) return NULL;\n    SizeOfTag -= sizeof(cmsUInt32Number);\n\n\n    OutSeq = cmsAllocProfileSequenceDescription(self ->ContextID, Count);\n    if (OutSeq == NULL) return NULL;\n\n    OutSeq ->n = Count;\n\n    // Get structures as well\n\n    for (i=0; i < Count; i++) {\n\n        cmsPSEQDESC* sec = &OutSeq -> seq[i];\n\n        if (!_cmsReadUInt32Number(io, &sec ->deviceMfg)) goto Error;\n        if (SizeOfTag < sizeof(cmsUInt32Number)) goto Error;\n        SizeOfTag -= sizeof(cmsUInt32Number);\n\n        if (!_cmsReadUInt32Number(io, &sec ->deviceModel)) goto Error;\n        if (SizeOfTag < sizeof(cmsUInt32Number)) goto Error;\n        SizeOfTag -= sizeof(cmsUInt32Number);\n\n        if (!_cmsReadUInt64Number(io, &sec ->attributes)) goto Error;\n        if (SizeOfTag < sizeof(cmsUInt64Number)) goto Error;\n        SizeOfTag -= sizeof(cmsUInt64Number);\n\n        if (!_cmsReadUInt32Number(io, (cmsUInt32Number *)&sec ->technology)) goto Error;\n        if (SizeOfTag < sizeof(cmsUInt32Number)) goto Error;\n        SizeOfTag -= sizeof(cmsUInt32Number);\n\n        if (!ReadEmbeddedText(self, io, &sec ->Manufacturer, SizeOfTag)) goto Error;\n        if (!ReadEmbeddedText(self, io, &sec ->Model, SizeOfTag)) goto Error;\n    }\n\n    *nItems = 1;\n    return OutSeq;\n\nError:\n    cmsFreeProfileSequenceDescription(OutSeq);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              3534,
              0
            ],
            [
              3585,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ProfileSequenceDesc_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  SaveDescription(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU* Text)\n{\n    if (self ->ICCVersion < 0x4000000) {\n\n        if (!_cmsWriteTypeBase(io, cmsSigTextDescriptionType)) return FALSE;\n        return Type_Text_Description_Write(self, io, Text, 1);\n    }\n    else {\n        if (!_cmsWriteTypeBase(io, cmsSigMultiLocalizedUnicodeType)) return FALSE;\n        return Type_MLU_Write(self, io, Text, 1);\n    }\n}",
          "fn_code_pos": [
            [
              3590,
              0
            ],
            [
              3602,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SaveDescription",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Text": "cmsMLU"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool  Type_ProfileSequenceDesc_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsSEQ* Seq = (cmsSEQ*) Ptr;\n    cmsUInt32Number i;\n\n    if (!_cmsWriteUInt32Number(io, Seq->n)) return FALSE;\n\n    for (i=0; i < Seq ->n; i++) {\n\n        cmsPSEQDESC* sec = &Seq -> seq[i];\n\n        if (!_cmsWriteUInt32Number(io, sec ->deviceMfg)) return FALSE;\n        if (!_cmsWriteUInt32Number(io, sec ->deviceModel)) return FALSE;\n        if (!_cmsWriteUInt64Number(io, &sec ->attributes)) return FALSE;\n        if (!_cmsWriteUInt32Number(io, sec ->technology)) return FALSE;\n\n        if (!SaveDescription(self, io, sec ->Manufacturer)) return FALSE;\n        if (!SaveDescription(self, io, sec ->Model)) return FALSE;\n    }\n\n     return TRUE;\n\n     cmsUNUSED_PARAMETER(nItems);\n}",
          "fn_code_pos": [
            [
              3605,
              0
            ],
            [
              3629,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ProfileSequenceDesc_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_ProfileSequenceDesc_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsDupProfileSequenceDescription((cmsSEQ*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              3632,
              0
            ],
            [
              3639,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ProfileSequenceDesc_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_ProfileSequenceDesc_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsFreeProfileSequenceDescription((cmsSEQ*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              3641,
              0
            ],
            [
              3648,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ProfileSequenceDesc_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool ReadSeqID(struct _cms_typehandler_struct* self,\n                                             cmsIOHANDLER* io,\n                                             void* Cargo,\n                                             cmsUInt32Number n,\n                                             cmsUInt32Number SizeOfTag)\n{\n    cmsSEQ* OutSeq = (cmsSEQ*) Cargo;\n    cmsPSEQDESC* seq = &OutSeq ->seq[n];\n\n    if (io -> Read(io, seq ->ProfileID.ID8, 16, 1) != 1) return FALSE;\n    if (!ReadEmbeddedText(self, io, &seq ->Description, SizeOfTag)) return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              3662,
              0
            ],
            [
              3676,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadSeqID",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Cargo": "void",
              "n": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid *Type_ProfileSequenceId_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsSEQ* OutSeq;\n    cmsUInt32Number Count;\n    cmsUInt32Number BaseOffset;\n\n    *nItems = 0;\n\n    // Get actual position as a basis for element offsets\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    // Get table count\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n\n    // Allocate an empty structure\n    OutSeq = cmsAllocProfileSequenceDescription(self ->ContextID, Count);\n    if (OutSeq == NULL) return NULL;\n\n\n    // Read the position table\n    if (!ReadPositionTable(self, io, Count, BaseOffset, OutSeq, ReadSeqID)) {\n\n        cmsFreeProfileSequenceDescription(OutSeq);\n        return NULL;\n    }\n\n    // Success\n    *nItems = 1;\n    return OutSeq;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              3680,
              0
            ],
            [
              3712,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ProfileSequenceId_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool WriteSeqID(struct _cms_typehandler_struct* self,\n                                             cmsIOHANDLER* io,\n                                             void* Cargo,\n                                             cmsUInt32Number n,\n                                             cmsUInt32Number SizeOfTag)\n{\n    cmsSEQ* Seq = (cmsSEQ*) Cargo;\n\n    if (!io ->Write(io, 16, Seq ->seq[n].ProfileID.ID8)) return FALSE;\n\n    // Store here the MLU\n    if (!SaveDescription(self, io, Seq ->seq[n].Description)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              3715,
              0
            ],
            [
              3732,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteSeqID",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Cargo": "void",
              "n": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool  Type_ProfileSequenceId_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsSEQ* Seq = (cmsSEQ*) Ptr;\n    cmsUInt32Number BaseOffset;\n\n    // Keep the base offset\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    // This is the table count\n    if (!_cmsWriteUInt32Number(io, Seq ->n)) return FALSE;\n\n    // This is the position table and content\n    if (!WritePositionTable(self, io, 0, Seq ->n, BaseOffset, Seq, WriteSeqID)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}",
          "fn_code_pos": [
            [
              3734,
              0
            ],
            [
              3752,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ProfileSequenceId_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_ProfileSequenceId_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsDupProfileSequenceDescription((cmsSEQ*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              3754,
              0
            ],
            [
              3761,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ProfileSequenceId_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_ProfileSequenceId_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsFreeProfileSequenceDescription((cmsSEQ*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              3763,
              0
            ],
            [
              3770,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ProfileSequenceId_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid *Type_UcrBg_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUcrBg* n = (cmsUcrBg*) _cmsMallocZero(self ->ContextID, sizeof(cmsUcrBg));\n    cmsUInt32Number CountUcr, CountBg;\n    cmsInt32Number SignedSizeOfTag = (cmsInt32Number)SizeOfTag;\n    char* ASCIIString;\n\n    *nItems = 0;\n    if (n == NULL) return NULL;\n\n    // First curve is Under color removal\n\n    if (SignedSizeOfTag < (cmsInt32Number) sizeof(cmsUInt32Number)) return NULL;\n    if (!_cmsReadUInt32Number(io, &CountUcr)) return NULL;\n    SignedSizeOfTag -= sizeof(cmsUInt32Number);\n\n    n ->Ucr = cmsBuildTabulatedToneCurve16(self ->ContextID, CountUcr, NULL);\n    if (n ->Ucr == NULL) goto error;\n\n    if (SignedSizeOfTag < (cmsInt32Number)(CountUcr * sizeof(cmsUInt16Number))) goto error;\n    if (!_cmsReadUInt16Array(io, CountUcr, n ->Ucr->Table16)) goto error;\n  \n    SignedSizeOfTag -= CountUcr * sizeof(cmsUInt16Number);\n\n    // Second curve is Black generation\n\n    if (SignedSizeOfTag < (cmsInt32Number)sizeof(cmsUInt32Number)) goto error;\n    if (!_cmsReadUInt32Number(io, &CountBg)) goto error;\n    SignedSizeOfTag -= sizeof(cmsUInt32Number);\n\n    n ->Bg = cmsBuildTabulatedToneCurve16(self ->ContextID, CountBg, NULL);\n    if (n ->Bg == NULL) goto error;\n\n    if (SignedSizeOfTag < (cmsInt32Number) (CountBg * sizeof(cmsUInt16Number))) goto error;\n    if (!_cmsReadUInt16Array(io, CountBg, n ->Bg->Table16)) goto error;\n    SignedSizeOfTag -= CountBg * sizeof(cmsUInt16Number);\n\n    if (SignedSizeOfTag < 0 || SignedSizeOfTag > 32000) goto error;\n\n    // Now comes the text. The length is specified by the tag size\n    n ->Desc = cmsMLUalloc(self ->ContextID, 1);\n    if (n ->Desc == NULL) goto error;\n\n    ASCIIString = (char*) _cmsMalloc(self ->ContextID, SignedSizeOfTag + 1);\n    if (io->Read(io, ASCIIString, sizeof(char), SignedSizeOfTag) != (cmsUInt32Number)SignedSizeOfTag)\n    {\n        _cmsFree(self->ContextID, ASCIIString);\n        goto error;\n    }\n\n    ASCIIString[SignedSizeOfTag] = 0;\n    cmsMLUsetASCII(n ->Desc, cmsNoLanguage, cmsNoCountry, ASCIIString);\n    _cmsFree(self ->ContextID, ASCIIString);\n\n    *nItems = 1;\n    return (void*) n;\n\nerror:\n\n    if (n->Ucr) cmsFreeToneCurve(n->Ucr);\n    if (n->Bg) cmsFreeToneCurve(n->Bg);\n    if (n->Desc) cmsMLUfree(n->Desc);\n    _cmsFree(self->ContextID, n);\n    *nItems = 0;\n    return NULL;\n\n}",
          "fn_code_pos": [
            [
              3782,
              0
            ],
            [
              3849,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UcrBg_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  Type_UcrBg_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUcrBg* Value = (cmsUcrBg*) Ptr;\n    cmsUInt32Number TextSize;\n    char* Text;\n\n    // First curve is Under color removal\n    if (!_cmsWriteUInt32Number(io, Value ->Ucr ->nEntries)) return FALSE;\n    if (!_cmsWriteUInt16Array(io, Value ->Ucr ->nEntries, Value ->Ucr ->Table16)) return FALSE;\n\n    // Then black generation\n    if (!_cmsWriteUInt32Number(io, Value ->Bg ->nEntries)) return FALSE;\n    if (!_cmsWriteUInt16Array(io, Value ->Bg ->nEntries, Value ->Bg ->Table16)) return FALSE;\n\n    // Now comes the text. The length is specified by the tag size\n    TextSize = cmsMLUgetASCII(Value ->Desc, cmsNoLanguage, cmsNoCountry, NULL, 0);\n    Text     = (char*) _cmsMalloc(self ->ContextID, TextSize);\n    if (cmsMLUgetASCII(Value ->Desc, cmsNoLanguage, cmsNoCountry, Text, TextSize) != TextSize) return FALSE;\n\n    if (!io ->Write(io, TextSize, Text)) return FALSE;\n    _cmsFree(self ->ContextID, Text);\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}",
          "fn_code_pos": [
            [
              3851,
              0
            ],
            [
              3877,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UcrBg_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_UcrBg_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    cmsUcrBg* Src = (cmsUcrBg*) Ptr;\n    cmsUcrBg* NewUcrBg = (cmsUcrBg*) _cmsMallocZero(self ->ContextID, sizeof(cmsUcrBg));\n\n    if (NewUcrBg == NULL) return NULL;\n\n    NewUcrBg ->Bg   = cmsDupToneCurve(Src ->Bg);\n    NewUcrBg ->Ucr  = cmsDupToneCurve(Src ->Ucr);\n    NewUcrBg ->Desc = cmsMLUdup(Src ->Desc);\n\n    return (void*) NewUcrBg;\n\n    cmsUNUSED_PARAMETER(n);\n}",
          "fn_code_pos": [
            [
              3879,
              0
            ],
            [
              3894,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UcrBg_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_UcrBg_Free(struct _cms_typehandler_struct* self, void *Ptr)\n{\n   cmsUcrBg* Src = (cmsUcrBg*) Ptr;\n\n   if (Src ->Ucr) cmsFreeToneCurve(Src ->Ucr);\n   if (Src ->Bg)  cmsFreeToneCurve(Src ->Bg);\n   if (Src ->Desc) cmsMLUfree(Src ->Desc);\n\n   _cmsFree(self ->ContextID, Ptr);\n}",
          "fn_code_pos": [
            [
              3896,
              0
            ],
            [
              3906,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UcrBg_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  ReadCountAndString(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU* mlu, cmsUInt32Number* SizeOfTag, const char* Section)\n{\n    cmsUInt32Number Count;\n    char* Text;\n\n    if (*SizeOfTag < sizeof(cmsUInt32Number)) return FALSE;\n\n    if (!_cmsReadUInt32Number(io, &Count)) return FALSE;\n\n    if (Count > UINT_MAX - sizeof(cmsUInt32Number)) return FALSE;\n    if (*SizeOfTag < Count + sizeof(cmsUInt32Number)) return FALSE;\n\n    Text     = (char*) _cmsMalloc(self ->ContextID, Count+1);\n    if (Text == NULL) return FALSE;\n\n    if (io ->Read(io, Text, sizeof(cmsUInt8Number), Count) != Count) {\n        _cmsFree(self ->ContextID, Text);\n        return FALSE;\n    }\n\n    Text[Count] = 0;\n\n    cmsMLUsetASCII(mlu, \"PS\", Section, Text);\n    _cmsFree(self ->ContextID, Text);\n\n    *SizeOfTag -= (Count + sizeof(cmsUInt32Number));\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              3928,
              0
            ],
            [
              3956,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadCountAndString",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "mlu": "cmsMLU",
              "SizeOfTag": "cmsUInt32Number",
              "Section": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool  WriteCountAndString(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsMLU* mlu, const char* Section)\n{\n cmsUInt32Number TextSize;\n char* Text;\n\n    TextSize = cmsMLUgetASCII(mlu, \"PS\", Section, NULL, 0);\n    Text     = (char*) _cmsMalloc(self ->ContextID, TextSize);\n\n    if (!_cmsWriteUInt32Number(io, TextSize)) return FALSE;\n\n    if (cmsMLUgetASCII(mlu, \"PS\", Section, Text, TextSize) == 0) return FALSE;\n\n    if (!io ->Write(io, TextSize, Text)) return FALSE;\n    _cmsFree(self ->ContextID, Text);\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              3958,
              0
            ],
            [
              3975,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteCountAndString",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "mlu": "cmsMLU",
              "Section": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid *Type_CrdInfo_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsMLU* mlu = cmsMLUalloc(self ->ContextID, 5);\n\n    *nItems = 0;\n    if (!ReadCountAndString(self, io, mlu, &SizeOfTag, \"nm\")) goto Error;\n    if (!ReadCountAndString(self, io, mlu, &SizeOfTag, \"#0\")) goto Error;\n    if (!ReadCountAndString(self, io, mlu, &SizeOfTag, \"#1\")) goto Error;\n    if (!ReadCountAndString(self, io, mlu, &SizeOfTag, \"#2\")) goto Error;\n    if (!ReadCountAndString(self, io, mlu, &SizeOfTag, \"#3\")) goto Error;\n\n    *nItems = 1;\n    return (void*) mlu;\n\nError:\n    cmsMLUfree(mlu);\n    return NULL;\n\n}",
          "fn_code_pos": [
            [
              3977,
              0
            ],
            [
              3996,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_CrdInfo_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  Type_CrdInfo_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n\n    cmsMLU* mlu = (cmsMLU*) Ptr;\n\n    if (!WriteCountAndString(self, io, mlu, \"nm\")) goto Error;\n    if (!WriteCountAndString(self, io, mlu, \"#0\")) goto Error;\n    if (!WriteCountAndString(self, io, mlu, \"#1\")) goto Error;\n    if (!WriteCountAndString(self, io, mlu, \"#2\")) goto Error;\n    if (!WriteCountAndString(self, io, mlu, \"#3\")) goto Error;\n\n    return TRUE;\n\nError:\n    return FALSE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}",
          "fn_code_pos": [
            [
              3998,
              0
            ],
            [
              4016,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_CrdInfo_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_CrdInfo_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsMLUdup((cmsMLU*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              4019,
              0
            ],
            [
              4026,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_CrdInfo_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_CrdInfo_Free(struct _cms_typehandler_struct* self, void *Ptr)\n{\n    cmsMLUfree((cmsMLU*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              4028,
              0
            ],
            [
              4035,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_CrdInfo_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid *Type_Screening_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsScreening* sc = NULL;\n    cmsUInt32Number i;\n\n    sc = (cmsScreening*) _cmsMallocZero(self ->ContextID, sizeof(cmsScreening));\n    if (sc == NULL) return NULL;\n\n    *nItems = 0;\n\n    if (!_cmsReadUInt32Number(io, &sc ->Flag)) goto Error;\n    if (!_cmsReadUInt32Number(io, &sc ->nChannels)) goto Error;\n\n    if (sc ->nChannels > cmsMAXCHANNELS - 1)\n        sc ->nChannels = cmsMAXCHANNELS - 1;\n\n    for (i=0; i < sc ->nChannels; i++) {\n\n        if (!_cmsRead15Fixed16Number(io, &sc ->Channels[i].Frequency)) goto Error;\n        if (!_cmsRead15Fixed16Number(io, &sc ->Channels[i].ScreenAngle)) goto Error;\n        if (!_cmsReadUInt32Number(io, &sc ->Channels[i].SpotShape)) goto Error;\n    }\n\n\n    *nItems = 1;\n\n    return (void*) sc;\n\nError:\n    if (sc != NULL)\n        _cmsFree(self ->ContextID, sc);\n\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              4044,
              0
            ],
            [
              4080,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Screening_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_Screening_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsScreening* sc = (cmsScreening* ) Ptr;\n    cmsUInt32Number i;\n\n    if (!_cmsWriteUInt32Number(io, sc ->Flag)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, sc ->nChannels)) return FALSE;\n\n    for (i=0; i < sc ->nChannels; i++) {\n\n        if (!_cmsWrite15Fixed16Number(io, sc ->Channels[i].Frequency)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, sc ->Channels[i].ScreenAngle)) return FALSE;\n        if (!_cmsWriteUInt32Number(io, sc ->Channels[i].SpotShape)) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              4083,
              0
            ],
            [
              4103,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Screening_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_Screening_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n   return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsScreening));\n\n   cmsUNUSED_PARAMETER(n);\n}",
          "fn_code_pos": [
            [
              4106,
              0
            ],
            [
              4112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Screening_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_Screening_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n   _cmsFree(self ->ContextID, Ptr);\n}",
          "fn_code_pos": [
            [
              4115,
              0
            ],
            [
              4119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Screening_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid *Type_ViewingConditions_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsICCViewingConditions* vc = NULL;\n\n    vc = (cmsICCViewingConditions*) _cmsMallocZero(self ->ContextID, sizeof(cmsICCViewingConditions));\n    if (vc == NULL) return NULL;\n\n    *nItems = 0;\n\n    if (!_cmsReadXYZNumber(io, &vc ->IlluminantXYZ)) goto Error;\n    if (!_cmsReadXYZNumber(io, &vc ->SurroundXYZ)) goto Error;\n    if (!_cmsReadUInt32Number(io, &vc ->IlluminantType)) goto Error;\n\n    *nItems = 1;\n\n    return (void*) vc;\n\nError:\n    if (vc != NULL)\n        _cmsFree(self ->ContextID, vc);\n\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              4129,
              0
            ],
            [
              4154,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ViewingConditions_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_ViewingConditions_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsICCViewingConditions* sc = (cmsICCViewingConditions* ) Ptr;\n\n    if (!_cmsWriteXYZNumber(io, &sc ->IlluminantXYZ)) return FALSE;\n    if (!_cmsWriteXYZNumber(io, &sc ->SurroundXYZ)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, sc ->IlluminantType)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              4157,
              0
            ],
            [
              4170,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ViewingConditions_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_ViewingConditions_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n   return _cmsDupMem(self->ContextID, Ptr, sizeof(cmsICCViewingConditions));\n\n   cmsUNUSED_PARAMETER(n);\n}",
          "fn_code_pos": [
            [
              4173,
              0
            ],
            [
              4179,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ViewingConditions_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_ViewingConditions_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n   _cmsFree(self ->ContextID, Ptr);\n}",
          "fn_code_pos": [
            [
              4182,
              0
            ],
            [
              4186,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ViewingConditions_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* GenericMPEdup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsStageDup((cmsStage*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              4194,
              0
            ],
            [
              4201,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GenericMPEdup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid GenericMPEfree(struct _cms_typehandler_struct* self, void *Ptr)\n{\n    cmsStageFree((cmsStage*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              4203,
              0
            ],
            [
              4210,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GenericMPEfree",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsToneCurve* ReadSegmentedCurve(struct _cms_typehandler_struct* self, cmsIOHANDLER* io)\n{\n    cmsCurveSegSignature ElementSig;\n    cmsUInt32Number i, j;\n    cmsUInt16Number nSegments;\n    cmsCurveSegment*  Segments;\n    cmsToneCurve* Curve;\n    cmsFloat32Number PrevBreak = MINUS_INF;    // - infinite\n\n    // Take signature and channels for each element.\n     if (!_cmsReadUInt32Number(io, (cmsUInt32Number*) &ElementSig)) return NULL;\n\n     // That should be a segmented curve\n     if (ElementSig != cmsSigSegmentedCurve) return NULL;\n\n     if (!_cmsReadUInt32Number(io, NULL)) return NULL;\n     if (!_cmsReadUInt16Number(io, &nSegments)) return NULL;\n     if (!_cmsReadUInt16Number(io, NULL)) return NULL;\n\n     if (nSegments < 1) return NULL;\n     Segments = (cmsCurveSegment*) _cmsCalloc(self ->ContextID, nSegments, sizeof(cmsCurveSegment));\n     if (Segments == NULL) return NULL;\n\n     // Read breakpoints\n     for (i=0; i < (cmsUInt32Number) nSegments - 1; i++) {\n\n         Segments[i].x0 = PrevBreak;\n         if (!_cmsReadFloat32Number(io, &Segments[i].x1)) goto Error;\n         PrevBreak = Segments[i].x1;\n     }\n\n     Segments[nSegments-1].x0 = PrevBreak;\n     Segments[nSegments-1].x1 = PLUS_INF;     // A big cmsFloat32Number number\n\n     // Read segments\n     for (i=0; i < nSegments; i++) {\n\n          if (!_cmsReadUInt32Number(io, (cmsUInt32Number*) &ElementSig)) goto Error;\n          if (!_cmsReadUInt32Number(io, NULL)) goto Error;\n\n           switch (ElementSig) {\n\n           case cmsSigFormulaCurveSeg: {\n\n               cmsUInt16Number Type;\n               cmsUInt32Number ParamsByType[] = { 4, 5, 5 };\n\n               if (!_cmsReadUInt16Number(io, &Type)) goto Error;\n               if (!_cmsReadUInt16Number(io, NULL)) goto Error;\n\n               Segments[i].Type = Type + 6;\n               if (Type > 2) goto Error;\n\n               for (j = 0; j < ParamsByType[Type]; j++) {\n\n                   cmsFloat32Number f;\n                   if (!_cmsReadFloat32Number(io, &f)) goto Error;\n                   Segments[i].Params[j] = f;\n               }\n           }\n           break;\n\n\n           case cmsSigSampledCurveSeg: {\n               cmsUInt32Number Count;\n\n               if (!_cmsReadUInt32Number(io, &Count)) goto Error;\n\n               // The first point is implicit in the last stage, we allocate an extra note to be populated latter on\n               Count++;\n               Segments[i].nGridPoints = Count;\n               Segments[i].SampledPoints = (cmsFloat32Number*)_cmsCalloc(self->ContextID, Count, sizeof(cmsFloat32Number));\n               if (Segments[i].SampledPoints == NULL) goto Error;\n\n               Segments[i].SampledPoints[0] = 0;\n               for (j = 1; j < Count; j++) {\n                   if (!_cmsReadFloat32Number(io, &Segments[i].SampledPoints[j])) goto Error;\n               }\n           }\n           break;\n\n            default:\n                {\n                char String[5];\n\n                _cmsTagSignature2String(String, (cmsTagSignature) ElementSig);\n                cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown curve element type '%s' found.\", String);\n                }\n                goto Error;\n\n         }\n     }\n\n     Curve = cmsBuildSegmentedToneCurve(self ->ContextID, nSegments, Segments);\n\n     for (i=0; i < nSegments; i++) {\n         if (Segments[i].SampledPoints) _cmsFree(self ->ContextID, Segments[i].SampledPoints);\n     }\n     _cmsFree(self ->ContextID, Segments);\n\n     // Explore for missing implicit points \n     for (i = 0; i < nSegments; i++) {\n\n         // If sampled curve, fix it\n         if (Curve->Segments[i].Type == 0) {\n\n             Curve->Segments[i].SampledPoints[0] = cmsEvalToneCurveFloat(Curve, Curve->Segments[i].x0);\n         }\n     }\n\n     return Curve;\n\nError:\n     if (Segments) {\n         for (i=0; i < nSegments; i++) {\n             if (Segments[i].SampledPoints) _cmsFree(self ->ContextID, Segments[i].SampledPoints);\n         }\n         _cmsFree(self ->ContextID, Segments);\n     }\n     return NULL;\n}",
          "fn_code_pos": [
            [
              4219,
              0
            ],
            [
              4340,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadSegmentedCurve",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER"
            },
            "return_type": "cmsToneCurve"
          }
        },
        {
          "fn_code": "static\ncmsBool ReadMPECurve(struct _cms_typehandler_struct* self,\n                     cmsIOHANDLER* io,\n                     void* Cargo,\n                     cmsUInt32Number n,\n                     cmsUInt32Number SizeOfTag)\n{\n      cmsToneCurve** GammaTables = ( cmsToneCurve**) Cargo;\n\n      GammaTables[n] = ReadSegmentedCurve(self, io);\n      return (GammaTables[n] != NULL);\n\n      cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              4343,
              0
            ],
            [
              4356,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadMPECurve",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Cargo": "void",
              "n": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid *Type_MPEcurve_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsStage* mpe = NULL;\n    cmsUInt16Number InputChans, OutputChans;\n    cmsUInt32Number i, BaseOffset;\n    cmsToneCurve** GammaTables;\n\n    *nItems = 0;\n\n    // Get actual position as a basis for element offsets\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;\n    if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;\n\n    if (InputChans != OutputChans) return NULL;\n\n    GammaTables = (cmsToneCurve**) _cmsCalloc(self ->ContextID, InputChans, sizeof(cmsToneCurve*));\n    if (GammaTables == NULL) return NULL;\n\n    if (ReadPositionTable(self, io, InputChans, BaseOffset, GammaTables, ReadMPECurve)) {\n\n        mpe = cmsStageAllocToneCurves(self ->ContextID, InputChans, GammaTables);\n    }\n    else {\n        mpe = NULL;\n    }\n\n    for (i=0; i < InputChans; i++) {\n        if (GammaTables[i]) cmsFreeToneCurve(GammaTables[i]);\n    }\n\n    _cmsFree(self ->ContextID, GammaTables);\n    *nItems = (mpe != NULL) ? 1U : 0;\n    return mpe;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              4358,
              0
            ],
            [
              4396,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MPEcurve_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool WriteSegmentedCurve(cmsIOHANDLER* io, cmsToneCurve* g)\n{\n    cmsUInt32Number i, j;\n    cmsCurveSegment* Segments = g ->Segments;\n    cmsUInt32Number nSegments = g ->nSegments;\n\n    if (!_cmsWriteUInt32Number(io, cmsSigSegmentedCurve)) goto Error;\n    if (!_cmsWriteUInt32Number(io, 0)) goto Error;\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) nSegments)) goto Error;\n    if (!_cmsWriteUInt16Number(io, 0)) goto Error;\n\n    // Write the break-points\n    for (i=0; i < nSegments - 1; i++) {\n        if (!_cmsWriteFloat32Number(io, Segments[i].x1)) goto Error;\n    }\n\n    // Write the segments\n    for (i=0; i < g ->nSegments; i++) {\n\n        cmsCurveSegment* ActualSeg = Segments + i;\n\n        if (ActualSeg -> Type == 0) {\n\n            // This is a sampled curve. First point is implicit in the ICC format, but not in our representation\n            if (!_cmsWriteUInt32Number(io, (cmsUInt32Number) cmsSigSampledCurveSeg)) goto Error;\n            if (!_cmsWriteUInt32Number(io, 0)) goto Error;\n            if (!_cmsWriteUInt32Number(io, ActualSeg -> nGridPoints - 1)) goto Error;\n\n            for (j=1; j < g ->Segments[i].nGridPoints; j++) {\n                if (!_cmsWriteFloat32Number(io, ActualSeg -> SampledPoints[j])) goto Error;\n            }\n\n        }\n        else {\n            int Type;\n            cmsUInt32Number ParamsByType[] = { 4, 5, 5 };\n\n            // This is a formula-based\n            if (!_cmsWriteUInt32Number(io, (cmsUInt32Number) cmsSigFormulaCurveSeg)) goto Error;\n            if (!_cmsWriteUInt32Number(io, 0)) goto Error;\n\n            // We only allow 1, 2 and 3 as types\n            Type = ActualSeg ->Type - 6;\n            if (Type > 2 || Type < 0) goto Error;\n\n            if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) Type)) goto Error;\n            if (!_cmsWriteUInt16Number(io, 0)) goto Error;\n\n            for (j=0; j < ParamsByType[Type]; j++) {\n                if (!_cmsWriteFloat32Number(io, (cmsFloat32Number) ActualSeg ->Params[j])) goto Error;\n            }\n        }\n\n        // It seems there is no need to align. Code is here, and for safety commented out\n        // if (!_cmsWriteAlignment(io)) goto Error;\n    }\n\n    return TRUE;\n\nError:\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              4400,
              0
            ],
            [
              4462,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteSegmentedCurve",
            "parameters": {
              "io": "cmsIOHANDLER",
              "g": "cmsToneCurve"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool WriteMPECurve(struct _cms_typehandler_struct* self,\n                      cmsIOHANDLER* io,\n                      void* Cargo,\n                      cmsUInt32Number n,\n                      cmsUInt32Number SizeOfTag)\n{\n    _cmsStageToneCurvesData* Curves  = (_cmsStageToneCurvesData*) Cargo;\n\n    return WriteSegmentedCurve(io, Curves ->TheCurves[n]);\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              4465,
              0
            ],
            [
              4478,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteMPECurve",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Cargo": "void",
              "n": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool  Type_MPEcurve_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt32Number BaseOffset;\n    cmsStage* mpe = (cmsStage*) Ptr;\n    _cmsStageToneCurvesData* Curves = (_cmsStageToneCurvesData*) mpe ->Data;\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    // Write the header. Since those are curves, input and output channels are same\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->InputChannels)) return FALSE;\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->InputChannels)) return FALSE;\n\n    if (!WritePositionTable(self, io, 0,\n                                mpe ->InputChannels, BaseOffset, Curves, WriteMPECurve)) return FALSE;\n\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}",
          "fn_code_pos": [
            [
              4481,
              0
            ],
            [
              4501,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MPEcurve_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid *Type_MPEmatrix_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsStage* mpe;\n    cmsUInt16Number   InputChans, OutputChans;\n    cmsUInt32Number   nElems, i;\n    cmsFloat64Number* Matrix;\n    cmsFloat64Number* Offsets;\n\n    if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;\n    if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;\n\n\n    // Input and output chans may be ANY (up to 0xffff), \n    // but we choose to limit to 16 channels for now\n    if (InputChans >= cmsMAXCHANNELS) return NULL;\n    if (OutputChans >= cmsMAXCHANNELS) return NULL;\n\n    nElems = (cmsUInt32Number) InputChans * OutputChans;\n\n    Matrix = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, nElems, sizeof(cmsFloat64Number));\n    if (Matrix == NULL) return NULL;\n\n    Offsets = (cmsFloat64Number*) _cmsCalloc(self ->ContextID, OutputChans, sizeof(cmsFloat64Number));\n    if (Offsets == NULL) {\n\n        _cmsFree(self ->ContextID, Matrix);\n        return NULL;\n    }\n\n    for (i=0; i < nElems; i++) {\n\n        cmsFloat32Number v;\n\n        if (!_cmsReadFloat32Number(io, &v)) {\n            _cmsFree(self ->ContextID, Matrix);\n            _cmsFree(self ->ContextID, Offsets);\n            return NULL;\n        }\n        Matrix[i] = v;\n    }\n\n\n    for (i=0; i < OutputChans; i++) {\n\n        cmsFloat32Number v;\n\n        if (!_cmsReadFloat32Number(io, &v)) {\n            _cmsFree(self ->ContextID, Matrix);\n            _cmsFree(self ->ContextID, Offsets);\n            return NULL;\n        }\n        Offsets[i] = v;\n    }\n\n\n    mpe = cmsStageAllocMatrix(self ->ContextID, OutputChans, InputChans, Matrix, Offsets);\n    _cmsFree(self ->ContextID, Matrix);\n    _cmsFree(self ->ContextID, Offsets);\n\n    *nItems = 1;\n\n    return mpe;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              4510,
              0
            ],
            [
              4575,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MPEmatrix_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  Type_MPEmatrix_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt32Number i, nElems;\n    cmsStage* mpe = (cmsStage*) Ptr;\n    _cmsStageMatrixData* Matrix = (_cmsStageMatrixData*) mpe ->Data;\n\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->InputChannels)) return FALSE;\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->OutputChannels)) return FALSE;\n\n    nElems = mpe ->InputChannels * mpe ->OutputChannels;\n\n    for (i=0; i < nElems; i++) {\n        if (!_cmsWriteFloat32Number(io, (cmsFloat32Number) Matrix->Double[i])) return FALSE;\n    }\n\n\n    for (i=0; i < mpe ->OutputChannels; i++) {\n\n        if (Matrix ->Offset == NULL) {\n\n               if (!_cmsWriteFloat32Number(io, 0)) return FALSE;\n        }\n        else {\n               if (!_cmsWriteFloat32Number(io, (cmsFloat32Number) Matrix->Offset[i])) return FALSE;\n        }\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              4577,
              0
            ],
            [
              4609,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MPEmatrix_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid *Type_MPEclut_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsStage* mpe = NULL;\n    cmsUInt16Number InputChans, OutputChans;\n    cmsUInt8Number Dimensions8[16];\n    cmsUInt32Number i, nMaxGrids, GridPoints[MAX_INPUT_DIMENSIONS];\n    _cmsStageCLutData* clut;\n\n    if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;\n    if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;\n\n    if (InputChans == 0 || InputChans >= cmsMAXCHANNELS) goto Error;\n    if (OutputChans == 0 || OutputChans >= cmsMAXCHANNELS) goto Error;\n\n    if (io ->Read(io, Dimensions8, sizeof(cmsUInt8Number), 16) != 16)\n        goto Error;\n\n    // Copy MAX_INPUT_DIMENSIONS at most. Expand to cmsUInt32Number\n    nMaxGrids = InputChans > MAX_INPUT_DIMENSIONS ? (cmsUInt32Number) MAX_INPUT_DIMENSIONS : InputChans;\n\n    for (i = 0; i < nMaxGrids; i++) {\n        if (Dimensions8[i] == 1) goto Error; // Impossible value, 0 for no CLUT and then 2 at least\n        GridPoints[i] = (cmsUInt32Number)Dimensions8[i];\n    }\n    \n    // Allocate the true CLUT\n    mpe = cmsStageAllocCLutFloatGranular(self ->ContextID, GridPoints, InputChans, OutputChans, NULL);\n    if (mpe == NULL) goto Error;\n\n    // Read and sanitize the data\n    clut = (_cmsStageCLutData*) mpe ->Data;\n    for (i=0; i < clut ->nEntries; i++) {\n\n        if (!_cmsReadFloat32Number(io, &clut->Tab.TFloat[i])) goto Error;\n    }\n\n    *nItems = 1;\n    return mpe;\n\nError:\n    *nItems = 0;\n    if (mpe != NULL) cmsStageFree(mpe);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              4613,
              0
            ],
            [
              4659,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MPEclut_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool  Type_MPEclut_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt8Number Dimensions8[16];  // 16 because the spec says 16 and not max number of channels\n    cmsUInt32Number i;\n    cmsStage* mpe = (cmsStage*) Ptr;\n    _cmsStageCLutData* clut = (_cmsStageCLutData*) mpe ->Data;\n\n    // Check for maximum number of channels supported by lcms\n    if (mpe -> InputChannels > MAX_INPUT_DIMENSIONS) return FALSE;\n\n    // Only floats are supported in MPE\n    if (clut ->HasFloatValues == FALSE) return FALSE;\n\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->InputChannels)) return FALSE;\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) mpe ->OutputChannels)) return FALSE;\n\n    memset(Dimensions8, 0, sizeof(Dimensions8));\n\n    for (i=0; i < mpe ->InputChannels; i++)\n        Dimensions8[i] = (cmsUInt8Number) clut ->Params ->nSamples[i];\n\n    if (!io ->Write(io, 16, Dimensions8)) return FALSE;\n\n    for (i=0; i < clut ->nEntries; i++) {\n\n        if (!_cmsWriteFloat32Number(io, clut ->Tab.TFloat[i])) return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              4662,
              0
            ],
            [
              4695,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MPEclut_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool ReadMPEElem(struct _cms_typehandler_struct* self,\n                    cmsIOHANDLER* io,\n                    void* Cargo,\n                    cmsUInt32Number n,\n                    cmsUInt32Number SizeOfTag)\n{\n    cmsStageSignature ElementSig;\n    cmsTagTypeHandler* TypeHandler;\n    cmsUInt32Number nItems;\n    cmsPipeline *NewLUT = (cmsPipeline *) Cargo;\n    _cmsTagTypePluginChunkType* MPETypePluginChunk  = ( _cmsTagTypePluginChunkType*) _cmsContextGetClientChunk(self->ContextID, MPEPlugin);\n\n\n    // Take signature and channels for each element.\n    if (!_cmsReadUInt32Number(io, (cmsUInt32Number*) &ElementSig)) return FALSE;\n\n    // The reserved placeholder\n    if (!_cmsReadUInt32Number(io, NULL)) return FALSE;\n\n    // Read diverse MPE types\n    TypeHandler = GetHandler((cmsTagTypeSignature) ElementSig, MPETypePluginChunk ->TagTypes, SupportedMPEtypes);\n    if (TypeHandler == NULL)  {\n\n        char String[5];\n\n        _cmsTagSignature2String(String, (cmsTagSignature) ElementSig);\n\n        // An unknown element was found.\n        cmsSignalError(self ->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown MPE type '%s' found.\", String);\n        return FALSE;\n    }\n\n    // If no read method, just ignore the element (valid for cmsSigBAcsElemType and cmsSigEAcsElemType)\n    // Read the MPE. No size is given\n    if (TypeHandler ->ReadPtr != NULL) {\n\n        // This is a real element which should be read and processed\n        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, (cmsStage*) TypeHandler ->ReadPtr(self, io, &nItems, SizeOfTag)))\n            return FALSE;\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n    cmsUNUSED_PARAMETER(n);\n}",
          "fn_code_pos": [
            [
              4712,
              0
            ],
            [
              4758,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadMPEElem",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Cargo": "void",
              "n": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid *Type_MPE_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsUInt16Number InputChans, OutputChans;\n    cmsUInt32Number ElementCount;\n    cmsPipeline *NewLUT = NULL;\n    cmsUInt32Number BaseOffset;\n\n    // Get actual position as a basis for element offsets\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    // Read channels and element count\n    if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;\n    if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;\n\n    if (InputChans == 0 || InputChans >= cmsMAXCHANNELS) return NULL;\n    if (OutputChans == 0 || OutputChans >= cmsMAXCHANNELS) return NULL;\n\n    // Allocates an empty LUT\n    NewLUT = cmsPipelineAlloc(self ->ContextID, InputChans, OutputChans);\n    if (NewLUT == NULL) return NULL;\n\n    if (!_cmsReadUInt32Number(io, &ElementCount)) goto Error;    \n    if (!ReadPositionTable(self, io, ElementCount, BaseOffset, NewLUT, ReadMPEElem)) goto Error;\n\n    // Check channel count\n    if (InputChans != NewLUT->InputChannels ||\n        OutputChans != NewLUT->OutputChannels) goto Error;\n\n    // Success\n    *nItems = 1;\n    return NewLUT;\n\n    // Error\nError:    \n    if (NewLUT != NULL) cmsPipelineFree(NewLUT);\n    *nItems = 0;\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              4762,
              0
            ],
            [
              4802,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MPE_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_MPE_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt32Number i, BaseOffset, DirectoryPos, CurrentPos;\n    cmsUInt32Number inputChan, outputChan;\n    cmsUInt32Number ElemCount;\n    cmsUInt32Number *ElementOffsets = NULL, *ElementSizes = NULL, Before;\n    cmsStageSignature ElementSig;\n    cmsPipeline* Lut = (cmsPipeline*) Ptr;\n    cmsStage* Elem = Lut ->Elements;\n    cmsTagTypeHandler* TypeHandler;\n    _cmsTagTypePluginChunkType* MPETypePluginChunk  = ( _cmsTagTypePluginChunkType*) _cmsContextGetClientChunk(self->ContextID, MPEPlugin);\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    inputChan  = cmsPipelineInputChannels(Lut);\n    outputChan = cmsPipelineOutputChannels(Lut);\n    ElemCount  = cmsPipelineStageCount(Lut);\n\n    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number));\n    if (ElementOffsets == NULL) goto Error;\n\n    ElementSizes = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number));\n    if (ElementSizes == NULL) goto Error;\n\n    // Write the head\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) inputChan)) goto Error;\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) outputChan)) goto Error;\n    if (!_cmsWriteUInt32Number(io, (cmsUInt16Number) ElemCount)) goto Error;\n\n    DirectoryPos = io ->Tell(io);\n\n    // Write a fake directory to be filled latter on\n    for (i=0; i < ElemCount; i++) {\n        if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // Offset\n        if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // size\n    }\n\n    // Write each single tag. Keep track of the size as well.\n    for (i=0; i < ElemCount; i++) {\n\n        ElementOffsets[i] = io ->Tell(io) - BaseOffset;\n\n        ElementSig = Elem ->Type;\n\n        TypeHandler = GetHandler((cmsTagTypeSignature) ElementSig, MPETypePluginChunk->TagTypes, SupportedMPEtypes);\n        if (TypeHandler == NULL)  {\n\n                char String[5];\n\n                _cmsTagSignature2String(String, (cmsTagSignature) ElementSig);\n\n                 // An unknown element was found.\n                 cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Found unknown MPE type '%s'\", String);\n                 goto Error;\n        }\n\n        if (!_cmsWriteUInt32Number(io, ElementSig)) goto Error;\n        if (!_cmsWriteUInt32Number(io, 0)) goto Error;\n        Before = io ->Tell(io);\n        if (!TypeHandler ->WritePtr(self, io, Elem, 1)) goto Error;\n        if (!_cmsWriteAlignment(io)) goto Error;\n\n        ElementSizes[i] = io ->Tell(io) - Before;\n\n        Elem = Elem ->Next;\n    }\n\n    // Write the directory\n    CurrentPos = io ->Tell(io);\n\n    if (!io ->Seek(io, DirectoryPos)) goto Error;\n\n    for (i=0; i < ElemCount; i++) {\n        if (!_cmsWriteUInt32Number(io, ElementOffsets[i])) goto Error;\n        if (!_cmsWriteUInt32Number(io, ElementSizes[i])) goto Error;\n    }\n\n    if (!io ->Seek(io, CurrentPos)) goto Error;\n\n    if (ElementOffsets != NULL) _cmsFree(self ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(self ->ContextID, ElementSizes);\n    return TRUE;\n\nError:\n    if (ElementOffsets != NULL) _cmsFree(self ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(self ->ContextID, ElementSizes);\n    return FALSE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}",
          "fn_code_pos": [
            [
              4807,
              0
            ],
            [
              4897,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MPE_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_MPE_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsPipelineDup((cmsPipeline*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              4900,
              0
            ],
            [
              4907,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MPE_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_MPE_Free(struct _cms_typehandler_struct* self, void *Ptr)\n{\n    cmsPipelineFree((cmsPipeline*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              4909,
              0
            ],
            [
              4916,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MPE_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid *Type_vcgt_Read(struct _cms_typehandler_struct* self,\n                     cmsIOHANDLER* io,\n                     cmsUInt32Number* nItems,\n                     cmsUInt32Number SizeOfTag)\n{\n    cmsUInt32Number TagType, n, i;\n    cmsToneCurve** Curves;\n\n    *nItems = 0;\n\n    // Read tag type\n    if (!_cmsReadUInt32Number(io, &TagType)) return NULL;\n\n    // Allocate space for the array\n    Curves = ( cmsToneCurve**) _cmsCalloc(self ->ContextID, 3, sizeof(cmsToneCurve*));\n    if (Curves == NULL) return NULL;\n\n    // There are two possible flavors\n    switch (TagType) {\n\n    // Gamma is stored as a table\n    case cmsVideoCardGammaTableType:\n    {\n       cmsUInt16Number nChannels, nElems, nBytes;\n\n       // Check channel count, which should be 3 (we don't support monochrome this time)\n       if (!_cmsReadUInt16Number(io, &nChannels)) goto Error;\n\n       if (nChannels != 3) {\n           cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported number of channels for VCGT '%d'\", nChannels);\n           goto Error;\n       }\n\n       // Get Table element count and bytes per element\n       if (!_cmsReadUInt16Number(io, &nElems)) goto Error;\n       if (!_cmsReadUInt16Number(io, &nBytes)) goto Error;\n\n       // Adobe's quirk fixup. Fixing broken profiles...\n       if (nElems == 256 && nBytes == 1 && SizeOfTag == 1576)\n           nBytes = 2;\n\n\n       // Populate tone curves\n       for (n=0; n < 3; n++) {\n\n           Curves[n] = cmsBuildTabulatedToneCurve16(self ->ContextID, nElems, NULL);\n           if (Curves[n] == NULL) goto Error;\n\n           // On depending on byte depth\n           switch (nBytes) {\n\n           // One byte, 0..255\n           case 1:\n               for (i=0; i < nElems; i++) {\n\n                   cmsUInt8Number v;\n\n                      if (!_cmsReadUInt8Number(io, &v)) goto Error;\n                      Curves[n] ->Table16[i] = FROM_8_TO_16(v);\n               }\n               break;\n\n           // One word 0..65535\n           case 2:\n              if (!_cmsReadUInt16Array(io, nElems, Curves[n]->Table16)) goto Error;\n              break;\n\n          // Unsupported\n           default:\n              cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported bit depth for VCGT '%d'\", nBytes * 8);\n              goto Error;\n           }\n       } // For all 3 channels\n    }\n    break;\n\n   // In this case, gamma is stored as a formula\n   case cmsVideoCardGammaFormulaType:\n   {\n       _cmsVCGTGAMMA Colorant[3];\n\n        // Populate tone curves\n       for (n=0; n < 3; n++) {\n\n           double Params[10];\n\n           if (!_cmsRead15Fixed16Number(io, &Colorant[n].Gamma)) goto Error;\n           if (!_cmsRead15Fixed16Number(io, &Colorant[n].Min)) goto Error;\n           if (!_cmsRead15Fixed16Number(io, &Colorant[n].Max)) goto Error;\n\n            // Parametric curve type 5 is:\n            // Y = (aX + b)^Gamma + e | X >= d\n            // Y = cX + f             | X < d\n\n            // vcgt formula is:\n            // Y = (Max - Min) * (X ^ Gamma) + Min\n\n            // So, the translation is\n            // a = (Max - Min) ^ ( 1 / Gamma)\n            // e = Min\n            // b=c=d=f=0\n\n           Params[0] = Colorant[n].Gamma;\n           Params[1] = pow((Colorant[n].Max - Colorant[n].Min), (1.0 / Colorant[n].Gamma));\n           Params[2] = 0;\n           Params[3] = 0;\n           Params[4] = 0;\n           Params[5] = Colorant[n].Min;\n           Params[6] = 0;\n\n           Curves[n] = cmsBuildParametricToneCurve(self ->ContextID, 5, Params);\n           if (Curves[n] == NULL) goto Error;\n       }\n   }\n   break;\n\n   // Unsupported\n   default:\n      cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported tag type for VCGT '%d'\", TagType);\n      goto Error;\n   }\n\n   *nItems = 1;\n   return (void*) Curves;\n\n// Regret,  free all resources\nError:\n\n    cmsFreeToneCurveTriple(Curves);\n    _cmsFree(self ->ContextID, Curves);\n    return NULL;\n\n     cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              4935,
              0
            ],
            [
              5069,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_vcgt_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_vcgt_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsToneCurve** Curves =  (cmsToneCurve**) Ptr;\n    cmsUInt32Number i, j;\n\n    if (cmsGetToneCurveParametricType(Curves[0]) == 5 &&\n        cmsGetToneCurveParametricType(Curves[1]) == 5 &&\n        cmsGetToneCurveParametricType(Curves[2]) == 5) {\n\n            if (!_cmsWriteUInt32Number(io, cmsVideoCardGammaFormulaType)) return FALSE;\n\n            // Save parameters\n            for (i=0; i < 3; i++) {\n\n                _cmsVCGTGAMMA v;\n\n                v.Gamma = Curves[i] ->Segments[0].Params[0];\n                v.Min   = Curves[i] ->Segments[0].Params[5];\n                v.Max   = pow(Curves[i] ->Segments[0].Params[1], v.Gamma) + v.Min;\n\n                if (!_cmsWrite15Fixed16Number(io, v.Gamma)) return FALSE;\n                if (!_cmsWrite15Fixed16Number(io, v.Min)) return FALSE;\n                if (!_cmsWrite15Fixed16Number(io, v.Max)) return FALSE;\n            }\n    }\n\n    else {\n\n        // Always store as a table of 256 words\n        if (!_cmsWriteUInt32Number(io, cmsVideoCardGammaTableType)) return FALSE;\n        if (!_cmsWriteUInt16Number(io, 3)) return FALSE;\n        if (!_cmsWriteUInt16Number(io, 256)) return FALSE;\n        if (!_cmsWriteUInt16Number(io, 2)) return FALSE;\n\n        for (i=0; i < 3; i++) {\n            for (j=0; j < 256; j++) {\n\n                cmsFloat32Number v = cmsEvalToneCurveFloat(Curves[i], (cmsFloat32Number) (j / 255.0));\n                cmsUInt16Number  n = _cmsQuickSaturateWord(v * 65535.0);\n\n                if (!_cmsWriteUInt16Number(io, n)) return FALSE;\n            }\n        }\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(self);\n    cmsUNUSED_PARAMETER(nItems);\n}",
          "fn_code_pos": [
            [
              5073,
              0
            ],
            [
              5123,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_vcgt_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_vcgt_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    cmsToneCurve** OldCurves =  (cmsToneCurve**) Ptr;\n    cmsToneCurve** NewCurves;\n\n    NewCurves = ( cmsToneCurve**) _cmsCalloc(self ->ContextID, 3, sizeof(cmsToneCurve*));\n    if (NewCurves == NULL) return NULL;\n\n    NewCurves[0] = cmsDupToneCurve(OldCurves[0]);\n    NewCurves[1] = cmsDupToneCurve(OldCurves[1]);\n    NewCurves[2] = cmsDupToneCurve(OldCurves[2]);\n\n    return (void*) NewCurves;\n\n    cmsUNUSED_PARAMETER(n);\n}",
          "fn_code_pos": [
            [
              5125,
              0
            ],
            [
              5141,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_vcgt_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_vcgt_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsFreeToneCurveTriple((cmsToneCurve**) Ptr);\n    _cmsFree(self ->ContextID, Ptr);\n}",
          "fn_code_pos": [
            [
              5144,
              0
            ],
            [
              5149,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_vcgt_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool AllocElem(cmsContext ContextID, _cmsDICelem* e,  cmsUInt32Number Count)\n{\n    e->Offsets = (cmsUInt32Number *) _cmsCalloc(ContextID, Count, sizeof(cmsUInt32Number));\n    if (e->Offsets == NULL) return FALSE;\n\n    e->Sizes = (cmsUInt32Number *) _cmsCalloc(ContextID, Count, sizeof(cmsUInt32Number));\n    if (e->Sizes == NULL) {\n\n        _cmsFree(ContextID, e -> Offsets);\n        return FALSE;\n    }\n\n    e ->ContextID = ContextID;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              5169,
              0
            ],
            [
              5184,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllocElem",
            "parameters": {
              "ContextID": "cmsContext",
              "e": "_cmsDICelem",
              "Count": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid FreeElem(_cmsDICelem* e)\n{\n    if (e ->Offsets != NULL)  _cmsFree(e -> ContextID, e -> Offsets);\n    if (e ->Sizes   != NULL)  _cmsFree(e -> ContextID, e -> Sizes);\n    e->Offsets = e ->Sizes = NULL;\n}",
          "fn_code_pos": [
            [
              5187,
              0
            ],
            [
              5193,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FreeElem",
            "parameters": {
              "e": "_cmsDICelem"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid FreeArray( _cmsDICarray* a)\n{\n    if (a ->Name.Offsets != NULL) FreeElem(&a->Name);\n    if (a ->Value.Offsets != NULL) FreeElem(&a ->Value);\n    if (a ->DisplayName.Offsets != NULL) FreeElem(&a->DisplayName);\n    if (a ->DisplayValue.Offsets != NULL) FreeElem(&a ->DisplayValue);\n}",
          "fn_code_pos": [
            [
              5196,
              0
            ],
            [
              5203,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FreeArray",
            "parameters": {
              "a": "_cmsDICarray"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool AllocArray(cmsContext ContextID, _cmsDICarray* a, cmsUInt32Number Count, cmsUInt32Number Length)\n{\n    // Empty values\n    memset(a, 0, sizeof(_cmsDICarray));\n\n    // On depending on record size, create column arrays\n    if (!AllocElem(ContextID, &a ->Name, Count)) goto Error;\n    if (!AllocElem(ContextID, &a ->Value, Count)) goto Error;\n\n    if (Length > 16) {\n        if (!AllocElem(ContextID, &a -> DisplayName, Count)) goto Error;\n\n    }\n    if (Length > 24) {\n        if (!AllocElem(ContextID, &a ->DisplayValue, Count)) goto Error;\n    }\n    return TRUE;\n\nError:\n    FreeArray(a);\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              5207,
              0
            ],
            [
              5229,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllocArray",
            "parameters": {
              "ContextID": "cmsContext",
              "a": "_cmsDICarray",
              "Count": "cmsUInt32Number",
              "Length": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool ReadOneElem(cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i, cmsUInt32Number BaseOffset)\n{\n    if (!_cmsReadUInt32Number(io, &e->Offsets[i])) return FALSE;\n    if (!_cmsReadUInt32Number(io, &e ->Sizes[i])) return FALSE;\n\n    // An offset of zero has special meaning and shall be preserved\n    if (e ->Offsets[i] > 0)\n        e ->Offsets[i] += BaseOffset;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              5232,
              0
            ],
            [
              5242,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadOneElem",
            "parameters": {
              "io": "cmsIOHANDLER",
              "e": "_cmsDICelem",
              "i": "cmsUInt32Number",
              "BaseOffset": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool ReadOffsetArray(cmsIOHANDLER* io,  _cmsDICarray* a, \n                        cmsUInt32Number Count, cmsUInt32Number Length, cmsUInt32Number BaseOffset,\n                        cmsInt32Number* SignedSizeOfTagPtr)\n{\n    cmsUInt32Number i;\n    cmsInt32Number SignedSizeOfTag = *SignedSizeOfTagPtr;\n\n    // Read column arrays\n    for (i=0; i < Count; i++) {\n\n        if (SignedSizeOfTag < 4 * (cmsInt32Number) sizeof(cmsUInt32Number)) return FALSE;\n        SignedSizeOfTag -= 4 * sizeof(cmsUInt32Number);\n\n        if (!ReadOneElem(io, &a -> Name, i, BaseOffset)) return FALSE;\n        if (!ReadOneElem(io, &a -> Value, i, BaseOffset)) return FALSE;\n\n        if (Length > 16) {\n\n            if (SignedSizeOfTag < 2 * (cmsInt32Number) sizeof(cmsUInt32Number)) return FALSE;\n            SignedSizeOfTag -= 2 * sizeof(cmsUInt32Number);\n\n            if (!ReadOneElem(io, &a ->DisplayName, i, BaseOffset)) return FALSE;\n\n        }\n\n        if (Length > 24) {\n\n            if (SignedSizeOfTag < 2 * (cmsInt32Number) sizeof(cmsUInt32Number)) return FALSE;\n            SignedSizeOfTag -= 2 * (cmsInt32Number) sizeof(cmsUInt32Number);\n\n            if (!ReadOneElem(io, & a -> DisplayValue, i, BaseOffset)) return FALSE;\n        }\n    }\n\n    *SignedSizeOfTagPtr = SignedSizeOfTag;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              5245,
              0
            ],
            [
              5282,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadOffsetArray",
            "parameters": {
              "io": "cmsIOHANDLER",
              "a": "_cmsDICarray",
              "Count": "cmsUInt32Number",
              "Length": "cmsUInt32Number",
              "BaseOffset": "cmsUInt32Number",
              "SignedSizeOfTagPtr": "cmsInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool WriteOneElem(cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i)\n{\n    if (!_cmsWriteUInt32Number(io, e->Offsets[i])) return FALSE;\n    if (!_cmsWriteUInt32Number(io, e ->Sizes[i])) return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              5286,
              0
            ],
            [
              5293,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteOneElem",
            "parameters": {
              "io": "cmsIOHANDLER",
              "e": "_cmsDICelem",
              "i": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool WriteOffsetArray(cmsIOHANDLER* io,  _cmsDICarray* a, cmsUInt32Number Count, cmsUInt32Number Length)\n{\n    cmsUInt32Number i;\n\n    for (i=0; i < Count; i++) {\n\n        if (!WriteOneElem(io, &a -> Name, i)) return FALSE;\n        if (!WriteOneElem(io, &a -> Value, i))  return FALSE;\n\n        if (Length > 16) {\n\n            if (!WriteOneElem(io, &a -> DisplayName, i))  return FALSE;\n        }\n\n        if (Length > 24) {\n\n            if (!WriteOneElem(io, &a -> DisplayValue, i))  return FALSE;\n        }\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              5295,
              0
            ],
            [
              5317,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteOffsetArray",
            "parameters": {
              "io": "cmsIOHANDLER",
              "a": "_cmsDICarray",
              "Count": "cmsUInt32Number",
              "Length": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool ReadOneWChar(cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i, wchar_t ** wcstr)\n{\n\n    cmsUInt32Number nChars;\n\n      // Special case for undefined strings (see ICC Votable\n      // Proposal Submission, Dictionary Type and Metadata TAG Definition)\n      if (e -> Offsets[i] == 0) {\n\n          *wcstr = NULL;\n          return TRUE;\n      }\n\n      if (!io -> Seek(io, e -> Offsets[i])) return FALSE;\n\n      nChars = e ->Sizes[i] / sizeof(cmsUInt16Number);\n\n\n      *wcstr = (wchar_t*) _cmsMallocZero(e ->ContextID, (nChars + 1) * sizeof(wchar_t));\n      if (*wcstr == NULL) return FALSE;\n\n      if (!_cmsReadWCharArray(io, nChars, *wcstr)) {\n          _cmsFree(e ->ContextID, *wcstr);\n          return FALSE;\n      }\n\n      // End of string marker\n      (*wcstr)[nChars] = 0;\n      return TRUE;\n}",
          "fn_code_pos": [
            [
              5319,
              0
            ],
            [
              5349,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadOneWChar",
            "parameters": {
              "io": "cmsIOHANDLER",
              "e": "_cmsDICelem",
              "i": "cmsUInt32Number",
              "wcstr": "wchar_t"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number mywcslen(const wchar_t *s)\n{\n    const wchar_t *p;\n\n    p = s;\n    while (*p)\n        p++;\n\n    return (cmsUInt32Number)(p - s);\n}",
          "fn_code_pos": [
            [
              5351,
              0
            ],
            [
              5361,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mywcslen",
            "parameters": {
              "s": "wchar_t"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsBool WriteOneWChar(cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i, const wchar_t * wcstr, cmsUInt32Number BaseOffset)\n{\n    cmsUInt32Number Before = io ->Tell(io);\n    cmsUInt32Number n;\n\n    e ->Offsets[i] = Before - BaseOffset;\n\n    if (wcstr == NULL) {\n        e ->Sizes[i] = 0;\n        e ->Offsets[i] = 0;\n        return TRUE;\n    }\n\n    n = mywcslen(wcstr);\n    if (!_cmsWriteWCharArray(io,  n, wcstr)) return FALSE;\n\n    e ->Sizes[i] = io ->Tell(io) - Before;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              5363,
              0
            ],
            [
              5382,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteOneWChar",
            "parameters": {
              "io": "cmsIOHANDLER",
              "e": "_cmsDICelem",
              "i": "cmsUInt32Number",
              "wcstr": "wchar_t",
              "BaseOffset": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool ReadOneMLUC(struct _cms_typehandler_struct* self, cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i, cmsMLU** mlu)\n{\n    cmsUInt32Number nItems = 0;\n\n    // A way to get null MLUCs\n    if (e -> Offsets[i] == 0 || e ->Sizes[i] == 0) {\n\n        *mlu = NULL;\n        return TRUE;\n    }\n\n    if (!io -> Seek(io, e -> Offsets[i])) return FALSE;\n\n    *mlu = (cmsMLU*) Type_MLU_Read(self, io, &nItems, e ->Sizes[i]);\n    return *mlu != NULL;\n}",
          "fn_code_pos": [
            [
              5384,
              0
            ],
            [
              5400,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadOneMLUC",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "e": "_cmsDICelem",
              "i": "cmsUInt32Number",
              "mlu": "cmsMLU"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool WriteOneMLUC(struct _cms_typehandler_struct* self, cmsIOHANDLER* io,  _cmsDICelem* e, cmsUInt32Number i, const cmsMLU* mlu, cmsUInt32Number BaseOffset)\n{\n    cmsUInt32Number Before;\n\n     // Special case for undefined strings (see ICC Votable\n     // Proposal Submission, Dictionary Type and Metadata TAG Definition)\n     if (mlu == NULL) {\n        e ->Sizes[i] = 0;\n        e ->Offsets[i] = 0;\n        return TRUE;\n    }\n\n    Before = io ->Tell(io);\n    if (e->Offsets != NULL)\n        e ->Offsets[i] = Before - BaseOffset;\n\n    if (!Type_MLU_Write(self, io, (void*) mlu, 1)) return FALSE;\n\n    if (e->Sizes != NULL)\n        e ->Sizes[i] = io ->Tell(io) - Before;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              5402,
              0
            ],
            [
              5424,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteOneMLUC",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "e": "_cmsDICelem",
              "i": "cmsUInt32Number",
              "mlu": "cmsMLU",
              "BaseOffset": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid *Type_Dictionary_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n   cmsHANDLE hDict = NULL;\n   cmsUInt32Number i, Count, Length;\n   cmsUInt32Number BaseOffset;\n   _cmsDICarray a;\n   wchar_t *NameWCS = NULL, *ValueWCS = NULL;\n   cmsMLU *DisplayNameMLU = NULL, *DisplayValueMLU=NULL;\n   cmsBool rc;\n   cmsInt32Number SignedSizeOfTag = (cmsInt32Number)SizeOfTag;\n\n    *nItems = 0;\n    memset(&a, 0, sizeof(a));\n\n    // Get actual position as a basis for element offsets\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    // Get name-value record count\n    SignedSizeOfTag -= sizeof(cmsUInt32Number);\n    if (SignedSizeOfTag < 0) goto Error;\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n    \n    // Get rec length\n    SignedSizeOfTag -= sizeof(cmsUInt32Number);\n    if (SignedSizeOfTag < 0) goto Error;\n    if (!_cmsReadUInt32Number(io, &Length)) return NULL;\n    \n\n    // Check for valid lengths\n    if (Length != 16 && Length != 24 && Length != 32) {\n         cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown record length in dictionary '%d'\", Length);\n         return NULL;\n    }\n\n    // Creates an empty dictionary\n    hDict = cmsDictAlloc(self -> ContextID);\n    if (hDict == NULL) return NULL;\n\n    // On depending on record size, create column arrays\n    if (!AllocArray(self -> ContextID, &a, Count, Length)) goto Error;\n\n    // Read column arrays\n    if (!ReadOffsetArray(io, &a, Count, Length, BaseOffset, &SignedSizeOfTag)) goto Error;\n\n    // Seek to each element and read it\n    for (i=0; i < Count; i++) {\n\n        if (!ReadOneWChar(io, &a.Name, i, &NameWCS)) goto Error;\n        if (!ReadOneWChar(io, &a.Value, i, &ValueWCS)) goto Error;\n\n        if (Length > 16) {\n            if (!ReadOneMLUC(self, io, &a.DisplayName, i, &DisplayNameMLU)) goto Error;\n        }\n\n        if (Length > 24) {\n            if (!ReadOneMLUC(self, io, &a.DisplayValue, i, &DisplayValueMLU)) goto Error;\n        }\n\n        if (NameWCS == NULL || ValueWCS == NULL) {\n        \n            cmsSignalError(self->ContextID, cmsERROR_CORRUPTION_DETECTED, \"Bad dictionary Name/Value\");        \n            rc = FALSE;\n        }\n        else {\n\n            rc = cmsDictAddEntry(hDict, NameWCS, ValueWCS, DisplayNameMLU, DisplayValueMLU);\n        }\n\n        if (NameWCS != NULL) _cmsFree(self ->ContextID, NameWCS);\n        if (ValueWCS != NULL) _cmsFree(self ->ContextID, ValueWCS);\n        if (DisplayNameMLU != NULL) cmsMLUfree(DisplayNameMLU);\n        if (DisplayValueMLU != NULL) cmsMLUfree(DisplayValueMLU);\n\n        if (!rc) goto Error;\n    }\n\n   FreeArray(&a);\n   *nItems = 1;\n   return (void*) hDict;\n\nError:\n   FreeArray(&a);\n   if (hDict != NULL) cmsDictFree(hDict);\n   return NULL;\n}",
          "fn_code_pos": [
            [
              5427,
              0
            ],
            [
              5512,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Dictionary_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_Dictionary_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsHANDLE hDict = (cmsHANDLE) Ptr;\n    const cmsDICTentry* p;\n    cmsBool AnyName, AnyValue;\n    cmsUInt32Number i, Count, Length;\n    cmsUInt32Number DirectoryPos, CurrentPos, BaseOffset;\n   _cmsDICarray a;\n\n    if (hDict == NULL) return FALSE;\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    // Let's inspect the dictionary\n    Count = 0; AnyName = FALSE; AnyValue = FALSE;\n    for (p = cmsDictGetEntryList(hDict); p != NULL; p = cmsDictNextEntry(p)) {\n\n        if (p ->DisplayName != NULL) AnyName = TRUE;\n        if (p ->DisplayValue != NULL) AnyValue = TRUE;\n        Count++;\n    }\n\n    Length = 16;\n    if (AnyName)  Length += 8;\n    if (AnyValue) Length += 8;\n\n    if (!_cmsWriteUInt32Number(io, Count)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, Length)) return FALSE;\n\n    // Keep starting position of offsets table\n    DirectoryPos = io ->Tell(io);\n\n    // Allocate offsets array\n    if (!AllocArray(self ->ContextID, &a, Count, Length)) goto Error;\n\n    // Write a fake directory to be filled latter on\n    if (!WriteOffsetArray(io, &a, Count, Length)) goto Error;\n\n    // Write each element. Keep track of the size as well.\n    p = cmsDictGetEntryList(hDict);\n    for (i=0; i < Count; i++) {\n\n        if (!WriteOneWChar(io, &a.Name, i,  p ->Name, BaseOffset)) goto Error;\n        if (!WriteOneWChar(io, &a.Value, i, p ->Value, BaseOffset)) goto Error;\n\n        if (p ->DisplayName != NULL) {\n            if (!WriteOneMLUC(self, io, &a.DisplayName, i, p ->DisplayName, BaseOffset)) goto Error;\n        }\n\n        if (p ->DisplayValue != NULL) {\n            if (!WriteOneMLUC(self, io, &a.DisplayValue, i, p ->DisplayValue, BaseOffset)) goto Error;\n        }\n\n       p = cmsDictNextEntry(p);\n    }\n\n    // Write the directory\n    CurrentPos = io ->Tell(io);\n    if (!io ->Seek(io, DirectoryPos)) goto Error;\n\n    if (!WriteOffsetArray(io, &a, Count, Length)) goto Error;\n\n    if (!io ->Seek(io, CurrentPos)) goto Error;\n\n    FreeArray(&a);\n    return TRUE;\n\nError:\n    FreeArray(&a);\n    return FALSE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}",
          "fn_code_pos": [
            [
              5515,
              0
            ],
            [
              5588,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Dictionary_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_Dictionary_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*)  cmsDictDup((cmsHANDLE) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              5591,
              0
            ],
            [
              5598,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Dictionary_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_Dictionary_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsDictFree((cmsHANDLE) Ptr);\n    cmsUNUSED_PARAMETER(self);\n}",
          "fn_code_pos": [
            [
              5601,
              0
            ],
            [
              5606,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Dictionary_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* Type_VideoSignal_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsVideoSignalType* cicp = NULL;\n\n    if (SizeOfTag != 8) return NULL; \n\n    if (!_cmsReadUInt32Number(io, NULL)) return NULL;\n\n    cicp = (cmsVideoSignalType*)_cmsCalloc(self->ContextID, 1, sizeof(cmsVideoSignalType));\n    if (cicp == NULL) return NULL;\n\n    if (!_cmsReadUInt8Number(io, &cicp->ColourPrimaries)) goto Error;\n    if (!_cmsReadUInt8Number(io, &cicp->TransferCharacteristics)) goto Error;\n    if (!_cmsReadUInt8Number(io, &cicp->MatrixCoefficients)) goto Error;\n    if (!_cmsReadUInt8Number(io, &cicp->VideoFullRangeFlag)) goto Error;\n\n    // Success\n    *nItems = 1;\n    return cicp;\n\nError:\n    if (cicp != NULL) _cmsFree(self->ContextID, cicp);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              5610,
              0
            ],
            [
              5634,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_VideoSignal_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_VideoSignal_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsVideoSignalType* cicp = (cmsVideoSignalType*)Ptr;\n\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, cicp->ColourPrimaries)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, cicp->TransferCharacteristics)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, cicp->MatrixCoefficients)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, cicp->VideoFullRangeFlag)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(self);\n    cmsUNUSED_PARAMETER(nItems);\n}",
          "fn_code_pos": [
            [
              5636,
              0
            ],
            [
              5651,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_VideoSignal_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "void* Type_VideoSignal_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self->ContextID, Ptr, sizeof(cmsVideoSignalType));\n\n    cmsUNUSED_PARAMETER(n);\n}",
          "fn_code_pos": [
            [
              5653,
              0
            ],
            [
              5658,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_VideoSignal_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Type_VideoSignal_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self->ContextID, Ptr);\n}",
          "fn_code_pos": [
            [
              5661,
              0
            ],
            [
              5665,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_VideoSignal_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid SetIdentity(cmsFloat64Number XYZ2XYZmatrix[3][4])\n{\n    XYZ2XYZmatrix[0][0] = 1.0; XYZ2XYZmatrix[0][1] = 0.0; XYZ2XYZmatrix[0][2] = 0.0; XYZ2XYZmatrix[0][3] = 0.0;\n    XYZ2XYZmatrix[1][0] = 0.0; XYZ2XYZmatrix[1][1] = 1.0; XYZ2XYZmatrix[1][2] = 0.0; XYZ2XYZmatrix[1][3] = 0.0;\n    XYZ2XYZmatrix[2][0] = 0.0; XYZ2XYZmatrix[2][1] = 0.0; XYZ2XYZmatrix[2][2] = 1.0; XYZ2XYZmatrix[2][3] = 0.0;\n}",
          "fn_code_pos": [
            [
              5672,
              0
            ],
            [
              5678,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetIdentity",
            "parameters": {
              "XYZ2XYZmatrix": "cmsFloat64Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool CloseEnough(cmsFloat64Number a, cmsFloat64Number b)\n{\n    return fabs(b - a) < (1.0 / 65535.0);\n}",
          "fn_code_pos": [
            [
              5680,
              0
            ],
            [
              5684,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CloseEnough",
            "parameters": {
              "a": "cmsFloat64Number",
              "b": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool IsIdentity(cmsFloat64Number XYZ2XYZmatrix[3][4])\n{\n    cmsFloat64Number Identity[3][4];\n    int i, j;\n\n    SetIdentity(Identity);\n\n    for (i = 0; i < 3; i++)\n        for (j = 0; j < 4; j++)\n            if (!CloseEnough(XYZ2XYZmatrix[i][j], Identity[i][j])) return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              5686,
              0
            ],
            [
              5698,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsIdentity",
            "parameters": {
              "XYZ2XYZmatrix": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid Type_MHC2_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsMHC2Type* mhc2 = (cmsMHC2Type*)Ptr;\n\n    if (mhc2->RedCurve != NULL) _cmsFree(self->ContextID, mhc2->RedCurve);\n    if (mhc2->GreenCurve != NULL) _cmsFree(self->ContextID, mhc2->GreenCurve);\n    if (mhc2->BlueCurve != NULL) _cmsFree(self->ContextID, mhc2->BlueCurve);\n\n    _cmsFree(self->ContextID, Ptr);\n}",
          "fn_code_pos": [
            [
              5700,
              0
            ],
            [
              5710,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MHC2_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void* Type_MHC2_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n{\n    cmsMHC2Type* mhc2 = _cmsDupMem(self->ContextID, Ptr, sizeof(cmsMHC2Type));\n\n    mhc2->RedCurve = _cmsDupMem(self->ContextID,   mhc2->RedCurve, mhc2->CurveEntries*sizeof(cmsFloat64Number));\n    mhc2->GreenCurve = _cmsDupMem(self->ContextID, mhc2->GreenCurve, mhc2->CurveEntries * sizeof(cmsFloat64Number));\n    mhc2->BlueCurve = _cmsDupMem(self->ContextID,  mhc2->BlueCurve, mhc2->CurveEntries * sizeof(cmsFloat64Number));\n\n    if (mhc2->RedCurve == NULL ||\n        mhc2->GreenCurve == NULL ||\n        mhc2->BlueCurve == NULL) {\n\n        Type_MHC2_Free(self, mhc2);\n        return NULL;\n    }\n\n    return mhc2;\n\n    cmsUNUSED_PARAMETER(n);\n}",
          "fn_code_pos": [
            [
              5712,
              0
            ],
            [
              5731,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MHC2_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool WriteDoubles(cmsIOHANDLER* io, cmsUInt32Number n, cmsFloat64Number* Values)\n{\n    cmsUInt32Number i;\n    \n    for (i = 0; i < n; i++) {\n\n        if (!_cmsWrite15Fixed16Number(io, *Values++)) return FALSE;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              5734,
              0
            ],
            [
              5745,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteDoubles",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt32Number",
              "Values": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_MHC2_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsMHC2Type* mhc2 = (cmsMHC2Type*)Ptr;\n    cmsUInt32Number BaseOffset = io->Tell(io) - sizeof(_cmsTagBase);\n    cmsUInt32Number TablesOffsetPos;\n    cmsUInt32Number MatrixOffset;\n    cmsUInt32Number OffsetRedTable, OffsetGreenTable, OffsetBlueTable;\n\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, mhc2->CurveEntries)) return FALSE;\n\n    if (!_cmsWrite15Fixed16Number(io, mhc2->MinLuminance)) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, mhc2->PeakLuminance)) return FALSE;\n\n    TablesOffsetPos = io->Tell(io);\n\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    // Matrix\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    // Curve R\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    // Curve G\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    // Curve B\n\n\n    if (IsIdentity(mhc2->XYZ2XYZmatrix))\n    {\n        MatrixOffset = 0;\n    }\n    else\n    {\n        MatrixOffset = io->Tell(io) - BaseOffset;\n        if (!WriteDoubles(io, 3 * 4, &mhc2->XYZ2XYZmatrix[0][0])) return FALSE;\n    }\n\n    OffsetRedTable = io->Tell(io) - BaseOffset;\n    if (!WriteDoubles(io, mhc2->CurveEntries, mhc2->RedCurve)) return FALSE;\n    OffsetGreenTable = io->Tell(io) - BaseOffset;\n    if (!WriteDoubles(io, mhc2->CurveEntries, mhc2->GreenCurve)) return FALSE;\n    OffsetBlueTable = io->Tell(io) - BaseOffset;\n    if (!WriteDoubles(io, mhc2->CurveEntries, mhc2->BlueCurve)) return FALSE;\n\n    if (!io->Seek(io, TablesOffsetPos)) return FALSE;\n\n    if (!_cmsWriteUInt32Number(io, MatrixOffset)) return FALSE;      \n    if (!_cmsWriteUInt32Number(io, OffsetRedTable)) return FALSE;    \n    if (!_cmsWriteUInt32Number(io, OffsetGreenTable)) return FALSE;  \n    if (!_cmsWriteUInt32Number(io, OffsetBlueTable)) return FALSE;   \n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(self);\n    cmsUNUSED_PARAMETER(nItems);\n}",
          "fn_code_pos": [
            [
              5747,
              0
            ],
            [
              5798,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MHC2_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool ReadDoublesAt(cmsIOHANDLER* io, cmsUInt32Number At, cmsUInt32Number n, cmsFloat64Number* Values)\n{\n    cmsUInt32Number CurrentPos = io->Tell(io);\n    cmsUInt32Number i;\n\n    if (!io->Seek(io, At)) return FALSE;\n\n    for (i = 0; i < n; i++) {\n\n        if (!_cmsRead15Fixed16Number(io, Values++)) return FALSE;\n    }\n\n    if (!io->Seek(io, CurrentPos)) return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              5801,
              0
            ],
            [
              5817,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadDoublesAt",
            "parameters": {
              "io": "cmsIOHANDLER",
              "At": "cmsUInt32Number",
              "n": "cmsUInt32Number",
              "Values": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_MHC2_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsMHC2Type* mhc2 = NULL;\n\n    cmsUInt32Number BaseOffset = io->Tell(io) - sizeof(_cmsTagBase);\n    cmsUInt32Number MatrixOffset;\n    cmsUInt32Number OffsetRedTable, OffsetGreenTable, OffsetBlueTable;\n    \n    if (!_cmsReadUInt32Number(io, NULL)) return NULL;\n\n    mhc2 = (cmsMHC2Type*)_cmsCalloc(self->ContextID, 1, sizeof(cmsMHC2Type));\n    if (mhc2 == NULL) return NULL;\n\n    if (!_cmsReadUInt32Number(io,    &mhc2->CurveEntries)) goto Error;\n\n    if (mhc2->CurveEntries > 4096) goto Error;\n\n    mhc2->RedCurve = (cmsFloat64Number*)_cmsCalloc(self->ContextID, mhc2->CurveEntries, sizeof(cmsFloat64Number));\n    mhc2->GreenCurve = (cmsFloat64Number*)_cmsCalloc(self->ContextID, mhc2->CurveEntries, sizeof(cmsFloat64Number));\n    mhc2->BlueCurve = (cmsFloat64Number*)_cmsCalloc(self->ContextID, mhc2->CurveEntries, sizeof(cmsFloat64Number));\n\n    if (mhc2->RedCurve == NULL ||\n        mhc2->GreenCurve == NULL ||\n        mhc2->BlueCurve == NULL)  goto Error;\n\n    if (!_cmsRead15Fixed16Number(io, &mhc2->MinLuminance)) goto Error;\n    if (!_cmsRead15Fixed16Number(io, &mhc2->PeakLuminance)) goto Error;\n\n    if (!_cmsReadUInt32Number(io, &MatrixOffset)) goto Error;\n    if (!_cmsReadUInt32Number(io, &OffsetRedTable)) goto Error;\n    if (!_cmsReadUInt32Number(io, &OffsetGreenTable)) goto Error;\n    if (!_cmsReadUInt32Number(io, &OffsetBlueTable)) goto Error;\n\n    if (MatrixOffset == 0) \n        SetIdentity(mhc2->XYZ2XYZmatrix);            \n    else\n    {\n        if (!ReadDoublesAt(io, BaseOffset + MatrixOffset, 3*4, &mhc2->XYZ2XYZmatrix[0][0])) goto Error;\n    }\n\n    if (!ReadDoublesAt(io, BaseOffset + OffsetRedTable, mhc2->CurveEntries, mhc2->RedCurve)) goto Error;\n    if (!ReadDoublesAt(io, BaseOffset + OffsetGreenTable, mhc2->CurveEntries, mhc2->GreenCurve)) goto Error;\n    if (!ReadDoublesAt(io, BaseOffset + OffsetBlueTable, mhc2->CurveEntries, mhc2->BlueCurve)) goto Error;\n    \n    // Success\n    *nItems = 1;\n    return mhc2;\n\nError:\n    Type_MHC2_Free(self, mhc2);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
          "fn_code_pos": [
            [
              5819,
              0
            ],
            [
              5873,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MHC2_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid DupTagTypeList(struct _cmsContext_struct* ctx, \n                    const struct _cmsContext_struct* src, \n                    int loc)\n{\n   _cmsTagTypePluginChunkType newHead = { NULL };\n   _cmsTagTypeLinkedList*  entry;\n   _cmsTagTypeLinkedList*  Anterior = NULL;\n   _cmsTagTypePluginChunkType* head = (_cmsTagTypePluginChunkType*) src->chunks[loc];\n\n   // Walk the list copying all nodes\n   for (entry = head->TagTypes;\n       entry != NULL;\n       entry = entry ->Next) {\n\n           _cmsTagTypeLinkedList *newEntry = ( _cmsTagTypeLinkedList *) _cmsSubAllocDup(ctx ->MemPool, entry, sizeof(_cmsTagTypeLinkedList));\n\n           if (newEntry == NULL) \n               return;\n\n           // We want to keep the linked list order, so this is a little bit tricky\n           newEntry -> Next = NULL;\n           if (Anterior)\n               Anterior -> Next = newEntry;\n\n           Anterior = newEntry;\n\n           if (newHead.TagTypes == NULL)\n               newHead.TagTypes = newEntry;\n   }\n\n   ctx ->chunks[loc] = _cmsSubAllocDup(ctx->MemPool, &newHead, sizeof(_cmsTagTypePluginChunkType));\n}",
          "fn_code_pos": [
            [
              5929,
              0
            ],
            [
              5961,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DupTagTypeList",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct",
              "loc": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void _cmsAllocTagTypePluginChunk(struct _cmsContext_struct* ctx, \n                                 const struct _cmsContext_struct* src)\n{\n    if (src != NULL) {\n        \n        // Duplicate the LIST\n        DupTagTypeList(ctx, src, TagTypePlugin);\n    }\n    else {\n        static _cmsTagTypePluginChunkType TagTypePluginChunk = { NULL };\n        ctx ->chunks[TagTypePlugin] = _cmsSubAllocDup(ctx ->MemPool, &TagTypePluginChunk, sizeof(_cmsTagTypePluginChunkType));\n    }\n}",
          "fn_code_pos": [
            [
              5964,
              0
            ],
            [
              5976,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocTagTypePluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void _cmsAllocMPETypePluginChunk(struct _cmsContext_struct* ctx, \n                               const struct _cmsContext_struct* src)\n{\n    if (src != NULL) {\n        \n        // Duplicate the LIST\n        DupTagTypeList(ctx, src, MPEPlugin);\n    }\n    else {\n        static _cmsTagTypePluginChunkType TagTypePluginChunk = { NULL };\n        ctx ->chunks[MPEPlugin] = _cmsSubAllocDup(ctx ->MemPool, &TagTypePluginChunk, sizeof(_cmsTagTypePluginChunkType));\n    }\n\n}",
          "fn_code_pos": [
            [
              5978,
              0
            ],
            [
              5991,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocMPETypePluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool  _cmsRegisterTagTypePlugin(cmsContext id, cmsPluginBase* Data)\n{\n    return RegisterTypesPlugin(id, Data, TagTypePlugin);\n}",
          "fn_code_pos": [
            [
              5995,
              0
            ],
            [
              5998,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterTagTypePlugin",
            "parameters": {
              "id": "cmsContext",
              "Data": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool  _cmsRegisterMultiProcessElementPlugin(cmsContext id, cmsPluginBase* Data)\n{\n    return RegisterTypesPlugin(id, Data,MPEPlugin);\n}",
          "fn_code_pos": [
            [
              6000,
              0
            ],
            [
              6003,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterMultiProcessElementPlugin",
            "parameters": {
              "id": "cmsContext",
              "Data": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsTagTypeHandler* _cmsGetTagTypeHandler(cmsContext ContextID, cmsTagTypeSignature sig)\n{\n    _cmsTagTypePluginChunkType* ctx = ( _cmsTagTypePluginChunkType*) _cmsContextGetClientChunk(ContextID, TagTypePlugin);\n\n    return GetHandler(sig, ctx->TagTypes, (_cmsTagTypeLinkedList*) SupportedTagTypes);\n}",
          "fn_code_pos": [
            [
              6007,
              0
            ],
            [
              6012,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTagTypeHandler",
            "parameters": {
              "ContextID": "cmsContext",
              "sig": "cmsTagTypeSignature"
            },
            "return_type": "cmsTagTypeHandler"
          }
        },
        {
          "fn_code": "static\nvoid DupTagList(struct _cmsContext_struct* ctx, \n                    const struct _cmsContext_struct* src)\n{\n   _cmsTagPluginChunkType newHead = { NULL };\n   _cmsTagLinkedList*  entry;\n   _cmsTagLinkedList*  Anterior = NULL;\n   _cmsTagPluginChunkType* head = (_cmsTagPluginChunkType*) src->chunks[TagPlugin];\n\n   // Walk the list copying all nodes\n   for (entry = head->Tag;\n       entry != NULL;\n       entry = entry ->Next) {\n\n           _cmsTagLinkedList *newEntry = ( _cmsTagLinkedList *) _cmsSubAllocDup(ctx ->MemPool, entry, sizeof(_cmsTagLinkedList));\n\n           if (newEntry == NULL) \n               return;\n\n           // We want to keep the linked list order, so this is a little bit tricky\n           newEntry -> Next = NULL;\n           if (Anterior)\n               Anterior -> Next = newEntry;\n\n           Anterior = newEntry;\n\n           if (newHead.Tag == NULL)\n               newHead.Tag = newEntry;\n   }\n\n   ctx ->chunks[TagPlugin] = _cmsSubAllocDup(ctx->MemPool, &newHead, sizeof(_cmsTagPluginChunkType));\n}",
          "fn_code_pos": [
            [
              6135,
              0
            ],
            [
              6166,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DupTagList",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void _cmsAllocTagPluginChunk(struct _cmsContext_struct* ctx, \n                                 const struct _cmsContext_struct* src)\n{\n    if (src != NULL) {\n\n        DupTagList(ctx, src);\n    }\n    else {\n        static _cmsTagPluginChunkType TagPluginChunk = { NULL };\n        ctx ->chunks[TagPlugin] = _cmsSubAllocDup(ctx ->MemPool, &TagPluginChunk, sizeof(_cmsTagPluginChunkType));\n    }\n\n}",
          "fn_code_pos": [
            [
              6168,
              0
            ],
            [
              6180,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocTagPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool  _cmsRegisterTagPlugin(cmsContext id, cmsPluginBase* Data)\n{\n    cmsPluginTag* Plugin = (cmsPluginTag*) Data;\n    _cmsTagLinkedList *pt;\n    _cmsTagPluginChunkType* TagPluginChunk = ( _cmsTagPluginChunkType*) _cmsContextGetClientChunk(id, TagPlugin);\n\n    if (Data == NULL) {\n\n        TagPluginChunk->Tag = NULL;\n        return TRUE;\n    }\n\n    pt = (_cmsTagLinkedList*) _cmsPluginMalloc(id, sizeof(_cmsTagLinkedList));\n    if (pt == NULL) return FALSE;\n\n    pt ->Signature  = Plugin ->Signature;\n    pt ->Descriptor = Plugin ->Descriptor;\n    pt ->Next       = TagPluginChunk ->Tag;\n\n    TagPluginChunk ->Tag = pt;\n    \n    return TRUE;\n}",
          "fn_code_pos": [
            [
              6182,
              0
            ],
            [
              6204,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterTagPlugin",
            "parameters": {
              "id": "cmsContext",
              "Data": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsTagDescriptor* _cmsGetTagDescriptor(cmsContext ContextID, cmsTagSignature sig)\n{\n    _cmsTagLinkedList* pt;\n    _cmsTagPluginChunkType* TagPluginChunk = ( _cmsTagPluginChunkType*) _cmsContextGetClientChunk(ContextID, TagPlugin);\n\n    for (pt = TagPluginChunk->Tag;\n             pt != NULL;\n             pt = pt ->Next) {\n\n                if (sig == pt -> Signature) return &pt ->Descriptor;\n    }\n\n    for (pt = SupportedTags;\n            pt != NULL;\n            pt = pt ->Next) {\n\n                if (sig == pt -> Signature) return &pt ->Descriptor;\n    }\n\n    return NULL;\n}",
          "fn_code_pos": [
            [
              6207,
              0
            ],
            [
              6227,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTagDescriptor",
            "parameters": {
              "ContextID": "cmsContext",
              "sig": "cmsTagSignature"
            },
            "return_type": "cmsTagDescriptor"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "GetHandler(cmsTagTypeSignature sig, _cmsTagTypeLinkedList* PluginLinkedList, _cmsTagTypeLinkedList* DefaultLinkedList)",
          "fn_dec_pos": [
            [
              98,
              19
            ],
            [
              98,
              137
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetHandler",
            "parameters": {
              "sig": "cmsTagTypeSignature",
              "PluginLinkedList": "_cmsTagTypeLinkedList",
              "DefaultLinkedList": "_cmsTagTypeLinkedList"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(* PositionTableEntryFn)(struct _cms_typehandler_struct* self,\n                                             cmsIOHANDLER* io,\n                                             void* Cargo,\n                                             cmsUInt32Number n,\n                                             cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              208,
              16
            ],
            [
              212,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Cargo": "void",
              "n": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "Type_XYZ_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              346,
              6
            ],
            [
              346,
              127
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_XYZ_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_XYZ_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              375,
              6
            ],
            [
              375,
              92
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_XYZ_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_Chromaticity_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              406,
              6
            ],
            [
              406,
              136
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Chromaticity_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_Chromaticity_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              481,
              6
            ],
            [
              481,
              101
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Chromaticity_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_ColorantOrderType_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              508,
              6
            ],
            [
              508,
              141
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ColorantOrderType_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_ColorantOrderType_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              558,
              6
            ],
            [
              558,
              106
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ColorantOrderType_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_UInt8_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              578,
              6
            ],
            [
              578,
              129
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UInt8_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_UInt8_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              618,
              6
            ],
            [
              618,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UInt8_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_UInt32_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              635,
              6
            ],
            [
              635,
              130
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UInt32_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_UInt32_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              675,
              6
            ],
            [
              675,
              95
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UInt32_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_UInt64_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              692,
              6
            ],
            [
              692,
              130
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UInt64_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_UInt64_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              732,
              6
            ],
            [
              732,
              95
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UInt64_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_S15Fixed16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              751,
              6
            ],
            [
              751,
              134
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_S15Fixed16_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_S15Fixed16_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              791,
              6
            ],
            [
              791,
              99
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_S15Fixed16_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_U16Fixed16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              811,
              6
            ],
            [
              811,
              134
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_U16Fixed16_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_U16Fixed16_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              857,
              6
            ],
            [
              857,
              99
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_U16Fixed16_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_Signature_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              878,
              6
            ],
            [
              878,
              133
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Signature_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_Signature_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              903,
              6
            ],
            [
              903,
              98
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Signature_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_Text_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              924,
              6
            ],
            [
              924,
              128
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Text_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_Text_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              991,
              6
            ],
            [
              991,
              93
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Text_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_Data_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              1028,
              6
            ],
            [
              1028,
              128
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Data_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_Data_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              1076,
              6
            ],
            [
              1076,
              93
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Data_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_Text_Description_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              1096,
              6
            ],
            [
              1096,
              140
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Text_Description_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_Text_Description_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              1290,
              6
            ],
            [
              1290,
              105
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Text_Description_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_Curve_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              1327,
              6
            ],
            [
              1327,
              129
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Curve_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_Curve_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              1405,
              6
            ],
            [
              1405,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Curve_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_ParametricCurve_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              1445,
              6
            ],
            [
              1445,
              139
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ParametricCurve_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_ParametricCurve_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              1515,
              6
            ],
            [
              1515,
              104
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ParametricCurve_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_DateTime_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              1550,
              6
            ],
            [
              1550,
              132
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_DateTime_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_DateTime_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              1586,
              6
            ],
            [
              1586,
              97
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_DateTime_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_Measurement_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              1612,
              6
            ],
            [
              1612,
              135
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Measurement_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_Measurement_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              1650,
              6
            ],
            [
              1650,
              100
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Measurement_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_MLU_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              1674,
              6
            ],
            [
              1674,
              127
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MLU_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_MLU_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              1812,
              6
            ],
            [
              1812,
              92
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MLU_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_LUT8_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              1999,
              6
            ],
            [
              1999,
              128
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUT8_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_LUT8_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              2213,
              6
            ],
            [
              2213,
              93
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUT8_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_LUT16_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              2304,
              6
            ],
            [
              2304,
              129
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUT16_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_LUT16_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              2534,
              6
            ],
            [
              2534,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUT16_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ReadMatrix(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number Offset)",
          "fn_dec_pos": [
            [
              2560,
              10
            ],
            [
              2560,
              100
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadMatrix",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Offset": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ReadCLUT(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, \n                   cmsUInt32Number Offset, cmsUInt32Number InputChannels, cmsUInt32Number OutputChannels)",
          "fn_dec_pos": [
            [
              2595,
              10
            ],
            [
              2596,
              105
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadCLUT",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Offset": "cmsUInt32Number",
              "InputChannels": "cmsUInt32Number",
              "OutputChannels": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ReadEmbeddedCurve(struct _cms_typehandler_struct* self, cmsIOHANDLER* io)",
          "fn_dec_pos": [
            [
              2658,
              14
            ],
            [
              2658,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadEmbeddedCurve",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ReadSetOfCurves(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number Offset, cmsUInt32Number nCurves)",
          "fn_dec_pos": [
            [
              2686,
              10
            ],
            [
              2686,
              130
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadSetOfCurves",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Offset": "cmsUInt32Number",
              "nCurves": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_LUTA2B_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              2739,
              6
            ],
            [
              2739,
              130
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUTA2B_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_LUTA2B_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              3037,
              6
            ],
            [
              3037,
              95
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUTA2B_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_LUTB2A_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              3058,
              6
            ],
            [
              3058,
              130
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUTB2A_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_LUTB2A_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              3220,
              6
            ],
            [
              3220,
              95
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_LUTB2A_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_ColorantTable_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              3251,
              6
            ],
            [
              3251,
              137
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ColorantTable_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_ColorantTable_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              3327,
              6
            ],
            [
              3327,
              102
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ColorantTable_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_NamedColor_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              3363,
              6
            ],
            [
              3363,
              134
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_NamedColor_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_NamedColor_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              3468,
              6
            ],
            [
              3468,
              99
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_NamedColor_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_ProfileSequenceDesc_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              3535,
              6
            ],
            [
              3535,
              143
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ProfileSequenceDesc_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_ProfileSequenceDesc_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              3633,
              6
            ],
            [
              3633,
              108
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ProfileSequenceDesc_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_ProfileSequenceId_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              3681,
              6
            ],
            [
              3681,
              141
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ProfileSequenceId_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_ProfileSequenceId_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              3755,
              6
            ],
            [
              3755,
              106
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ProfileSequenceId_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_UcrBg_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              3783,
              6
            ],
            [
              3783,
              129
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UcrBg_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_UcrBg_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              3880,
              6
            ],
            [
              3880,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_UcrBg_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_CrdInfo_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              3978,
              6
            ],
            [
              3978,
              131
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_CrdInfo_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_CrdInfo_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              4020,
              6
            ],
            [
              4020,
              96
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_CrdInfo_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_Screening_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              4045,
              6
            ],
            [
              4045,
              133
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Screening_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_Screening_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              4107,
              6
            ],
            [
              4107,
              98
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Screening_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_ViewingConditions_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              4130,
              6
            ],
            [
              4130,
              141
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ViewingConditions_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_ViewingConditions_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              4174,
              6
            ],
            [
              4174,
              106
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_ViewingConditions_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "GenericMPEdup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              4195,
              6
            ],
            [
              4195,
              93
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GenericMPEdup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ReadSegmentedCurve(struct _cms_typehandler_struct* self, cmsIOHANDLER* io)",
          "fn_dec_pos": [
            [
              4220,
              14
            ],
            [
              4220,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadSegmentedCurve",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_MPEcurve_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              4359,
              6
            ],
            [
              4359,
              132
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MPEcurve_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_MPEmatrix_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              4511,
              6
            ],
            [
              4511,
              133
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MPEmatrix_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_MPEclut_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              4614,
              6
            ],
            [
              4614,
              131
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MPEclut_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_MPE_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              4763,
              6
            ],
            [
              4763,
              127
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MPE_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_MPE_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              4901,
              6
            ],
            [
              4901,
              92
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MPE_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_vcgt_Read(struct _cms_typehandler_struct* self,\n                     cmsIOHANDLER* io,\n                     cmsUInt32Number* nItems,\n                     cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              4936,
              6
            ],
            [
              4939,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_vcgt_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_vcgt_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              5126,
              6
            ],
            [
              5126,
              93
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_vcgt_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_Dictionary_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              5428,
              6
            ],
            [
              5428,
              134
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Dictionary_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_Dictionary_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              5592,
              6
            ],
            [
              5592,
              99
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_Dictionary_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_VideoSignal_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              5611,
              6
            ],
            [
              5611,
              135
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_VideoSignal_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_VideoSignal_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              5653,
              6
            ],
            [
              5653,
              100
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_VideoSignal_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_MHC2_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              5712,
              6
            ],
            [
              5712,
              93
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MHC2_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_MHC2_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              5820,
              6
            ],
            [
              5820,
              128
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_MHC2_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsGetTagTypeHandler(cmsContext ContextID, cmsTagTypeSignature sig)",
          "fn_dec_pos": [
            [
              6007,
              19
            ],
            [
              6007,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTagTypeHandler",
            "parameters": {
              "ContextID": "cmsContext",
              "sig": "cmsTagTypeSignature"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsGetTagDescriptor(cmsContext ContextID, cmsTagSignature sig)",
          "fn_dec_pos": [
            [
              6207,
              18
            ],
            [
              6207,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTagDescriptor",
            "parameters": {
              "ContextID": "cmsContext",
              "sig": "cmsTagSignature"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct _cmsTagTypeLinkedList_st {\n\n    cmsTagTypeHandler Handler;\n    struct _cmsTagTypeLinkedList_st* Next;\n\n} _cmsTagTypeLinkedList;",
          {
            "Handler": "cmsTagTypeHandler",
            "* Next": "struct _cmsTagTypeLinkedList_st"
          },
          "_cmsTagTypeLinkedList",
          [
            43,
            0
          ],
          [
            48,
            24
          ]
        ],
        [
          "typedef struct {\n    double Gamma;\n    double Min;\n    double Max;\n} _cmsVCGTGAMMA;",
          {
            "Gamma": "double",
            "Min": "double",
            "Max": "double"
          },
          "_cmsVCGTGAMMA",
          [
            4928,
            0
          ],
          [
            4932,
            16
          ]
        ],
        [
          "typedef struct {\n    cmsContext ContextID;\n    cmsUInt32Number *Offsets;\n    cmsUInt32Number *Sizes;\n} _cmsDICelem;",
          {
            "ContextID": "cmsContext",
            "*Offsets": "cmsUInt32Number",
            "*Sizes": "cmsUInt32Number"
          },
          "_cmsDICelem",
          [
            5157,
            0
          ],
          [
            5161,
            14
          ]
        ],
        [
          "typedef struct {\n    _cmsDICelem Name, Value, DisplayName, DisplayValue;\n\n} _cmsDICarray;",
          {
            "Name": "_cmsDICelem"
          },
          "_cmsDICarray",
          [
            5163,
            0
          ],
          [
            5166,
            15
          ]
        ],
        [
          "typedef struct _cmsTagLinkedList_st {\n\n            cmsTagSignature Signature;\n            cmsTagDescriptor Descriptor;\n            struct _cmsTagLinkedList_st* Next;\n\n} _cmsTagLinkedList;",
          {
            "Signature": "cmsTagSignature",
            "Descriptor": "cmsTagDescriptor",
            "* Next": "struct _cmsTagLinkedList_st"
          },
          "_cmsTagLinkedList",
          [
            6018,
            0
          ],
          [
            6024,
            20
          ]
        ],
        [
          "typedef struct _cmsTagTypeLinkedList_st {\n\n    cmsTagTypeHandler Handler;\n    struct _cmsTagTypeLinkedList_st* Next;\n\n} _cmsTagTypeLinkedList;",
          {
            "Handler": "cmsTagTypeHandler",
            "* Next": "struct _cmsTagTypeLinkedList_st"
          },
          "_cmsTagTypeLinkedList",
          [
            43,
            0
          ],
          [
            48,
            24
          ]
        ],
        [
          "struct _cmsTagTypeLinkedList_st",
          {},
          "",
          [
            46,
            4
          ],
          [
            46,
            35
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            208,
            41
          ],
          [
            208,
            71
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            218,
            26
          ],
          [
            218,
            56
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            272,
            27
          ],
          [
            272,
            57
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            346,
            20
          ],
          [
            346,
            50
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            366,
            24
          ],
          [
            366,
            54
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            375,
            19
          ],
          [
            375,
            49
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            383,
            19
          ],
          [
            383,
            49
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            406,
            29
          ],
          [
            406,
            59
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            463,
            33
          ],
          [
            463,
            63
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            481,
            28
          ],
          [
            481,
            58
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            489,
            28
          ],
          [
            489,
            58
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            508,
            34
          ],
          [
            508,
            64
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            536,
            37
          ],
          [
            536,
            67
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            558,
            33
          ],
          [
            558,
            63
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            567,
            33
          ],
          [
            567,
            63
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            578,
            22
          ],
          [
            578,
            52
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            602,
            25
          ],
          [
            602,
            55
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            618,
            21
          ],
          [
            618,
            51
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            625,
            21
          ],
          [
            625,
            51
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            635,
            23
          ],
          [
            635,
            53
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            659,
            26
          ],
          [
            659,
            56
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            675,
            22
          ],
          [
            675,
            52
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            682,
            22
          ],
          [
            682,
            52
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            692,
            23
          ],
          [
            692,
            53
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            716,
            26
          ],
          [
            716,
            56
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            732,
            22
          ],
          [
            732,
            52
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            739,
            22
          ],
          [
            739,
            52
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            751,
            27
          ],
          [
            751,
            57
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            775,
            30
          ],
          [
            775,
            60
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            791,
            26
          ],
          [
            791,
            56
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            798,
            26
          ],
          [
            798,
            56
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            811,
            27
          ],
          [
            811,
            57
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            838,
            30
          ],
          [
            838,
            60
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            857,
            26
          ],
          [
            857,
            56
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            863,
            26
          ],
          [
            863,
            56
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            878,
            26
          ],
          [
            878,
            56
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            892,
            30
          ],
          [
            892,
            60
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            903,
            25
          ],
          [
            903,
            55
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            909,
            25
          ],
          [
            909,
            55
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            924,
            21
          ],
          [
            924,
            51
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            964,
            24
          ],
          [
            964,
            54
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            991,
            20
          ],
          [
            991,
            50
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1001,
            20
          ],
          [
            1001,
            50
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1028,
            21
          ],
          [
            1028,
            51
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1062,
            24
          ],
          [
            1062,
            54
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1076,
            20
          ],
          [
            1076,
            50
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1086,
            20
          ],
          [
            1086,
            50
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1096,
            33
          ],
          [
            1096,
            63
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1196,
            37
          ],
          [
            1196,
            67
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1290,
            32
          ],
          [
            1290,
            62
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1299,
            32
          ],
          [
            1299,
            62
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1327,
            22
          ],
          [
            1327,
            52
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1381,
            26
          ],
          [
            1381,
            56
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1405,
            21
          ],
          [
            1405,
            51
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1414,
            21
          ],
          [
            1414,
            51
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1445,
            32
          ],
          [
            1445,
            62
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1480,
            36
          ],
          [
            1480,
            66
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1515,
            31
          ],
          [
            1515,
            61
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1524,
            31
          ],
          [
            1524,
            61
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1550,
            25
          ],
          [
            1550,
            55
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            1553,
            4
          ],
          [
            1553,
            13
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            1556,
            19
          ],
          [
            1556,
            28
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            1556,
            67
          ],
          [
            1556,
            76
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1571,
            29
          ],
          [
            1571,
            59
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            1573,
            4
          ],
          [
            1573,
            13
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            1573,
            28
          ],
          [
            1573,
            37
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1586,
            24
          ],
          [
            1586,
            54
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            1588,
            52
          ],
          [
            1588,
            61
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1594,
            24
          ],
          [
            1594,
            54
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1612,
            28
          ],
          [
            1612,
            58
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1633,
            32
          ],
          [
            1633,
            62
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1650,
            27
          ],
          [
            1650,
            57
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1658,
            27
          ],
          [
            1658,
            57
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1674,
            20
          ],
          [
            1674,
            50
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1768,
            24
          ],
          [
            1768,
            54
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1812,
            19
          ],
          [
            1812,
            49
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1821,
            19
          ],
          [
            1821,
            49
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            1999,
            21
          ],
          [
            1999,
            51
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            2100,
            24
          ],
          [
            2100,
            54
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            2213,
            20
          ],
          [
            2213,
            50
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            2222,
            20
          ],
          [
            2222,
            50
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            2304,
            22
          ],
          [
            2304,
            52
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            2397,
            25
          ],
          [
            2397,
            55
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            2534,
            21
          ],
          [
            2534,
            51
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            2543,
            21
          ],
          [
            2543,
            51
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            2560,
            21
          ],
          [
            2560,
            51
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            2595,
            19
          ],
          [
            2595,
            49
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            2658,
            32
          ],
          [
            2658,
            62
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            2686,
            26
          ],
          [
            2686,
            56
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            2739,
            23
          ],
          [
            2739,
            53
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            2808,
            21
          ],
          [
            2808,
            51
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            2845,
            25
          ],
          [
            2845,
            55
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            2898,
            18
          ],
          [
            2898,
            48
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            2947,
            26
          ],
          [
            2947,
            56
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3037,
            22
          ],
          [
            3037,
            52
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3046,
            22
          ],
          [
            3046,
            52
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3058,
            23
          ],
          [
            3058,
            53
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3135,
            27
          ],
          [
            3135,
            57
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3220,
            22
          ],
          [
            3220,
            52
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3229,
            22
          ],
          [
            3229,
            52
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3251,
            30
          ],
          [
            3251,
            60
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3296,
            34
          ],
          [
            3296,
            64
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3327,
            29
          ],
          [
            3327,
            59
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3338,
            29
          ],
          [
            3338,
            59
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3363,
            27
          ],
          [
            3363,
            57
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3423,
            30
          ],
          [
            3423,
            60
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3468,
            26
          ],
          [
            3468,
            56
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3480,
            26
          ],
          [
            3480,
            56
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3501,
            25
          ],
          [
            3501,
            55
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3535,
            36
          ],
          [
            3535,
            66
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3591,
            25
          ],
          [
            3591,
            55
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3606,
            40
          ],
          [
            3606,
            70
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3633,
            35
          ],
          [
            3633,
            65
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3642,
            35
          ],
          [
            3642,
            65
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3663,
            18
          ],
          [
            3663,
            48
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3681,
            34
          ],
          [
            3681,
            64
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3716,
            19
          ],
          [
            3716,
            49
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3735,
            38
          ],
          [
            3735,
            68
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3755,
            33
          ],
          [
            3755,
            63
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3764,
            33
          ],
          [
            3764,
            63
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3783,
            22
          ],
          [
            3783,
            52
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3852,
            26
          ],
          [
            3852,
            56
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3880,
            21
          ],
          [
            3880,
            51
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3897,
            21
          ],
          [
            3897,
            51
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3929,
            28
          ],
          [
            3929,
            58
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3959,
            29
          ],
          [
            3959,
            59
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3978,
            24
          ],
          [
            3978,
            54
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            3999,
            28
          ],
          [
            3999,
            58
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4020,
            23
          ],
          [
            4020,
            53
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4029,
            23
          ],
          [
            4029,
            53
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4045,
            26
          ],
          [
            4045,
            56
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4084,
            29
          ],
          [
            4084,
            59
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4107,
            25
          ],
          [
            4107,
            55
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4116,
            25
          ],
          [
            4116,
            55
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4130,
            34
          ],
          [
            4130,
            64
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4158,
            37
          ],
          [
            4158,
            67
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4174,
            33
          ],
          [
            4174,
            63
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4183,
            33
          ],
          [
            4183,
            63
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4195,
            20
          ],
          [
            4195,
            50
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4204,
            20
          ],
          [
            4204,
            50
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4220,
            33
          ],
          [
            4220,
            63
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4344,
            21
          ],
          [
            4344,
            51
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4359,
            25
          ],
          [
            4359,
            55
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4466,
            22
          ],
          [
            4466,
            52
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4482,
            29
          ],
          [
            4482,
            59
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4511,
            26
          ],
          [
            4511,
            56
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4578,
            30
          ],
          [
            4578,
            60
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4614,
            24
          ],
          [
            4614,
            54
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4663,
            28
          ],
          [
            4663,
            58
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4713,
            20
          ],
          [
            4713,
            50
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4763,
            20
          ],
          [
            4763,
            50
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4808,
            23
          ],
          [
            4808,
            53
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4901,
            19
          ],
          [
            4901,
            49
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4910,
            19
          ],
          [
            4910,
            49
          ]
        ],
        [
          "typedef struct {\n    double Gamma;\n    double Min;\n    double Max;\n} _cmsVCGTGAMMA;",
          {
            "Gamma": "double",
            "Min": "double",
            "Max": "double"
          },
          "_cmsVCGTGAMMA",
          [
            4928,
            0
          ],
          [
            4932,
            16
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            4936,
            21
          ],
          [
            4936,
            51
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            5074,
            24
          ],
          [
            5074,
            54
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            5126,
            20
          ],
          [
            5126,
            50
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            5145,
            20
          ],
          [
            5145,
            50
          ]
        ],
        [
          "typedef struct {\n    cmsContext ContextID;\n    cmsUInt32Number *Offsets;\n    cmsUInt32Number *Sizes;\n} _cmsDICelem;",
          {
            "ContextID": "cmsContext",
            "*Offsets": "cmsUInt32Number",
            "*Sizes": "cmsUInt32Number"
          },
          "_cmsDICelem",
          [
            5157,
            0
          ],
          [
            5161,
            14
          ]
        ],
        [
          "typedef struct {\n    _cmsDICelem Name, Value, DisplayName, DisplayValue;\n\n} _cmsDICarray;",
          {
            "Name": "_cmsDICelem"
          },
          "_cmsDICarray",
          [
            5163,
            0
          ],
          [
            5166,
            15
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            5385,
            20
          ],
          [
            5385,
            50
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            5403,
            21
          ],
          [
            5403,
            51
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            5428,
            27
          ],
          [
            5428,
            57
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            5516,
            30
          ],
          [
            5516,
            60
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            5592,
            26
          ],
          [
            5592,
            56
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            5602,
            26
          ],
          [
            5602,
            56
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            5611,
            28
          ],
          [
            5611,
            58
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            5637,
            31
          ],
          [
            5637,
            61
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            5653,
            27
          ],
          [
            5653,
            57
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            5662,
            27
          ],
          [
            5662,
            57
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            5701,
            20
          ],
          [
            5701,
            50
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            5712,
            20
          ],
          [
            5712,
            50
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            5748,
            24
          ],
          [
            5748,
            54
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            5820,
            21
          ],
          [
            5820,
            51
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            5930,
            20
          ],
          [
            5930,
            45
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            5931,
            26
          ],
          [
            5931,
            51
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            5964,
            33
          ],
          [
            5964,
            58
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            5965,
            39
          ],
          [
            5965,
            64
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            5978,
            33
          ],
          [
            5978,
            58
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            5979,
            37
          ],
          [
            5979,
            62
          ]
        ],
        [
          "typedef struct _cmsTagLinkedList_st {\n\n            cmsTagSignature Signature;\n            cmsTagDescriptor Descriptor;\n            struct _cmsTagLinkedList_st* Next;\n\n} _cmsTagLinkedList;",
          {
            "Signature": "cmsTagSignature",
            "Descriptor": "cmsTagDescriptor",
            "* Next": "struct _cmsTagLinkedList_st"
          },
          "_cmsTagLinkedList",
          [
            6018,
            0
          ],
          [
            6024,
            20
          ]
        ],
        [
          "struct _cmsTagLinkedList_st",
          {},
          "",
          [
            6022,
            12
          ],
          [
            6022,
            39
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            6136,
            16
          ],
          [
            6136,
            41
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            6137,
            26
          ],
          [
            6137,
            51
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            6168,
            29
          ],
          [
            6168,
            54
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            6169,
            39
          ],
          [
            6169,
            64
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmspcs.c": {
      "fn_def_list": [
        {
          "fn_code": "void CMSEXPORT cmsXYZ2xyY(cmsCIExyY* Dest, const cmsCIEXYZ* Source)\n{\n    cmsFloat64Number ISum;\n\n    ISum = 1./(Source -> X + Source -> Y + Source -> Z);\n\n    Dest -> x = (Source -> X) * ISum;\n    Dest -> y = (Source -> Y) * ISum;\n    Dest -> Y = Source -> Y;\n}",
          "fn_code_pos": [
            [
              90,
              0
            ],
            [
              99,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsXYZ2xyY",
            "parameters": {
              "Dest": "cmsCIExyY",
              "Source": "cmsCIEXYZ"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsxyY2XYZ(cmsCIEXYZ* Dest, const cmsCIExyY* Source)\n{\n    Dest -> X = (Source -> x / Source -> y) * Source -> Y;\n    Dest -> Y = Source -> Y;\n    Dest -> Z = ((1 - Source -> x - Source -> y) / Source -> y) * Source -> Y;\n}",
          "fn_code_pos": [
            [
              101,
              0
            ],
            [
              106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsxyY2XYZ",
            "parameters": {
              "Dest": "cmsCIEXYZ",
              "Source": "cmsCIExyY"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number f(cmsFloat64Number t)\n{\n    const cmsFloat64Number Limit = (24.0/116.0) * (24.0/116.0) * (24.0/116.0);\n\n    if (t <= Limit)\n        return (841.0/108.0) * t + (16.0/116.0);\n    else\n        return pow(t, 1.0/3.0);\n}",
          "fn_code_pos": [
            [
              117,
              0
            ],
            [
              126,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "f",
            "parameters": {
              "t": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number f_1(cmsFloat64Number t)\n{\n    const cmsFloat64Number Limit = (24.0/116.0);\n\n    if (t <= Limit) {\n        return (108.0/841.0) * (t - (16.0/116.0));\n    }\n\n    return t * t * t;\n}",
          "fn_code_pos": [
            [
              128,
              0
            ],
            [
              138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "f_1",
            "parameters": {
              "t": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsXYZ2Lab(const cmsCIEXYZ* WhitePoint, cmsCIELab* Lab, const cmsCIEXYZ* xyz)\n{\n    cmsFloat64Number fx, fy, fz;\n\n    if (WhitePoint == NULL)\n        WhitePoint = cmsD50_XYZ();\n\n    fx = f(xyz->X / WhitePoint->X);\n    fy = f(xyz->Y / WhitePoint->Y);\n    fz = f(xyz->Z / WhitePoint->Z);\n\n    Lab->L = 116.0*fy - 16.0;\n    Lab->a = 500.0*(fx - fy);\n    Lab->b = 200.0*(fy - fz);\n}",
          "fn_code_pos": [
            [
              142,
              0
            ],
            [
              156,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsXYZ2Lab",
            "parameters": {
              "WhitePoint": "cmsCIEXYZ",
              "Lab": "cmsCIELab",
              "xyz": "cmsCIEXYZ"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsLab2XYZ(const cmsCIEXYZ* WhitePoint, cmsCIEXYZ* xyz,  const cmsCIELab* Lab)\n{\n    cmsFloat64Number x, y, z;\n\n    if (WhitePoint == NULL)\n        WhitePoint = cmsD50_XYZ();\n\n    y = (Lab-> L + 16.0) / 116.0;\n    x = y + 0.002 * Lab -> a;\n    z = y - 0.005 * Lab -> b;\n\n    xyz -> X = f_1(x) * WhitePoint -> X;\n    xyz -> Y = f_1(y) * WhitePoint -> Y;\n    xyz -> Z = f_1(z) * WhitePoint -> Z;\n\n}",
          "fn_code_pos": [
            [
              160,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsLab2XYZ",
            "parameters": {
              "WhitePoint": "cmsCIEXYZ",
              "xyz": "cmsCIEXYZ",
              "Lab": "cmsCIELab"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number L2float2(cmsUInt16Number v)\n{\n    return (cmsFloat64Number) v / 652.800;\n}",
          "fn_code_pos": [
            [
              177,
              0
            ],
            [
              181,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "L2float2",
            "parameters": {
              "v": "cmsUInt16Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number ab2float2(cmsUInt16Number v)\n{\n    return ((cmsFloat64Number) v / 256.0) - 128.0;\n}",
          "fn_code_pos": [
            [
              184,
              0
            ],
            [
              188,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ab2float2",
            "parameters": {
              "v": "cmsUInt16Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt16Number L2Fix2(cmsFloat64Number L)\n{\n    return _cmsQuickSaturateWord(L *  652.8);\n}",
          "fn_code_pos": [
            [
              190,
              0
            ],
            [
              194,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "L2Fix2",
            "parameters": {
              "L": "cmsFloat64Number"
            },
            "return_type": "cmsUInt16Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt16Number ab2Fix2(cmsFloat64Number ab)\n{\n    return _cmsQuickSaturateWord((ab + 128.0) * 256.0);\n}",
          "fn_code_pos": [
            [
              196,
              0
            ],
            [
              200,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ab2Fix2",
            "parameters": {
              "ab": "cmsFloat64Number"
            },
            "return_type": "cmsUInt16Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number L2float4(cmsUInt16Number v)\n{\n    return (cmsFloat64Number) v / 655.35;\n}",
          "fn_code_pos": [
            [
              203,
              0
            ],
            [
              207,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "L2float4",
            "parameters": {
              "v": "cmsUInt16Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number ab2float4(cmsUInt16Number v)\n{\n    return ((cmsFloat64Number) v / 257.0) - 128.0;\n}",
          "fn_code_pos": [
            [
              210,
              0
            ],
            [
              214,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ab2float4",
            "parameters": {
              "v": "cmsUInt16Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsLabEncoded2FloatV2(cmsCIELab* Lab, const cmsUInt16Number wLab[3])\n{\n        Lab->L = L2float2(wLab[0]);\n        Lab->a = ab2float2(wLab[1]);\n        Lab->b = ab2float2(wLab[2]);\n}",
          "fn_code_pos": [
            [
              217,
              0
            ],
            [
              222,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsLabEncoded2FloatV2",
            "parameters": {
              "Lab": "cmsCIELab",
              "wLab": "cmsUInt16Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsLabEncoded2Float(cmsCIELab* Lab, const cmsUInt16Number wLab[3])\n{\n        Lab->L = L2float4(wLab[0]);\n        Lab->a = ab2float4(wLab[1]);\n        Lab->b = ab2float4(wLab[2]);\n}",
          "fn_code_pos": [
            [
              225,
              0
            ],
            [
              230,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsLabEncoded2Float",
            "parameters": {
              "Lab": "cmsCIELab",
              "wLab": "cmsUInt16Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number Clamp_L_doubleV2(cmsFloat64Number L)\n{\n    const cmsFloat64Number L_max = (cmsFloat64Number) (0xFFFF * 100.0) / 0xFF00;\n\n    if (L < 0) L = 0;\n    if (L > L_max) L = L_max;\n\n    return L;\n}",
          "fn_code_pos": [
            [
              232,
              0
            ],
            [
              241,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Clamp_L_doubleV2",
            "parameters": {
              "L": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number Clamp_ab_doubleV2(cmsFloat64Number ab)\n{\n    if (ab < MIN_ENCODEABLE_ab2) ab = MIN_ENCODEABLE_ab2;\n    if (ab > MAX_ENCODEABLE_ab2) ab = MAX_ENCODEABLE_ab2;\n\n    return ab;\n}",
          "fn_code_pos": [
            [
              244,
              0
            ],
            [
              251,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Clamp_ab_doubleV2",
            "parameters": {
              "ab": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsFloat2LabEncodedV2(cmsUInt16Number wLab[3], const cmsCIELab* fLab)\n{\n    cmsCIELab Lab;\n\n    Lab.L = Clamp_L_doubleV2(fLab ->L);\n    Lab.a = Clamp_ab_doubleV2(fLab ->a);\n    Lab.b = Clamp_ab_doubleV2(fLab ->b);\n\n    wLab[0] = L2Fix2(Lab.L);\n    wLab[1] = ab2Fix2(Lab.a);\n    wLab[2] = ab2Fix2(Lab.b);\n}",
          "fn_code_pos": [
            [
              253,
              0
            ],
            [
              264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFloat2LabEncodedV2",
            "parameters": {
              "wLab": "cmsUInt16Number",
              "fLab": "cmsCIELab"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number Clamp_L_doubleV4(cmsFloat64Number L)\n{\n    if (L < 0) L = 0;\n    if (L > 100.0) L = 100.0;\n\n    return L;\n}",
          "fn_code_pos": [
            [
              267,
              0
            ],
            [
              274,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Clamp_L_doubleV4",
            "parameters": {
              "L": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number Clamp_ab_doubleV4(cmsFloat64Number ab)\n{\n    if (ab < MIN_ENCODEABLE_ab4) ab = MIN_ENCODEABLE_ab4;\n    if (ab > MAX_ENCODEABLE_ab4) ab = MAX_ENCODEABLE_ab4;\n\n    return ab;\n}",
          "fn_code_pos": [
            [
              276,
              0
            ],
            [
              283,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Clamp_ab_doubleV4",
            "parameters": {
              "ab": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt16Number L2Fix4(cmsFloat64Number L)\n{\n    return _cmsQuickSaturateWord(L *  655.35);\n}",
          "fn_code_pos": [
            [
              285,
              0
            ],
            [
              289,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "L2Fix4",
            "parameters": {
              "L": "cmsFloat64Number"
            },
            "return_type": "cmsUInt16Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt16Number ab2Fix4(cmsFloat64Number ab)\n{\n    return _cmsQuickSaturateWord((ab + 128.0) * 257.0);\n}",
          "fn_code_pos": [
            [
              291,
              0
            ],
            [
              295,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ab2Fix4",
            "parameters": {
              "ab": "cmsFloat64Number"
            },
            "return_type": "cmsUInt16Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsFloat2LabEncoded(cmsUInt16Number wLab[3], const cmsCIELab* fLab)\n{\n    cmsCIELab Lab;\n\n    Lab.L = Clamp_L_doubleV4(fLab ->L);\n    Lab.a = Clamp_ab_doubleV4(fLab ->a);\n    Lab.b = Clamp_ab_doubleV4(fLab ->b);\n\n    wLab[0] = L2Fix4(Lab.L);\n    wLab[1] = ab2Fix4(Lab.a);\n    wLab[2] = ab2Fix4(Lab.b);\n}",
          "fn_code_pos": [
            [
              297,
              0
            ],
            [
              308,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFloat2LabEncoded",
            "parameters": {
              "wLab": "cmsUInt16Number",
              "fLab": "cmsCIELab"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number RADIANS(cmsFloat64Number deg)\n{\n    return (deg * M_PI) / 180.;\n}",
          "fn_code_pos": [
            [
              311,
              0
            ],
            [
              315,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RADIANS",
            "parameters": {
              "deg": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number atan2deg(cmsFloat64Number a, cmsFloat64Number b)\n{\n   cmsFloat64Number h;\n\n   if (a == 0 && b == 0)\n            h   = 0;\n    else\n            h = atan2(a, b);\n\n    h *= (180. / M_PI);\n\n    while (h > 360.)\n        h -= 360.;\n\n    while ( h < 0)\n        h += 360.;\n\n    return h;\n}",
          "fn_code_pos": [
            [
              319,
              0
            ],
            [
              338,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "atan2deg",
            "parameters": {
              "a": "cmsFloat64Number",
              "b": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number Sqr(cmsFloat64Number v)\n{\n    return v *  v;\n}",
          "fn_code_pos": [
            [
              342,
              0
            ],
            [
              346,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Sqr",
            "parameters": {
              "v": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsLab2LCh(cmsCIELCh* LCh, const cmsCIELab* Lab)\n{\n    LCh -> L = Lab -> L;\n    LCh -> C = pow(Sqr(Lab ->a) + Sqr(Lab ->b), 0.5);\n    LCh -> h = atan2deg(Lab ->b, Lab ->a);\n}",
          "fn_code_pos": [
            [
              348,
              0
            ],
            [
              353,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsLab2LCh",
            "parameters": {
              "LCh": "cmsCIELCh",
              "Lab": "cmsCIELab"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsLCh2Lab(cmsCIELab* Lab, const cmsCIELCh* LCh)\n{\n    cmsFloat64Number h = (LCh -> h * M_PI) / 180.0;\n\n    Lab -> L = LCh -> L;\n    Lab -> a = LCh -> C * cos(h);\n    Lab -> b = LCh -> C * sin(h);\n}",
          "fn_code_pos": [
            [
              357,
              0
            ],
            [
              364,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsLCh2Lab",
            "parameters": {
              "Lab": "cmsCIELab",
              "LCh": "cmsCIELCh"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsUInt16Number XYZ2Fix(cmsFloat64Number d)\n{\n    return _cmsQuickSaturateWord(d * 32768.0);\n}",
          "fn_code_pos": [
            [
              367,
              0
            ],
            [
              371,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "XYZ2Fix",
            "parameters": {
              "d": "cmsFloat64Number"
            },
            "return_type": "cmsUInt16Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsFloat2XYZEncoded(cmsUInt16Number XYZ[3], const cmsCIEXYZ* fXYZ)\n{\n    cmsCIEXYZ xyz;\n\n    xyz.X = fXYZ -> X;\n    xyz.Y = fXYZ -> Y;\n    xyz.Z = fXYZ -> Z;\n\n    // Clamp to encodeable values.\n    if (xyz.Y <= 0) {\n\n        xyz.X = 0;\n        xyz.Y = 0;\n        xyz.Z = 0;\n    }\n\n    if (xyz.X > MAX_ENCODEABLE_XYZ)\n        xyz.X = MAX_ENCODEABLE_XYZ;\n\n    if (xyz.X < 0)\n        xyz.X = 0;\n\n    if (xyz.Y > MAX_ENCODEABLE_XYZ)\n        xyz.Y = MAX_ENCODEABLE_XYZ;\n\n    if (xyz.Y < 0)\n        xyz.Y = 0;\n\n    if (xyz.Z > MAX_ENCODEABLE_XYZ)\n        xyz.Z = MAX_ENCODEABLE_XYZ;\n\n    if (xyz.Z < 0)\n        xyz.Z = 0;\n\n\n    XYZ[0] = XYZ2Fix(xyz.X);\n    XYZ[1] = XYZ2Fix(xyz.Y);\n    XYZ[2] = XYZ2Fix(xyz.Z);\n}",
          "fn_code_pos": [
            [
              373,
              0
            ],
            [
              411,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFloat2XYZEncoded",
            "parameters": {
              "XYZ": "cmsUInt16Number",
              "fXYZ": "cmsCIEXYZ"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number XYZ2float(cmsUInt16Number v)\n{\n    cmsS15Fixed16Number fix32;\n\n    // From 1.15 to 15.16\n    fix32 = v << 1;\n\n    // From fixed 15.16 to cmsFloat64Number\n    return _cms15Fixed16toDouble(fix32);\n}",
          "fn_code_pos": [
            [
              415,
              0
            ],
            [
              425,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "XYZ2float",
            "parameters": {
              "v": "cmsUInt16Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsXYZEncoded2Float(cmsCIEXYZ* fXYZ, const cmsUInt16Number XYZ[3])\n{\n    fXYZ -> X = XYZ2float(XYZ[0]);\n    fXYZ -> Y = XYZ2float(XYZ[1]);\n    fXYZ -> Z = XYZ2float(XYZ[2]);\n}",
          "fn_code_pos": [
            [
              428,
              0
            ],
            [
              433,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsXYZEncoded2Float",
            "parameters": {
              "fXYZ": "cmsCIEXYZ",
              "XYZ": "cmsUInt16Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsFloat64Number CMSEXPORT cmsDeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2)\n{\n    cmsFloat64Number dL, da, db;\n\n    dL = fabs(Lab1 -> L - Lab2 -> L);\n    da = fabs(Lab1 -> a - Lab2 -> a);\n    db = fabs(Lab1 -> b - Lab2 -> b);\n\n    return pow(Sqr(dL) + Sqr(da) + Sqr(db), 0.5);\n}",
          "fn_code_pos": [
            [
              437,
              0
            ],
            [
              446,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDeltaE",
            "parameters": {
              "Lab1": "cmsCIELab",
              "Lab2": "cmsCIELab"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "cmsFloat64Number CMSEXPORT cmsCIE94DeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2)\n{\n    cmsCIELCh LCh1, LCh2;\n    cmsFloat64Number dE, dL, dC, dh, dhsq;\n    cmsFloat64Number c12, sc, sh;\n\n    dL = fabs(Lab1 ->L - Lab2 ->L);\n\n    cmsLab2LCh(&LCh1, Lab1);\n    cmsLab2LCh(&LCh2, Lab2);\n\n    dC  = fabs(LCh1.C - LCh2.C);\n    dE  = cmsDeltaE(Lab1, Lab2);\n\n    dhsq = Sqr(dE) - Sqr(dL) - Sqr(dC);\n    if (dhsq < 0)\n        dh = 0;\n    else\n        dh = pow(dhsq, 0.5);\n\n    c12 = sqrt(LCh1.C * LCh2.C);\n\n    sc = 1.0 + (0.048 * c12);\n    sh = 1.0 + (0.014 * c12);\n\n    return sqrt(Sqr(dL)  + Sqr(dC) / Sqr(sc) + Sqr(dh) / Sqr(sh));\n}",
          "fn_code_pos": [
            [
              450,
              0
            ],
            [
              476,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCIE94DeltaE",
            "parameters": {
              "Lab1": "cmsCIELab",
              "Lab2": "cmsCIELab"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number ComputeLBFD(const cmsCIELab* Lab)\n{\n  cmsFloat64Number yt;\n\n  if (Lab->L > 7.996969)\n        yt = (Sqr((Lab->L+16)/116)*((Lab->L+16)/116))*100;\n  else\n        yt = 100 * (Lab->L / 903.3);\n\n  return (54.6 * (M_LOG10E * (log(yt + 1.5))) - 9.6);\n}",
          "fn_code_pos": [
            [
              480,
              0
            ],
            [
              491,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComputeLBFD",
            "parameters": {
              "Lab": "cmsCIELab"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "cmsFloat64Number CMSEXPORT cmsBFDdeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2)\n{\n    cmsFloat64Number lbfd1,lbfd2,AveC,Aveh,dE,deltaL,\n        deltaC,deltah,dc,t,g,dh,rh,rc,rt,bfd;\n    cmsCIELCh LCh1, LCh2;\n\n\n    lbfd1 = ComputeLBFD(Lab1);\n    lbfd2 = ComputeLBFD(Lab2);\n    deltaL = lbfd2 - lbfd1;\n\n    cmsLab2LCh(&LCh1, Lab1);\n    cmsLab2LCh(&LCh2, Lab2);\n\n    deltaC = LCh2.C - LCh1.C;\n    AveC = (LCh1.C+LCh2.C)/2;\n    Aveh = (LCh1.h+LCh2.h)/2;\n\n    dE = cmsDeltaE(Lab1, Lab2);\n\n    if (Sqr(dE)>(Sqr(Lab2->L-Lab1->L)+Sqr(deltaC)))\n        deltah = sqrt(Sqr(dE)-Sqr(Lab2->L-Lab1->L)-Sqr(deltaC));\n    else\n        deltah =0;\n\n\n    dc   = 0.035 * AveC / (1 + 0.00365 * AveC)+0.521;\n    g    = sqrt(Sqr(Sqr(AveC))/(Sqr(Sqr(AveC))+14000));\n    t    = 0.627+(0.055*cos((Aveh-254)/(180/M_PI))-\n           0.040*cos((2*Aveh-136)/(180/M_PI))+\n           0.070*cos((3*Aveh-31)/(180/M_PI))+\n           0.049*cos((4*Aveh+114)/(180/M_PI))-\n           0.015*cos((5*Aveh-103)/(180/M_PI)));\n\n    dh    = dc*(g*t+1-g);\n    rh    = -0.260*cos((Aveh-308)/(180/M_PI))-\n           0.379*cos((2*Aveh-160)/(180/M_PI))-\n           0.636*cos((3*Aveh+254)/(180/M_PI))+\n           0.226*cos((4*Aveh+140)/(180/M_PI))-\n           0.194*cos((5*Aveh+280)/(180/M_PI));\n\n    rc = sqrt((AveC*AveC*AveC*AveC*AveC*AveC)/((AveC*AveC*AveC*AveC*AveC*AveC)+70000000));\n    rt = rh*rc;\n\n    bfd = sqrt(Sqr(deltaL)+Sqr(deltaC/dc)+Sqr(deltah/dh)+(rt*(deltaC/dc)*(deltah/dh)));\n\n    return bfd;\n}",
          "fn_code_pos": [
            [
              496,
              0
            ],
            [
              543,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsBFDdeltaE",
            "parameters": {
              "Lab1": "cmsCIELab",
              "Lab2": "cmsCIELab"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "cmsFloat64Number CMSEXPORT cmsCMCdeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2, cmsFloat64Number l, cmsFloat64Number c)\n{\n  cmsFloat64Number dE,dL,dC,dh,sl,sc,sh,t,f,cmc;\n  cmsCIELCh LCh1, LCh2;\n\n  if (Lab1 ->L == 0 && Lab2 ->L == 0) return 0;\n\n  cmsLab2LCh(&LCh1, Lab1);\n  cmsLab2LCh(&LCh2, Lab2);\n\n\n  dL = Lab2->L-Lab1->L;\n  dC = LCh2.C-LCh1.C;\n\n  dE = cmsDeltaE(Lab1, Lab2);\n\n  if (Sqr(dE)>(Sqr(dL)+Sqr(dC)))\n            dh = sqrt(Sqr(dE)-Sqr(dL)-Sqr(dC));\n  else\n            dh =0;\n\n  if ((LCh1.h > 164) && (LCh1.h < 345))\n      t = 0.56 + fabs(0.2 * cos(((LCh1.h + 168)/(180/M_PI))));\n  else\n      t = 0.36 + fabs(0.4 * cos(((LCh1.h + 35 )/(180/M_PI))));\n\n   sc  = 0.0638   * LCh1.C / (1 + 0.0131  * LCh1.C) + 0.638;\n   sl  = 0.040975 * Lab1->L /(1 + 0.01765 * Lab1->L);\n\n   if (Lab1->L<16)\n         sl = 0.511;\n\n   f   = sqrt((LCh1.C * LCh1.C * LCh1.C * LCh1.C)/((LCh1.C * LCh1.C * LCh1.C * LCh1.C)+1900));\n   sh  = sc*(t*f+1-f);\n   cmc = sqrt(Sqr(dL/(l*sl))+Sqr(dC/(c*sc))+Sqr(dh/sh));\n\n   return cmc;\n}",
          "fn_code_pos": [
            [
              547,
              0
            ],
            [
              584,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCMCdeltaE",
            "parameters": {
              "Lab1": "cmsCIELab",
              "Lab2": "cmsCIELab",
              "l": "cmsFloat64Number",
              "c": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "cmsFloat64Number CMSEXPORT cmsCIE2000DeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2,\n                                  cmsFloat64Number Kl, cmsFloat64Number Kc, cmsFloat64Number Kh)\n{\n    cmsFloat64Number L1  = Lab1->L;\n    cmsFloat64Number a1  = Lab1->a;\n    cmsFloat64Number b1  = Lab1->b;\n    cmsFloat64Number C   = sqrt( Sqr(a1) + Sqr(b1) );\n\n    cmsFloat64Number Ls = Lab2 ->L;\n    cmsFloat64Number as = Lab2 ->a;\n    cmsFloat64Number bs = Lab2 ->b;\n    cmsFloat64Number Cs = sqrt( Sqr(as) + Sqr(bs) );\n\n    cmsFloat64Number G = 0.5 * ( 1 - sqrt(pow((C + Cs) / 2 , 7.0) / (pow((C + Cs) / 2, 7.0) + pow(25.0, 7.0) ) ));\n\n    cmsFloat64Number a_p = (1 + G ) * a1;\n    cmsFloat64Number b_p = b1;\n    cmsFloat64Number C_p = sqrt( Sqr(a_p) + Sqr(b_p));\n    cmsFloat64Number h_p = atan2deg(b_p, a_p);\n\n\n    cmsFloat64Number a_ps = (1 + G) * as;\n    cmsFloat64Number b_ps = bs;\n    cmsFloat64Number C_ps = sqrt(Sqr(a_ps) + Sqr(b_ps));\n    cmsFloat64Number h_ps = atan2deg(b_ps, a_ps);\n\n    cmsFloat64Number meanC_p =(C_p + C_ps) / 2;\n\n    cmsFloat64Number hps_plus_hp  = h_ps + h_p;\n    cmsFloat64Number hps_minus_hp = h_ps - h_p;\n\n    cmsFloat64Number meanh_p = fabs(hps_minus_hp) <= 180.000001 ? (hps_plus_hp)/2 :\n                            (hps_plus_hp) < 360 ? (hps_plus_hp + 360)/2 :\n                                                 (hps_plus_hp - 360)/2;\n\n    cmsFloat64Number delta_h = (hps_minus_hp) <= -180.000001 ?  (hps_minus_hp + 360) :\n                            (hps_minus_hp) > 180 ? (hps_minus_hp - 360) :\n                                                    (hps_minus_hp);\n    cmsFloat64Number delta_L = (Ls - L1);\n    cmsFloat64Number delta_C = (C_ps - C_p );\n\n\n    cmsFloat64Number delta_H =2 * sqrt(C_ps*C_p) * sin(RADIANS(delta_h) / 2);\n\n    cmsFloat64Number T = 1 - 0.17 * cos(RADIANS(meanh_p-30))\n                 + 0.24 * cos(RADIANS(2*meanh_p))\n                 + 0.32 * cos(RADIANS(3*meanh_p + 6))\n                 - 0.2  * cos(RADIANS(4*meanh_p - 63));\n\n    cmsFloat64Number Sl = 1 + (0.015 * Sqr((Ls + L1) /2- 50) )/ sqrt(20 + Sqr( (Ls+L1)/2 - 50) );\n\n    cmsFloat64Number Sc = 1 + 0.045 * (C_p + C_ps)/2;\n    cmsFloat64Number Sh = 1 + 0.015 * ((C_ps + C_p)/2) * T;\n\n    cmsFloat64Number delta_ro = 30 * exp( -Sqr(((meanh_p - 275 ) / 25)));\n\n    cmsFloat64Number Rc = 2 * sqrt(( pow(meanC_p, 7.0) )/( pow(meanC_p, 7.0) + pow(25.0, 7.0)));\n\n    cmsFloat64Number Rt = -sin(2 * RADIANS(delta_ro)) * Rc;\n\n    cmsFloat64Number deltaE00 = sqrt( Sqr(delta_L /(Sl * Kl)) +\n                            Sqr(delta_C/(Sc * Kc))  +\n                            Sqr(delta_H/(Sh * Kh))  +\n                            Rt*(delta_C/(Sc * Kc)) * (delta_H / (Sh * Kh)));\n\n    return deltaE00;\n}",
          "fn_code_pos": [
            [
              588,
              0
            ],
            [
              654,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCIE2000DeltaE",
            "parameters": {
              "Lab1": "cmsCIELab",
              "Lab2": "cmsCIELab",
              "Kl": "cmsFloat64Number",
              "Kc": "cmsFloat64Number",
              "Kh": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT _cmsReasonableGridpointsByColorspace(cmsColorSpaceSignature Colorspace, cmsUInt32Number dwFlags)\n{\n    cmsUInt32Number nChannels;\n\n    // Already specified?\n    if (dwFlags & 0x00FF0000) {\n            // Yes, grab'em\n            return (dwFlags >> 16) & 0xFF;\n    }\n\n    nChannels = cmsChannelsOf(Colorspace);\n\n    // HighResPrecalc is maximum resolution\n    if (dwFlags & cmsFLAGS_HIGHRESPRECALC) {\n\n        if (nChannels > 4)\n                return 7;       // 7 for Hifi\n\n        if (nChannels == 4)     // 23 for CMYK\n                return 23;\n\n        return 49;      // 49 for RGB and others\n    }\n\n\n    // LowResPrecal is lower resolution\n    if (dwFlags & cmsFLAGS_LOWRESPRECALC) {\n\n        if (nChannels > 4)\n                return 6;       // 6 for more than 4 channels\n\n        if (nChannels == 1)\n                return 33;      // For monochrome\n\n        return 17;              // 17 for remaining\n    }\n\n    // Default values\n    if (nChannels > 4)\n                return 7;       // 7 for Hifi\n\n    if (nChannels == 4)\n                return 17;      // 17 for CMYK\n\n    return 33;                  // 33 for RGB\n}",
          "fn_code_pos": [
            [
              658,
              0
            ],
            [
              703,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReasonableGridpointsByColorspace",
            "parameters": {
              "Colorspace": "cmsColorSpaceSignature",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsBool  _cmsEndPointsBySpace(cmsColorSpaceSignature Space,\n                             cmsUInt16Number **White,\n                             cmsUInt16Number **Black,\n                             cmsUInt32Number *nOutputs)\n{\n       // Only most common spaces\n\n       static cmsUInt16Number RGBblack[4]  = { 0, 0, 0 };\n       static cmsUInt16Number RGBwhite[4]  = { 0xffff, 0xffff, 0xffff };\n       static cmsUInt16Number CMYKblack[4] = { 0xffff, 0xffff, 0xffff, 0xffff };   // 400% of ink\n       static cmsUInt16Number CMYKwhite[4] = { 0, 0, 0, 0 };\n       static cmsUInt16Number LABblack[4]  = { 0, 0x8080, 0x8080 };               // V4 Lab encoding\n       static cmsUInt16Number LABwhite[4]  = { 0xFFFF, 0x8080, 0x8080 };\n       static cmsUInt16Number CMYblack[4]  = { 0xffff, 0xffff, 0xffff };\n       static cmsUInt16Number CMYwhite[4]  = { 0, 0, 0 };\n       static cmsUInt16Number Grayblack[4] = { 0 };\n       static cmsUInt16Number GrayWhite[4] = { 0xffff };\n\n       switch (Space) {\n\n       case cmsSigGrayData: if (White)    *White = GrayWhite;\n                           if (Black)    *Black = Grayblack;\n                           if (nOutputs) *nOutputs = 1;\n                           return TRUE;\n\n       case cmsSigRgbData:  if (White)    *White = RGBwhite;\n                           if (Black)    *Black = RGBblack;\n                           if (nOutputs) *nOutputs = 3;\n                           return TRUE;\n\n       case cmsSigLabData:  if (White)    *White = LABwhite;\n                           if (Black)    *Black = LABblack;\n                           if (nOutputs) *nOutputs = 3;\n                           return TRUE;\n\n       case cmsSigCmykData: if (White)    *White = CMYKwhite;\n                           if (Black)    *Black = CMYKblack;\n                           if (nOutputs) *nOutputs = 4;\n                           return TRUE;\n\n       case cmsSigCmyData:  if (White)    *White = CMYwhite;\n                           if (Black)    *Black = CMYblack;\n                           if (nOutputs) *nOutputs = 3;\n                           return TRUE;\n\n       default:;\n       }\n\n  return FALSE;\n}",
          "fn_code_pos": [
            [
              706,
              0
            ],
            [
              755,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsEndPointsBySpace",
            "parameters": {
              "Space": "cmsColorSpaceSignature",
              "White": "cmsUInt16Number",
              "Black": "cmsUInt16Number",
              "nOutputs": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsColorSpaceSignature CMSEXPORT _cmsICCcolorSpace(int OurNotation)\n{\n       switch (OurNotation) {\n\n       case 1:\n       case PT_GRAY: return cmsSigGrayData;\n\n       case 2:\n       case PT_RGB:  return cmsSigRgbData;\n\n       case PT_CMY:  return cmsSigCmyData;\n       case PT_CMYK: return cmsSigCmykData;\n       case PT_YCbCr:return cmsSigYCbCrData;\n       case PT_YUV:  return cmsSigLuvData;\n       case PT_XYZ:  return cmsSigXYZData;\n\n       case PT_LabV2:\n       case PT_Lab:  return cmsSigLabData;\n\n       case PT_YUVK: return cmsSigLuvKData;\n       case PT_HSV:  return cmsSigHsvData;\n       case PT_HLS:  return cmsSigHlsData;\n       case PT_Yxy:  return cmsSigYxyData;\n\n       case PT_MCH1: return cmsSigMCH1Data;\n       case PT_MCH2: return cmsSigMCH2Data;\n       case PT_MCH3: return cmsSigMCH3Data;\n       case PT_MCH4: return cmsSigMCH4Data;\n       case PT_MCH5: return cmsSigMCH5Data;\n       case PT_MCH6: return cmsSigMCH6Data;\n       case PT_MCH7: return cmsSigMCH7Data;\n       case PT_MCH8: return cmsSigMCH8Data;\n\n       case PT_MCH9:  return cmsSigMCH9Data;\n       case PT_MCH10: return cmsSigMCHAData;\n       case PT_MCH11: return cmsSigMCHBData;\n       case PT_MCH12: return cmsSigMCHCData;\n       case PT_MCH13: return cmsSigMCHDData;\n       case PT_MCH14: return cmsSigMCHEData;\n       case PT_MCH15: return cmsSigMCHFData;\n\n       default:  return (cmsColorSpaceSignature) 0;\n       }\n}",
          "fn_code_pos": [
            [
              763,
              0
            ],
            [
              806,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsICCcolorSpace",
            "parameters": {
              "OurNotation": "int"
            },
            "return_type": "cmsColorSpaceSignature"
          }
        },
        {
          "fn_code": "int CMSEXPORT _cmsLCMScolorSpace(cmsColorSpaceSignature ProfileSpace)\n{\n    switch (ProfileSpace) {\n\n    case cmsSigGrayData: return  PT_GRAY;\n    case cmsSigRgbData:  return  PT_RGB;\n    case cmsSigCmyData:  return  PT_CMY;\n    case cmsSigCmykData: return  PT_CMYK;\n    case cmsSigYCbCrData:return  PT_YCbCr;\n    case cmsSigLuvData:  return  PT_YUV;\n    case cmsSigXYZData:  return  PT_XYZ;\n    case cmsSigLabData:  return  PT_Lab;\n    case cmsSigLuvKData: return  PT_YUVK;\n    case cmsSigHsvData:  return  PT_HSV;\n    case cmsSigHlsData:  return  PT_HLS;\n    case cmsSigYxyData:  return  PT_Yxy;\n\n    case cmsSig1colorData:\n    case cmsSigMCH1Data: return PT_MCH1;\n\n    case cmsSig2colorData:\n    case cmsSigMCH2Data: return PT_MCH2;\n\n    case cmsSig3colorData:\n    case cmsSigMCH3Data: return PT_MCH3;\n\n    case cmsSig4colorData:\n    case cmsSigMCH4Data: return PT_MCH4;\n\n    case cmsSig5colorData:\n    case cmsSigMCH5Data: return PT_MCH5;\n\n    case cmsSig6colorData:\n    case cmsSigMCH6Data: return PT_MCH6;\n\n    case cmsSigMCH7Data:\n    case cmsSig7colorData:return PT_MCH7;\n\n    case cmsSigMCH8Data:\n    case cmsSig8colorData:return PT_MCH8;\n\n    case cmsSigMCH9Data:\n    case cmsSig9colorData:return PT_MCH9;\n\n    case cmsSigMCHAData:\n    case cmsSig10colorData:return PT_MCH10;\n\n    case cmsSigMCHBData:\n    case cmsSig11colorData:return PT_MCH11;\n\n    case cmsSigMCHCData:\n    case cmsSig12colorData:return PT_MCH12;\n\n    case cmsSigMCHDData:\n    case cmsSig13colorData:return PT_MCH13;\n\n    case cmsSigMCHEData:\n    case cmsSig14colorData:return PT_MCH14;\n\n    case cmsSigMCHFData:\n    case cmsSig15colorData:return PT_MCH15;\n\n    default:  return (cmsColorSpaceSignature) 0;\n    }\n}",
          "fn_code_pos": [
            [
              809,
              0
            ],
            [
              873,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsLCMScolorSpace",
            "parameters": {
              "ProfileSpace": "cmsColorSpaceSignature"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "cmsInt32Number CMSEXPORT cmsChannelsOfColorSpace(cmsColorSpaceSignature ColorSpace)\n{\n    switch (ColorSpace) {\n\n    case cmsSigMCH1Data:\n    case cmsSig1colorData:\n    case cmsSigGrayData: return 1;\n\n    case cmsSigMCH2Data:\n    case cmsSig2colorData:  return 2;\n\n    case cmsSigXYZData:\n    case cmsSigLabData:\n    case cmsSigLuvData:\n    case cmsSigYCbCrData:\n    case cmsSigYxyData:\n    case cmsSigRgbData:\n    case cmsSigHsvData:\n    case cmsSigHlsData:\n    case cmsSigCmyData:\n    case cmsSigMCH3Data:\n    case cmsSig3colorData:  return 3;\n\n    case cmsSigLuvKData:\n    case cmsSigCmykData:\n    case cmsSigMCH4Data:\n    case cmsSig4colorData:  return 4;\n\n    case cmsSigMCH5Data:\n    case cmsSig5colorData:  return 5;\n\n    case cmsSigMCH6Data:\n    case cmsSig6colorData:  return 6;\n\n    case cmsSigMCH7Data:\n    case cmsSig7colorData:  return  7;\n\n    case cmsSigMCH8Data:\n    case cmsSig8colorData:  return  8;\n\n    case cmsSigMCH9Data:\n    case cmsSig9colorData:  return  9;\n\n    case cmsSigMCHAData:\n    case cmsSig10colorData: return 10;\n\n    case cmsSigMCHBData:\n    case cmsSig11colorData: return 11;\n\n    case cmsSigMCHCData:\n    case cmsSig12colorData: return 12;\n\n    case cmsSigMCHDData:\n    case cmsSig13colorData: return 13;\n\n    case cmsSigMCHEData:\n    case cmsSig14colorData: return 14;\n\n    case cmsSigMCHFData:\n    case cmsSig15colorData: return 15;\n\n    default: return -1;\n    }\n}",
          "fn_code_pos": [
            [
              876,
              0
            ],
            [
              939,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsChannelsOfColorSpace",
            "parameters": {
              "ColorSpace": "cmsColorSpaceSignature"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsChannelsOf(cmsColorSpaceSignature ColorSpace)\n{\n    int n = cmsChannelsOfColorSpace(ColorSpace);\n    if (n < 0) return 3;\n    return (cmsUInt32Number)n;\n}",
          "fn_code_pos": [
            [
              944,
              0
            ],
            [
              949,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsChannelsOf",
            "parameters": {
              "ColorSpace": "cmsColorSpaceSignature"
            },
            "return_type": "cmsUInt32Number"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmsplugin.c": {
      "fn_def_list": [
        {
          "fn_code": "cmsUInt16Number CMSEXPORT  _cmsAdjustEndianess16(cmsUInt16Number Word)\n{\n#ifndef CMS_USE_BIG_ENDIAN\n\n    cmsUInt8Number* pByte = (cmsUInt8Number*) &Word;\n    cmsUInt8Number tmp;\n\n    tmp = pByte[0];\n    pByte[0] = pByte[1];\n    pByte[1] = tmp;\n#endif\n\n    return Word;\n}",
          "fn_code_pos": [
            [
              36,
              0
            ],
            [
              49,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAdjustEndianess16",
            "parameters": {
              "Word": "cmsUInt16Number"
            },
            "return_type": "cmsUInt16Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT  _cmsAdjustEndianess32(cmsUInt32Number DWord)\n{\n#ifndef CMS_USE_BIG_ENDIAN\n\n    cmsUInt8Number* pByte = (cmsUInt8Number*) &DWord;\n    cmsUInt8Number temp1;\n    cmsUInt8Number temp2;\n\n    temp1 = *pByte++;\n    temp2 = *pByte++;\n    *(pByte-1) = *pByte;\n    *pByte++ = temp2;\n    *(pByte-3) = *pByte;\n    *pByte = temp1;\n#endif\n    return DWord;\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              73,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAdjustEndianess32",
            "parameters": {
              "DWord": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT  _cmsAdjustEndianess64(cmsUInt64Number* Result, cmsUInt64Number* QWord)\n{\n\n#ifndef CMS_USE_BIG_ENDIAN\n\n    cmsUInt8Number* pIn  = (cmsUInt8Number*) QWord;\n    cmsUInt8Number* pOut = (cmsUInt8Number*) Result;\n\n    _cmsAssert(Result != NULL);\n\n    pOut[7] = pIn[0];\n    pOut[6] = pIn[1];\n    pOut[5] = pIn[2];\n    pOut[4] = pIn[3];\n    pOut[3] = pIn[4];\n    pOut[2] = pIn[5];\n    pOut[1] = pIn[6];\n    pOut[0] = pIn[7];\n\n#else\n    _cmsAssert(Result != NULL);\n\n#  ifdef CMS_DONT_USE_INT64\n    (*Result)[0] = (*QWord)[0];\n    (*Result)[1] = (*QWord)[1];\n#  else\n    *Result = *QWord;\n#  endif\n#endif\n}",
          "fn_code_pos": [
            [
              78,
              0
            ],
            [
              107,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAdjustEndianess64",
            "parameters": {
              "Result": "cmsUInt64Number",
              "QWord": "cmsUInt64Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT  _cmsReadUInt8Number(cmsIOHANDLER* io, cmsUInt8Number* n)\n{\n    cmsUInt8Number tmp;\n\n    _cmsAssert(io != NULL);\n\n    if (io -> Read(io, &tmp, sizeof(cmsUInt8Number), 1) != 1)\n            return FALSE;\n\n    if (n != NULL) *n = tmp;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              110,
              0
            ],
            [
              121,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadUInt8Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt8Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT  _cmsReadUInt16Number(cmsIOHANDLER* io, cmsUInt16Number* n)\n{\n    cmsUInt16Number tmp;\n\n    _cmsAssert(io != NULL);\n\n    if (io -> Read(io, &tmp, sizeof(cmsUInt16Number), 1) != 1)\n            return FALSE;\n\n    if (n != NULL) *n = _cmsAdjustEndianess16(tmp);\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              123,
              0
            ],
            [
              134,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadUInt16Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt16Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT  _cmsReadUInt16Array(cmsIOHANDLER* io, cmsUInt32Number n, cmsUInt16Number* Array)\n{\n    cmsUInt32Number i;\n\n    _cmsAssert(io != NULL);\n\n    for (i=0; i < n; i++) {\n\n        if (Array != NULL) {\n            if (!_cmsReadUInt16Number(io, Array + i)) return FALSE;\n        }\n        else {\n            if (!_cmsReadUInt16Number(io, NULL)) return FALSE;\n        }\n\n    }\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              136,
              0
            ],
            [
              153,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadUInt16Array",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt32Number",
              "Array": "cmsUInt16Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT  _cmsReadUInt32Number(cmsIOHANDLER* io, cmsUInt32Number* n)\n{\n    cmsUInt32Number tmp;\n\n    _cmsAssert(io != NULL);\n\n    if (io -> Read(io, &tmp, sizeof(cmsUInt32Number), 1) != 1)\n            return FALSE;\n\n    if (n != NULL) *n = _cmsAdjustEndianess32(tmp);\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              155,
              0
            ],
            [
              166,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadUInt32Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT  _cmsReadFloat32Number(cmsIOHANDLER* io, cmsFloat32Number* n)\n{\n    union typeConverter {\n        cmsUInt32Number integer;\n        cmsFloat32Number floating_point;\n    } tmp;\n\n    _cmsAssert(io != NULL);\n\n    if (io->Read(io, &tmp.integer, sizeof(cmsUInt32Number), 1) != 1)\n        return FALSE;\n\n    if (n != NULL) {\n\n        tmp.integer = _cmsAdjustEndianess32(tmp.integer);\n        *n = tmp.floating_point;\n\n        // Safeguard which covers against absurd values\n        if (*n > 1E+20 || *n < -1E+20) return FALSE;\n\n        #if defined(_MSC_VER) && _MSC_VER < 1800\n           return TRUE;\n        #elif defined (__BORLANDC__)\n           return TRUE;\n        #elif !defined(_MSC_VER) && (defined(__STDC_VERSION__) && __STDC_VERSION__ < 199901L)\n           return TRUE;\n        #else\n\n           // fpclassify() required by C99 (only provided by MSVC >= 1800, VS2013 onwards)\n           return ((fpclassify(*n) == FP_ZERO) || (fpclassify(*n) == FP_NORMAL));\n        #endif        \n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              168,
              0
            ],
            [
              202,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadFloat32Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsFloat32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT   _cmsReadUInt64Number(cmsIOHANDLER* io, cmsUInt64Number* n)\n{\n    cmsUInt64Number tmp;\n\n    _cmsAssert(io != NULL);\n\n    if (io -> Read(io, &tmp, sizeof(cmsUInt64Number), 1) != 1)\n            return FALSE;\n\n    if (n != NULL) {\n\n        _cmsAdjustEndianess64(n, &tmp);\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              205,
              0
            ],
            [
              220,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadUInt64Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT  _cmsRead15Fixed16Number(cmsIOHANDLER* io, cmsFloat64Number* n)\n{\n    cmsUInt32Number tmp;\n\n    _cmsAssert(io != NULL);\n\n    if (io -> Read(io, &tmp, sizeof(cmsUInt32Number), 1) != 1)\n            return FALSE;\n\n    if (n != NULL) {\n        *n = _cms15Fixed16toDouble((cmsS15Fixed16Number) _cmsAdjustEndianess32(tmp));\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              223,
              0
            ],
            [
              237,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRead15Fixed16Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT  _cmsReadXYZNumber(cmsIOHANDLER* io, cmsCIEXYZ* XYZ)\n{\n    cmsEncodedXYZNumber xyz;\n\n    _cmsAssert(io != NULL);\n\n    if (io ->Read(io, &xyz, sizeof(cmsEncodedXYZNumber), 1) != 1) return FALSE;\n\n    if (XYZ != NULL) {\n\n        XYZ->X = _cms15Fixed16toDouble((cmsS15Fixed16Number) _cmsAdjustEndianess32((cmsUInt32Number) xyz.X));\n        XYZ->Y = _cms15Fixed16toDouble((cmsS15Fixed16Number) _cmsAdjustEndianess32((cmsUInt32Number) xyz.Y));\n        XYZ->Z = _cms15Fixed16toDouble((cmsS15Fixed16Number) _cmsAdjustEndianess32((cmsUInt32Number) xyz.Z));\n    }\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              240,
              0
            ],
            [
              255,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadXYZNumber",
            "parameters": {
              "io": "cmsIOHANDLER",
              "XYZ": "cmsCIEXYZ"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT  _cmsWriteUInt8Number(cmsIOHANDLER* io, cmsUInt8Number n)\n{\n    _cmsAssert(io != NULL);\n\n    if (io -> Write(io, sizeof(cmsUInt8Number), &n) != 1)\n            return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              257,
              0
            ],
            [
              265,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteUInt8Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt8Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT  _cmsWriteUInt16Number(cmsIOHANDLER* io, cmsUInt16Number n)\n{\n    cmsUInt16Number tmp;\n\n    _cmsAssert(io != NULL);\n\n    tmp = _cmsAdjustEndianess16(n);\n    if (io -> Write(io, sizeof(cmsUInt16Number), &tmp) != 1)\n            return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              267,
              0
            ],
            [
              278,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteUInt16Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt16Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT  _cmsWriteUInt16Array(cmsIOHANDLER* io, cmsUInt32Number n, const cmsUInt16Number* Array)\n{\n    cmsUInt32Number i;\n\n    _cmsAssert(io != NULL);\n    _cmsAssert(Array != NULL);\n\n    for (i=0; i < n; i++) {\n        if (!_cmsWriteUInt16Number(io, Array[i])) return FALSE;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              280,
              0
            ],
            [
              292,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteUInt16Array",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt32Number",
              "Array": "cmsUInt16Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT  _cmsWriteUInt32Number(cmsIOHANDLER* io, cmsUInt32Number n)\n{\n    cmsUInt32Number tmp;\n\n    _cmsAssert(io != NULL);\n\n    tmp = _cmsAdjustEndianess32(n);\n    if (io -> Write(io, sizeof(cmsUInt32Number), &tmp) != 1)\n            return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              294,
              0
            ],
            [
              305,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteUInt32Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT  _cmsWriteFloat32Number(cmsIOHANDLER* io, cmsFloat32Number n)\n{\n    union typeConverter {\n        cmsUInt32Number integer;\n        cmsFloat32Number floating_point;\n    } tmp;\n\n    tmp.floating_point = n;\n    tmp.integer = _cmsAdjustEndianess32(tmp.integer);\n    if (io -> Write(io, sizeof(cmsUInt32Number), &tmp.integer) != 1)\n            return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              308,
              0
            ],
            [
              321,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteFloat32Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsFloat32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT  _cmsWriteUInt64Number(cmsIOHANDLER* io, cmsUInt64Number* n)\n{\n    cmsUInt64Number tmp;\n\n    _cmsAssert(io != NULL);\n\n    _cmsAdjustEndianess64(&tmp, n);\n    if (io -> Write(io, sizeof(cmsUInt64Number), &tmp) != 1)\n            return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              323,
              0
            ],
            [
              334,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteUInt64Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT  _cmsWrite15Fixed16Number(cmsIOHANDLER* io, cmsFloat64Number n)\n{\n    cmsUInt32Number tmp;\n\n    _cmsAssert(io != NULL);\n\n    tmp = _cmsAdjustEndianess32((cmsUInt32Number) _cmsDoubleTo15Fixed16(n));\n    if (io -> Write(io, sizeof(cmsUInt32Number), &tmp) != 1)\n            return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              336,
              0
            ],
            [
              347,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWrite15Fixed16Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT  _cmsWriteXYZNumber(cmsIOHANDLER* io, const cmsCIEXYZ* XYZ)\n{\n    cmsEncodedXYZNumber xyz;\n\n    _cmsAssert(io != NULL);\n    _cmsAssert(XYZ != NULL);\n\n    xyz.X = (cmsS15Fixed16Number) _cmsAdjustEndianess32((cmsUInt32Number) _cmsDoubleTo15Fixed16(XYZ->X));\n    xyz.Y = (cmsS15Fixed16Number) _cmsAdjustEndianess32((cmsUInt32Number) _cmsDoubleTo15Fixed16(XYZ->Y));\n    xyz.Z = (cmsS15Fixed16Number) _cmsAdjustEndianess32((cmsUInt32Number) _cmsDoubleTo15Fixed16(XYZ->Z));\n\n    return io -> Write(io,  sizeof(cmsEncodedXYZNumber), &xyz);\n}",
          "fn_code_pos": [
            [
              349,
              0
            ],
            [
              361,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteXYZNumber",
            "parameters": {
              "io": "cmsIOHANDLER",
              "XYZ": "cmsCIEXYZ"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsFloat64Number CMSEXPORT _cms8Fixed8toDouble(cmsUInt16Number fixed8)\n{\n    return fixed8 / 256.0;\n}",
          "fn_code_pos": [
            [
              364,
              0
            ],
            [
              367,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cms8Fixed8toDouble",
            "parameters": {
              "fixed8": "cmsUInt16Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "cmsUInt16Number CMSEXPORT _cmsDoubleTo8Fixed8(cmsFloat64Number val)\n{\n    cmsS15Fixed16Number GammaFixed32 = _cmsDoubleTo15Fixed16(val);\n    return  (cmsUInt16Number) ((GammaFixed32 >> 8) & 0xFFFF);\n}",
          "fn_code_pos": [
            [
              369,
              0
            ],
            [
              373,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsDoubleTo8Fixed8",
            "parameters": {
              "val": "cmsFloat64Number"
            },
            "return_type": "cmsUInt16Number"
          }
        },
        {
          "fn_code": "cmsFloat64Number CMSEXPORT _cms15Fixed16toDouble(cmsS15Fixed16Number fix32)\n{\n    return fix32 / 65536.0;\n}",
          "fn_code_pos": [
            [
              376,
              0
            ],
            [
              379,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cms15Fixed16toDouble",
            "parameters": {
              "fix32": "cmsS15Fixed16Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "cmsS15Fixed16Number CMSEXPORT _cmsDoubleTo15Fixed16(cmsFloat64Number v)\n{\n    return ((cmsS15Fixed16Number) floor((v)*65536.0 + 0.5));\n}",
          "fn_code_pos": [
            [
              382,
              0
            ],
            [
              385,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsDoubleTo15Fixed16",
            "parameters": {
              "v": "cmsFloat64Number"
            },
            "return_type": "cmsS15Fixed16Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT _cmsDecodeDateTimeNumber(const cmsDateTimeNumber *Source, struct tm *Dest)\n{\n\n    _cmsAssert(Dest != NULL);\n    _cmsAssert(Source != NULL);\n\n    Dest->tm_sec   = _cmsAdjustEndianess16(Source->seconds);\n    Dest->tm_min   = _cmsAdjustEndianess16(Source->minutes);\n    Dest->tm_hour  = _cmsAdjustEndianess16(Source->hours);\n    Dest->tm_mday  = _cmsAdjustEndianess16(Source->day);\n    Dest->tm_mon   = _cmsAdjustEndianess16(Source->month) - 1;\n    Dest->tm_year  = _cmsAdjustEndianess16(Source->year) - 1900;\n    Dest->tm_wday  = -1;\n    Dest->tm_yday  = -1;\n    Dest->tm_isdst = 0;\n}",
          "fn_code_pos": [
            [
              389,
              0
            ],
            [
              404,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsDecodeDateTimeNumber",
            "parameters": {
              "Source": "cmsDateTimeNumber",
              "Dest": "struct tm"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT _cmsEncodeDateTimeNumber(cmsDateTimeNumber *Dest, const struct tm *Source)\n{\n    _cmsAssert(Dest != NULL);\n    _cmsAssert(Source != NULL);\n\n    Dest->seconds = _cmsAdjustEndianess16((cmsUInt16Number) Source->tm_sec);\n    Dest->minutes = _cmsAdjustEndianess16((cmsUInt16Number) Source->tm_min);\n    Dest->hours   = _cmsAdjustEndianess16((cmsUInt16Number) Source->tm_hour);\n    Dest->day     = _cmsAdjustEndianess16((cmsUInt16Number) Source->tm_mday);\n    Dest->month   = _cmsAdjustEndianess16((cmsUInt16Number) (Source->tm_mon + 1));\n    Dest->year    = _cmsAdjustEndianess16((cmsUInt16Number) (Source->tm_year + 1900));\n}",
          "fn_code_pos": [
            [
              406,
              0
            ],
            [
              417,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsEncodeDateTimeNumber",
            "parameters": {
              "Dest": "cmsDateTimeNumber",
              "Source": "struct tm"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsTagTypeSignature CMSEXPORT _cmsReadTypeBase(cmsIOHANDLER* io)\n{\n    _cmsTagBase Base;\n\n    _cmsAssert(io != NULL);\n\n    if (io -> Read(io, &Base, sizeof(_cmsTagBase), 1) != 1)\n        return (cmsTagTypeSignature) 0;\n\n    return (cmsTagTypeSignature) _cmsAdjustEndianess32(Base.sig);\n}",
          "fn_code_pos": [
            [
              420,
              0
            ],
            [
              430,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadTypeBase",
            "parameters": {
              "io": "cmsIOHANDLER"
            },
            "return_type": "cmsTagTypeSignature"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT _cmsWriteTypeBase(cmsIOHANDLER* io, cmsTagTypeSignature sig)\n{\n    _cmsTagBase  Base;\n\n    _cmsAssert(io != NULL);\n\n    Base.sig = (cmsTagTypeSignature) _cmsAdjustEndianess32(sig);\n    memset(&Base.reserved, 0, sizeof(Base.reserved));\n    return io -> Write(io, sizeof(_cmsTagBase), &Base);\n}",
          "fn_code_pos": [
            [
              433,
              0
            ],
            [
              442,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteTypeBase",
            "parameters": {
              "io": "cmsIOHANDLER",
              "sig": "cmsTagTypeSignature"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT _cmsReadAlignment(cmsIOHANDLER* io)\n{\n    cmsUInt8Number  Buffer[4];\n    cmsUInt32Number NextAligned, At;\n    cmsUInt32Number BytesToNextAlignedPos;\n\n    _cmsAssert(io != NULL);\n\n    At = io -> Tell(io);\n    NextAligned = _cmsALIGNLONG(At);\n    BytesToNextAlignedPos = NextAligned - At;\n    if (BytesToNextAlignedPos == 0) return TRUE;\n    if (BytesToNextAlignedPos > 4)  return FALSE;\n\n    return (io ->Read(io, Buffer, BytesToNextAlignedPos, 1) == 1);\n}",
          "fn_code_pos": [
            [
              444,
              0
            ],
            [
              459,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadAlignment",
            "parameters": {
              "io": "cmsIOHANDLER"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT _cmsWriteAlignment(cmsIOHANDLER* io)\n{\n    cmsUInt8Number  Buffer[4];\n    cmsUInt32Number NextAligned, At;\n    cmsUInt32Number BytesToNextAlignedPos;\n\n    _cmsAssert(io != NULL);\n\n    At = io -> Tell(io);\n    NextAligned = _cmsALIGNLONG(At);\n    BytesToNextAlignedPos = NextAligned - At;\n    if (BytesToNextAlignedPos == 0) return TRUE;\n    if (BytesToNextAlignedPos > 4)  return FALSE;\n\n    memset(Buffer, 0, BytesToNextAlignedPos);\n    return io -> Write(io, BytesToNextAlignedPos, Buffer);\n}",
          "fn_code_pos": [
            [
              461,
              0
            ],
            [
              477,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteAlignment",
            "parameters": {
              "io": "cmsIOHANDLER"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT _cmsIOPrintf(cmsIOHANDLER* io, const char* frm, ...)\n{\n    va_list args;\n    int len;\n    cmsUInt8Number Buffer[2048];\n    cmsBool rc;\n    cmsUInt8Number* ptr;\n\n    _cmsAssert(io != NULL);\n    _cmsAssert(frm != NULL);\n\n    va_start(args, frm);\n\n    len = vsnprintf((char*) Buffer, 2047, frm, args);\n    if (len < 0) {\n        va_end(args);\n        return FALSE;   // Truncated, which is a fatal error for us\n    }\n\n    // setlocale may be active, no commas are needed in PS generator\n    // and PS generator is our only client\n    for (ptr = Buffer; *ptr; ptr++)\n    {\n        if (*ptr == ',') *ptr = '.';\n    }\n\n    rc = io ->Write(io, (cmsUInt32Number) len, Buffer);\n\n    va_end(args);\n\n    return rc;\n}",
          "fn_code_pos": [
            [
              481,
              0
            ],
            [
              512,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsIOPrintf",
            "parameters": {
              "io": "cmsIOHANDLER",
              "frm": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "void* _cmsPluginMalloc(cmsContext ContextID, cmsUInt32Number size)\n{\n    struct _cmsContext_struct* ctx = _cmsGetContext(ContextID);\n\n    if (ctx ->MemPool == NULL) {\n\n        if (ContextID == NULL) {\n\n            ctx->MemPool = _cmsCreateSubAlloc(0, 2*1024);\n            if (ctx->MemPool == NULL) return NULL;\n        }\n        else {\n            cmsSignalError(ContextID, cmsERROR_CORRUPTION_DETECTED, \"NULL memory pool on context\");\n            return NULL;\n        }\n    }\n\n    return _cmsSubAlloc(ctx->MemPool, size);\n}",
          "fn_code_pos": [
            [
              518,
              0
            ],
            [
              536,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsPluginMalloc",
            "parameters": {
              "ContextID": "cmsContext",
              "size": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsPlugin(void* Plug_in)\n{\n    return cmsPluginTHR(NULL, Plug_in);\n}",
          "fn_code_pos": [
            [
              540,
              0
            ],
            [
              543,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPlugin",
            "parameters": {
              "Plug_in": "void"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsPluginTHR(cmsContext id, void* Plug_in)\n{\n    cmsPluginBase* Plugin;\n\n    for (Plugin = (cmsPluginBase*) Plug_in;\n         Plugin != NULL;\n         Plugin = Plugin -> Next) {\n\n            if (Plugin -> Magic != cmsPluginMagicNumber) {\n                cmsSignalError(id, cmsERROR_UNKNOWN_EXTENSION, \"Unrecognized plugin\");\n                return FALSE;\n            }\n\n            if (Plugin ->ExpectedVersion > LCMS_VERSION) {\n                cmsSignalError(id, cmsERROR_UNKNOWN_EXTENSION, \"plugin needs Little CMS %d, current version is %d\",\n                    Plugin ->ExpectedVersion, LCMS_VERSION);\n                return FALSE;\n            }\n\n            switch (Plugin -> Type) {\n\n                case cmsPluginMemHandlerSig:\n                    if (!_cmsRegisterMemHandlerPlugin(id, Plugin)) return FALSE;\n                    break;\n\n                case cmsPluginInterpolationSig:\n                    if (!_cmsRegisterInterpPlugin(id, Plugin)) return FALSE;\n                    break;\n\n                case cmsPluginTagTypeSig:\n                    if (!_cmsRegisterTagTypePlugin(id, Plugin)) return FALSE;\n                    break;\n\n                case cmsPluginTagSig:\n                    if (!_cmsRegisterTagPlugin(id, Plugin)) return FALSE;\n                    break;\n\n                case cmsPluginFormattersSig:\n                    if (!_cmsRegisterFormattersPlugin(id, Plugin)) return FALSE;\n                    break;\n\n                case cmsPluginRenderingIntentSig:\n                    if (!_cmsRegisterRenderingIntentPlugin(id, Plugin)) return FALSE;\n                    break;\n\n                case cmsPluginParametricCurveSig:\n                    if (!_cmsRegisterParametricCurvesPlugin(id, Plugin)) return FALSE;\n                    break;\n\n                case cmsPluginMultiProcessElementSig:\n                    if (!_cmsRegisterMultiProcessElementPlugin(id, Plugin)) return FALSE;\n                    break;\n\n                case cmsPluginOptimizationSig:\n                    if (!_cmsRegisterOptimizationPlugin(id, Plugin)) return FALSE;\n                    break;\n\n                case cmsPluginTransformSig:\n                    if (!_cmsRegisterTransformPlugin(id, Plugin)) return FALSE;\n                    break;\n\n                case cmsPluginMutexSig:\n                    if (!_cmsRegisterMutexPlugin(id, Plugin)) return FALSE;\n                    break;\n\n                case cmsPluginParalellizationSig:\n                    if (!_cmsRegisterParallelizationPlugin(id, Plugin)) return FALSE;\n                    break;\n\n                default:\n                    cmsSignalError(id, cmsERROR_UNKNOWN_EXTENSION, \"Unrecognized plugin type '%X'\", Plugin -> Type);\n                    return FALSE;\n            }\n    }\n\n    // Keep a reference to the plug-in\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              545,
              0
            ],
            [
              622,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPluginTHR",
            "parameters": {
              "id": "cmsContext",
              "Plug_in": "void"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsUnregisterPlugins(void)\n{\n    cmsUnregisterPluginsTHR(NULL);\n}",
          "fn_code_pos": [
            [
              626,
              0
            ],
            [
              629,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsUnregisterPlugins",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool InitContextMutex(void)\n{\n    // See the comments regarding locking in lcms2_internal.h\n    // for an explanation of why we need the following code.\n#ifndef CMS_NO_PTHREADS\n#ifdef CMS_IS_WINDOWS_\n#ifndef CMS_RELY_ON_WINDOWS_STATIC_MUTEX_INIT\n\n    static cmsBool already_initialized = FALSE;\n\n    if (!already_initialized)\n    {\n        static HANDLE _cmsWindowsInitMutex = NULL;\n        static volatile HANDLE* mutex = &_cmsWindowsInitMutex;\n\n        if (*mutex == NULL)\n        {\n            HANDLE p = CreateMutex(NULL, FALSE, NULL);\n            if (p && InterlockedCompareExchangePointer((void**)mutex, (void*)p, NULL) != NULL)\n                CloseHandle(p);\n        }\n        if (*mutex == NULL || WaitForSingleObject(*mutex, INFINITE) == WAIT_FAILED)\n        {\n            cmsSignalError(0, cmsERROR_INTERNAL, \"Mutex lock failed\");\n            return FALSE;\n        }\n        if (((void**)&_cmsContextPoolHeadMutex)[0] == NULL)\n            InitializeCriticalSection(&_cmsContextPoolHeadMutex);\n        if (*mutex == NULL || !ReleaseMutex(*mutex))\n        {\n            cmsSignalError(0, cmsERROR_INTERNAL, \"Mutex unlock failed\");\n            return FALSE;\n        }\n        already_initialized = TRUE;\n    }\n#endif\n#endif\n#endif\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              667,
              0
            ],
            [
              708,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "InitContextMutex",
            "parameters": {},
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "struct _cmsContext_struct* _cmsGetContext(cmsContext ContextID)\n{\n    struct _cmsContext_struct* id = (struct _cmsContext_struct*) ContextID;\n    struct _cmsContext_struct* ctx;\n\n    // On 0, use global settings\n    if (id == NULL) \n        return &globalContext;\n\n    InitContextMutex();\n\n    // Search\n    _cmsEnterCriticalSectionPrimitive(&_cmsContextPoolHeadMutex);\n\n    for (ctx = _cmsContextPoolHead;\n         ctx != NULL;\n         ctx = ctx ->Next) {\n\n            // Found it?\n        if (id == ctx)\n        {\n            _cmsLeaveCriticalSectionPrimitive(&_cmsContextPoolHeadMutex);\n            return ctx; // New-style context\n        }\n    }\n\n    _cmsLeaveCriticalSectionPrimitive(&_cmsContextPoolHeadMutex);\n    return &globalContext;\n}",
          "fn_code_pos": [
            [
              713,
              0
            ],
            [
              741,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetContext",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void* _cmsContextGetClientChunk(cmsContext ContextID, _cmsMemoryClient mc)\n{\n    struct _cmsContext_struct* ctx;\n    void *ptr;\n\n    if ((int) mc < 0 || mc >= MemoryClientMax) {\n        \n           cmsSignalError(ContextID, cmsERROR_INTERNAL, \"Bad context client -- possible corruption\");\n\n           // This is catastrophic. Should never reach here\n           _cmsAssert(0);\n\n           // Reverts to global context\n           return globalContext.chunks[UserPtr];\n    }\n    \n    ctx = _cmsGetContext(ContextID);\n    ptr = ctx ->chunks[mc];\n\n    if (ptr != NULL)\n        return ptr;\n\n    // A null ptr means no special settings for that context, and this \n    // reverts to Context0 globals\n    return globalContext.chunks[mc];    \n}",
          "fn_code_pos": [
            [
              746,
              0
            ],
            [
              771,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsContextGetClientChunk",
            "parameters": {
              "ContextID": "cmsContext",
              "mc": "_cmsMemoryClient"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsUnregisterPluginsTHR(cmsContext ContextID)\n{    \n    _cmsRegisterMemHandlerPlugin(ContextID, NULL);\n    _cmsRegisterInterpPlugin(ContextID, NULL);\n    _cmsRegisterTagTypePlugin(ContextID, NULL);\n    _cmsRegisterTagPlugin(ContextID, NULL);\n    _cmsRegisterFormattersPlugin(ContextID, NULL);\n    _cmsRegisterRenderingIntentPlugin(ContextID, NULL);\n    _cmsRegisterParametricCurvesPlugin(ContextID, NULL);\n    _cmsRegisterMultiProcessElementPlugin(ContextID, NULL);\n    _cmsRegisterOptimizationPlugin(ContextID, NULL);\n    _cmsRegisterTransformPlugin(ContextID, NULL);    \n    _cmsRegisterMutexPlugin(ContextID, NULL);\n    _cmsRegisterParallelizationPlugin(ContextID, NULL);\n\n}",
          "fn_code_pos": [
            [
              779,
              0
            ],
            [
              794,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsUnregisterPluginsTHR",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsPluginMemHandler* _cmsFindMemoryPlugin(void* PluginBundle)\n{\n    cmsPluginBase* Plugin;\n\n    for (Plugin = (cmsPluginBase*) PluginBundle;\n        Plugin != NULL;\n        Plugin = Plugin -> Next) {\n\n            if (Plugin -> Magic == cmsPluginMagicNumber && \n                Plugin -> ExpectedVersion <= LCMS_VERSION && \n                Plugin -> Type == cmsPluginMemHandlerSig) {\n\n                    // Found!\n                    return (cmsPluginMemHandler*) Plugin;  \n            }\n    }\n\n    // Nope, revert to defaults \n    return NULL;\n}",
          "fn_code_pos": [
            [
              798,
              0
            ],
            [
              818,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsFindMemoryPlugin",
            "parameters": {
              "PluginBundle": "void"
            },
            "return_type": "cmsPluginMemHandler"
          }
        },
        {
          "fn_code": "cmsContext CMSEXPORT cmsCreateContext(void* Plugin, void* UserData)\n{\n    struct _cmsContext_struct* ctx;\n    struct _cmsContext_struct  fakeContext;\n        \n    if (!InitContextMutex()) return NULL;\n\n    _cmsInstallAllocFunctions(_cmsFindMemoryPlugin(Plugin), &fakeContext.DefaultMemoryManager);\n    \n    fakeContext.chunks[UserPtr]     = UserData;\n    fakeContext.chunks[MemPlugin]   = &fakeContext.DefaultMemoryManager;\n\n    // Create the context structure.\n    ctx = (struct _cmsContext_struct*) _cmsMalloc(&fakeContext, sizeof(struct _cmsContext_struct));\n    if (ctx == NULL)   \n        return NULL;     // Something very wrong happened!\n\n    // Init the structure and the memory manager\n    memset(ctx, 0, sizeof(struct _cmsContext_struct));\n\n    // Keep memory manager\n    memcpy(&ctx->DefaultMemoryManager, &fakeContext.DefaultMemoryManager, sizeof(_cmsMemPluginChunk)); \n   \n    // Maintain the linked list (with proper locking)\n    _cmsEnterCriticalSectionPrimitive(&_cmsContextPoolHeadMutex);\n       ctx ->Next = _cmsContextPoolHead;\n       _cmsContextPoolHead = ctx;\n    _cmsLeaveCriticalSectionPrimitive(&_cmsContextPoolHeadMutex);\n\n    ctx ->chunks[UserPtr]     = UserData;\n    ctx ->chunks[MemPlugin]   = &ctx->DefaultMemoryManager;\n   \n    // Now we can allocate the pool by using default memory manager\n    ctx ->MemPool = _cmsCreateSubAlloc(ctx, 22 * sizeof(void*));  // default size about 22 pointers\n    if (ctx ->MemPool == NULL) {\n\n         cmsDeleteContext(ctx);\n        return NULL;\n    }\n\n    _cmsAllocLogErrorChunk(ctx, NULL);\n    _cmsAllocAlarmCodesChunk(ctx, NULL);\n    _cmsAllocAdaptationStateChunk(ctx, NULL);\n    _cmsAllocMemPluginChunk(ctx, NULL);\n    _cmsAllocInterpPluginChunk(ctx, NULL);\n    _cmsAllocCurvesPluginChunk(ctx, NULL);\n    _cmsAllocFormattersPluginChunk(ctx, NULL);\n    _cmsAllocTagTypePluginChunk(ctx, NULL);\n    _cmsAllocMPETypePluginChunk(ctx, NULL);\n    _cmsAllocTagPluginChunk(ctx, NULL);\n    _cmsAllocIntentsPluginChunk(ctx, NULL);\n    _cmsAllocOptimizationPluginChunk(ctx, NULL);\n    _cmsAllocTransformPluginChunk(ctx, NULL);\n    _cmsAllocMutexPluginChunk(ctx, NULL);\n    _cmsAllocParallelizationPluginChunk(ctx, NULL);\n\n    // Setup the plug-ins\n    if (!cmsPluginTHR(ctx, Plugin)) {\n    \n        cmsDeleteContext(ctx);\n        return NULL;\n    }\n\n    return (cmsContext) ctx;  \n}",
          "fn_code_pos": [
            [
              823,
              0
            ],
            [
              887,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateContext",
            "parameters": {
              "Plugin": "void",
              "UserData": "void"
            },
            "return_type": "cmsContext"
          }
        },
        {
          "fn_code": "cmsContext CMSEXPORT cmsDupContext(cmsContext ContextID, void* NewUserData)\n{\n    int i;\n    struct _cmsContext_struct* ctx;\n    const struct _cmsContext_struct* src = _cmsGetContext(ContextID);\n\n    void* userData = (NewUserData != NULL) ? NewUserData : src -> chunks[UserPtr];\n    \n    \n    ctx = (struct _cmsContext_struct*) _cmsMalloc(ContextID, sizeof(struct _cmsContext_struct));\n    if (ctx == NULL)   \n        return NULL;     // Something very wrong happened\n\n    if (!InitContextMutex()) return NULL;\n\n    // Setup default memory allocators\n    memcpy(&ctx->DefaultMemoryManager, &src->DefaultMemoryManager, sizeof(ctx->DefaultMemoryManager));\n\n    // Maintain the linked list\n    _cmsEnterCriticalSectionPrimitive(&_cmsContextPoolHeadMutex);\n       ctx ->Next = _cmsContextPoolHead;\n       _cmsContextPoolHead = ctx;\n    _cmsLeaveCriticalSectionPrimitive(&_cmsContextPoolHeadMutex);\n\n    ctx ->chunks[UserPtr]    = userData;\n    ctx ->chunks[MemPlugin]  = &ctx->DefaultMemoryManager;\n\n    ctx ->MemPool = _cmsCreateSubAlloc(ctx, 22 * sizeof(void*));\n    if (ctx ->MemPool == NULL) {\n\n         cmsDeleteContext(ctx);\n        return NULL;\n    }\n\n    // Allocate all required chunks.\n    _cmsAllocLogErrorChunk(ctx, src);\n    _cmsAllocAlarmCodesChunk(ctx, src);\n    _cmsAllocAdaptationStateChunk(ctx, src);\n    _cmsAllocMemPluginChunk(ctx, src);\n    _cmsAllocInterpPluginChunk(ctx, src);\n    _cmsAllocCurvesPluginChunk(ctx, src);\n    _cmsAllocFormattersPluginChunk(ctx, src);\n    _cmsAllocTagTypePluginChunk(ctx, src);\n    _cmsAllocMPETypePluginChunk(ctx, src);\n    _cmsAllocTagPluginChunk(ctx, src);\n    _cmsAllocIntentsPluginChunk(ctx, src);\n    _cmsAllocOptimizationPluginChunk(ctx, src);\n    _cmsAllocTransformPluginChunk(ctx, src);\n    _cmsAllocMutexPluginChunk(ctx, src);\n    _cmsAllocParallelizationPluginChunk(ctx, src);\n\n    // Make sure no one failed\n    for (i=Logger; i < MemoryClientMax; i++) {\n\n        if (src ->chunks[i] == NULL) {\n            cmsDeleteContext((cmsContext) ctx);\n            return NULL;\n        }\n    }\n\n    return (cmsContext) ctx;\n}",
          "fn_code_pos": [
            [
              892,
              0
            ],
            [
              953,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDupContext",
            "parameters": {
              "ContextID": "cmsContext",
              "NewUserData": "void"
            },
            "return_type": "cmsContext"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsDeleteContext(cmsContext ContextID)\n{\n    if (ContextID == NULL) {\n\n        cmsUnregisterPlugins();\n        if (globalContext.MemPool != NULL)\n            _cmsSubAllocDestroy(globalContext.MemPool);\n        globalContext.MemPool = NULL;\n    }\n    else {\n\n        struct _cmsContext_struct* ctx = (struct _cmsContext_struct*) ContextID;              \n        struct _cmsContext_struct  fakeContext;  \n        struct _cmsContext_struct* prev;\n\n\n        InitContextMutex();\n\n        memcpy(&fakeContext.DefaultMemoryManager, &ctx->DefaultMemoryManager, sizeof(ctx->DefaultMemoryManager));\n\n        fakeContext.chunks[UserPtr]     = ctx ->chunks[UserPtr];\n        fakeContext.chunks[MemPlugin]   = &fakeContext.DefaultMemoryManager;\n\n        // Get rid of plugins\n        cmsUnregisterPluginsTHR(ContextID); \n\n        // Since all memory is allocated in the private pool, all what we need to do is destroy the pool\n        if (ctx -> MemPool != NULL)\n              _cmsSubAllocDestroy(ctx ->MemPool);\n        ctx -> MemPool = NULL;\n\n        // Maintain list\n        _cmsEnterCriticalSectionPrimitive(&_cmsContextPoolHeadMutex);\n        if (_cmsContextPoolHead == ctx) { \n\n            _cmsContextPoolHead = ctx->Next;\n        }\n        else {\n\n            // Search for previous\n            for (prev = _cmsContextPoolHead; \n                 prev != NULL;\n                 prev = prev ->Next)\n            {\n                if (prev -> Next == ctx) {\n                    prev -> Next = ctx ->Next;\n                    break;\n                }\n            }\n        }\n        _cmsLeaveCriticalSectionPrimitive(&_cmsContextPoolHeadMutex);\n\n        // free the memory block itself\n        _cmsFree(&fakeContext, ctx);\n    }\n}",
          "fn_code_pos": [
            [
              959,
              0
            ],
            [
              1014,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDeleteContext",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void* CMSEXPORT cmsGetContextUserData(cmsContext ContextID)\n{\n    return _cmsContextGetClientChunk(ContextID, UserPtr);\n}",
          "fn_code_pos": [
            [
              1017,
              0
            ],
            [
              1020,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetContextUserData",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool _cmsGetTime(struct tm* ptr_time)\n{\n    struct tm* t;\n#if defined(HAVE_GMTIME_R) || defined(HAVE_GMTIME_S)\n    struct tm tm;\n#endif\n\n    time_t now = time(NULL);\n\n#ifdef HAVE_GMTIME_R\n    t = gmtime_r(&now, &tm);\n#elif defined(HAVE_GMTIME_S)\n    t = gmtime_s(&tm, &now) == 0 ? &tm : NULL;\n#else\n    if (!InitContextMutex()) return FALSE;\n\n    _cmsEnterCriticalSectionPrimitive(&_cmsContextPoolHeadMutex);\n    t = gmtime(&now);\n    _cmsLeaveCriticalSectionPrimitive(&_cmsContextPoolHeadMutex);\n#endif\n\n    if (t == NULL) \n        return FALSE;\n    else {\n        *ptr_time = *t;\n        return TRUE;\n    }\n}",
          "fn_code_pos": [
            [
              1024,
              0
            ],
            [
              1051,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTime",
            "parameters": {
              "ptr_time": "struct tm"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "_cmsPluginMalloc(cmsContext ContextID, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              518,
              6
            ],
            [
              518,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsPluginMalloc",
            "parameters": {
              "ContextID": "cmsContext",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsGetContext(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              713,
              27
            ],
            [
              713,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetContext",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsContextGetClientChunk(cmsContext ContextID, _cmsMemoryClient mc)",
          "fn_dec_pos": [
            [
              746,
              6
            ],
            [
              746,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsContextGetClientChunk",
            "parameters": {
              "ContextID": "cmsContext",
              "mc": "_cmsMemoryClient"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsFindMemoryPlugin(void* PluginBundle)",
          "fn_dec_pos": [
            [
              799,
              21
            ],
            [
              799,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsFindMemoryPlugin",
            "parameters": {
              "PluginBundle": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsGetContextUserData(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              1017,
              16
            ],
            [
              1017,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetContextUserData",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct tm",
          {},
          "",
          [
            389,
            73
          ],
          [
            389,
            82
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            406,
            71
          ],
          [
            406,
            80
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            520,
            4
          ],
          [
            520,
            29
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            634,
            7
          ],
          [
            634,
            32
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            663,
            7
          ],
          [
            663,
            32
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            713,
            0
          ],
          [
            713,
            25
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            715,
            4
          ],
          [
            715,
            29
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            715,
            37
          ],
          [
            715,
            62
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            716,
            4
          ],
          [
            716,
            29
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            748,
            4
          ],
          [
            748,
            29
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            825,
            4
          ],
          [
            825,
            29
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            826,
            4
          ],
          [
            826,
            29
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            836,
            11
          ],
          [
            836,
            36
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            836,
            71
          ],
          [
            836,
            96
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            841,
            26
          ],
          [
            841,
            51
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            895,
            4
          ],
          [
            895,
            29
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            896,
            10
          ],
          [
            896,
            35
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            901,
            11
          ],
          [
            901,
            36
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            901,
            68
          ],
          [
            901,
            93
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            970,
            8
          ],
          [
            970,
            33
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            970,
            42
          ],
          [
            970,
            67
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            971,
            8
          ],
          [
            971,
            33
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            972,
            8
          ],
          [
            972,
            33
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            1024,
            20
          ],
          [
            1024,
            29
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            1026,
            4
          ],
          [
            1026,
            13
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            1028,
            4
          ],
          [
            1028,
            13
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmsgmt.c": {
      "fn_def_list": [
        {
          "fn_code": "cmsHTRANSFORM _cmsChain2Lab(cmsContext            ContextID,\n                            cmsUInt32Number        nProfiles,\n                            cmsUInt32Number        InputFormat,\n                            cmsUInt32Number        OutputFormat,\n                            const cmsUInt32Number  Intents[],\n                            const cmsHPROFILE      hProfiles[],\n                            const cmsBool          BPC[],\n                            const cmsFloat64Number AdaptationStates[],\n                            cmsUInt32Number        dwFlags)\n{\n    cmsHTRANSFORM xform;\n    cmsHPROFILE   hLab;\n    cmsHPROFILE   ProfileList[256];\n    cmsBool       BPCList[256];\n    cmsFloat64Number AdaptationList[256];\n    cmsUInt32Number IntentList[256];\n    cmsUInt32Number i;\n\n    // This is a rather big number and there is no need of dynamic memory\n    // since we are adding a profile, 254 + 1 = 255 and this is the limit\n    if (nProfiles > 254) return NULL;\n\n    // The output space\n    hLab = cmsCreateLab4ProfileTHR(ContextID, NULL);\n    if (hLab == NULL) return NULL;\n\n    // Create a copy of parameters\n    for (i=0; i < nProfiles; i++) {\n\n        ProfileList[i]    = hProfiles[i];\n        BPCList[i]        = BPC[i];\n        AdaptationList[i] = AdaptationStates[i];\n        IntentList[i]     = Intents[i];\n    }\n\n    // Place Lab identity at chain's end.\n    ProfileList[nProfiles]    = hLab;\n    BPCList[nProfiles]        = 0;\n    AdaptationList[nProfiles] = 1.0;\n    IntentList[nProfiles]     = INTENT_RELATIVE_COLORIMETRIC;\n\n    // Create the transform\n    xform = cmsCreateExtendedTransform(ContextID, nProfiles + 1, ProfileList,\n                                       BPCList,\n                                       IntentList,\n                                       AdaptationList,\n                                       NULL, 0,\n                                       InputFormat,\n                                       OutputFormat,\n                                       dwFlags);\n\n    cmsCloseProfile(hLab);\n\n    return xform;\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              85,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsChain2Lab",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "Intents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsHTRANSFORM"
          }
        },
        {
          "fn_code": "static\ncmsToneCurve* ComputeKToLstar(cmsContext            ContextID,\n                               cmsUInt32Number       nPoints,\n                               cmsUInt32Number       nProfiles,\n                               const cmsUInt32Number Intents[],\n                               const cmsHPROFILE     hProfiles[],\n                               const cmsBool         BPC[],\n                               const cmsFloat64Number AdaptationStates[],\n                               cmsUInt32Number dwFlags)\n{\n    cmsToneCurve* out = NULL;\n    cmsUInt32Number i;\n    cmsHTRANSFORM xform;\n    cmsCIELab Lab;\n    cmsFloat32Number cmyk[4];\n    cmsFloat32Number* SampledPoints;\n\n    xform = _cmsChain2Lab(ContextID, nProfiles, TYPE_CMYK_FLT, TYPE_Lab_DBL, Intents, hProfiles, BPC, AdaptationStates, dwFlags);\n    if (xform == NULL) return NULL;\n\n    SampledPoints = (cmsFloat32Number*) _cmsCalloc(ContextID, nPoints, sizeof(cmsFloat32Number));\n    if (SampledPoints  == NULL) goto Error;\n\n    for (i=0; i < nPoints; i++) {\n\n        cmyk[0] = 0;\n        cmyk[1] = 0;\n        cmyk[2] = 0;\n        cmyk[3] = (cmsFloat32Number) ((i * 100.0) / (nPoints-1));\n\n        cmsDoTransform(xform, cmyk, &Lab, 1);\n        SampledPoints[i]= (cmsFloat32Number) (1.0 - Lab.L / 100.0); // Negate K for easier operation\n    }\n\n    out = cmsBuildTabulatedToneCurveFloat(ContextID, nPoints, SampledPoints);\n\nError:\n\n    cmsDeleteTransform(xform);\n    if (SampledPoints) _cmsFree(ContextID, SampledPoints);\n\n    return out;\n}",
          "fn_code_pos": [
            [
              90,
              0
            ],
            [
              132,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComputeKToLstar",
            "parameters": {
              "ContextID": "cmsContext",
              "nPoints": "cmsUInt32Number",
              "nProfiles": "cmsUInt32Number",
              "Intents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsToneCurve"
          }
        },
        {
          "fn_code": "cmsToneCurve* _cmsBuildKToneCurve(cmsContext        ContextID,\n                                   cmsUInt32Number   nPoints,\n                                   cmsUInt32Number   nProfiles,\n                                   const cmsUInt32Number Intents[],\n                                   const cmsHPROFILE hProfiles[],\n                                   const cmsBool     BPC[],\n                                   const cmsFloat64Number AdaptationStates[],\n                                   cmsUInt32Number   dwFlags)\n{\n    cmsToneCurve *in, *out, *KTone;\n\n    // Make sure CMYK -> CMYK\n    if (cmsGetColorSpace(hProfiles[0]) != cmsSigCmykData ||\n        cmsGetColorSpace(hProfiles[nProfiles-1])!= cmsSigCmykData) return NULL;\n\n\n    // Make sure last is an output profile\n    if (cmsGetDeviceClass(hProfiles[nProfiles - 1]) != cmsSigOutputClass) return NULL;\n\n    // Create individual curves. BPC works also as each K to L* is\n    // computed as a BPC to zero black point in case of L*\n    in  = ComputeKToLstar(ContextID, nPoints, nProfiles - 1, Intents, hProfiles, BPC, AdaptationStates, dwFlags);\n    if (in == NULL) return NULL;\n\n    out = ComputeKToLstar(ContextID, nPoints, 1,\n                            Intents + (nProfiles - 1),\n                            &hProfiles [nProfiles - 1],\n                            BPC + (nProfiles - 1),\n                            AdaptationStates + (nProfiles - 1),\n                            dwFlags);\n    if (out == NULL) {\n        cmsFreeToneCurve(in);\n        return NULL;\n    }\n\n    // Build the relationship. This effectively limits the maximum accuracy to 16 bits, but\n    // since this is used on black-preserving LUTs, we are not losing  accuracy in any case\n    KTone = cmsJoinToneCurve(ContextID, in, out, nPoints);\n\n    // Get rid of components\n    cmsFreeToneCurve(in); cmsFreeToneCurve(out);\n\n    // Something went wrong...\n    if (KTone == NULL) return NULL;\n\n    // Make sure it is monotonic\n    if (!cmsIsToneCurveMonotonic(KTone)) {\n        cmsFreeToneCurve(KTone);\n        return NULL;\n    }\n\n    return KTone;\n}",
          "fn_code_pos": [
            [
              138,
              0
            ],
            [
              190,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsBuildKToneCurve",
            "parameters": {
              "ContextID": "cmsContext",
              "nPoints": "cmsUInt32Number",
              "nProfiles": "cmsUInt32Number",
              "Intents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsToneCurve"
          }
        },
        {
          "fn_code": "static\nint GamutSampler(CMSREGISTER const cmsUInt16Number In[], CMSREGISTER cmsUInt16Number Out[], CMSREGISTER void* Cargo)\n{\n    GAMUTCHAIN*  t = (GAMUTCHAIN* ) Cargo;\n    cmsCIELab LabIn1, LabOut1;\n    cmsCIELab LabIn2, LabOut2;\n    cmsUInt16Number Proof[cmsMAXCHANNELS], Proof2[cmsMAXCHANNELS];\n    cmsFloat64Number dE1, dE2, ErrorRatio;\n\n    // Assume in-gamut by default. NEVER READ, USED FOR DEBUG PURPOSES.\n    ErrorRatio = 1.0;\n\n    // Convert input to Lab\n    cmsDoTransform(t -> hInput, In, &LabIn1, 1);\n\n    // converts from PCS to colorant. This always\n    // does return in-gamut values,\n    cmsDoTransform(t -> hForward, &LabIn1, Proof, 1);\n\n    // Now, do the inverse, from colorant to PCS.\n    cmsDoTransform(t -> hReverse, Proof, &LabOut1, 1);\n\n    memmove(&LabIn2, &LabOut1, sizeof(cmsCIELab));\n\n    // Try again, but this time taking Check as input\n    cmsDoTransform(t -> hForward, &LabOut1, Proof2, 1);\n    cmsDoTransform(t -> hReverse, Proof2, &LabOut2, 1);\n\n    // Take difference of direct value\n    dE1 = cmsDeltaE(&LabIn1, &LabOut1);\n\n    // Take difference of converted value\n    dE2 = cmsDeltaE(&LabIn2, &LabOut2);\n\n\n    // if dE1 is small and dE2 is small, value is likely to be in gamut\n    if (dE1 < t->Threshold && dE2 < t->Threshold)\n        Out[0] = 0;\n    else {\n\n        // if dE1 is small and dE2 is big, undefined. Assume in gamut\n        if (dE1 < t->Threshold && dE2 > t->Threshold)\n            Out[0] = 0;\n        else\n            // dE1 is big and dE2 is small, clearly out of gamut\n            if (dE1 > t->Threshold && dE2 < t->Threshold)\n                Out[0] = (cmsUInt16Number) _cmsQuickFloor((dE1 - t->Threshold) + .5);\n            else  {\n\n                // dE1 is big and dE2 is also big, could be due to perceptual mapping\n                // so take error ratio\n                if (dE2 == 0.0)\n                    ErrorRatio = dE1;\n                else\n                    ErrorRatio = dE1 / dE2;\n\n                if (ErrorRatio > t->Threshold)\n                    Out[0] = (cmsUInt16Number)  _cmsQuickFloor((ErrorRatio - t->Threshold) + .5);\n                else\n                    Out[0] = 0;\n            }\n    }\n\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              212,
              0
            ],
            [
              277,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GamutSampler",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "cmsPipeline* _cmsCreateGamutCheckPipeline(cmsContext ContextID,\n                                          cmsHPROFILE hProfiles[],\n                                          cmsBool  BPC[],\n                                          cmsUInt32Number Intents[],\n                                          cmsFloat64Number AdaptationStates[],\n                                          cmsUInt32Number nGamutPCSposition,\n                                          cmsHPROFILE hGamut)\n{\n    cmsHPROFILE hLab;\n    cmsPipeline* Gamut;\n    cmsStage* CLUT;\n    cmsUInt32Number dwFormat;\n    GAMUTCHAIN Chain;\n    cmsUInt32Number nGridpoints;\n    cmsInt32Number nChannels;\n    cmsColorSpaceSignature ColorSpace;\n    cmsUInt32Number i;\n    cmsHPROFILE ProfileList[256];\n    cmsBool     BPCList[256];\n    cmsFloat64Number AdaptationList[256];\n    cmsUInt32Number IntentList[256];\n\n    memset(&Chain, 0, sizeof(GAMUTCHAIN));\n\n\n    if (nGamutPCSposition <= 0 || nGamutPCSposition > 255) {\n        cmsSignalError(ContextID, cmsERROR_RANGE, \"Wrong position of PCS. 1..255 expected, %d found.\", nGamutPCSposition);\n        return NULL;\n    }\n\n    hLab = cmsCreateLab4ProfileTHR(ContextID, NULL);\n    if (hLab == NULL) return NULL;\n\n\n    // The figure of merit. On matrix-shaper profiles, should be almost zero as\n    // the conversion is pretty exact. On LUT based profiles, different resolutions\n    // of input and output CLUT may result in differences.\n\n    if (cmsIsMatrixShaper(hGamut)) {\n\n        Chain.Threshold = 1.0;\n    }\n    else {\n        Chain.Threshold = ERR_THRESHOLD;\n    }\n\n\n    // Create a copy of parameters\n    for (i=0; i < nGamutPCSposition; i++) {\n        ProfileList[i]    = hProfiles[i];\n        BPCList[i]        = BPC[i];\n        AdaptationList[i] = AdaptationStates[i];\n        IntentList[i]     = Intents[i];\n    }\n\n    // Fill Lab identity\n    ProfileList[nGamutPCSposition] = hLab;\n    BPCList[nGamutPCSposition] = 0;\n    AdaptationList[nGamutPCSposition] = 1.0;\n    IntentList[nGamutPCSposition] = INTENT_RELATIVE_COLORIMETRIC;\n\n\n    ColorSpace  = cmsGetColorSpace(hGamut);\n    nChannels   = cmsChannelsOfColorSpace(ColorSpace);\n    nGridpoints = _cmsReasonableGridpointsByColorspace(ColorSpace, cmsFLAGS_HIGHRESPRECALC);\n    dwFormat    = (CHANNELS_SH(nChannels)|BYTES_SH(2));\n\n    // 16 bits to Lab double\n    Chain.hInput = cmsCreateExtendedTransform(ContextID,\n        nGamutPCSposition + 1,\n        ProfileList,\n        BPCList,\n        IntentList,\n        AdaptationList,\n        NULL, 0,\n        dwFormat, TYPE_Lab_DBL,\n        cmsFLAGS_NOCACHE);\n\n\n    // Does create the forward step. Lab double to device\n    dwFormat    = (CHANNELS_SH(nChannels)|BYTES_SH(2));\n    Chain.hForward = cmsCreateTransformTHR(ContextID,\n        hLab, TYPE_Lab_DBL,\n        hGamut, dwFormat,\n        INTENT_RELATIVE_COLORIMETRIC,\n        cmsFLAGS_NOCACHE);\n\n    // Does create the backwards step\n    Chain.hReverse = cmsCreateTransformTHR(ContextID, hGamut, dwFormat,\n        hLab, TYPE_Lab_DBL,\n        INTENT_RELATIVE_COLORIMETRIC,\n        cmsFLAGS_NOCACHE);\n\n\n    // All ok?\n    if (Chain.hInput && Chain.hForward && Chain.hReverse) {\n\n        // Go on, try to compute gamut LUT from PCS. This consist on a single channel containing\n        // dE when doing a transform back and forth on the colorimetric intent.\n\n        Gamut = cmsPipelineAlloc(ContextID, 3, 1);\n        if (Gamut != NULL) {\n\n            CLUT = cmsStageAllocCLut16bit(ContextID, nGridpoints, nChannels, 1, NULL);\n            if (!cmsPipelineInsertStage(Gamut, cmsAT_BEGIN, CLUT)) {\n                cmsPipelineFree(Gamut);\n                Gamut = NULL;\n            } \n            else {\n                cmsStageSampleCLut16bit(CLUT, GamutSampler, (void*) &Chain, 0);\n            }\n        }\n    }\n    else\n        Gamut = NULL;   // Didn't work...\n\n    // Free all needed stuff.\n    if (Chain.hInput)   cmsDeleteTransform(Chain.hInput);\n    if (Chain.hForward) cmsDeleteTransform(Chain.hForward);\n    if (Chain.hReverse) cmsDeleteTransform(Chain.hReverse);\n    if (hLab) cmsCloseProfile(hLab);\n\n    // And return computed hull\n    return Gamut;\n}",
          "fn_code_pos": [
            [
              286,
              0
            ],
            [
              410,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsCreateGamutCheckPipeline",
            "parameters": {
              "ContextID": "cmsContext",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "Intents": "cmsUInt32Number",
              "AdaptationStates": "cmsFloat64Number",
              "nGamutPCSposition": "cmsUInt32Number",
              "hGamut": "cmsHPROFILE"
            },
            "return_type": "cmsPipeline"
          }
        },
        {
          "fn_code": "static\nint EstimateTAC(CMSREGISTER const cmsUInt16Number In[], CMSREGISTER cmsUInt16Number Out[], CMSREGISTER void * Cargo)\n{\n    cmsTACestimator* bp = (cmsTACestimator*) Cargo;\n    cmsFloat32Number RoundTrip[cmsMAXCHANNELS];\n    cmsUInt32Number i;\n    cmsFloat32Number Sum;\n\n\n    // Evaluate the xform\n    cmsDoTransform(bp->hRoundTrip, In, RoundTrip, 1);\n\n    // All all amounts of ink\n    for (Sum=0, i=0; i < bp ->nOutputChans; i++)\n            Sum += RoundTrip[i];\n\n    // If above maximum, keep track of input values\n    if (Sum > bp ->MaxTAC) {\n\n            bp ->MaxTAC = Sum;\n\n            for (i=0; i < bp ->nOutputChans; i++) {\n                bp ->MaxInput[i] = In[i];\n            }\n    }\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(Out);\n}",
          "fn_code_pos": [
            [
              425,
              0
            ],
            [
              454,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EstimateTAC",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "cmsFloat64Number CMSEXPORT cmsDetectTAC(cmsHPROFILE hProfile)\n{\n    cmsTACestimator bp;\n    cmsUInt32Number dwFormatter;\n    cmsUInt32Number GridPoints[MAX_INPUT_DIMENSIONS];\n    cmsHPROFILE hLab;\n    cmsContext ContextID = cmsGetProfileContextID(hProfile);\n\n    // TAC only works on output profiles\n    if (cmsGetDeviceClass(hProfile) != cmsSigOutputClass) {\n        return 0;\n    }\n\n    // Create a fake formatter for result\n    dwFormatter = cmsFormatterForColorspaceOfProfile(hProfile, 4, TRUE);\n\n    // Unsupported color space?\n    if (dwFormatter == 0) return 0;\n\n    bp.nOutputChans = T_CHANNELS(dwFormatter);\n    bp.MaxTAC = 0;    // Initial TAC is 0\n\n    //  for safety\n    if (bp.nOutputChans >= cmsMAXCHANNELS) return 0;\n\n    hLab = cmsCreateLab4ProfileTHR(ContextID, NULL);\n    if (hLab == NULL) return 0;\n    // Setup a roundtrip on perceptual intent in output profile for TAC estimation\n    bp.hRoundTrip = cmsCreateTransformTHR(ContextID, hLab, TYPE_Lab_16,\n                                          hProfile, dwFormatter, INTENT_PERCEPTUAL, cmsFLAGS_NOOPTIMIZE|cmsFLAGS_NOCACHE);\n\n    cmsCloseProfile(hLab);\n    if (bp.hRoundTrip == NULL) return 0;\n\n    // For L* we only need black and white. For C* we need many points\n    GridPoints[0] = 6;\n    GridPoints[1] = 74;\n    GridPoints[2] = 74;\n\n\n    if (!cmsSliceSpace16(3, GridPoints, EstimateTAC, &bp)) {\n        bp.MaxTAC = 0;\n    }\n\n    cmsDeleteTransform(bp.hRoundTrip);\n\n    // Results in %\n    return bp.MaxTAC;\n}",
          "fn_code_pos": [
            [
              458,
              0
            ],
            [
              506,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDetectTAC",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsDesaturateLab(cmsCIELab* Lab,\n                                   double amax, double amin,\n                                   double bmax, double bmin)\n{\n\n    // Whole Luma surface to zero\n\n    if (Lab -> L < 0) {\n\n        Lab-> L = Lab->a = Lab-> b = 0.0;\n        return FALSE;\n    }\n\n    // Clamp white, DISCARD HIGHLIGHTS. This is done\n    // in such way because icc spec doesn't allow the\n    // use of L>100 as a highlight means.\n\n    if (Lab->L > 100)\n        Lab -> L = 100;\n\n    // Check out gamut prism, on a, b faces\n\n    if (Lab -> a < amin || Lab->a > amax||\n        Lab -> b < bmin || Lab->b > bmax) {\n\n            cmsCIELCh LCh;\n            double h, slope;\n\n            // Falls outside a, b limits. Transports to LCh space,\n            // and then do the clipping\n\n\n            if (Lab -> a == 0.0) { // Is hue exactly 90?\n\n                // atan will not work, so clamp here\n                Lab -> b = Lab->b < 0 ? bmin : bmax;\n                return TRUE;\n            }\n\n            cmsLab2LCh(&LCh, Lab);\n\n            slope = Lab -> b / Lab -> a;\n            h = LCh.h;\n\n            // There are 4 zones\n\n            if ((h >= 0. && h < 45.) ||\n                (h >= 315 && h <= 360.)) {\n\n                    // clip by amax\n                    Lab -> a = amax;\n                    Lab -> b = amax * slope;\n            }\n            else\n                if (h >= 45. && h < 135.)\n                {\n                    // clip by bmax\n                    Lab -> b = bmax;\n                    Lab -> a = bmax / slope;\n                }\n                else\n                    if (h >= 135. && h < 225.) {\n                        // clip by amin\n                        Lab -> a = amin;\n                        Lab -> b = amin * slope;\n\n                    }\n                    else\n                        if (h >= 225. && h < 315.) {\n                            // clip by bmin\n                            Lab -> b = bmin;\n                            Lab -> a = bmin / slope;\n                        }\n                        else  {\n                            cmsSignalError(0, cmsERROR_RANGE, \"Invalid angle\");\n                            return FALSE;\n                        }\n\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              511,
              0
            ],
            [
              592,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDesaturateLab",
            "parameters": {
              "Lab": "cmsCIELab",
              "amax": "double",
              "amin": "double",
              "bmax": "double",
              "bmin": "double"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsFloat64Number CMSEXPORT cmsDetectRGBProfileGamma(cmsHPROFILE hProfile, cmsFloat64Number threshold)\n{\n    cmsContext ContextID;\n    cmsHPROFILE hXYZ;\n    cmsHTRANSFORM xform;\n    cmsToneCurve* Y_curve;\n    cmsUInt16Number rgb[256][3];\n    cmsCIEXYZ XYZ[256];\n    cmsFloat32Number Y_normalized[256];\n    cmsFloat64Number gamma;\n    cmsProfileClassSignature cl;\n    int i;\n\n    if (cmsGetColorSpace(hProfile) != cmsSigRgbData)\n        return -1;\n\n    cl = cmsGetDeviceClass(hProfile);\n    if (cl != cmsSigInputClass && cl != cmsSigDisplayClass && \n        cl != cmsSigOutputClass && cl != cmsSigColorSpaceClass)\n        return -1;\n\n    ContextID = cmsGetProfileContextID(hProfile);\n    hXYZ = cmsCreateXYZProfileTHR(ContextID);\n    if (hXYZ == NULL)\n        return -1;\n    xform = cmsCreateTransformTHR(ContextID, hProfile, TYPE_RGB_16, hXYZ, TYPE_XYZ_DBL, \n                                    INTENT_RELATIVE_COLORIMETRIC, cmsFLAGS_NOOPTIMIZE);\n\n    if (xform == NULL) { // If not RGB or forward direction is not supported, regret with the previous error\n\n        cmsCloseProfile(hXYZ);        \n        return -1;\n    }\n\n    for (i = 0; i < 256; i++) {\n        rgb[i][0] = rgb[i][1] = rgb[i][2] = FROM_8_TO_16(i);       \n    }\n\n    cmsDoTransform(xform, rgb, XYZ, 256);\n\n    cmsDeleteTransform(xform);\n    cmsCloseProfile(hXYZ);\n\n    for (i = 0; i < 256; i++) {\n        Y_normalized[i] = (cmsFloat32Number) XYZ[i].Y;\n    }\n\n    Y_curve = cmsBuildTabulatedToneCurveFloat(ContextID, 256, Y_normalized);\n    if (Y_curve == NULL)     \n        return -1;\n    \n    gamma = cmsEstimateGamma(Y_curve, threshold);\n\n    cmsFreeToneCurve(Y_curve);\n\n    return gamma;\n}",
          "fn_code_pos": [
            [
              601,
              0
            ],
            [
              657,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDetectRGBProfileGamma",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "threshold": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ComputeKToLstar(cmsContext            ContextID,\n                               cmsUInt32Number       nPoints,\n                               cmsUInt32Number       nProfiles,\n                               const cmsUInt32Number Intents[],\n                               const cmsHPROFILE     hProfiles[],\n                               const cmsBool         BPC[],\n                               const cmsFloat64Number AdaptationStates[],\n                               cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              91,
              14
            ],
            [
              98,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComputeKToLstar",
            "parameters": {
              "ContextID": "cmsContext",
              "nPoints": "cmsUInt32Number",
              "nProfiles": "cmsUInt32Number",
              "Intents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsBuildKToneCurve(cmsContext        ContextID,\n                                   cmsUInt32Number   nPoints,\n                                   cmsUInt32Number   nProfiles,\n                                   const cmsUInt32Number Intents[],\n                                   const cmsHPROFILE hProfiles[],\n                                   const cmsBool     BPC[],\n                                   const cmsFloat64Number AdaptationStates[],\n                                   cmsUInt32Number   dwFlags)",
          "fn_dec_pos": [
            [
              138,
              14
            ],
            [
              145,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsBuildKToneCurve",
            "parameters": {
              "ContextID": "cmsContext",
              "nPoints": "cmsUInt32Number",
              "nProfiles": "cmsUInt32Number",
              "Intents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsCreateGamutCheckPipeline(cmsContext ContextID,\n                                          cmsHPROFILE hProfiles[],\n                                          cmsBool  BPC[],\n                                          cmsUInt32Number Intents[],\n                                          cmsFloat64Number AdaptationStates[],\n                                          cmsUInt32Number nGamutPCSposition,\n                                          cmsHPROFILE hGamut)",
          "fn_dec_pos": [
            [
              286,
              13
            ],
            [
              292,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsCreateGamutCheckPipeline",
            "parameters": {
              "ContextID": "cmsContext",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "Intents": "cmsUInt32Number",
              "AdaptationStates": "cmsFloat64Number",
              "nGamutPCSposition": "cmsUInt32Number",
              "hGamut": "cmsHPROFILE"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\n    cmsHTRANSFORM hInput;               // From whatever input color space. 16 bits to DBL\n    cmsHTRANSFORM hForward, hReverse;   // Transforms going from Lab to colorant and back\n    cmsFloat64Number Threshold;         // The threshold after which is considered out of gamut\n\n    } GAMUTCHAIN;",
          {
            "hInput": "cmsHTRANSFORM",
            "hForward": "cmsHTRANSFORM",
            "Threshold": "cmsFloat64Number"
          },
          "GAMUTCHAIN",
          [
            197,
            0
          ],
          [
            203,
            17
          ]
        ],
        [
          "typedef struct {\n    cmsUInt32Number  nOutputChans;\n    cmsHTRANSFORM    hRoundTrip;\n    cmsFloat32Number MaxTAC;\n    cmsFloat32Number MaxInput[cmsMAXCHANNELS];\n\n} cmsTACestimator;",
          {
            "nOutputChans": "cmsUInt32Number",
            "hRoundTrip": "cmsHTRANSFORM",
            "MaxTAC": "cmsFloat32Number",
            "MaxInput[cmsMAXCHANNELS]": "cmsFloat32Number"
          },
          "cmsTACestimator",
          [
            414,
            0
          ],
          [
            420,
            18
          ]
        ],
        [
          "typedef struct {\n\n    cmsHTRANSFORM hInput;               // From whatever input color space. 16 bits to DBL\n    cmsHTRANSFORM hForward, hReverse;   // Transforms going from Lab to colorant and back\n    cmsFloat64Number Threshold;         // The threshold after which is considered out of gamut\n\n    } GAMUTCHAIN;",
          {
            "hInput": "cmsHTRANSFORM",
            "hForward": "cmsHTRANSFORM",
            "Threshold": "cmsFloat64Number"
          },
          "GAMUTCHAIN",
          [
            197,
            0
          ],
          [
            203,
            17
          ]
        ],
        [
          "typedef struct {\n    cmsUInt32Number  nOutputChans;\n    cmsHTRANSFORM    hRoundTrip;\n    cmsFloat32Number MaxTAC;\n    cmsFloat32Number MaxInput[cmsMAXCHANNELS];\n\n} cmsTACestimator;",
          {
            "nOutputChans": "cmsUInt32Number",
            "hRoundTrip": "cmsHTRANSFORM",
            "MaxTAC": "cmsFloat32Number",
            "MaxInput[cmsMAXCHANNELS]": "cmsFloat32Number"
          },
          "cmsTACestimator",
          [
            414,
            0
          ],
          [
            420,
            18
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmsopt.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nvoid _RemoveElement(cmsStage** head)\n{\n    cmsStage* mpe = *head;\n    cmsStage* next = mpe ->Next;\n    *head = next;\n    cmsStageFree(mpe);\n}",
          "fn_code_pos": [
            [
              107,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_RemoveElement",
            "parameters": {
              "head": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool _Remove1Op(cmsPipeline* Lut, cmsStageSignature UnaryOp)\n{\n    cmsStage** pt = &Lut ->Elements;\n    cmsBool AnyOpt = FALSE;\n\n    while (*pt != NULL) {\n\n        if ((*pt) ->Implements == UnaryOp) {\n            _RemoveElement(pt);\n            AnyOpt = TRUE;\n        }\n        else\n            pt = &((*pt) -> Next);\n    }\n\n    return AnyOpt;\n}",
          "fn_code_pos": [
            [
              117,
              0
            ],
            [
              134,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_Remove1Op",
            "parameters": {
              "Lut": "cmsPipeline",
              "UnaryOp": "cmsStageSignature"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool _Remove2Op(cmsPipeline* Lut, cmsStageSignature Op1, cmsStageSignature Op2)\n{\n    cmsStage** pt1;\n    cmsStage** pt2;\n    cmsBool AnyOpt = FALSE;\n\n    pt1 = &Lut ->Elements;\n    if (*pt1 == NULL) return AnyOpt;\n\n    while (*pt1 != NULL) {\n\n        pt2 = &((*pt1) -> Next);\n        if (*pt2 == NULL) return AnyOpt;\n\n        if ((*pt1) ->Implements == Op1 && (*pt2) ->Implements == Op2) {\n            _RemoveElement(pt2);\n            _RemoveElement(pt1);\n            AnyOpt = TRUE;\n        }\n        else\n            pt1 = &((*pt1) -> Next);\n    }\n\n    return AnyOpt;\n}",
          "fn_code_pos": [
            [
              137,
              0
            ],
            [
              162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_Remove2Op",
            "parameters": {
              "Lut": "cmsPipeline",
              "Op1": "cmsStageSignature",
              "Op2": "cmsStageSignature"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool CloseEnoughFloat(cmsFloat64Number a, cmsFloat64Number b)\n{\n       return fabs(b - a) < 0.00001f;\n}",
          "fn_code_pos": [
            [
              165,
              0
            ],
            [
              169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CloseEnoughFloat",
            "parameters": {
              "a": "cmsFloat64Number",
              "b": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool  isFloatMatrixIdentity(const cmsMAT3* a)\n{\n       cmsMAT3 Identity;\n       int i, j;\n\n       _cmsMAT3identity(&Identity);\n\n       for (i = 0; i < 3; i++)\n              for (j = 0; j < 3; j++)\n                     if (!CloseEnoughFloat(a->v[i].n[j], Identity.v[i].n[j])) return FALSE;\n\n       return TRUE;\n}",
          "fn_code_pos": [
            [
              171,
              0
            ],
            [
              184,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "isFloatMatrixIdentity",
            "parameters": {
              "a": "cmsMAT3"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool _MultiplyMatrix(cmsPipeline* Lut)\n{\n       cmsStage** pt1;\n       cmsStage** pt2;\n       cmsStage*  chain;\n       cmsBool AnyOpt = FALSE;\n\n       pt1 = &Lut->Elements;\n       if (*pt1 == NULL) return AnyOpt;\n\n       while (*pt1 != NULL) {\n\n              pt2 = &((*pt1)->Next);\n              if (*pt2 == NULL) return AnyOpt;\n\n              if ((*pt1)->Implements == cmsSigMatrixElemType && (*pt2)->Implements == cmsSigMatrixElemType) {\n\n                     // Get both matrices\n                     _cmsStageMatrixData* m1 = (_cmsStageMatrixData*) cmsStageData(*pt1);\n                     _cmsStageMatrixData* m2 = (_cmsStageMatrixData*) cmsStageData(*pt2);\n                     cmsMAT3 res;\n                     \n                     // Input offset and output offset should be zero to use this optimization\n                     if (m1->Offset != NULL || m2 ->Offset != NULL || \n                            cmsStageInputChannels(*pt1) != 3 || cmsStageOutputChannels(*pt1) != 3 ||                            \n                            cmsStageInputChannels(*pt2) != 3 || cmsStageOutputChannels(*pt2) != 3)\n                            return FALSE;\n\n                     // Multiply both matrices to get the result\n                     _cmsMAT3per(&res, (cmsMAT3*)m2->Double, (cmsMAT3*)m1->Double);\n\n                     // Get the next in chain after the matrices\n                     chain = (*pt2)->Next;\n\n                     // Remove both matrices\n                     _RemoveElement(pt2);\n                     _RemoveElement(pt1);\n\n                     // Now what if the result is a plain identity?                     \n                     if (!isFloatMatrixIdentity(&res)) {\n\n                            // We can not get rid of full matrix                            \n                            cmsStage* Multmat = cmsStageAllocMatrix(Lut->ContextID, 3, 3, (const cmsFloat64Number*) &res, NULL);\n                            if (Multmat == NULL) return FALSE;  // Should never happen\n\n                            // Recover the chain\n                            Multmat->Next = chain;\n                            *pt1 = Multmat;\n                     }\n\n                     AnyOpt = TRUE;\n              }\n              else\n                     pt1 = &((*pt1)->Next);\n       }\n\n       return AnyOpt;\n}",
          "fn_code_pos": [
            [
              187,
              0
            ],
            [
              245,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_MultiplyMatrix",
            "parameters": {
              "Lut": "cmsPipeline"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool PreOptimize(cmsPipeline* Lut)\n{\n    cmsBool AnyOpt = FALSE, Opt;\n\n    do {\n\n        Opt = FALSE;\n\n        // Remove all identities\n        Opt |= _Remove1Op(Lut, cmsSigIdentityElemType);\n\n        // Remove XYZ2Lab followed by Lab2XYZ\n        Opt |= _Remove2Op(Lut, cmsSigXYZ2LabElemType, cmsSigLab2XYZElemType);\n\n        // Remove Lab2XYZ followed by XYZ2Lab\n        Opt |= _Remove2Op(Lut, cmsSigLab2XYZElemType, cmsSigXYZ2LabElemType);\n\n        // Remove V4 to V2 followed by V2 to V4\n        Opt |= _Remove2Op(Lut, cmsSigLabV4toV2, cmsSigLabV2toV4);\n\n        // Remove V2 to V4 followed by V4 to V2\n        Opt |= _Remove2Op(Lut, cmsSigLabV2toV4, cmsSigLabV4toV2);\n\n        // Remove float pcs Lab conversions\n        Opt |= _Remove2Op(Lut, cmsSigLab2FloatPCS, cmsSigFloatPCS2Lab);\n\n        // Remove float pcs Lab conversions\n        Opt |= _Remove2Op(Lut, cmsSigXYZ2FloatPCS, cmsSigFloatPCS2XYZ);\n\n        // Simplify matrix. \n        Opt |= _MultiplyMatrix(Lut);\n\n        if (Opt) AnyOpt = TRUE;\n\n    } while (Opt);\n\n    return AnyOpt;\n}",
          "fn_code_pos": [
            [
              250,
              0
            ],
            [
              288,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PreOptimize",
            "parameters": {
              "Lut": "cmsPipeline"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid Eval16nop1D(CMSREGISTER const cmsUInt16Number Input[],\n                 CMSREGISTER cmsUInt16Number Output[],\n                 CMSREGISTER const struct _cms_interp_struc* p)\n{\n    Output[0] = Input[0];\n\n    cmsUNUSED_PARAMETER(p);\n}",
          "fn_code_pos": [
            [
              290,
              0
            ],
            [
              298,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Eval16nop1D",
            "parameters": {
              "Input": "CMSREGISTER",
              "Output": "CMSREGISTER",
              "struct": "CMSREGISTER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid PrelinEval16(CMSREGISTER const cmsUInt16Number Input[],\n                  CMSREGISTER cmsUInt16Number Output[],\n                  CMSREGISTER const void* D)\n{\n    Prelin16Data* p16 = (Prelin16Data*) D;\n    cmsUInt16Number  StageABC[MAX_INPUT_DIMENSIONS];\n    cmsUInt16Number  StageDEF[cmsMAXCHANNELS];\n    cmsUInt32Number i;\n\n    for (i=0; i < p16 ->nInputs; i++) {\n\n        p16 ->EvalCurveIn16[i](&Input[i], &StageABC[i], p16 ->ParamsCurveIn16[i]);\n    }\n\n    p16 ->EvalCLUT(StageABC, StageDEF, p16 ->CLUTparams);\n\n    for (i=0; i < p16 ->nOutputs; i++) {\n\n        p16 ->EvalCurveOut16[i](&StageDEF[i], &Output[i], p16 ->ParamsCurveOut16[i]);\n    }\n}",
          "fn_code_pos": [
            [
              300,
              0
            ],
            [
              321,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrelinEval16",
            "parameters": {
              "Input": "CMSREGISTER",
              "Output": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid PrelinOpt16free(cmsContext ContextID, void* ptr)\n{\n    Prelin16Data* p16 = (Prelin16Data*) ptr;\n\n    _cmsFree(ContextID, p16 ->EvalCurveOut16);\n    _cmsFree(ContextID, p16 ->ParamsCurveOut16);\n\n    _cmsFree(ContextID, p16);\n}",
          "fn_code_pos": [
            [
              324,
              0
            ],
            [
              333,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrelinOpt16free",
            "parameters": {
              "ContextID": "cmsContext",
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* Prelin16dup(cmsContext ContextID, const void* ptr)\n{\n    Prelin16Data* p16 = (Prelin16Data*) ptr;\n    Prelin16Data* Duped = (Prelin16Data*) _cmsDupMem(ContextID, p16, sizeof(Prelin16Data));\n\n    if (Duped == NULL) return NULL;\n\n    Duped->EvalCurveOut16 = (_cmsInterpFn16*) _cmsDupMem(ContextID, p16->EvalCurveOut16, p16->nOutputs * sizeof(_cmsInterpFn16));\n    Duped->ParamsCurveOut16 = (cmsInterpParams**)_cmsDupMem(ContextID, p16->ParamsCurveOut16, p16->nOutputs * sizeof(cmsInterpParams*));\n\n    return Duped;\n}",
          "fn_code_pos": [
            [
              335,
              0
            ],
            [
              347,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Prelin16dup",
            "parameters": {
              "ContextID": "cmsContext",
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nPrelin16Data* PrelinOpt16alloc(cmsContext ContextID,\n                               const cmsInterpParams* ColorMap,\n                               cmsUInt32Number nInputs, cmsToneCurve** In,\n                               cmsUInt32Number nOutputs, cmsToneCurve** Out )\n{\n    cmsUInt32Number i;\n    Prelin16Data* p16 = (Prelin16Data*)_cmsMallocZero(ContextID, sizeof(Prelin16Data));\n    if (p16 == NULL) return NULL;\n\n    p16 ->nInputs = nInputs;\n    p16 ->nOutputs = nOutputs;\n\n\n    for (i=0; i < nInputs; i++) {\n\n        if (In == NULL) {\n            p16 -> ParamsCurveIn16[i] = NULL;\n            p16 -> EvalCurveIn16[i] = Eval16nop1D;\n\n        }\n        else {\n            p16 -> ParamsCurveIn16[i] = In[i] ->InterpParams;\n            p16 -> EvalCurveIn16[i] = p16 ->ParamsCurveIn16[i]->Interpolation.Lerp16;\n        }\n    }\n\n    p16 ->CLUTparams = ColorMap;\n    p16 ->EvalCLUT   = ColorMap ->Interpolation.Lerp16;\n\n\n    p16 -> EvalCurveOut16 = (_cmsInterpFn16*) _cmsCalloc(ContextID, nOutputs, sizeof(_cmsInterpFn16));\n    if (p16->EvalCurveOut16 == NULL)\n    {\n        _cmsFree(ContextID, p16);\n        return NULL;\n    }\n\n    p16 -> ParamsCurveOut16 = (cmsInterpParams**) _cmsCalloc(ContextID, nOutputs, sizeof(cmsInterpParams* ));\n    if (p16->ParamsCurveOut16 == NULL)\n    {\n\n        _cmsFree(ContextID, p16->EvalCurveOut16);\n        _cmsFree(ContextID, p16);\n        return NULL;\n    }\n\n    for (i=0; i < nOutputs; i++) {\n\n        if (Out == NULL) {\n            p16 ->ParamsCurveOut16[i] = NULL;\n            p16 -> EvalCurveOut16[i] = Eval16nop1D;\n        }\n        else {\n\n            p16 ->ParamsCurveOut16[i] = Out[i] ->InterpParams;\n            p16 -> EvalCurveOut16[i] = p16 ->ParamsCurveOut16[i]->Interpolation.Lerp16;\n        }\n    }\n\n    return p16;\n}",
          "fn_code_pos": [
            [
              350,
              0
            ],
            [
              411,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrelinOpt16alloc",
            "parameters": {
              "ContextID": "cmsContext",
              "ColorMap": "cmsInterpParams",
              "nInputs": "cmsUInt32Number",
              "In": "cmsToneCurve",
              "nOutputs": "cmsUInt32Number",
              "Out": "cmsToneCurve"
            },
            "return_type": "Prelin16Data"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number XFormSampler16(CMSREGISTER const cmsUInt16Number In[], \n                              CMSREGISTER cmsUInt16Number Out[], \n                              CMSREGISTER void* Cargo)\n{\n    cmsPipeline* Lut = (cmsPipeline*) Cargo;\n    cmsFloat32Number InFloat[cmsMAXCHANNELS], OutFloat[cmsMAXCHANNELS];\n    cmsUInt32Number i;\n\n    _cmsAssert(Lut -> InputChannels < cmsMAXCHANNELS);\n    _cmsAssert(Lut -> OutputChannels < cmsMAXCHANNELS);\n\n    // From 16 bit to floating point\n    for (i=0; i < Lut ->InputChannels; i++)\n        InFloat[i] = (cmsFloat32Number) (In[i] / 65535.0);\n\n    // Evaluate in floating point\n    cmsPipelineEvalFloat(InFloat, OutFloat, Lut);\n\n    // Back to 16 bits representation\n    for (i=0; i < Lut ->OutputChannels; i++)\n        Out[i] = _cmsQuickSaturateWord(OutFloat[i] * 65535.0);\n\n    // Always succeed\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              421,
              0
            ],
            [
              446,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "XFormSampler16",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsBool AllCurvesAreLinear(cmsStage* mpe)\n{\n    cmsToneCurve** Curves;\n    cmsUInt32Number i, n;\n\n    Curves = _cmsStageGetPtrToCurveSet(mpe);\n    if (Curves == NULL) return FALSE;\n\n    n = cmsStageOutputChannels(mpe);\n\n    for (i=0; i < n; i++) {\n        if (!cmsIsToneCurveLinear(Curves[i])) return FALSE;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              449,
              0
            ],
            [
              465,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllCurvesAreLinear",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool  PatchLUT(cmsStage* CLUT, cmsUInt16Number At[], cmsUInt16Number Value[],\n                  cmsUInt32Number nChannelsOut, cmsUInt32Number nChannelsIn)\n{\n    _cmsStageCLutData* Grid = (_cmsStageCLutData*) CLUT ->Data;\n    cmsInterpParams* p16  = Grid ->Params;\n    cmsFloat64Number px, py, pz, pw;\n    int        x0, y0, z0, w0;\n    int        i, index;\n\n    if (CLUT -> Type != cmsSigCLutElemType) {\n        cmsSignalError(CLUT->ContextID, cmsERROR_INTERNAL, \"(internal) Attempt to PatchLUT on non-lut stage\");\n        return FALSE;\n    }\n\n    if (nChannelsIn == 4) {\n\n        px = ((cmsFloat64Number) At[0] * (p16->Domain[0])) / 65535.0;\n        py = ((cmsFloat64Number) At[1] * (p16->Domain[1])) / 65535.0;\n        pz = ((cmsFloat64Number) At[2] * (p16->Domain[2])) / 65535.0;\n        pw = ((cmsFloat64Number) At[3] * (p16->Domain[3])) / 65535.0;\n\n        x0 = (int) floor(px);\n        y0 = (int) floor(py);\n        z0 = (int) floor(pz);\n        w0 = (int) floor(pw);\n\n        if (((px - x0) != 0) ||\n            ((py - y0) != 0) ||\n            ((pz - z0) != 0) ||\n            ((pw - w0) != 0)) return FALSE; // Not on exact node\n\n        index = (int) p16 -> opta[3] * x0 +\n                (int) p16 -> opta[2] * y0 +\n                (int) p16 -> opta[1] * z0 +\n                (int) p16 -> opta[0] * w0;\n    }\n    else\n        if (nChannelsIn == 3) {\n\n            px = ((cmsFloat64Number) At[0] * (p16->Domain[0])) / 65535.0;\n            py = ((cmsFloat64Number) At[1] * (p16->Domain[1])) / 65535.0;\n            pz = ((cmsFloat64Number) At[2] * (p16->Domain[2])) / 65535.0;\n           \n            x0 = (int) floor(px);\n            y0 = (int) floor(py);\n            z0 = (int) floor(pz);\n           \n            if (((px - x0) != 0) ||\n                ((py - y0) != 0) ||\n                ((pz - z0) != 0)) return FALSE;  // Not on exact node\n\n            index = (int) p16 -> opta[2] * x0 +\n                    (int) p16 -> opta[1] * y0 +\n                    (int) p16 -> opta[0] * z0;\n        }\n        else\n            if (nChannelsIn == 1) {\n\n                px = ((cmsFloat64Number) At[0] * (p16->Domain[0])) / 65535.0;\n                \n                x0 = (int) floor(px);\n                \n                if (((px - x0) != 0)) return FALSE; // Not on exact node\n\n                index = (int) p16 -> opta[0] * x0;\n            }\n            else {\n                cmsSignalError(CLUT->ContextID, cmsERROR_INTERNAL, \"(internal) %d Channels are not supported on PatchLUT\", nChannelsIn);\n                return FALSE;\n            }\n\n    for (i = 0; i < (int) nChannelsOut; i++)\n        Grid->Tab.T[index + i] = Value[i];\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              469,
              0
            ],
            [
              545,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PatchLUT",
            "parameters": {
              "CLUT": "cmsStage",
              "At": "cmsUInt16Number",
              "Value": "cmsUInt16Number",
              "nChannelsOut": "cmsUInt32Number",
              "nChannelsIn": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool WhitesAreEqual(cmsUInt32Number n, cmsUInt16Number White1[], cmsUInt16Number White2[] )\n{\n    cmsUInt32Number i;\n\n    for (i=0; i < n; i++) {\n\n        if (abs(White1[i] - White2[i]) > 0xf000) return TRUE;  // Values are so extremely different that the fixup should be avoided\n        if (White1[i] != White2[i]) return FALSE;\n    }\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              548,
              0
            ],
            [
              559,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WhitesAreEqual",
            "parameters": {
              "n": "cmsUInt32Number",
              "White1": "cmsUInt16Number",
              "White2": "cmsUInt16Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool FixWhiteMisalignment(cmsPipeline* Lut, cmsColorSpaceSignature EntryColorSpace, cmsColorSpaceSignature ExitColorSpace)\n{\n    cmsUInt16Number *WhitePointIn, *WhitePointOut;\n    cmsUInt16Number  WhiteIn[cmsMAXCHANNELS], WhiteOut[cmsMAXCHANNELS], ObtainedOut[cmsMAXCHANNELS];\n    cmsUInt32Number i, nOuts, nIns;\n    cmsStage *PreLin = NULL, *CLUT = NULL, *PostLin = NULL;\n\n    if (!_cmsEndPointsBySpace(EntryColorSpace,\n        &WhitePointIn, NULL, &nIns)) return FALSE;\n\n    if (!_cmsEndPointsBySpace(ExitColorSpace,\n        &WhitePointOut, NULL, &nOuts)) return FALSE;\n\n    // It needs to be fixed?\n    if (Lut ->InputChannels != nIns) return FALSE;\n    if (Lut ->OutputChannels != nOuts) return FALSE;\n\n    cmsPipelineEval16(WhitePointIn, ObtainedOut, Lut);\n\n    if (WhitesAreEqual(nOuts, WhitePointOut, ObtainedOut)) return TRUE; // whites already match\n\n    // Check if the LUT comes as Prelin, CLUT or Postlin. We allow all combinations\n    if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType, &PreLin, &CLUT, &PostLin))\n        if (!cmsPipelineCheckAndRetreiveStages(Lut, 2, cmsSigCurveSetElemType, cmsSigCLutElemType, &PreLin, &CLUT))\n            if (!cmsPipelineCheckAndRetreiveStages(Lut, 2, cmsSigCLutElemType, cmsSigCurveSetElemType, &CLUT, &PostLin))\n                if (!cmsPipelineCheckAndRetreiveStages(Lut, 1, cmsSigCLutElemType, &CLUT))\n                    return FALSE;\n\n    // We need to interpolate white points of both, pre and post curves\n    if (PreLin) {\n\n        cmsToneCurve** Curves = _cmsStageGetPtrToCurveSet(PreLin);\n\n        for (i=0; i < nIns; i++) {\n            WhiteIn[i] = cmsEvalToneCurve16(Curves[i], WhitePointIn[i]);\n        }\n    }\n    else {\n        for (i=0; i < nIns; i++)\n            WhiteIn[i] = WhitePointIn[i];\n    }\n\n    // If any post-linearization, we need to find how is represented white before the curve, do\n    // a reverse interpolation in this case.\n    if (PostLin) {\n\n        cmsToneCurve** Curves = _cmsStageGetPtrToCurveSet(PostLin);\n\n        for (i=0; i < nOuts; i++) {\n\n            cmsToneCurve* InversePostLin = cmsReverseToneCurve(Curves[i]);\n            if (InversePostLin == NULL) {\n                WhiteOut[i] = WhitePointOut[i];    \n\n            } else {\n\n                WhiteOut[i] = cmsEvalToneCurve16(InversePostLin, WhitePointOut[i]);\n                cmsFreeToneCurve(InversePostLin);\n            }\n        }\n    }\n    else {\n        for (i=0; i < nOuts; i++)\n            WhiteOut[i] = WhitePointOut[i];\n    }\n\n    // Ok, proceed with patching. May fail and we don't care if it fails\n    PatchLUT(CLUT, WhiteIn, WhiteOut, nOuts, nIns);\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              563,
              0
            ],
            [
              634,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FixWhiteMisalignment",
            "parameters": {
              "Lut": "cmsPipeline",
              "EntryColorSpace": "cmsColorSpaceSignature",
              "ExitColorSpace": "cmsColorSpaceSignature"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool OptimizeByResampling(cmsPipeline** Lut, cmsUInt32Number Intent, cmsUInt32Number* InputFormat, cmsUInt32Number* OutputFormat, cmsUInt32Number* dwFlags)\n{\n    cmsPipeline* Src = NULL;\n    cmsPipeline* Dest = NULL;\n    cmsStage* CLUT;\n    cmsStage *KeepPreLin = NULL, *KeepPostLin = NULL;\n    cmsUInt32Number nGridPoints;\n    cmsColorSpaceSignature ColorSpace, OutputColorSpace;\n    cmsStage *NewPreLin = NULL;\n    cmsStage *NewPostLin = NULL;\n    _cmsStageCLutData* DataCLUT;\n    cmsToneCurve** DataSetIn;\n    cmsToneCurve** DataSetOut;\n    Prelin16Data* p16;\n\n    // This is a lossy optimization! does not apply in floating-point cases\n    if (_cmsFormatterIsFloat(*InputFormat) || _cmsFormatterIsFloat(*OutputFormat)) return FALSE;\n\n    ColorSpace       = _cmsICCcolorSpace((int) T_COLORSPACE(*InputFormat));\n    OutputColorSpace = _cmsICCcolorSpace((int) T_COLORSPACE(*OutputFormat));\n\n    // Color space must be specified\n    if (ColorSpace == (cmsColorSpaceSignature)0 ||\n        OutputColorSpace == (cmsColorSpaceSignature)0) return FALSE;\n\n    nGridPoints = _cmsReasonableGridpointsByColorspace(ColorSpace, *dwFlags);\n\n    // For empty LUTs, 2 points are enough\n    if (cmsPipelineStageCount(*Lut) == 0)\n        nGridPoints = 2;\n\n    Src = *Lut;\n\n    // Allocate an empty LUT\n    Dest =  cmsPipelineAlloc(Src ->ContextID, Src ->InputChannels, Src ->OutputChannels);\n    if (!Dest) return FALSE;\n\n    // Prelinearization tables are kept unless indicated by flags\n    if (*dwFlags & cmsFLAGS_CLUT_PRE_LINEARIZATION) {\n\n        // Get a pointer to the prelinearization element\n        cmsStage* PreLin = cmsPipelineGetPtrToFirstStage(Src);\n\n        // Check if suitable\n        if (PreLin && PreLin ->Type == cmsSigCurveSetElemType) {\n\n            // Maybe this is a linear tram, so we can avoid the whole stuff\n            if (!AllCurvesAreLinear(PreLin)) {\n\n                // All seems ok, proceed.\n                NewPreLin = cmsStageDup(PreLin);\n                if(!cmsPipelineInsertStage(Dest, cmsAT_BEGIN, NewPreLin))\n                    goto Error;\n\n                // Remove prelinearization. Since we have duplicated the curve\n                // in destination LUT, the sampling should be applied after this stage.\n                cmsPipelineUnlinkStage(Src, cmsAT_BEGIN, &KeepPreLin);\n            }\n        }\n    }\n\n    // Allocate the CLUT\n    CLUT = cmsStageAllocCLut16bit(Src ->ContextID, nGridPoints, Src ->InputChannels, Src->OutputChannels, NULL);\n    if (CLUT == NULL) goto Error;\n\n    // Add the CLUT to the destination LUT\n    if (!cmsPipelineInsertStage(Dest, cmsAT_END, CLUT)) {\n        goto Error;\n    }\n\n    // Postlinearization tables are kept unless indicated by flags\n    if (*dwFlags & cmsFLAGS_CLUT_POST_LINEARIZATION) {\n\n        // Get a pointer to the postlinearization if present\n        cmsStage* PostLin = cmsPipelineGetPtrToLastStage(Src);\n\n        // Check if suitable\n        if (PostLin && cmsStageType(PostLin) == cmsSigCurveSetElemType) {\n\n            // Maybe this is a linear tram, so we can avoid the whole stuff\n            if (!AllCurvesAreLinear(PostLin)) {\n\n                // All seems ok, proceed.\n                NewPostLin = cmsStageDup(PostLin);\n                if (!cmsPipelineInsertStage(Dest, cmsAT_END, NewPostLin))\n                    goto Error;\n\n                // In destination LUT, the sampling should be applied after this stage.\n                cmsPipelineUnlinkStage(Src, cmsAT_END, &KeepPostLin);\n            }\n        }\n    }\n\n    // Now its time to do the sampling. We have to ignore pre/post linearization\n    // The source LUT without pre/post curves is passed as parameter.\n    if (!cmsStageSampleCLut16bit(CLUT, XFormSampler16, (void*) Src, 0)) {\nError:\n        // Ops, something went wrong, Restore stages\n        if (KeepPreLin != NULL) {\n            if (!cmsPipelineInsertStage(Src, cmsAT_BEGIN, KeepPreLin)) {\n                _cmsAssert(0); // This never happens\n            }\n        }\n        if (KeepPostLin != NULL) {\n            if (!cmsPipelineInsertStage(Src, cmsAT_END,   KeepPostLin)) {\n                _cmsAssert(0); // This never happens\n            }\n        }\n        cmsPipelineFree(Dest);\n        return FALSE;\n    }\n\n    // Done.\n\n    if (KeepPreLin != NULL) cmsStageFree(KeepPreLin);\n    if (KeepPostLin != NULL) cmsStageFree(KeepPostLin);\n    cmsPipelineFree(Src);\n\n    DataCLUT = (_cmsStageCLutData*) CLUT ->Data;\n\n    if (NewPreLin == NULL) DataSetIn = NULL;\n    else DataSetIn = ((_cmsStageToneCurvesData*) NewPreLin ->Data) ->TheCurves;\n\n    if (NewPostLin == NULL) DataSetOut = NULL;\n    else  DataSetOut = ((_cmsStageToneCurvesData*) NewPostLin ->Data) ->TheCurves;\n\n\n    if (DataSetIn == NULL && DataSetOut == NULL) {\n\n        _cmsPipelineSetOptimizationParameters(Dest, (_cmsPipelineEval16Fn) DataCLUT->Params->Interpolation.Lerp16, DataCLUT->Params, NULL, NULL);\n    }\n    else {\n\n        p16 = PrelinOpt16alloc(Dest ->ContextID,\n            DataCLUT ->Params,\n            Dest ->InputChannels,\n            DataSetIn,\n            Dest ->OutputChannels,\n            DataSetOut);\n\n        _cmsPipelineSetOptimizationParameters(Dest, PrelinEval16, (void*) p16, PrelinOpt16free, Prelin16dup);\n    }\n\n\n    // Don't fix white on absolute colorimetric\n    if (Intent == INTENT_ABSOLUTE_COLORIMETRIC)\n        *dwFlags |= cmsFLAGS_NOWHITEONWHITEFIXUP;\n\n    if (!(*dwFlags & cmsFLAGS_NOWHITEONWHITEFIXUP)) {\n\n        FixWhiteMisalignment(Dest, ColorSpace, OutputColorSpace);\n    }\n\n    *Lut = Dest;\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(Intent);\n}",
          "fn_code_pos": [
            [
              645,
              0
            ],
            [
              803,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OptimizeByResampling",
            "parameters": {
              "Lut": "cmsPipeline",
              "Intent": "cmsUInt32Number",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid SlopeLimiting(cmsToneCurve* g)\n{\n    int BeginVal, EndVal;\n    int AtBegin = (int) floor((cmsFloat64Number) g ->nEntries * 0.02 + 0.5);   // Cutoff at 2%\n    int AtEnd   = (int) g ->nEntries - AtBegin - 1;                                  // And 98%\n    cmsFloat64Number Val, Slope, beta;\n    int i;\n\n    if (cmsIsToneCurveDescending(g)) {\n        BeginVal = 0xffff; EndVal = 0;\n    }\n    else {\n        BeginVal = 0; EndVal = 0xffff;\n    }\n\n    // Compute slope and offset for begin of curve\n    Val   = g ->Table16[AtBegin];\n    Slope = (Val - BeginVal) / AtBegin;\n    beta  = Val - Slope * AtBegin;\n\n    for (i=0; i < AtBegin; i++)\n        g ->Table16[i] = _cmsQuickSaturateWord(i * Slope + beta);\n\n    // Compute slope and offset for the end\n    Val   = g ->Table16[AtEnd];\n    Slope = (EndVal - Val) / AtBegin;   // AtBegin holds the X interval, which is same in both cases\n    beta  = Val - Slope * AtEnd;\n\n    for (i = AtEnd; i < (int) g ->nEntries; i++)\n        g ->Table16[i] = _cmsQuickSaturateWord(i * Slope + beta);\n}",
          "fn_code_pos": [
            [
              815,
              0
            ],
            [
              846,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SlopeLimiting",
            "parameters": {
              "g": "cmsToneCurve"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nPrelin8Data* PrelinOpt8alloc(cmsContext ContextID, const cmsInterpParams* p, cmsToneCurve* G[3])\n{\n    int i;\n    cmsUInt16Number Input[3];\n    cmsS15Fixed16Number v1, v2, v3;\n    Prelin8Data* p8;\n\n    p8 = (Prelin8Data*)_cmsMallocZero(ContextID, sizeof(Prelin8Data));\n    if (p8 == NULL) return NULL;\n\n    // Since this only works for 8 bit input, values comes always as x * 257,\n    // we can safely take msb byte (x << 8 + x)\n\n    for (i=0; i < 256; i++) {\n\n        if (G != NULL) {\n\n            // Get 16-bit representation\n            Input[0] = cmsEvalToneCurve16(G[0], FROM_8_TO_16(i));\n            Input[1] = cmsEvalToneCurve16(G[1], FROM_8_TO_16(i));\n            Input[2] = cmsEvalToneCurve16(G[2], FROM_8_TO_16(i));\n        }\n        else {\n            Input[0] = FROM_8_TO_16(i);\n            Input[1] = FROM_8_TO_16(i);\n            Input[2] = FROM_8_TO_16(i);\n        }\n\n\n        // Move to 0..1.0 in fixed domain\n        v1 = _cmsToFixedDomain((int) (Input[0] * p -> Domain[0]));\n        v2 = _cmsToFixedDomain((int) (Input[1] * p -> Domain[1]));\n        v3 = _cmsToFixedDomain((int) (Input[2] * p -> Domain[2]));\n\n        // Store the precalculated table of nodes\n        p8 ->X0[i] = (p->opta[2] * FIXED_TO_INT(v1));\n        p8 ->Y0[i] = (p->opta[1] * FIXED_TO_INT(v2));\n        p8 ->Z0[i] = (p->opta[0] * FIXED_TO_INT(v3));\n\n        // Store the precalculated table of offsets\n        p8 ->rx[i] = (cmsUInt16Number) FIXED_REST_TO_INT(v1);\n        p8 ->ry[i] = (cmsUInt16Number) FIXED_REST_TO_INT(v2);\n        p8 ->rz[i] = (cmsUInt16Number) FIXED_REST_TO_INT(v3);\n    }\n\n    p8 ->ContextID = ContextID;\n    p8 ->p = p;\n\n    return p8;\n}",
          "fn_code_pos": [
            [
              850,
              0
            ],
            [
              900,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrelinOpt8alloc",
            "parameters": {
              "ContextID": "cmsContext",
              "p": "cmsInterpParams",
              "G": "cmsToneCurve"
            },
            "return_type": "Prelin8Data"
          }
        },
        {
          "fn_code": "static\nvoid Prelin8free(cmsContext ContextID, void* ptr)\n{\n    _cmsFree(ContextID, ptr);\n}",
          "fn_code_pos": [
            [
              902,
              0
            ],
            [
              906,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Prelin8free",
            "parameters": {
              "ContextID": "cmsContext",
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* Prelin8dup(cmsContext ContextID, const void* ptr)\n{\n    return _cmsDupMem(ContextID, ptr, sizeof(Prelin8Data));\n}",
          "fn_code_pos": [
            [
              908,
              0
            ],
            [
              912,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Prelin8dup",
            "parameters": {
              "ContextID": "cmsContext",
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static CMS_NO_SANITIZE\nvoid PrelinEval8(CMSREGISTER const cmsUInt16Number Input[],\n                 CMSREGISTER cmsUInt16Number Output[],\n                 CMSREGISTER const void* D)\n{\n\n    cmsUInt8Number         r, g, b;\n    cmsS15Fixed16Number    rx, ry, rz;\n    cmsS15Fixed16Number    c0, c1, c2, c3, Rest;\n    int                    OutChan;\n    CMSREGISTER cmsS15Fixed16Number X0, X1, Y0, Y1, Z0, Z1;\n    Prelin8Data* p8 = (Prelin8Data*) D;\n    CMSREGISTER const cmsInterpParams* p = p8 ->p;\n    int                    TotalOut = (int) p -> nOutputs;\n    const cmsUInt16Number* LutTable = (const cmsUInt16Number*) p->Table;\n\n    r = (cmsUInt8Number) (Input[0] >> 8);\n    g = (cmsUInt8Number) (Input[1] >> 8);\n    b = (cmsUInt8Number) (Input[2] >> 8);\n\n    X0 = (cmsS15Fixed16Number) p8->X0[r];\n    Y0 = (cmsS15Fixed16Number) p8->Y0[g];\n    Z0 = (cmsS15Fixed16Number) p8->Z0[b];\n\n    rx = p8 ->rx[r];\n    ry = p8 ->ry[g];\n    rz = p8 ->rz[b];\n\n    X1 = X0 + (cmsS15Fixed16Number)((rx == 0) ? 0 :  p ->opta[2]);\n    Y1 = Y0 + (cmsS15Fixed16Number)((ry == 0) ? 0 :  p ->opta[1]);\n    Z1 = Z0 + (cmsS15Fixed16Number)((rz == 0) ? 0 :  p ->opta[0]);\n\n\n    // These are the 6 Tetrahedral\n    for (OutChan=0; OutChan < TotalOut; OutChan++) {\n\n        c0 = DENS(X0, Y0, Z0);\n\n        if (rx >= ry && ry >= rz)\n        {\n            c1 = DENS(X1, Y0, Z0) - c0;\n            c2 = DENS(X1, Y1, Z0) - DENS(X1, Y0, Z0);\n            c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);\n        }\n        else\n            if (rx >= rz && rz >= ry)\n            {\n                c1 = DENS(X1, Y0, Z0) - c0;\n                c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);\n                c3 = DENS(X1, Y0, Z1) - DENS(X1, Y0, Z0);\n            }\n            else\n                if (rz >= rx && rx >= ry)\n                {\n                    c1 = DENS(X1, Y0, Z1) - DENS(X0, Y0, Z1);\n                    c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);\n                    c3 = DENS(X0, Y0, Z1) - c0;\n                }\n                else\n                    if (ry >= rx && rx >= rz)\n                    {\n                        c1 = DENS(X1, Y1, Z0) - DENS(X0, Y1, Z0);\n                        c2 = DENS(X0, Y1, Z0) - c0;\n                        c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);\n                    }\n                    else\n                        if (ry >= rz && rz >= rx)\n                        {\n                            c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);\n                            c2 = DENS(X0, Y1, Z0) - c0;\n                            c3 = DENS(X0, Y1, Z1) - DENS(X0, Y1, Z0);\n                        }\n                        else\n                            if (rz >= ry && ry >= rx)\n                            {\n                                c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);\n                                c2 = DENS(X0, Y1, Z1) - DENS(X0, Y0, Z1);\n                                c3 = DENS(X0, Y0, Z1) - c0;\n                            }\n                            else  {\n                                c1 = c2 = c3 = 0;\n                            }\n\n        Rest = c1 * rx + c2 * ry + c3 * rz + 0x8001;\n        Output[OutChan] = (cmsUInt16Number) (c0 + ((Rest + (Rest >> 16)) >> 16));\n\n    }\n}",
          "fn_code_pos": [
            [
              918,
              0
            ],
            [
              1005,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrelinEval8",
            "parameters": {
              "Input": "CMSREGISTER",
              "Output": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "CMS_NO_SANITIZE"
          }
        },
        {
          "fn_code": "static\ncmsBool IsDegenerated(const cmsToneCurve* g)\n{\n    cmsUInt32Number i, Zeros = 0, Poles = 0;\n    cmsUInt32Number nEntries = g ->nEntries;\n\n    for (i=0; i < nEntries; i++) {\n\n        if (g ->Table16[i] == 0x0000) Zeros++;\n        if (g ->Table16[i] == 0xffff) Poles++;\n    }\n\n    if (Zeros == 1 && Poles == 1) return FALSE;  // For linear tables\n    if (Zeros > (nEntries / 20)) return TRUE;  // Degenerated, many zeros\n    if (Poles > (nEntries / 20)) return TRUE;  // Degenerated, many poles\n\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              1011,
              0
            ],
            [
              1028,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsDegenerated",
            "parameters": {
              "g": "cmsToneCurve"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool OptimizeByComputingLinearization(cmsPipeline** Lut, cmsUInt32Number Intent, cmsUInt32Number* InputFormat, cmsUInt32Number* OutputFormat, cmsUInt32Number* dwFlags)\n{\n    cmsPipeline* OriginalLut;\n    cmsUInt32Number nGridPoints;\n    cmsToneCurve *Trans[cmsMAXCHANNELS], *TransReverse[cmsMAXCHANNELS];\n    cmsUInt32Number t, i;\n    cmsFloat32Number v, In[cmsMAXCHANNELS], Out[cmsMAXCHANNELS];\n    cmsBool lIsSuitable, lIsLinear;\n    cmsPipeline* OptimizedLUT = NULL, *LutPlusCurves = NULL;\n    cmsStage* OptimizedCLUTmpe;\n    cmsColorSpaceSignature ColorSpace, OutputColorSpace;\n    cmsStage* OptimizedPrelinMpe;\n    cmsToneCurve** OptimizedPrelinCurves;\n    _cmsStageCLutData* OptimizedPrelinCLUT;\n\n\n    // This is a lossy optimization! does not apply in floating-point cases\n    if (_cmsFormatterIsFloat(*InputFormat) || _cmsFormatterIsFloat(*OutputFormat)) return FALSE;\n\n    // Only on chunky RGB\n    if (T_COLORSPACE(*InputFormat)  != PT_RGB) return FALSE;\n    if (T_PLANAR(*InputFormat)) return FALSE;\n\n    if (T_COLORSPACE(*OutputFormat) != PT_RGB) return FALSE;\n    if (T_PLANAR(*OutputFormat)) return FALSE;\n\n    // On 16 bits, user has to specify the feature\n    if (!_cmsFormatterIs8bit(*InputFormat)) {\n        if (!(*dwFlags & cmsFLAGS_CLUT_PRE_LINEARIZATION)) return FALSE;\n    }\n\n    OriginalLut = *Lut;\n   \n    ColorSpace       = _cmsICCcolorSpace((int) T_COLORSPACE(*InputFormat));\n    OutputColorSpace = _cmsICCcolorSpace((int) T_COLORSPACE(*OutputFormat));\n\n    // Color space must be specified\n    if (ColorSpace == (cmsColorSpaceSignature)0 ||\n        OutputColorSpace == (cmsColorSpaceSignature)0) return FALSE;\n\n    nGridPoints      = _cmsReasonableGridpointsByColorspace(ColorSpace, *dwFlags);\n\n    // Empty gamma containers\n    memset(Trans, 0, sizeof(Trans));\n    memset(TransReverse, 0, sizeof(TransReverse));\n\n    // If the last stage of the original lut are curves, and those curves are\n    // degenerated, it is likely the transform is squeezing and clipping\n    // the output from previous CLUT. We cannot optimize this case     \n    {\n        cmsStage* last = cmsPipelineGetPtrToLastStage(OriginalLut);\n\n        if (last == NULL) goto Error;\n        if (cmsStageType(last) == cmsSigCurveSetElemType) {\n\n            _cmsStageToneCurvesData* Data = (_cmsStageToneCurvesData*)cmsStageData(last);\n            for (i = 0; i < Data->nCurves; i++) {\n                if (IsDegenerated(Data->TheCurves[i]))\n                    goto Error;\n            }\n        }\n    }\n\n    for (t = 0; t < OriginalLut ->InputChannels; t++) {\n        Trans[t] = cmsBuildTabulatedToneCurve16(OriginalLut ->ContextID, PRELINEARIZATION_POINTS, NULL);\n        if (Trans[t] == NULL) goto Error;\n    }\n\n    // Populate the curves\n    for (i=0; i < PRELINEARIZATION_POINTS; i++) {\n\n        v = (cmsFloat32Number) ((cmsFloat64Number) i / (PRELINEARIZATION_POINTS - 1));\n\n        // Feed input with a gray ramp\n        for (t=0; t < OriginalLut ->InputChannels; t++)\n            In[t] = v;\n\n        // Evaluate the gray value\n        cmsPipelineEvalFloat(In, Out, OriginalLut);\n\n        // Store result in curve\n        for (t=0; t < OriginalLut ->InputChannels; t++)\n        {\n            if (Trans[t]->Table16 != NULL)\n                Trans[t] ->Table16[i] = _cmsQuickSaturateWord(Out[t] * 65535.0);\n        }\n    }\n\n    // Slope-limit the obtained curves\n    for (t = 0; t < OriginalLut ->InputChannels; t++)\n        SlopeLimiting(Trans[t]);\n\n    // Check for validity. lIsLinear is here for debug purposes\n    lIsSuitable = TRUE;\n    lIsLinear   = TRUE;\n    for (t=0; (lIsSuitable && (t < OriginalLut ->InputChannels)); t++) {\n\n        // Exclude if already linear\n        if (!cmsIsToneCurveLinear(Trans[t]))\n            lIsLinear = FALSE;\n\n        // Exclude if non-monotonic\n        if (!cmsIsToneCurveMonotonic(Trans[t]))\n            lIsSuitable = FALSE;\n\n        if (IsDegenerated(Trans[t]))\n            lIsSuitable = FALSE;\n    }\n\n    // If it is not suitable, just quit\n    if (!lIsSuitable) goto Error;\n\n    // Invert curves if possible\n    for (t = 0; t < OriginalLut ->InputChannels; t++) {\n        TransReverse[t] = cmsReverseToneCurveEx(PRELINEARIZATION_POINTS, Trans[t]);\n        if (TransReverse[t] == NULL) goto Error;\n    }\n\n    // Now inset the reversed curves at the begin of transform\n    LutPlusCurves = cmsPipelineDup(OriginalLut);\n    if (LutPlusCurves == NULL) goto Error;\n\n    if (!cmsPipelineInsertStage(LutPlusCurves, cmsAT_BEGIN, cmsStageAllocToneCurves(OriginalLut ->ContextID, OriginalLut ->InputChannels, TransReverse)))\n        goto Error;\n\n    // Create the result LUT\n    OptimizedLUT = cmsPipelineAlloc(OriginalLut ->ContextID, OriginalLut ->InputChannels, OriginalLut ->OutputChannels);\n    if (OptimizedLUT == NULL) goto Error;\n\n    OptimizedPrelinMpe = cmsStageAllocToneCurves(OriginalLut ->ContextID, OriginalLut ->InputChannels, Trans);\n\n    // Create and insert the curves at the beginning\n    if (!cmsPipelineInsertStage(OptimizedLUT, cmsAT_BEGIN, OptimizedPrelinMpe))\n        goto Error;\n\n    // Allocate the CLUT for result\n    OptimizedCLUTmpe = cmsStageAllocCLut16bit(OriginalLut ->ContextID, nGridPoints, OriginalLut ->InputChannels, OriginalLut ->OutputChannels, NULL);\n\n    // Add the CLUT to the destination LUT\n    if (!cmsPipelineInsertStage(OptimizedLUT, cmsAT_END, OptimizedCLUTmpe))\n        goto Error;\n\n    // Resample the LUT\n    if (!cmsStageSampleCLut16bit(OptimizedCLUTmpe, XFormSampler16, (void*) LutPlusCurves, 0)) goto Error;\n\n    // Free resources\n    for (t = 0; t < OriginalLut ->InputChannels; t++) {\n\n        if (Trans[t]) cmsFreeToneCurve(Trans[t]);\n        if (TransReverse[t]) cmsFreeToneCurve(TransReverse[t]);\n    }\n\n    cmsPipelineFree(LutPlusCurves);\n\n\n    OptimizedPrelinCurves = _cmsStageGetPtrToCurveSet(OptimizedPrelinMpe);\n    OptimizedPrelinCLUT   = (_cmsStageCLutData*) OptimizedCLUTmpe ->Data;\n\n    // Set the evaluator if 8-bit\n    if (_cmsFormatterIs8bit(*InputFormat)) {\n\n        Prelin8Data* p8 = PrelinOpt8alloc(OptimizedLUT ->ContextID,\n                                                OptimizedPrelinCLUT ->Params,\n                                                OptimizedPrelinCurves);\n        if (p8 == NULL) return FALSE;\n\n        _cmsPipelineSetOptimizationParameters(OptimizedLUT, PrelinEval8, (void*) p8, Prelin8free, Prelin8dup);\n\n    }\n    else\n    {\n        Prelin16Data* p16 = PrelinOpt16alloc(OptimizedLUT ->ContextID,\n            OptimizedPrelinCLUT ->Params,\n            3, OptimizedPrelinCurves, 3, NULL);\n        if (p16 == NULL) return FALSE;\n\n        _cmsPipelineSetOptimizationParameters(OptimizedLUT, PrelinEval16, (void*) p16, PrelinOpt16free, Prelin16dup);\n\n    }\n\n    // Don't fix white on absolute colorimetric\n    if (Intent == INTENT_ABSOLUTE_COLORIMETRIC)\n        *dwFlags |= cmsFLAGS_NOWHITEONWHITEFIXUP;\n\n    if (!(*dwFlags & cmsFLAGS_NOWHITEONWHITEFIXUP)) {\n\n        if (!FixWhiteMisalignment(OptimizedLUT, ColorSpace, OutputColorSpace)) {\n\n            return FALSE;\n        }\n    }\n\n    // And return the obtained LUT\n\n    cmsPipelineFree(OriginalLut);\n    *Lut = OptimizedLUT;\n    return TRUE;\n\nError:\n\n    for (t = 0; t < OriginalLut ->InputChannels; t++) {\n\n        if (Trans[t]) cmsFreeToneCurve(Trans[t]);\n        if (TransReverse[t]) cmsFreeToneCurve(TransReverse[t]);\n    }\n\n    if (LutPlusCurves != NULL) cmsPipelineFree(LutPlusCurves);\n    if (OptimizedLUT != NULL) cmsPipelineFree(OptimizedLUT);\n\n    return FALSE;\n\n    cmsUNUSED_PARAMETER(Intent);\n    cmsUNUSED_PARAMETER(lIsLinear);\n}",
          "fn_code_pos": [
            [
              1033,
              0
            ],
            [
              1247,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OptimizeByComputingLinearization",
            "parameters": {
              "Lut": "cmsPipeline",
              "Intent": "cmsUInt32Number",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid CurvesFree(cmsContext ContextID, void* ptr)\n{\n     Curves16Data* Data = (Curves16Data*) ptr;\n     cmsUInt32Number i;\n\n     for (i=0; i < Data -> nCurves; i++) {\n\n         _cmsFree(ContextID, Data ->Curves[i]);\n     }\n\n     _cmsFree(ContextID, Data ->Curves);\n     _cmsFree(ContextID, ptr);\n}",
          "fn_code_pos": [
            [
              1252,
              0
            ],
            [
              1265,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CurvesFree",
            "parameters": {
              "ContextID": "cmsContext",
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* CurvesDup(cmsContext ContextID, const void* ptr)\n{\n    Curves16Data* Data = (Curves16Data*)_cmsDupMem(ContextID, ptr, sizeof(Curves16Data));\n    cmsUInt32Number i;\n\n    if (Data == NULL) return NULL;\n\n    Data->Curves = (cmsUInt16Number**) _cmsDupMem(ContextID, Data->Curves, Data->nCurves * sizeof(cmsUInt16Number*));\n\n    for (i=0; i < Data -> nCurves; i++) {\n        Data->Curves[i] = (cmsUInt16Number*) _cmsDupMem(ContextID, Data->Curves[i], Data->nElements * sizeof(cmsUInt16Number));\n    }\n\n    return (void*) Data;\n}",
          "fn_code_pos": [
            [
              1267,
              0
            ],
            [
              1282,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CurvesDup",
            "parameters": {
              "ContextID": "cmsContext",
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nCurves16Data* CurvesAlloc(cmsContext ContextID, cmsUInt32Number nCurves, cmsUInt32Number nElements, cmsToneCurve** G)\n{\n    cmsUInt32Number i, j;\n    Curves16Data* c16;\n\n    c16 = (Curves16Data*)_cmsMallocZero(ContextID, sizeof(Curves16Data));\n    if (c16 == NULL) return NULL;\n\n    c16 ->nCurves = nCurves;\n    c16 ->nElements = nElements;\n\n    c16->Curves = (cmsUInt16Number**) _cmsCalloc(ContextID, nCurves, sizeof(cmsUInt16Number*));\n    if (c16->Curves == NULL) {\n        _cmsFree(ContextID, c16);\n        return NULL;\n    }\n\n    for (i=0; i < nCurves; i++) {\n\n        c16->Curves[i] = (cmsUInt16Number*) _cmsCalloc(ContextID, nElements, sizeof(cmsUInt16Number));\n\n        if (c16->Curves[i] == NULL) {\n\n            for (j=0; j < i; j++) {\n                _cmsFree(ContextID, c16->Curves[j]);\n            }\n            _cmsFree(ContextID, c16->Curves);\n            _cmsFree(ContextID, c16);\n            return NULL;\n        }\n\n        if (nElements == 256U) {\n\n            for (j=0; j < nElements; j++) {\n\n                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], FROM_8_TO_16(j));\n            }\n        }\n        else {\n\n            for (j=0; j < nElements; j++) {\n                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], (cmsUInt16Number) j);\n            }\n        }\n    }\n\n    return c16;\n}",
          "fn_code_pos": [
            [
              1285,
              0
            ],
            [
              1333,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CurvesAlloc",
            "parameters": {
              "ContextID": "cmsContext",
              "nCurves": "cmsUInt32Number",
              "nElements": "cmsUInt32Number",
              "G": "cmsToneCurve"
            },
            "return_type": "Curves16Data"
          }
        },
        {
          "fn_code": "static\nvoid FastEvaluateCurves8(CMSREGISTER const cmsUInt16Number In[],\n                         CMSREGISTER cmsUInt16Number Out[],\n                         CMSREGISTER const void* D)\n{\n    Curves16Data* Data = (Curves16Data*) D;\n    int x;\n    cmsUInt32Number i;\n\n    for (i=0; i < Data ->nCurves; i++) {\n\n         x = (In[i] >> 8);\n         Out[i] = Data -> Curves[i][x];\n    }\n}",
          "fn_code_pos": [
            [
              1335,
              0
            ],
            [
              1349,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FastEvaluateCurves8",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid FastEvaluateCurves16(CMSREGISTER const cmsUInt16Number In[],\n                          CMSREGISTER cmsUInt16Number Out[],\n                          CMSREGISTER const void* D)\n{\n    Curves16Data* Data = (Curves16Data*) D;\n    cmsUInt32Number i;\n\n    for (i=0; i < Data ->nCurves; i++) {\n         Out[i] = Data -> Curves[i][In[i]];\n    }\n}",
          "fn_code_pos": [
            [
              1352,
              0
            ],
            [
              1363,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FastEvaluateCurves16",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid FastIdentity16(CMSREGISTER const cmsUInt16Number In[],\n                    CMSREGISTER cmsUInt16Number Out[],\n                    CMSREGISTER const void* D)\n{\n    cmsPipeline* Lut = (cmsPipeline*) D;\n    cmsUInt32Number i;\n\n    for (i=0; i < Lut ->InputChannels; i++) {\n         Out[i] = In[i];\n    }\n}",
          "fn_code_pos": [
            [
              1366,
              0
            ],
            [
              1377,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FastIdentity16",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool OptimizeByJoiningCurves(cmsPipeline** Lut, cmsUInt32Number Intent, cmsUInt32Number* InputFormat, cmsUInt32Number* OutputFormat, cmsUInt32Number* dwFlags)\n{\n    cmsToneCurve** GammaTables = NULL;\n    cmsFloat32Number InFloat[cmsMAXCHANNELS], OutFloat[cmsMAXCHANNELS];\n    cmsUInt32Number i, j;\n    cmsPipeline* Src = *Lut;\n    cmsPipeline* Dest = NULL;\n    cmsStage* mpe;\n    cmsStage* ObtainedCurves = NULL;\n\n\n    // This is a lossy optimization! does not apply in floating-point cases\n    if (_cmsFormatterIsFloat(*InputFormat) || _cmsFormatterIsFloat(*OutputFormat)) return FALSE;\n\n    //  Only curves in this LUT?\n    for (mpe = cmsPipelineGetPtrToFirstStage(Src);\n         mpe != NULL;\n         mpe = cmsStageNext(mpe)) {\n            if (cmsStageType(mpe) != cmsSigCurveSetElemType) return FALSE;\n    }\n\n    // Allocate an empty LUT\n    Dest =  cmsPipelineAlloc(Src ->ContextID, Src ->InputChannels, Src ->OutputChannels);\n    if (Dest == NULL) return FALSE;\n\n    // Create target curves\n    GammaTables = (cmsToneCurve**) _cmsCalloc(Src ->ContextID, Src ->InputChannels, sizeof(cmsToneCurve*));\n    if (GammaTables == NULL) goto Error;\n\n    for (i=0; i < Src ->InputChannels; i++) {\n        GammaTables[i] = cmsBuildTabulatedToneCurve16(Src ->ContextID, PRELINEARIZATION_POINTS, NULL);\n        if (GammaTables[i] == NULL) goto Error;\n    }\n\n    // Compute 16 bit result by using floating point\n    for (i=0; i < PRELINEARIZATION_POINTS; i++) {\n\n        for (j=0; j < Src ->InputChannels; j++)\n            InFloat[j] = (cmsFloat32Number) ((cmsFloat64Number) i / (PRELINEARIZATION_POINTS - 1));\n\n        cmsPipelineEvalFloat(InFloat, OutFloat, Src);\n\n        for (j=0; j < Src ->InputChannels; j++)\n            GammaTables[j] -> Table16[i] = _cmsQuickSaturateWord(OutFloat[j] * 65535.0);\n    }\n\n    ObtainedCurves = cmsStageAllocToneCurves(Src ->ContextID, Src ->InputChannels, GammaTables);\n    if (ObtainedCurves == NULL) goto Error;\n\n    for (i=0; i < Src ->InputChannels; i++) {\n        cmsFreeToneCurve(GammaTables[i]);\n        GammaTables[i] = NULL;\n    }\n\n    if (GammaTables != NULL) {\n        _cmsFree(Src->ContextID, GammaTables);\n        GammaTables = NULL;\n    }\n\n    // Maybe the curves are linear at the end\n    if (!AllCurvesAreLinear(ObtainedCurves)) {\n       _cmsStageToneCurvesData* Data;\n\n        if (!cmsPipelineInsertStage(Dest, cmsAT_BEGIN, ObtainedCurves))\n            goto Error;\n        Data = (_cmsStageToneCurvesData*) cmsStageData(ObtainedCurves);\n        ObtainedCurves = NULL;\n\n        // If the curves are to be applied in 8 bits, we can save memory\n        if (_cmsFormatterIs8bit(*InputFormat)) {\n             Curves16Data* c16 = CurvesAlloc(Dest ->ContextID, Data ->nCurves, 256, Data ->TheCurves);\n\n             if (c16 == NULL) goto Error;\n             *dwFlags |= cmsFLAGS_NOCACHE;\n            _cmsPipelineSetOptimizationParameters(Dest, FastEvaluateCurves8, c16, CurvesFree, CurvesDup);\n\n        }\n        else {\n             Curves16Data* c16 = CurvesAlloc(Dest ->ContextID, Data ->nCurves, 65536, Data ->TheCurves);\n\n             if (c16 == NULL) goto Error;\n             *dwFlags |= cmsFLAGS_NOCACHE;\n            _cmsPipelineSetOptimizationParameters(Dest, FastEvaluateCurves16, c16, CurvesFree, CurvesDup);\n        }\n    }\n    else {\n\n        // LUT optimizes to nothing. Set the identity LUT\n        cmsStageFree(ObtainedCurves);\n        ObtainedCurves = NULL;\n\n        if (!cmsPipelineInsertStage(Dest, cmsAT_BEGIN, cmsStageAllocIdentity(Dest ->ContextID, Src ->InputChannels)))\n            goto Error;\n\n        *dwFlags |= cmsFLAGS_NOCACHE;\n        _cmsPipelineSetOptimizationParameters(Dest, FastIdentity16, (void*) Dest, NULL, NULL);\n    }\n\n    // We are done.\n    cmsPipelineFree(Src);\n    *Lut = Dest;\n    return TRUE;\n\nError:\n\n    if (ObtainedCurves != NULL) cmsStageFree(ObtainedCurves);\n    if (GammaTables != NULL) {\n        for (i=0; i < Src ->InputChannels; i++) {\n            if (GammaTables[i] != NULL) cmsFreeToneCurve(GammaTables[i]);\n        }\n\n        _cmsFree(Src ->ContextID, GammaTables);\n    }\n\n    if (Dest != NULL) cmsPipelineFree(Dest);\n    return FALSE;\n\n    cmsUNUSED_PARAMETER(Intent);\n    cmsUNUSED_PARAMETER(InputFormat);\n    cmsUNUSED_PARAMETER(OutputFormat);\n    cmsUNUSED_PARAMETER(dwFlags);\n}",
          "fn_code_pos": [
            [
              1382,
              0
            ],
            [
              1504,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OptimizeByJoiningCurves",
            "parameters": {
              "Lut": "cmsPipeline",
              "Intent": "cmsUInt32Number",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid  FreeMatShaper(cmsContext ContextID, void* Data)\n{\n    if (Data != NULL) _cmsFree(ContextID, Data);\n}",
          "fn_code_pos": [
            [
              1510,
              0
            ],
            [
              1514,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FreeMatShaper",
            "parameters": {
              "ContextID": "cmsContext",
              "Data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* DupMatShaper(cmsContext ContextID, const void* Data)\n{\n    return _cmsDupMem(ContextID, Data, sizeof(MatShaper8Data));\n}",
          "fn_code_pos": [
            [
              1516,
              0
            ],
            [
              1520,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DupMatShaper",
            "parameters": {
              "ContextID": "cmsContext",
              "Data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static CMS_NO_SANITIZE\nvoid MatShaperEval16(CMSREGISTER const cmsUInt16Number In[],\n                     CMSREGISTER cmsUInt16Number Out[],\n                     CMSREGISTER const void* D)\n{\n    MatShaper8Data* p = (MatShaper8Data*) D;\n    cmsS1Fixed14Number l1, l2, l3, r, g, b;\n    cmsUInt32Number ri, gi, bi;\n\n    // In this case (and only in this case!) we can use this simplification since\n    // In[] is assured to come from a 8 bit number. (a << 8 | a)\n    ri = In[0] & 0xFFU;\n    gi = In[1] & 0xFFU;\n    bi = In[2] & 0xFFU;\n\n    // Across first shaper, which also converts to 1.14 fixed point\n    r = p->Shaper1R[ri];\n    g = p->Shaper1G[gi];\n    b = p->Shaper1B[bi];\n\n    // Evaluate the matrix in 1.14 fixed point\n    l1 =  (p->Mat[0][0] * r + p->Mat[0][1] * g + p->Mat[0][2] * b + p->Off[0] + 0x2000) >> 14;\n    l2 =  (p->Mat[1][0] * r + p->Mat[1][1] * g + p->Mat[1][2] * b + p->Off[1] + 0x2000) >> 14;\n    l3 =  (p->Mat[2][0] * r + p->Mat[2][1] * g + p->Mat[2][2] * b + p->Off[2] + 0x2000) >> 14;\n\n    // Now we have to clip to 0..1.0 range\n    ri = (l1 < 0) ? 0 : ((l1 > 16384) ? 16384U : (cmsUInt32Number) l1);\n    gi = (l2 < 0) ? 0 : ((l2 > 16384) ? 16384U : (cmsUInt32Number) l2);\n    bi = (l3 < 0) ? 0 : ((l3 > 16384) ? 16384U : (cmsUInt32Number) l3);\n\n    // And across second shaper,\n    Out[0] = p->Shaper2R[ri];\n    Out[1] = p->Shaper2G[gi];\n    Out[2] = p->Shaper2B[bi];\n\n}",
          "fn_code_pos": [
            [
              1526,
              0
            ],
            [
              1561,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MatShaperEval16",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "CMS_NO_SANITIZE"
          }
        },
        {
          "fn_code": "static\nvoid FillFirstShaper(cmsS1Fixed14Number* Table, cmsToneCurve* Curve)\n{\n    int i;\n    cmsFloat32Number R, y;\n\n    for (i=0; i < 256; i++) {\n\n        R   = (cmsFloat32Number) (i / 255.0);\n        y   = cmsEvalToneCurveFloat(Curve, R);\n\n        if (y < 131072.0)\n            Table[i] = DOUBLE_TO_1FIXED14(y);\n        else\n            Table[i] = 0x7fffffff;\n    }\n}",
          "fn_code_pos": [
            [
              1564,
              0
            ],
            [
              1580,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FillFirstShaper",
            "parameters": {
              "Table": "cmsS1Fixed14Number",
              "Curve": "cmsToneCurve"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid FillSecondShaper(cmsUInt16Number* Table, cmsToneCurve* Curve, cmsBool Is8BitsOutput)\n{\n    int i;\n    cmsFloat32Number R, Val;\n\n    for (i=0; i < 16385; i++) {\n\n        R   = (cmsFloat32Number) (i / 16384.0);\n        Val = cmsEvalToneCurveFloat(Curve, R);    // Val comes 0..1.0\n\n        if (Val < 0)\n            Val = 0;\n\n        if (Val > 1.0)\n            Val = 1.0;\n\n        if (Is8BitsOutput) {\n\n            // If 8 bits output, we can optimize further by computing the / 257 part.\n            // first we compute the resulting byte and then we store the byte times\n            // 257. This quantization allows to round very quick by doing a >> 8, but\n            // since the low byte is always equal to msb, we can do a & 0xff and this works!\n            cmsUInt16Number w = _cmsQuickSaturateWord(Val * 65535.0);\n            cmsUInt8Number  b = FROM_16_TO_8(w);\n\n            Table[i] = FROM_8_TO_16(b);\n        }\n        else Table[i]  = _cmsQuickSaturateWord(Val * 65535.0);\n    }\n}",
          "fn_code_pos": [
            [
              1583,
              0
            ],
            [
              1613,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FillSecondShaper",
            "parameters": {
              "Table": "cmsUInt16Number",
              "Curve": "cmsToneCurve",
              "Is8BitsOutput": "cmsBool"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool SetMatShaper(cmsPipeline* Dest, cmsToneCurve* Curve1[3], cmsMAT3* Mat, cmsVEC3* Off, cmsToneCurve* Curve2[3], cmsUInt32Number* OutputFormat)\n{\n    MatShaper8Data* p;\n    int i, j;\n    cmsBool Is8Bits = _cmsFormatterIs8bit(*OutputFormat);\n\n    // Allocate a big chuck of memory to store precomputed tables\n    p = (MatShaper8Data*) _cmsMalloc(Dest ->ContextID, sizeof(MatShaper8Data));\n    if (p == NULL) return FALSE;\n\n    p -> ContextID = Dest -> ContextID;\n\n    // Precompute tables\n    FillFirstShaper(p ->Shaper1R, Curve1[0]);\n    FillFirstShaper(p ->Shaper1G, Curve1[1]);\n    FillFirstShaper(p ->Shaper1B, Curve1[2]);\n\n    FillSecondShaper(p ->Shaper2R, Curve2[0], Is8Bits);\n    FillSecondShaper(p ->Shaper2G, Curve2[1], Is8Bits);\n    FillSecondShaper(p ->Shaper2B, Curve2[2], Is8Bits);\n\n    // Convert matrix to nFixed14. Note that those values may take more than 16 bits \n    for (i=0; i < 3; i++) {\n        for (j=0; j < 3; j++) {\n            p ->Mat[i][j] = DOUBLE_TO_1FIXED14(Mat->v[i].n[j]);\n        }\n    }\n\n    for (i=0; i < 3; i++) {\n\n        if (Off == NULL) {\n            p ->Off[i] = 0;\n        }\n        else {\n            p ->Off[i] = DOUBLE_TO_1FIXED14(Off->n[i]);\n        }\n    }\n\n    // Mark as optimized for faster formatter\n    if (Is8Bits)\n        *OutputFormat |= OPTIMIZED_SH(1);\n\n    // Fill function pointers\n    _cmsPipelineSetOptimizationParameters(Dest, MatShaperEval16, (void*) p, FreeMatShaper, DupMatShaper);\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1616,
              0
            ],
            [
              1662,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetMatShaper",
            "parameters": {
              "Dest": "cmsPipeline",
              "Curve1": "cmsToneCurve",
              "Mat": "cmsMAT3",
              "Off": "cmsVEC3",
              "Curve2": "cmsToneCurve",
              "OutputFormat": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool OptimizeMatrixShaper(cmsPipeline** Lut, cmsUInt32Number Intent, cmsUInt32Number* InputFormat, cmsUInt32Number* OutputFormat, cmsUInt32Number* dwFlags)\n{\n       cmsStage* Curve1, *Curve2;\n       cmsStage* Matrix1, *Matrix2;\n       cmsMAT3 res;\n       cmsBool IdentityMat;\n       cmsPipeline* Dest, *Src;\n       cmsFloat64Number* Offset;\n\n       // Only works on RGB to RGB\n       if (T_CHANNELS(*InputFormat) != 3 || T_CHANNELS(*OutputFormat) != 3) return FALSE;\n\n       // Only works on 8 bit input\n       if (!_cmsFormatterIs8bit(*InputFormat)) return FALSE;\n\n       // Seems suitable, proceed\n       Src = *Lut;\n\n       // Check for:\n       // \n       //    shaper-matrix-matrix-shaper \n       //    shaper-matrix-shaper\n       // \n       // Both of those constructs are possible (first because abs. colorimetric). \n       // additionally, In the first case, the input matrix offset should be zero.\n\n       IdentityMat = FALSE;\n       if (cmsPipelineCheckAndRetreiveStages(Src, 4,\n              cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType,\n              &Curve1, &Matrix1, &Matrix2, &Curve2)) {\n\n              // Get both matrices\n              _cmsStageMatrixData* Data1 = (_cmsStageMatrixData*)cmsStageData(Matrix1);\n              _cmsStageMatrixData* Data2 = (_cmsStageMatrixData*)cmsStageData(Matrix2);\n\n              // Only RGB to RGB\n              if (Matrix1->InputChannels != 3 || Matrix1->OutputChannels != 3 ||\n                  Matrix2->InputChannels != 3 || Matrix2->OutputChannels != 3) return FALSE;\n\n              // Input offset should be zero\n              if (Data1->Offset != NULL) return FALSE;\n\n              // Multiply both matrices to get the result\n              _cmsMAT3per(&res, (cmsMAT3*)Data2->Double, (cmsMAT3*)Data1->Double);\n\n              // Only 2nd matrix has offset, or it is zero \n              Offset = Data2->Offset;\n\n              // Now the result is in res + Data2 -> Offset. Maybe is a plain identity?\n              if (_cmsMAT3isIdentity(&res) && Offset == NULL) {\n\n                     // We can get rid of full matrix\n                     IdentityMat = TRUE;\n              }\n\n       }\n       else {\n\n              if (cmsPipelineCheckAndRetreiveStages(Src, 3,\n                     cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType,\n                     &Curve1, &Matrix1, &Curve2)) {\n\n                     _cmsStageMatrixData* Data = (_cmsStageMatrixData*)cmsStageData(Matrix1);\n\n                     if (Matrix1->InputChannels != 3 || Matrix1->OutputChannels != 3) return FALSE;\n\n                     // Copy the matrix to our result\n                     memcpy(&res, Data->Double, sizeof(res));\n\n                     // Preserve the Odffset (may be NULL as a zero offset)\n                     Offset = Data->Offset;\n\n                     if (_cmsMAT3isIdentity(&res) && Offset == NULL) {\n\n                            // We can get rid of full matrix\n                            IdentityMat = TRUE;\n                     }\n              }\n              else\n                     return FALSE; // Not optimizeable this time\n\n       }\n\n      // Allocate an empty LUT\n    Dest =  cmsPipelineAlloc(Src ->ContextID, Src ->InputChannels, Src ->OutputChannels);\n    if (!Dest) return FALSE;\n\n    // Assamble the new LUT\n    if (!cmsPipelineInsertStage(Dest, cmsAT_BEGIN, cmsStageDup(Curve1)))\n        goto Error;\n\n    if (!IdentityMat) {\n\n           if (!cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageAllocMatrix(Dest->ContextID, 3, 3, (const cmsFloat64Number*)&res, Offset)))\n                  goto Error;\n    }\n\n    if (!cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageDup(Curve2)))\n        goto Error;\n\n    // If identity on matrix, we can further optimize the curves, so call the join curves routine\n    if (IdentityMat) {\n\n        OptimizeByJoiningCurves(&Dest, Intent, InputFormat, OutputFormat, dwFlags);\n    }\n    else {\n        _cmsStageToneCurvesData* mpeC1 = (_cmsStageToneCurvesData*) cmsStageData(Curve1);\n        _cmsStageToneCurvesData* mpeC2 = (_cmsStageToneCurvesData*) cmsStageData(Curve2);\n\n        // In this particular optimization, cache does not help as it takes more time to deal with\n        // the cache than with the pixel handling\n        *dwFlags |= cmsFLAGS_NOCACHE;\n\n        // Setup the optimizarion routines\n        SetMatShaper(Dest, mpeC1 ->TheCurves, &res, (cmsVEC3*) Offset, mpeC2->TheCurves, OutputFormat);\n    }\n\n    cmsPipelineFree(Src);\n    *Lut = Dest;\n    return TRUE;\nError:\n    // Leave Src unchanged\n    cmsPipelineFree(Dest);\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              1665,
              0
            ],
            [
              1790,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OptimizeMatrixShaper",
            "parameters": {
              "Lut": "cmsPipeline",
              "Intent": "cmsUInt32Number",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid DupPluginOptimizationList(struct _cmsContext_struct* ctx, \n                               const struct _cmsContext_struct* src)\n{\n   _cmsOptimizationPluginChunkType newHead = { NULL };\n   _cmsOptimizationCollection*  entry;\n   _cmsOptimizationCollection*  Anterior = NULL;\n   _cmsOptimizationPluginChunkType* head = (_cmsOptimizationPluginChunkType*) src->chunks[OptimizationPlugin];\n\n    _cmsAssert(ctx != NULL);\n    _cmsAssert(head != NULL);\n\n    // Walk the list copying all nodes\n   for (entry = head->OptimizationCollection;\n        entry != NULL;\n        entry = entry ->Next) {\n\n            _cmsOptimizationCollection *newEntry = ( _cmsOptimizationCollection *) _cmsSubAllocDup(ctx ->MemPool, entry, sizeof(_cmsOptimizationCollection));\n   \n            if (newEntry == NULL) \n                return;\n\n            // We want to keep the linked list order, so this is a little bit tricky\n            newEntry -> Next = NULL;\n            if (Anterior)\n                Anterior -> Next = newEntry;\n     \n            Anterior = newEntry;\n\n            if (newHead.OptimizationCollection == NULL)\n                newHead.OptimizationCollection = newEntry;\n    }\n\n  ctx ->chunks[OptimizationPlugin] = _cmsSubAllocDup(ctx->MemPool, &newHead, sizeof(_cmsOptimizationPluginChunkType));\n}",
          "fn_code_pos": [
            [
              1820,
              0
            ],
            [
              1854,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DupPluginOptimizationList",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void  _cmsAllocOptimizationPluginChunk(struct _cmsContext_struct* ctx, \n                                         const struct _cmsContext_struct* src)\n{\n  if (src != NULL) {\n\n        // Copy all linked list\n       DupPluginOptimizationList(ctx, src);\n    }\n    else {\n        static _cmsOptimizationPluginChunkType OptimizationPluginChunkType = { NULL };\n        ctx ->chunks[OptimizationPlugin] = _cmsSubAllocDup(ctx ->MemPool, &OptimizationPluginChunkType, sizeof(_cmsOptimizationPluginChunkType));\n    }\n}",
          "fn_code_pos": [
            [
              1856,
              0
            ],
            [
              1868,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocOptimizationPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool  _cmsRegisterOptimizationPlugin(cmsContext ContextID, cmsPluginBase* Data)\n{\n    cmsPluginOptimization* Plugin = (cmsPluginOptimization*) Data;\n    _cmsOptimizationPluginChunkType* ctx = ( _cmsOptimizationPluginChunkType*) _cmsContextGetClientChunk(ContextID, OptimizationPlugin);\n    _cmsOptimizationCollection* fl;\n\n    if (Data == NULL) {\n\n        ctx->OptimizationCollection = NULL;\n        return TRUE;\n    }\n\n    // Optimizer callback is required\n    if (Plugin ->OptimizePtr == NULL) return FALSE;\n\n    fl = (_cmsOptimizationCollection*) _cmsPluginMalloc(ContextID, sizeof(_cmsOptimizationCollection));\n    if (fl == NULL) return FALSE;\n\n    // Copy the parameters\n    fl ->OptimizePtr = Plugin ->OptimizePtr;\n\n    // Keep linked list\n    fl ->Next = ctx->OptimizationCollection;\n\n    // Set the head\n    ctx ->OptimizationCollection = fl;\n\n    // All is ok\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1872,
              0
            ],
            [
              1901,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterOptimizationPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Data": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT _cmsOptimizePipeline(cmsContext ContextID,\n                             cmsPipeline**    PtrLut,\n                             cmsUInt32Number  Intent,\n                             cmsUInt32Number* InputFormat,\n                             cmsUInt32Number* OutputFormat,\n                             cmsUInt32Number* dwFlags)\n{\n    _cmsOptimizationPluginChunkType* ctx = ( _cmsOptimizationPluginChunkType*) _cmsContextGetClientChunk(ContextID, OptimizationPlugin);\n    _cmsOptimizationCollection* Opts;\n    cmsBool AnySuccess = FALSE;\n    cmsStage* mpe;\n\n    // A CLUT is being asked, so force this specific optimization\n    if (*dwFlags & cmsFLAGS_FORCE_CLUT) {\n\n        PreOptimize(*PtrLut);\n        return OptimizeByResampling(PtrLut, Intent, InputFormat, OutputFormat, dwFlags);\n    }\n\n    // Anything to optimize?\n    if ((*PtrLut) ->Elements == NULL) {\n        _cmsPipelineSetOptimizationParameters(*PtrLut, FastIdentity16, (void*) *PtrLut, NULL, NULL);\n        return TRUE;\n    }\n\n    // Named color pipelines cannot be optimized \n    for (mpe = cmsPipelineGetPtrToFirstStage(*PtrLut);\n        mpe != NULL;\n        mpe = cmsStageNext(mpe)) {        \n            if (cmsStageType(mpe) == cmsSigNamedColorElemType) return FALSE;\n    }\n\n    // Try to get rid of identities and trivial conversions.\n    AnySuccess = PreOptimize(*PtrLut);\n\n    // After removal do we end with an identity?\n    if ((*PtrLut) ->Elements == NULL) {\n        _cmsPipelineSetOptimizationParameters(*PtrLut, FastIdentity16, (void*) *PtrLut, NULL, NULL);\n        return TRUE;\n    }\n\n    // Do not optimize, keep all precision\n    if (*dwFlags & cmsFLAGS_NOOPTIMIZE)\n        return FALSE;\n\n    // Try plug-in optimizations \n    for (Opts = ctx->OptimizationCollection;\n         Opts != NULL;\n         Opts = Opts ->Next) {\n\n            // If one schema succeeded, we are done\n            if (Opts ->OptimizePtr(PtrLut, Intent, InputFormat, OutputFormat, dwFlags)) {\n\n                return TRUE;    // Optimized!\n            }\n    }\n\n   // Try built-in optimizations \n    for (Opts = DefaultOptimization;\n         Opts != NULL;\n         Opts = Opts ->Next) {\n\n            if (Opts ->OptimizePtr(PtrLut, Intent, InputFormat, OutputFormat, dwFlags)) {\n\n                return TRUE;  \n            }\n    }\n\n    // Only simple optimizations succeeded\n    return AnySuccess;\n}",
          "fn_code_pos": [
            [
              1904,
              0
            ],
            [
              1974,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsOptimizePipeline",
            "parameters": {
              "ContextID": "cmsContext",
              "PtrLut": "cmsPipeline",
              "Intent": "cmsUInt32Number",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "Prelin16dup(cmsContext ContextID, const void* ptr)",
          "fn_dec_pos": [
            [
              336,
              6
            ],
            [
              336,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Prelin16dup",
            "parameters": {
              "ContextID": "cmsContext",
              "ptr": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PrelinOpt16alloc(cmsContext ContextID,\n                               const cmsInterpParams* ColorMap,\n                               cmsUInt32Number nInputs, cmsToneCurve** In,\n                               cmsUInt32Number nOutputs, cmsToneCurve** Out )",
          "fn_dec_pos": [
            [
              351,
              14
            ],
            [
              354,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrelinOpt16alloc",
            "parameters": {
              "ContextID": "cmsContext",
              "ColorMap": "cmsInterpParams",
              "nInputs": "cmsUInt32Number",
              "In": "cmsToneCurve",
              "nOutputs": "cmsUInt32Number",
              "Out": "cmsToneCurve"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PrelinOpt8alloc(cmsContext ContextID, const cmsInterpParams* p, cmsToneCurve* G[3])",
          "fn_dec_pos": [
            [
              851,
              13
            ],
            [
              851,
              96
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrelinOpt8alloc",
            "parameters": {
              "ContextID": "cmsContext",
              "p": "cmsInterpParams",
              "G": "cmsToneCurve"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Prelin8dup(cmsContext ContextID, const void* ptr)",
          "fn_dec_pos": [
            [
              909,
              6
            ],
            [
              909,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Prelin8dup",
            "parameters": {
              "ContextID": "cmsContext",
              "ptr": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CurvesDup(cmsContext ContextID, const void* ptr)",
          "fn_dec_pos": [
            [
              1268,
              6
            ],
            [
              1268,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CurvesDup",
            "parameters": {
              "ContextID": "cmsContext",
              "ptr": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CurvesAlloc(cmsContext ContextID, cmsUInt32Number nCurves, cmsUInt32Number nElements, cmsToneCurve** G)",
          "fn_dec_pos": [
            [
              1286,
              14
            ],
            [
              1286,
              117
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CurvesAlloc",
            "parameters": {
              "ContextID": "cmsContext",
              "nCurves": "cmsUInt32Number",
              "nElements": "cmsUInt32Number",
              "G": "cmsToneCurve"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DupMatShaper(cmsContext ContextID, const void* Data)",
          "fn_dec_pos": [
            [
              1517,
              6
            ],
            [
              1517,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DupMatShaper",
            "parameters": {
              "ContextID": "cmsContext",
              "Data": "void"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\n    cmsContext ContextID;\n\n    const cmsInterpParams* p;   // Tetrahedrical interpolation parameters. This is a not-owned pointer.\n\n    cmsUInt16Number rx[256], ry[256], rz[256];\n    cmsUInt32Number X0[256], Y0[256], Z0[256];  // Precomputed nodes and offsets for 8-bit input data\n\n\n} Prelin8Data;",
          {
            "ContextID": "cmsContext",
            "cmsInterpParams": "const",
            "rx[256]": "cmsUInt16Number",
            "X0[256]": "cmsUInt32Number"
          },
          "Prelin8Data",
          [
            32,
            0
          ],
          [
            42,
            14
          ]
        ],
        [
          "typedef struct {\n\n    cmsContext ContextID;\n\n    // Number of channels\n    cmsUInt32Number nInputs;\n    cmsUInt32Number nOutputs;\n\n    _cmsInterpFn16 EvalCurveIn16[MAX_INPUT_DIMENSIONS];       // The maximum number of input channels is known in advance\n    cmsInterpParams*  ParamsCurveIn16[MAX_INPUT_DIMENSIONS];\n\n    _cmsInterpFn16 EvalCLUT;            // The evaluator for 3D grid\n    const cmsInterpParams* CLUTparams;  // (not-owned pointer)\n\n\n    _cmsInterpFn16* EvalCurveOut16;       // Points to an array of curve evaluators in 16 bits (not-owned pointer)\n    cmsInterpParams**  ParamsCurveOut16;  // Points to an array of references to interpolation params (not-owned pointer)\n\n\n} Prelin16Data;",
          {
            "ContextID": "cmsContext",
            "nInputs": "cmsUInt32Number",
            "nOutputs": "cmsUInt32Number",
            "EvalCurveIn16[MAX_INPUT_DIMENSIONS]": "_cmsInterpFn16",
            "*  ParamsCurveIn16[MAX_INPUT_DIMENSIONS]": "cmsInterpParams",
            "EvalCLUT": "_cmsInterpFn16",
            "cmsInterpParams": "const",
            "* EvalCurveOut16": "_cmsInterpFn16",
            "**  ParamsCurveOut16": "cmsInterpParams"
          },
          "Prelin16Data",
          [
            46,
            0
          ],
          [
            65,
            15
          ]
        ],
        [
          "typedef struct {\n\n    cmsContext ContextID;\n\n    cmsS1Fixed14Number Shaper1R[256];  // from 0..255 to 1.14  (0.0...1.0)\n    cmsS1Fixed14Number Shaper1G[256];\n    cmsS1Fixed14Number Shaper1B[256];\n\n    cmsS1Fixed14Number Mat[3][3];     // n.14 to n.14 (needs a saturation after that)\n    cmsS1Fixed14Number Off[3];\n\n    cmsUInt16Number Shaper2R[16385];    // 1.14 to 0..255\n    cmsUInt16Number Shaper2G[16385];\n    cmsUInt16Number Shaper2B[16385];\n\n} MatShaper8Data;",
          {
            "ContextID": "cmsContext",
            "Shaper1R[256]": "cmsS1Fixed14Number",
            "Shaper1G[256]": "cmsS1Fixed14Number",
            "Shaper1B[256]": "cmsS1Fixed14Number",
            "Mat[3][3]": "cmsS1Fixed14Number",
            "Off[3]": "cmsS1Fixed14Number",
            "Shaper2R[16385]": "cmsUInt16Number",
            "Shaper2G[16385]": "cmsUInt16Number",
            "Shaper2B[16385]": "cmsUInt16Number"
          },
          "MatShaper8Data",
          [
            74,
            0
          ],
          [
            89,
            17
          ]
        ],
        [
          "typedef struct {\n\n    cmsContext ContextID;\n\n    cmsUInt32Number nCurves;      // Number of curves\n    cmsUInt32Number nElements;    // Elements in curves\n    cmsUInt16Number** Curves;     // Points to a dynamically  allocated array\n\n} Curves16Data;",
          {
            "ContextID": "cmsContext",
            "nCurves": "cmsUInt32Number",
            "nElements": "cmsUInt32Number",
            "** Curves": "cmsUInt16Number"
          },
          "Curves16Data",
          [
            92,
            0
          ],
          [
            100,
            15
          ]
        ],
        [
          "typedef struct _cmsOptimizationCollection_st {\n\n    _cmsOPToptimizeFn  OptimizePtr;\n\n    struct _cmsOptimizationCollection_st *Next;\n\n} _cmsOptimizationCollection;",
          {
            "OptimizePtr": "_cmsOPToptimizeFn",
            "*Next": "struct _cmsOptimizationCollection_st"
          },
          "_cmsOptimizationCollection",
          [
            1797,
            0
          ],
          [
            1803,
            29
          ]
        ],
        [
          "typedef struct {\n\n    cmsContext ContextID;\n\n    const cmsInterpParams* p;   // Tetrahedrical interpolation parameters. This is a not-owned pointer.\n\n    cmsUInt16Number rx[256], ry[256], rz[256];\n    cmsUInt32Number X0[256], Y0[256], Z0[256];  // Precomputed nodes and offsets for 8-bit input data\n\n\n} Prelin8Data;",
          {
            "ContextID": "cmsContext",
            "cmsInterpParams": "const",
            "rx[256]": "cmsUInt16Number",
            "X0[256]": "cmsUInt32Number"
          },
          "Prelin8Data",
          [
            32,
            0
          ],
          [
            42,
            14
          ]
        ],
        [
          "typedef struct {\n\n    cmsContext ContextID;\n\n    // Number of channels\n    cmsUInt32Number nInputs;\n    cmsUInt32Number nOutputs;\n\n    _cmsInterpFn16 EvalCurveIn16[MAX_INPUT_DIMENSIONS];       // The maximum number of input channels is known in advance\n    cmsInterpParams*  ParamsCurveIn16[MAX_INPUT_DIMENSIONS];\n\n    _cmsInterpFn16 EvalCLUT;            // The evaluator for 3D grid\n    const cmsInterpParams* CLUTparams;  // (not-owned pointer)\n\n\n    _cmsInterpFn16* EvalCurveOut16;       // Points to an array of curve evaluators in 16 bits (not-owned pointer)\n    cmsInterpParams**  ParamsCurveOut16;  // Points to an array of references to interpolation params (not-owned pointer)\n\n\n} Prelin16Data;",
          {
            "ContextID": "cmsContext",
            "nInputs": "cmsUInt32Number",
            "nOutputs": "cmsUInt32Number",
            "EvalCurveIn16[MAX_INPUT_DIMENSIONS]": "_cmsInterpFn16",
            "*  ParamsCurveIn16[MAX_INPUT_DIMENSIONS]": "cmsInterpParams",
            "EvalCLUT": "_cmsInterpFn16",
            "cmsInterpParams": "const",
            "* EvalCurveOut16": "_cmsInterpFn16",
            "**  ParamsCurveOut16": "cmsInterpParams"
          },
          "Prelin16Data",
          [
            46,
            0
          ],
          [
            65,
            15
          ]
        ],
        [
          "typedef struct {\n\n    cmsContext ContextID;\n\n    cmsS1Fixed14Number Shaper1R[256];  // from 0..255 to 1.14  (0.0...1.0)\n    cmsS1Fixed14Number Shaper1G[256];\n    cmsS1Fixed14Number Shaper1B[256];\n\n    cmsS1Fixed14Number Mat[3][3];     // n.14 to n.14 (needs a saturation after that)\n    cmsS1Fixed14Number Off[3];\n\n    cmsUInt16Number Shaper2R[16385];    // 1.14 to 0..255\n    cmsUInt16Number Shaper2G[16385];\n    cmsUInt16Number Shaper2B[16385];\n\n} MatShaper8Data;",
          {
            "ContextID": "cmsContext",
            "Shaper1R[256]": "cmsS1Fixed14Number",
            "Shaper1G[256]": "cmsS1Fixed14Number",
            "Shaper1B[256]": "cmsS1Fixed14Number",
            "Mat[3][3]": "cmsS1Fixed14Number",
            "Off[3]": "cmsS1Fixed14Number",
            "Shaper2R[16385]": "cmsUInt16Number",
            "Shaper2G[16385]": "cmsUInt16Number",
            "Shaper2B[16385]": "cmsUInt16Number"
          },
          "MatShaper8Data",
          [
            74,
            0
          ],
          [
            89,
            17
          ]
        ],
        [
          "typedef struct {\n\n    cmsContext ContextID;\n\n    cmsUInt32Number nCurves;      // Number of curves\n    cmsUInt32Number nElements;    // Elements in curves\n    cmsUInt16Number** Curves;     // Points to a dynamically  allocated array\n\n} Curves16Data;",
          {
            "ContextID": "cmsContext",
            "nCurves": "cmsUInt32Number",
            "nElements": "cmsUInt32Number",
            "** Curves": "cmsUInt16Number"
          },
          "Curves16Data",
          [
            92,
            0
          ],
          [
            100,
            15
          ]
        ],
        [
          "typedef struct _cmsOptimizationCollection_st {\n\n    _cmsOPToptimizeFn  OptimizePtr;\n\n    struct _cmsOptimizationCollection_st *Next;\n\n} _cmsOptimizationCollection;",
          {
            "OptimizePtr": "_cmsOPToptimizeFn",
            "*Next": "struct _cmsOptimizationCollection_st"
          },
          "_cmsOptimizationCollection",
          [
            1797,
            0
          ],
          [
            1803,
            29
          ]
        ],
        [
          "struct _cmsOptimizationCollection_st",
          {},
          "",
          [
            1801,
            4
          ],
          [
            1801,
            40
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            1821,
            31
          ],
          [
            1821,
            56
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            1822,
            37
          ],
          [
            1822,
            62
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            1856,
            39
          ],
          [
            1856,
            64
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            1857,
            47
          ],
          [
            1857,
            72
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmscgats.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nstring* StringAlloc(cmsIT8* it8, int max)\n{\n    string* s = (string*) AllocChunk(it8, sizeof(string));\n    if (s == NULL) return NULL;\n\n    s->it8 = it8;\n    s->max = max;\n    s->len = 0;\n    s->begin = (char*) AllocChunk(it8, s->max);\n\n    return s;\n}",
          "fn_code_pos": [
            [
              399,
              0
            ],
            [
              411,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "StringAlloc",
            "parameters": {
              "it8": "cmsIT8",
              "max": "int"
            },
            "return_type": "string"
          }
        },
        {
          "fn_code": "static\nvoid StringClear(string* s)\n{\n    s->len = 0;    \n    s->begin[0] = 0;\n}",
          "fn_code_pos": [
            [
              413,
              0
            ],
            [
              418,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "StringClear",
            "parameters": {
              "s": "string"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool StringAppend(string* s, char c)\n{\n    if (s->len + 1 >= s->max)\n    {\n        char* new_ptr;\n\n        s->max *= 10;\n        new_ptr = (char*) AllocChunk(s->it8, s->max);\n        if (new_ptr == NULL) return FALSE;\n\n        if (new_ptr != NULL && s->begin != NULL)\n            memcpy(new_ptr, s->begin, s->len);\n\n        s->begin = new_ptr;\n    }\n\n    if (s->begin != NULL)\n    {\n        s->begin[s->len++] = c;\n        s->begin[s->len] = 0;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              420,
              0
            ],
            [
              444,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "StringAppend",
            "parameters": {
              "s": "string",
              "c": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nchar* StringPtr(string* s)\n{\n    return s->begin;\n}",
          "fn_code_pos": [
            [
              446,
              0
            ],
            [
              450,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "StringPtr",
            "parameters": {
              "s": "string"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static\ncmsBool StringCat(string* s, const char* c)\n{\n    while (*c)\n    {\n        if (!StringAppend(s, *c)) return FALSE;\n        c++;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              452,
              0
            ],
            [
              462,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "StringCat",
            "parameters": {
              "s": "string",
              "c": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool isseparator(int c)\n{\n    return (c == ' ') || (c == '\\t');\n}",
          "fn_code_pos": [
            [
              466,
              0
            ],
            [
              470,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "isseparator",
            "parameters": {
              "c": "int"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool ismiddle(int c)\n{\n   return (!isseparator(c) && (c != '#') && (c !='\\\"') && (c != '\\'') && (c > 32) && (c < 127));\n}",
          "fn_code_pos": [
            [
              473,
              0
            ],
            [
              477,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ismiddle",
            "parameters": {
              "c": "int"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool isidchar(int c)\n{\n   return isalnum(c) || ismiddle(c);\n}",
          "fn_code_pos": [
            [
              480,
              0
            ],
            [
              484,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "isidchar",
            "parameters": {
              "c": "int"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool isfirstidchar(int c)\n{\n     return c != '-' && !isdigit(c) && ismiddle(c);\n}",
          "fn_code_pos": [
            [
              487,
              0
            ],
            [
              491,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "isfirstidchar",
            "parameters": {
              "c": "int"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool isabsolutepath(const char *path)\n{\n    char ThreeChars[4];\n\n    if(path == NULL)\n        return FALSE;\n    if (path[0] == 0)\n        return FALSE;\n\n    strncpy(ThreeChars, path, 3);\n    ThreeChars[3] = 0;\n\n    if(ThreeChars[0] == DIR_CHAR)\n        return TRUE;\n\n#ifdef  CMS_IS_WINDOWS_\n    if (isalpha((int) ThreeChars[0]) && ThreeChars[1] == ':')\n        return TRUE;\n#endif\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              494,
              0
            ],
            [
              515,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "isabsolutepath",
            "parameters": {
              "path": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool BuildAbsolutePath(const char *relPath, const char *basePath, char *buffer, cmsUInt32Number MaxLen)\n{\n    char *tail;\n    cmsUInt32Number len;\n\n    // Already absolute?\n    if (isabsolutepath(relPath)) {\n\n        memcpy(buffer, relPath, MaxLen);\n        buffer[MaxLen-1] = 0;\n        return TRUE;\n    }\n\n    // No, search for last\n    memcpy(buffer, basePath, MaxLen);\n    buffer[MaxLen-1] = 0;\n\n    tail = strrchr(buffer, DIR_CHAR);\n    if (tail == NULL) return FALSE;    // Is not absolute and has no separators??\n\n    len = (cmsUInt32Number) (tail - buffer);\n    if (len >= MaxLen) return FALSE;\n\n    // No need to assure zero terminator over here\n    strncpy(tail + 1, relPath, MaxLen - len);\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              520,
              0
            ],
            [
              548,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BuildAbsolutePath",
            "parameters": {
              "relPath": "char",
              "basePath": "char",
              "buffer": "char",
              "MaxLen": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nconst char* NoMeta(const char* str)\n{\n    if (strchr(str, '%') != NULL)\n        return \"**** CORRUPTED FORMAT STRING ***\";\n\n    return str;\n}",
          "fn_code_pos": [
            [
              552,
              0
            ],
            [
              559,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NoMeta",
            "parameters": {
              "str": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static\ncmsBool SynError(cmsIT8* it8, const char *Txt, ...)\n{\n    char Buffer[256], ErrMsg[1024];\n    va_list args;\n\n    va_start(args, Txt);\n    vsnprintf(Buffer, 255, Txt, args);\n    Buffer[255] = 0;\n    va_end(args);\n\n    snprintf(ErrMsg, 1023, \"%s: Line %d, %s\", it8->FileStack[it8 ->IncludeSP]->FileName, it8->lineno, Buffer);\n    ErrMsg[1023] = 0;\n    it8->sy = SSYNERROR;\n    cmsSignalError(it8 ->ContextID, cmsERROR_CORRUPTION_DETECTED, \"%s\", ErrMsg);\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              562,
              0
            ],
            [
              578,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SynError",
            "parameters": {
              "it8": "cmsIT8",
              "Txt": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool Check(cmsIT8* it8, SYMBOL sy, const char* Err)\n{\n        if (it8 -> sy != sy)\n                return SynError(it8, NoMeta(Err));\n        return TRUE;\n}",
          "fn_code_pos": [
            [
              581,
              0
            ],
            [
              587,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check",
            "parameters": {
              "it8": "cmsIT8",
              "sy": "SYMBOL",
              "Err": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid NextCh(cmsIT8* it8)\n{\n    if (it8 -> FileStack[it8 ->IncludeSP]->Stream) {\n\n        it8 ->ch = fgetc(it8 ->FileStack[it8 ->IncludeSP]->Stream);\n\n        if (feof(it8 -> FileStack[it8 ->IncludeSP]->Stream))  {\n\n            if (it8 ->IncludeSP > 0) {\n\n                fclose(it8 ->FileStack[it8->IncludeSP--]->Stream);\n                it8 -> ch = ' ';                            // Whitespace to be ignored\n\n            } else\n                it8 ->ch = 0;   // EOF\n        }\n    }\n    else {\n        it8->ch = *it8->Source;\n        if (it8->ch) it8->Source++;\n    }\n}",
          "fn_code_pos": [
            [
              590,
              0
            ],
            [
              612,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NextCh",
            "parameters": {
              "it8": "cmsIT8"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nSYMBOL BinSrchKey(const char *id, int NumKeys, const KEYWORD* TabKeys)\n{\n    int l = 1;\n    int r = NumKeys;\n    int x, res;\n\n    while (r >= l)\n    {\n        x = (l+r)/2;\n        res = cmsstrcasecmp(id, TabKeys[x-1].id);\n        if (res == 0) return TabKeys[x-1].sy;\n        if (res < 0) r = x - 1;\n        else l = x + 1;\n    }\n\n    return SUNDEFINED;\n}",
          "fn_code_pos": [
            [
              616,
              0
            ],
            [
              633,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BinSrchKey",
            "parameters": {
              "id": "char",
              "NumKeys": "int",
              "TabKeys": "KEYWORD"
            },
            "return_type": "SYMBOL"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number xpow10(int n)\n{\n    return pow(10, (cmsFloat64Number) n);\n}",
          "fn_code_pos": [
            [
              637,
              0
            ],
            [
              641,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "xpow10",
            "parameters": {
              "n": "int"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\nvoid ReadReal(cmsIT8* it8, cmsInt32Number inum)\n{\n    it8->dnum = (cmsFloat64Number)inum;\n\n    while (isdigit(it8->ch)) {\n\n        it8->dnum = (cmsFloat64Number)it8->dnum * 10.0 + (cmsFloat64Number)(it8->ch - '0');\n        NextCh(it8);\n    }\n\n    if (it8->ch == '.') {        // Decimal point\n\n        cmsFloat64Number frac = 0.0;      // fraction\n        int prec = 0;                     // precision\n\n        NextCh(it8);               // Eats dec. point\n\n        while (isdigit(it8->ch)) {\n\n            frac = frac * 10.0 + (cmsFloat64Number)(it8->ch - '0');\n            prec++;\n            NextCh(it8);\n        }\n\n        it8->dnum = it8->dnum + (frac / xpow10(prec));\n    }\n\n    // Exponent, example 34.00E+20\n    if (toupper(it8->ch) == 'E') {\n\n        cmsInt32Number e;\n        cmsInt32Number sgn;\n\n        NextCh(it8); sgn = 1;\n\n        if (it8->ch == '-') {\n\n            sgn = -1; NextCh(it8);\n        }\n        else\n            if (it8->ch == '+') {\n\n                sgn = +1;\n                NextCh(it8);\n            }\n\n        e = 0;\n        while (isdigit(it8->ch)) {\n\n            cmsInt32Number digit = (it8->ch - '0');\n\n            if ((cmsFloat64Number)e * 10.0 + (cmsFloat64Number)digit < (cmsFloat64Number)+2147483647.0)\n                e = e * 10 + digit;\n\n            NextCh(it8);\n        }\n\n        e = sgn*e;\n        it8->dnum = it8->dnum * xpow10(e);\n    }\n}",
          "fn_code_pos": [
            [
              645,
              0
            ],
            [
              706,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadReal",
            "parameters": {
              "it8": "cmsIT8",
              "inum": "cmsInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number ParseFloatNumber(const char *Buffer)\n{\n    cmsFloat64Number dnum = 0.0;\n    int sign = 1;\n\n    // keep safe\n    if (Buffer == NULL) return 0.0;\n\n    if (*Buffer == '-' || *Buffer == '+') {\n\n        sign = (*Buffer == '-') ? -1 : 1;\n        Buffer++;\n    }\n\n\n    while (*Buffer && isdigit((int)*Buffer)) {\n\n        dnum = dnum * 10.0 + (*Buffer - '0');\n        if (*Buffer) Buffer++;\n    }\n\n    if (*Buffer == '.') {\n\n        cmsFloat64Number frac = 0.0;      // fraction\n        int prec = 0;                     // precision\n\n        if (*Buffer) Buffer++;\n\n        while (*Buffer && isdigit((int)*Buffer)) {\n\n            frac = frac * 10.0 + (*Buffer - '0');\n            prec++;\n            if (*Buffer) Buffer++;\n        }\n\n        dnum = dnum + (frac / xpow10(prec));\n    }\n\n    // Exponent, example 34.00E+20\n    if (*Buffer && toupper(*Buffer) == 'E') {\n\n        int e;\n        int sgn;\n\n        if (*Buffer) Buffer++;\n        sgn = 1;\n\n        if (*Buffer == '-') {\n\n            sgn = -1;\n            if (*Buffer) Buffer++;\n        }\n        else\n            if (*Buffer == '+') {\n\n                sgn = +1;\n                if (*Buffer) Buffer++;\n            }\n\n        e = 0;\n        while (*Buffer && isdigit((int)*Buffer)) {\n\n            cmsInt32Number digit = (*Buffer - '0');\n\n            if ((cmsFloat64Number)e * 10.0 + digit < (cmsFloat64Number)+2147483647.0)\n                e = e * 10 + digit;\n\n            if (*Buffer) Buffer++;\n        }\n\n        e = sgn*e;\n        dnum = dnum * xpow10(e);\n    }\n\n    return sign * dnum;\n}",
          "fn_code_pos": [
            [
              711,
              0
            ],
            [
              787,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ParseFloatNumber",
            "parameters": {
              "Buffer": "char"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\nvoid InStringSymbol(cmsIT8* it8)\n{\n    while (isseparator(it8->ch))\n        NextCh(it8);\n\n    if (it8->ch == '\\'' || it8->ch == '\\\"')\n    {\n        int sng;\n\n        sng = it8->ch;\n        StringClear(it8->str);\n\n        NextCh(it8);\n\n        while (it8->ch != sng) {\n\n            if (it8->ch == '\\n' || it8->ch == '\\r' || it8->ch == 0) break;\n            else {\n                if (!StringAppend(it8->str, (char)it8->ch)) {\n\n                    SynError(it8, \"Out of memory\");                    \n                    return;\n                }\n\n                NextCh(it8);\n            }\n        }\n\n        it8->sy = SSTRING;\n        NextCh(it8);        \n    }\n    else\n        SynError(it8, \"String expected\");\n\n}",
          "fn_code_pos": [
            [
              791,
              0
            ],
            [
              826,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "InStringSymbol",
            "parameters": {
              "it8": "cmsIT8"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid InSymbol(cmsIT8* it8)\n{\n    SYMBOL key;\n    \n    do {\n\n        while (isseparator(it8->ch))\n            NextCh(it8);\n\n        if (isfirstidchar(it8->ch)) {          // Identifier\n\n            StringClear(it8->id);\n\n            do {\n\n                if (!StringAppend(it8->id, (char)it8->ch)) {\n\n                    SynError(it8, \"Out of memory\");                    \n                    return;\n                }\n\n                NextCh(it8);\n\n            } while (isidchar(it8->ch));\n\n\n            key = BinSrchKey(StringPtr(it8->id),\n                    it8->IsCUBE ? NUMKEYS_CUBE : NUMKEYS_IT8,\n                    it8->IsCUBE ? TabKeysCUBE : TabKeysIT8);\n            if (key == SUNDEFINED) it8->sy = SIDENT;\n            else it8->sy = key;\n\n        }\n        else                         // Is a number?\n            if (isdigit(it8->ch) || it8->ch == '.' || it8->ch == '-' || it8->ch == '+')\n            {\n                int sign = 1;\n\n                if (it8->ch == '-') {\n                    sign = -1;\n                    NextCh(it8);\n                }\n\n                it8->inum = 0;\n                it8->sy   = SINUM;\n\n                if (it8->ch == '0') {          // 0xnnnn (Hexa) or 0bnnnn (Binary)\n\n                    NextCh(it8);\n                    if (toupper(it8->ch) == 'X') {\n\n                        int j;\n\n                        NextCh(it8);\n                        while (isxdigit(it8->ch))\n                        {\n                            it8->ch = toupper(it8->ch);\n                            if (it8->ch >= 'A' && it8->ch <= 'F')  j = it8->ch -'A'+10;\n                            else j = it8->ch - '0';\n\n                            if ((cmsFloat64Number) it8->inum * 16.0 + (cmsFloat64Number) j > (cmsFloat64Number)+2147483647.0)\n                            {\n                                SynError(it8, \"Invalid hexadecimal number\");\n                                return;\n                            }\n\n                            it8->inum = it8->inum * 16 + j;\n                            NextCh(it8);\n                        }\n                        return;\n                    }\n\n                    if (toupper(it8->ch) == 'B') {  // Binary\n\n                        int j;\n\n                        NextCh(it8);\n                        while (it8->ch == '0' || it8->ch == '1')\n                        {\n                            j = it8->ch - '0';\n\n                            if ((cmsFloat64Number) it8->inum * 2.0 + j > (cmsFloat64Number)+2147483647.0)\n                            {\n                                SynError(it8, \"Invalid binary number\");                                \n                                return;\n                            }\n\n                            it8->inum = it8->inum * 2 + j;\n                            NextCh(it8);\n                        }\n                        return;\n                    }\n                }\n\n\n                while (isdigit(it8->ch)) {\n\n                    cmsInt32Number digit = (it8->ch - '0');\n\n                    if ((cmsFloat64Number) it8->inum * 10.0 + (cmsFloat64Number) digit > (cmsFloat64Number) +2147483647.0) {\n                        ReadReal(it8, it8->inum);\n                        it8->sy = SDNUM;\n                        it8->dnum *= sign;\n                        return;\n                    }\n\n                    it8->inum = it8->inum * 10 + digit;\n                    NextCh(it8);\n                }\n\n                if (it8->ch == '.') {\n\n                    ReadReal(it8, it8->inum);\n                    it8->sy = SDNUM;\n                    it8->dnum *= sign;\n                    return;\n                }\n\n                it8 -> inum *= sign;\n\n                // Special case. Numbers followed by letters are taken as identifiers\n\n                if (isidchar(it8 ->ch)) {\n\n                    char buffer[127];\n\n                    if (it8 ->sy == SINUM) {\n\n                        snprintf(buffer, sizeof(buffer), \"%d\", it8->inum);\n                    }\n                    else {\n\n                        snprintf(buffer, sizeof(buffer), it8 ->DoubleFormatter, it8->dnum);\n                    }\n\n                    StringClear(it8->id);\n                    if (!StringCat(it8->id, buffer)) {\n\n                        SynError(it8, \"Out of memory\");                        \n                        return;\n                    }\n\n                    do {\n\n                        if (!StringAppend(it8->id, (char)it8->ch)) {\n\n                            SynError(it8, \"Out of memory\");                            \n                            return;\n                        }\n\n                        NextCh(it8);\n\n                    } while (isidchar(it8->ch));\n\n                    it8->sy = SIDENT;\n                }\n                return;\n\n            }\n            else\n                switch ((int) it8->ch) {\n        \n        // Eof stream markers\n        case '\\x1a':\n        case 0:\n        case -1:\n            it8->sy = SEOF;\n            break;\n\n\n        // Next line\n        case '\\r':\n            NextCh(it8);\n            if (it8->ch == '\\n')\n                NextCh(it8);\n            it8->sy = SEOLN;\n            it8->lineno++;\n            break;\n\n        case '\\n':\n            NextCh(it8);\n            it8->sy = SEOLN;\n            it8->lineno++;\n            break;\n\n        // Comment\n        case '#':\n            NextCh(it8);\n            while (it8->ch && it8->ch != '\\n' && it8->ch != '\\r')\n                NextCh(it8);\n\n            it8->sy = SCOMMENT;\n            break;\n\n        // String.\n        case '\\'':\n        case '\\\"':\n            InStringSymbol(it8);\n            break;\n\n\n        default:\n            SynError(it8, \"Unrecognized character: 0x%x\", it8 ->ch);            \n            return;\n            }\n\n    } while (it8->sy == SCOMMENT);\n\n    // Handle the include special token\n\n    if (it8 -> sy == SINCLUDE) {\n\n                FILECTX* FileNest;\n\n                if(it8 -> IncludeSP >= (MAXINCLUDE-1)) {\n\n                    SynError(it8, \"Too many recursion levels\");                    \n                    return;\n                }\n\n                InStringSymbol(it8);\n                if (!Check(it8, SSTRING, \"Filename expected\"))                                    \n                    return;\n                \n\n                FileNest = it8 -> FileStack[it8 -> IncludeSP + 1];\n                if(FileNest == NULL) {\n\n                    FileNest = it8 ->FileStack[it8 -> IncludeSP + 1] = (FILECTX*)AllocChunk(it8, sizeof(FILECTX));\n                    if (FileNest == NULL) {\n\n                        SynError(it8, \"Out of memory\");                        \n                        return;\n                    }\n                }\n\n                if (BuildAbsolutePath(StringPtr(it8->str),\n                                      it8->FileStack[it8->IncludeSP]->FileName,\n                                      FileNest->FileName, cmsMAX_PATH-1) == FALSE) {\n\n                    SynError(it8, \"File path too long\");                    \n                    return;\n                }\n\n                FileNest->Stream = fopen(FileNest->FileName, \"rt\");\n                if (FileNest->Stream == NULL) {\n\n                        SynError(it8, \"File %s not found\", FileNest->FileName);                        \n                        return;\n                }\n                it8->IncludeSP++;\n\n                it8 ->ch = ' ';\n                InSymbol(it8);\n    }\n\n}",
          "fn_code_pos": [
            [
              829,
              0
            ],
            [
              1086,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "InSymbol",
            "parameters": {
              "it8": "cmsIT8"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool CheckEOLN(cmsIT8* it8)\n{\n    if (!Check(it8, SEOLN, \"Expected separator\")) return FALSE;\n    while (it8->sy == SEOLN)\n        InSymbol(it8);\n    return TRUE;\n\n}",
          "fn_code_pos": [
            [
              1089,
              0
            ],
            [
              1097,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckEOLN",
            "parameters": {
              "it8": "cmsIT8"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid Skip(cmsIT8* it8, SYMBOL sy)\n{\n    if (it8->sy == sy && it8->sy != SEOF && it8->sy != SSYNERROR)\n        InSymbol(it8);\n}",
          "fn_code_pos": [
            [
              1101,
              0
            ],
            [
              1106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Skip",
            "parameters": {
              "it8": "cmsIT8",
              "sy": "SYMBOL"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid SkipEOLN(cmsIT8* it8)\n{\n    while (it8->sy == SEOLN) {\n        InSymbol(it8);\n    }\n}",
          "fn_code_pos": [
            [
              1110,
              0
            ],
            [
              1116,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SkipEOLN",
            "parameters": {
              "it8": "cmsIT8"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool GetVal(cmsIT8* it8, char* Buffer, cmsUInt32Number max, const char* ErrorTitle)\n{\n    switch (it8->sy) {\n\n    case SEOLN:   // Empty value\n                  Buffer[0]=0;\n                  break;\n    case SIDENT:  strncpy(Buffer, StringPtr(it8->id), max);\n                  Buffer[max-1]=0;\n                  break;\n    case SINUM:   snprintf(Buffer, max, \"%d\", it8 -> inum); break;\n    case SDNUM:   snprintf(Buffer, max, it8->DoubleFormatter, it8 -> dnum); break;\n    case SSTRING: strncpy(Buffer, StringPtr(it8->str), max);\n                  Buffer[max-1] = 0;\n                  break;\n\n\n    default:\n         return SynError(it8, \"%s\", ErrorTitle);\n    }\n\n    Buffer[max] = 0;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1120,
              0
            ],
            [
              1144,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetVal",
            "parameters": {
              "it8": "cmsIT8",
              "Buffer": "char",
              "max": "cmsUInt32Number",
              "ErrorTitle": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nTABLE* GetTable(cmsIT8* it8)\n{\n   if ((it8 -> nTable >= it8 ->TablesCount)) {\n\n           SynError(it8, \"Table %d out of sequence\", it8 -> nTable);\n           return it8 -> Tab;\n   }\n\n   return it8 ->Tab + it8 ->nTable;\n}",
          "fn_code_pos": [
            [
              1148,
              0
            ],
            [
              1158,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetTable",
            "parameters": {
              "it8": "cmsIT8"
            },
            "return_type": "TABLE"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsIT8Free(cmsHANDLE hIT8)\n{\n   cmsIT8* it8 = (cmsIT8*) hIT8;\n\n    if (it8 == NULL)\n        return;\n\n    if (it8->MemorySink) {\n\n        OWNEDMEM* p;\n        OWNEDMEM* n;\n\n        for (p = it8->MemorySink; p != NULL; p = n) {\n\n            n = p->Next;\n            if (p->Ptr) _cmsFree(it8 ->ContextID, p->Ptr);\n            _cmsFree(it8 ->ContextID, p);\n        }\n    }\n\n    if (it8->MemoryBlock)\n        _cmsFree(it8 ->ContextID, it8->MemoryBlock);\n\n    _cmsFree(it8 ->ContextID, it8);\n}",
          "fn_code_pos": [
            [
              1164,
              0
            ],
            [
              1188,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8Free",
            "parameters": {
              "hIT8": "cmsHANDLE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* AllocBigBlock(cmsIT8* it8, cmsUInt32Number size)\n{\n    OWNEDMEM* ptr1;\n    void* ptr = _cmsMallocZero(it8->ContextID, size);\n\n    if (ptr != NULL) {\n\n        ptr1 = (OWNEDMEM*) _cmsMallocZero(it8 ->ContextID, sizeof(OWNEDMEM));\n\n        if (ptr1 == NULL) {\n\n            _cmsFree(it8 ->ContextID, ptr);\n            return NULL;\n        }\n\n        ptr1-> Ptr        = ptr;\n        ptr1-> Next       = it8 -> MemorySink;\n        it8 -> MemorySink = ptr1;\n    }\n\n    return ptr;\n}",
          "fn_code_pos": [
            [
              1192,
              0
            ],
            [
              1214,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllocBigBlock",
            "parameters": {
              "it8": "cmsIT8",
              "size": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* AllocChunk(cmsIT8* it8, cmsUInt32Number size)\n{\n    cmsUInt32Number Free = it8 ->Allocator.BlockSize - it8 ->Allocator.Used;\n    cmsUInt8Number* ptr;\n\n    size = _cmsALIGNMEM(size);\n    if (size == 0) return NULL;\n\n    if (size > Free) {\n\n        cmsUInt8Number* new_block;\n\n        if (it8 -> Allocator.BlockSize == 0)\n\n                it8 -> Allocator.BlockSize = 20*1024;\n        else\n                it8 ->Allocator.BlockSize *= 2;\n\n        if (it8 ->Allocator.BlockSize < size)\n                it8 ->Allocator.BlockSize = size;\n\n        it8 ->Allocator.Used = 0;\n        new_block = (cmsUInt8Number*)AllocBigBlock(it8, it8->Allocator.BlockSize);\n        if (new_block == NULL) \n            return NULL;\n\n        it8->Allocator.Block = new_block;\n    }\n\n    if (it8->Allocator.Block == NULL)\n        return NULL;\n\n    ptr = it8 ->Allocator.Block + it8 ->Allocator.Used;\n    it8 ->Allocator.Used += size;\n\n    return (void*) ptr;\n}",
          "fn_code_pos": [
            [
              1218,
              0
            ],
            [
              1255,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllocChunk",
            "parameters": {
              "it8": "cmsIT8",
              "size": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nchar *AllocString(cmsIT8* it8, const char* str)\n{\n    cmsUInt32Number Size;\n    char *ptr;\n\n    if (str == NULL) return NULL;\n\n    Size = (cmsUInt32Number)strlen(str) + 1;\n\n    ptr = (char *) AllocChunk(it8, Size);\n    if (ptr) memcpy(ptr, str, Size-1);\n\n    return ptr;\n}",
          "fn_code_pos": [
            [
              1259,
              0
            ],
            [
              1273,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllocString",
            "parameters": {
              "it8": "cmsIT8",
              "str": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static\ncmsBool IsAvailableOnList(KEYVALUE* p, const char* Key, const char* Subkey, KEYVALUE** LastPtr)\n{\n    if (LastPtr) *LastPtr = p;\n\n    for (;  p != NULL; p = p->Next) {\n\n        if (LastPtr) *LastPtr = p;\n\n        if (*Key != '#') { // Comments are ignored\n\n            if (cmsstrcasecmp(Key, p->Keyword) == 0)\n                break;\n        }\n    }\n\n    if (p == NULL)\n        return FALSE;\n\n    if (Subkey == 0)\n        return TRUE;\n\n    for (; p != NULL; p = p->NextSubkey) {\n\n        if (p ->Subkey == NULL) continue;\n\n        if (LastPtr) *LastPtr = p;\n\n        if (cmsstrcasecmp(Subkey, p->Subkey) == 0)\n            return TRUE;\n    }\n\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              1277,
              0
            ],
            [
              1310,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsAvailableOnList",
            "parameters": {
              "p": "KEYVALUE",
              "Key": "char",
              "Subkey": "char",
              "LastPtr": "KEYVALUE"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nKEYVALUE* AddToList(cmsIT8* it8, KEYVALUE** Head, const char *Key, const char *Subkey, const char* xValue, WRITEMODE WriteAs)\n{\n    KEYVALUE* p;\n    KEYVALUE* last;\n\n\n    // Check if property is already in list\n\n    if (IsAvailableOnList(*Head, Key, Subkey, &p)) {\n\n        // This may work for editing properties\n\n        if (cmsstrcasecmp(Key, \"NUMBER_OF_FIELDS\") == 0 ||\n            cmsstrcasecmp(Key, \"NUMBER_OF_SETS\") == 0) {\n\n            SynError(it8, \"duplicate key <%s>\", Key);\n            return NULL;\n        }\n    }\n    else {\n\n        last = p;\n\n        // Allocate the container\n        p = (KEYVALUE*) AllocChunk(it8, sizeof(KEYVALUE));\n        if (p == NULL)\n        {\n            SynError(it8, \"AddToList: out of memory\");\n            return NULL;\n        }\n\n        // Store name and value\n        p->Keyword = AllocString(it8, Key);\n        p->Subkey = (Subkey == NULL) ? NULL : AllocString(it8, Subkey);\n\n        // Keep the container in our list\n        if (*Head == NULL) {\n            *Head = p;\n        }\n        else\n        {\n            if (Subkey != NULL && last != NULL) {\n\n                last->NextSubkey = p;\n\n                // If Subkey is not null, then last is the last property with the same key,\n                // but not necessarily is the last property in the list, so we need to move\n                // to the actual list end\n                while (last->Next != NULL)\n                         last = last->Next;\n            }\n\n            if (last != NULL) last->Next = p;\n        }\n\n        p->Next    = NULL;\n        p->NextSubkey = NULL;\n    }\n\n    p->WriteAs = WriteAs;\n\n    if (xValue != NULL) {\n\n        p->Value   = AllocString(it8, xValue);\n    }\n    else {\n        p->Value   = NULL;\n    }\n\n    return p;\n}",
          "fn_code_pos": [
            [
              1315,
              0
            ],
            [
              1386,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddToList",
            "parameters": {
              "it8": "cmsIT8",
              "Head": "KEYVALUE",
              "Key": "char",
              "Subkey": "char",
              "xValue": "char",
              "WriteAs": "WRITEMODE"
            },
            "return_type": "KEYVALUE"
          }
        },
        {
          "fn_code": "static\nKEYVALUE* AddAvailableProperty(cmsIT8* it8, const char* Key, WRITEMODE as)\n{\n    return AddToList(it8, &it8->ValidKeywords, Key, NULL, NULL, as);\n}",
          "fn_code_pos": [
            [
              1388,
              0
            ],
            [
              1392,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddAvailableProperty",
            "parameters": {
              "it8": "cmsIT8",
              "Key": "char",
              "as": "WRITEMODE"
            },
            "return_type": "KEYVALUE"
          }
        },
        {
          "fn_code": "static\nKEYVALUE* AddAvailableSampleID(cmsIT8* it8, const char* Key)\n{\n    return AddToList(it8, &it8->ValidSampleID, Key, NULL, NULL, WRITE_UNCOOKED);\n}",
          "fn_code_pos": [
            [
              1395,
              0
            ],
            [
              1399,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddAvailableSampleID",
            "parameters": {
              "it8": "cmsIT8",
              "Key": "char"
            },
            "return_type": "KEYVALUE"
          }
        },
        {
          "fn_code": "static\ncmsBool AllocTable(cmsIT8* it8)\n{\n    TABLE* t;\n\n    if (it8->TablesCount >= (MAXTABLES-1)) \n        return FALSE;\n\n    t = it8 ->Tab + it8 ->TablesCount;\n\n    t->HeaderList = NULL;\n    t->DataFormat = NULL;\n    t->Data       = NULL;\n\n    it8 ->TablesCount++;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1402,
              0
            ],
            [
              1418,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllocTable",
            "parameters": {
              "it8": "cmsIT8"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsInt32Number CMSEXPORT cmsIT8SetTable(cmsHANDLE  IT8, cmsUInt32Number nTable)\n{\n     cmsIT8* it8 = (cmsIT8*) IT8;\n\n     if (nTable >= it8 ->TablesCount) {\n\n         if (nTable == it8 ->TablesCount) {\n\n             if (!AllocTable(it8)) {\n                 SynError(it8, \"Too many tables\");\n                 return -1;\n             }\n         }\n         else {\n             SynError(it8, \"Table %d is out of sequence\", nTable);\n             return -1;\n         }\n     }\n\n     it8 ->nTable = nTable;\n\n     return (cmsInt32Number) nTable;\n}",
          "fn_code_pos": [
            [
              1421,
              0
            ],
            [
              1443,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetTable",
            "parameters": {
              "IT8": "cmsHANDLE",
              "nTable": "cmsUInt32Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "cmsHANDLE  CMSEXPORT cmsIT8Alloc(cmsContext ContextID)\n{\n    cmsIT8* it8;\n    cmsUInt32Number i;\n\n    it8 = (cmsIT8*) _cmsMallocZero(ContextID, sizeof(cmsIT8));\n    if (it8 == NULL) return NULL;\n\n    AllocTable(it8);\n\n    it8->MemoryBlock = NULL;\n    it8->MemorySink  = NULL;\n\n    it8->IsCUBE = FALSE;\n\n    it8 ->nTable = 0;\n\n    it8->ContextID = ContextID;\n    it8->Allocator.Used = 0;\n    it8->Allocator.Block = NULL;\n    it8->Allocator.BlockSize = 0;\n\n    it8->ValidKeywords = NULL;\n    it8->ValidSampleID = NULL;\n\n    it8 -> sy = SUNDEFINED;\n    it8 -> ch = ' ';\n    it8 -> Source = NULL;\n    it8 -> inum = 0;\n    it8 -> dnum = 0.0;\n\n    it8->FileStack[0] = (FILECTX*)AllocChunk(it8, sizeof(FILECTX));\n    it8->IncludeSP   = 0;\n    it8 -> lineno = 1;\n\n    it8->id = StringAlloc(it8, MAXSTR);\n    it8->str = StringAlloc(it8, MAXSTR);\n\n    strcpy(it8->DoubleFormatter, DEFAULT_DBL_FORMAT);\n    cmsIT8SetSheetType((cmsHANDLE) it8, \"CGATS.17\");\n\n    // Initialize predefined properties & data\n\n    for (i=0; i < NUMPREDEFINEDPROPS; i++)\n            AddAvailableProperty(it8, PredefinedProperties[i].id, PredefinedProperties[i].as);\n\n    for (i=0; i < NUMPREDEFINEDSAMPLEID; i++)\n            AddAvailableSampleID(it8, PredefinedSampleID[i]);\n\n\n   return (cmsHANDLE) it8;\n}",
          "fn_code_pos": [
            [
              1448,
              0
            ],
            [
              1499,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8Alloc",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "cmsHANDLE"
          }
        },
        {
          "fn_code": "const char* CMSEXPORT cmsIT8GetSheetType(cmsHANDLE hIT8)\n{\n        return GetTable((cmsIT8*) hIT8)->SheetType;\n}",
          "fn_code_pos": [
            [
              1502,
              0
            ],
            [
              1505,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetSheetType",
            "parameters": {
              "hIT8": "cmsHANDLE"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsIT8SetSheetType(cmsHANDLE hIT8, const char* Type)\n{\n        TABLE* t = GetTable((cmsIT8*) hIT8);\n\n        strncpy(t ->SheetType, Type, MAXSTR-1);\n        t ->SheetType[MAXSTR-1] = 0;\n        return TRUE;\n}",
          "fn_code_pos": [
            [
              1507,
              0
            ],
            [
              1514,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetSheetType",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "Type": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsIT8SetComment(cmsHANDLE hIT8, const char* Val)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n\n    if (!Val) return FALSE;\n    if (!*Val) return FALSE;\n\n    return AddToList(it8, &GetTable(it8)->HeaderList, \"# \", NULL, Val, WRITE_UNCOOKED) != NULL;\n}",
          "fn_code_pos": [
            [
              1516,
              0
            ],
            [
              1524,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetComment",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "Val": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsIT8SetPropertyStr(cmsHANDLE hIT8, const char* Key, const char *Val)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n\n    if (!Val) return FALSE;\n    if (!*Val) return FALSE;\n\n    return AddToList(it8, &GetTable(it8)->HeaderList, Key, NULL, Val, WRITE_STRINGIFY) != NULL;\n}",
          "fn_code_pos": [
            [
              1527,
              0
            ],
            [
              1535,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetPropertyStr",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "Key": "char",
              "Val": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsIT8SetPropertyDbl(cmsHANDLE hIT8, const char* cProp, cmsFloat64Number Val)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n    char Buffer[1024];\n\n    snprintf(Buffer, 1023, it8->DoubleFormatter, Val);\n\n    return AddToList(it8, &GetTable(it8)->HeaderList, cProp, NULL, Buffer, WRITE_UNCOOKED) != NULL;\n}",
          "fn_code_pos": [
            [
              1537,
              0
            ],
            [
              1545,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetPropertyDbl",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cProp": "char",
              "Val": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsIT8SetPropertyHex(cmsHANDLE hIT8, const char* cProp, cmsUInt32Number Val)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n    char Buffer[1024];\n\n    snprintf(Buffer, 1023, \"%u\", Val);\n\n    return AddToList(it8, &GetTable(it8)->HeaderList, cProp, NULL, Buffer, WRITE_HEXADECIMAL) != NULL;\n}",
          "fn_code_pos": [
            [
              1547,
              0
            ],
            [
              1555,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetPropertyHex",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cProp": "char",
              "Val": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsIT8SetPropertyUncooked(cmsHANDLE hIT8, const char* Key, const char* Buffer)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n\n    return AddToList(it8, &GetTable(it8)->HeaderList, Key, NULL, Buffer, WRITE_UNCOOKED) != NULL;\n}",
          "fn_code_pos": [
            [
              1557,
              0
            ],
            [
              1562,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetPropertyUncooked",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "Key": "char",
              "Buffer": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsIT8SetPropertyMulti(cmsHANDLE hIT8, const char* Key, const char* SubKey, const char *Buffer)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n\n    return AddToList(it8, &GetTable(it8)->HeaderList, Key, SubKey, Buffer, WRITE_PAIR) != NULL;\n}",
          "fn_code_pos": [
            [
              1564,
              0
            ],
            [
              1569,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetPropertyMulti",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "Key": "char",
              "SubKey": "char",
              "Buffer": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "const char* CMSEXPORT cmsIT8GetProperty(cmsHANDLE hIT8, const char* Key)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n    KEYVALUE* p;\n\n    if (IsAvailableOnList(GetTable(it8) -> HeaderList, Key, NULL, &p))\n    {\n        return p -> Value;\n    }\n    return NULL;\n}",
          "fn_code_pos": [
            [
              1572,
              0
            ],
            [
              1582,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetProperty",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "Key": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "cmsFloat64Number CMSEXPORT cmsIT8GetPropertyDbl(cmsHANDLE hIT8, const char* cProp)\n{\n    const char *v = cmsIT8GetProperty(hIT8, cProp);\n\n    if (v == NULL) return 0.0;\n\n    return ParseFloatNumber(v);\n}",
          "fn_code_pos": [
            [
              1585,
              0
            ],
            [
              1592,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetPropertyDbl",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cProp": "char"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "const char* CMSEXPORT cmsIT8GetPropertyMulti(cmsHANDLE hIT8, const char* Key, const char *SubKey)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n    KEYVALUE* p;\n\n    if (IsAvailableOnList(GetTable(it8) -> HeaderList, Key, SubKey, &p)) {\n        return p -> Value;\n    }\n    return NULL;\n}",
          "fn_code_pos": [
            [
              1594,
              0
            ],
            [
              1603,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetPropertyMulti",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "Key": "char",
              "SubKey": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number satoi(const char* b)\n{\n    int n;\n\n    if (b == NULL) return 0;\n\n    n = atoi(b);\n    if (n > 0x7ffffff0L) return 0x7ffffff0L;\n    if (n < -0x7ffffff0L) return -0x7ffffff0L;\n\n    return (cmsInt32Number)n;\n}",
          "fn_code_pos": [
            [
              1608,
              0
            ],
            [
              1620,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "satoi",
            "parameters": {
              "b": "char"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsBool AllocateDataFormat(cmsIT8* it8)\n{\n    cmsUInt32Number size;\n\n    TABLE* t = GetTable(it8);\n\n    if (t->DataFormat) return TRUE;    // Already allocated\n\n    t->nSamples = satoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n\n    if (t->nSamples <= 0 || t->nSamples > 0x7ffe) {\n\n        SynError(it8, \"Wrong NUMBER_OF_FIELDS\");\n        return FALSE;\n    }\n\n    size = ((cmsUInt32Number)t->nSamples + 1) * sizeof(char*);\n\n    t->DataFormat = (char**)AllocChunk(it8, size);\n    if (t->DataFormat == NULL) {\n\n        SynError(it8, \"Unable to allocate dataFormat array\");\n        return FALSE;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1623,
              0
            ],
            [
              1650,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllocateDataFormat",
            "parameters": {
              "it8": "cmsIT8"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nconst char *GetDataFormat(cmsIT8* it8, int n)\n{\n    TABLE* t = GetTable(it8);\n\n    if (t->DataFormat)\n        return t->DataFormat[n];\n\n    return NULL;\n}",
          "fn_code_pos": [
            [
              1652,
              0
            ],
            [
              1661,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetDataFormat",
            "parameters": {
              "it8": "cmsIT8",
              "n": "int"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static\ncmsBool SetDataFormat(cmsIT8* it8, int n, const char *label)\n{\n    TABLE* t = GetTable(it8);\n\n    if (!t->DataFormat) {\n\n        if (!AllocateDataFormat(it8))\n            return FALSE;\n    }\n\n    if (n >= t -> nSamples) {\n        SynError(it8, \"More than NUMBER_OF_FIELDS fields.\");\n        return FALSE;\n    }\n\n    if (t->DataFormat) {\n        t->DataFormat[n] = AllocString(it8, label);\n        if (t->DataFormat[n] == NULL) return FALSE;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1663,
              0
            ],
            [
              1685,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetDataFormat",
            "parameters": {
              "it8": "cmsIT8",
              "n": "int",
              "label": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsIT8SetDataFormat(cmsHANDLE  h, int n, const char *Sample)\n{\n    cmsIT8* it8 = (cmsIT8*)h;\n    return SetDataFormat(it8, n, Sample);\n}",
          "fn_code_pos": [
            [
              1688,
              0
            ],
            [
              1692,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetDataFormat",
            "parameters": {
              "h": "cmsHANDLE",
              "n": "int",
              "Sample": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nconst char* satob(const char* v)\n{\n    cmsUInt32Number x;\n    static char buf[33];\n    char *s = buf + 33;\n    \n    if (v == NULL) return \"0\";\n    \n    x = atoi(v);\n    *--s = 0;\n    if (!x) *--s = '0';\n    for (; x; x /= 2) *--s = '0' + x%2;\n    \n    return s;\n}",
          "fn_code_pos": [
            [
              1695,
              0
            ],
            [
              1710,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "satob",
            "parameters": {
              "v": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static\ncmsBool AllocateDataSet(cmsIT8* it8)\n{\n    TABLE* t = GetTable(it8);\n\n    if (t -> Data) return TRUE;    // Already allocated\n\n    t-> nSamples   = satoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n    t-> nPatches   = satoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n\n    if (t -> nSamples < 0 || t->nSamples > 0x7ffe || t->nPatches < 0 || t->nPatches > 0x7ffe || \n        (t->nPatches * t->nSamples) > 200000)\n    {\n        SynError(it8, \"AllocateDataSet: too much data\");\n        return FALSE;\n    }\n    else {\n        // Some dumb analyzers warns of possible overflow here, just take a look couple of lines above.\n        t->Data = (char**)AllocChunk(it8, ((cmsUInt32Number)t->nSamples + 1) * ((cmsUInt32Number)t->nPatches + 1) * sizeof(char*));\n        if (t->Data == NULL) {\n\n            SynError(it8, \"AllocateDataSet: Unable to allocate data array\");\n            return FALSE;\n        }\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1713,
              0
            ],
            [
              1740,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllocateDataSet",
            "parameters": {
              "it8": "cmsIT8"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nchar* GetData(cmsIT8* it8, int nSet, int nField)\n{\n    TABLE* t = GetTable(it8);\n    int nSamples    = t -> nSamples;\n    int nPatches    = t -> nPatches;\n\n    if (nSet < 0 || nSet >= nPatches || nField < 0 || nField >= nSamples)\n        return NULL;\n\n    if (!t->Data) return NULL;\n    return t->Data [nSet * nSamples + nField];\n}",
          "fn_code_pos": [
            [
              1742,
              0
            ],
            [
              1754,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetData",
            "parameters": {
              "it8": "cmsIT8",
              "nSet": "int",
              "nField": "int"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static\ncmsBool SetData(cmsIT8* it8, int nSet, int nField, const char *Val)\n{\n    char* ptr;\n\n    TABLE* t = GetTable(it8);\n    \n\n    if (!t->Data) {\n        if (!AllocateDataSet(it8)) return FALSE;\n    }\n\n    if (!t->Data) return FALSE;\n\n    if (nSet > t -> nPatches || nSet < 0) {\n\n            return SynError(it8, \"Patch %d out of range, there are %d patches\", nSet, t -> nPatches);\n    }\n\n    if (nField > t ->nSamples || nField < 0) {\n            return SynError(it8, \"Sample %d out of range, there are %d samples\", nField, t ->nSamples);\n\n    }\n\n    ptr = AllocString(it8, Val);\n    if (ptr == NULL)\n        return FALSE;\n\n    t->Data [nSet * t -> nSamples + nField] = ptr;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1756,
              0
            ],
            [
              1786,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetData",
            "parameters": {
              "it8": "cmsIT8",
              "nSet": "int",
              "nField": "int",
              "Val": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid WriteStr(SAVESTREAM* f, const char *str)\n{\n    cmsUInt32Number len;\n\n    if (str == NULL)\n        str = \" \";\n\n    // Length to write\n    len = (cmsUInt32Number) strlen(str);\n    f ->Used += len;\n\n\n    if (f ->stream) {   // Should I write it to a file?\n\n        if (fwrite(str, 1, len, f->stream) != len) {\n            cmsSignalError(0, cmsERROR_WRITE, \"Write to file error in CGATS parser\");\n            return;\n        }\n\n    }\n    else {  // Or to a memory block?\n\n        if (f ->Base) {   // Am I just counting the bytes?\n\n            if (f ->Used > f ->Max) {\n\n                 cmsSignalError(0, cmsERROR_WRITE, \"Write to memory overflows in CGATS parser\");\n                 return;\n            }\n\n            memmove(f ->Ptr, str, len);\n            f->Ptr += len;\n        }\n\n    }\n}",
          "fn_code_pos": [
            [
              1793,
              0
            ],
            [
              1829,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteStr",
            "parameters": {
              "f": "SAVESTREAM",
              "str": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Writef(SAVESTREAM* f, const char* frm, ...)\n{\n    char Buffer[4096];\n    va_list args;\n\n    va_start(args, frm);\n    vsnprintf(Buffer, 4095, frm, args);\n    Buffer[4095] = 0;\n    WriteStr(f, Buffer);\n    va_end(args);\n\n}",
          "fn_code_pos": [
            [
              1834,
              0
            ],
            [
              1846,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Writef",
            "parameters": {
              "f": "SAVESTREAM",
              "frm": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid WriteHeader(cmsIT8* it8, SAVESTREAM* fp)\n{\n    KEYVALUE* p;\n    TABLE* t = GetTable(it8);\n\n    // Writes the type\n    WriteStr(fp, t->SheetType);\n    WriteStr(fp, \"\\n\");\n\n    for (p = t->HeaderList; (p != NULL); p = p->Next)\n    {\n        if (*p ->Keyword == '#') {\n\n            char* Pt;\n\n            WriteStr(fp, \"#\\n# \");\n            for (Pt = p ->Value; *Pt; Pt++) {\n\n\n                Writef(fp, \"%c\", *Pt);\n\n                if (*Pt == '\\n') {\n                    WriteStr(fp, \"# \");\n                }\n            }\n\n            WriteStr(fp, \"\\n#\\n\");\n            continue;\n        }\n\n\n        if (!IsAvailableOnList(it8-> ValidKeywords, p->Keyword, NULL, NULL)) {\n\n#ifdef CMS_STRICT_CGATS\n            WriteStr(fp, \"KEYWORD\\t\\\"\");\n            WriteStr(fp, p->Keyword);\n            WriteStr(fp, \"\\\"\\n\");\n#endif\n\n            AddAvailableProperty(it8, p->Keyword, WRITE_UNCOOKED);\n        }\n\n        WriteStr(fp, p->Keyword);\n        if (p->Value) {\n\n            switch (p ->WriteAs) {\n\n            case WRITE_UNCOOKED:\n                    Writef(fp, \"\\t%s\", p ->Value);\n                    break;\n\n            case WRITE_STRINGIFY:\n                    Writef(fp, \"\\t\\\"%s\\\"\", p->Value );\n                    break;\n\n            case WRITE_HEXADECIMAL:\n                    Writef(fp, \"\\t0x%X\", satoi(p ->Value));\n                    break;\n\n            case WRITE_BINARY:\n                    Writef(fp, \"\\t0b%s\", satob(p ->Value));\n                    break;\n\n            case WRITE_PAIR:\n                    Writef(fp, \"\\t\\\"%s,%s\\\"\", p->Subkey, p->Value);\n                    break;\n\n            default: SynError(it8, \"Unknown write mode %d\", p ->WriteAs);\n                     return;\n            }\n        }\n\n        WriteStr (fp, \"\\n\");\n    }\n\n}",
          "fn_code_pos": [
            [
              1849,
              0
            ],
            [
              1925,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteHeader",
            "parameters": {
              "it8": "cmsIT8",
              "fp": "SAVESTREAM"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid WriteDataFormat(SAVESTREAM* fp, cmsIT8* it8)\n{\n    int i, nSamples;\n    TABLE* t = GetTable(it8);\n\n    if (!t -> DataFormat) return;\n\n       WriteStr(fp, \"BEGIN_DATA_FORMAT\\n\");\n       WriteStr(fp, \" \");\n       nSamples = satoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n\n       if (nSamples <= t->nSamples) {\n\n           for (i = 0; i < nSamples; i++) {\n\n               WriteStr(fp, t->DataFormat[i]);\n               WriteStr(fp, ((i == (nSamples - 1)) ? \"\\n\" : \"\\t\"));\n           }\n       }\n\n       WriteStr (fp, \"END_DATA_FORMAT\\n\");\n}",
          "fn_code_pos": [
            [
              1929,
              0
            ],
            [
              1951,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteDataFormat",
            "parameters": {
              "fp": "SAVESTREAM",
              "it8": "cmsIT8"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid WriteData(SAVESTREAM* fp, cmsIT8* it8)\n{\n       int  i, j, nPatches;\n       TABLE* t = GetTable(it8);\n\n       if (!t->Data) return;\n\n       WriteStr (fp, \"BEGIN_DATA\\n\");\n\n       nPatches = satoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n\n       if (nPatches <= t->nPatches) {\n\n           for (i = 0; i < nPatches; i++) {\n\n               WriteStr(fp, \" \");\n\n               for (j = 0; j < t->nSamples; j++) {\n\n                   char* ptr = t->Data[i * t->nSamples + j];\n\n                   if (ptr == NULL) WriteStr(fp, \"\\\"\\\"\");\n                   else {\n                       // If value contains whitespace, enclose within quote\n\n                       if (strchr(ptr, ' ') != NULL) {\n\n                           WriteStr(fp, \"\\\"\");\n                           WriteStr(fp, ptr);\n                           WriteStr(fp, \"\\\"\");\n                       }\n                       else\n                           WriteStr(fp, ptr);\n                   }\n\n                   WriteStr(fp, ((j == (t->nSamples - 1)) ? \"\\n\" : \"\\t\"));\n               }\n           }\n       }\n       WriteStr (fp, \"END_DATA\\n\");\n}",
          "fn_code_pos": [
            [
              1955,
              0
            ],
            [
              1996,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteData",
            "parameters": {
              "fp": "SAVESTREAM",
              "it8": "cmsIT8"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsIT8SaveToFile(cmsHANDLE hIT8, const char* cFileName)\n{\n    SAVESTREAM sd;\n    cmsUInt32Number i;\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n\n    memset(&sd, 0, sizeof(sd));\n\n    sd.stream = fopen(cFileName, \"wt\");\n    if (!sd.stream) return FALSE;\n\n    for (i=0; i < it8 ->TablesCount; i++) {\n\n        TABLE* t;\n\n        if (cmsIT8SetTable(hIT8, i) < 0) goto Error;\n        \n        /**\n        * Check for wrong data\n        */\n        t = GetTable(it8);\n        if (t->Data == NULL) goto Error;\n        if (t->DataFormat == NULL) goto Error;\n\n        WriteHeader(it8, &sd);\n        WriteDataFormat(&sd, it8);\n        WriteData(&sd, it8);\n    }\n\n    if (fclose(sd.stream) != 0) return FALSE;\n    return TRUE;\n\nError:\n    fclose(sd.stream);\n    return FALSE;\n\n}",
          "fn_code_pos": [
            [
              2001,
              0
            ],
            [
              2037,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SaveToFile",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cFileName": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsIT8SaveToMem(cmsHANDLE hIT8, void *MemPtr, cmsUInt32Number* BytesNeeded)\n{\n    SAVESTREAM sd;\n    cmsUInt32Number i;\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n\n    memset(&sd, 0, sizeof(sd));\n\n    sd.stream = NULL;\n    sd.Base   = (cmsUInt8Number*) MemPtr;\n    sd.Ptr    = sd.Base;\n\n    sd.Used = 0;\n\n    if (sd.Base && (*BytesNeeded > 0)) {\n\n        sd.Max = (*BytesNeeded) - 1;     // Write to memory?\n    }\n    else\n        sd.Max  = 0;                // Just counting the needed bytes\n\n    for (i=0; i < it8 ->TablesCount; i++) {\n\n        cmsIT8SetTable(hIT8, i);\n        WriteHeader(it8, &sd);\n        WriteDataFormat(&sd, it8);\n        WriteData(&sd, it8);\n    }\n\n    sd.Used++;  // The \\0 at the very end\n\n    if (sd.Base)\n        *sd.Ptr = 0;\n\n    *BytesNeeded = sd.Used;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              2041,
              0
            ],
            [
              2078,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SaveToMem",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "MemPtr": "void",
              "BytesNeeded": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool DataFormatSection(cmsIT8* it8)\n{\n    int iField = 0;\n    TABLE* t = GetTable(it8);\n\n    InSymbol(it8);   // Eats \"BEGIN_DATA_FORMAT\"\n    CheckEOLN(it8);\n\n    while (it8->sy != SEND_DATA_FORMAT &&\n        it8->sy != SEOLN &&\n        it8->sy != SEOF &&\n        it8->sy != SSYNERROR)  {\n\n            if (it8->sy != SIDENT) {\n\n                return SynError(it8, \"Sample type expected\");\n            }\n\n            if (!SetDataFormat(it8, iField, StringPtr(it8->id))) return FALSE;\n            iField++;\n\n            InSymbol(it8);\n            SkipEOLN(it8);\n       }\n\n       SkipEOLN(it8);\n       Skip(it8, SEND_DATA_FORMAT);\n       SkipEOLN(it8);\n\n       if (iField != t ->nSamples) {\n           SynError(it8, \"Count mismatch. NUMBER_OF_FIELDS was %d, found %d\\n\", t ->nSamples, iField);\n\n\n       }\n\n       return TRUE;\n}",
          "fn_code_pos": [
            [
              2083,
              0
            ],
            [
              2120,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DataFormatSection",
            "parameters": {
              "it8": "cmsIT8"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool DataSection (cmsIT8* it8)\n{\n    int  iField = 0;\n    int  iSet   = 0;\n    char Buffer[256];\n    TABLE* t = GetTable(it8);\n\n    InSymbol(it8);   // Eats \"BEGIN_DATA\"\n    CheckEOLN(it8);\n\n    if (!t->Data) {\n        if (!AllocateDataSet(it8)) return FALSE;\n    }\n\n    while (it8->sy != SEND_DATA && it8->sy != SEOF && it8->sy != SSYNERROR)\n    {\n        if (iField >= t -> nSamples) {\n            iField = 0;\n            iSet++;\n\n        }\n\n        if (it8->sy != SEND_DATA && it8->sy != SEOF && it8->sy != SSYNERROR) {\n\n            switch (it8->sy)\n            {\n\n            // To keep very long data\n            case SIDENT:  \n                if (!SetData(it8, iSet, iField, StringPtr(it8->id)))\n                    return FALSE;\n                break;\n\n            case SSTRING:\n                if (!SetData(it8, iSet, iField, StringPtr(it8->str)))\n                    return FALSE;\n                break;\n\n            default:\n\n            if (!GetVal(it8, Buffer, 255, \"Sample data expected\"))\n                return FALSE;\n\n            if (!SetData(it8, iSet, iField, Buffer))\n                return FALSE;\n            }\n\n            iField++;\n\n            InSymbol(it8);\n            SkipEOLN(it8);\n        }\n    }\n\n    SkipEOLN(it8);\n    Skip(it8, SEND_DATA);\n    SkipEOLN(it8);\n\n    // Check for data completion.\n\n    if ((iSet+1) != t -> nPatches)\n        return SynError(it8, \"Count mismatch. NUMBER_OF_SETS was %d, found %d\\n\", t ->nPatches, iSet+1);\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              2124,
              0
            ],
            [
              2189,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DataSection",
            "parameters": {
              "it8": "cmsIT8"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool HeaderSection(cmsIT8* it8)\n{\n    char VarName[MAXID];\n    char Buffer[MAXSTR];\n    KEYVALUE* Key;\n\n        while (it8->sy != SEOF &&\n               it8->sy != SSYNERROR &&\n               it8->sy != SBEGIN_DATA_FORMAT &&\n               it8->sy != SBEGIN_DATA) {\n\n\n        switch (it8 -> sy) {\n\n        case SKEYWORD:\n                InSymbol(it8);\n                if (!GetVal(it8, Buffer, MAXSTR-1, \"Keyword expected\")) return FALSE;\n                if (!AddAvailableProperty(it8, Buffer, WRITE_UNCOOKED)) return FALSE;\n                InSymbol(it8);\n                break;\n\n\n        case SDATA_FORMAT_ID:\n                InSymbol(it8);\n                if (!GetVal(it8, Buffer, MAXSTR-1, \"Keyword expected\")) return FALSE;\n                if (!AddAvailableSampleID(it8, Buffer)) return FALSE;\n                InSymbol(it8);\n                break;\n\n\n        case SIDENT:\n            strncpy(VarName, StringPtr(it8->id), MAXID - 1);\n            VarName[MAXID - 1] = 0;\n\n            if (!IsAvailableOnList(it8->ValidKeywords, VarName, NULL, &Key)) {\n\n#ifdef CMS_STRICT_CGATS\n                return SynError(it8, \"Undefined keyword '%s'\", VarName);\n#else\n                Key = AddAvailableProperty(it8, VarName, WRITE_UNCOOKED);\n                if (Key == NULL) return FALSE;\n#endif\n            }\n\n            InSymbol(it8);\n            if (!GetVal(it8, Buffer, MAXSTR - 1, \"Property data expected\")) return FALSE;\n\n            if (Key->WriteAs != WRITE_PAIR) {\n                if (AddToList(it8, &GetTable(it8)->HeaderList, VarName, NULL, Buffer,\n                    (it8->sy == SSTRING) ? WRITE_STRINGIFY : WRITE_UNCOOKED) == NULL) return FALSE;\n            }\n            else {\n                const char *Subkey;\n                char *Nextkey;\n                if (it8->sy != SSTRING)\n                    return SynError(it8, \"Invalid value '%s' for property '%s'.\", Buffer, VarName);\n\n                // chop the string as a list of \"subkey, value\" pairs, using ';' as a separator\n                for (Subkey = Buffer; Subkey != NULL; Subkey = Nextkey)\n                {\n                    char *Value, *temp;\n\n                    //  identify token pair boundary\n                    Nextkey = (char*)strchr(Subkey, ';');\n                    if (Nextkey)\n                        *Nextkey++ = '\\0';\n\n                    // for each pair, split the subkey and the value\n                    Value = (char*)strrchr(Subkey, ',');\n                    if (Value == NULL)\n                        return SynError(it8, \"Invalid value for property '%s'.\", VarName);\n\n                    // gobble the spaces before the coma, and the coma itself\n                    temp = Value++;\n                    do *temp-- = '\\0'; while (temp >= Subkey && *temp == ' ');\n\n                    // gobble any space at the right\n                    temp = Value + strlen(Value) - 1;\n                    while (*temp == ' ') *temp-- = '\\0';\n\n                    // trim the strings from the left\n                    Subkey += strspn(Subkey, \" \");\n                    Value += strspn(Value, \" \");\n\n                    if (Subkey[0] == 0 || Value[0] == 0)\n                        return SynError(it8, \"Invalid value for property '%s'.\", VarName);\n                    AddToList(it8, &GetTable(it8)->HeaderList, VarName, Subkey, Value, WRITE_PAIR);\n                }\n            }\n\n            InSymbol(it8);\n            break;\n\n\n        case SEOLN: break;\n\n        default:\n                return SynError(it8, \"expected keyword or identifier\");\n        }\n\n    SkipEOLN(it8);\n    }\n\n    return TRUE;\n\n}",
          "fn_code_pos": [
            [
              2194,
              0
            ],
            [
              2300,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HeaderSection",
            "parameters": {
              "it8": "cmsIT8"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid ReadType(cmsIT8* it8, char* SheetTypePtr)\n{\n    cmsInt32Number cnt = 0;\n\n    // First line is a very special case.\n\n    while (isseparator(it8->ch))\n            NextCh(it8);\n\n    while (it8->ch != '\\r' && it8 ->ch != '\\n' && it8->ch != '\\t' && it8 -> ch != 0) {\n\n        if (cnt++ < MAXSTR) \n            *SheetTypePtr++= (char) it8 ->ch;\n        NextCh(it8);\n    }\n\n    *SheetTypePtr = 0;\n}",
          "fn_code_pos": [
            [
              2303,
              0
            ],
            [
              2321,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadType",
            "parameters": {
              "it8": "cmsIT8",
              "SheetTypePtr": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool ParseIT8(cmsIT8* it8, cmsBool nosheet)\n{\n    char* SheetTypePtr = it8 ->Tab[0].SheetType;\n\n    if (nosheet == 0) {\n        ReadType(it8, SheetTypePtr);\n    }\n\n    InSymbol(it8);\n\n    SkipEOLN(it8);\n\n    while (it8-> sy != SEOF &&\n           it8-> sy != SSYNERROR) {\n\n            switch (it8 -> sy) {\n\n            case SBEGIN_DATA_FORMAT:\n                    if (!DataFormatSection(it8)) return FALSE;\n                    break;\n\n            case SBEGIN_DATA:\n\n                    if (!DataSection(it8)) return FALSE;\n\n                    if (it8 -> sy != SEOF && it8->sy != SSYNERROR) {\n\n                            if (!AllocTable(it8)) return FALSE;                        \n\n                            it8 ->nTable = it8 ->TablesCount - 1;\n\n                            // Read sheet type if present. We only support identifier and string.\n                            // <ident> <eoln> is a type string\n                            // anything else, is not a type string\n                            if (nosheet == 0) {\n\n                                if (it8 ->sy == SIDENT) {\n\n                                    // May be a type sheet or may be a prop value statement. We cannot use insymbol in\n                                    // this special case...\n                                     while (isseparator(it8->ch))\n                                         NextCh(it8);\n\n                                     // If a newline is found, then this is a type string\n                                    if (it8 ->ch == '\\n' || it8->ch == '\\r') {\n\n                                         cmsIT8SetSheetType(it8, StringPtr(it8 ->id));\n                                         InSymbol(it8);\n                                    }\n                                    else\n                                    {\n                                        // It is not. Just continue\n                                        cmsIT8SetSheetType(it8, \"\");\n                                    }\n                                }\n                                else\n                                    // Validate quoted strings\n                                    if (it8 ->sy == SSTRING) {\n                                        cmsIT8SetSheetType(it8, StringPtr(it8 ->str));\n                                        InSymbol(it8);\n                                    }\n                           }\n\n                    }\n                    break;\n\n            case SEOLN:\n                    SkipEOLN(it8);\n                    break;\n\n            default:\n                    if (!HeaderSection(it8)) return FALSE;\n           }\n\n    }\n\n    return (it8 -> sy != SSYNERROR);\n}",
          "fn_code_pos": [
            [
              2324,
              0
            ],
            [
              2402,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ParseIT8",
            "parameters": {
              "it8": "cmsIT8",
              "nosheet": "cmsBool"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid CookPointers(cmsIT8* it8)\n{\n    int idField, i;\n    char* Fld;\n    cmsUInt32Number j;\n    cmsUInt32Number nOldTable = it8->nTable;\n\n    for (j = 0; j < it8->TablesCount; j++) {\n\n        TABLE* t = it8->Tab + j;\n\n        t->SampleID = 0;\n        it8->nTable = j;\n\n        for (idField = 0; idField < t->nSamples; idField++)\n        {\n            if (t->DataFormat == NULL) {\n                SynError(it8, \"Undefined DATA_FORMAT\");\n                return;\n            }\n\n            Fld = t->DataFormat[idField];\n            if (!Fld) continue;\n\n\n            if (cmsstrcasecmp(Fld, \"SAMPLE_ID\") == 0) {\n\n                t->SampleID = idField;\n            }\n\n            // \"LABEL\" is an extension. It keeps references to forward tables\n\n            if ((cmsstrcasecmp(Fld, \"LABEL\") == 0) || Fld[0] == '$') {\n\n                // Search for table references...\n                for (i = 0; i < t->nPatches; i++) {\n\n                    char* Label = GetData(it8, i, idField);\n\n                    if (Label) {\n\n                        cmsUInt32Number k;\n\n                        // This is the label, search for a table containing\n                        // this property\n\n                        for (k = 0; k < it8->TablesCount; k++) {\n\n                            TABLE* Table = it8->Tab + k;\n                            KEYVALUE* p;\n\n                            if (IsAvailableOnList(Table->HeaderList, Label, NULL, &p)) {\n\n                                // Available, keep type and table\n                                char Buffer[256];\n\n                                char* Type = p->Value;\n                                int  nTable = (int)k;\n\n                                snprintf(Buffer, 255, \"%s %d %s\", Label, nTable, Type);\n\n                                SetData(it8, i, idField, Buffer);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    it8->nTable = nOldTable;\n}",
          "fn_code_pos": [
            [
              2408,
              0
            ],
            [
              2480,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CookPointers",
            "parameters": {
              "it8": "cmsIT8"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nint IsMyBlock(const cmsUInt8Number* Buffer, cmsUInt32Number n)\n{\n    int words = 1, space = 0, quot = 0;\n    cmsUInt32Number i;\n\n    if (n < 10) return 0;   // Too small\n\n    if (n > 132)\n        n = 132;\n\n    for (i = 1; i < n; i++) {\n\n        switch(Buffer[i])\n        {\n        case '\\n':\n        case '\\r':\n            return ((quot == 1) || (words > 2)) ? 0 : words;\n        case '\\t':\n        case ' ':\n            if(!quot && !space)\n                space = 1;\n            break;\n        case '\\\"':\n            quot = !quot;\n            break;\n        default:\n            if (Buffer[i] < 32) return 0;\n            if (Buffer[i] > 127) return 0;\n            words += space;\n            space = 0;\n            break;\n        }\n    }\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              2485,
              0
            ],
            [
              2521,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsMyBlock",
            "parameters": {
              "Buffer": "cmsUInt8Number",
              "n": "cmsUInt32Number"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\ncmsBool IsMyFile(const char* FileName)\n{\n   FILE *fp;\n   cmsUInt32Number Size;\n   cmsUInt8Number Ptr[133];\n\n   fp = fopen(FileName, \"rt\");\n   if (!fp) {\n       cmsSignalError(0, cmsERROR_FILE, \"File '%s' not found\", FileName);\n       return FALSE;\n   }\n\n   Size = (cmsUInt32Number) fread(Ptr, 1, 132, fp);\n\n   if (fclose(fp) != 0)\n       return FALSE;\n\n   Ptr[Size] = '\\0';\n\n   return IsMyBlock(Ptr, Size);\n}",
          "fn_code_pos": [
            [
              2524,
              0
            ],
            [
              2545,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsMyFile",
            "parameters": {
              "FileName": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsHANDLE  CMSEXPORT cmsIT8LoadFromMem(cmsContext ContextID, const void *Ptr, cmsUInt32Number len)\n{\n    cmsHANDLE hIT8;\n    cmsIT8*  it8;\n    int type;\n\n    _cmsAssert(Ptr != NULL);\n    _cmsAssert(len != 0);\n\n    type = IsMyBlock((const cmsUInt8Number*)Ptr, len);\n    if (type == 0) return NULL;\n\n    hIT8 = cmsIT8Alloc(ContextID);\n    if (!hIT8) return NULL;\n\n    it8 = (cmsIT8*) hIT8;\n    it8 ->MemoryBlock = (char*) _cmsMalloc(ContextID, len + 1);\n    if (it8->MemoryBlock == NULL)\n    {\n        cmsIT8Free(hIT8);\n        return NULL;\n    }\n\n    strncpy(it8 ->MemoryBlock, (const char*) Ptr, len);\n    it8 ->MemoryBlock[len] = 0;\n\n    strncpy(it8->FileStack[0]->FileName, \"\", cmsMAX_PATH-1);\n    it8-> Source = it8 -> MemoryBlock;\n\n    if (!ParseIT8(it8, type-1)) {\n\n        cmsIT8Free(hIT8);\n        return NULL;\n    }\n\n    CookPointers(it8);\n    it8 ->nTable = 0;\n\n    _cmsFree(ContextID, it8->MemoryBlock);\n    it8 -> MemoryBlock = NULL;\n\n    return hIT8;\n\n\n}",
          "fn_code_pos": [
            [
              2550,
              0
            ],
            [
              2594,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8LoadFromMem",
            "parameters": {
              "ContextID": "cmsContext",
              "Ptr": "void",
              "len": "cmsUInt32Number"
            },
            "return_type": "cmsHANDLE"
          }
        },
        {
          "fn_code": "cmsHANDLE  CMSEXPORT cmsIT8LoadFromFile(cmsContext ContextID, const char* cFileName)\n{\n\n     cmsHANDLE hIT8;\n     cmsIT8*  it8;\n     int type;\n\n     _cmsAssert(cFileName != NULL);\n\n     type = IsMyFile(cFileName);\n     if (type == 0) return NULL;\n\n     hIT8 = cmsIT8Alloc(ContextID);\n     it8 = (cmsIT8*) hIT8;\n     if (!hIT8) return NULL;\n\n\n     it8 ->FileStack[0]->Stream = fopen(cFileName, \"rt\");\n\n     if (!it8 ->FileStack[0]->Stream) {\n         cmsIT8Free(hIT8);\n         return NULL;\n     }\n\n\n    strncpy(it8->FileStack[0]->FileName, cFileName, cmsMAX_PATH-1);\n    it8->FileStack[0]->FileName[cmsMAX_PATH-1] = 0;\n\n    if (!ParseIT8(it8, type-1)) {\n\n            fclose(it8 ->FileStack[0]->Stream);\n            cmsIT8Free(hIT8);\n            return NULL;\n    }\n\n    CookPointers(it8);\n    it8 ->nTable = 0;\n\n    if (fclose(it8 ->FileStack[0]->Stream)!= 0) {\n            cmsIT8Free(hIT8);\n            return NULL;\n    }\n\n    return hIT8;\n\n}",
          "fn_code_pos": [
            [
              2597,
              0
            ],
            [
              2642,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8LoadFromFile",
            "parameters": {
              "ContextID": "cmsContext",
              "cFileName": "char"
            },
            "return_type": "cmsHANDLE"
          }
        },
        {
          "fn_code": "int CMSEXPORT cmsIT8EnumDataFormat(cmsHANDLE hIT8, char ***SampleNames)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n    TABLE* t;\n\n    _cmsAssert(hIT8 != NULL);\n\n    t = GetTable(it8);\n\n    if (SampleNames)\n        *SampleNames = t -> DataFormat;\n    return t -> nSamples;\n}",
          "fn_code_pos": [
            [
              2644,
              0
            ],
            [
              2656,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8EnumDataFormat",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "SampleNames": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsIT8EnumProperties(cmsHANDLE hIT8, char ***PropertyNames)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n    KEYVALUE* p;\n    cmsUInt32Number n;\n    char **Props;\n    TABLE* t;\n\n    _cmsAssert(hIT8 != NULL);\n\n    t = GetTable(it8);\n\n    // Pass#1 - count properties\n\n    n = 0;\n    for (p = t -> HeaderList;  p != NULL; p = p->Next) {\n        n++;\n    }\n\n\n    Props = (char**)AllocChunk(it8, sizeof(char*) * n);\n    if (Props != NULL) {\n\n        // Pass#2 - Fill pointers\n        n = 0;\n        for (p = t->HeaderList; p != NULL; p = p->Next) {\n            Props[n++] = p->Keyword;\n        }\n\n    }\n    *PropertyNames = Props;\n\n    return n;\n}",
          "fn_code_pos": [
            [
              2659,
              0
            ],
            [
              2692,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8EnumProperties",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "PropertyNames": "char"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsIT8EnumPropertyMulti(cmsHANDLE hIT8, const char* cProp, const char ***SubpropertyNames)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n    KEYVALUE *p, *tmp;\n    cmsUInt32Number n;\n    const char **Props;\n    TABLE* t;\n\n    _cmsAssert(hIT8 != NULL);\n\n\n    t = GetTable(it8);\n\n    if(!IsAvailableOnList(t->HeaderList, cProp, NULL, &p)) {\n        *SubpropertyNames = 0;\n        return 0;\n    }\n\n    // Pass#1 - count properties\n\n    n = 0;\n    for (tmp = p;  tmp != NULL; tmp = tmp->NextSubkey) {\n        if(tmp->Subkey != NULL)\n            n++;\n    }\n\n\n    Props = (const char **) AllocChunk(it8, sizeof(char *) * n);\n    if (Props != NULL) {\n\n        // Pass#2 - Fill pointers\n        n = 0;\n        for (tmp = p; tmp != NULL; tmp = tmp->NextSubkey) {\n            if (tmp->Subkey != NULL)\n                Props[n++] = p->Subkey;\n        }\n    }\n\n    *SubpropertyNames = Props;\n    return n;\n}",
          "fn_code_pos": [
            [
              2694,
              0
            ],
            [
              2734,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8EnumPropertyMulti",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cProp": "char",
              "SubpropertyNames": "char"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\nint LocatePatch(cmsIT8* it8, const char* cPatch)\n{\n    int i;\n    const char *data;\n    TABLE* t = GetTable(it8);\n\n    for (i=0; i < t-> nPatches; i++) {\n\n        data = GetData(it8, i, t->SampleID);\n\n        if (data != NULL) {\n\n                if (cmsstrcasecmp(data, cPatch) == 0)\n                        return i;\n                }\n        }\n\n        // SynError(it8, \"Couldn't find patch '%s'\\n\", cPatch);\n        return -1;\n}",
          "fn_code_pos": [
            [
              2736,
              0
            ],
            [
              2756,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LocatePatch",
            "parameters": {
              "it8": "cmsIT8",
              "cPatch": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint LocateEmptyPatch(cmsIT8* it8)\n{\n    int i;\n    const char *data;\n    TABLE* t = GetTable(it8);\n\n    for (i=0; i < t-> nPatches; i++) {\n\n        data = GetData(it8, i, t->SampleID);\n\n        if (data == NULL)\n            return i;\n\n    }\n\n    return -1;\n}",
          "fn_code_pos": [
            [
              2759,
              0
            ],
            [
              2776,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LocateEmptyPatch",
            "parameters": {
              "it8": "cmsIT8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint LocateSample(cmsIT8* it8, const char* cSample)\n{\n    int i;\n    const char *fld;\n    TABLE* t = GetTable(it8);\n\n    for (i=0; i < t->nSamples; i++) {\n\n        fld = GetDataFormat(it8, i);\n        if (fld != NULL) {\n            if (cmsstrcasecmp(fld, cSample) == 0)\n                return i;\n        }\n    }\n\n    return -1;\n\n}",
          "fn_code_pos": [
            [
              2778,
              0
            ],
            [
              2796,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LocateSample",
            "parameters": {
              "it8": "cmsIT8",
              "cSample": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int CMSEXPORT cmsIT8FindDataFormat(cmsHANDLE hIT8, const char* cSample)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n\n    _cmsAssert(hIT8 != NULL);\n\n    return LocateSample(it8, cSample);\n}",
          "fn_code_pos": [
            [
              2799,
              0
            ],
            [
              2806,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8FindDataFormat",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cSample": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "const char* CMSEXPORT cmsIT8GetDataRowCol(cmsHANDLE hIT8, int row, int col)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n\n    _cmsAssert(hIT8 != NULL);\n\n    return GetData(it8, row, col);\n}",
          "fn_code_pos": [
            [
              2810,
              0
            ],
            [
              2817,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetDataRowCol",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "row": "int",
              "col": "int"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "cmsFloat64Number CMSEXPORT cmsIT8GetDataRowColDbl(cmsHANDLE hIT8, int row, int col)\n{\n    const char* Buffer;\n\n    Buffer = cmsIT8GetDataRowCol(hIT8, row, col);\n\n    if (Buffer == NULL) return 0.0;\n\n    return ParseFloatNumber(Buffer);\n}",
          "fn_code_pos": [
            [
              2820,
              0
            ],
            [
              2829,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetDataRowColDbl",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "row": "int",
              "col": "int"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsIT8SetDataRowCol(cmsHANDLE hIT8, int row, int col, const char* Val)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n\n    _cmsAssert(hIT8 != NULL);\n\n    return SetData(it8, row, col, Val);\n}",
          "fn_code_pos": [
            [
              2832,
              0
            ],
            [
              2839,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetDataRowCol",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "row": "int",
              "col": "int",
              "Val": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsIT8SetDataRowColDbl(cmsHANDLE hIT8, int row, int col, cmsFloat64Number Val)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n    char Buff[256];\n\n    _cmsAssert(hIT8 != NULL);\n\n    snprintf(Buff, 255, it8->DoubleFormatter, Val);\n\n    return SetData(it8, row, col, Buff);\n}",
          "fn_code_pos": [
            [
              2842,
              0
            ],
            [
              2852,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetDataRowColDbl",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "row": "int",
              "col": "int",
              "Val": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "const char* CMSEXPORT cmsIT8GetData(cmsHANDLE hIT8, const char* cPatch, const char* cSample)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n    int iField, iSet;\n\n    _cmsAssert(hIT8 != NULL);\n\n    iField = LocateSample(it8, cSample);\n    if (iField < 0) {\n        return NULL;\n    }\n\n    iSet = LocatePatch(it8, cPatch);\n    if (iSet < 0) {\n            return NULL;\n    }\n\n    return GetData(it8, iSet, iField);\n}",
          "fn_code_pos": [
            [
              2856,
              0
            ],
            [
              2874,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetData",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cPatch": "char",
              "cSample": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "cmsFloat64Number CMSEXPORT cmsIT8GetDataDbl(cmsHANDLE  it8, const char* cPatch, const char* cSample)\n{\n    const char* Buffer;\n\n    Buffer = cmsIT8GetData(it8, cPatch, cSample);\n\n    return ParseFloatNumber(Buffer);\n}",
          "fn_code_pos": [
            [
              2877,
              0
            ],
            [
              2884,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetDataDbl",
            "parameters": {
              "it8": "cmsHANDLE",
              "cPatch": "char",
              "cSample": "char"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsIT8SetData(cmsHANDLE hIT8, const char* cPatch, const char* cSample, const char *Val)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n    int iField, iSet;\n    TABLE* t;\n\n    _cmsAssert(hIT8 != NULL);\n\n    t = GetTable(it8);\n\n    iField = LocateSample(it8, cSample);\n\n    if (iField < 0)\n        return FALSE;\n\n    if (t-> nPatches == 0) {\n\n        if (!AllocateDataFormat(it8))\n            return FALSE;\n\n        if (!AllocateDataSet(it8))\n            return FALSE;\n\n        CookPointers(it8);\n    }\n\n    if (cmsstrcasecmp(cSample, \"SAMPLE_ID\") == 0) {\n\n        iSet   = LocateEmptyPatch(it8);\n        if (iSet < 0) {\n            return SynError(it8, \"Couldn't add more patches '%s'\\n\", cPatch);\n        }\n\n        iField = t -> SampleID;\n    }\n    else {\n        iSet = LocatePatch(it8, cPatch);\n        if (iSet < 0) {\n            return FALSE;\n        }\n    }\n\n    return SetData(it8, iSet, iField, Val);\n}",
          "fn_code_pos": [
            [
              2888,
              0
            ],
            [
              2931,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetData",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cPatch": "char",
              "cSample": "char",
              "Val": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsIT8SetDataDbl(cmsHANDLE hIT8, const char* cPatch,\n                                   const char* cSample,\n                                   cmsFloat64Number Val)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n    char Buff[256];\n\n    _cmsAssert(hIT8 != NULL);\n\n    snprintf(Buff, 255, it8->DoubleFormatter, Val);\n    return cmsIT8SetData(hIT8, cPatch, cSample, Buff);\n}",
          "fn_code_pos": [
            [
              2934,
              0
            ],
            [
              2945,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetDataDbl",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cPatch": "char",
              "cSample": "char",
              "Val": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "const char* CMSEXPORT cmsIT8GetPatchName(cmsHANDLE hIT8, int nPatch, char* buffer)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n    TABLE* t;\n    char* Data;\n\n    _cmsAssert(hIT8 != NULL);\n\n    t = GetTable(it8);\n    Data = GetData(it8, nPatch, t->SampleID);\n\n    if (!Data) return NULL;\n    if (!buffer) return Data;\n\n    strncpy(buffer, Data, MAXSTR-1);\n    buffer[MAXSTR-1] = 0;\n    return buffer;\n}",
          "fn_code_pos": [
            [
              2949,
              0
            ],
            [
              2966,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetPatchName",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "nPatch": "int",
              "buffer": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "int CMSEXPORT cmsIT8GetPatchByName(cmsHANDLE hIT8, const char *cPatch)\n{\n    _cmsAssert(hIT8 != NULL);\n\n    return LocatePatch((cmsIT8*)hIT8, cPatch);\n}",
          "fn_code_pos": [
            [
              2968,
              0
            ],
            [
              2973,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetPatchByName",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cPatch": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsIT8TableCount(cmsHANDLE hIT8)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n\n    _cmsAssert(hIT8 != NULL);\n\n    return it8 ->TablesCount;\n}",
          "fn_code_pos": [
            [
              2975,
              0
            ],
            [
              2982,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8TableCount",
            "parameters": {
              "hIT8": "cmsHANDLE"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "int CMSEXPORT cmsIT8SetTableByLabel(cmsHANDLE hIT8, const char* cSet, const char* cField, const char* ExpectedType)\n{\n    const char* cLabelFld;\n    char Type[256], Label[256];\n    cmsUInt32Number nTable;\n\n    _cmsAssert(hIT8 != NULL);\n\n    if (cField != NULL && *cField == 0)\n            cField = \"LABEL\";\n\n    if (cField == NULL)\n            cField = \"LABEL\";\n\n    cLabelFld = cmsIT8GetData(hIT8, cSet, cField);\n    if (!cLabelFld) return -1;\n\n    if (sscanf(cLabelFld, \"%255s %u %255s\", Label, &nTable, Type) != 3)\n            return -1;\n\n    if (ExpectedType != NULL && *ExpectedType == 0)\n        ExpectedType = NULL;\n\n    if (ExpectedType) {\n\n        if (cmsstrcasecmp(Type, ExpectedType) != 0) return -1;\n    }\n\n    return cmsIT8SetTable(hIT8, nTable);\n}",
          "fn_code_pos": [
            [
              2987,
              0
            ],
            [
              3016,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetTableByLabel",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cSet": "char",
              "cField": "char",
              "ExpectedType": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsIT8SetIndexColumn(cmsHANDLE hIT8, const char* cSample)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n    int pos;\n\n    _cmsAssert(hIT8 != NULL);\n\n    pos = LocateSample(it8, cSample);\n    if(pos == -1)\n        return FALSE;\n\n    it8->Tab[it8->nTable].SampleID = pos;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              3019,
              0
            ],
            [
              3032,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetIndexColumn",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cSample": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsIT8DefineDblFormat(cmsHANDLE hIT8, const char* Formatter)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n\n    _cmsAssert(hIT8 != NULL);\n\n    if (Formatter == NULL)\n        strcpy(it8->DoubleFormatter, DEFAULT_DBL_FORMAT);\n    else\n        strncpy(it8->DoubleFormatter, Formatter, sizeof(it8->DoubleFormatter));\n\n    it8 ->DoubleFormatter[sizeof(it8 ->DoubleFormatter)-1] = 0;\n}",
          "fn_code_pos": [
            [
              3035,
              0
            ],
            [
              3047,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8DefineDblFormat",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "Formatter": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool ReadNumbers(cmsIT8* cube, int n, cmsFloat64Number* arr)\n{\n    int i;\n\n    for (i = 0; i < n; i++) {\n\n        if (cube->sy == SINUM)\n            arr[i] = cube->inum;\n        else\n            if (cube->sy == SDNUM)\n                arr[i] = cube->dnum;\n            else\n                return SynError(cube, \"Number expected\");\n\n        InSymbol(cube);\n    }\n\n    return CheckEOLN(cube);\n}",
          "fn_code_pos": [
            [
              3050,
              0
            ],
            [
              3069,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadNumbers",
            "parameters": {
              "cube": "cmsIT8",
              "n": "int",
              "arr": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool ParseCube(cmsIT8* cube, cmsStage** Shaper, cmsStage** CLUT, char title[])\n{\n    cmsFloat64Number domain_min[3] = { 0, 0, 0 };\n    cmsFloat64Number domain_max[3] = { 1.0, 1.0, 1.0 };\n    cmsFloat64Number check_0_1[2] = { 0, 1.0 };\n    int shaper_size = 0;\n    int lut_size = 0;\n    int i;\n\n    InSymbol(cube);\n\n    while (cube->sy != SEOF && cube->sy != SSYNERROR) {\n\n        switch (cube->sy)\n        {\n        // Set profile description\n        case STITLE:\n            InSymbol(cube);\n            if (!Check(cube, SSTRING, \"Title string expected\")) return FALSE;\n            memcpy(title, StringPtr(cube->str), MAXSTR);\n            title[MAXSTR - 1] = 0;\n            InSymbol(cube);\n            break;\n\n        // Define domain\n        case SDOMAIN_MIN:\n            InSymbol(cube);\n            if (!ReadNumbers(cube, 3, domain_min)) return FALSE;\n            break;\n\n        case SDOMAIN_MAX:\n            InSymbol(cube);\n            if (!ReadNumbers(cube, 3, domain_max)) return FALSE;\n            break;\n\n        // Define shaper\n        case S_LUT1D_SIZE:\n            InSymbol(cube);\n            if (!Check(cube, SINUM, \"Shaper size expected\")) return FALSE;\n            shaper_size = cube->inum;\n            InSymbol(cube);\n            break;\n        \n        // Deefine CLUT\n        case S_LUT3D_SIZE:\n            InSymbol(cube);\n            if (!Check(cube, SINUM, \"LUT size expected\")) return FALSE;\n            lut_size = cube->inum;\n            InSymbol(cube);\n            break;\n\n        // Range. If present, has to be 0..1.0\n        case S_LUT1D_INPUT_RANGE:\n        case S_LUT3D_INPUT_RANGE:\n            InSymbol(cube);\n            if (!ReadNumbers(cube, 2, check_0_1)) return FALSE;\n            if (check_0_1[0] != 0 || check_0_1[1] != 1.0) {\n                return SynError(cube, \"Unsupported format\");\n            }\n            break;\n\n        case SEOLN:\n            InSymbol(cube);\n            break;\n\n        default:\n        case S_LUT_IN_VIDEO_RANGE:\n        case S_LUT_OUT_VIDEO_RANGE:\n            return SynError(cube, \"Unsupported format\");\n\n            // Read and create tables\n        case SINUM:\n        case SDNUM:\n\n            if (shaper_size > 0) {\n\n                cmsToneCurve* curves[3];\n                cmsFloat32Number* shapers = (cmsFloat32Number*)_cmsMalloc(cube->ContextID, 3 * shaper_size * sizeof(cmsFloat32Number));\n                if (shapers == NULL) return FALSE;\n\n                for (i = 0; i < shaper_size; i++) {\n\n                    cmsFloat64Number nums[3];\n\n                    if (!ReadNumbers(cube, 3, nums)) return FALSE;\n\n                    shapers[i + 0]               = (cmsFloat32Number) ((nums[0] - domain_min[0]) / (domain_max[0] - domain_min[0]));\n                    shapers[i + 1 * shaper_size] = (cmsFloat32Number) ((nums[1] - domain_min[1]) / (domain_max[1] - domain_min[1]));\n                    shapers[i + 2 * shaper_size] = (cmsFloat32Number) ((nums[2] - domain_min[2]) / (domain_max[2] - domain_min[2]));\n                }\n\n                for (i = 0; i < 3; i++) {\n\n                    curves[i] = cmsBuildTabulatedToneCurveFloat(cube->ContextID, shaper_size,\n                        &shapers[i * shaper_size]);\n                    if (curves[i] == NULL) return FALSE;\n                }\n\n                *Shaper = cmsStageAllocToneCurves(cube->ContextID, 3, curves);\n\n                cmsFreeToneCurveTriple(curves);\n            }\n\n            if (lut_size > 0) {\n\n                int nodes = lut_size * lut_size * lut_size;\n\n                cmsFloat32Number* lut_table = _cmsMalloc(cube->ContextID, nodes * 3 * sizeof(cmsFloat32Number));\n                if (lut_table == NULL) return FALSE;\n\n                for (i = 0; i < nodes; i++) {\n\n                    cmsFloat64Number nums[3];\n\n                    if (!ReadNumbers(cube, 3, nums)) return FALSE;\n\n                    lut_table[i * 3 + 2] = (cmsFloat32Number) ((nums[0] - domain_min[0]) / (domain_max[0] - domain_min[0]));\n                    lut_table[i * 3 + 1] = (cmsFloat32Number) ((nums[1] - domain_min[1]) / (domain_max[1] - domain_min[1]));\n                    lut_table[i * 3 + 0] = (cmsFloat32Number) ((nums[2] - domain_min[2]) / (domain_max[2] - domain_min[2]));\n                }\n\n                *CLUT = cmsStageAllocCLutFloat(cube->ContextID, lut_size, 3, 3, lut_table);\n                _cmsFree(cube->ContextID, lut_table);\n            }   \n\n            if (!Check(cube, SEOF, \"Extra symbols found in file\")) return FALSE;\n        }\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              3071,
              0
            ],
            [
              3202,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ParseCube",
            "parameters": {
              "cube": "cmsIT8",
              "Shaper": "cmsStage",
              "CLUT": "cmsStage",
              "title": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateDeviceLinkFromCubeFileTHR(cmsContext ContextID, const char* cFileName)\n{    \n    cmsHPROFILE hProfile = NULL;\n    cmsIT8* cube = NULL;\n    cmsPipeline* Pipeline = NULL;   \n    cmsStage* CLUT = NULL;\n    cmsStage* Shaper = NULL;\n    cmsMLU* DescriptionMLU = NULL;\n    char title[MAXSTR];\n\n    _cmsAssert(cFileName != NULL);\n    \n    cube = (cmsIT8*) cmsIT8Alloc(ContextID);    \n    if (!cube) return NULL;\n\n    cube->IsCUBE = TRUE;\n    cube->FileStack[0]->Stream = fopen(cFileName, \"rt\");\n\n    if (!cube->FileStack[0]->Stream) goto Done;\n\n    strncpy(cube->FileStack[0]->FileName, cFileName, cmsMAX_PATH - 1);\n    cube->FileStack[0]->FileName[cmsMAX_PATH - 1] = 0;\n\n    if (!ParseCube(cube, &Shaper, &CLUT, title)) goto Done;\n        \n    // Success on parsing, let's create the profile\n    hProfile = cmsCreateProfilePlaceholder(ContextID);\n    if (!hProfile) goto Done;\n        \n    cmsSetProfileVersion(hProfile, 4.4);\n\n    cmsSetDeviceClass(hProfile, cmsSigLinkClass);\n    cmsSetColorSpace(hProfile,  cmsSigRgbData);\n    cmsSetPCS(hProfile,         cmsSigRgbData);\n\n    cmsSetHeaderRenderingIntent(hProfile, INTENT_PERCEPTUAL);\n\n    // Creates a Pipeline to hold CLUT and shaper\n    Pipeline = cmsPipelineAlloc(ContextID, 3, 3);\n    if (Pipeline == NULL) goto Done;\n\n    // Populates the pipeline\n    if (Shaper != NULL) {\n        if (!cmsPipelineInsertStage(Pipeline, cmsAT_BEGIN, Shaper))\n            goto Done;\n    }\n\n    if (CLUT != NULL) {\n        if (!cmsPipelineInsertStage(Pipeline, cmsAT_END, CLUT))\n            goto Done;\n    }\n\n    // Propagate the description. We put no copyright because we know\n    // nothing on the copyrighted state of the .cube\n    DescriptionMLU = cmsMLUalloc(ContextID, 1);\n    if (!cmsMLUsetUTF8(DescriptionMLU, cmsNoLanguage, cmsNoCountry, title)) goto Done;\n\n    // Flush the tags\n    if (!cmsWriteTag(hProfile, cmsSigProfileDescriptionTag, DescriptionMLU)) goto Done;\n    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, (void*)Pipeline)) goto Done;\n\nDone:\n\n    if (DescriptionMLU != NULL)\n        cmsMLUfree(DescriptionMLU);\n\n    if (Pipeline != NULL)\n        cmsPipelineFree(Pipeline);\n\n    cmsIT8Free((cmsHANDLE) cube);\n\n    return hProfile;\n}",
          "fn_code_pos": [
            [
              3205,
              0
            ],
            [
              3277,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateDeviceLinkFromCubeFileTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "cFileName": "char"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateDeviceLinkFromCubeFile(const char* cFileName)\n{\n    return cmsCreateDeviceLinkFromCubeFileTHR(NULL, cFileName);\n}",
          "fn_code_pos": [
            [
              3279,
              0
            ],
            [
              3282,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateDeviceLinkFromCubeFile",
            "parameters": {
              "cFileName": "char"
            },
            "return_type": "cmsHPROFILE"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "AllocChunk(cmsIT8* it8, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              397,
              13
            ],
            [
              397,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllocChunk",
            "parameters": {
              "it8": "cmsIT8",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "StringAlloc(cmsIT8* it8, int max)",
          "fn_dec_pos": [
            [
              400,
              8
            ],
            [
              400,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "StringAlloc",
            "parameters": {
              "it8": "cmsIT8",
              "max": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "StringPtr(string* s)",
          "fn_dec_pos": [
            [
              447,
              6
            ],
            [
              447,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "StringPtr",
            "parameters": {
              "s": "string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "NoMeta(const char* str)",
          "fn_dec_pos": [
            [
              553,
              12
            ],
            [
              553,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NoMeta",
            "parameters": {
              "str": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "GetTable(cmsIT8* it8)",
          "fn_dec_pos": [
            [
              1149,
              7
            ],
            [
              1149,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetTable",
            "parameters": {
              "it8": "cmsIT8"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "AllocBigBlock(cmsIT8* it8, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              1193,
              6
            ],
            [
              1193,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllocBigBlock",
            "parameters": {
              "it8": "cmsIT8",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "AllocChunk(cmsIT8* it8, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              1219,
              6
            ],
            [
              1219,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllocChunk",
            "parameters": {
              "it8": "cmsIT8",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "AllocString(cmsIT8* it8, const char* str)",
          "fn_dec_pos": [
            [
              1260,
              6
            ],
            [
              1260,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllocString",
            "parameters": {
              "it8": "cmsIT8",
              "str": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "AddToList(cmsIT8* it8, KEYVALUE** Head, const char *Key, const char *Subkey, const char* xValue, WRITEMODE WriteAs)",
          "fn_dec_pos": [
            [
              1316,
              10
            ],
            [
              1316,
              125
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddToList",
            "parameters": {
              "it8": "cmsIT8",
              "Head": "KEYVALUE",
              "Key": "char",
              "Subkey": "char",
              "xValue": "char",
              "WriteAs": "WRITEMODE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "AddAvailableProperty(cmsIT8* it8, const char* Key, WRITEMODE as)",
          "fn_dec_pos": [
            [
              1389,
              10
            ],
            [
              1389,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddAvailableProperty",
            "parameters": {
              "it8": "cmsIT8",
              "Key": "char",
              "as": "WRITEMODE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "AddAvailableSampleID(cmsIT8* it8, const char* Key)",
          "fn_dec_pos": [
            [
              1396,
              10
            ],
            [
              1396,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddAvailableSampleID",
            "parameters": {
              "it8": "cmsIT8",
              "Key": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsIT8GetSheetType(cmsHANDLE hIT8)",
          "fn_dec_pos": [
            [
              1502,
              22
            ],
            [
              1502,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetSheetType",
            "parameters": {
              "hIT8": "cmsHANDLE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsIT8GetProperty(cmsHANDLE hIT8, const char* Key)",
          "fn_dec_pos": [
            [
              1572,
              22
            ],
            [
              1572,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetProperty",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "Key": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsIT8GetPropertyMulti(cmsHANDLE hIT8, const char* Key, const char *SubKey)",
          "fn_dec_pos": [
            [
              1594,
              22
            ],
            [
              1594,
              97
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetPropertyMulti",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "Key": "char",
              "SubKey": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "GetDataFormat(cmsIT8* it8, int n)",
          "fn_dec_pos": [
            [
              1653,
              12
            ],
            [
              1653,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetDataFormat",
            "parameters": {
              "it8": "cmsIT8",
              "n": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "satob(const char* v)",
          "fn_dec_pos": [
            [
              1696,
              12
            ],
            [
              1696,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "satob",
            "parameters": {
              "v": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "GetData(cmsIT8* it8, int nSet, int nField)",
          "fn_dec_pos": [
            [
              1743,
              6
            ],
            [
              1743,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetData",
            "parameters": {
              "it8": "cmsIT8",
              "nSet": "int",
              "nField": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsIT8GetDataRowCol(cmsHANDLE hIT8, int row, int col)",
          "fn_dec_pos": [
            [
              2810,
              22
            ],
            [
              2810,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetDataRowCol",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "row": "int",
              "col": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsIT8GetData(cmsHANDLE hIT8, const char* cPatch, const char* cSample)",
          "fn_dec_pos": [
            [
              2856,
              22
            ],
            [
              2856,
              92
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetData",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cPatch": "char",
              "cSample": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsIT8GetPatchName(cmsHANDLE hIT8, int nPatch, char* buffer)",
          "fn_dec_pos": [
            [
              2949,
              22
            ],
            [
              2949,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetPatchName",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "nPatch": "int",
              "buffer": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct _KeyVal {\n\n        struct _KeyVal*  Next;\n        char*            Keyword;       // Name of variable\n        struct _KeyVal*  NextSubkey;    // If key is a dictionary, points to the next item\n        char*            Subkey;        // If key is a dictionary, points to the subkey name\n        char*            Value;         // Points to value\n        WRITEMODE        WriteAs;       // How to write the value\n\n   } KEYVALUE;",
          {
            "*  Next": "struct _KeyVal",
            "*            Keyword": "char",
            "*  NextSubkey": "struct _KeyVal",
            "*            Subkey": "char",
            "*            Value": "char",
            "WriteAs": "WRITEMODE"
          },
          "KEYVALUE",
          [
            97,
            0
          ],
          [
            106,
            14
          ]
        ],
        [
          "typedef struct _OwnedMem {\n\n        struct _OwnedMem* Next;\n        void *            Ptr;          // Point to value\n\n   } OWNEDMEM;",
          {
            "* Next": "struct _OwnedMem",
            "*            Ptr": "void"
          },
          "OWNEDMEM",
          [
            110,
            0
          ],
          [
            115,
            14
          ]
        ],
        [
          "typedef struct _SubAllocator {\n\n         cmsUInt8Number* Block;\n         cmsUInt32Number BlockSize;\n         cmsUInt32Number Used;\n\n    } SUBALLOCATOR;",
          {
            "* Block": "cmsUInt8Number",
            "BlockSize": "cmsUInt32Number",
            "Used": "cmsUInt32Number"
          },
          "SUBALLOCATOR",
          [
            118,
            0
          ],
          [
            124,
            19
          ]
        ],
        [
          "typedef struct _Table {\n\n        char SheetType[MAXSTR];               // The first row of the IT8 (the type)\n\n        int            nSamples, nPatches;    // Cols, Rows\n        int            SampleID;              // Pos of ID\n\n        KEYVALUE*      HeaderList;            // The properties\n\n        char**         DataFormat;            // The binary stream descriptor\n        char**         Data;                  // The binary stream\n\n    } TABLE;",
          {
            "SheetType[MAXSTR]": "char",
            "nSamples": "int",
            "SampleID": "int",
            "*      HeaderList": "KEYVALUE",
            "**         DataFormat": "char",
            "**         Data": "char"
          },
          "TABLE",
          [
            127,
            0
          ],
          [
            139,
            12
          ]
        ],
        [
          "typedef struct _FileContext {\n        char           FileName[cmsMAX_PATH];    // File name if being read from file\n        FILE*          Stream;                   // File stream or NULL if holded in memory\n    } FILECTX;",
          {
            "FileName[cmsMAX_PATH]": "char",
            "*          Stream": "FILE"
          },
          "FILECTX",
          [
            142,
            0
          ],
          [
            145,
            14
          ]
        ],
        [
          "typedef struct {\n\n        struct struct_it8* it8;\n        cmsInt32Number max;\n        cmsInt32Number len;\n        char* begin;\n    } string;",
          {
            "* it8": "struct struct_it8",
            "max": "cmsInt32Number",
            "len": "cmsInt32Number",
            "* begin": "char"
          },
          "string",
          [
            148,
            0
          ],
          [
            154,
            13
          ]
        ],
        [
          "typedef struct struct_it8 {\n\n        cmsUInt32Number  TablesCount;                     // How many tables in this stream\n        cmsUInt32Number  nTable;                          // The actual table\n\n        // Partser type\n        cmsBool        IsCUBE;\n\n        // Tables\n        TABLE Tab[MAXTABLES];\n\n        // Memory management\n        OWNEDMEM*      MemorySink;            // The storage backend\n        SUBALLOCATOR   Allocator;             // String suballocator -- just to keep it fast\n\n        // Parser state machine\n        SYMBOL             sy;                // Current symbol\n        int                ch;                // Current character\n\n        cmsInt32Number     inum;              // integer value\n        cmsFloat64Number   dnum;              // real value\n\n        string*        id;            // identifier\n        string*        str;           // string\n\n        // Allowed keywords & datasets. They have visibility on whole stream\n        KEYVALUE*      ValidKeywords;\n        KEYVALUE*      ValidSampleID;\n\n        char*          Source;                // Points to loc. being parsed\n        cmsInt32Number lineno;                // line counter for error reporting\n\n        FILECTX*       FileStack[MAXINCLUDE]; // Stack of files being parsed\n        cmsInt32Number IncludeSP;             // Include Stack Pointer\n\n        char*          MemoryBlock;           // The stream if holded in memory\n\n        char           DoubleFormatter[MAXID];// Printf-like 'cmsFloat64Number' formatter\n\n        cmsContext    ContextID;              // The threading context\n\n   } cmsIT8;",
          {
            "TablesCount": "cmsUInt32Number",
            "nTable": "cmsUInt32Number",
            "IsCUBE": "cmsBool",
            "Tab[MAXTABLES]": "TABLE",
            "*      MemorySink": "OWNEDMEM",
            "Allocator": "SUBALLOCATOR",
            "sy": "SYMBOL",
            "ch": "int",
            "inum": "cmsInt32Number",
            "dnum": "cmsFloat64Number",
            "*        id": "string",
            "*        str": "string",
            "*      ValidKeywords": "KEYVALUE",
            "*      ValidSampleID": "KEYVALUE",
            "*          Source": "char",
            "lineno": "cmsInt32Number",
            "*       FileStack[MAXINCLUDE]": "FILECTX",
            "IncludeSP": "cmsInt32Number",
            "*          MemoryBlock": "char",
            "DoubleFormatter[MAXID]": "char",
            "ContextID": "cmsContext"
          },
          "cmsIT8",
          [
            158,
            0
          ],
          [
            199,
            12
          ]
        ],
        [
          "typedef struct {\n\n        FILE* stream;   // For save-to-file behaviour\n\n        cmsUInt8Number* Base;\n        cmsUInt8Number* Ptr;        // For save-to-mem behaviour\n        cmsUInt32Number Used;\n        cmsUInt32Number Max;\n\n    } SAVESTREAM;",
          {
            "* stream": "FILE",
            "* Base": "cmsUInt8Number",
            "* Ptr": "cmsUInt8Number",
            "Used": "cmsUInt32Number",
            "Max": "cmsUInt32Number"
          },
          "SAVESTREAM",
          [
            203,
            0
          ],
          [
            212,
            17
          ]
        ],
        [
          "typedef struct {\n\n        const char *id;\n        SYMBOL sy;\n\n   } KEYWORD;",
          {
            "char": "const",
            "sy": "SYMBOL"
          },
          "KEYWORD",
          [
            219,
            0
          ],
          [
            224,
            13
          ]
        ],
        [
          "typedef struct {\n        const char *id;    // The identifier\n        WRITEMODE as;      // How is supposed to be written\n    } PROPERTY;",
          {
            "char": "const",
            "as": "WRITEMODE"
          },
          "PROPERTY",
          [
            263,
            0
          ],
          [
            266,
            15
          ]
        ],
        [
          "typedef struct _KeyVal {\n\n        struct _KeyVal*  Next;\n        char*            Keyword;       // Name of variable\n        struct _KeyVal*  NextSubkey;    // If key is a dictionary, points to the next item\n        char*            Subkey;        // If key is a dictionary, points to the subkey name\n        char*            Value;         // Points to value\n        WRITEMODE        WriteAs;       // How to write the value\n\n   } KEYVALUE;",
          {
            "*  Next": "struct _KeyVal",
            "*            Keyword": "char",
            "*  NextSubkey": "struct _KeyVal",
            "*            Subkey": "char",
            "*            Value": "char",
            "WriteAs": "WRITEMODE"
          },
          "KEYVALUE",
          [
            97,
            0
          ],
          [
            106,
            14
          ]
        ],
        [
          "struct _KeyVal",
          {},
          "",
          [
            99,
            8
          ],
          [
            99,
            22
          ]
        ],
        [
          "struct _KeyVal",
          {},
          "",
          [
            101,
            8
          ],
          [
            101,
            22
          ]
        ],
        [
          "typedef struct _OwnedMem {\n\n        struct _OwnedMem* Next;\n        void *            Ptr;          // Point to value\n\n   } OWNEDMEM;",
          {
            "* Next": "struct _OwnedMem",
            "*            Ptr": "void"
          },
          "OWNEDMEM",
          [
            110,
            0
          ],
          [
            115,
            14
          ]
        ],
        [
          "struct _OwnedMem",
          {},
          "",
          [
            112,
            8
          ],
          [
            112,
            24
          ]
        ],
        [
          "typedef struct _SubAllocator {\n\n         cmsUInt8Number* Block;\n         cmsUInt32Number BlockSize;\n         cmsUInt32Number Used;\n\n    } SUBALLOCATOR;",
          {
            "* Block": "cmsUInt8Number",
            "BlockSize": "cmsUInt32Number",
            "Used": "cmsUInt32Number"
          },
          "SUBALLOCATOR",
          [
            118,
            0
          ],
          [
            124,
            19
          ]
        ],
        [
          "typedef struct _Table {\n\n        char SheetType[MAXSTR];               // The first row of the IT8 (the type)\n\n        int            nSamples, nPatches;    // Cols, Rows\n        int            SampleID;              // Pos of ID\n\n        KEYVALUE*      HeaderList;            // The properties\n\n        char**         DataFormat;            // The binary stream descriptor\n        char**         Data;                  // The binary stream\n\n    } TABLE;",
          {
            "SheetType[MAXSTR]": "char",
            "nSamples": "int",
            "SampleID": "int",
            "*      HeaderList": "KEYVALUE",
            "**         DataFormat": "char",
            "**         Data": "char"
          },
          "TABLE",
          [
            127,
            0
          ],
          [
            139,
            12
          ]
        ],
        [
          "typedef struct _FileContext {\n        char           FileName[cmsMAX_PATH];    // File name if being read from file\n        FILE*          Stream;                   // File stream or NULL if holded in memory\n    } FILECTX;",
          {
            "FileName[cmsMAX_PATH]": "char",
            "*          Stream": "FILE"
          },
          "FILECTX",
          [
            142,
            0
          ],
          [
            145,
            14
          ]
        ],
        [
          "typedef struct {\n\n        struct struct_it8* it8;\n        cmsInt32Number max;\n        cmsInt32Number len;\n        char* begin;\n    } string;",
          {
            "* it8": "struct struct_it8",
            "max": "cmsInt32Number",
            "len": "cmsInt32Number",
            "* begin": "char"
          },
          "string",
          [
            148,
            0
          ],
          [
            154,
            13
          ]
        ],
        [
          "struct struct_it8",
          {},
          "",
          [
            150,
            8
          ],
          [
            150,
            25
          ]
        ],
        [
          "typedef struct struct_it8 {\n\n        cmsUInt32Number  TablesCount;                     // How many tables in this stream\n        cmsUInt32Number  nTable;                          // The actual table\n\n        // Partser type\n        cmsBool        IsCUBE;\n\n        // Tables\n        TABLE Tab[MAXTABLES];\n\n        // Memory management\n        OWNEDMEM*      MemorySink;            // The storage backend\n        SUBALLOCATOR   Allocator;             // String suballocator -- just to keep it fast\n\n        // Parser state machine\n        SYMBOL             sy;                // Current symbol\n        int                ch;                // Current character\n\n        cmsInt32Number     inum;              // integer value\n        cmsFloat64Number   dnum;              // real value\n\n        string*        id;            // identifier\n        string*        str;           // string\n\n        // Allowed keywords & datasets. They have visibility on whole stream\n        KEYVALUE*      ValidKeywords;\n        KEYVALUE*      ValidSampleID;\n\n        char*          Source;                // Points to loc. being parsed\n        cmsInt32Number lineno;                // line counter for error reporting\n\n        FILECTX*       FileStack[MAXINCLUDE]; // Stack of files being parsed\n        cmsInt32Number IncludeSP;             // Include Stack Pointer\n\n        char*          MemoryBlock;           // The stream if holded in memory\n\n        char           DoubleFormatter[MAXID];// Printf-like 'cmsFloat64Number' formatter\n\n        cmsContext    ContextID;              // The threading context\n\n   } cmsIT8;",
          {
            "TablesCount": "cmsUInt32Number",
            "nTable": "cmsUInt32Number",
            "IsCUBE": "cmsBool",
            "Tab[MAXTABLES]": "TABLE",
            "*      MemorySink": "OWNEDMEM",
            "Allocator": "SUBALLOCATOR",
            "sy": "SYMBOL",
            "ch": "int",
            "inum": "cmsInt32Number",
            "dnum": "cmsFloat64Number",
            "*        id": "string",
            "*        str": "string",
            "*      ValidKeywords": "KEYVALUE",
            "*      ValidSampleID": "KEYVALUE",
            "*          Source": "char",
            "lineno": "cmsInt32Number",
            "*       FileStack[MAXINCLUDE]": "FILECTX",
            "IncludeSP": "cmsInt32Number",
            "*          MemoryBlock": "char",
            "DoubleFormatter[MAXID]": "char",
            "ContextID": "cmsContext"
          },
          "cmsIT8",
          [
            158,
            0
          ],
          [
            199,
            12
          ]
        ],
        [
          "typedef struct {\n\n        FILE* stream;   // For save-to-file behaviour\n\n        cmsUInt8Number* Base;\n        cmsUInt8Number* Ptr;        // For save-to-mem behaviour\n        cmsUInt32Number Used;\n        cmsUInt32Number Max;\n\n    } SAVESTREAM;",
          {
            "* stream": "FILE",
            "* Base": "cmsUInt8Number",
            "* Ptr": "cmsUInt8Number",
            "Used": "cmsUInt32Number",
            "Max": "cmsUInt32Number"
          },
          "SAVESTREAM",
          [
            203,
            0
          ],
          [
            212,
            17
          ]
        ],
        [
          "typedef struct {\n\n        const char *id;\n        SYMBOL sy;\n\n   } KEYWORD;",
          {
            "char": "const",
            "sy": "SYMBOL"
          },
          "KEYWORD",
          [
            219,
            0
          ],
          [
            224,
            13
          ]
        ],
        [
          "typedef struct {\n        const char *id;    // The identifier\n        WRITEMODE as;      // How is supposed to be written\n    } PROPERTY;",
          {
            "char": "const",
            "as": "WRITEMODE"
          },
          "PROPERTY",
          [
            263,
            0
          ],
          [
            266,
            15
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#    include <io.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n\n        SUNDEFINED,\n        SINUM,      // Integer\n        SDNUM,      // Real\n        SIDENT,     // Identifier\n        SSTRING,    // string\n        SCOMMENT,   // comment\n        SEOLN,      // End of line\n        SEOF,       // End of stream\n        SSYNERROR,  // Syntax error found on stream\n\n        // IT8 symbols\n\n        SBEGIN_DATA,\n        SBEGIN_DATA_FORMAT,\n        SEND_DATA,\n        SEND_DATA_FORMAT,\n        SKEYWORD,\n        SDATA_FORMAT_ID,\n        SINCLUDE,\n\n        // Cube symbols\n\n        SDOMAIN_MAX,\n        SDOMAIN_MIN,\n        S_LUT1D_SIZE,\n        S_LUT1D_INPUT_RANGE,\n        S_LUT3D_SIZE,\n        S_LUT3D_INPUT_RANGE,\n        S_LUT_IN_VIDEO_RANGE,\n        S_LUT_OUT_VIDEO_RANGE,\n        STITLE\n\n    } SYMBOL;",
          {
            "SUNDEFINED": "",
            "SINUM": "",
            "SDNUM": "",
            "SIDENT": "",
            "SSTRING": "",
            "SCOMMENT": "",
            "SEOLN": "",
            "SEOF": "",
            "SSYNERROR": "",
            "SBEGIN_DATA": "",
            "SBEGIN_DATA_FORMAT": "",
            "SEND_DATA": "",
            "SEND_DATA_FORMAT": "",
            "SKEYWORD": "",
            "SDATA_FORMAT_ID": "",
            "SINCLUDE": "",
            "SDOMAIN_MAX": "",
            "SDOMAIN_MIN": "",
            "S_LUT1D_SIZE": "",
            "S_LUT1D_INPUT_RANGE": "",
            "S_LUT3D_SIZE": "",
            "S_LUT3D_INPUT_RANGE": "",
            "S_LUT_IN_VIDEO_RANGE": "",
            "S_LUT_OUT_VIDEO_RANGE": "",
            "STITLE": ""
          },
          "SYMBOL",
          [
            48,
            0
          ],
          [
            82,
            13
          ]
        ],
        [
          "typedef enum {\n\n        WRITE_UNCOOKED,\n        WRITE_STRINGIFY,\n        WRITE_HEXADECIMAL,\n        WRITE_BINARY,\n        WRITE_PAIR\n\n    } WRITEMODE;",
          {
            "WRITE_UNCOOKED": "",
            "WRITE_STRINGIFY": "",
            "WRITE_HEXADECIMAL": "",
            "WRITE_BINARY": "",
            "WRITE_PAIR": ""
          },
          "WRITEMODE",
          [
            86,
            0
          ],
          [
            94,
            16
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmshalf.c": {
      "fn_def_list": [
        {
          "fn_code": "cmsFloat32Number CMSEXPORT _cmsHalf2Float(cmsUInt16Number h)\n{\n    union {\n        cmsFloat32Number flt;\n        cmsUInt32Number  num;\n    } out;\n\n    int n = h >> 10;\n\n    out.num = Mantissa[  (h & 0x3ff) + Offset[ n ] ] + Exponent[ n ];\n    return out.flt;\n}",
          "fn_code_pos": [
            [
              505,
              0
            ],
            [
              516,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsHalf2Float",
            "parameters": {
              "h": "cmsUInt16Number"
            },
            "return_type": "cmsFloat32Number"
          }
        },
        {
          "fn_code": "cmsUInt16Number CMSEXPORT _cmsFloat2Half(cmsFloat32Number flt)\n{\n    union {\n        cmsFloat32Number flt;\n        cmsUInt32Number  num;\n    } in;\n\n    cmsUInt32Number n, j;\n\n    in.flt = flt;\n    n = in.num;\n    j = (n >> 23) & 0x1ff;\n\n    return (cmsUInt16Number) ((cmsUInt32Number) Base[ j ] + (( n & 0x007fffff) >> Shift[ j ]));\n}",
          "fn_code_pos": [
            [
              518,
              0
            ],
            [
              532,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsFloat2Half",
            "parameters": {
              "flt": "cmsFloat32Number"
            },
            "return_type": "cmsUInt16Number"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmsxform.c": {
      "fn_def_list": [
        {
          "fn_code": "void _cmsAllocAdaptationStateChunk(struct _cmsContext_struct* ctx, \n                                   const struct _cmsContext_struct* src)\n{\n    static _cmsAdaptationStateChunkType AdaptationStateChunk = { DEFAULT_OBSERVER_ADAPTATION_STATE };\n    void* from;\n     \n    if (src != NULL) {\n        from = src ->chunks[AdaptationStateContext];       \n    }\n    else {\n       from = &AdaptationStateChunk;\n    }\n    \n    ctx ->chunks[AdaptationStateContext] = _cmsSubAllocDup(ctx ->MemPool, from, sizeof(_cmsAdaptationStateChunkType));     \n}",
          "fn_code_pos": [
            [
              37,
              0
            ],
            [
              51,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocAdaptationStateChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsFloat64Number CMSEXPORT cmsSetAdaptationStateTHR(cmsContext ContextID, cmsFloat64Number d)\n{\n    cmsFloat64Number prev;\n    _cmsAdaptationStateChunkType* ptr = (_cmsAdaptationStateChunkType*) _cmsContextGetClientChunk(ContextID, AdaptationStateContext);\n\n    // Get previous value for return\n    prev = ptr ->AdaptationState;\n\n    // Set the value if d is positive or zero\n    if (d >= 0.0) {\n\n        ptr ->AdaptationState = d;\n    }\n\n    // Always return previous value\n    return prev;\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              72,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetAdaptationStateTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "d": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "cmsFloat64Number CMSEXPORT cmsSetAdaptationState(cmsFloat64Number d)\n{    \n    return cmsSetAdaptationStateTHR(NULL, d);\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetAdaptationState",
            "parameters": {
              "d": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsSetAlarmCodesTHR(cmsContext ContextID, const cmsUInt16Number AlarmCodesP[cmsMAXCHANNELS])\n{\n    _cmsAlarmCodesChunkType* ContextAlarmCodes = (_cmsAlarmCodesChunkType*) _cmsContextGetClientChunk(ContextID, AlarmCodesContext);\n       \n    _cmsAssert(ContextAlarmCodes != NULL); // Can't happen\n    \n    memcpy(ContextAlarmCodes->AlarmCodes, AlarmCodesP, sizeof(ContextAlarmCodes->AlarmCodes));    \n}",
          "fn_code_pos": [
            [
              92,
              0
            ],
            [
              99,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetAlarmCodesTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "AlarmCodesP": "cmsUInt16Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsGetAlarmCodesTHR(cmsContext ContextID, cmsUInt16Number AlarmCodesP[cmsMAXCHANNELS])\n{\n    _cmsAlarmCodesChunkType* ContextAlarmCodes = (_cmsAlarmCodesChunkType*) _cmsContextGetClientChunk(ContextID, AlarmCodesContext);\n\n    _cmsAssert(ContextAlarmCodes != NULL); // Can't happen\n\n    memcpy(AlarmCodesP, ContextAlarmCodes->AlarmCodes, sizeof(ContextAlarmCodes->AlarmCodes));\n}",
          "fn_code_pos": [
            [
              103,
              0
            ],
            [
              110,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetAlarmCodesTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "AlarmCodesP": "cmsUInt16Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsSetAlarmCodes(const cmsUInt16Number NewAlarm[cmsMAXCHANNELS])\n{\n    _cmsAssert(NewAlarm != NULL);\n\n    cmsSetAlarmCodesTHR(NULL, NewAlarm);\n}",
          "fn_code_pos": [
            [
              112,
              0
            ],
            [
              117,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetAlarmCodes",
            "parameters": {
              "NewAlarm": "cmsUInt16Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsGetAlarmCodes(cmsUInt16Number OldAlarm[cmsMAXCHANNELS])\n{ \n    _cmsAssert(OldAlarm != NULL);\n    cmsGetAlarmCodesTHR(NULL, OldAlarm);\n}",
          "fn_code_pos": [
            [
              119,
              0
            ],
            [
              123,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetAlarmCodes",
            "parameters": {
              "OldAlarm": "cmsUInt16Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void _cmsAllocAlarmCodesChunk(struct _cmsContext_struct* ctx, \n                              const struct _cmsContext_struct* src)\n{\n    static _cmsAlarmCodesChunkType AlarmCodesChunk = { DEFAULT_ALARM_CODES_VALUE };\n    void* from;\n     \n    if (src != NULL) {\n        from = src ->chunks[AlarmCodesContext];       \n    }\n    else {\n       from = &AlarmCodesChunk;\n    }\n    \n    ctx ->chunks[AlarmCodesContext] = _cmsSubAllocDup(ctx ->MemPool, from, sizeof(_cmsAlarmCodesChunkType));     \n}",
          "fn_code_pos": [
            [
              127,
              0
            ],
            [
              141,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocAlarmCodesChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsDeleteTransform(cmsHTRANSFORM hTransform)\n{\n    _cmsTRANSFORM* p = (_cmsTRANSFORM*) hTransform;\n\n    _cmsAssert(p != NULL);\n\n    if (p -> GamutCheck)\n        cmsPipelineFree(p -> GamutCheck);\n\n    if (p -> Lut)\n        cmsPipelineFree(p -> Lut);\n\n    if (p ->InputColorant)\n        cmsFreeNamedColorList(p ->InputColorant);\n\n    if (p -> OutputColorant)\n        cmsFreeNamedColorList(p ->OutputColorant);\n\n    if (p ->Sequence)\n        cmsFreeProfileSequenceDescription(p ->Sequence);\n\n    if (p ->UserData)\n        p ->FreeUserData(p ->ContextID, p ->UserData);\n\n    _cmsFree(p ->ContextID, (void *) p);\n}",
          "fn_code_pos": [
            [
              146,
              0
            ],
            [
              171,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDeleteTransform",
            "parameters": {
              "hTransform": "cmsHTRANSFORM"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number PixelSize(cmsUInt32Number Format)\n{\n    cmsUInt32Number fmt_bytes = T_BYTES(Format);\n\n    // For double, the T_BYTES field is zero\n    if (fmt_bytes == 0)\n        return sizeof(cmsUInt64Number);\n\n    // Otherwise, it is already correct for all formats\n    return fmt_bytes;\n}",
          "fn_code_pos": [
            [
              174,
              0
            ],
            [
              185,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixelSize",
            "parameters": {
              "Format": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsDoTransform(cmsHTRANSFORM  Transform,\n                              const void* InputBuffer,\n                              void* OutputBuffer,\n                              cmsUInt32Number Size)\n\n{\n    _cmsTRANSFORM* p = (_cmsTRANSFORM*) Transform;\n    cmsStride stride;\n\n    stride.BytesPerLineIn = 0;  // Not used\n    stride.BytesPerLineOut = 0;\n    stride.BytesPerPlaneIn = Size * PixelSize(p->InputFormat);\n    stride.BytesPerPlaneOut = Size * PixelSize(p->OutputFormat);\n           \n    p -> xform(p, InputBuffer, OutputBuffer, Size, 1, &stride);\n}",
          "fn_code_pos": [
            [
              191,
              0
            ],
            [
              206,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDoTransform",
            "parameters": {
              "Transform": "cmsHTRANSFORM",
              "InputBuffer": "void",
              "OutputBuffer": "void",
              "Size": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsDoTransformStride(cmsHTRANSFORM  Transform,\n                              const void* InputBuffer,\n                              void* OutputBuffer,\n                              cmsUInt32Number Size, cmsUInt32Number Stride)\n\n{\n    _cmsTRANSFORM* p = (_cmsTRANSFORM*) Transform;\n    cmsStride stride;\n\n    stride.BytesPerLineIn = 0;  \n    stride.BytesPerLineOut = 0;\n    stride.BytesPerPlaneIn = Stride;\n    stride.BytesPerPlaneOut = Stride;\n\n    p -> xform(p, InputBuffer, OutputBuffer, Size, 1, &stride);\n}",
          "fn_code_pos": [
            [
              210,
              0
            ],
            [
              225,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDoTransformStride",
            "parameters": {
              "Transform": "cmsHTRANSFORM",
              "InputBuffer": "void",
              "OutputBuffer": "void",
              "Size": "cmsUInt32Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsDoTransformLineStride(cmsHTRANSFORM  Transform,\n                              const void* InputBuffer,\n                              void* OutputBuffer,\n                              cmsUInt32Number PixelsPerLine,\n                              cmsUInt32Number LineCount,\n                              cmsUInt32Number BytesPerLineIn,\n                              cmsUInt32Number BytesPerLineOut,\n                              cmsUInt32Number BytesPerPlaneIn,\n                              cmsUInt32Number BytesPerPlaneOut)\n\n{\n    _cmsTRANSFORM* p = (_cmsTRANSFORM*) Transform;\n    cmsStride stride;\n\n    stride.BytesPerLineIn = BytesPerLineIn;\n    stride.BytesPerLineOut = BytesPerLineOut;\n    stride.BytesPerPlaneIn = BytesPerPlaneIn;\n    stride.BytesPerPlaneOut = BytesPerPlaneOut;\n\n    p->xform(p, InputBuffer, OutputBuffer, PixelsPerLine, LineCount, &stride);\n}",
          "fn_code_pos": [
            [
              228,
              0
            ],
            [
              248,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDoTransformLineStride",
            "parameters": {
              "Transform": "cmsHTRANSFORM",
              "InputBuffer": "void",
              "OutputBuffer": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "BytesPerLineIn": "cmsUInt32Number",
              "BytesPerLineOut": "cmsUInt32Number",
              "BytesPerPlaneIn": "cmsUInt32Number",
              "BytesPerPlaneOut": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid FloatXFORM(_cmsTRANSFORM* p,\n                const void* in,\n                void* out, \n                cmsUInt32Number PixelsPerLine,\n                cmsUInt32Number LineCount,\n                const cmsStride* Stride)\n{\n    cmsUInt8Number* accum;\n    cmsUInt8Number* output;\n    cmsFloat32Number fIn[cmsMAXCHANNELS], fOut[cmsMAXCHANNELS];\n    cmsFloat32Number OutOfGamut;\n    size_t i, j, c, strideIn, strideOut;\n\n    _cmsHandleExtraChannels(p, in, out, PixelsPerLine, LineCount, Stride);\n\n    strideIn = 0;\n    strideOut = 0;\n    memset(fIn, 0, sizeof(fIn));\n    memset(fOut, 0, sizeof(fOut));\n\n    for (i = 0; i < LineCount; i++) {\n\n        accum = (cmsUInt8Number*)in + strideIn;\n        output = (cmsUInt8Number*)out + strideOut;\n\n        for (j = 0; j < PixelsPerLine; j++) {\n\n            accum = p->FromInputFloat(p, fIn, accum, Stride->BytesPerPlaneIn);\n\n            // Any gamut check to do?\n            if (p->GamutCheck != NULL) {\n\n                // Evaluate gamut marker.\n                cmsPipelineEvalFloat(fIn, &OutOfGamut, p->GamutCheck);\n\n                // Is current color out of gamut?\n                if (OutOfGamut > 0.0) {\n\n                    // Certainly, out of gamut\n                    for (c = 0; c < cmsMAXCHANNELS; c++)\n                        fOut[c] = -1.0;\n\n                }\n                else {\n                    // No, proceed normally\n                    cmsPipelineEvalFloat(fIn, fOut, p->Lut);\n                }\n            }\n            else {\n\n                // No gamut check at all\n                cmsPipelineEvalFloat(fIn, fOut, p->Lut);\n            }\n\n\n            output = p->ToOutputFloat(p, fOut, output, Stride->BytesPerPlaneOut);\n        }\n\n        strideIn += Stride->BytesPerLineIn;\n        strideOut += Stride->BytesPerLineOut;\n    }\n\n}",
          "fn_code_pos": [
            [
              256,
              0
            ],
            [
              319,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FloatXFORM",
            "parameters": {
              "p": "_cmsTRANSFORM",
              "in": "void",
              "out": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid NullFloatXFORM(_cmsTRANSFORM* p,\n                    const void* in,\n                    void* out, \n                    cmsUInt32Number PixelsPerLine,\n                    cmsUInt32Number LineCount,\n                    const cmsStride* Stride)\n\n{\n    cmsUInt8Number* accum;\n    cmsUInt8Number* output;\n    cmsFloat32Number fIn[cmsMAXCHANNELS];\n    size_t i, j, strideIn, strideOut;\n\n    _cmsHandleExtraChannels(p, in, out, PixelsPerLine, LineCount, Stride);\n\n    strideIn = 0;\n    strideOut = 0;\n    memset(fIn, 0, sizeof(fIn));\n\n    for (i = 0; i < LineCount; i++) {\n\n           accum = (cmsUInt8Number*) in + strideIn;\n           output = (cmsUInt8Number*) out + strideOut;\n\n           for (j = 0; j < PixelsPerLine; j++) {\n\n                  accum = p->FromInputFloat(p, fIn, accum, Stride ->BytesPerPlaneIn);\n                  output = p->ToOutputFloat(p, fIn, output, Stride->BytesPerPlaneOut);\n           }\n\n           strideIn += Stride->BytesPerLineIn;\n           strideOut += Stride->BytesPerLineOut;\n    }\n}",
          "fn_code_pos": [
            [
              322,
              0
            ],
            [
              356,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NullFloatXFORM",
            "parameters": {
              "p": "_cmsTRANSFORM",
              "in": "void",
              "out": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid NullXFORM(_cmsTRANSFORM* p,\n               const void* in,\n               void* out,\n               cmsUInt32Number PixelsPerLine,\n               cmsUInt32Number LineCount,\n               const cmsStride* Stride)\n{\n    cmsUInt8Number* accum;\n    cmsUInt8Number* output;\n    cmsUInt16Number wIn[cmsMAXCHANNELS];\n    size_t i, j, strideIn, strideOut;\n\n    _cmsHandleExtraChannels(p, in, out, PixelsPerLine, LineCount, Stride);\n\n    strideIn = 0;\n    strideOut = 0;\n    memset(wIn, 0, sizeof(wIn));\n\n    for (i = 0; i < LineCount; i++) {\n\n        accum = (cmsUInt8Number*)in + strideIn;\n        output = (cmsUInt8Number*)out + strideOut;\n\n        for (j = 0; j < PixelsPerLine; j++) {\n\n            accum = p->FromInput(p, wIn, accum, Stride->BytesPerPlaneIn);\n            output = p->ToOutput(p, wIn, output, Stride->BytesPerPlaneOut);\n        }\n\n        strideIn += Stride->BytesPerLineIn;\n        strideOut += Stride->BytesPerLineOut;\n    }\n\n}",
          "fn_code_pos": [
            [
              361,
              0
            ],
            [
              395,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NullXFORM",
            "parameters": {
              "p": "_cmsTRANSFORM",
              "in": "void",
              "out": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid PrecalculatedXFORM(_cmsTRANSFORM* p,\n                        const void* in,\n                        void* out, \n                        cmsUInt32Number PixelsPerLine,\n                        cmsUInt32Number LineCount,\n                        const cmsStride* Stride)\n{\n    CMSREGISTER cmsUInt8Number* accum;\n    CMSREGISTER cmsUInt8Number* output;\n    cmsUInt16Number wIn[cmsMAXCHANNELS], wOut[cmsMAXCHANNELS];\n    size_t i, j, strideIn, strideOut;\n\n    _cmsHandleExtraChannels(p, in, out, PixelsPerLine, LineCount, Stride);\n\n    strideIn = 0;\n    strideOut = 0;\n    memset(wIn, 0, sizeof(wIn));\n    memset(wOut, 0, sizeof(wOut));\n\n    for (i = 0; i < LineCount; i++) {\n\n        accum = (cmsUInt8Number*)in + strideIn;\n        output = (cmsUInt8Number*)out + strideOut;\n\n        for (j = 0; j < PixelsPerLine; j++) {\n\n            accum = p->FromInput(p, wIn, accum, Stride->BytesPerPlaneIn);\n            p->Lut->Eval16Fn(wIn, wOut, p->Lut->Data);\n            output = p->ToOutput(p, wOut, output, Stride->BytesPerPlaneOut);\n        }\n\n        strideIn += Stride->BytesPerLineIn;\n        strideOut += Stride->BytesPerLineOut;\n    }\n\n}",
          "fn_code_pos": [
            [
              399,
              0
            ],
            [
              435,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrecalculatedXFORM",
            "parameters": {
              "p": "_cmsTRANSFORM",
              "in": "void",
              "out": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid TransformOnePixelWithGamutCheck(_cmsTRANSFORM* p,\n                                     const cmsUInt16Number wIn[],\n                                     cmsUInt16Number wOut[])\n{\n    cmsUInt16Number wOutOfGamut;\n\n    p ->GamutCheck ->Eval16Fn(wIn, &wOutOfGamut, p ->GamutCheck ->Data);\n    if (wOutOfGamut >= 1) {\n\n        cmsUInt32Number i;\n        _cmsAlarmCodesChunkType* ContextAlarmCodes = (_cmsAlarmCodesChunkType*) _cmsContextGetClientChunk(p->ContextID, AlarmCodesContext);        \n\n        for (i=0; i < p ->Lut->OutputChannels; i++) {\n\n            wOut[i] = ContextAlarmCodes ->AlarmCodes[i];\n        }\n    }\n    else\n        p ->Lut ->Eval16Fn(wIn, wOut, p -> Lut->Data);\n}",
          "fn_code_pos": [
            [
              439,
              0
            ],
            [
              459,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TransformOnePixelWithGamutCheck",
            "parameters": {
              "p": "_cmsTRANSFORM",
              "wIn": "cmsUInt16Number",
              "wOut": "cmsUInt16Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid PrecalculatedXFORMGamutCheck(_cmsTRANSFORM* p,\n                                  const void* in,\n                                  void* out, \n                                  cmsUInt32Number PixelsPerLine,\n                                  cmsUInt32Number LineCount,\n                                  const cmsStride* Stride)\n{\n    cmsUInt8Number* accum;\n    cmsUInt8Number* output;\n    cmsUInt16Number wIn[cmsMAXCHANNELS], wOut[cmsMAXCHANNELS];\n    size_t i, j, strideIn, strideOut;\n\n    _cmsHandleExtraChannels(p, in, out, PixelsPerLine, LineCount, Stride);\n\n    strideIn = 0;\n    strideOut = 0;\n    memset(wIn, 0, sizeof(wIn));\n    memset(wOut, 0, sizeof(wOut));\n\n    for (i = 0; i < LineCount; i++) {\n\n        accum = (cmsUInt8Number*)in + strideIn;\n        output = (cmsUInt8Number*)out + strideOut;\n\n        for (j = 0; j < PixelsPerLine; j++) {\n\n            accum = p->FromInput(p, wIn, accum, Stride->BytesPerPlaneIn);\n            TransformOnePixelWithGamutCheck(p, wIn, wOut);\n            output = p->ToOutput(p, wOut, output, Stride->BytesPerPlaneOut);\n        }\n\n        strideIn += Stride->BytesPerLineIn;\n        strideOut += Stride->BytesPerLineOut;\n    }\n}",
          "fn_code_pos": [
            [
              462,
              0
            ],
            [
              497,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrecalculatedXFORMGamutCheck",
            "parameters": {
              "p": "_cmsTRANSFORM",
              "in": "void",
              "out": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid CachedXFORM(_cmsTRANSFORM* p,\n                 const void* in,\n                 void* out,\n                 cmsUInt32Number PixelsPerLine,\n                 cmsUInt32Number LineCount,\n                 const cmsStride* Stride)\n{\n    cmsUInt8Number* accum;\n    cmsUInt8Number* output;\n    cmsUInt16Number wIn[cmsMAXCHANNELS], wOut[cmsMAXCHANNELS];\n    _cmsCACHE Cache;\n    size_t i, j, strideIn, strideOut;\n\n    _cmsHandleExtraChannels(p, in, out, PixelsPerLine, LineCount, Stride);\n\n    // Empty buffers for quick memcmp\n    memset(wIn, 0, sizeof(wIn));\n    memset(wOut, 0, sizeof(wOut));\n\n    // Get copy of zero cache\n    memcpy(&Cache, &p->Cache, sizeof(Cache));\n\n    strideIn = 0;\n    strideOut = 0;\n\n    for (i = 0; i < LineCount; i++) {\n\n        accum = (cmsUInt8Number*)in + strideIn;\n        output = (cmsUInt8Number*)out + strideOut;\n\n        for (j = 0; j < PixelsPerLine; j++) {\n\n            accum = p->FromInput(p, wIn, accum, Stride->BytesPerPlaneIn);\n\n            if (memcmp(wIn, Cache.CacheIn, sizeof(Cache.CacheIn)) == 0) {\n\n                memcpy(wOut, Cache.CacheOut, sizeof(Cache.CacheOut));\n            }\n            else {\n                p->Lut->Eval16Fn(wIn, wOut, p->Lut->Data);\n\n                memcpy(Cache.CacheIn, wIn, sizeof(Cache.CacheIn));\n                memcpy(Cache.CacheOut, wOut, sizeof(Cache.CacheOut));\n            }\n\n            output = p->ToOutput(p, wOut, output, Stride->BytesPerPlaneOut);\n        }\n\n        strideIn += Stride->BytesPerLineIn;\n        strideOut += Stride->BytesPerLineOut;\n    }\n}",
          "fn_code_pos": [
            [
              501,
              0
            ],
            [
              553,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CachedXFORM",
            "parameters": {
              "p": "_cmsTRANSFORM",
              "in": "void",
              "out": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid CachedXFORMGamutCheck(_cmsTRANSFORM* p,\n                           const void* in,\n                           void* out, \n                           cmsUInt32Number PixelsPerLine,\n                           cmsUInt32Number LineCount,\n                           const cmsStride* Stride)\n{\n    cmsUInt8Number* accum;\n    cmsUInt8Number* output;\n    cmsUInt16Number wIn[cmsMAXCHANNELS], wOut[cmsMAXCHANNELS];\n    _cmsCACHE Cache;\n    size_t i, j, strideIn, strideOut;\n\n    _cmsHandleExtraChannels(p, in, out, PixelsPerLine, LineCount, Stride);\n\n    // Empty buffers for quick memcmp\n    memset(wIn, 0, sizeof(wIn));\n    memset(wOut, 0, sizeof(wOut));\n\n    // Get copy of zero cache\n    memcpy(&Cache, &p->Cache, sizeof(Cache));\n\n    strideIn = 0;\n    strideOut = 0;\n\n    for (i = 0; i < LineCount; i++) {\n\n        accum = (cmsUInt8Number*)in + strideIn;\n        output = (cmsUInt8Number*)out + strideOut;\n\n        for (j = 0; j < PixelsPerLine; j++) {\n\n            accum = p->FromInput(p, wIn, accum, Stride->BytesPerPlaneIn);\n\n            if (memcmp(wIn, Cache.CacheIn, sizeof(Cache.CacheIn)) == 0) {\n\n                memcpy(wOut, Cache.CacheOut, sizeof(Cache.CacheOut));\n            }\n            else {\n                TransformOnePixelWithGamutCheck(p, wIn, wOut);\n\n                memcpy(Cache.CacheIn, wIn, sizeof(Cache.CacheIn));\n                memcpy(Cache.CacheOut, wOut, sizeof(Cache.CacheOut));\n            }\n\n            output = p->ToOutput(p, wOut, output, Stride->BytesPerPlaneOut);\n        }\n\n        strideIn += Stride->BytesPerLineIn;\n        strideOut += Stride->BytesPerLineOut;\n    }\n}",
          "fn_code_pos": [
            [
              556,
              0
            ],
            [
              608,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CachedXFORMGamutCheck",
            "parameters": {
              "p": "_cmsTRANSFORM",
              "in": "void",
              "out": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid DupPluginTransformList(struct _cmsContext_struct* ctx, \n                                               const struct _cmsContext_struct* src)\n{\n   _cmsTransformPluginChunkType newHead = { NULL };\n   _cmsTransformCollection*  entry;\n   _cmsTransformCollection*  Anterior = NULL;\n   _cmsTransformPluginChunkType* head = (_cmsTransformPluginChunkType*) src->chunks[TransformPlugin];\n\n    // Walk the list copying all nodes\n   for (entry = head->TransformCollection;\n        entry != NULL;\n        entry = entry ->Next) {\n\n            _cmsTransformCollection *newEntry = ( _cmsTransformCollection *) _cmsSubAllocDup(ctx ->MemPool, entry, sizeof(_cmsTransformCollection));\n   \n            if (newEntry == NULL) \n                return;\n\n            // We want to keep the linked list order, so this is a little bit tricky\n            newEntry -> Next = NULL;\n            if (Anterior)\n                Anterior -> Next = newEntry;\n     \n            Anterior = newEntry;\n\n            if (newHead.TransformCollection == NULL)\n                newHead.TransformCollection = newEntry;\n    }\n\n  ctx ->chunks[TransformPlugin] = _cmsSubAllocDup(ctx->MemPool, &newHead, sizeof(_cmsTransformPluginChunkType));\n}",
          "fn_code_pos": [
            [
              627,
              0
            ],
            [
              658,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DupPluginTransformList",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void _cmsAllocTransformPluginChunk(struct _cmsContext_struct* ctx, \n                                        const struct _cmsContext_struct* src)\n{\n    if (src != NULL) {\n\n        // Copy all linked list\n        DupPluginTransformList(ctx, src);\n    }\n    else {\n        static _cmsTransformPluginChunkType TransformPluginChunkType = { NULL };\n        ctx ->chunks[TransformPlugin] = _cmsSubAllocDup(ctx ->MemPool, &TransformPluginChunkType, sizeof(_cmsTransformPluginChunkType));\n    }\n}",
          "fn_code_pos": [
            [
              661,
              0
            ],
            [
              673,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocTransformPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid _cmsTransform2toTransformAdaptor(struct _cmstransform_struct *CMMcargo,\n                                      const void* InputBuffer,\n                                      void* OutputBuffer,\n                                      cmsUInt32Number PixelsPerLine,\n                                      cmsUInt32Number LineCount,\n                                      const cmsStride* Stride)\n{\n     \n       size_t i, strideIn, strideOut;\n\n       _cmsHandleExtraChannels(CMMcargo, InputBuffer, OutputBuffer, PixelsPerLine, LineCount, Stride);\n\n       strideIn = 0;\n       strideOut = 0;\n\n       for (i = 0; i < LineCount; i++) {\n\n              void *accum = (cmsUInt8Number*)InputBuffer + strideIn;\n              void *output = (cmsUInt8Number*)OutputBuffer + strideOut;\n\n              CMMcargo->OldXform(CMMcargo, accum, output, PixelsPerLine, Stride->BytesPerPlaneIn);\n\n              strideIn += Stride->BytesPerLineIn;\n              strideOut += Stride->BytesPerLineOut;\n       }\n}",
          "fn_code_pos": [
            [
              676,
              0
            ],
            [
              702,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsTransform2toTransformAdaptor",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "InputBuffer": "void",
              "OutputBuffer": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool  _cmsRegisterTransformPlugin(cmsContext ContextID, cmsPluginBase* Data)\n{\n    cmsPluginTransform* Plugin = (cmsPluginTransform*) Data;\n    _cmsTransformCollection* fl;\n    _cmsTransformPluginChunkType* ctx = ( _cmsTransformPluginChunkType*) _cmsContextGetClientChunk(ContextID,TransformPlugin);\n\n    if (Data == NULL) {\n\n        // Free the chain. Memory is safely freed at exit\n        ctx->TransformCollection = NULL;\n        return TRUE;\n    }\n\n    // Factory callback is required\n    if (Plugin->factories.xform == NULL) return FALSE;\n\n\n    fl = (_cmsTransformCollection*) _cmsPluginMalloc(ContextID, sizeof(_cmsTransformCollection));\n    if (fl == NULL) return FALSE;\n\n    // Check for full xform plug-ins previous to 2.8, we would need an adapter in that case\n    if (Plugin->base.ExpectedVersion < 2080) {\n\n           fl->OldXform = TRUE;\n    }\n    else\n           fl->OldXform = FALSE;\n\n    // Copy the parameters\n    fl->Factory = Plugin->factories.xform;\n\n    // Keep linked list\n    fl ->Next = ctx->TransformCollection;\n    ctx->TransformCollection = fl;\n\n    // All is ok\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              707,
              0
            ],
            [
              744,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterTransformPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Data": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "void CMSEXPORT _cmsSetTransformUserData(struct _cmstransform_struct *CMMcargo, void* ptr, _cmsFreeUserDataFn FreePrivateDataFn)\n{\n    _cmsAssert(CMMcargo != NULL);\n    CMMcargo ->UserData = ptr;\n    CMMcargo ->FreeUserData = FreePrivateDataFn;\n}",
          "fn_code_pos": [
            [
              747,
              0
            ],
            [
              752,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsSetTransformUserData",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "ptr": "void",
              "FreePrivateDataFn": "_cmsFreeUserDataFn"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void * CMSEXPORT _cmsGetTransformUserData(struct _cmstransform_struct *CMMcargo)\n{\n    _cmsAssert(CMMcargo != NULL);\n    return CMMcargo ->UserData;\n}",
          "fn_code_pos": [
            [
              755,
              0
            ],
            [
              759,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTransformUserData",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT _cmsGetTransformFormatters16(struct _cmstransform_struct *CMMcargo, cmsFormatter16* FromInput, cmsFormatter16* ToOutput)\n{\n     _cmsAssert(CMMcargo != NULL);\n     if (FromInput) *FromInput = CMMcargo ->FromInput;\n     if (ToOutput)  *ToOutput  = CMMcargo ->ToOutput;\n}",
          "fn_code_pos": [
            [
              762,
              0
            ],
            [
              767,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTransformFormatters16",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "FromInput": "cmsFormatter16",
              "ToOutput": "cmsFormatter16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT _cmsGetTransformFormattersFloat(struct _cmstransform_struct *CMMcargo, cmsFormatterFloat* FromInput, cmsFormatterFloat* ToOutput)\n{\n     _cmsAssert(CMMcargo != NULL);\n     if (FromInput) *FromInput = CMMcargo ->FromInputFloat;\n     if (ToOutput)  *ToOutput  = CMMcargo ->ToOutputFloat;\n}",
          "fn_code_pos": [
            [
              769,
              0
            ],
            [
              774,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTransformFormattersFloat",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "FromInput": "cmsFormatterFloat",
              "ToOutput": "cmsFormatterFloat"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT _cmsGetTransformFlags(struct _cmstransform_struct* CMMcargo)\n{\n    _cmsAssert(CMMcargo != NULL);\n    return CMMcargo->dwOriginalFlags;\n}",
          "fn_code_pos": [
            [
              777,
              0
            ],
            [
              781,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTransformFlags",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "_cmsTransform2Fn CMSEXPORT _cmsGetTransformWorker(struct _cmstransform_struct* CMMcargo)\n{\n    _cmsAssert(CMMcargo != NULL);\n    return CMMcargo->Worker;\n}",
          "fn_code_pos": [
            [
              784,
              0
            ],
            [
              788,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTransformWorker",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct"
            },
            "return_type": "_cmsTransform2Fn"
          }
        },
        {
          "fn_code": "cmsInt32Number CMSEXPORT _cmsGetTransformMaxWorkers(struct _cmstransform_struct* CMMcargo)\n{\n    _cmsAssert(CMMcargo != NULL);\n    return CMMcargo->MaxWorkers;\n}",
          "fn_code_pos": [
            [
              791,
              0
            ],
            [
              795,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTransformMaxWorkers",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT _cmsGetTransformWorkerFlags(struct _cmstransform_struct* CMMcargo)\n{\n    _cmsAssert(CMMcargo != NULL);\n    return CMMcargo->WorkerFlags;\n}",
          "fn_code_pos": [
            [
              798,
              0
            ],
            [
              802,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTransformWorkerFlags",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid ParalellizeIfSuitable(_cmsTRANSFORM* p)\n{\n    _cmsParallelizationPluginChunkType* ctx = (_cmsParallelizationPluginChunkType*)_cmsContextGetClientChunk(p->ContextID, ParallelizationPlugin);\n\n    _cmsAssert(p != NULL);\n    if (ctx != NULL && ctx->SchedulerFn != NULL) {\n\n        p->Worker = p->xform;\n        p->xform = ctx->SchedulerFn;\n        p->MaxWorkers = ctx->MaxWorkers;\n        p->WorkerFlags = ctx->WorkerFlags;\n    }\n}",
          "fn_code_pos": [
            [
              805,
              0
            ],
            [
              818,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ParalellizeIfSuitable",
            "parameters": {
              "p": "_cmsTRANSFORM"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollNothing(CMSREGISTER _cmsTRANSFORM* info,\n                              CMSREGISTER cmsUInt16Number wIn[],\n                              CMSREGISTER cmsUInt8Number* accum,\n                              CMSREGISTER cmsUInt32Number Stride)\n{    \n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(wIn);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              824,
              0
            ],
            [
              835,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollNothing",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackNothing(CMSREGISTER _cmsTRANSFORM* info,\n                           CMSREGISTER cmsUInt16Number wOut[],\n                           CMSREGISTER cmsUInt8Number* output,\n                           CMSREGISTER cmsUInt32Number Stride)\n{\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(wOut);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              837,
              0
            ],
            [
              848,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackNothing",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\n_cmsTRANSFORM* AllocEmptyTransform(cmsContext ContextID, cmsPipeline* lut,\n                                               cmsUInt32Number Intent, cmsUInt32Number* InputFormat, cmsUInt32Number* OutputFormat, cmsUInt32Number* dwFlags)\n{\n     _cmsTransformPluginChunkType* ctx = ( _cmsTransformPluginChunkType*) _cmsContextGetClientChunk(ContextID, TransformPlugin);\n     _cmsTransformCollection* Plugin;\n\n       // Allocate needed memory\n       _cmsTRANSFORM* p = (_cmsTRANSFORM*)_cmsMallocZero(ContextID, sizeof(_cmsTRANSFORM));\n       if (!p) {\n              cmsPipelineFree(lut);\n              return NULL;\n       }\n\n       // Store the proposed pipeline\n       p->Lut = lut;\n\n       // Let's see if any plug-in want to do the transform by itself\n       if (p->Lut != NULL) {\n\n           if (!(*dwFlags & cmsFLAGS_NOOPTIMIZE))\n           {\n               for (Plugin = ctx->TransformCollection;\n                   Plugin != NULL;\n                   Plugin = Plugin->Next) {\n\n                   if (Plugin->Factory(&p->xform, &p->UserData, &p->FreeUserData, &p->Lut, InputFormat, OutputFormat, dwFlags)) {\n\n                       // Last plugin in the declaration order takes control. We just keep\n                       // the original parameters as a logging. \n                       // Note that cmsFLAGS_CAN_CHANGE_FORMATTER is not set, so by default \n                       // an optimized transform is not reusable. The plug-in can, however, change\n                       // the flags and make it suitable.\n\n                       p->ContextID = ContextID;\n                       p->InputFormat = *InputFormat;\n                       p->OutputFormat = *OutputFormat;\n                       p->dwOriginalFlags = *dwFlags;\n\n                       // Fill the formatters just in case the optimized routine is interested.\n                       // No error is thrown if the formatter doesn't exist. It is up to the optimization \n                       // factory to decide what to do in those cases.\n                       p->FromInput = _cmsGetFormatter(ContextID, *InputFormat, cmsFormatterInput, CMS_PACK_FLAGS_16BITS).Fmt16;\n                       p->ToOutput = _cmsGetFormatter(ContextID, *OutputFormat, cmsFormatterOutput, CMS_PACK_FLAGS_16BITS).Fmt16;\n                       p->FromInputFloat = _cmsGetFormatter(ContextID, *InputFormat, cmsFormatterInput, CMS_PACK_FLAGS_FLOAT).FmtFloat;\n                       p->ToOutputFloat = _cmsGetFormatter(ContextID, *OutputFormat, cmsFormatterOutput, CMS_PACK_FLAGS_FLOAT).FmtFloat;\n\n                       // Save the day? (Ignore the warning)\n                       if (Plugin->OldXform) {\n                           p->OldXform = (_cmsTransformFn)(void*)p->xform;\n                           p->xform = _cmsTransform2toTransformAdaptor;\n                       }\n\n                       ParalellizeIfSuitable(p);\n                       return p;\n                   }\n               }\n           }\n\n           // Not suitable for the transform plug-in, let's check  the pipeline plug-in\n           _cmsOptimizePipeline(ContextID, &p->Lut, Intent, InputFormat, OutputFormat, dwFlags);\n       }\n\n    // Check whatever this is a true floating point transform\n    if (_cmsFormatterIsFloat(*InputFormat) || _cmsFormatterIsFloat(*OutputFormat)) {\n\n        // Get formatter function always return a valid union, but the contents of this union may be NULL.\n        p ->FromInputFloat = _cmsGetFormatter(ContextID, *InputFormat,  cmsFormatterInput, CMS_PACK_FLAGS_FLOAT).FmtFloat;\n        p ->ToOutputFloat  = _cmsGetFormatter(ContextID, *OutputFormat, cmsFormatterOutput, CMS_PACK_FLAGS_FLOAT).FmtFloat;\n        *dwFlags |= cmsFLAGS_CAN_CHANGE_FORMATTER;\n\n        if (p ->FromInputFloat == NULL || p ->ToOutputFloat == NULL) {\n\n            cmsSignalError(ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported raster format\");\n            cmsDeleteTransform(p);\n            return NULL;\n        }\n\n        if (*dwFlags & cmsFLAGS_NULLTRANSFORM) {\n\n            p ->xform = NullFloatXFORM;\n        }\n        else {\n            // Float transforms don't use cache, always are non-NULL\n            p ->xform = FloatXFORM;\n        }\n\n    }\n    else {\n\n        // Formats are intended to be changed before use\n        if (*InputFormat == 0 && *OutputFormat == 0) {\n            p->FromInput = UnrollNothing;\n            p->ToOutput = PackNothing;\n            *dwFlags |= cmsFLAGS_CAN_CHANGE_FORMATTER;\n        }\n        else {\n\n            cmsUInt32Number BytesPerPixelInput;\n\n            p ->FromInput = _cmsGetFormatter(ContextID, *InputFormat,  cmsFormatterInput, CMS_PACK_FLAGS_16BITS).Fmt16;\n            p ->ToOutput  = _cmsGetFormatter(ContextID, *OutputFormat, cmsFormatterOutput, CMS_PACK_FLAGS_16BITS).Fmt16;\n\n            if (p ->FromInput == NULL || p ->ToOutput == NULL) {\n\n                cmsSignalError(ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported raster format\");\n                cmsDeleteTransform(p);\n                return NULL;\n            }\n\n            BytesPerPixelInput = T_BYTES(*InputFormat);\n            if (BytesPerPixelInput == 0 || BytesPerPixelInput >= 2)\n                   *dwFlags |= cmsFLAGS_CAN_CHANGE_FORMATTER;\n\n        }\n\n        if (*dwFlags & cmsFLAGS_NULLTRANSFORM) {\n\n            p ->xform = NullXFORM;\n        }\n        else {\n            if (*dwFlags & cmsFLAGS_NOCACHE) {\n\n                if (*dwFlags & cmsFLAGS_GAMUTCHECK)\n                    p ->xform = PrecalculatedXFORMGamutCheck;  // Gamut check, no cache\n                else\n                    p ->xform = PrecalculatedXFORM;  // No cache, no gamut check\n            }\n            else {\n\n                if (*dwFlags & cmsFLAGS_GAMUTCHECK)\n                    p ->xform = CachedXFORMGamutCheck;    // Gamut check, cache\n                else\n                    p ->xform = CachedXFORM;  // No gamut check, cache\n\n            }\n        }\n    }\n\n    /**\n    * Check consistency for alpha channel copy\n    */\n    if (*dwFlags & cmsFLAGS_COPY_ALPHA)\n    {\n        if (T_EXTRA(*InputFormat) != T_EXTRA(*OutputFormat))\n        {\n            cmsSignalError(ContextID, cmsERROR_NOT_SUITABLE, \"Mismatched alpha channels\");\n            cmsDeleteTransform(p);\n            return NULL;\n        }\n    }\n\n    p ->InputFormat     = *InputFormat;\n    p ->OutputFormat    = *OutputFormat;\n    p ->dwOriginalFlags = *dwFlags;\n    p ->ContextID       = ContextID;\n    p ->UserData        = NULL;\n    ParalellizeIfSuitable(p);\n    return p;\n}",
          "fn_code_pos": [
            [
              852,
              0
            ],
            [
              1011,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllocEmptyTransform",
            "parameters": {
              "ContextID": "cmsContext",
              "lut": "cmsPipeline",
              "Intent": "cmsUInt32Number",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "_cmsTRANSFORM"
          }
        },
        {
          "fn_code": "static\ncmsBool GetXFormColorSpaces(cmsUInt32Number nProfiles, cmsHPROFILE hProfiles[], cmsColorSpaceSignature* Input, cmsColorSpaceSignature* Output)\n{\n    cmsColorSpaceSignature ColorSpaceIn, ColorSpaceOut;\n    cmsColorSpaceSignature PostColorSpace;\n    cmsUInt32Number i;\n\n    if (nProfiles == 0) return FALSE;\n    if (hProfiles[0] == NULL) return FALSE;\n\n    *Input = PostColorSpace = cmsGetColorSpace(hProfiles[0]);\n\n    for (i=0; i < nProfiles; i++) {\n\n        cmsProfileClassSignature cls;\n        cmsHPROFILE hProfile = hProfiles[i];\n\n        int lIsInput = (PostColorSpace != cmsSigXYZData) &&\n                       (PostColorSpace != cmsSigLabData);\n\n        if (hProfile == NULL) return FALSE;\n\n        cls = cmsGetDeviceClass(hProfile);\n\n        if (cls == cmsSigNamedColorClass) {\n\n            ColorSpaceIn    = cmsSig1colorData;\n            ColorSpaceOut   = (nProfiles > 1) ? cmsGetPCS(hProfile) : cmsGetColorSpace(hProfile);\n        }\n        else\n        if (lIsInput || (cls == cmsSigLinkClass)) {\n\n            ColorSpaceIn    = cmsGetColorSpace(hProfile);\n            ColorSpaceOut   = cmsGetPCS(hProfile);\n        }\n        else\n        {\n            ColorSpaceIn    = cmsGetPCS(hProfile);\n            ColorSpaceOut   = cmsGetColorSpace(hProfile);\n        }\n\n        if (i==0)\n            *Input = ColorSpaceIn;\n\n        PostColorSpace = ColorSpaceOut;\n    }\n\n    *Output = PostColorSpace;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1013,
              0
            ],
            [
              1063,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetXFormColorSpaces",
            "parameters": {
              "nProfiles": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "Input": "cmsColorSpaceSignature",
              "Output": "cmsColorSpaceSignature"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool  IsProperColorSpace(cmsColorSpaceSignature Check, cmsUInt32Number dwFormat)\n{\n    int Space1 = (int) T_COLORSPACE(dwFormat);\n    int Space2 = _cmsLCMScolorSpace(Check);\n\n    if (Space1 == PT_ANY) return (T_CHANNELS(dwFormat) == cmsChannelsOf(Check));\n    if (Space1 == Space2) return TRUE;\n\n    if (Space1 == PT_LabV2 && Space2 == PT_Lab) return TRUE;\n    if (Space1 == PT_Lab   && Space2 == PT_LabV2) return TRUE;\n\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              1066,
              0
            ],
            [
              1079,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsProperColorSpace",
            "parameters": {
              "Check": "cmsColorSpaceSignature",
              "dwFormat": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid NormalizeXYZ(cmsCIEXYZ* Dest)\n{\n    while (Dest -> X > 2. &&\n           Dest -> Y > 2. &&\n           Dest -> Z > 2.) {\n\n               Dest -> X /= 10.;\n               Dest -> Y /= 10.;\n               Dest -> Z /= 10.;\n       }\n}",
          "fn_code_pos": [
            [
              1086,
              0
            ],
            [
              1097,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NormalizeXYZ",
            "parameters": {
              "Dest": "cmsCIEXYZ"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid SetWhitePoint(cmsCIEXYZ* wtPt, const cmsCIEXYZ* src)\n{\n    if (src == NULL) {\n        wtPt ->X = cmsD50X;\n        wtPt ->Y = cmsD50Y;\n        wtPt ->Z = cmsD50Z;\n    }\n    else {\n        wtPt ->X = src->X;\n        wtPt ->Y = src->Y;\n        wtPt ->Z = src->Z;\n\n        NormalizeXYZ(wtPt);\n    }\n\n}",
          "fn_code_pos": [
            [
              1099,
              0
            ],
            [
              1115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetWhitePoint",
            "parameters": {
              "wtPt": "cmsCIEXYZ",
              "src": "cmsCIEXYZ"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsHTRANSFORM CMSEXPORT cmsCreateExtendedTransform(cmsContext ContextID,\n                                                   cmsUInt32Number nProfiles, cmsHPROFILE hProfiles[],\n                                                   cmsBool  BPC[],\n                                                   cmsUInt32Number Intents[],\n                                                   cmsFloat64Number AdaptationStates[],\n                                                   cmsHPROFILE hGamutProfile,\n                                                   cmsUInt32Number nGamutPCSposition,\n                                                   cmsUInt32Number InputFormat,\n                                                   cmsUInt32Number OutputFormat,\n                                                   cmsUInt32Number dwFlags)\n{\n    _cmsTRANSFORM* xform;    \n    cmsColorSpaceSignature EntryColorSpace;\n    cmsColorSpaceSignature ExitColorSpace;\n    cmsPipeline* Lut;\n    cmsUInt32Number LastIntent;\n\n    // Safeguard\n    if (nProfiles <= 0 || nProfiles > 255) {\n        cmsSignalError(ContextID, cmsERROR_RANGE, \"Wrong number of profiles. 1..255 expected, %d found.\", nProfiles);\n        return NULL;\n    }\n\n    LastIntent = Intents[nProfiles - 1];\n\n    // If it is a fake transform\n    if (dwFlags & cmsFLAGS_NULLTRANSFORM)\n    {\n        return AllocEmptyTransform(ContextID, NULL, INTENT_PERCEPTUAL, &InputFormat, &OutputFormat, &dwFlags);\n    }\n\n    // If gamut check is requested, make sure we have a gamut profile\n    if (dwFlags & cmsFLAGS_GAMUTCHECK) {\n        if (hGamutProfile == NULL) dwFlags &= ~cmsFLAGS_GAMUTCHECK;\n    }\n\n    // On floating point transforms, inhibit cache\n    if (_cmsFormatterIsFloat(InputFormat) || _cmsFormatterIsFloat(OutputFormat))\n        dwFlags |= cmsFLAGS_NOCACHE;\n\n    // Mark entry/exit spaces\n    if (!GetXFormColorSpaces(nProfiles, hProfiles, &EntryColorSpace, &ExitColorSpace)) {\n        cmsSignalError(ContextID, cmsERROR_NULL, \"NULL input profiles on transform\");\n        return NULL;\n    }\n\n    // Check if proper colorspaces\n    if (!IsProperColorSpace(EntryColorSpace, InputFormat)) {\n        cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, \"Wrong input color space on transform\");\n        return NULL;\n    }\n\n    if (!IsProperColorSpace(ExitColorSpace, OutputFormat)) {\n        cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, \"Wrong output color space on transform\");\n        return NULL;\n    }\n\n    // Check whatever the transform is 16 bits and involves linear RGB in first profile. If so, disable optimizations\n    if (EntryColorSpace == cmsSigRgbData && T_BYTES(InputFormat) == 2 && !(dwFlags & cmsFLAGS_NOOPTIMIZE))\n    {\n        cmsFloat64Number gamma = cmsDetectRGBProfileGamma(hProfiles[0], 0.1);\n\n        if (gamma > 0 && gamma < 1.6)\n            dwFlags |= cmsFLAGS_NOOPTIMIZE;\n    }\n\n    // Create a pipeline with all transformations\n    Lut = _cmsLinkProfiles(ContextID, nProfiles, Intents, hProfiles, BPC, AdaptationStates, dwFlags);\n    if (Lut == NULL) {\n        cmsSignalError(ContextID, cmsERROR_NOT_SUITABLE, \"Couldn't link the profiles\");\n        return NULL;\n    }\n\n    // Check channel count\n    if ((cmsChannelsOfColorSpace(EntryColorSpace) != (cmsInt32Number) cmsPipelineInputChannels(Lut)) ||\n        (cmsChannelsOfColorSpace(ExitColorSpace)  != (cmsInt32Number) cmsPipelineOutputChannels(Lut))) {\n        cmsPipelineFree(Lut);\n        cmsSignalError(ContextID, cmsERROR_NOT_SUITABLE, \"Channel count doesn't match. Profile is corrupted\");\n        return NULL;\n    }\n\n\n    // All seems ok\n    xform = AllocEmptyTransform(ContextID, Lut, LastIntent, &InputFormat, &OutputFormat, &dwFlags);\n    if (xform == NULL) {\n        return NULL;\n    }\n\n    // Keep values\n    xform ->EntryColorSpace = EntryColorSpace;\n    xform ->ExitColorSpace  = ExitColorSpace;\n    xform ->RenderingIntent = Intents[nProfiles-1];\n\n    // Take white points\n    SetWhitePoint(&xform->EntryWhitePoint, (cmsCIEXYZ*) cmsReadTag(hProfiles[0], cmsSigMediaWhitePointTag));\n    SetWhitePoint(&xform->ExitWhitePoint,  (cmsCIEXYZ*) cmsReadTag(hProfiles[nProfiles-1], cmsSigMediaWhitePointTag));\n   \n\n    // Create a gamut check LUT if requested\n    if (hGamutProfile != NULL && (dwFlags & cmsFLAGS_GAMUTCHECK))\n        xform ->GamutCheck  = _cmsCreateGamutCheckPipeline(ContextID, hProfiles,\n                                                        BPC, Intents,\n                                                        AdaptationStates,\n                                                        nGamutPCSposition,\n                                                        hGamutProfile);\n\n\n    // Try to read input and output colorant table\n    if (cmsIsTag(hProfiles[0], cmsSigColorantTableTag)) {\n\n        // Input table can only come in this way.\n        xform ->InputColorant = cmsDupNamedColorList((cmsNAMEDCOLORLIST*) cmsReadTag(hProfiles[0], cmsSigColorantTableTag));\n    }\n\n    // Output is a little bit more complex.\n    if (cmsGetDeviceClass(hProfiles[nProfiles-1]) == cmsSigLinkClass) {\n\n        // This tag may exist only on devicelink profiles.\n        if (cmsIsTag(hProfiles[nProfiles-1], cmsSigColorantTableOutTag)) {\n\n            // It may be NULL if error\n            xform ->OutputColorant = cmsDupNamedColorList((cmsNAMEDCOLORLIST*) cmsReadTag(hProfiles[nProfiles-1], cmsSigColorantTableOutTag));\n        }\n\n    } else {\n\n        if (cmsIsTag(hProfiles[nProfiles-1], cmsSigColorantTableTag)) {\n\n            xform -> OutputColorant = cmsDupNamedColorList((cmsNAMEDCOLORLIST*) cmsReadTag(hProfiles[nProfiles-1], cmsSigColorantTableTag));\n        }\n    }\n\n    // Store the sequence of profiles\n    if (dwFlags & cmsFLAGS_KEEP_SEQUENCE) {\n        xform ->Sequence = _cmsCompileProfileSequence(ContextID, nProfiles, hProfiles);\n    }\n    else\n        xform ->Sequence = NULL;\n\n    // If this is a cached transform, init first value, which is zero (16 bits only)\n    if (!(dwFlags & cmsFLAGS_NOCACHE)) {\n\n        memset(&xform ->Cache.CacheIn, 0, sizeof(xform ->Cache.CacheIn));\n\n        if (xform ->GamutCheck != NULL) {\n            TransformOnePixelWithGamutCheck(xform, xform ->Cache.CacheIn, xform->Cache.CacheOut);\n        }\n        else {\n\n            xform ->Lut ->Eval16Fn(xform ->Cache.CacheIn, xform->Cache.CacheOut, xform -> Lut->Data);\n        }\n\n    }\n\n    return (cmsHTRANSFORM) xform;\n}",
          "fn_code_pos": [
            [
              1118,
              0
            ],
            [
              1273,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateExtendedTransform",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "Intents": "cmsUInt32Number",
              "AdaptationStates": "cmsFloat64Number",
              "hGamutProfile": "cmsHPROFILE",
              "nGamutPCSposition": "cmsUInt32Number",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsHTRANSFORM"
          }
        },
        {
          "fn_code": "cmsHTRANSFORM CMSEXPORT cmsCreateMultiprofileTransformTHR(cmsContext ContextID,\n                                                       cmsHPROFILE hProfiles[],\n                                                       cmsUInt32Number nProfiles,\n                                                       cmsUInt32Number InputFormat,\n                                                       cmsUInt32Number OutputFormat,\n                                                       cmsUInt32Number Intent,\n                                                       cmsUInt32Number dwFlags)\n{\n    cmsUInt32Number i;\n    cmsBool BPC[256];\n    cmsUInt32Number Intents[256];\n    cmsFloat64Number AdaptationStates[256];\n\n    if (nProfiles <= 0 || nProfiles > 255) {\n         cmsSignalError(ContextID, cmsERROR_RANGE, \"Wrong number of profiles. 1..255 expected, %d found.\", nProfiles);\n        return NULL;\n    }\n\n    for (i=0; i < nProfiles; i++) {\n        BPC[i] = dwFlags & cmsFLAGS_BLACKPOINTCOMPENSATION ? TRUE : FALSE;\n        Intents[i] = Intent;\n        AdaptationStates[i] = cmsSetAdaptationStateTHR(ContextID, -1);\n    }\n\n\n    return cmsCreateExtendedTransform(ContextID, nProfiles, hProfiles, BPC, Intents, AdaptationStates, NULL, 0, InputFormat, OutputFormat, dwFlags);\n}",
          "fn_code_pos": [
            [
              1276,
              0
            ],
            [
              1302,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateMultiprofileTransformTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "hProfiles": "cmsHPROFILE",
              "nProfiles": "cmsUInt32Number",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsHTRANSFORM"
          }
        },
        {
          "fn_code": "cmsHTRANSFORM CMSEXPORT cmsCreateMultiprofileTransform(cmsHPROFILE hProfiles[],\n                                                  cmsUInt32Number nProfiles,\n                                                  cmsUInt32Number InputFormat,\n                                                  cmsUInt32Number OutputFormat,\n                                                  cmsUInt32Number Intent,\n                                                  cmsUInt32Number dwFlags)\n{\n\n    if (nProfiles <= 0 || nProfiles > 255) {\n         cmsSignalError(NULL, cmsERROR_RANGE, \"Wrong number of profiles. 1..255 expected, %d found.\", nProfiles);\n         return NULL;\n    }\n\n    return cmsCreateMultiprofileTransformTHR(cmsGetProfileContextID(hProfiles[0]),\n                                                  hProfiles,\n                                                  nProfiles,\n                                                  InputFormat,\n                                                  OutputFormat,\n                                                  Intent,\n                                                  dwFlags);\n}",
          "fn_code_pos": [
            [
              1306,
              0
            ],
            [
              1326,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateMultiprofileTransform",
            "parameters": {
              "hProfiles": "cmsHPROFILE",
              "nProfiles": "cmsUInt32Number",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsHTRANSFORM"
          }
        },
        {
          "fn_code": "cmsHTRANSFORM CMSEXPORT cmsCreateTransformTHR(cmsContext ContextID,\n                                              cmsHPROFILE Input,\n                                              cmsUInt32Number InputFormat,\n                                              cmsHPROFILE Output,\n                                              cmsUInt32Number OutputFormat,\n                                              cmsUInt32Number Intent,\n                                              cmsUInt32Number dwFlags)\n{\n\n    cmsHPROFILE hArray[2];\n\n    hArray[0] = Input;\n    hArray[1] = Output;\n\n    return cmsCreateMultiprofileTransformTHR(ContextID, hArray, Output == NULL ? 1U : 2U, InputFormat, OutputFormat, Intent, dwFlags);\n}",
          "fn_code_pos": [
            [
              1328,
              0
            ],
            [
              1343,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateTransformTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "Input": "cmsHPROFILE",
              "InputFormat": "cmsUInt32Number",
              "Output": "cmsHPROFILE",
              "OutputFormat": "cmsUInt32Number",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsHTRANSFORM"
          }
        },
        {
          "fn_code": "CMSAPI cmsHTRANSFORM CMSEXPORT cmsCreateTransform(cmsHPROFILE Input,\n                                                  cmsUInt32Number InputFormat,\n                                                  cmsHPROFILE Output,\n                                                  cmsUInt32Number OutputFormat,\n                                                  cmsUInt32Number Intent,\n                                                  cmsUInt32Number dwFlags)\n{\n    return cmsCreateTransformTHR(cmsGetProfileContextID(Input), Input, InputFormat, Output, OutputFormat, Intent, dwFlags);\n}",
          "fn_code_pos": [
            [
              1345,
              0
            ],
            [
              1353,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateTransform",
            "parameters": {
              "Input": "cmsHPROFILE",
              "InputFormat": "cmsUInt32Number",
              "Output": "cmsHPROFILE",
              "OutputFormat": "cmsUInt32Number",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsHTRANSFORM CMSEXPORT cmsCreateProofingTransformTHR(cmsContext ContextID,\n                                                   cmsHPROFILE InputProfile,\n                                                   cmsUInt32Number InputFormat,\n                                                   cmsHPROFILE OutputProfile,\n                                                   cmsUInt32Number OutputFormat,\n                                                   cmsHPROFILE ProofingProfile,\n                                                   cmsUInt32Number nIntent,\n                                                   cmsUInt32Number ProofingIntent,\n                                                   cmsUInt32Number dwFlags)\n{\n    cmsHPROFILE hArray[4];\n    cmsUInt32Number Intents[4];\n    cmsBool  BPC[4];\n    cmsFloat64Number Adaptation[4];\n    cmsBool  DoBPC = (dwFlags & cmsFLAGS_BLACKPOINTCOMPENSATION) ? TRUE : FALSE;\n\n\n    hArray[0]  = InputProfile; hArray[1] = ProofingProfile; hArray[2]  = ProofingProfile;               hArray[3] = OutputProfile;\n    Intents[0] = nIntent;      Intents[1] = nIntent;        Intents[2] = INTENT_RELATIVE_COLORIMETRIC;  Intents[3] = ProofingIntent;\n    BPC[0]     = DoBPC;        BPC[1] = DoBPC;              BPC[2] = 0;                                 BPC[3] = 0;\n\n    Adaptation[0] = Adaptation[1] = Adaptation[2] = Adaptation[3] = cmsSetAdaptationStateTHR(ContextID, -1);\n\n    if (!(dwFlags & (cmsFLAGS_SOFTPROOFING|cmsFLAGS_GAMUTCHECK)))\n        return cmsCreateTransformTHR(ContextID, InputProfile, InputFormat, OutputProfile, OutputFormat, nIntent, dwFlags);\n\n    return cmsCreateExtendedTransform(ContextID, 4, hArray, BPC, Intents, Adaptation,\n                                        ProofingProfile, 1, InputFormat, OutputFormat, dwFlags);\n\n}",
          "fn_code_pos": [
            [
              1356,
              0
            ],
            [
              1385,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateProofingTransformTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "InputProfile": "cmsHPROFILE",
              "InputFormat": "cmsUInt32Number",
              "OutputProfile": "cmsHPROFILE",
              "OutputFormat": "cmsUInt32Number",
              "ProofingProfile": "cmsHPROFILE",
              "nIntent": "cmsUInt32Number",
              "ProofingIntent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsHTRANSFORM"
          }
        },
        {
          "fn_code": "cmsHTRANSFORM CMSEXPORT cmsCreateProofingTransform(cmsHPROFILE InputProfile,\n                                                   cmsUInt32Number InputFormat,\n                                                   cmsHPROFILE OutputProfile,\n                                                   cmsUInt32Number OutputFormat,\n                                                   cmsHPROFILE ProofingProfile,\n                                                   cmsUInt32Number nIntent,\n                                                   cmsUInt32Number ProofingIntent,\n                                                   cmsUInt32Number dwFlags)\n{\n    return cmsCreateProofingTransformTHR(cmsGetProfileContextID(InputProfile),\n                                                   InputProfile,\n                                                   InputFormat,\n                                                   OutputProfile,\n                                                   OutputFormat,\n                                                   ProofingProfile,\n                                                   nIntent,\n                                                   ProofingIntent,\n                                                   dwFlags);\n}",
          "fn_code_pos": [
            [
              1388,
              0
            ],
            [
              1406,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateProofingTransform",
            "parameters": {
              "InputProfile": "cmsHPROFILE",
              "InputFormat": "cmsUInt32Number",
              "OutputProfile": "cmsHPROFILE",
              "OutputFormat": "cmsUInt32Number",
              "ProofingProfile": "cmsHPROFILE",
              "nIntent": "cmsUInt32Number",
              "ProofingIntent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsHTRANSFORM"
          }
        },
        {
          "fn_code": "cmsContext CMSEXPORT cmsGetTransformContextID(cmsHTRANSFORM hTransform)\n{\n    _cmsTRANSFORM* xform = (_cmsTRANSFORM*) hTransform;\n\n    if (xform == NULL) return NULL;\n    return xform -> ContextID;\n}",
          "fn_code_pos": [
            [
              1410,
              0
            ],
            [
              1416,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetTransformContextID",
            "parameters": {
              "hTransform": "cmsHTRANSFORM"
            },
            "return_type": "cmsContext"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsGetTransformInputFormat(cmsHTRANSFORM hTransform)\n{\n    _cmsTRANSFORM* xform = (_cmsTRANSFORM*) hTransform;\n\n    if (xform == NULL) return 0;\n    return xform->InputFormat;\n}",
          "fn_code_pos": [
            [
              1419,
              0
            ],
            [
              1425,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetTransformInputFormat",
            "parameters": {
              "hTransform": "cmsHTRANSFORM"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsGetTransformOutputFormat(cmsHTRANSFORM hTransform)\n{\n    _cmsTRANSFORM* xform = (_cmsTRANSFORM*) hTransform;\n\n    if (xform == NULL) return 0;\n    return xform->OutputFormat;\n}",
          "fn_code_pos": [
            [
              1427,
              0
            ],
            [
              1433,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetTransformOutputFormat",
            "parameters": {
              "hTransform": "cmsHTRANSFORM"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsChangeBuffersFormat(cmsHTRANSFORM hTransform,\n                                         cmsUInt32Number InputFormat,\n                                         cmsUInt32Number OutputFormat)\n{\n    _cmsTRANSFORM* xform = (_cmsTRANSFORM*) hTransform;\n    cmsFormatter16 FromInput, ToOutput;\n\n\n    // We only can afford to change formatters if previous transform is at least 16 bits\n    if (!(xform ->dwOriginalFlags & cmsFLAGS_CAN_CHANGE_FORMATTER)) {\n\n        cmsSignalError(xform ->ContextID, cmsERROR_NOT_SUITABLE, \"cmsChangeBuffersFormat works only on transforms created originally with at least 16 bits of precision\");\n        return FALSE;\n    }\n\n    FromInput = _cmsGetFormatter(xform->ContextID, InputFormat,  cmsFormatterInput, CMS_PACK_FLAGS_16BITS).Fmt16;\n    ToOutput  = _cmsGetFormatter(xform->ContextID, OutputFormat, cmsFormatterOutput, CMS_PACK_FLAGS_16BITS).Fmt16;\n\n    if (FromInput == NULL || ToOutput == NULL) {\n\n        cmsSignalError(xform -> ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported raster format\");\n        return FALSE;\n    }\n\n    xform ->InputFormat  = InputFormat;\n    xform ->OutputFormat = OutputFormat;\n    xform ->FromInput    = FromInput;\n    xform ->ToOutput     = ToOutput;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1436,
              0
            ],
            [
              1465,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsChangeBuffersFormat",
            "parameters": {
              "hTransform": "cmsHTRANSFORM",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "_cmsGetTransformUserData(struct _cmstransform_struct *CMMcargo)",
          "fn_dec_pos": [
            [
              755,
              17
            ],
            [
              755,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTransformUserData",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollNothing(CMSREGISTER _cmsTRANSFORM* info,\n                              CMSREGISTER cmsUInt16Number wIn[],\n                              CMSREGISTER cmsUInt8Number* accum,\n                              CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              825,
              16
            ],
            [
              828,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollNothing",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackNothing(CMSREGISTER _cmsTRANSFORM* info,\n                           CMSREGISTER cmsUInt16Number wOut[],\n                           CMSREGISTER cmsUInt8Number* output,\n                           CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              838,
              16
            ],
            [
              841,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackNothing",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "AllocEmptyTransform(cmsContext ContextID, cmsPipeline* lut,\n                                               cmsUInt32Number Intent, cmsUInt32Number* InputFormat, cmsUInt32Number* OutputFormat, cmsUInt32Number* dwFlags)",
          "fn_dec_pos": [
            [
              853,
              15
            ],
            [
              854,
              157
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllocEmptyTransform",
            "parameters": {
              "ContextID": "cmsContext",
              "lut": "cmsPipeline",
              "Intent": "cmsUInt32Number",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct _cmsTransformCollection_st {\n\n    _cmsTransform2Factory  Factory;\n    cmsBool                OldXform;   // Factory returns xform function in the old style\n\n    struct _cmsTransformCollection_st *Next;\n\n} _cmsTransformCollection;",
          {
            "Factory": "_cmsTransform2Factory",
            "OldXform": "cmsBool",
            "*Next": "struct _cmsTransformCollection_st"
          },
          "_cmsTransformCollection",
          [
            613,
            0
          ],
          [
            620,
            26
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            37,
            35
          ],
          [
            37,
            60
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            38,
            41
          ],
          [
            38,
            66
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            127,
            30
          ],
          [
            127,
            55
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            128,
            36
          ],
          [
            128,
            61
          ]
        ],
        [
          "typedef struct _cmsTransformCollection_st {\n\n    _cmsTransform2Factory  Factory;\n    cmsBool                OldXform;   // Factory returns xform function in the old style\n\n    struct _cmsTransformCollection_st *Next;\n\n} _cmsTransformCollection;",
          {
            "Factory": "_cmsTransform2Factory",
            "OldXform": "cmsBool",
            "*Next": "struct _cmsTransformCollection_st"
          },
          "_cmsTransformCollection",
          [
            613,
            0
          ],
          [
            620,
            26
          ]
        ],
        [
          "struct _cmsTransformCollection_st",
          {},
          "",
          [
            618,
            4
          ],
          [
            618,
            37
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            628,
            28
          ],
          [
            628,
            53
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            629,
            53
          ],
          [
            629,
            78
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            661,
            35
          ],
          [
            661,
            60
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            662,
            46
          ],
          [
            662,
            71
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            677,
            38
          ],
          [
            677,
            65
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            747,
            40
          ],
          [
            747,
            67
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            755,
            42
          ],
          [
            755,
            69
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            762,
            44
          ],
          [
            762,
            71
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            769,
            47
          ],
          [
            769,
            74
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            777,
            48
          ],
          [
            777,
            75
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            784,
            50
          ],
          [
            784,
            77
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            791,
            52
          ],
          [
            791,
            79
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            798,
            54
          ],
          [
            798,
            81
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmsps2.c": {
      "fn_def_list": [
        {
          "fn_code": "static\ncmsUInt8Number Word2Byte(cmsUInt16Number w)\n{\n    return (cmsUInt8Number) floor((cmsFloat64Number) w / 257.0 + 0.5);\n}",
          "fn_code_pos": [
            [
              290,
              0
            ],
            [
              294,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Word2Byte",
            "parameters": {
              "w": "cmsUInt16Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\nvoid WriteByte(cmsIOHANDLER* m, cmsUInt8Number b)\n{\n    _cmsIOPrintf(m, \"%02x\", b);\n    _cmsPSActualColumn += 2;\n\n    if (_cmsPSActualColumn > MAXPSCOLS) {\n\n        _cmsIOPrintf(m, \"\\n\");\n        _cmsPSActualColumn = 0;\n    }\n}",
          "fn_code_pos": [
            [
              298,
              0
            ],
            [
              309,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteByte",
            "parameters": {
              "m": "cmsIOHANDLER",
              "b": "cmsUInt8Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nchar* RemoveCR(const char* txt)\n{\n    static char Buffer[2048];\n    char* pt;\n\n    strncpy(Buffer, txt, 2047);\n    Buffer[2047] = 0;\n    for (pt = Buffer; *pt; pt++)\n            if (*pt == '\\n' || *pt == '\\r') *pt = ' ';\n\n    return Buffer;\n\n}",
          "fn_code_pos": [
            [
              316,
              0
            ],
            [
              329,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RemoveCR",
            "parameters": {
              "txt": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static\nvoid EmitHeader(cmsIOHANDLER* m, const char* Title, cmsHPROFILE hProfile)\n{\n    time_t timer;\n    cmsMLU *Description, *Copyright;\n    char DescASCII[256], CopyrightASCII[256];\n\n    time(&timer);\n\n    Description = (cmsMLU*) cmsReadTag(hProfile, cmsSigProfileDescriptionTag);\n    Copyright   = (cmsMLU*) cmsReadTag(hProfile, cmsSigCopyrightTag);\n\n    DescASCII[0] = DescASCII[255] = 0;\n    CopyrightASCII[0] = CopyrightASCII[255] = 0;\n\n    if (Description != NULL) cmsMLUgetASCII(Description,  cmsNoLanguage, cmsNoCountry, DescASCII,       255);\n    if (Copyright != NULL)   cmsMLUgetASCII(Copyright,    cmsNoLanguage, cmsNoCountry, CopyrightASCII,  255);\n\n    _cmsIOPrintf(m, \"%%!PS-Adobe-3.0\\n\");\n    _cmsIOPrintf(m, \"%%\\n\");\n    _cmsIOPrintf(m, \"%% %s\\n\", Title);\n    _cmsIOPrintf(m, \"%% Source: %s\\n\", RemoveCR(DescASCII));\n    _cmsIOPrintf(m, \"%%         %s\\n\", RemoveCR(CopyrightASCII));\n    _cmsIOPrintf(m, \"%% Created: %s\", ctime(&timer)); // ctime appends a \\n!!!\n    _cmsIOPrintf(m, \"%%\\n\");\n    _cmsIOPrintf(m, \"%%%%BeginResource\\n\");\n\n}",
          "fn_code_pos": [
            [
              331,
              0
            ],
            [
              358,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EmitHeader",
            "parameters": {
              "m": "cmsIOHANDLER",
              "Title": "char",
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid EmitWhiteBlackD50(cmsIOHANDLER* m, cmsCIEXYZ* BlackPoint)\n{\n\n    _cmsIOPrintf(m, \"/BlackPoint [%f %f %f]\\n\", BlackPoint -> X,\n                                          BlackPoint -> Y,\n                                          BlackPoint -> Z);\n\n    _cmsIOPrintf(m, \"/WhitePoint [%f %f %f]\\n\", cmsD50_XYZ()->X,\n                                          cmsD50_XYZ()->Y,\n                                          cmsD50_XYZ()->Z);\n}",
          "fn_code_pos": [
            [
              364,
              0
            ],
            [
              375,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EmitWhiteBlackD50",
            "parameters": {
              "m": "cmsIOHANDLER",
              "BlackPoint": "cmsCIEXYZ"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid EmitRangeCheck(cmsIOHANDLER* m)\n{\n    _cmsIOPrintf(m, \"dup 0.0 lt { pop 0.0 } if \"\n                    \"dup 1.0 gt { pop 1.0 } if \");\n\n}",
          "fn_code_pos": [
            [
              378,
              0
            ],
            [
              384,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EmitRangeCheck",
            "parameters": {
              "m": "cmsIOHANDLER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid EmitIntent(cmsIOHANDLER* m, cmsUInt32Number RenderingIntent)\n{\n    const char *intent;\n\n    switch (RenderingIntent) {\n\n        case INTENT_PERCEPTUAL:            intent = \"Perceptual\"; break;\n        case INTENT_RELATIVE_COLORIMETRIC: intent = \"RelativeColorimetric\"; break;\n        case INTENT_ABSOLUTE_COLORIMETRIC: intent = \"AbsoluteColorimetric\"; break;\n        case INTENT_SATURATION:            intent = \"Saturation\"; break;\n\n        default: intent = \"Undefined\"; break;\n    }\n\n    _cmsIOPrintf(m, \"/RenderingIntent (%s)\\n\", intent );\n}",
          "fn_code_pos": [
            [
              388,
              0
            ],
            [
              404,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EmitIntent",
            "parameters": {
              "m": "cmsIOHANDLER",
              "RenderingIntent": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid EmitLab2XYZ(cmsIOHANDLER* m)\n{\n    _cmsIOPrintf(m, \"/RangeABC [ 0 1 0 1 0 1]\\n\");\n    _cmsIOPrintf(m, \"/DecodeABC [\\n\");\n    _cmsIOPrintf(m, \"{100 mul  16 add 116 div } bind\\n\");\n    _cmsIOPrintf(m, \"{255 mul 128 sub 500 div } bind\\n\");\n    _cmsIOPrintf(m, \"{255 mul 128 sub 200 div } bind\\n\");\n    _cmsIOPrintf(m, \"]\\n\");\n    _cmsIOPrintf(m, \"/MatrixABC [ 1 1 1 1 0 0 0 0 -1]\\n\");\n    _cmsIOPrintf(m, \"/RangeLMN [ -0.236 1.254 0 1 -0.635 1.640 ]\\n\");\n    _cmsIOPrintf(m, \"/DecodeLMN [\\n\");\n    _cmsIOPrintf(m, \"{dup 6 29 div ge {dup dup mul mul} {4 29 div sub 108 841 div mul} ifelse 0.964200 mul} bind\\n\");\n    _cmsIOPrintf(m, \"{dup 6 29 div ge {dup dup mul mul} {4 29 div sub 108 841 div mul} ifelse } bind\\n\");\n    _cmsIOPrintf(m, \"{dup 6 29 div ge {dup dup mul mul} {4 29 div sub 108 841 div mul} ifelse 0.824900 mul} bind\\n\");\n    _cmsIOPrintf(m, \"]\\n\");\n}",
          "fn_code_pos": [
            [
              415,
              0
            ],
            [
              431,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EmitLab2XYZ",
            "parameters": {
              "m": "cmsIOHANDLER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Emit1Gamma(cmsIOHANDLER* m, cmsToneCurve* Table)\n{\n    cmsUInt32Number i;\n    cmsFloat64Number gamma;\n\n    /**\n    * On error, empty tables or lienar assume gamma 1.0\n    */\n    if (Table == NULL ||\n        Table->nEntries <= 0 ||\n        cmsIsToneCurveLinear(Table)) {\n\n        _cmsIOPrintf(m, \"{ 1 } bind \");\n        return;\n    }\n\n\n    // Check if is really an exponential. If so, emit \"exp\"\n    gamma = cmsEstimateGamma(Table, 0.001);\n     if (gamma > 0) {\n            _cmsIOPrintf(m, \"{ %g exp } bind \", gamma);\n            return;\n     }\n\n    _cmsIOPrintf(m, \"{ \");\n\n    // Bounds check\n    EmitRangeCheck(m);\n\n    // Emit interpolation code\n\n    // PostScript code                      Stack\n    // ===============                      ========================\n                                            // v\n    _cmsIOPrintf(m, \" [\");\n\n    for (i=0; i < Table->nEntries; i++) {\n    if (i % 10 == 0)\n            _cmsIOPrintf(m, \"\\n  \");\n        _cmsIOPrintf(m, \"%d \", Table->Table16[i]);\n    }\n\n    _cmsIOPrintf(m, \"] \");                        // v tab\n\n    _cmsIOPrintf(m, \"dup \");                      // v tab tab\n    _cmsIOPrintf(m, \"length 1 sub \");             // v tab dom\n    _cmsIOPrintf(m, \"3 -1 roll \");                // tab dom v\n    _cmsIOPrintf(m, \"mul \");                      // tab val2\n    _cmsIOPrintf(m, \"dup \");                      // tab val2 val2\n    _cmsIOPrintf(m, \"dup \");                      // tab val2 val2 val2\n    _cmsIOPrintf(m, \"floor cvi \");                // tab val2 val2 cell0\n    _cmsIOPrintf(m, \"exch \");                     // tab val2 cell0 val2\n    _cmsIOPrintf(m, \"ceiling cvi \");              // tab val2 cell0 cell1\n    _cmsIOPrintf(m, \"3 index \");                  // tab val2 cell0 cell1 tab\n    _cmsIOPrintf(m, \"exch \");                     // tab val2 cell0 tab cell1\n    _cmsIOPrintf(m, \"get\\n  \");                   // tab val2 cell0 y1\n    _cmsIOPrintf(m, \"4 -1 roll \");                // val2 cell0 y1 tab\n    _cmsIOPrintf(m, \"3 -1 roll \");                // val2 y1 tab cell0\n    _cmsIOPrintf(m, \"get \");                      // val2 y1 y0\n    _cmsIOPrintf(m, \"dup \");                      // val2 y1 y0 y0\n    _cmsIOPrintf(m, \"3 1 roll \");                 // val2 y0 y1 y0\n    _cmsIOPrintf(m, \"sub \");                      // val2 y0 (y1-y0)\n    _cmsIOPrintf(m, \"3 -1 roll \");                // y0 (y1-y0) val2\n    _cmsIOPrintf(m, \"dup \");                      // y0 (y1-y0) val2 val2\n    _cmsIOPrintf(m, \"floor cvi \");                // y0 (y1-y0) val2 floor(val2)\n    _cmsIOPrintf(m, \"sub \");                      // y0 (y1-y0) rest\n    _cmsIOPrintf(m, \"mul \");                      // y0 t1\n    _cmsIOPrintf(m, \"add \");                      // y\n    _cmsIOPrintf(m, \"65535 div\\n\");               // result\n\n    _cmsIOPrintf(m, \" } bind \");\n}",
          "fn_code_pos": [
            [
              437,
              0
            ],
            [
              509,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Emit1Gamma",
            "parameters": {
              "m": "cmsIOHANDLER",
              "Table": "cmsToneCurve"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool GammaTableEquals(cmsUInt16Number* g1, cmsUInt16Number* g2, cmsUInt32Number nG1, cmsUInt32Number nG2)\n{\n    if (nG1 != nG2) return FALSE;\n    return memcmp(g1, g2, nG1 * sizeof(cmsUInt16Number)) == 0;\n}",
          "fn_code_pos": [
            [
              514,
              0
            ],
            [
              519,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GammaTableEquals",
            "parameters": {
              "g1": "cmsUInt16Number",
              "g2": "cmsUInt16Number",
              "nG1": "cmsUInt32Number",
              "nG2": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid EmitNGamma(cmsIOHANDLER* m, cmsUInt32Number n, cmsToneCurve* g[])\n{\n    cmsUInt32Number i;\n   \n\n    for( i=0; i < n; i++ )\n    {\n        if (g[i] == NULL) return; // Error\n\n        if (i > 0 && GammaTableEquals(g[i-1]->Table16, g[i]->Table16, g[i-1]->nEntries, g[i]->nEntries)) {\n\n            _cmsIOPrintf(m, \"dup \");\n        }\n        else {\n            Emit1Gamma(m, g[i]);\n        }\n    }\n\n}",
          "fn_code_pos": [
            [
              524,
              0
            ],
            [
              543,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EmitNGamma",
            "parameters": {
              "m": "cmsIOHANDLER",
              "n": "cmsUInt32Number",
              "g": "cmsToneCurve"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nint OutputValueSampler(CMSREGISTER const cmsUInt16Number In[], CMSREGISTER cmsUInt16Number Out[], CMSREGISTER void* Cargo)\n{\n    cmsPsSamplerCargo* sc = (cmsPsSamplerCargo*) Cargo;\n    cmsUInt32Number i;\n\n\n    if (sc -> FixWhite) {\n\n        if (In[0] == 0xFFFF) {  // Only in L* = 100, ab = [-8..8]\n\n            if ((In[1] >= 0x7800 && In[1] <= 0x8800) &&\n                (In[2] >= 0x7800 && In[2] <= 0x8800)) {\n\n                cmsUInt16Number* Black;\n                cmsUInt16Number* White;\n                cmsUInt32Number nOutputs;\n\n                if (!_cmsEndPointsBySpace(sc ->ColorSpace, &White, &Black, &nOutputs))\n                        return 0;\n\n                for (i=0; i < nOutputs; i++)\n                        Out[i] = White[i];\n            }\n\n\n        }\n    }\n\n\n    // Handle the parenthesis on rows\n\n    if (In[0] != sc ->FirstComponent) {\n\n            if (sc ->FirstComponent != -1) {\n\n                    _cmsIOPrintf(sc ->m, sc ->PostMin);\n                    sc ->SecondComponent = -1;\n                    _cmsIOPrintf(sc ->m, sc ->PostMaj);\n            }\n\n            // Begin block\n            _cmsPSActualColumn = 0;\n\n            _cmsIOPrintf(sc ->m, sc ->PreMaj);\n            sc ->FirstComponent = In[0];\n    }\n\n\n      if (In[1] != sc ->SecondComponent) {\n\n            if (sc ->SecondComponent != -1) {\n\n                    _cmsIOPrintf(sc ->m, sc ->PostMin);\n            }\n\n            _cmsIOPrintf(sc ->m, sc ->PreMin);\n            sc ->SecondComponent = In[1];\n    }\n\n      // Dump table.\n\n      for (i=0; i < sc -> Pipeline ->Params->nOutputs; i++) {\n\n          cmsUInt16Number wWordOut = Out[i];\n          cmsUInt8Number wByteOut;           // Value as byte\n\n\n          // We always deal with Lab4\n\n          wByteOut = Word2Byte(wWordOut);\n          WriteByte(sc -> m, wByteOut);\n      }\n\n      return 1;\n}",
          "fn_code_pos": [
            [
              561,
              0
            ],
            [
              636,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OutputValueSampler",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nvoid WriteCLUT(cmsIOHANDLER* m, cmsStage* mpe, const char* PreMaj,\n                                               const char* PostMaj,\n                                               const char* PreMin,\n                                               const char* PostMin,\n                                               int FixWhite,\n                                               cmsColorSpaceSignature ColorSpace)\n{\n    cmsUInt32Number i;\n    cmsPsSamplerCargo sc;\n\n    sc.FirstComponent = -1;\n    sc.SecondComponent = -1;\n    sc.Pipeline = (_cmsStageCLutData *) mpe ->Data;\n    sc.m   = m;\n    sc.PreMaj = PreMaj;\n    sc.PostMaj= PostMaj;\n\n    sc.PreMin   = PreMin;\n    sc.PostMin  = PostMin;\n    sc.FixWhite = FixWhite;\n    sc.ColorSpace = ColorSpace;\n\n    if (sc.Pipeline != NULL && sc.Pipeline->Params != NULL) {\n\n        _cmsIOPrintf(m, \"[\");\n\n        for (i = 0; i < sc.Pipeline->Params->nInputs; i++) {\n            if (i < MAX_INPUT_DIMENSIONS)\n                _cmsIOPrintf(m, \" %d \", sc.Pipeline->Params->nSamples[i]);\n        }\n\n        _cmsIOPrintf(m, \" [\\n\");\n\n        cmsStageSampleCLut16bit(mpe, OutputValueSampler, (void*)&sc, SAMPLER_INSPECT);\n\n        _cmsIOPrintf(m, PostMin);\n        _cmsIOPrintf(m, PostMaj);\n        _cmsIOPrintf(m, \"] \");\n    }\n\n}",
          "fn_code_pos": [
            [
              640,
              0
            ],
            [
              681,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteCLUT",
            "parameters": {
              "m": "cmsIOHANDLER",
              "mpe": "cmsStage",
              "PreMaj": "char",
              "PostMaj": "char",
              "PreMin": "char",
              "PostMin": "char",
              "FixWhite": "int",
              "ColorSpace": "cmsColorSpaceSignature"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nint EmitCIEBasedA(cmsIOHANDLER* m, cmsToneCurve* Curve, cmsCIEXYZ* BlackPoint)\n{\n\n    _cmsIOPrintf(m, \"[ /CIEBasedA\\n\");\n    _cmsIOPrintf(m, \"  <<\\n\");\n\n    _cmsIOPrintf(m, \"/DecodeA \");\n\n    Emit1Gamma(m, Curve);\n\n    _cmsIOPrintf(m, \" \\n\");\n\n    _cmsIOPrintf(m, \"/MatrixA [ 0.9642 1.0000 0.8249 ]\\n\");\n    _cmsIOPrintf(m, \"/RangeLMN [ 0.0 0.9642 0.0 1.0000 0.0 0.8249 ]\\n\");\n\n    EmitWhiteBlackD50(m, BlackPoint);\n    EmitIntent(m, INTENT_PERCEPTUAL);\n\n    _cmsIOPrintf(m, \">>\\n\");\n    _cmsIOPrintf(m, \"]\\n\");\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              686,
              0
            ],
            [
              709,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EmitCIEBasedA",
            "parameters": {
              "m": "cmsIOHANDLER",
              "Curve": "cmsToneCurve",
              "BlackPoint": "cmsCIEXYZ"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint EmitCIEBasedABC(cmsIOHANDLER* m, cmsFloat64Number* Matrix, cmsToneCurve** CurveSet, cmsCIEXYZ* BlackPoint)\n{\n    int i;\n\n    _cmsIOPrintf(m, \"[ /CIEBasedABC\\n\");\n    _cmsIOPrintf(m, \"<<\\n\");\n    _cmsIOPrintf(m, \"/DecodeABC [ \");\n\n    EmitNGamma(m, 3, CurveSet);\n\n    _cmsIOPrintf(m, \"]\\n\");\n\n    _cmsIOPrintf(m, \"/MatrixABC [ \" );\n\n    for( i=0; i < 3; i++ ) {\n\n        _cmsIOPrintf(m, \"%.6f %.6f %.6f \", Matrix[i + 3*0],\n                                           Matrix[i + 3*1],\n                                           Matrix[i + 3*2]);\n    }\n\n\n    _cmsIOPrintf(m, \"]\\n\");\n\n    _cmsIOPrintf(m, \"/RangeLMN [ 0.0 0.9642 0.0 1.0000 0.0 0.8249 ]\\n\");\n\n    EmitWhiteBlackD50(m, BlackPoint);\n    EmitIntent(m, INTENT_PERCEPTUAL);\n\n    _cmsIOPrintf(m, \">>\\n\");\n    _cmsIOPrintf(m, \"]\\n\");\n\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              714,
              0
            ],
            [
              749,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EmitCIEBasedABC",
            "parameters": {
              "m": "cmsIOHANDLER",
              "Matrix": "cmsFloat64Number",
              "CurveSet": "cmsToneCurve",
              "BlackPoint": "cmsCIEXYZ"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint EmitCIEBasedDEF(cmsIOHANDLER* m, cmsPipeline* Pipeline, cmsUInt32Number Intent, cmsCIEXYZ* BlackPoint)\n{\n    const char* PreMaj;\n    const char* PostMaj;\n    const char* PreMin, *PostMin;\n    cmsStage* mpe;\n        \n    mpe = Pipeline->Elements;\n\n    switch (cmsStageInputChannels(mpe)) {\n    case 3:\n        _cmsIOPrintf(m, \"[ /CIEBasedDEF\\n\");\n        PreMaj = \"<\";\n        PostMaj = \">\\n\";\n        PreMin = PostMin = \"\";\n        break;\n\n    case 4:\n        _cmsIOPrintf(m, \"[ /CIEBasedDEFG\\n\");\n        PreMaj = \"[\";\n        PostMaj = \"]\\n\";\n        PreMin = \"<\";\n        PostMin = \">\\n\";\n        break;\n\n    default:\n        return 0;\n\n    }\n\n    _cmsIOPrintf(m, \"<<\\n\");\n\n    if (cmsStageType(mpe) == cmsSigCurveSetElemType) {\n\n        _cmsIOPrintf(m, \"/DecodeDEF [ \");\n        EmitNGamma(m, cmsStageOutputChannels(mpe), _cmsStageGetPtrToCurveSet(mpe));\n        _cmsIOPrintf(m, \"]\\n\");\n\n        mpe = mpe ->Next;\n    }\n\n    if (cmsStageType(mpe) == cmsSigCLutElemType) {\n\n            _cmsIOPrintf(m, \"/Table \");\n            WriteCLUT(m, mpe, PreMaj, PostMaj, PreMin, PostMin, FALSE, (cmsColorSpaceSignature) 0);\n            _cmsIOPrintf(m, \"]\\n\");\n    }\n\n    EmitLab2XYZ(m);\n    EmitWhiteBlackD50(m, BlackPoint);\n    EmitIntent(m, Intent);\n\n    _cmsIOPrintf(m, \"   >>\\n\");\n    _cmsIOPrintf(m, \"]\\n\");\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              752,
              0
            ],
            [
              809,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EmitCIEBasedDEF",
            "parameters": {
              "m": "cmsIOHANDLER",
              "Pipeline": "cmsPipeline",
              "Intent": "cmsUInt32Number",
              "BlackPoint": "cmsCIEXYZ"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\ncmsToneCurve* ExtractGray2Y(cmsContext ContextID, cmsHPROFILE hProfile, cmsUInt32Number Intent)\n{\n    cmsToneCurve* Out = cmsBuildTabulatedToneCurve16(ContextID, 256, NULL);\n    cmsHPROFILE hXYZ  = cmsCreateXYZProfile();\n    cmsHTRANSFORM xform = cmsCreateTransformTHR(ContextID, hProfile, TYPE_GRAY_8, hXYZ, TYPE_XYZ_DBL, Intent, cmsFLAGS_NOOPTIMIZE);\n    int i;\n\n    if (Out != NULL && xform != NULL) {\n        for (i=0; i < 256; i++) {\n\n            cmsUInt8Number Gray = (cmsUInt8Number) i;\n            cmsCIEXYZ XYZ;\n\n            cmsDoTransform(xform, &Gray, &XYZ, 1);\n\n            Out ->Table16[i] =_cmsQuickSaturateWord(XYZ.Y * 65535.0);\n        }\n    }\n\n    if (xform) cmsDeleteTransform(xform);\n    if (hXYZ) cmsCloseProfile(hXYZ);\n    return Out;\n}",
          "fn_code_pos": [
            [
              813,
              0
            ],
            [
              836,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExtractGray2Y",
            "parameters": {
              "ContextID": "cmsContext",
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number"
            },
            "return_type": "cmsToneCurve"
          }
        },
        {
          "fn_code": "static\ncmsBool WriteInputLUT(cmsIOHANDLER* m, cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number dwFlags)\n{\n    cmsHPROFILE hLab;\n    cmsHTRANSFORM xform;\n    cmsUInt32Number nChannels;\n    cmsUInt32Number InputFormat;\n\n    cmsHPROFILE Profiles[2];\n    cmsCIEXYZ BlackPointAdaptedToD50;\n\n    // Does create a device-link based transform.\n    // The DeviceLink is next dumped as working CSA.\n\n    InputFormat = cmsFormatterForColorspaceOfProfile(hProfile, 2, FALSE);\n    nChannels   = T_CHANNELS(InputFormat);\n\n\n    cmsDetectBlackPoint(&BlackPointAdaptedToD50, hProfile, Intent, 0);\n\n    // Adjust output to Lab4\n    hLab = cmsCreateLab4ProfileTHR(m ->ContextID, NULL);\n\n    Profiles[0] = hProfile;\n    Profiles[1] = hLab;\n\n    xform = cmsCreateMultiprofileTransform(Profiles, 2,  InputFormat, TYPE_Lab_DBL, Intent, 0);\n    cmsCloseProfile(hLab);\n\n    if (xform == NULL) {\n\n        cmsSignalError(m ->ContextID, cmsERROR_COLORSPACE_CHECK, \"Cannot create transform Profile -> Lab\");\n        return FALSE;\n    }\n\n    // Only 1, 3 and 4 channels are allowed\n\n    switch (nChannels) {\n\n    case 1: {\n            cmsToneCurve* Gray2Y = ExtractGray2Y(m ->ContextID, hProfile, Intent);\n            EmitCIEBasedA(m, Gray2Y, &BlackPointAdaptedToD50);\n            cmsFreeToneCurve(Gray2Y);            \n            }\n            break;\n\n    case 3:\n    case 4: {\n            cmsUInt32Number OutFrm = TYPE_Lab_16;\n            cmsPipeline* DeviceLink;\n            _cmsTRANSFORM* v = (_cmsTRANSFORM*) xform;\n            cmsBool rc;\n\n            DeviceLink = cmsPipelineDup(v ->Lut);\n            if (DeviceLink == NULL) {\n                cmsDeleteTransform(xform);\n                return FALSE;\n            }\n\n            dwFlags |= cmsFLAGS_FORCE_CLUT;\n            _cmsOptimizePipeline(m->ContextID, &DeviceLink, Intent, &InputFormat, &OutFrm, &dwFlags);\n\n            rc = EmitCIEBasedDEF(m, DeviceLink, Intent, &BlackPointAdaptedToD50);\n            cmsPipelineFree(DeviceLink);            \n            if (!rc) {\n                cmsDeleteTransform(xform);\n                return FALSE;\n            }\n            }\n            break;\n\n    default:\n\n        cmsDeleteTransform(xform);        \n        cmsSignalError(m ->ContextID, cmsERROR_COLORSPACE_CHECK, \"Only 3, 4 channels are supported for CSA. This profile has %d channels.\", nChannels);        \n        return FALSE;        \n    }\n\n    cmsDeleteTransform(xform);\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              843,
              0
            ],
            [
              923,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteInputLUT",
            "parameters": {
              "m": "cmsIOHANDLER",
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number* GetPtrToMatrix(const cmsStage* mpe)\n{\n    _cmsStageMatrixData* Data = (_cmsStageMatrixData*) mpe ->Data;\n\n    return Data -> Double;\n}",
          "fn_code_pos": [
            [
              925,
              0
            ],
            [
              931,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetPtrToMatrix",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\nint WriteInputMatrixShaper(cmsIOHANDLER* m, cmsHPROFILE hProfile, cmsStage* Matrix, cmsStage* Shaper)\n{\n    cmsColorSpaceSignature ColorSpace;\n    int rc;\n    cmsCIEXYZ BlackPointAdaptedToD50;\n\n    ColorSpace = cmsGetColorSpace(hProfile);\n\n    cmsDetectBlackPoint(&BlackPointAdaptedToD50, hProfile, INTENT_RELATIVE_COLORIMETRIC, 0);\n\n    if (ColorSpace == cmsSigGrayData) {\n\n        cmsToneCurve** ShaperCurve = _cmsStageGetPtrToCurveSet(Shaper);\n        rc = EmitCIEBasedA(m, ShaperCurve[0], &BlackPointAdaptedToD50);\n\n    }\n    else\n        if (ColorSpace == cmsSigRgbData) {\n\n            cmsMAT3 Mat;\n            int i, j;\n\n            memmove(&Mat, GetPtrToMatrix(Matrix), sizeof(Mat));\n\n            for (i = 0; i < 3; i++)\n                for (j = 0; j < 3; j++)\n                    Mat.v[i].n[j] *= MAX_ENCODEABLE_XYZ;\n\n            rc = EmitCIEBasedABC(m,  (cmsFloat64Number *) &Mat,\n                                _cmsStageGetPtrToCurveSet(Shaper),\n                                 &BlackPointAdaptedToD50);\n        }\n        else {\n\n            cmsSignalError(m->ContextID, cmsERROR_COLORSPACE_CHECK, \"Profile is not suitable for CSA. Unsupported colorspace.\");\n            return 0;\n        }\n\n    return rc;\n}",
          "fn_code_pos": [
            [
              935,
              0
            ],
            [
              975,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteInputMatrixShaper",
            "parameters": {
              "m": "cmsIOHANDLER",
              "hProfile": "cmsHPROFILE",
              "Matrix": "cmsStage",
              "Shaper": "cmsStage"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint WriteNamedColorCSA(cmsIOHANDLER* m, cmsHPROFILE hNamedColor, cmsUInt32Number Intent)\n{\n    cmsHTRANSFORM xform;\n    cmsHPROFILE   hLab;\n    cmsUInt32Number i, nColors;\n    char ColorName[cmsMAX_PATH];\n    cmsNAMEDCOLORLIST* NamedColorList;\n\n    hLab  = cmsCreateLab4ProfileTHR(m ->ContextID, NULL);\n    xform = cmsCreateTransform(hNamedColor, TYPE_NAMED_COLOR_INDEX, hLab, TYPE_Lab_DBL, Intent, 0);\n    cmsCloseProfile(hLab);\n\n    if (xform == NULL) return 0;\n\n    NamedColorList = cmsGetNamedColorList(xform);\n    if (NamedColorList == NULL) {\n        cmsDeleteTransform(xform);\n        return 0;\n    }\n\n    _cmsIOPrintf(m, \"<<\\n\");\n    _cmsIOPrintf(m, \"(colorlistcomment) (%s)\\n\", \"Named color CSA\");\n    _cmsIOPrintf(m, \"(Prefix) [ (Pantone ) (PANTONE ) ]\\n\");\n    _cmsIOPrintf(m, \"(Suffix) [ ( CV) ( CVC) ( C) ]\\n\");\n\n    nColors   = cmsNamedColorCount(NamedColorList);\n\n    for (i=0; i < nColors; i++) {\n\n        cmsUInt16Number In[1];\n        cmsCIELab Lab;\n\n        In[0] = (cmsUInt16Number) i;\n\n        if (!cmsNamedColorInfo(NamedColorList, i, ColorName, NULL, NULL, NULL, NULL))\n                continue;\n\n        cmsDoTransform(xform, In, &Lab, 1);\n        _cmsIOPrintf(m, \"  (%s) [ %.3f %.3f %.3f ]\\n\", ColorName, Lab.L, Lab.a, Lab.b);\n    }\n\n    _cmsIOPrintf(m, \">>\\n\");\n\n    cmsDeleteTransform(xform);\n    return 1;\n}",
          "fn_code_pos": [
            [
              982,
              0
            ],
            [
              1028,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteNamedColorCSA",
            "parameters": {
              "m": "cmsIOHANDLER",
              "hNamedColor": "cmsHPROFILE",
              "Intent": "cmsUInt32Number"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number GenerateCSA(cmsContext ContextID,\n                            cmsHPROFILE hProfile,\n                            cmsUInt32Number Intent,\n                            cmsUInt32Number dwFlags,\n                            cmsIOHANDLER* mem)\n{\n    cmsUInt32Number dwBytesUsed;\n    cmsPipeline* lut = NULL;\n    cmsStage* Matrix, *Shaper;\n\n\n    // Is a named color profile?\n    if (cmsGetDeviceClass(hProfile) == cmsSigNamedColorClass) {\n\n        if (!WriteNamedColorCSA(mem, hProfile, Intent)) goto Error;\n    }\n    else {\n\n\n        // Any profile class are allowed (including devicelink), but\n        // output (PCS) colorspace must be XYZ or Lab\n        cmsColorSpaceSignature ColorSpace = cmsGetPCS(hProfile);\n\n        if (ColorSpace != cmsSigXYZData &&\n            ColorSpace != cmsSigLabData) {\n\n                cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, \"Invalid output color space\");\n                goto Error;\n        }\n\n\n        // Read the lut with all necessary conversion stages\n        lut = _cmsReadInputLUT(hProfile, Intent);\n        if (lut == NULL) goto Error;\n\n\n        // Tone curves + matrix can be implemented without any LUT\n        if (cmsPipelineCheckAndRetreiveStages(lut, 2, cmsSigCurveSetElemType, cmsSigMatrixElemType, &Shaper, &Matrix)) {\n\n            if (!WriteInputMatrixShaper(mem, hProfile, Matrix, Shaper)) goto Error;\n\n        }\n        else {\n           // We need a LUT for the rest\n           if (!WriteInputLUT(mem, hProfile, Intent, dwFlags)) goto Error;\n        }\n    }\n\n\n    // Done, keep memory usage\n    dwBytesUsed = mem ->UsedSpace;\n\n    // Get rid of LUT\n    if (lut != NULL) cmsPipelineFree(lut);\n\n    // Finally, return used byte count\n    return dwBytesUsed;\n\nError:\n    if (lut != NULL) cmsPipelineFree(lut);\n    return 0;\n}",
          "fn_code_pos": [
            [
              1032,
              0
            ],
            [
              1094,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GenerateCSA",
            "parameters": {
              "ContextID": "cmsContext",
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number",
              "mem": "cmsIOHANDLER"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid EmitPQRStage(cmsIOHANDLER* m, cmsHPROFILE hProfile, int DoBPC, int lIsAbsolute)\n{\n\n\n        if (lIsAbsolute) {\n\n            // For absolute colorimetric intent, encode back to relative\n            // and generate a relative Pipeline\n\n            // Relative encoding is obtained across XYZpcs*(D50/WhitePoint)\n\n            cmsCIEXYZ White;\n\n            _cmsReadMediaWhitePoint(&White, hProfile);\n\n            _cmsIOPrintf(m,\"/MatrixPQR [1 0 0 0 1 0 0 0 1 ]\\n\");\n            _cmsIOPrintf(m,\"/RangePQR [ -0.5 2 -0.5 2 -0.5 2 ]\\n\");\n\n            _cmsIOPrintf(m, \"%% Absolute colorimetric -- encode to relative to maximize LUT usage\\n\"\n                      \"/TransformPQR [\\n\"\n                      \"{0.9642 mul %g div exch pop exch pop exch pop exch pop} bind\\n\"\n                      \"{1.0000 mul %g div exch pop exch pop exch pop exch pop} bind\\n\"\n                      \"{0.8249 mul %g div exch pop exch pop exch pop exch pop} bind\\n]\\n\",\n                      White.X, White.Y, White.Z);\n            return;\n        }\n\n\n        _cmsIOPrintf(m,\"%% Bradford Cone Space\\n\"\n                 \"/MatrixPQR [0.8951 -0.7502 0.0389 0.2664 1.7135 -0.0685 -0.1614 0.0367 1.0296 ] \\n\");\n\n        _cmsIOPrintf(m, \"/RangePQR [ -0.5 2 -0.5 2 -0.5 2 ]\\n\");\n\n\n        // No BPC\n\n        if (!DoBPC) {\n\n            _cmsIOPrintf(m, \"%% VonKries-like transform in Bradford Cone Space\\n\"\n                      \"/TransformPQR [\\n\"\n                      \"{exch pop exch 3 get mul exch pop exch 3 get div} bind\\n\"\n                      \"{exch pop exch 4 get mul exch pop exch 4 get div} bind\\n\"\n                      \"{exch pop exch 5 get mul exch pop exch 5 get div} bind\\n]\\n\");\n        } else {\n\n            // BPC\n\n            _cmsIOPrintf(m, \"%% VonKries-like transform in Bradford Cone Space plus BPC\\n\"\n                      \"/TransformPQR [\\n\");\n\n            _cmsIOPrintf(m, \"{4 index 3 get div 2 index 3 get mul \"\n                    \"2 index 3 get 2 index 3 get sub mul \"\n                    \"2 index 3 get 4 index 3 get 3 index 3 get sub mul sub \"\n                    \"3 index 3 get 3 index 3 get exch sub div \"\n                    \"exch pop exch pop exch pop exch pop } bind\\n\");\n\n            _cmsIOPrintf(m, \"{4 index 4 get div 2 index 4 get mul \"\n                    \"2 index 4 get 2 index 4 get sub mul \"\n                    \"2 index 4 get 4 index 4 get 3 index 4 get sub mul sub \"\n                    \"3 index 4 get 3 index 4 get exch sub div \"\n                    \"exch pop exch pop exch pop exch pop } bind\\n\");\n\n            _cmsIOPrintf(m, \"{4 index 5 get div 2 index 5 get mul \"\n                    \"2 index 5 get 2 index 5 get sub mul \"\n                    \"2 index 5 get 4 index 5 get 3 index 5 get sub mul sub \"\n                    \"3 index 5 get 3 index 5 get exch sub div \"\n                    \"exch pop exch pop exch pop exch pop } bind\\n]\\n\");\n\n        }\n}",
          "fn_code_pos": [
            [
              1162,
              0
            ],
            [
              1232,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EmitPQRStage",
            "parameters": {
              "m": "cmsIOHANDLER",
              "hProfile": "cmsHPROFILE",
              "DoBPC": "int",
              "lIsAbsolute": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid EmitXYZ2Lab(cmsIOHANDLER* m)\n{\n    _cmsIOPrintf(m, \"/RangeLMN [ -0.635 2.0 0 2 -0.635 2.0 ]\\n\");\n    _cmsIOPrintf(m, \"/EncodeLMN [\\n\");\n    _cmsIOPrintf(m, \"{ 0.964200  div dup 0.008856 le {7.787 mul 16 116 div add}{1 3 div exp} ifelse } bind\\n\");\n    _cmsIOPrintf(m, \"{ 1.000000  div dup 0.008856 le {7.787 mul 16 116 div add}{1 3 div exp} ifelse } bind\\n\");\n    _cmsIOPrintf(m, \"{ 0.824900  div dup 0.008856 le {7.787 mul 16 116 div add}{1 3 div exp} ifelse } bind\\n\");\n    _cmsIOPrintf(m, \"]\\n\");\n    _cmsIOPrintf(m, \"/MatrixABC [ 0 1 0 1 -1 1 0 0 -1 ]\\n\");\n    _cmsIOPrintf(m, \"/EncodeABC [\\n\");\n\n\n    _cmsIOPrintf(m, \"{ 116 mul  16 sub 100 div  } bind\\n\");\n    _cmsIOPrintf(m, \"{ 500 mul 128 add 256 div  } bind\\n\");\n    _cmsIOPrintf(m, \"{ 200 mul 128 add 256 div  } bind\\n\");\n\n\n    _cmsIOPrintf(m, \"]\\n\");\n\n\n}",
          "fn_code_pos": [
            [
              1235,
              0
            ],
            [
              1256,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EmitXYZ2Lab",
            "parameters": {
              "m": "cmsIOHANDLER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool WriteOutputLUT(cmsIOHANDLER* m, cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number dwFlags)\n{\n    cmsHPROFILE hLab;\n    cmsHTRANSFORM xform;\n    cmsUInt32Number i, nChannels;\n    cmsUInt32Number OutputFormat;\n    _cmsTRANSFORM* v;\n    cmsPipeline* DeviceLink;\n    cmsHPROFILE Profiles[3];\n    cmsCIEXYZ BlackPointAdaptedToD50;\n    cmsBool lDoBPC = (cmsBool) (dwFlags & cmsFLAGS_BLACKPOINTCOMPENSATION);\n    cmsBool lFixWhite = (cmsBool) !(dwFlags & cmsFLAGS_NOWHITEONWHITEFIXUP);\n    cmsUInt32Number InFrm = TYPE_Lab_16;\n    cmsUInt32Number RelativeEncodingIntent;\n    cmsColorSpaceSignature ColorSpace;\n    cmsStage* first;\n\n    hLab = cmsCreateLab4ProfileTHR(m ->ContextID, NULL);\n    if (hLab == NULL) return FALSE;\n\n    OutputFormat = cmsFormatterForColorspaceOfProfile(hProfile, 2, FALSE);\n    nChannels    = T_CHANNELS(OutputFormat);\n\n    ColorSpace = cmsGetColorSpace(hProfile);\n\n    // For absolute colorimetric, the LUT is encoded as relative in order to preserve precision.\n\n    RelativeEncodingIntent = Intent;\n    if (RelativeEncodingIntent == INTENT_ABSOLUTE_COLORIMETRIC)\n        RelativeEncodingIntent = INTENT_RELATIVE_COLORIMETRIC;\n\n\n    // Use V4 Lab always\n    Profiles[0] = hLab;\n    Profiles[1] = hProfile;\n\n    xform = cmsCreateMultiprofileTransformTHR(m ->ContextID,\n                                              Profiles, 2, TYPE_Lab_DBL,\n                                              OutputFormat, RelativeEncodingIntent, 0);\n    cmsCloseProfile(hLab);\n\n    if (xform == NULL) {        \n        cmsSignalError(m ->ContextID, cmsERROR_COLORSPACE_CHECK, \"Cannot create transform Lab -> Profile in CRD creation\");\n        return FALSE;\n    }\n\n    // Get a copy of the internal devicelink\n    v = (_cmsTRANSFORM*) xform;\n    DeviceLink = cmsPipelineDup(v ->Lut);\n    if (DeviceLink == NULL) {\n        cmsDeleteTransform(xform);\n        cmsSignalError(m->ContextID, cmsERROR_CORRUPTION_DETECTED, \"Cannot access link for CRD\");\n        return FALSE;\n    }\n\n     // We need a CLUT\n    dwFlags |= cmsFLAGS_FORCE_CLUT;\n    if (!_cmsOptimizePipeline(m->ContextID, &DeviceLink, RelativeEncodingIntent, &InFrm, &OutputFormat, &dwFlags)) {\n        cmsPipelineFree(DeviceLink);\n        cmsDeleteTransform(xform);\n        cmsSignalError(m->ContextID, cmsERROR_CORRUPTION_DETECTED, \"Cannot create CLUT table for CRD\");\n        return FALSE;\n    }\n\n    _cmsIOPrintf(m, \"<<\\n\");\n    _cmsIOPrintf(m, \"/ColorRenderingType 1\\n\");\n\n    cmsDetectBlackPoint(&BlackPointAdaptedToD50, hProfile, Intent, 0);\n\n    // Emit headers, etc.\n    EmitWhiteBlackD50(m, &BlackPointAdaptedToD50);\n    EmitPQRStage(m, hProfile, lDoBPC, Intent == INTENT_ABSOLUTE_COLORIMETRIC);\n    EmitXYZ2Lab(m);\n\n\n    // FIXUP: map Lab (100, 0, 0) to perfect white, because the particular encoding for Lab\n    // does map a=b=0 not falling into any specific node. Since range a,b goes -128..127,\n    // zero is slightly moved towards right, so assure next node (in L=100 slice) is mapped to\n    // zero. This would sacrifice a bit of highlights, but failure to do so would cause\n    // scum dot. Ouch.\n\n    if (Intent == INTENT_ABSOLUTE_COLORIMETRIC)\n            lFixWhite = FALSE;\n\n    _cmsIOPrintf(m, \"/RenderTable \");\n\n    first = cmsPipelineGetPtrToFirstStage(DeviceLink);\n    if (first != NULL) {\n        WriteCLUT(m, first, \"<\", \">\\n\", \"\", \"\", lFixWhite, ColorSpace);\n    }\n\n    _cmsIOPrintf(m, \" %d {} bind \", nChannels);\n\n    for (i=1; i < nChannels; i++)\n            _cmsIOPrintf(m, \"dup \");\n\n    _cmsIOPrintf(m, \"]\\n\");\n\n    EmitIntent(m, Intent);\n\n    _cmsIOPrintf(m, \">>\\n\");\n\n    if (!(dwFlags & cmsFLAGS_NODEFAULTRESOURCEDEF)) {\n\n        _cmsIOPrintf(m, \"/Current exch /ColorRendering defineresource pop\\n\");\n    }\n\n    cmsPipelineFree(DeviceLink);\n    cmsDeleteTransform(xform);\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1264,
              0
            ],
            [
              1376,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteOutputLUT",
            "parameters": {
              "m": "cmsIOHANDLER",
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid BuildColorantList(char *Colorant, cmsUInt32Number nColorant, cmsUInt16Number Out[])\n{\n    char Buff[32];\n    cmsUInt32Number j;\n\n    Colorant[0] = 0;\n    if (nColorant > cmsMAXCHANNELS)\n        nColorant = cmsMAXCHANNELS;\n\n    for (j = 0; j < nColorant; j++) {\n\n        snprintf(Buff, 31, \"%.3f\", Out[j] / 65535.0);\n        Buff[31] = 0;\n        strcat(Colorant, Buff);\n        if (j < nColorant - 1)\n            strcat(Colorant, \" \");\n\n    }\n}",
          "fn_code_pos": [
            [
              1380,
              0
            ],
            [
              1399,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BuildColorantList",
            "parameters": {
              "Colorant": "char",
              "nColorant": "cmsUInt32Number",
              "Out": "cmsUInt16Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nint WriteNamedColorCRD(cmsIOHANDLER* m, cmsHPROFILE hNamedColor, cmsUInt32Number Intent, cmsUInt32Number dwFlags)\n{\n    cmsHTRANSFORM xform;\n    cmsUInt32Number i, nColors, nColorant;\n    cmsUInt32Number OutputFormat;\n    char ColorName[cmsMAX_PATH];\n    char Colorant[512];\n    cmsNAMEDCOLORLIST* NamedColorList;\n\n\n    OutputFormat = cmsFormatterForColorspaceOfProfile(hNamedColor, 2, FALSE);\n    nColorant    = T_CHANNELS(OutputFormat);\n\n\n    xform = cmsCreateTransform(hNamedColor, TYPE_NAMED_COLOR_INDEX, NULL, OutputFormat, Intent, dwFlags);\n    if (xform == NULL) return 0;\n\n\n    NamedColorList = cmsGetNamedColorList(xform);\n    if (NamedColorList == NULL) {\n        cmsDeleteTransform(xform);\n        return 0;\n    }\n\n    _cmsIOPrintf(m, \"<<\\n\");\n    _cmsIOPrintf(m, \"(colorlistcomment) (%s) \\n\", \"Named profile\");\n    _cmsIOPrintf(m, \"(Prefix) [ (Pantone ) (PANTONE ) ]\\n\");\n    _cmsIOPrintf(m, \"(Suffix) [ ( CV) ( CVC) ( C) ]\\n\");\n\n    nColors   = cmsNamedColorCount(NamedColorList);\n\n    for (i=0; i < nColors; i++) {\n\n        cmsUInt16Number In[1];\n        cmsUInt16Number Out[cmsMAXCHANNELS];\n\n        In[0] = (cmsUInt16Number) i;\n\n        if (!cmsNamedColorInfo(NamedColorList, i, ColorName, NULL, NULL, NULL, NULL))\n                continue;\n\n        cmsDoTransform(xform, In, Out, 1);\n        BuildColorantList(Colorant, nColorant, Out);\n        _cmsIOPrintf(m, \"  (%s) [ %s ]\\n\", ColorName, Colorant);\n    }\n\n    _cmsIOPrintf(m, \"   >>\");\n\n    if (!(dwFlags & cmsFLAGS_NODEFAULTRESOURCEDEF)) {\n\n    _cmsIOPrintf(m, \" /Current exch /HPSpotTable defineresource pop\\n\");\n    }\n\n    cmsDeleteTransform(xform);\n    return 1;\n}",
          "fn_code_pos": [
            [
              1405,
              0
            ],
            [
              1461,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteNamedColorCRD",
            "parameters": {
              "m": "cmsIOHANDLER",
              "hNamedColor": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number  GenerateCRD(cmsContext ContextID,\n                             cmsHPROFILE hProfile,\n                             cmsUInt32Number Intent, cmsUInt32Number dwFlags,\n                             cmsIOHANDLER* mem)\n{\n    cmsUInt32Number dwBytesUsed;\n\n    if (!(dwFlags & cmsFLAGS_NODEFAULTRESOURCEDEF)) {\n\n        EmitHeader(mem, \"Color Rendering Dictionary (CRD)\", hProfile);\n    }\n\n\n    // Is a named color profile?\n    if (cmsGetDeviceClass(hProfile) == cmsSigNamedColorClass) {\n\n        if (!WriteNamedColorCRD(mem, hProfile, Intent, dwFlags)) {\n            return 0;\n        }\n    }\n    else {\n\n        // CRD are always implemented as LUT\n\n        if (!WriteOutputLUT(mem, hProfile, Intent, dwFlags)) {\n            return 0;\n        }\n    }\n\n    if (!(dwFlags & cmsFLAGS_NODEFAULTRESOURCEDEF)) {\n\n        _cmsIOPrintf(mem, \"%%%%EndResource\\n\");\n        _cmsIOPrintf(mem, \"\\n%% CRD End\\n\");\n    }\n\n    // Done, keep memory usage\n    dwBytesUsed = mem ->UsedSpace;\n\n    // Finally, return used byte count\n    return dwBytesUsed;\n\n    cmsUNUSED_PARAMETER(ContextID);\n}",
          "fn_code_pos": [
            [
              1469,
              0
            ],
            [
              1512,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GenerateCRD",
            "parameters": {
              "ContextID": "cmsContext",
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number",
              "mem": "cmsIOHANDLER"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsGetPostScriptColorResource(cmsContext ContextID,\n                                                               cmsPSResourceType Type,\n                                                               cmsHPROFILE hProfile,\n                                                               cmsUInt32Number Intent,\n                                                               cmsUInt32Number dwFlags,\n                                                               cmsIOHANDLER* io)\n{\n    cmsUInt32Number  rc;\n\n\n    switch (Type) {\n\n        case cmsPS_RESOURCE_CSA:\n            rc = GenerateCSA(ContextID, hProfile, Intent, dwFlags, io);\n            break;\n\n        default:\n        case cmsPS_RESOURCE_CRD:\n            rc = GenerateCRD(ContextID, hProfile, Intent, dwFlags, io);\n            break;\n    }\n\n    return rc;\n}",
          "fn_code_pos": [
            [
              1517,
              0
            ],
            [
              1540,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetPostScriptColorResource",
            "parameters": {
              "ContextID": "cmsContext",
              "Type": "cmsPSResourceType",
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number",
              "io": "cmsIOHANDLER"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsGetPostScriptCRD(cmsContext ContextID,\n                              cmsHPROFILE hProfile,\n                              cmsUInt32Number Intent, cmsUInt32Number dwFlags,\n                              void* Buffer, cmsUInt32Number dwBufferLen)\n{\n    cmsIOHANDLER* mem;\n    cmsUInt32Number dwBytesUsed;\n\n    // Set up the serialization engine\n    if (Buffer == NULL)\n        mem = cmsOpenIOhandlerFromNULL(ContextID);\n    else\n        mem = cmsOpenIOhandlerFromMem(ContextID, Buffer, dwBufferLen, \"w\");\n\n    if (!mem) return 0;\n\n    dwBytesUsed =  cmsGetPostScriptColorResource(ContextID, cmsPS_RESOURCE_CRD, hProfile, Intent, dwFlags, mem);\n\n    // Get rid of memory stream\n    cmsCloseIOhandler(mem);\n\n    return dwBytesUsed;\n}",
          "fn_code_pos": [
            [
              1544,
              0
            ],
            [
              1566,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetPostScriptCRD",
            "parameters": {
              "ContextID": "cmsContext",
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number",
              "Buffer": "void",
              "dwBufferLen": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsGetPostScriptCSA(cmsContext ContextID,\n                                              cmsHPROFILE hProfile,\n                                              cmsUInt32Number Intent,\n                                              cmsUInt32Number dwFlags,\n                                              void* Buffer,\n                                              cmsUInt32Number dwBufferLen)\n{\n    cmsIOHANDLER* mem;\n    cmsUInt32Number dwBytesUsed;\n\n    if (Buffer == NULL)\n        mem = cmsOpenIOhandlerFromNULL(ContextID);\n    else\n        mem = cmsOpenIOhandlerFromMem(ContextID, Buffer, dwBufferLen, \"w\");\n\n    if (!mem) return 0;\n\n    dwBytesUsed =  cmsGetPostScriptColorResource(ContextID, cmsPS_RESOURCE_CSA, hProfile, Intent, dwFlags, mem);\n\n    // Get rid of memory stream\n    cmsCloseIOhandler(mem);\n\n    return dwBytesUsed;\n\n}",
          "fn_code_pos": [
            [
              1571,
              0
            ],
            [
              1595,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetPostScriptCSA",
            "parameters": {
              "ContextID": "cmsContext",
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number",
              "Buffer": "void",
              "dwBufferLen": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "RemoveCR(const char* txt)",
          "fn_dec_pos": [
            [
              317,
              6
            ],
            [
              317,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RemoveCR",
            "parameters": {
              "txt": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ExtractGray2Y(cmsContext ContextID, cmsHPROFILE hProfile, cmsUInt32Number Intent)",
          "fn_dec_pos": [
            [
              814,
              14
            ],
            [
              814,
              95
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExtractGray2Y",
            "parameters": {
              "ContextID": "cmsContext",
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "GetPtrToMatrix(const cmsStage* mpe)",
          "fn_dec_pos": [
            [
              926,
              18
            ],
            [
              926,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetPtrToMatrix",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n    _cmsStageCLutData* Pipeline;\n    cmsIOHANDLER* m;\n\n    int FirstComponent;\n    int SecondComponent;\n\n    const char* PreMaj;\n    const char* PostMaj;\n    const char* PreMin;\n    const char* PostMin;\n\n    int  FixWhite;    // Force mapping of pure white\n\n    cmsColorSpaceSignature  ColorSpace;  // ColorSpace of profile\n\n\n} cmsPsSamplerCargo;",
          {
            "* Pipeline": "_cmsStageCLutData",
            "* m": "cmsIOHANDLER",
            "FirstComponent": "int",
            "SecondComponent": "int",
            "char": "const",
            "FixWhite": "int",
            "ColorSpace": "cmsColorSpaceSignature"
          },
          "cmsPsSamplerCargo",
          [
            267,
            0
          ],
          [
            284,
            20
          ]
        ],
        [
          "typedef struct {\n    _cmsStageCLutData* Pipeline;\n    cmsIOHANDLER* m;\n\n    int FirstComponent;\n    int SecondComponent;\n\n    const char* PreMaj;\n    const char* PostMaj;\n    const char* PreMin;\n    const char* PostMin;\n\n    int  FixWhite;    // Force mapping of pure white\n\n    cmsColorSpaceSignature  ColorSpace;  // ColorSpace of profile\n\n\n} cmsPsSamplerCargo;",
          {
            "* Pipeline": "_cmsStageCLutData",
            "* m": "cmsIOHANDLER",
            "FirstComponent": "int",
            "SecondComponent": "int",
            "char": "const",
            "FixWhite": "int",
            "ColorSpace": "cmsColorSpaceSignature"
          },
          "cmsPsSamplerCargo",
          [
            267,
            0
          ],
          [
            284,
            20
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmsio1.c": {
      "fn_def_list": [
        {
          "fn_code": "cmsBool  _cmsReadMediaWhitePoint(cmsCIEXYZ* Dest, cmsHPROFILE hProfile)\n{\n    cmsCIEXYZ* Tag;\n\n    _cmsAssert(Dest != NULL);\n\n    Tag = (cmsCIEXYZ*) cmsReadTag(hProfile, cmsSigMediaWhitePointTag);\n\n    // If no wp, take D50\n    if (Tag == NULL) {\n        *Dest = *cmsD50_XYZ();\n        return TRUE;\n    }\n\n    // V2 display profiles should give D50\n    if (cmsGetEncodedICCversion(hProfile) < 0x4000000) {\n\n        if (cmsGetDeviceClass(hProfile) == cmsSigDisplayClass) {\n            *Dest = *cmsD50_XYZ();\n            return TRUE;\n        }\n    }\n\n    // All seems ok\n    *Dest = *Tag;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              63,
              0
            ],
            [
              89,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadMediaWhitePoint",
            "parameters": {
              "Dest": "cmsCIEXYZ",
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool  _cmsReadCHAD(cmsMAT3* Dest, cmsHPROFILE hProfile)\n{\n    cmsMAT3* Tag;\n\n    _cmsAssert(Dest != NULL);\n\n    Tag = (cmsMAT3*) cmsReadTag(hProfile, cmsSigChromaticAdaptationTag);\n\n    if (Tag != NULL) {\n        *Dest = *Tag;\n        return TRUE;\n    }\n\n    // No CHAD available, default it to identity\n    _cmsMAT3identity(Dest);\n\n    // V2 display profiles should give D50\n    if (cmsGetEncodedICCversion(hProfile) < 0x4000000) {\n\n        if (cmsGetDeviceClass(hProfile) == cmsSigDisplayClass) {\n\n            cmsCIEXYZ* White = (cmsCIEXYZ*) cmsReadTag(hProfile, cmsSigMediaWhitePointTag);\n\n            if (White == NULL) {\n\n                _cmsMAT3identity(Dest);\n                return TRUE;\n            }\n\n            return _cmsAdaptationMatrix(Dest, NULL, White, cmsD50_XYZ());\n        }\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              93,
              0
            ],
            [
              127,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadCHAD",
            "parameters": {
              "Dest": "cmsMAT3",
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool ReadICCMatrixRGB2XYZ(cmsMAT3* r, cmsHPROFILE hProfile)\n{\n    cmsCIEXYZ *PtrRed, *PtrGreen, *PtrBlue;\n\n    _cmsAssert(r != NULL);\n\n    PtrRed   = (cmsCIEXYZ *) cmsReadTag(hProfile, cmsSigRedColorantTag);\n    PtrGreen = (cmsCIEXYZ *) cmsReadTag(hProfile, cmsSigGreenColorantTag);\n    PtrBlue  = (cmsCIEXYZ *) cmsReadTag(hProfile, cmsSigBlueColorantTag);\n\n    if (PtrRed == NULL || PtrGreen == NULL || PtrBlue == NULL)\n        return FALSE;\n\n    _cmsVEC3init(&r -> v[0], PtrRed -> X, PtrGreen -> X,  PtrBlue -> X);\n    _cmsVEC3init(&r -> v[1], PtrRed -> Y, PtrGreen -> Y,  PtrBlue -> Y);\n    _cmsVEC3init(&r -> v[2], PtrRed -> Z, PtrGreen -> Z,  PtrBlue -> Z);\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              131,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadICCMatrixRGB2XYZ",
            "parameters": {
              "r": "cmsMAT3",
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsPipeline* BuildGrayInputMatrixPipeline(cmsHPROFILE hProfile)\n{\n    cmsToneCurve *GrayTRC;\n    cmsPipeline* Lut;\n    cmsContext ContextID = cmsGetProfileContextID(hProfile);\n\n    GrayTRC = (cmsToneCurve *) cmsReadTag(hProfile, cmsSigGrayTRCTag);\n    if (GrayTRC == NULL) return NULL;\n\n    Lut = cmsPipelineAlloc(ContextID, 1, 3);\n    if (Lut == NULL)\n        goto Error;\n\n    if (cmsGetPCS(hProfile) == cmsSigLabData) {\n\n        // In this case we implement the profile as an  identity matrix plus 3 tone curves\n        cmsUInt16Number Zero[2] = { 0x8080, 0x8080 };\n        cmsToneCurve* EmptyTab;\n        cmsToneCurve* LabCurves[3];\n\n        EmptyTab = cmsBuildTabulatedToneCurve16(ContextID, 2, Zero);\n\n        if (EmptyTab == NULL)\n            goto Error;\n\n        LabCurves[0] = GrayTRC;\n        LabCurves[1] = EmptyTab;\n        LabCurves[2] = EmptyTab;\n\n        if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3,  1, OneToThreeInputMatrix, NULL)) ||\n            !cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 3, LabCurves))) {\n                cmsFreeToneCurve(EmptyTab);\n                goto Error;\n        }\n\n        cmsFreeToneCurve(EmptyTab);\n\n    }\n    else  {\n\n        if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 1, &GrayTRC)) ||\n            !cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3,  1, GrayInputMatrix, NULL)))\n            goto Error;\n    }\n\n    return Lut;\n\nError:    \n    cmsPipelineFree(Lut);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              154,
              0
            ],
            [
              205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BuildGrayInputMatrixPipeline",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsPipeline"
          }
        },
        {
          "fn_code": "static\ncmsPipeline* BuildRGBInputMatrixShaper(cmsHPROFILE hProfile)\n{\n    cmsPipeline* Lut;\n    cmsMAT3 Mat;\n    cmsToneCurve *Shapes[3];\n    cmsContext ContextID = cmsGetProfileContextID(hProfile);\n    int i, j;\n\n    if (!ReadICCMatrixRGB2XYZ(&Mat, hProfile)) return NULL;\n\n    // XYZ PCS in encoded in 1.15 format, and the matrix output comes in 0..0xffff range, so\n    // we need to adjust the output by a factor of (0x10000/0xffff) to put data in\n    // a 1.16 range, and then a >> 1 to obtain 1.15. The total factor is (65536.0)/(65535.0*2)\n\n    for (i=0; i < 3; i++)\n        for (j=0; j < 3; j++)\n            Mat.v[i].n[j] *= InpAdj;\n\n\n    Shapes[0] = (cmsToneCurve *) cmsReadTag(hProfile, cmsSigRedTRCTag);\n    Shapes[1] = (cmsToneCurve *) cmsReadTag(hProfile, cmsSigGreenTRCTag);\n    Shapes[2] = (cmsToneCurve *) cmsReadTag(hProfile, cmsSigBlueTRCTag);\n\n    if (!Shapes[0] || !Shapes[1] || !Shapes[2])\n        return NULL;\n\n    Lut = cmsPipelineAlloc(ContextID, 3, 3);\n    if (Lut != NULL) {\n\n        if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 3, Shapes)) ||\n            !cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3, 3, (cmsFloat64Number*) &Mat, NULL)))\n            goto Error;\n\n        // Note that it is certainly possible a single profile would have a LUT based\n        // tag for output working in lab and a matrix-shaper for the fallback cases. \n        // This is not allowed by the spec, but this code is tolerant to those cases    \n        if (cmsGetPCS(hProfile) == cmsSigLabData) {\n\n            if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocXYZ2Lab(ContextID)))\n                goto Error;\n        }\n\n    }\n\n    return Lut;\n\nError:\n    cmsPipelineFree(Lut);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              208,
              0
            ],
            [
              258,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BuildRGBInputMatrixShaper",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsPipeline"
          }
        },
        {
          "fn_code": "static\ncmsPipeline* _cmsReadFloatInputTag(cmsHPROFILE hProfile, cmsTagSignature tagFloat)\n{\n    cmsContext ContextID       = cmsGetProfileContextID(hProfile);\n    cmsPipeline* Lut           = cmsPipelineDup((cmsPipeline*) cmsReadTag(hProfile, tagFloat));\n    cmsColorSpaceSignature spc = cmsGetColorSpace(hProfile);\n    cmsColorSpaceSignature PCS = cmsGetPCS(hProfile);\n    \n    if (Lut == NULL) return NULL;\n    \n    // input and output of transform are in lcms 0..1 encoding.  If XYZ or Lab spaces are used, \n    //  these need to be normalized into the appropriate ranges (Lab = 100,0,0, XYZ=1.0,1.0,1.0)\n    if ( spc == cmsSigLabData)\n    {\n        if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToLabFloat(ContextID)))\n            goto Error;\n    }\n    else if (spc == cmsSigXYZData)\n    {\n        if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToXyzFloat(ContextID)))\n            goto Error;\n    }\n    \n    if ( PCS == cmsSigLabData)\n    {\n        if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromLabFloat(ContextID)))\n            goto Error;\n    }\n    else if( PCS == cmsSigXYZData)\n    {\n        if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromXyzFloat(ContextID)))\n            goto Error;\n    }\n    \n    return Lut;\n\nError:\n    cmsPipelineFree(Lut);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              263,
              0
            ],
            [
              302,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadFloatInputTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "tagFloat": "cmsTagSignature"
            },
            "return_type": "cmsPipeline"
          }
        },
        {
          "fn_code": "static\ncmsPipeline* BuildGrayOutputPipeline(cmsHPROFILE hProfile)\n{\n    cmsToneCurve *GrayTRC, *RevGrayTRC;\n    cmsPipeline* Lut;\n    cmsContext ContextID = cmsGetProfileContextID(hProfile);\n\n    GrayTRC = (cmsToneCurve *) cmsReadTag(hProfile, cmsSigGrayTRCTag);\n    if (GrayTRC == NULL) return NULL;\n\n    RevGrayTRC = cmsReverseToneCurve(GrayTRC);\n    if (RevGrayTRC == NULL) return NULL;\n\n    Lut = cmsPipelineAlloc(ContextID, 3, 1);\n    if (Lut == NULL) {\n        cmsFreeToneCurve(RevGrayTRC);\n        return NULL;\n    }\n\n    if (cmsGetPCS(hProfile) == cmsSigLabData) {\n\n        if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 1,  3, PickLstarMatrix, NULL)))\n            goto Error;\n    }\n    else  {\n        if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 1,  3, PickYMatrix, NULL)))\n            goto Error;\n    }\n\n    if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 1, &RevGrayTRC)))\n        goto Error;\n\n    cmsFreeToneCurve(RevGrayTRC);\n    return Lut;\n\nError:\n    cmsFreeToneCurve(RevGrayTRC);\n    cmsPipelineFree(Lut);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              409,
              0
            ],
            [
              448,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BuildGrayOutputPipeline",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsPipeline"
          }
        },
        {
          "fn_code": "static\ncmsPipeline* BuildRGBOutputMatrixShaper(cmsHPROFILE hProfile)\n{\n    cmsPipeline* Lut;\n    cmsToneCurve *Shapes[3], *InvShapes[3];\n    cmsMAT3 Mat, Inv;\n    int i, j;\n    cmsContext ContextID = cmsGetProfileContextID(hProfile);\n\n    if (!ReadICCMatrixRGB2XYZ(&Mat, hProfile))\n        return NULL;\n\n    if (!_cmsMAT3inverse(&Mat, &Inv))\n        return NULL;\n\n    // XYZ PCS in encoded in 1.15 format, and the matrix input should come in 0..0xffff range, so\n    // we need to adjust the input by a << 1 to obtain a 1.16 fixed and then by a factor of\n    // (0xffff/0x10000) to put data in 0..0xffff range. Total factor is (2.0*65535.0)/65536.0;\n\n    for (i=0; i < 3; i++)\n        for (j=0; j < 3; j++)\n            Inv.v[i].n[j] *= OutpAdj;\n\n    Shapes[0] = (cmsToneCurve *) cmsReadTag(hProfile, cmsSigRedTRCTag);\n    Shapes[1] = (cmsToneCurve *) cmsReadTag(hProfile, cmsSigGreenTRCTag);\n    Shapes[2] = (cmsToneCurve *) cmsReadTag(hProfile, cmsSigBlueTRCTag);\n\n    if (!Shapes[0] || !Shapes[1] || !Shapes[2])\n        return NULL;\n\n    InvShapes[0] = cmsReverseToneCurve(Shapes[0]);\n    InvShapes[1] = cmsReverseToneCurve(Shapes[1]);\n    InvShapes[2] = cmsReverseToneCurve(Shapes[2]);\n\n    if (!InvShapes[0] || !InvShapes[1] || !InvShapes[2]) {\n        return NULL;\n    }\n\n    Lut = cmsPipelineAlloc(ContextID, 3, 3);\n    if (Lut != NULL) {\n\n        // Note that it is certainly possible a single profile would have a LUT based\n        // tag for output working in lab and a matrix-shaper for the fallback cases. \n        // This is not allowed by the spec, but this code is tolerant to those cases    \n        if (cmsGetPCS(hProfile) == cmsSigLabData) {\n\n            if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLab2XYZ(ContextID)))\n                goto Error;\n        }\n\n        if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3, 3, (cmsFloat64Number*) &Inv, NULL)) ||\n            !cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 3, InvShapes)))\n            goto Error;\n    }\n\n    cmsFreeToneCurveTriple(InvShapes);\n    return Lut;\nError:\n    cmsFreeToneCurveTriple(InvShapes);\n    cmsPipelineFree(Lut);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              451,
              0
            ],
            [
              512,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BuildRGBOutputMatrixShaper",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsPipeline"
          }
        },
        {
          "fn_code": "static\nvoid ChangeInterpolationToTrilinear(cmsPipeline* Lut)\n{\n    cmsStage* Stage;\n\n    for (Stage = cmsPipelineGetPtrToFirstStage(Lut);\n        Stage != NULL;\n        Stage = cmsStageNext(Stage)) {\n\n            if (cmsStageType(Stage) == cmsSigCLutElemType) {\n\n                _cmsStageCLutData* CLUT = (_cmsStageCLutData*) Stage ->Data;\n\n                CLUT ->Params->dwFlags |= CMS_LERP_FLAGS_TRILINEAR;\n                _cmsSetInterpolationRoutine(Lut->ContextID, CLUT ->Params);\n            }\n    }\n}",
          "fn_code_pos": [
            [
              516,
              0
            ],
            [
              533,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ChangeInterpolationToTrilinear",
            "parameters": {
              "Lut": "cmsPipeline"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsPipeline* _cmsReadFloatOutputTag(cmsHPROFILE hProfile, cmsTagSignature tagFloat)\n{\n    cmsContext ContextID       = cmsGetProfileContextID(hProfile);\n    cmsPipeline* Lut           = cmsPipelineDup((cmsPipeline*) cmsReadTag(hProfile, tagFloat));\n    cmsColorSpaceSignature PCS = cmsGetPCS(hProfile);\n    cmsColorSpaceSignature dataSpace = cmsGetColorSpace(hProfile);\n    \n    if (Lut == NULL) return NULL;\n    \n    // If PCS is Lab or XYZ, the floating point tag is accepting data in the space encoding,\n    // and since the formatter has already accommodated to 0..1.0, we should undo this change\n    if ( PCS == cmsSigLabData)\n    {\n        if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToLabFloat(ContextID)))\n            goto Error;\n    }\n    else\n        if (PCS == cmsSigXYZData)\n        {\n            if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToXyzFloat(ContextID)))\n                goto Error;\n        }\n    \n    // the output can be Lab or XYZ, in which case normalisation is needed on the end of the pipeline\n    if ( dataSpace == cmsSigLabData)\n    {\n        if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromLabFloat(ContextID)))\n            goto Error;\n    }\n    else if (dataSpace == cmsSigXYZData)\n    {\n        if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromXyzFloat(ContextID)))\n            goto Error;\n    }\n    \n    return Lut;\n\nError:\n    cmsPipelineFree(Lut);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              537,
              0
            ],
            [
              578,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadFloatOutputTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "tagFloat": "cmsTagSignature"
            },
            "return_type": "cmsPipeline"
          }
        },
        {
          "fn_code": "static\ncmsPipeline* _cmsReadFloatDevicelinkTag(cmsHPROFILE hProfile, cmsTagSignature tagFloat)\n{\n    cmsContext ContextID = cmsGetProfileContextID(hProfile);\n    cmsPipeline* Lut = cmsPipelineDup((cmsPipeline*)cmsReadTag(hProfile, tagFloat));\n    cmsColorSpaceSignature PCS = cmsGetPCS(hProfile);\n    cmsColorSpaceSignature spc = cmsGetColorSpace(hProfile);\n\n    if (Lut == NULL) return NULL;\n\n    if (spc == cmsSigLabData)\n    {\n        if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToLabFloat(ContextID)))\n            goto Error;\n    }\n    else\n        if (spc == cmsSigXYZData)\n        {\n            if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToXyzFloat(ContextID)))\n                goto Error;\n        }\n\n    if (PCS == cmsSigLabData)\n    {\n        if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromLabFloat(ContextID)))\n            goto Error;\n    }\n    else\n        if (PCS == cmsSigXYZData)\n        {\n            if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromXyzFloat(ContextID)))\n                goto Error;\n        }\n\n    return Lut;\nError:\n    cmsPipelineFree(Lut);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              662,
              0
            ],
            [
              700,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadFloatDevicelinkTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "tagFloat": "cmsTagSignature"
            },
            "return_type": "cmsPipeline"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT cmsIsMatrixShaper(cmsHPROFILE hProfile)\n{\n    switch (cmsGetColorSpace(hProfile)) {\n\n    case cmsSigGrayData:\n\n        return cmsIsTag(hProfile, cmsSigGrayTRCTag);\n\n    case cmsSigRgbData:\n\n        return (cmsIsTag(hProfile, cmsSigRedColorantTag) &&\n                cmsIsTag(hProfile, cmsSigGreenColorantTag) &&\n                cmsIsTag(hProfile, cmsSigBlueColorantTag) &&\n                cmsIsTag(hProfile, cmsSigRedTRCTag) &&\n                cmsIsTag(hProfile, cmsSigGreenTRCTag) &&\n                cmsIsTag(hProfile, cmsSigBlueTRCTag));\n\n    default:\n\n        return FALSE;\n    }\n}",
          "fn_code_pos": [
            [
              805,
              0
            ],
            [
              826,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIsMatrixShaper",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT cmsIsCLUT(cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number UsedDirection)\n{\n    const cmsTagSignature* TagTable;\n\n    // For devicelinks, the supported intent is that one stated in the header\n    if (cmsGetDeviceClass(hProfile) == cmsSigLinkClass) {\n            return (cmsGetHeaderRenderingIntent(hProfile) == Intent);\n    }\n\n    switch (UsedDirection) {\n\n       case LCMS_USED_AS_INPUT: TagTable = Device2PCS16; break;\n       case LCMS_USED_AS_OUTPUT:TagTable = PCS2Device16; break;\n\n       // For proofing, we need rel. colorimetric in output. Let's do some recursion\n       case LCMS_USED_AS_PROOF:\n           return cmsIsIntentSupported(hProfile, Intent, LCMS_USED_AS_INPUT) &&\n                  cmsIsIntentSupported(hProfile, INTENT_RELATIVE_COLORIMETRIC, LCMS_USED_AS_OUTPUT);\n\n       default:\n           cmsSignalError(cmsGetProfileContextID(hProfile), cmsERROR_RANGE, \"Unexpected direction (%d)\", UsedDirection);\n           return FALSE;\n    }\n\n    // Extended intents are not strictly CLUT-based\n    if (Intent > INTENT_ABSOLUTE_COLORIMETRIC)\n        return FALSE;\n\n    return cmsIsTag(hProfile, TagTable[Intent]);\n\n}",
          "fn_code_pos": [
            [
              829,
              0
            ],
            [
              859,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIsCLUT",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "UsedDirection": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT cmsIsIntentSupported(cmsHPROFILE hProfile,\n                                        cmsUInt32Number Intent, cmsUInt32Number UsedDirection)\n{\n\n    if (cmsIsCLUT(hProfile, Intent, UsedDirection)) return TRUE;\n\n    // Is there any matrix-shaper? If so, the intent is supported. This is a bit odd, since V2 matrix shaper\n    // does not fully support relative colorimetric because they cannot deal with non-zero black points, but\n    // many profiles claims that, and this is certainly not true for V4 profiles. Lets answer \"yes\" no matter\n    // the accuracy would be less than optimal in rel.col and v2 case.\n\n    return cmsIsMatrixShaper(hProfile);\n}",
          "fn_code_pos": [
            [
              863,
              0
            ],
            [
              875,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIsIntentSupported",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "UsedDirection": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsSEQ* _cmsReadProfileSequence(cmsHPROFILE hProfile)\n{\n    cmsSEQ* ProfileSeq;\n    cmsSEQ* ProfileId;\n    cmsSEQ* NewSeq;\n    cmsUInt32Number i;\n\n    // Take profile sequence description first\n    ProfileSeq = (cmsSEQ*) cmsReadTag(hProfile, cmsSigProfileSequenceDescTag);\n\n    // Take profile sequence ID\n    ProfileId  = (cmsSEQ*) cmsReadTag(hProfile, cmsSigProfileSequenceIdTag);\n\n    if (ProfileSeq == NULL && ProfileId == NULL) return NULL;\n\n    if (ProfileSeq == NULL) return cmsDupProfileSequenceDescription(ProfileId);\n    if (ProfileId  == NULL) return cmsDupProfileSequenceDescription(ProfileSeq);\n\n    // We have to mix both together. For that they must agree\n    if (ProfileSeq ->n != ProfileId ->n) return cmsDupProfileSequenceDescription(ProfileSeq);\n\n    NewSeq = cmsDupProfileSequenceDescription(ProfileSeq);\n\n    // Ok, proceed to the mixing\n    if (NewSeq != NULL) {\n        for (i=0; i < ProfileSeq ->n; i++) {\n\n            memmove(&NewSeq ->seq[i].ProfileID, &ProfileId ->seq[i].ProfileID, sizeof(cmsProfileID));\n            NewSeq ->seq[i].Description = cmsMLUdup(ProfileId ->seq[i].Description);\n        }\n    }\n    return NewSeq;\n}",
          "fn_code_pos": [
            [
              882,
              0
            ],
            [
              914,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadProfileSequence",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsSEQ"
          }
        },
        {
          "fn_code": "cmsBool _cmsWriteProfileSequence(cmsHPROFILE hProfile, const cmsSEQ* seq)\n{\n    if (!cmsWriteTag(hProfile, cmsSigProfileSequenceDescTag, seq)) return FALSE;\n\n    if (cmsGetEncodedICCversion(hProfile) >= 0x4000000) {\n\n            if (!cmsWriteTag(hProfile, cmsSigProfileSequenceIdTag, seq)) return FALSE;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              917,
              0
            ],
            [
              927,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteProfileSequence",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "seq": "cmsSEQ"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsMLU* GetMLUFromProfile(cmsHPROFILE h, cmsTagSignature sig)\n{\n    cmsMLU* mlu = (cmsMLU*) cmsReadTag(h, sig);\n    if (mlu == NULL) return NULL;\n\n    return cmsMLUdup(mlu);\n}",
          "fn_code_pos": [
            [
              931,
              0
            ],
            [
              938,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetMLUFromProfile",
            "parameters": {
              "h": "cmsHPROFILE",
              "sig": "cmsTagSignature"
            },
            "return_type": "cmsMLU"
          }
        },
        {
          "fn_code": "cmsSEQ* _cmsCompileProfileSequence(cmsContext ContextID, cmsUInt32Number nProfiles, cmsHPROFILE hProfiles[])\n{\n    cmsUInt32Number i;\n    cmsSEQ* seq = cmsAllocProfileSequenceDescription(ContextID, nProfiles);\n\n    if (seq == NULL) return NULL;\n\n    for (i=0; i < nProfiles; i++) {\n\n        cmsPSEQDESC* ps = &seq ->seq[i];\n        cmsHPROFILE h = hProfiles[i];\n        cmsTechnologySignature* techpt;\n\n        cmsGetHeaderAttributes(h, &ps ->attributes);\n        cmsGetHeaderProfileID(h, ps ->ProfileID.ID8);\n        ps ->deviceMfg   = cmsGetHeaderManufacturer(h);\n        ps ->deviceModel = cmsGetHeaderModel(h);\n\n        techpt = (cmsTechnologySignature*) cmsReadTag(h, cmsSigTechnologyTag);\n        if (techpt == NULL)\n            ps ->technology   =  (cmsTechnologySignature) 0;\n        else\n            ps ->technology   = *techpt;\n\n        ps ->Manufacturer = GetMLUFromProfile(h,  cmsSigDeviceMfgDescTag);\n        ps ->Model        = GetMLUFromProfile(h,  cmsSigDeviceModelDescTag);\n        ps ->Description  = GetMLUFromProfile(h, cmsSigProfileDescriptionTag);\n\n    }\n\n    return seq;\n}",
          "fn_code_pos": [
            [
              941,
              0
            ],
            [
              972,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsCompileProfileSequence",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE"
            },
            "return_type": "cmsSEQ"
          }
        },
        {
          "fn_code": "static\nconst cmsMLU* GetInfo(cmsHPROFILE hProfile, cmsInfoType Info)\n{\n    cmsTagSignature sig;\n\n    switch (Info) {\n\n    case cmsInfoDescription:\n        sig = cmsSigProfileDescriptionTag;\n        break;\n\n    case cmsInfoManufacturer:\n        sig = cmsSigDeviceMfgDescTag;\n        break;\n\n    case cmsInfoModel:\n        sig = cmsSigDeviceModelDescTag;\n         break;\n\n    case cmsInfoCopyright:\n        sig = cmsSigCopyrightTag;\n        break;\n\n    default: return NULL;\n    }\n\n\n    return (cmsMLU*) cmsReadTag(hProfile, sig);\n}",
          "fn_code_pos": [
            [
              977,
              0
            ],
            [
              1005,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetInfo",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Info": "cmsInfoType"
            },
            "return_type": "cmsMLU"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsGetProfileInfo(cmsHPROFILE hProfile, cmsInfoType Info,\n                                            const char LanguageCode[3], const char CountryCode[3],\n                                            wchar_t* Buffer, cmsUInt32Number BufferSize)\n{\n    const cmsMLU* mlu = GetInfo(hProfile, Info);\n    if (mlu == NULL) return 0;\n\n    return cmsMLUgetWide(mlu, LanguageCode, CountryCode, Buffer, BufferSize);\n}",
          "fn_code_pos": [
            [
              1009,
              0
            ],
            [
              1017,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetProfileInfo",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Info": "cmsInfoType",
              "LanguageCode": "char",
              "CountryCode": "char",
              "Buffer": "wchar_t",
              "BufferSize": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number  CMSEXPORT cmsGetProfileInfoASCII(cmsHPROFILE hProfile, cmsInfoType Info,\n                                                          const char LanguageCode[3], const char CountryCode[3],\n                                                          char* Buffer, cmsUInt32Number BufferSize)\n{\n    const cmsMLU* mlu = GetInfo(hProfile, Info);\n    if (mlu == NULL) return 0;\n\n    return cmsMLUgetASCII(mlu, LanguageCode, CountryCode, Buffer, BufferSize);\n}",
          "fn_code_pos": [
            [
              1020,
              0
            ],
            [
              1028,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetProfileInfoASCII",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Info": "cmsInfoType",
              "LanguageCode": "char",
              "CountryCode": "char",
              "Buffer": "char",
              "BufferSize": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number  CMSEXPORT cmsGetProfileInfoUTF8(cmsHPROFILE hProfile, cmsInfoType Info,\n                                                          const char LanguageCode[3], const char CountryCode[3],\n                                                          char* Buffer, cmsUInt32Number BufferSize)\n{\n    const cmsMLU* mlu = GetInfo(hProfile, Info);\n    if (mlu == NULL) return 0;\n\n    return cmsMLUgetUTF8(mlu, LanguageCode, CountryCode, Buffer, BufferSize);\n}",
          "fn_code_pos": [
            [
              1030,
              0
            ],
            [
              1038,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetProfileInfoUTF8",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Info": "cmsInfoType",
              "LanguageCode": "char",
              "CountryCode": "char",
              "Buffer": "char",
              "BufferSize": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "BuildGrayInputMatrixPipeline(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              155,
              13
            ],
            [
              155,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BuildGrayInputMatrixPipeline",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "BuildRGBInputMatrixShaper(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              209,
              13
            ],
            [
              209,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BuildRGBInputMatrixShaper",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsReadFloatInputTag(cmsHPROFILE hProfile, cmsTagSignature tagFloat)",
          "fn_dec_pos": [
            [
              264,
              13
            ],
            [
              264,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadFloatInputTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "tagFloat": "cmsTagSignature"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "BuildGrayOutputPipeline(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              410,
              13
            ],
            [
              410,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BuildGrayOutputPipeline",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "BuildRGBOutputMatrixShaper(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              452,
              13
            ],
            [
              452,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BuildRGBOutputMatrixShaper",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsReadFloatOutputTag(cmsHPROFILE hProfile, cmsTagSignature tagFloat)",
          "fn_dec_pos": [
            [
              538,
              13
            ],
            [
              538,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadFloatOutputTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "tagFloat": "cmsTagSignature"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsReadFloatDevicelinkTag(cmsHPROFILE hProfile, cmsTagSignature tagFloat)",
          "fn_dec_pos": [
            [
              663,
              13
            ],
            [
              663,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadFloatDevicelinkTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "tagFloat": "cmsTagSignature"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsReadProfileSequence(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              882,
              8
            ],
            [
              882,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadProfileSequence",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "GetMLUFromProfile(cmsHPROFILE h, cmsTagSignature sig)",
          "fn_dec_pos": [
            [
              932,
              8
            ],
            [
              932,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetMLUFromProfile",
            "parameters": {
              "h": "cmsHPROFILE",
              "sig": "cmsTagSignature"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsCompileProfileSequence(cmsContext ContextID, cmsUInt32Number nProfiles, cmsHPROFILE hProfiles[])",
          "fn_dec_pos": [
            [
              941,
              8
            ],
            [
              941,
              108
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsCompileProfileSequence",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "GetInfo(cmsHPROFILE hProfile, cmsInfoType Info)",
          "fn_dec_pos": [
            [
              978,
              14
            ],
            [
              978,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetInfo",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Info": "cmsInfoType"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmsmd5.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nvoid byteReverse(cmsUInt8Number * buf, cmsUInt32Number longs)\n{\n    do {\n\n        cmsUInt32Number t = _cmsAdjustEndianess32(*(cmsUInt32Number *) buf);\n        *(cmsUInt32Number *) buf = t;\n        buf += sizeof(cmsUInt32Number);\n\n    } while (--longs);\n\n}",
          "fn_code_pos": [
            [
              30,
              0
            ],
            [
              41,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "byteReverse",
            "parameters": {
              "buf": "cmsUInt8Number",
              "longs": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid cmsMD5_Transform(cmsUInt32Number buf[4], cmsUInt32Number in[16])\n{\n    CMSREGISTER cmsUInt32Number a, b, c, d;\n\n    a = buf[0];\n    b = buf[1];\n    c = buf[2];\n    d = buf[3];\n\n    STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);\n    STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);\n    STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);\n    STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);\n    STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);\n    STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);\n    STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);\n    STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);\n    STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);\n    STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);\n    STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);\n    STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);\n    STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);\n    STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);\n    STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);\n    STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);\n\n    STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);\n    STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);\n    STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);\n    STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);\n    STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);\n    STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);\n    STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);\n    STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);\n    STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);\n    STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);\n    STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);\n    STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);\n    STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);\n    STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);\n    STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);\n    STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);\n\n    STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);\n    STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);\n    STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);\n    STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);\n    STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);\n    STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);\n    STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);\n    STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);\n    STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);\n    STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);\n    STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);\n    STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);\n    STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);\n    STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);\n    STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);\n    STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);\n\n    STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);\n    STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);\n    STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);\n    STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);\n    STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);\n    STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);\n    STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);\n    STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);\n    STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);\n    STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);\n    STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);\n    STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);\n    STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);\n    STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);\n    STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);\n    STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);\n\n    buf[0] += a;\n    buf[1] += b;\n    buf[2] += c;\n    buf[3] += d;\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              148,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMD5_Transform",
            "parameters": {
              "buf": "cmsUInt32Number",
              "in": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsHANDLE CMSEXPORT cmsMD5alloc(cmsContext ContextID)\n{\n    _cmsMD5* ctx = (_cmsMD5*) _cmsMallocZero(ContextID, sizeof(_cmsMD5));\n    if (ctx == NULL) return NULL;\n\n    ctx ->ContextID = ContextID;\n\n    ctx->buf[0] = 0x67452301;\n    ctx->buf[1] = 0xefcdab89;\n    ctx->buf[2] = 0x98badcfe;\n    ctx->buf[3] = 0x10325476;\n\n    ctx->bits[0] = 0;\n    ctx->bits[1] = 0;\n\n    return (cmsHANDLE) ctx;\n}",
          "fn_code_pos": [
            [
              153,
              0
            ],
            [
              169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMD5alloc",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "cmsHANDLE"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsMD5add(cmsHANDLE Handle, const cmsUInt8Number* buf, cmsUInt32Number len)\n{\n    _cmsMD5* ctx = (_cmsMD5*) Handle;\n    cmsUInt32Number t;\n\n    t = ctx->bits[0];\n    if ((ctx->bits[0] = t + (len << 3)) < t)\n        ctx->bits[1]++;\n\n    ctx->bits[1] += len >> 29;\n\n    t = (t >> 3) & 0x3f;\n\n    if (t) {\n\n        cmsUInt8Number *p = (cmsUInt8Number *) ctx->in + t;\n\n        t = 64 - t;\n        if (len < t) {\n            memmove(p, buf, len);\n            return;\n        }\n\n        memmove(p, buf, t);\n        byteReverse(ctx->in, 16);\n\n        cmsMD5_Transform(ctx->buf, (cmsUInt32Number *) ctx->in);\n        buf += t;\n        len -= t;\n    }\n\n    while (len >= 64) {\n        memmove(ctx->in, buf, 64);\n        byteReverse(ctx->in, 16);\n        cmsMD5_Transform(ctx->buf, (cmsUInt32Number *) ctx->in);\n        buf += 64;\n        len -= 64;\n    }\n\n    memmove(ctx->in, buf, len);\n}",
          "fn_code_pos": [
            [
              171,
              0
            ],
            [
              211,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMD5add",
            "parameters": {
              "Handle": "cmsHANDLE",
              "buf": "cmsUInt8Number",
              "len": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsMD5finish(cmsProfileID* ProfileID,  cmsHANDLE Handle)\n{\n    _cmsMD5* ctx = (_cmsMD5*) Handle;\n    cmsUInt32Number count;\n    cmsUInt8Number *p;\n\n    count = (ctx->bits[0] >> 3) & 0x3F;\n\n    p = ctx->in + count;\n    *p++ = 0x80;\n\n    count = 64 - 1 - count;\n\n    if (count < 8) {\n\n        memset(p, 0, count);\n        byteReverse(ctx->in, 16);\n        cmsMD5_Transform(ctx->buf, (cmsUInt32Number *) ctx->in);\n\n        memset(ctx->in, 0, 56);\n    } else {\n        memset(p, 0, count - 8);\n    }\n    byteReverse(ctx->in, 14);\n\n    ((cmsUInt32Number *) ctx->in)[14] = ctx->bits[0];\n    ((cmsUInt32Number *) ctx->in)[15] = ctx->bits[1];\n\n    cmsMD5_Transform(ctx->buf, (cmsUInt32Number *) ctx->in);\n\n    byteReverse((cmsUInt8Number *) ctx->buf, 4);\n    memmove(ProfileID ->ID8, ctx->buf, 16);\n\n    _cmsFree(ctx ->ContextID, ctx);\n}",
          "fn_code_pos": [
            [
              214,
              0
            ],
            [
              248,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMD5finish",
            "parameters": {
              "ProfileID": "cmsProfileID",
              "Handle": "cmsHANDLE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsMD5computeID(cmsHPROFILE hProfile)\n{\n    cmsContext   ContextID;\n    cmsUInt32Number BytesNeeded;\n    cmsUInt8Number* Mem = NULL;\n    cmsHANDLE  MD5 = NULL;\n    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;\n    _cmsICCPROFILE Keep;\n\n    _cmsAssert(hProfile != NULL);\n\n    ContextID = cmsGetProfileContextID(hProfile);\n\n    // Save a copy of the profile header\n    memmove(&Keep, Icc, sizeof(_cmsICCPROFILE));\n\n    // Set RI, flags and ID\n    Icc ->flags = 0;\n    Icc ->RenderingIntent = 0;\n    memset(&Icc ->ProfileID, 0, sizeof(Icc ->ProfileID));\n\n    // Compute needed storage\n    if (!cmsSaveProfileToMem(hProfile, NULL, &BytesNeeded)) goto Error;\n\n    // Allocate memory\n    Mem = (cmsUInt8Number*) _cmsMalloc(ContextID, BytesNeeded);\n    if (Mem == NULL) goto Error;\n\n    // Save to temporary storage\n    if (!cmsSaveProfileToMem(hProfile, Mem, &BytesNeeded)) goto Error;\n\n    // Create MD5 object\n    MD5 = cmsMD5alloc(ContextID);\n    if (MD5 == NULL) goto Error;\n\n    // Add all bytes\n    cmsMD5add(MD5, Mem, BytesNeeded);\n\n    // Temp storage is no longer needed\n    _cmsFree(ContextID, Mem);\n\n    // Restore header\n    memmove(Icc, &Keep, sizeof(_cmsICCPROFILE));\n\n    // And store the ID\n    cmsMD5finish(&Icc ->ProfileID,  MD5);\n    return TRUE;\n\nError:\n\n    // Free resources as something went wrong\n    // \"MD5\" cannot be other than NULL here, so no need to free it\n    if (Mem != NULL) _cmsFree(ContextID, Mem);\n    memmove(Icc, &Keep, sizeof(_cmsICCPROFILE));\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              256,
              0
            ],
            [
              311,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMD5computeID",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\n    cmsUInt32Number buf[4];\n    cmsUInt32Number bits[2];\n    cmsUInt8Number in[64];\n    cmsContext ContextID;\n\n} _cmsMD5;",
          {
            "buf[4]": "cmsUInt32Number",
            "bits[2]": "cmsUInt32Number",
            "in[64]": "cmsUInt8Number",
            "ContextID": "cmsContext"
          },
          "_cmsMD5",
          [
            48,
            0
          ],
          [
            55,
            10
          ]
        ],
        [
          "typedef struct {\n\n    cmsUInt32Number buf[4];\n    cmsUInt32Number bits[2];\n    cmsUInt8Number in[64];\n    cmsContext ContextID;\n\n} _cmsMD5;",
          {
            "buf[4]": "cmsUInt32Number",
            "bits[2]": "cmsUInt32Number",
            "in[64]": "cmsUInt8Number",
            "ContextID": "cmsContext"
          },
          "_cmsMD5",
          [
            48,
            0
          ],
          [
            55,
            10
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmssamp.c": {
      "fn_def_list": [
        {
          "fn_code": "static\ncmsHTRANSFORM CreateRoundtripXForm(cmsHPROFILE hProfile, cmsUInt32Number nIntent)\n{\n    cmsContext ContextID = cmsGetProfileContextID(hProfile);\n    cmsHPROFILE hLab = cmsCreateLab4ProfileTHR(ContextID, NULL);\n    cmsHTRANSFORM xform;\n    cmsBool BPC[4] = { FALSE, FALSE, FALSE, FALSE };\n    cmsFloat64Number States[4] = { 1.0, 1.0, 1.0, 1.0 };\n    cmsHPROFILE hProfiles[4];\n    cmsUInt32Number Intents[4];\n\n    hProfiles[0] = hLab; hProfiles[1] = hProfile; hProfiles[2] = hProfile; hProfiles[3] = hLab;\n    Intents[0]   = INTENT_RELATIVE_COLORIMETRIC; Intents[1] = nIntent; Intents[2] = INTENT_RELATIVE_COLORIMETRIC; Intents[3] = INTENT_RELATIVE_COLORIMETRIC;\n\n    xform =  cmsCreateExtendedTransform(ContextID, 4, hProfiles, BPC, Intents,\n        States, NULL, 0, TYPE_Lab_DBL, TYPE_Lab_DBL, cmsFLAGS_NOCACHE|cmsFLAGS_NOOPTIMIZE);\n\n    cmsCloseProfile(hLab);\n    return xform;\n}",
          "fn_code_pos": [
            [
              39,
              0
            ],
            [
              58,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CreateRoundtripXForm",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "nIntent": "cmsUInt32Number"
            },
            "return_type": "cmsHTRANSFORM"
          }
        },
        {
          "fn_code": "static\ncmsBool  BlackPointAsDarkerColorant(cmsHPROFILE    hInput,\n                                    cmsUInt32Number Intent,\n                                    cmsCIEXYZ* BlackPoint,\n                                    cmsUInt32Number dwFlags)\n{\n    cmsUInt16Number *Black;\n    cmsHTRANSFORM xform;\n    cmsColorSpaceSignature Space;\n    cmsUInt32Number nChannels;\n    cmsUInt32Number dwFormat;\n    cmsHPROFILE hLab;\n    cmsCIELab  Lab;\n    cmsCIEXYZ  BlackXYZ;\n    cmsContext ContextID = cmsGetProfileContextID(hInput);\n\n    // If the profile does not support input direction, assume Black point 0\n    if (!cmsIsIntentSupported(hInput, Intent, LCMS_USED_AS_INPUT)) {\n\n        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;\n        return FALSE;\n    }\n\n    // Create a formatter which has n channels and no floating point\n    dwFormat = cmsFormatterForColorspaceOfProfile(hInput, 2, FALSE);\n\n    // Try to get black by using black colorant\n    Space = cmsGetColorSpace(hInput);\n\n    // This function returns darker colorant in 16 bits for several spaces\n    if (!_cmsEndPointsBySpace(Space, NULL, &Black, &nChannels)) {\n\n        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;\n        return FALSE;\n    }\n\n    if (nChannels != T_CHANNELS(dwFormat)) {\n       BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;\n       return FALSE;\n    }\n\n    // Lab will be used as the output space, but lab2 will avoid recursion\n    hLab = cmsCreateLab2ProfileTHR(ContextID, NULL);\n    if (hLab == NULL) {\n       BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;\n       return FALSE;\n    }\n\n    // Create the transform\n    xform = cmsCreateTransformTHR(ContextID, hInput, dwFormat,\n                                hLab, TYPE_Lab_DBL, Intent, cmsFLAGS_NOOPTIMIZE|cmsFLAGS_NOCACHE);\n    cmsCloseProfile(hLab);\n\n    if (xform == NULL) {\n\n        // Something went wrong. Get rid of open resources and return zero as black\n        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;\n        return FALSE;\n    }\n\n    // Convert black to Lab\n    cmsDoTransform(xform, Black, &Lab, 1);\n\n    // Force it to be neutral, check for inconsistencies\n    Lab.a = Lab.b = 0;\n    if (Lab.L > 50 || Lab.L < 0) Lab.L = 0;\n\n    // Free the resources\n    cmsDeleteTransform(xform);\n\n    // Convert from Lab (which is now clipped) to XYZ.\n    cmsLab2XYZ(NULL, &BlackXYZ, &Lab);\n\n    if (BlackPoint != NULL)\n        *BlackPoint = BlackXYZ;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(dwFlags);\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              141,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BlackPointAsDarkerColorant",
            "parameters": {
              "hInput": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "BlackPoint": "cmsCIEXYZ",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool BlackPointUsingPerceptualBlack(cmsCIEXYZ* BlackPoint, cmsHPROFILE hProfile)\n{\n    cmsHTRANSFORM hRoundTrip;\n    cmsCIELab LabIn, LabOut;\n    cmsCIEXYZ  BlackXYZ;\n\n     // Is the intent supported by the profile?\n    if (!cmsIsIntentSupported(hProfile, INTENT_PERCEPTUAL, LCMS_USED_AS_INPUT)) {\n\n        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;\n        return TRUE;\n    }\n\n    hRoundTrip = CreateRoundtripXForm(hProfile, INTENT_PERCEPTUAL);\n    if (hRoundTrip == NULL) {\n        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;\n        return FALSE;\n    }\n\n    LabIn.L = LabIn.a = LabIn.b = 0;\n    cmsDoTransform(hRoundTrip, &LabIn, &LabOut, 1);\n\n    // Clip Lab to reasonable limits\n    if (LabOut.L > 50) LabOut.L = 50;\n    LabOut.a = LabOut.b = 0;\n\n    cmsDeleteTransform(hRoundTrip);\n\n    // Convert it to XYZ\n    cmsLab2XYZ(NULL, &BlackXYZ, &LabOut);\n\n    if (BlackPoint != NULL)\n        *BlackPoint = BlackXYZ;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              146,
              0
            ],
            [
              182,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BlackPointUsingPerceptualBlack",
            "parameters": {
              "BlackPoint": "cmsCIEXYZ",
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsDetectBlackPoint(cmsCIEXYZ* BlackPoint, cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number dwFlags)\n{\n    cmsProfileClassSignature devClass;\n\n    // Make sure the device class is adequate\n    devClass = cmsGetDeviceClass(hProfile);\n    if (devClass == cmsSigLinkClass ||\n        devClass == cmsSigAbstractClass ||\n        devClass == cmsSigNamedColorClass) {\n            BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;\n            return FALSE;\n    }\n\n    // Make sure intent is adequate\n    if (Intent != INTENT_PERCEPTUAL &&\n        Intent != INTENT_RELATIVE_COLORIMETRIC &&\n        Intent != INTENT_SATURATION) {\n            BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;\n            return FALSE;\n    }\n\n    // v4 + perceptual & saturation intents does have its own black point, and it is\n    // well specified enough to use it. Black point tag is deprecated in V4.\n    if ((cmsGetEncodedICCversion(hProfile) >= 0x4000000) &&\n        (Intent == INTENT_PERCEPTUAL || Intent == INTENT_SATURATION)) {\n\n            // Matrix shaper share MRC & perceptual intents\n            if (cmsIsMatrixShaper(hProfile))\n                return BlackPointAsDarkerColorant(hProfile, INTENT_RELATIVE_COLORIMETRIC, BlackPoint, 0);\n\n            // Get Perceptual black out of v4 profiles. That is fixed for perceptual & saturation intents\n            BlackPoint -> X = cmsPERCEPTUAL_BLACK_X;\n            BlackPoint -> Y = cmsPERCEPTUAL_BLACK_Y;\n            BlackPoint -> Z = cmsPERCEPTUAL_BLACK_Z;\n\n            return TRUE;\n    }\n\n\n#ifdef CMS_USE_PROFILE_BLACK_POINT_TAG\n\n    // v2, v4 rel/abs colorimetric\n    if (cmsIsTag(hProfile, cmsSigMediaBlackPointTag) &&\n        Intent == INTENT_RELATIVE_COLORIMETRIC) {\n\n            cmsCIEXYZ *BlackPtr, BlackXYZ, UntrustedBlackPoint, TrustedBlackPoint, MediaWhite;\n            cmsCIELab Lab;\n\n            // If black point is specified, then use it,\n\n            BlackPtr = cmsReadTag(hProfile, cmsSigMediaBlackPointTag);\n            if (BlackPtr != NULL) {\n\n                BlackXYZ = *BlackPtr;\n                _cmsReadMediaWhitePoint(&MediaWhite, hProfile);\n\n                // Black point is absolute XYZ, so adapt to D50 to get PCS value\n                cmsAdaptToIlluminant(&UntrustedBlackPoint, &MediaWhite, cmsD50_XYZ(), &BlackXYZ);\n\n                // Force a=b=0 to get rid of any chroma\n                cmsXYZ2Lab(NULL, &Lab, &UntrustedBlackPoint);\n                Lab.a = Lab.b = 0;\n                if (Lab.L > 50) Lab.L = 50; // Clip to L* <= 50\n                cmsLab2XYZ(NULL, &TrustedBlackPoint, &Lab);\n\n                if (BlackPoint != NULL)\n                    *BlackPoint = TrustedBlackPoint;\n\n                return TRUE;\n            }\n    }\n#endif\n\n    // That is about v2 profiles.\n\n    // If output profile, discount ink-limiting and that's all\n    if (Intent == INTENT_RELATIVE_COLORIMETRIC &&\n        (cmsGetDeviceClass(hProfile) == cmsSigOutputClass) &&\n        (cmsGetColorSpace(hProfile)  == cmsSigCmykData))\n        return BlackPointUsingPerceptualBlack(BlackPoint, hProfile);\n\n    // Nope, compute BP using current intent.\n    return BlackPointAsDarkerColorant(hProfile, Intent, BlackPoint, dwFlags);\n}",
          "fn_code_pos": [
            [
              190,
              0
            ],
            [
              273,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDetectBlackPoint",
            "parameters": {
              "BlackPoint": "cmsCIEXYZ",
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number RootOfLeastSquaresFitQuadraticCurve(int n, cmsFloat64Number x[], cmsFloat64Number y[])\n{\n    double sum_x = 0, sum_x2 = 0, sum_x3 = 0, sum_x4 = 0;\n    double sum_y = 0, sum_yx = 0, sum_yx2 = 0;\n    double d, a, b, c;\n    int i;\n    cmsMAT3 m;\n    cmsVEC3 v, res;\n\n    if (n < 4) return 0;\n\n    for (i=0; i < n; i++) {\n\n        double xn = x[i];\n        double yn = y[i];\n\n        sum_x  += xn;\n        sum_x2 += xn*xn;\n        sum_x3 += xn*xn*xn;\n        sum_x4 += xn*xn*xn*xn;\n\n        sum_y += yn;\n        sum_yx += yn*xn;\n        sum_yx2 += yn*xn*xn;\n    }\n\n    _cmsVEC3init(&m.v[0], n,      sum_x,  sum_x2);\n    _cmsVEC3init(&m.v[1], sum_x,  sum_x2, sum_x3);\n    _cmsVEC3init(&m.v[2], sum_x2, sum_x3, sum_x4);\n\n    _cmsVEC3init(&v, sum_y, sum_yx, sum_yx2);\n\n    if (!_cmsMAT3solve(&res, &m, &v)) return 0;\n\n      \n    a = res.n[2];\n    b = res.n[1];\n    c = res.n[0];\n\n    if (fabs(a) < 1.0E-10) {\n    \n        if (fabs(b) < 1.0E-10) return 0;\n        return cmsmin(0, cmsmax(50, -c/b ));\n    }\n    else {\n\n         d = b*b - 4.0 * a * c;\n         if (d <= 0) {\n             return 0;\n         }\n         else {\n\n             double rt;\n             \n             if (fabs(a) < 1.0E-10) return 0;\n\n             rt = (-b + sqrt(d)) / (2.0 * a);\n\n             return cmsmax(0, cmsmin(50, rt));\n         }\n   }\n\n}",
          "fn_code_pos": [
            [
              282,
              0
            ],
            [
              345,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RootOfLeastSquaresFitQuadraticCurve",
            "parameters": {
              "n": "int",
              "x": "cmsFloat64Number",
              "y": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsDetectDestinationBlackPoint(cmsCIEXYZ* BlackPoint, cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number dwFlags)\n{\n    cmsColorSpaceSignature ColorSpace;\n    cmsHTRANSFORM hRoundTrip = NULL;\n    cmsCIELab InitialLab, destLab, Lab;\n    cmsFloat64Number inRamp[256], outRamp[256];\n    cmsFloat64Number MinL, MaxL;\n    cmsBool NearlyStraightMidrange = TRUE;  \n    cmsFloat64Number yRamp[256];\n    cmsFloat64Number x[256], y[256];\n    cmsFloat64Number lo, hi;\n    int n, l;\n    cmsProfileClassSignature devClass;\n\n    // Make sure the device class is adequate\n    devClass = cmsGetDeviceClass(hProfile);\n    if (devClass == cmsSigLinkClass ||\n        devClass == cmsSigAbstractClass ||\n        devClass == cmsSigNamedColorClass) {\n            BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;\n            return FALSE;\n    }\n\n    // Make sure intent is adequate\n    if (Intent != INTENT_PERCEPTUAL &&\n        Intent != INTENT_RELATIVE_COLORIMETRIC &&\n        Intent != INTENT_SATURATION) {\n            BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;\n            return FALSE;\n    }\n\n\n    // v4 + perceptual & saturation intents does have its own black point, and it is\n    // well specified enough to use it. Black point tag is deprecated in V4.\n    if ((cmsGetEncodedICCversion(hProfile) >= 0x4000000) &&\n        (Intent == INTENT_PERCEPTUAL || Intent == INTENT_SATURATION)) {\n\n            // Matrix shaper share MRC & perceptual intents\n            if (cmsIsMatrixShaper(hProfile))\n                return BlackPointAsDarkerColorant(hProfile, INTENT_RELATIVE_COLORIMETRIC, BlackPoint, 0);\n\n            // Get Perceptual black out of v4 profiles. That is fixed for perceptual & saturation intents\n            BlackPoint -> X = cmsPERCEPTUAL_BLACK_X;\n            BlackPoint -> Y = cmsPERCEPTUAL_BLACK_Y;\n            BlackPoint -> Z = cmsPERCEPTUAL_BLACK_Z;\n            return TRUE;\n    }\n\n\n    // Check if the profile is lut based and gray, rgb or cmyk (7.2 in Adobe's document)\n    ColorSpace = cmsGetColorSpace(hProfile);\n    if (!cmsIsCLUT(hProfile, Intent, LCMS_USED_AS_OUTPUT ) ||\n        (ColorSpace != cmsSigGrayData &&\n         ColorSpace != cmsSigRgbData  &&\n         ColorSpace != cmsSigCmykData)) {\n\n        // In this case, handle as input case\n        return cmsDetectBlackPoint(BlackPoint, hProfile, Intent, dwFlags);\n    }\n\n    // It is one of the valid cases!, use Adobe algorithm\n\n    \n    // Set a first guess, that should work on good profiles.\n    if (Intent == INTENT_RELATIVE_COLORIMETRIC) {\n\n        cmsCIEXYZ IniXYZ;\n\n        // calculate initial Lab as source black point\n        if (!cmsDetectBlackPoint(&IniXYZ, hProfile, Intent, dwFlags)) {\n            return FALSE;\n        }\n\n        // convert the XYZ to lab\n        cmsXYZ2Lab(NULL, &InitialLab, &IniXYZ);\n\n    } else {\n\n        // set the initial Lab to zero, that should be the black point for perceptual and saturation\n        InitialLab.L = 0;\n        InitialLab.a = 0;\n        InitialLab.b = 0;\n    }\n\n\n    // Step 2\n    // ======\n\n    // Create a roundtrip. Define a Transform BT for all x in L*a*b*\n    hRoundTrip = CreateRoundtripXForm(hProfile, Intent);\n    if (hRoundTrip == NULL)  return FALSE;\n\n    // Compute ramps\n\n    for (l=0; l < 256; l++) {\n\n        Lab.L = (cmsFloat64Number) (l * 100.0) / 255.0;\n        Lab.a = cmsmin(50, cmsmax(-50, InitialLab.a));\n        Lab.b = cmsmin(50, cmsmax(-50, InitialLab.b));\n\n        cmsDoTransform(hRoundTrip, &Lab, &destLab, 1);\n\n        inRamp[l]  = Lab.L;\n        outRamp[l] = destLab.L;\n    }\n\n    // Make monotonic\n    for (l = 254; l > 0; --l) {\n        outRamp[l] = cmsmin(outRamp[l], outRamp[l+1]);\n    }\n\n    // Check\n    if (! (outRamp[0] < outRamp[255])) {\n\n        cmsDeleteTransform(hRoundTrip);\n        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;\n        return FALSE;\n    }\n\n\n    // Test for mid range straight (only on relative colorimetric)\n    NearlyStraightMidrange = TRUE;\n    MinL = outRamp[0]; MaxL = outRamp[255];\n    if (Intent == INTENT_RELATIVE_COLORIMETRIC) {\n      \n        for (l=0; l < 256; l++) {\n\n            if (! ((inRamp[l] <= MinL + 0.2 * (MaxL - MinL) ) ||   \n                (fabs(inRamp[l] - outRamp[l]) < 4.0 )))\n                NearlyStraightMidrange = FALSE;\n        }\n\n        // If the mid range is straight (as determined above) then the \n        // DestinationBlackPoint shall be the same as initialLab. \n        // Otherwise, the DestinationBlackPoint shall be determined \n        // using curve fitting.\n        if (NearlyStraightMidrange) {\n\n            cmsLab2XYZ(NULL, BlackPoint, &InitialLab);\n            cmsDeleteTransform(hRoundTrip);\n            return TRUE;\n        }\n    }\n\n \n    // curve fitting: The round-trip curve normally looks like a nearly constant section at the black point,\n    // with a corner and a nearly straight line to the white point.  \n    for (l=0; l < 256; l++) {\n    \n        yRamp[l] = (outRamp[l] - MinL) / (MaxL - MinL);\n    }\n\n    // find the black point using the least squares error quadratic curve fitting\n    if (Intent == INTENT_RELATIVE_COLORIMETRIC) {\n        lo = 0.1;\n        hi = 0.5;\n    }\n    else {\n\n        // Perceptual and saturation\n        lo = 0.03;\n        hi = 0.25;\n    }\n\n    // Capture shadow points for the fitting.\n    n = 0;\n    for (l=0; l < 256; l++) {\n    \n        cmsFloat64Number ff = yRamp[l];\n\n        if (ff >= lo && ff < hi) {\n            x[n] = inRamp[l];\n            y[n] = yRamp[l];\n            n++;\n        }    \n    }\n\n    \n    // No suitable points\n    if (n < 3 ) {\n        cmsDeleteTransform(hRoundTrip);\n        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;\n        return FALSE;\n    }\n\n  \n    // fit and get the vertex of quadratic curve\n    Lab.L = RootOfLeastSquaresFitQuadraticCurve(n, x, y);\n\n    if (Lab.L < 0.0) { // clip to zero L* if the vertex is negative\n        Lab.L = 0;\n    }\n\n    Lab.a = InitialLab.a;\n    Lab.b = InitialLab.b;\n\n    cmsLab2XYZ(NULL, BlackPoint, &Lab);\n\n    cmsDeleteTransform(hRoundTrip);\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              351,
              0
            ],
            [
              551,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDetectDestinationBlackPoint",
            "parameters": {
              "BlackPoint": "cmsCIEXYZ",
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmsgamma.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nvoid DupPluginCurvesList(struct _cmsContext_struct* ctx, \n                                               const struct _cmsContext_struct* src)\n{\n   _cmsCurvesPluginChunkType newHead = { NULL };\n   _cmsParametricCurvesCollection*  entry;\n   _cmsParametricCurvesCollection*  Anterior = NULL;\n   _cmsCurvesPluginChunkType* head = (_cmsCurvesPluginChunkType*) src->chunks[CurvesPlugin];\n\n    _cmsAssert(head != NULL);\n\n    // Walk the list copying all nodes\n   for (entry = head->ParametricCurves;\n        entry != NULL;\n        entry = entry ->Next) {\n\n            _cmsParametricCurvesCollection *newEntry = ( _cmsParametricCurvesCollection *) _cmsSubAllocDup(ctx ->MemPool, entry, sizeof(_cmsParametricCurvesCollection));\n   \n            if (newEntry == NULL) \n                return;\n\n            // We want to keep the linked list order, so this is a little bit tricky\n            newEntry -> Next = NULL;\n            if (Anterior)\n                Anterior -> Next = newEntry;\n     \n            Anterior = newEntry;\n\n            if (newHead.ParametricCurves == NULL)\n                newHead.ParametricCurves = newEntry;\n    }\n\n  ctx ->chunks[CurvesPlugin] = _cmsSubAllocDup(ctx->MemPool, &newHead, sizeof(_cmsCurvesPluginChunkType));\n}",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              102,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DupPluginCurvesList",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void _cmsAllocCurvesPluginChunk(struct _cmsContext_struct* ctx, \n                                const struct _cmsContext_struct* src)\n{\n    _cmsAssert(ctx != NULL);\n\n    if (src != NULL) {\n\n        // Copy all linked list\n       DupPluginCurvesList(ctx, src);\n    }\n    else {\n        static _cmsCurvesPluginChunkType CurvesPluginChunk = { NULL };\n        ctx ->chunks[CurvesPlugin] = _cmsSubAllocDup(ctx ->MemPool, &CurvesPluginChunk, sizeof(_cmsCurvesPluginChunkType));\n    }\n}",
          "fn_code_pos": [
            [
              105,
              0
            ],
            [
              119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocCurvesPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool _cmsRegisterParametricCurvesPlugin(cmsContext ContextID, cmsPluginBase* Data)\n{\n    _cmsCurvesPluginChunkType* ctx = ( _cmsCurvesPluginChunkType*) _cmsContextGetClientChunk(ContextID, CurvesPlugin);\n    cmsPluginParametricCurves* Plugin = (cmsPluginParametricCurves*) Data;\n    _cmsParametricCurvesCollection* fl;\n\n    if (Data == NULL) {\n\n          ctx -> ParametricCurves =  NULL;\n          return TRUE;\n    }\n\n    fl = (_cmsParametricCurvesCollection*) _cmsPluginMalloc(ContextID, sizeof(_cmsParametricCurvesCollection));\n    if (fl == NULL) return FALSE;\n\n    // Copy the parameters\n    fl ->Evaluator  = Plugin ->Evaluator;\n    fl ->nFunctions = Plugin ->nFunctions;\n\n    // Make sure no mem overwrites\n    if (fl ->nFunctions > MAX_TYPES_IN_LCMS_PLUGIN)\n        fl ->nFunctions = MAX_TYPES_IN_LCMS_PLUGIN;\n\n    // Copy the data\n    memmove(fl->FunctionTypes,  Plugin ->FunctionTypes,   fl->nFunctions * sizeof(cmsUInt32Number));\n    memmove(fl->ParameterCount, Plugin ->ParameterCount,  fl->nFunctions * sizeof(cmsUInt32Number));\n\n    // Keep linked list\n    fl ->Next = ctx->ParametricCurves;\n    ctx->ParametricCurves = fl;\n\n    // All is ok\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              126,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterParametricCurvesPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Data": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nint IsInSet(int Type, _cmsParametricCurvesCollection* c)\n{\n    int i;\n\n    for (i=0; i < (int) c ->nFunctions; i++)\n        if (abs(Type) == c ->FunctionTypes[i]) return i;\n\n    return -1;\n}",
          "fn_code_pos": [
            [
              163,
              0
            ],
            [
              172,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsInSet",
            "parameters": {
              "Type": "int",
              "c": "_cmsParametricCurvesCollection"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\n_cmsParametricCurvesCollection *GetParametricCurveByType(cmsContext ContextID, int Type, int* index)\n{\n    _cmsParametricCurvesCollection* c;\n    int Position;\n    _cmsCurvesPluginChunkType* ctx = ( _cmsCurvesPluginChunkType*) _cmsContextGetClientChunk(ContextID, CurvesPlugin);\n\n    for (c = ctx->ParametricCurves; c != NULL; c = c ->Next) {\n\n        Position = IsInSet(Type, c);\n\n        if (Position != -1) {\n            if (index != NULL)\n                *index = Position;\n            return c;\n        }\n    }\n    // If none found, revert for defaults\n    for (c = &DefaultCurves; c != NULL; c = c ->Next) {\n\n        Position = IsInSet(Type, c);\n\n        if (Position != -1) {\n            if (index != NULL)\n                *index = Position;\n            return c;\n        }\n    }\n\n    return NULL;\n}",
          "fn_code_pos": [
            [
              176,
              0
            ],
            [
              206,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetParametricCurveByType",
            "parameters": {
              "ContextID": "cmsContext",
              "Type": "int",
              "index": "int"
            },
            "return_type": "_cmsParametricCurvesCollection"
          }
        },
        {
          "fn_code": "static\ncmsToneCurve* AllocateToneCurveStruct(cmsContext ContextID, cmsUInt32Number nEntries,\n                                      cmsUInt32Number nSegments, const cmsCurveSegment* Segments,\n                                      const cmsUInt16Number* Values)\n{\n    cmsToneCurve* p;\n    cmsUInt32Number i;\n\n    // We allow huge tables, which are then restricted for smoothing operations\n    if (nEntries > 65530) {\n        cmsSignalError(ContextID, cmsERROR_RANGE, \"Couldn't create tone curve of more than 65530 entries\");\n        return NULL;\n    }\n\n    if (nEntries == 0 && nSegments == 0) {\n        cmsSignalError(ContextID, cmsERROR_RANGE, \"Couldn't create tone curve with zero segments and no table\");\n        return NULL;\n    }\n\n    // Allocate all required pointers, etc.\n    p = (cmsToneCurve*) _cmsMallocZero(ContextID, sizeof(cmsToneCurve));\n    if (!p) return NULL;\n\n    // In this case, there are no segments\n    if (nSegments == 0) {\n        p ->Segments = NULL;\n        p ->Evals = NULL;\n    }\n    else {\n        p ->Segments = (cmsCurveSegment*) _cmsCalloc(ContextID, nSegments, sizeof(cmsCurveSegment));\n        if (p ->Segments == NULL) goto Error;\n\n        p ->Evals    = (cmsParametricCurveEvaluator*) _cmsCalloc(ContextID, nSegments, sizeof(cmsParametricCurveEvaluator));\n        if (p ->Evals == NULL) goto Error;\n    }\n\n    p -> nSegments = nSegments;\n\n    // This 16-bit table contains a limited precision representation of the whole curve and is kept for\n    // increasing xput on certain operations.\n    if (nEntries == 0) {\n        p ->Table16 = NULL;\n    }\n    else {\n       p ->Table16 = (cmsUInt16Number*)  _cmsCalloc(ContextID, nEntries, sizeof(cmsUInt16Number));\n       if (p ->Table16 == NULL) goto Error;\n    }\n\n    p -> nEntries  = nEntries;\n\n    // Initialize members if requested\n    if (Values != NULL && (nEntries > 0)) {\n\n        for (i=0; i < nEntries; i++)\n            p ->Table16[i] = Values[i];\n    }\n\n    // Initialize the segments stuff. The evaluator for each segment is located and a pointer to it\n    // is placed in advance to maximize performance.\n    if (Segments != NULL && (nSegments > 0)) {\n\n        _cmsParametricCurvesCollection *c;\n\n        p ->SegInterp = (cmsInterpParams**) _cmsCalloc(ContextID, nSegments, sizeof(cmsInterpParams*));\n        if (p ->SegInterp == NULL) goto Error;\n\n        for (i=0; i < nSegments; i++) {\n\n            // Type 0 is a special marker for table-based curves\n            if (Segments[i].Type == 0)\n                p ->SegInterp[i] = _cmsComputeInterpParams(ContextID, Segments[i].nGridPoints, 1, 1, NULL, CMS_LERP_FLAGS_FLOAT);\n\n            memmove(&p ->Segments[i], &Segments[i], sizeof(cmsCurveSegment));\n\n            if (Segments[i].Type == 0 && Segments[i].SampledPoints != NULL)\n                p ->Segments[i].SampledPoints = (cmsFloat32Number*) _cmsDupMem(ContextID, Segments[i].SampledPoints, sizeof(cmsFloat32Number) * Segments[i].nGridPoints);\n            else\n                p ->Segments[i].SampledPoints = NULL;\n\n\n            c = GetParametricCurveByType(ContextID, Segments[i].Type, NULL);\n            if (c != NULL)\n                    p ->Evals[i] = c ->Evaluator;\n        }\n    }\n\n    p ->InterpParams = _cmsComputeInterpParams(ContextID, p ->nEntries, 1, 1, p->Table16, CMS_LERP_FLAGS_16BITS);\n    if (p->InterpParams != NULL)\n        return p;\n\nError:\n    for (i=0; i < nSegments; i++) {\n        if (p ->Segments && p ->Segments[i].SampledPoints) _cmsFree(ContextID, p ->Segments[i].SampledPoints);\n        if (p ->SegInterp && p ->SegInterp[i]) _cmsFree(ContextID, p ->SegInterp[i]);\n    }\n    if (p -> SegInterp) _cmsFree(ContextID, p -> SegInterp);\n    if (p -> Segments) _cmsFree(ContextID, p -> Segments);\n    if (p -> Evals) _cmsFree(ContextID, p -> Evals);\n    if (p ->Table16) _cmsFree(ContextID, p ->Table16);\n    _cmsFree(ContextID, p);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              211,
              0
            ],
            [
              312,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllocateToneCurveStruct",
            "parameters": {
              "ContextID": "cmsContext",
              "nEntries": "cmsUInt32Number",
              "nSegments": "cmsUInt32Number",
              "Segments": "cmsCurveSegment",
              "Values": "cmsUInt16Number"
            },
            "return_type": "cmsToneCurve"
          }
        },
        {
          "fn_code": "cmsINLINE double sigmoid_base(double k, double t)\n{\n    return (1.0 / (1.0 + exp(-k * t))) - 0.5;\n}",
          "fn_code_pos": [
            [
              316,
              0
            ],
            [
              319,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sigmoid_base",
            "parameters": {
              "k": "double",
              "t": "double"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE double inverted_sigmoid_base(double k, double t)\n{\n    return -log((1.0 / (t + 0.5)) - 1.0) / k;\n}",
          "fn_code_pos": [
            [
              321,
              0
            ],
            [
              324,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inverted_sigmoid_base",
            "parameters": {
              "k": "double",
              "t": "double"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE double sigmoid_factory(double k, double t)\n{\n    double correction = 0.5 / sigmoid_base(k, 1);\n\n    return correction * sigmoid_base(k, 2.0 * t - 1.0) + 0.5;\n}",
          "fn_code_pos": [
            [
              326,
              0
            ],
            [
              331,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sigmoid_factory",
            "parameters": {
              "k": "double",
              "t": "double"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE double inverse_sigmoid_factory(double k, double t)\n{\n    double correction = 0.5 / sigmoid_base(k, 1);\n\n    return (inverted_sigmoid_base(k, (t - 0.5) / correction) + 1.0) / 2.0;\n}",
          "fn_code_pos": [
            [
              333,
              0
            ],
            [
              338,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inverse_sigmoid_factory",
            "parameters": {
              "k": "double",
              "t": "double"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number DefaultEvalParametricFn(cmsInt32Number Type, const cmsFloat64Number Params[], cmsFloat64Number R)\n{\n    cmsFloat64Number e, Val, disc;\n\n    switch (Type) {\n\n   // X = Y ^ Gamma\n    case 1:\n        if (R < 0) {\n\n            if (fabs(Params[0] - 1.0) < MATRIX_DET_TOLERANCE)\n                Val = R;\n            else\n                Val = 0;\n        }\n        else\n            Val = pow(R, Params[0]);\n        break;\n\n    // Type 1 Reversed: X = Y ^1/gamma\n    case -1:\n        if (R < 0) {\n\n            if (fabs(Params[0] - 1.0) < MATRIX_DET_TOLERANCE)\n                Val = R;\n            else\n                Val = 0;\n        }\n        else\n        {\n            if (fabs(Params[0]) < MATRIX_DET_TOLERANCE)\n                Val = PLUS_INF;\n            else\n                Val = pow(R, 1 / Params[0]);\n        }\n        break;\n\n    // CIE 122-1966\n    // Y = (aX + b)^Gamma  | X >= -b/a\n    // Y = 0               | else\n    case 2:\n    {\n\n        if (fabs(Params[1]) < MATRIX_DET_TOLERANCE)\n        {\n            Val = 0;\n        }\n        else\n        {\n            disc = -Params[2] / Params[1];\n\n            if (R >= disc) {\n\n                e = Params[1] * R + Params[2];\n\n                if (e > 0)\n                    Val = pow(e, Params[0]);\n                else\n                    Val = 0;\n            }\n            else\n                Val = 0;\n        }\n    }\n    break;\n\n     // Type 2 Reversed\n     // X = (Y ^1/g  - b) / a\n     case -2:\n     {\n         if (fabs(Params[0]) < MATRIX_DET_TOLERANCE ||\n             fabs(Params[1]) < MATRIX_DET_TOLERANCE)\n         {\n             Val = 0;\n         }\n         else\n         {\n             if (R < 0)\n                 Val = 0;\n             else\n                 Val = (pow(R, 1.0 / Params[0]) - Params[2]) / Params[1];\n\n             if (Val < 0)\n                 Val = 0;\n         }\n     }         \n     break;\n\n\n    // IEC 61966-3\n    // Y = (aX + b)^Gamma + c | X <= -b/a\n    // Y = c                  | else\n    case 3:\n    {\n        if (fabs(Params[1]) < MATRIX_DET_TOLERANCE)\n        {\n            Val = 0;\n        }\n        else\n        {\n            disc = -Params[2] / Params[1];\n            if (disc < 0)\n                disc = 0;\n\n            if (R >= disc) {\n\n                e = Params[1] * R + Params[2];\n\n                if (e > 0)\n                    Val = pow(e, Params[0]) + Params[3];\n                else\n                    Val = 0;\n            }\n            else\n                Val = Params[3];\n        }\n    }\n    break;\n\n\n    // Type 3 reversed\n    // X=((Y-c)^1/g - b)/a      | (Y>=c)\n    // X=-b/a                   | (Y<c)\n    case -3:\n    {\n        if (fabs(Params[0]) < MATRIX_DET_TOLERANCE ||\n            fabs(Params[1]) < MATRIX_DET_TOLERANCE)\n        {\n            Val = 0;\n        }\n        else\n        {\n            if (R >= Params[3]) {\n\n                e = R - Params[3];\n\n                if (e > 0)\n                    Val = (pow(e, 1 / Params[0]) - Params[2]) / Params[1];\n                else\n                    Val = 0;\n            }\n            else {\n                Val = -Params[2] / Params[1];\n            }\n        }\n    }\n    break;\n\n\n    // IEC 61966-2.1 (sRGB)\n    // Y = (aX + b)^Gamma | X >= d\n    // Y = cX             | X < d\n    case 4:\n        if (R >= Params[4]) {\n\n            e = Params[1]*R + Params[2];\n\n            if (e > 0)\n                Val = pow(e, Params[0]);\n            else\n                Val = 0;\n        }\n        else\n            Val = R * Params[3];\n        break;\n\n    // Type 4 reversed\n    // X=((Y^1/g-b)/a)    | Y >= (ad+b)^g\n    // X=Y/c              | Y< (ad+b)^g\n    case -4:\n    {\n\n        e = Params[1] * Params[4] + Params[2];\n        if (e < 0)\n            disc = 0;\n        else\n            disc = pow(e, Params[0]);\n\n        if (R >= disc) {\n\n            if (fabs(Params[0]) < MATRIX_DET_TOLERANCE ||\n                fabs(Params[1]) < MATRIX_DET_TOLERANCE)\n\n                Val = 0;\n\n            else\n                Val = (pow(R, 1.0 / Params[0]) - Params[2]) / Params[1];\n        }\n        else {\n\n            if (fabs(Params[3]) < MATRIX_DET_TOLERANCE)\n                Val = 0;\n            else\n                Val = R / Params[3];\n        }\n\n    }\n    break;\n\n\n    // Y = (aX + b)^Gamma + e | X >= d\n    // Y = cX + f             | X < d\n    case 5:\n        if (R >= Params[4]) {\n\n            e = Params[1]*R + Params[2];\n\n            if (e > 0)\n                Val = pow(e, Params[0]) + Params[5];\n            else\n                Val = Params[5];\n        }\n        else\n            Val = R*Params[3] + Params[6];\n        break;\n\n\n    // Reversed type 5\n    // X=((Y-e)1/g-b)/a   | Y >=(ad+b)^g+e), cd+f\n    // X=(Y-f)/c          | else\n    case -5:\n    {\n        disc = Params[3] * Params[4] + Params[6];\n        if (R >= disc) {\n\n            e = R - Params[5];\n            if (e < 0)\n                Val = 0;\n            else\n            {\n                if (fabs(Params[0]) < MATRIX_DET_TOLERANCE ||\n                    fabs(Params[1]) < MATRIX_DET_TOLERANCE)\n\n                    Val = 0;\n                else\n                    Val = (pow(e, 1.0 / Params[0]) - Params[2]) / Params[1];\n            }\n        }\n        else {\n            if (fabs(Params[3]) < MATRIX_DET_TOLERANCE)\n                Val = 0;\n            else\n                Val = (R - Params[6]) / Params[3];\n        }\n\n    }\n    break;\n\n\n    // Types 6,7,8 comes from segmented curves as described in ICCSpecRevision_02_11_06_Float.pdf\n    // Type 6 is basically identical to type 5 without d\n\n    // Y = (a * X + b) ^ Gamma + c\n    case 6:\n        e = Params[1]*R + Params[2];\n\n        // On gamma 1.0, don't clamp\n        if (Params[0] == 1.0) {\n            Val = e + Params[3];\n        }\n        else {\n            if (e < 0)\n                Val = Params[3];\n            else\n                Val = pow(e, Params[0]) + Params[3];\n        }\n        break;\n\n    // ((Y - c) ^1/Gamma - b) / a\n    case -6:\n    {\n        if (fabs(Params[0]) < MATRIX_DET_TOLERANCE ||\n            fabs(Params[1]) < MATRIX_DET_TOLERANCE)\n        {\n            Val = 0;\n        }\n        else\n        {\n            e = R - Params[3];\n            if (e < 0)\n                Val = 0;\n            else\n                Val = (pow(e, 1.0 / Params[0]) - Params[2]) / Params[1];\n        }\n    }\n    break;\n\n\n    // Y = a * log (b * X^Gamma + c) + d\n    case 7:\n\n       e = Params[2] * pow(R, Params[0]) + Params[3];\n       if (e <= 0)\n           Val = Params[4];\n       else\n           Val = Params[1]*log10(e) + Params[4];\n       break;\n\n    // (Y - d) / a = log(b * X ^Gamma + c)\n    // pow(10, (Y-d) / a) = b * X ^Gamma + c\n    // pow((pow(10, (Y-d) / a) - c) / b, 1/g) = X\n    case -7:\n    {\n        if (fabs(Params[0]) < MATRIX_DET_TOLERANCE ||\n            fabs(Params[1]) < MATRIX_DET_TOLERANCE ||\n            fabs(Params[2]) < MATRIX_DET_TOLERANCE)\n        {\n            Val = 0;\n        }\n        else\n        {\n            Val = pow((pow(10.0, (R - Params[4]) / Params[1]) - Params[3]) / Params[2], 1.0 / Params[0]);\n        }\n    }\n    break;\n\n\n   //Y = a * b^(c*X+d) + e\n   case 8:\n       Val = (Params[0] * pow(Params[1], Params[2] * R + Params[3]) + Params[4]);\n       break;\n\n\n   // Y = (log((y-e) / a) / log(b) - d ) / c\n   // a=0, b=1, c=2, d=3, e=4,\n   case -8:\n\n       disc = R - Params[4];\n       if (disc < 0) Val = 0;\n       else\n       {\n           if (fabs(Params[0]) < MATRIX_DET_TOLERANCE ||\n               fabs(Params[2]) < MATRIX_DET_TOLERANCE)\n           {\n               Val = 0;\n           }\n           else\n           {\n               Val = (log(disc / Params[0]) / log(Params[1]) - Params[3]) / Params[2];\n           }\n       }\n       break;\n\n\n   // S-Shaped: (1 - (1-x)^1/g)^1/g\n   case 108:\n       if (fabs(Params[0]) < MATRIX_DET_TOLERANCE)\n           Val = 0;\n       else\n           Val = pow(1.0 - pow(1 - R, 1/Params[0]), 1/Params[0]);\n      break;\n\n    // y = (1 - (1-x)^1/g)^1/g\n    // y^g = (1 - (1-x)^1/g)\n    // 1 - y^g = (1-x)^1/g\n    // (1 - y^g)^g = 1 - x\n    // 1 - (1 - y^g)^g\n    case -108:\n        Val = 1 - pow(1 - pow(R, Params[0]), Params[0]);\n        break;\n\n    // Sigmoidals\n    case 109:\n        Val = sigmoid_factory(Params[0], R);\n        break;\n\n    case -109:\n        Val = inverse_sigmoid_factory(Params[0], R);\n        break;\n\n    default:\n        // Unsupported parametric curve. Should never reach here\n        return 0;\n    }\n\n    return Val;\n}",
          "fn_code_pos": [
            [
              342,
              0
            ],
            [
              719,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DefaultEvalParametricFn",
            "parameters": {
              "Type": "cmsInt32Number",
              "Params": "cmsFloat64Number",
              "R": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number EvalSegmentedFn(const cmsToneCurve *g, cmsFloat64Number R)\n{\n    int i;\n    cmsFloat32Number Out32;\n    cmsFloat64Number Out;\n\n    for (i = (int) g->nSegments - 1; i >= 0; --i) {\n\n        // Check for domain\n        if ((R > g->Segments[i].x0) && (R <= g->Segments[i].x1)) {\n\n            // Type == 0 means segment is sampled\n            if (g->Segments[i].Type == 0) {\n\n                cmsFloat32Number R1 = (cmsFloat32Number)(R - g->Segments[i].x0) / (g->Segments[i].x1 - g->Segments[i].x0);\n\n                // Setup the table (TODO: clean that)\n                g->SegInterp[i]->Table = g->Segments[i].SampledPoints;\n\n                g->SegInterp[i]->Interpolation.LerpFloat(&R1, &Out32, g->SegInterp[i]);\n                Out = (cmsFloat64Number) Out32;\n\n            }\n            else {\n                Out = g->Evals[i](g->Segments[i].Type, g->Segments[i].Params, R);\n            }\n\n            if (isinf(Out))\n                return PLUS_INF;\n            else\n            {\n                if (isinf(-Out))\n                    return MINUS_INF;\n            }\n\n            return Out;\n        }\n    }\n\n    return MINUS_INF;\n}",
          "fn_code_pos": [
            [
              723,
              0
            ],
            [
              764,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EvalSegmentedFn",
            "parameters": {
              "g": "cmsToneCurve",
              "R": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsGetToneCurveEstimatedTableEntries(const cmsToneCurve* t)\n{\n    _cmsAssert(t != NULL);\n    return t ->nEntries;\n}",
          "fn_code_pos": [
            [
              767,
              0
            ],
            [
              771,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetToneCurveEstimatedTableEntries",
            "parameters": {
              "t": "cmsToneCurve"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "const cmsUInt16Number* CMSEXPORT cmsGetToneCurveEstimatedTable(const cmsToneCurve* t)\n{\n    _cmsAssert(t != NULL);\n    return t ->Table16;\n}",
          "fn_code_pos": [
            [
              773,
              0
            ],
            [
              777,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetToneCurveEstimatedTable",
            "parameters": {
              "t": "cmsToneCurve"
            },
            "return_type": "cmsUInt16Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number EntriesByGamma(cmsFloat64Number Gamma)\n{\n    if (fabs(Gamma - 1.0) < 0.001) return 2;\n    return 4096;\n}",
          "fn_code_pos": [
            [
              787,
              0
            ],
            [
              792,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EntriesByGamma",
            "parameters": {
              "Gamma": "cmsFloat64Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsFreeToneCurve(cmsToneCurve* Curve)\n{\n    cmsContext ContextID;\n\n    if (Curve == NULL) return;\n\n    ContextID = Curve ->InterpParams->ContextID;\n\n    _cmsFreeInterpParams(Curve ->InterpParams);\n\n    if (Curve -> Table16)\n        _cmsFree(ContextID, Curve ->Table16);\n\n    if (Curve ->Segments) {\n\n        cmsUInt32Number i;\n\n        for (i=0; i < Curve ->nSegments; i++) {\n\n            if (Curve ->Segments[i].SampledPoints) {\n                _cmsFree(ContextID, Curve ->Segments[i].SampledPoints);\n            }\n\n            if (Curve ->SegInterp[i] != 0)\n                _cmsFreeInterpParams(Curve->SegInterp[i]);\n        }\n\n        _cmsFree(ContextID, Curve ->Segments);\n        _cmsFree(ContextID, Curve ->SegInterp);\n    }\n\n    if (Curve -> Evals)\n        _cmsFree(ContextID, Curve -> Evals);\n\n    _cmsFree(ContextID, Curve);\n}",
          "fn_code_pos": [
            [
              915,
              0
            ],
            [
              950,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFreeToneCurve",
            "parameters": {
              "Curve": "cmsToneCurve"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsFreeToneCurveTriple(cmsToneCurve* Curve[3])\n{\n\n    _cmsAssert(Curve != NULL);\n\n    if (Curve[0] != NULL) cmsFreeToneCurve(Curve[0]);\n    if (Curve[1] != NULL) cmsFreeToneCurve(Curve[1]);\n    if (Curve[2] != NULL) cmsFreeToneCurve(Curve[2]);\n\n    Curve[0] = Curve[1] = Curve[2] = NULL;\n}",
          "fn_code_pos": [
            [
              953,
              0
            ],
            [
              963,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFreeToneCurveTriple",
            "parameters": {
              "Curve": "cmsToneCurve"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nint GetInterval(cmsFloat64Number In, const cmsUInt16Number LutTable[], const struct _cms_interp_struc* p)\n{\n    int i;\n    int y0, y1;\n\n    // A 1 point table is not allowed\n    if (p -> Domain[0] < 1) return -1;\n\n    // Let's see if ascending or descending.\n    if (LutTable[0] < LutTable[p ->Domain[0]]) {\n\n        // Table is overall ascending\n        for (i = (int) p->Domain[0] - 1; i >= 0; --i) {\n\n            y0 = LutTable[i];\n            y1 = LutTable[i+1];\n\n            if (y0 <= y1) { // Increasing\n                if (In >= y0 && In <= y1) return i;\n            }\n            else\n                if (y1 < y0) { // Decreasing\n                    if (In >= y1 && In <= y0) return i;\n                }\n        }\n    }\n    else {\n        // Table is overall descending\n        for (i=0; i < (int) p -> Domain[0]; i++) {\n\n            y0 = LutTable[i];\n            y1 = LutTable[i+1];\n\n            if (y0 <= y1) { // Increasing\n                if (In >= y0 && In <= y1) return i;\n            }\n            else\n                if (y1 < y0) { // Decreasing\n                    if (In >= y1 && In <= y0) return i;\n                }\n        }\n    }\n\n    return -1;\n}",
          "fn_code_pos": [
            [
              1021,
              0
            ],
            [
              1066,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetInterval",
            "parameters": {
              "In": "cmsFloat64Number",
              "LutTable": "cmsUInt16Number",
              "p": "struct _cms_interp_struc"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\ncmsBool smooth2(cmsContext ContextID, cmsFloat32Number w[], cmsFloat32Number y[], \n                cmsFloat32Number z[], cmsFloat32Number lambda, int m)\n{\n    int i, i1, i2;\n    cmsFloat32Number *c, *d, *e;\n    cmsBool st;\n\n\n    c = (cmsFloat32Number*) _cmsCalloc(ContextID, MAX_NODES_IN_CURVE, sizeof(cmsFloat32Number));\n    d = (cmsFloat32Number*) _cmsCalloc(ContextID, MAX_NODES_IN_CURVE, sizeof(cmsFloat32Number));\n    e = (cmsFloat32Number*) _cmsCalloc(ContextID, MAX_NODES_IN_CURVE, sizeof(cmsFloat32Number));\n\n    if (c != NULL && d != NULL && e != NULL) {\n\n\n    d[1] = w[1] + lambda;\n    c[1] = -2 * lambda / d[1];\n    e[1] = lambda /d[1];\n    z[1] = w[1] * y[1];\n    d[2] = w[2] + 5 * lambda - d[1] * c[1] *  c[1];\n    c[2] = (-4 * lambda - d[1] * c[1] * e[1]) / d[2];\n    e[2] = lambda / d[2];\n    z[2] = w[2] * y[2] - c[1] * z[1];\n\n    for (i = 3; i < m - 1; i++) {\n        i1 = i - 1; i2 = i - 2;\n        d[i]= w[i] + 6 * lambda - c[i1] * c[i1] * d[i1] - e[i2] * e[i2] * d[i2];\n        c[i] = (-4 * lambda -d[i1] * c[i1] * e[i1])/ d[i];\n        e[i] = lambda / d[i];\n        z[i] = w[i] * y[i] - c[i1] * z[i1] - e[i2] * z[i2];\n    }\n\n    i1 = m - 2; i2 = m - 3;\n\n    d[m - 1] = w[m - 1] + 5 * lambda -c[i1] * c[i1] * d[i1] - e[i2] * e[i2] * d[i2];\n    c[m - 1] = (-2 * lambda - d[i1] * c[i1] * e[i1]) / d[m - 1];\n    z[m - 1] = w[m - 1] * y[m - 1] - c[i1] * z[i1] - e[i2] * z[i2];\n    i1 = m - 1; i2 = m - 2;\n\n    d[m] = w[m] + lambda - c[i1] * c[i1] * d[i1] - e[i2] * e[i2] * d[i2];\n    z[m] = (w[m] * y[m] - c[i1] * z[i1] - e[i2] * z[i2]) / d[m];\n    z[m - 1] = z[m - 1] / d[m - 1] - c[m - 1] * z[m];\n\n    for (i = m - 2; 1<= i; i--)\n        z[i] = z[i] / d[i] - c[i] * z[i + 1] - e[i] * z[i + 2];\n\n      st = TRUE;\n    }\n    else st = FALSE;\n\n    if (c != NULL) _cmsFree(ContextID, c);\n    if (d != NULL) _cmsFree(ContextID, d);\n    if (e != NULL) _cmsFree(ContextID, e);\n\n    return st;\n}",
          "fn_code_pos": [
            [
              1152,
              0
            ],
            [
              1208,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "smooth2",
            "parameters": {
              "ContextID": "cmsContext",
              "w": "cmsFloat32Number",
              "y": "cmsFloat32Number",
              "z": "cmsFloat32Number",
              "lambda": "cmsFloat32Number",
              "m": "int"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT cmsSmoothToneCurve(cmsToneCurve* Tab, cmsFloat64Number lambda)\n{\n    cmsBool SuccessStatus = TRUE;\n    cmsFloat32Number *w, *y, *z;\n    cmsUInt32Number i, nItems, Zeros, Poles;\n    cmsBool notCheck = FALSE;\n\n    if (Tab != NULL && Tab->InterpParams != NULL)\n    {\n        cmsContext ContextID = Tab->InterpParams->ContextID;\n\n        if (!cmsIsToneCurveLinear(Tab)) // Only non-linear curves need smoothing\n        {\n            nItems = Tab->nEntries;\n            if (nItems < MAX_NODES_IN_CURVE)\n            {\n                // Allocate one more item than needed\n                w = (cmsFloat32Number *)_cmsCalloc(ContextID, nItems + 1, sizeof(cmsFloat32Number));\n                y = (cmsFloat32Number *)_cmsCalloc(ContextID, nItems + 1, sizeof(cmsFloat32Number));\n                z = (cmsFloat32Number *)_cmsCalloc(ContextID, nItems + 1, sizeof(cmsFloat32Number));\n\n                if (w != NULL && y != NULL && z != NULL) // Ensure no memory allocation failure\n                {\n                    memset(w, 0, (nItems + 1) * sizeof(cmsFloat32Number));\n                    memset(y, 0, (nItems + 1) * sizeof(cmsFloat32Number));\n                    memset(z, 0, (nItems + 1) * sizeof(cmsFloat32Number));\n\n                    for (i = 0; i < nItems; i++)\n                    {\n                        y[i + 1] = (cmsFloat32Number)Tab->Table16[i];\n                        w[i + 1] = 1.0;\n                    }\n\n                    if (lambda < 0)\n                    {\n                        notCheck = TRUE;\n                        lambda = -lambda;\n                    }\n\n                    if (smooth2(ContextID, w, y, z, (cmsFloat32Number)lambda, (int)nItems))\n                    {\n                        // Do some reality - checking...\n\n                        Zeros = Poles = 0;\n                        for (i = nItems; i > 1; --i)\n                        {\n                            if (z[i] == 0.) Zeros++;\n                            if (z[i] >= 65535.) Poles++;\n                            if (z[i] < z[i - 1])\n                            {\n                                cmsSignalError(ContextID, cmsERROR_RANGE, \"cmsSmoothToneCurve: Non-Monotonic.\");\n                                SuccessStatus = notCheck;\n                                break;\n                            }\n                        }\n\n                        if (SuccessStatus && Zeros > (nItems / 3))\n                        {\n                            cmsSignalError(ContextID, cmsERROR_RANGE, \"cmsSmoothToneCurve: Degenerated, mostly zeros.\");\n                            SuccessStatus = notCheck;\n                        }\n\n                        if (SuccessStatus && Poles > (nItems / 3))\n                        {\n                            cmsSignalError(ContextID, cmsERROR_RANGE, \"cmsSmoothToneCurve: Degenerated, mostly poles.\");\n                            SuccessStatus = notCheck;\n                        }\n\n                        if (SuccessStatus) // Seems ok\n                        {\n                            for (i = 0; i < nItems; i++)\n                            {\n                                // Clamp to cmsUInt16Number\n                                Tab->Table16[i] = _cmsQuickSaturateWord(z[i + 1]);\n                            }\n                        }\n                    }\n                    else // Could not smooth\n                    {\n                        cmsSignalError(ContextID, cmsERROR_RANGE, \"cmsSmoothToneCurve: Function smooth2 failed.\");\n                        SuccessStatus = FALSE;\n                    }\n                }\n                else // One or more buffers could not be allocated\n                {\n                    cmsSignalError(ContextID, cmsERROR_RANGE, \"cmsSmoothToneCurve: Could not allocate memory.\");\n                    SuccessStatus = FALSE;\n                }\n\n                if (z != NULL)\n                    _cmsFree(ContextID, z);\n\n                if (y != NULL)\n                    _cmsFree(ContextID, y);\n\n                if (w != NULL)\n                    _cmsFree(ContextID, w);\n            }\n            else // too many items in the table\n            {\n                cmsSignalError(ContextID, cmsERROR_RANGE, \"cmsSmoothToneCurve: Too many points.\");\n                SuccessStatus = FALSE;\n            }\n        }\n    }\n    else // Tab parameter or Tab->InterpParams is NULL\n    {\n        // Can't signal an error here since the ContextID is not known at this point\n        SuccessStatus = FALSE;\n    }\n\n    return SuccessStatus;\n}",
          "fn_code_pos": [
            [
              1211,
              0
            ],
            [
              1323,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSmoothToneCurve",
            "parameters": {
              "Tab": "cmsToneCurve",
              "lambda": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsIsToneCurveLinear(const cmsToneCurve* Curve)\n{\n    int i;\n    int diff;\n\n    _cmsAssert(Curve != NULL);\n\n    for (i=0; i < (int) Curve ->nEntries; i++) {\n\n        diff = abs((int) Curve->Table16[i] - (int) _cmsQuantizeVal(i, Curve ->nEntries));\n        if (diff > 0x0f)\n            return FALSE;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1327,
              0
            ],
            [
              1342,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIsToneCurveLinear",
            "parameters": {
              "Curve": "cmsToneCurve"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT cmsIsToneCurveMonotonic(const cmsToneCurve* t)\n{\n    cmsUInt32Number n;\n    int i, last;\n    cmsBool lDescending;\n\n    _cmsAssert(t != NULL);\n\n    // Degenerated curves are monotonic? Ok, let's pass them\n    n = t ->nEntries;\n    if (n < 2) return TRUE;\n\n    // Curve direction\n    lDescending = cmsIsToneCurveDescending(t);\n\n    if (lDescending) {\n\n        last = t ->Table16[0];\n\n        for (i = 1; i < (int) n; i++) {\n\n            if (t ->Table16[i] - last > 2) // We allow some ripple\n                return FALSE;\n            else\n                last = t ->Table16[i];\n\n        }\n    }\n    else {\n\n        last = t ->Table16[n-1];\n\n        for (i = (int) n - 2; i >= 0; --i) {\n\n            if (t ->Table16[i] - last > 2)\n                return FALSE;\n            else\n                last = t ->Table16[i];\n\n        }\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1345,
              0
            ],
            [
              1388,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIsToneCurveMonotonic",
            "parameters": {
              "t": "cmsToneCurve"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT cmsIsToneCurveDescending(const cmsToneCurve* t)\n{\n    _cmsAssert(t != NULL);\n\n    return t ->Table16[0] > t ->Table16[t ->nEntries-1];\n}",
          "fn_code_pos": [
            [
              1391,
              0
            ],
            [
              1396,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIsToneCurveDescending",
            "parameters": {
              "t": "cmsToneCurve"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT cmsIsToneCurveMultisegment(const cmsToneCurve* t)\n{\n    _cmsAssert(t != NULL);\n\n    return t -> nSegments > 1;\n}",
          "fn_code_pos": [
            [
              1400,
              0
            ],
            [
              1405,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIsToneCurveMultisegment",
            "parameters": {
              "t": "cmsToneCurve"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsInt32Number  CMSEXPORT cmsGetToneCurveParametricType(const cmsToneCurve* t)\n{\n    _cmsAssert(t != NULL);\n\n    if (t -> nSegments != 1) return 0;\n    return t ->Segments[0].Type;\n}",
          "fn_code_pos": [
            [
              1407,
              0
            ],
            [
              1413,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetToneCurveParametricType",
            "parameters": {
              "t": "cmsToneCurve"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "cmsFloat32Number CMSEXPORT cmsEvalToneCurveFloat(const cmsToneCurve* Curve, cmsFloat32Number v)\n{\n    _cmsAssert(Curve != NULL);\n\n    // Check for 16 bits table. If so, this is a limited-precision tone curve\n    if (Curve ->nSegments == 0) {\n\n        cmsUInt16Number In, Out;\n\n        In = (cmsUInt16Number) _cmsQuickSaturateWord(v * 65535.0);\n        Out = cmsEvalToneCurve16(Curve, In);\n\n        return (cmsFloat32Number) (Out / 65535.0);\n    }\n\n    return (cmsFloat32Number) EvalSegmentedFn(Curve, v);\n}",
          "fn_code_pos": [
            [
              1416,
              0
            ],
            [
              1432,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsEvalToneCurveFloat",
            "parameters": {
              "Curve": "cmsToneCurve",
              "v": "cmsFloat32Number"
            },
            "return_type": "cmsFloat32Number"
          }
        },
        {
          "fn_code": "cmsUInt16Number CMSEXPORT cmsEvalToneCurve16(const cmsToneCurve* Curve, cmsUInt16Number v)\n{\n    cmsUInt16Number out;\n\n    _cmsAssert(Curve != NULL);\n\n    Curve ->InterpParams ->Interpolation.Lerp16(&v, &out, Curve ->InterpParams);\n    return out;\n}",
          "fn_code_pos": [
            [
              1435,
              0
            ],
            [
              1443,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsEvalToneCurve16",
            "parameters": {
              "Curve": "cmsToneCurve",
              "v": "cmsUInt16Number"
            },
            "return_type": "cmsUInt16Number"
          }
        },
        {
          "fn_code": "cmsFloat64Number CMSEXPORT cmsEstimateGamma(const cmsToneCurve* t, cmsFloat64Number Precision)\n{\n    cmsFloat64Number gamma, sum, sum2;\n    cmsFloat64Number n, x, y, Std;\n    cmsUInt32Number i;\n\n    _cmsAssert(t != NULL);\n\n    sum = sum2 = n = 0;\n\n    // Excluding endpoints\n    for (i=1; i < (MAX_NODES_IN_CURVE-1); i++) {\n\n        x = (cmsFloat64Number) i / (MAX_NODES_IN_CURVE-1);\n        y = (cmsFloat64Number) cmsEvalToneCurveFloat(t, (cmsFloat32Number) x);\n\n        // Avoid 7% on lower part to prevent\n        // artifacts due to linear ramps\n\n        if (y > 0. && y < 1. && x > 0.07) {\n\n            gamma = log(y) / log(x);\n            sum  += gamma;\n            sum2 += gamma * gamma;\n            n++;\n        }\n    }\n\n    // We need enough valid samples\n    if (n <= 1) return -1.0;\n\n    // Take a look on SD to see if gamma isn't exponential at all\n    Std = sqrt((n * sum2 - sum * sum) / (n*(n-1)));\n\n    if (Std > Precision)\n        return -1.0;\n\n    return (sum / n);   // The mean\n}",
          "fn_code_pos": [
            [
              1463,
              0
            ],
            [
              1501,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsEstimateGamma",
            "parameters": {
              "t": "cmsToneCurve",
              "Precision": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "const cmsCurveSegment* CMSEXPORT cmsGetToneCurveSegment(cmsInt32Number n, const cmsToneCurve* t)\n{\n    _cmsAssert(t != NULL);\n\n    if (n < 0 || n >= (cmsInt32Number) t->nSegments) return NULL;\n    return t->Segments + n;\n}",
          "fn_code_pos": [
            [
              1505,
              0
            ],
            [
              1511,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetToneCurveSegment",
            "parameters": {
              "n": "cmsInt32Number",
              "t": "cmsToneCurve"
            },
            "return_type": "cmsCurveSegment"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "DefaultEvalParametricFn(cmsInt32Number Type, const cmsFloat64Number Params[], cmsFloat64Number R)",
          "fn_dec_pos": [
            [
              57,
              24
            ],
            [
              57,
              121
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DefaultEvalParametricFn",
            "parameters": {
              "Type": "cmsInt32Number",
              "Params": "cmsFloat64Number",
              "R": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "GetParametricCurveByType(cmsContext ContextID, int Type, int* index)",
          "fn_dec_pos": [
            [
              177,
              32
            ],
            [
              177,
              100
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetParametricCurveByType",
            "parameters": {
              "ContextID": "cmsContext",
              "Type": "int",
              "index": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "AllocateToneCurveStruct(cmsContext ContextID, cmsUInt32Number nEntries,\n                                      cmsUInt32Number nSegments, const cmsCurveSegment* Segments,\n                                      const cmsUInt16Number* Values)",
          "fn_dec_pos": [
            [
              212,
              14
            ],
            [
              214,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AllocateToneCurveStruct",
            "parameters": {
              "ContextID": "cmsContext",
              "nEntries": "cmsUInt32Number",
              "nSegments": "cmsUInt32Number",
              "Segments": "cmsCurveSegment",
              "Values": "cmsUInt16Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsGetToneCurveEstimatedTable(const cmsToneCurve* t)",
          "fn_dec_pos": [
            [
              773,
              33
            ],
            [
              773,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetToneCurveEstimatedTable",
            "parameters": {
              "t": "cmsToneCurve"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsGetToneCurveSegment(cmsInt32Number n, const cmsToneCurve* t)",
          "fn_dec_pos": [
            [
              1505,
              33
            ],
            [
              1505,
              96
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetToneCurveSegment",
            "parameters": {
              "n": "cmsInt32Number",
              "t": "cmsToneCurve"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct _cmsParametricCurvesCollection_st {\n\n    cmsUInt32Number nFunctions;                                     // Number of supported functions in this chunk\n    cmsInt32Number  FunctionTypes[MAX_TYPES_IN_LCMS_PLUGIN];        // The identification types\n    cmsUInt32Number ParameterCount[MAX_TYPES_IN_LCMS_PLUGIN];       // Number of parameters for each function\n\n    cmsParametricCurveEvaluator Evaluator;                          // The evaluator\n\n    struct _cmsParametricCurvesCollection_st* Next; // Next in list\n\n} _cmsParametricCurvesCollection;",
          {
            "nFunctions": "cmsUInt32Number",
            "FunctionTypes[MAX_TYPES_IN_LCMS_PLUGIN]": "cmsInt32Number",
            "ParameterCount[MAX_TYPES_IN_LCMS_PLUGIN]": "cmsUInt32Number",
            "Evaluator": "cmsParametricCurveEvaluator",
            "* Next": "struct _cmsParametricCurvesCollection_st"
          },
          "_cmsParametricCurvesCollection",
          [
            44,
            0
          ],
          [
            54,
            33
          ]
        ],
        [
          "typedef struct _cmsParametricCurvesCollection_st {\n\n    cmsUInt32Number nFunctions;                                     // Number of supported functions in this chunk\n    cmsInt32Number  FunctionTypes[MAX_TYPES_IN_LCMS_PLUGIN];        // The identification types\n    cmsUInt32Number ParameterCount[MAX_TYPES_IN_LCMS_PLUGIN];       // Number of parameters for each function\n\n    cmsParametricCurveEvaluator Evaluator;                          // The evaluator\n\n    struct _cmsParametricCurvesCollection_st* Next; // Next in list\n\n} _cmsParametricCurvesCollection;",
          {
            "nFunctions": "cmsUInt32Number",
            "FunctionTypes[MAX_TYPES_IN_LCMS_PLUGIN]": "cmsInt32Number",
            "ParameterCount[MAX_TYPES_IN_LCMS_PLUGIN]": "cmsUInt32Number",
            "Evaluator": "cmsParametricCurveEvaluator",
            "* Next": "struct _cmsParametricCurvesCollection_st"
          },
          "_cmsParametricCurvesCollection",
          [
            44,
            0
          ],
          [
            54,
            33
          ]
        ],
        [
          "struct _cmsParametricCurvesCollection_st",
          {},
          "",
          [
            52,
            4
          ],
          [
            52,
            44
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            70,
            25
          ],
          [
            70,
            50
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            71,
            53
          ],
          [
            71,
            78
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            105,
            32
          ],
          [
            105,
            57
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            106,
            38
          ],
          [
            106,
            63
          ]
        ],
        [
          "struct _cms_interp_struc",
          {},
          "",
          [
            1022,
            77
          ],
          [
            1022,
            101
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmsalpha.c": {
      "fn_def_list": [
        {
          "fn_code": "cmsINLINE cmsUInt8Number _cmsQuickSaturateByte(cmsFloat64Number d)\n{\n       d += 0.5;\n       if (d <= 0) return 0;\n       if (d >= 255.0) return 255;\n\n       return (cmsUInt8Number) _cmsQuickFloorWord(d);\n}",
          "fn_code_pos": [
            [
              35,
              0
            ],
            [
              42,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsUInt8Number _cmsQuickSaturateByte",
            "parameters": {
              "d": "cmsFloat64Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number trueBytesSize(cmsUInt32Number Format)\n{\n    cmsUInt32Number fmt_bytes = T_BYTES(Format);\n\n    // For double, the T_BYTES field returns zero\n    if (fmt_bytes == 0)\n        return sizeof(double);\n\n    // Otherwise, it is already correct for all formats\n    return fmt_bytes;\n}",
          "fn_code_pos": [
            [
              46,
              0
            ],
            [
              57,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "trueBytesSize",
            "parameters": {
              "Format": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid copy8(void* dst, const void* src)\n{\n       memmove(dst, src, 1);\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              71,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copy8",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid from8to16(void* dst, const void* src)\n{\n       cmsUInt8Number n = *(cmsUInt8Number*)src;\n       *(cmsUInt16Number*) dst = (cmsUInt16Number) FROM_8_TO_16(n);\n}",
          "fn_code_pos": [
            [
              73,
              0
            ],
            [
              78,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "from8to16",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid from8to16SE(void* dst, const void* src)\n{\n    cmsUInt8Number n = *(cmsUInt8Number*)src;    \n    *(cmsUInt16Number*)dst = CHANGE_ENDIAN(FROM_8_TO_16(n));\n}",
          "fn_code_pos": [
            [
              80,
              0
            ],
            [
              85,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "from8to16SE",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid from8toFLT(void* dst, const void* src)\n{\n       *(cmsFloat32Number*)dst = (cmsFloat32Number) (*(cmsUInt8Number*)src) / 255.0f;\n}",
          "fn_code_pos": [
            [
              87,
              0
            ],
            [
              91,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "from8toFLT",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid from8toDBL(void* dst, const void* src)\n{\n       *(cmsFloat64Number*)dst = (cmsFloat64Number) (*(cmsUInt8Number*)src) / 255.0;\n}",
          "fn_code_pos": [
            [
              93,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "from8toDBL",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid from8toHLF(void* dst, const void* src)\n{\n#ifndef CMS_NO_HALF_SUPPORT\n       cmsFloat32Number n = (*(cmsUInt8Number*)src) / 255.0f;\n       *(cmsUInt16Number*)dst = _cmsFloat2Half(n);\n#else\n    cmsUNUSED_PARAMETER(dst);\n    cmsUNUSED_PARAMETER(src);\n#endif\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              109,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "from8toHLF",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid from16to8(void* dst, const void* src)\n{\n       cmsUInt16Number n = *(cmsUInt16Number*)src;\n       *(cmsUInt8Number*) dst = FROM_16_TO_8(n);\n}",
          "fn_code_pos": [
            [
              113,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "from16to8",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid from16SEto8(void* dst, const void* src)\n{\n    cmsUInt16Number n = *(cmsUInt16Number*)src;\n    *(cmsUInt8Number*)dst = FROM_16_TO_8(CHANGE_ENDIAN(n));\n}",
          "fn_code_pos": [
            [
              120,
              0
            ],
            [
              125,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "from16SEto8",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid copy16(void* dst, const void* src)\n{\n       memmove(dst, src, 2);\n}",
          "fn_code_pos": [
            [
              127,
              0
            ],
            [
              131,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copy16",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid from16to16(void* dst, const void* src)\n{\n    cmsUInt16Number n = *(cmsUInt16Number*)src;\n    *(cmsUInt16Number*)dst = CHANGE_ENDIAN(n);\n}",
          "fn_code_pos": [
            [
              133,
              0
            ],
            [
              138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "from16to16",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid from16toFLT(void* dst, const void* src)\n{\n       *(cmsFloat32Number*)dst = (*(cmsUInt16Number*)src) / 65535.0f;\n}",
          "fn_code_pos": [
            [
              140,
              0
            ],
            [
              144,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "from16toFLT",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid from16SEtoFLT(void* dst, const void* src)\n{\n    *(cmsFloat32Number*)dst = (CHANGE_ENDIAN(*(cmsUInt16Number*)src)) / 65535.0f;\n}",
          "fn_code_pos": [
            [
              146,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "from16SEtoFLT",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid from16toDBL(void* dst, const void* src)\n{\n       *(cmsFloat64Number*)dst = (cmsFloat64Number) (*(cmsUInt16Number*)src) / 65535.0;\n}",
          "fn_code_pos": [
            [
              152,
              0
            ],
            [
              156,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "from16toDBL",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid from16SEtoDBL(void* dst, const void* src)\n{\n    *(cmsFloat64Number*)dst = (cmsFloat64Number) (CHANGE_ENDIAN(*(cmsUInt16Number*)src)) / 65535.0;\n}",
          "fn_code_pos": [
            [
              158,
              0
            ],
            [
              162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "from16SEtoDBL",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid from16toHLF(void* dst, const void* src)\n{\n#ifndef CMS_NO_HALF_SUPPORT\n       cmsFloat32Number n = (*(cmsUInt16Number*)src) / 65535.0f;\n       *(cmsUInt16Number*)dst = _cmsFloat2Half(n);\n#else\n    cmsUNUSED_PARAMETER(dst);\n    cmsUNUSED_PARAMETER(src);\n#endif\n}",
          "fn_code_pos": [
            [
              164,
              0
            ],
            [
              174,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "from16toHLF",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid from16SEtoHLF(void* dst, const void* src)\n{\n#ifndef CMS_NO_HALF_SUPPORT\n    cmsFloat32Number n = (CHANGE_ENDIAN(*(cmsUInt16Number*)src)) / 65535.0f;\n    *(cmsUInt16Number*)dst = _cmsFloat2Half(n);\n#else\n    cmsUNUSED_PARAMETER(dst);\n    cmsUNUSED_PARAMETER(src);\n#endif\n}",
          "fn_code_pos": [
            [
              176,
              0
            ],
            [
              186,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "from16SEtoHLF",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid fromFLTto8(void* dst, const void* src)\n{\n    cmsFloat32Number n = *(cmsFloat32Number*)src;\n    *(cmsUInt8Number*)dst = _cmsQuickSaturateByte(n * 255.0);\n}",
          "fn_code_pos": [
            [
              189,
              0
            ],
            [
              194,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fromFLTto8",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid fromFLTto16(void* dst, const void* src)\n{\n    cmsFloat32Number n = *(cmsFloat32Number*)src;\n    *(cmsUInt16Number*)dst = _cmsQuickSaturateWord(n * 65535.0);\n}",
          "fn_code_pos": [
            [
              196,
              0
            ],
            [
              201,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fromFLTto16",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid fromFLTto16SE(void* dst, const void* src)\n{\n    cmsFloat32Number n = *(cmsFloat32Number*)src;\n    cmsUInt16Number i = _cmsQuickSaturateWord(n * 65535.0);\n\n    *(cmsUInt16Number*)dst = CHANGE_ENDIAN(i);\n}",
          "fn_code_pos": [
            [
              203,
              0
            ],
            [
              210,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fromFLTto16SE",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid copy32(void* dst, const void* src)\n{\n    memmove(dst, src, sizeof(cmsFloat32Number));\n}",
          "fn_code_pos": [
            [
              212,
              0
            ],
            [
              216,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copy32",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid fromFLTtoDBL(void* dst, const void* src)\n{\n    cmsFloat32Number n = *(cmsFloat32Number*)src;\n    *(cmsFloat64Number*)dst = (cmsFloat64Number)n;\n}",
          "fn_code_pos": [
            [
              218,
              0
            ],
            [
              223,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fromFLTtoDBL",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid fromFLTtoHLF(void* dst, const void* src)\n{\n#ifndef CMS_NO_HALF_SUPPORT\n       cmsFloat32Number n = *(cmsFloat32Number*)src;\n       *(cmsUInt16Number*)dst = _cmsFloat2Half(n);\n#else\n    cmsUNUSED_PARAMETER(dst);\n    cmsUNUSED_PARAMETER(src);\n#endif\n}",
          "fn_code_pos": [
            [
              225,
              0
            ],
            [
              235,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fromFLTtoHLF",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid fromHLFto8(void* dst, const void* src)\n{\n#ifndef CMS_NO_HALF_SUPPORT\n       cmsFloat32Number n = _cmsHalf2Float(*(cmsUInt16Number*)src);\n       *(cmsUInt8Number*)dst = _cmsQuickSaturateByte(n * 255.0);\n#else\n    cmsUNUSED_PARAMETER(dst);\n    cmsUNUSED_PARAMETER(src);\n#endif\n\n}",
          "fn_code_pos": [
            [
              240,
              0
            ],
            [
              251,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fromHLFto8",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid fromHLFto16(void* dst, const void* src)\n{\n#ifndef CMS_NO_HALF_SUPPORT\n       cmsFloat32Number n = _cmsHalf2Float(*(cmsUInt16Number*)src);\n       *(cmsUInt16Number*)dst = _cmsQuickSaturateWord(n * 65535.0);\n#else\n    cmsUNUSED_PARAMETER(dst);\n    cmsUNUSED_PARAMETER(src);\n#endif\n}",
          "fn_code_pos": [
            [
              253,
              0
            ],
            [
              263,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fromHLFto16",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid fromHLFto16SE(void* dst, const void* src)\n{\n#ifndef CMS_NO_HALF_SUPPORT\n    cmsFloat32Number n = _cmsHalf2Float(*(cmsUInt16Number*)src);\n    cmsUInt16Number i = _cmsQuickSaturateWord(n * 65535.0);\n    *(cmsUInt16Number*)dst = CHANGE_ENDIAN(i);\n#else\n    cmsUNUSED_PARAMETER(dst);\n    cmsUNUSED_PARAMETER(src);\n#endif\n}",
          "fn_code_pos": [
            [
              265,
              0
            ],
            [
              276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fromHLFto16SE",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid fromHLFtoFLT(void* dst, const void* src)\n{\n#ifndef CMS_NO_HALF_SUPPORT\n       *(cmsFloat32Number*)dst = _cmsHalf2Float(*(cmsUInt16Number*)src);\n#else\n    cmsUNUSED_PARAMETER(dst);\n    cmsUNUSED_PARAMETER(src);\n#endif\n}",
          "fn_code_pos": [
            [
              278,
              0
            ],
            [
              287,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fromHLFtoFLT",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid fromHLFtoDBL(void* dst, const void* src)\n{\n#ifndef CMS_NO_HALF_SUPPORT\n       *(cmsFloat64Number*)dst = (cmsFloat64Number)_cmsHalf2Float(*(cmsUInt16Number*)src);\n#else\n    cmsUNUSED_PARAMETER(dst);\n    cmsUNUSED_PARAMETER(src);\n#endif\n}",
          "fn_code_pos": [
            [
              289,
              0
            ],
            [
              298,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fromHLFtoDBL",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid fromDBLto8(void* dst, const void* src)\n{\n       cmsFloat64Number n = *(cmsFloat64Number*)src;\n       *(cmsUInt8Number*)dst = _cmsQuickSaturateByte(n * 255.0);\n}",
          "fn_code_pos": [
            [
              301,
              0
            ],
            [
              306,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fromDBLto8",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid fromDBLto16(void* dst, const void* src)\n{\n       cmsFloat64Number n = *(cmsFloat64Number*)src;\n       *(cmsUInt16Number*)dst = _cmsQuickSaturateWord(n * 65535.0f);\n}",
          "fn_code_pos": [
            [
              308,
              0
            ],
            [
              313,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fromDBLto16",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid fromDBLto16SE(void* dst, const void* src)\n{\n    cmsFloat64Number n = *(cmsFloat64Number*)src;\n    cmsUInt16Number  i = _cmsQuickSaturateWord(n * 65535.0f);\n    *(cmsUInt16Number*)dst = CHANGE_ENDIAN(i);\n}",
          "fn_code_pos": [
            [
              315,
              0
            ],
            [
              321,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fromDBLto16SE",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid fromDBLtoFLT(void* dst, const void* src)\n{\n       cmsFloat64Number n = *(cmsFloat64Number*)src;\n       *(cmsFloat32Number*)dst = (cmsFloat32Number) n;\n}",
          "fn_code_pos": [
            [
              323,
              0
            ],
            [
              328,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fromDBLtoFLT",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid fromDBLtoHLF(void* dst, const void* src)\n{\n#ifndef CMS_NO_HALF_SUPPORT\n       cmsFloat32Number n = (cmsFloat32Number) *(cmsFloat64Number*)src;\n       *(cmsUInt16Number*)dst = _cmsFloat2Half(n);\n#else\n    cmsUNUSED_PARAMETER(dst);\n    cmsUNUSED_PARAMETER(src);\n#endif\n}",
          "fn_code_pos": [
            [
              330,
              0
            ],
            [
              340,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fromDBLtoHLF",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid copy64(void* dst, const void* src)\n{\n       memmove(dst, src, sizeof(cmsFloat64Number));\n}",
          "fn_code_pos": [
            [
              342,
              0
            ],
            [
              346,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copy64",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nint FormatterPos(cmsUInt32Number frm)\n{\n    cmsUInt32Number  b = T_BYTES(frm);\n\n    if (b == 0 && T_FLOAT(frm))\n        return 5; // DBL\n#ifndef CMS_NO_HALF_SUPPORT\n    if (b == 2 && T_FLOAT(frm))\n        return 3; // HLF\n#endif\n    if (b == 4 && T_FLOAT(frm))\n        return 4; // FLT\n    if (b == 2 && !T_FLOAT(frm))\n    {\n        if (T_ENDIAN16(frm))\n            return 2; // 16SE\n        else\n            return 1; // 16\n    }\n    if (b == 1 && !T_FLOAT(frm))\n        return 0; // 8\n    return -1; // not recognized\n}",
          "fn_code_pos": [
            [
              350,
              0
            ],
            [
              373,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FormatterPos",
            "parameters": {
              "frm": "cmsUInt32Number"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\ncmsFormatterAlphaFn _cmsGetFormatterAlpha(cmsContext id, cmsUInt32Number in, cmsUInt32Number out)\n{\nstatic cmsFormatterAlphaFn FormattersAlpha[6][6] = {\n\n       /* from 8 */  { copy8,       from8to16,   from8to16SE,   from8toHLF,   from8toFLT,    from8toDBL    },\n       /* from 16*/  { from16to8,   copy16,      from16to16,    from16toHLF,  from16toFLT,   from16toDBL   },\n       /* from 16SE*/{ from16SEto8, from16to16,  copy16,        from16SEtoHLF,from16SEtoFLT, from16SEtoDBL },\n       /* from HLF*/ { fromHLFto8,  fromHLFto16, fromHLFto16SE, copy16,       fromHLFtoFLT,  fromHLFtoDBL  },\n       /* from FLT*/ { fromFLTto8,  fromFLTto16, fromFLTto16SE, fromFLTtoHLF, copy32,        fromFLTtoDBL  },\n       /* from DBL*/ { fromDBLto8,  fromDBLto16, fromDBLto16SE, fromDBLtoHLF, fromDBLtoFLT,  copy64 }};\n\n        int in_n  = FormatterPos(in);\n        int out_n = FormatterPos(out);\n\n        if (in_n < 0 || out_n < 0 || in_n > 5 || out_n > 5) {\n\n               cmsSignalError(id, cmsERROR_UNKNOWN_EXTENSION, \"Unrecognized alpha channel width\");\n               return NULL;\n        }\n\n        return FormattersAlpha[in_n][out_n];\n}",
          "fn_code_pos": [
            [
              376,
              0
            ],
            [
              398,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetFormatterAlpha",
            "parameters": {
              "id": "cmsContext",
              "in": "cmsUInt32Number",
              "out": "cmsUInt32Number"
            },
            "return_type": "cmsFormatterAlphaFn"
          }
        },
        {
          "fn_code": "static\ncmsBool ComputeIncrementsForChunky(cmsUInt32Number Format,\n                                cmsUInt32Number ComponentStartingOrder[], \n                                cmsUInt32Number ComponentPointerIncrements[])\n{\n       cmsUInt32Number channels[cmsMAXCHANNELS];\n       cmsUInt32Number extra = T_EXTRA(Format);\n       cmsUInt32Number nchannels = T_CHANNELS(Format);\n       cmsUInt32Number total_chans = nchannels + extra;\n       cmsUInt32Number i;\n       cmsUInt32Number channelSize = trueBytesSize(Format);\n       cmsUInt32Number pixelSize = channelSize * total_chans;\n       \n       // Sanity check\n       if (total_chans <= 0 || total_chans >= cmsMAXCHANNELS)\n           return FALSE;\n\n        memset(channels, 0, sizeof(channels));\n\n       // Separation is independent of starting point and only depends on channel size\n       for (i = 0; i < extra; i++)\n              ComponentPointerIncrements[i] = pixelSize;\n\n       // Handle do swap\n       for (i = 0; i < total_chans; i++)\n       {\n              if (T_DOSWAP(Format)) {\n                     channels[i] = total_chans - i - 1;\n              }\n              else {\n                     channels[i] = i;\n              }\n       }\n\n       // Handle swap first (ROL of positions), example CMYK -> KCMY | 0123 -> 3012\n       if (T_SWAPFIRST(Format) && total_chans > 1) {\n              \n              cmsUInt32Number tmp = channels[0];\n              for (i = 0; i < total_chans-1; i++)\n                     channels[i] = channels[i + 1];\n\n              channels[total_chans - 1] = tmp;\n       }\n\n       // Handle size\n       if (channelSize > 1)\n              for (i = 0; i < total_chans; i++) {\n                     channels[i] *= channelSize;\n              }\n\n       for (i = 0; i < extra; i++)\n              ComponentStartingOrder[i] = channels[i + nchannels];\n\n       return TRUE;\n}",
          "fn_code_pos": [
            [
              403,
              0
            ],
            [
              457,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComputeIncrementsForChunky",
            "parameters": {
              "Format": "cmsUInt32Number",
              "ComponentStartingOrder": "cmsUInt32Number",
              "ComponentPointerIncrements": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool ComputeIncrementsForPlanar(cmsUInt32Number Format,\n                                cmsUInt32Number BytesPerPlane,\n                                cmsUInt32Number ComponentStartingOrder[], \n                                cmsUInt32Number ComponentPointerIncrements[])\n{\n       cmsUInt32Number channels[cmsMAXCHANNELS];       \n       cmsUInt32Number extra = T_EXTRA(Format);\n       cmsUInt32Number nchannels = T_CHANNELS(Format);\n       cmsUInt32Number total_chans = nchannels + extra;\n       cmsUInt32Number i;\n       cmsUInt32Number channelSize = trueBytesSize(Format);\n      \n       // Sanity check\n       if (total_chans <= 0 || total_chans >= cmsMAXCHANNELS)\n           return FALSE;\n\n       memset(channels, 0, sizeof(channels));\n\n       // Separation is independent of starting point and only depends on channel size\n       for (i = 0; i < extra; i++)\n              ComponentPointerIncrements[i] = channelSize;\n\n       // Handle do swap\n       for (i = 0; i < total_chans; i++)\n       {\n              if (T_DOSWAP(Format)) {\n                     channels[i] = total_chans - i - 1;\n              }\n              else {\n                     channels[i] = i;\n              }\n       }\n\n       // Handle swap first (ROL of positions), example CMYK -> KCMY | 0123 -> 3012\n       if (T_SWAPFIRST(Format) && total_chans > 0) {\n\n              cmsUInt32Number tmp = channels[0];\n              for (i = 0; i < total_chans - 1; i++)\n                     channels[i] = channels[i + 1];\n\n              channels[total_chans - 1] = tmp;\n       }\n\n       // Handle size\n       for (i = 0; i < total_chans; i++) {\n              channels[i] *= BytesPerPlane;\n       }\n\n       for (i = 0; i < extra; i++)\n              ComponentStartingOrder[i] = channels[i + nchannels];\n\n       return TRUE;\n}",
          "fn_code_pos": [
            [
              462,
              0
            ],
            [
              515,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComputeIncrementsForPlanar",
            "parameters": {
              "Format": "cmsUInt32Number",
              "BytesPerPlane": "cmsUInt32Number",
              "ComponentStartingOrder": "cmsUInt32Number",
              "ComponentPointerIncrements": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool ComputeComponentIncrements(cmsUInt32Number Format,\n                                 cmsUInt32Number BytesPerPlane,\n                                 cmsUInt32Number ComponentStartingOrder[], \n                                 cmsUInt32Number ComponentPointerIncrements[])\n{\n       if (T_PLANAR(Format)) {\n\n              return ComputeIncrementsForPlanar(Format,  BytesPerPlane, ComponentStartingOrder, ComponentPointerIncrements);\n       }\n       else {\n              return ComputeIncrementsForChunky(Format,  ComponentStartingOrder, ComponentPointerIncrements);\n       }\n\n}",
          "fn_code_pos": [
            [
              520,
              0
            ],
            [
              534,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComputeComponentIncrements",
            "parameters": {
              "Format": "cmsUInt32Number",
              "BytesPerPlane": "cmsUInt32Number",
              "ComponentStartingOrder": "cmsUInt32Number",
              "ComponentPointerIncrements": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "void _cmsHandleExtraChannels(_cmsTRANSFORM* p, const void* in,\n                                               void* out,\n                                               cmsUInt32Number PixelsPerLine,\n                                               cmsUInt32Number LineCount,\n                                               const cmsStride* Stride)\n{\n    cmsUInt32Number i, j, k;\n    cmsUInt32Number nExtra;\n    cmsUInt32Number SourceStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number SourceIncrements[cmsMAXCHANNELS];\n    cmsUInt32Number DestStartingOrder[cmsMAXCHANNELS];\n    cmsUInt32Number DestIncrements[cmsMAXCHANNELS];\n\n    cmsFormatterAlphaFn copyValueFn;\n\n    // Make sure we need some copy\n    if (!(p->dwOriginalFlags & cmsFLAGS_COPY_ALPHA))\n        return;\n\n    // Exit early if in-place color-management is occurring - no need to copy extra channels to themselves.\n    if (p->InputFormat == p->OutputFormat && in == out)\n        return;\n\n    // Make sure we have same number of alpha channels. If not, just return as this should be checked at transform creation time.\n    nExtra = T_EXTRA(p->InputFormat);\n    if (nExtra != T_EXTRA(p->OutputFormat))\n        return;\n\n    // Anything to do?\n    if (nExtra == 0)\n        return;\n\n    // Compute the increments\n    if (!ComputeComponentIncrements(p->InputFormat, Stride->BytesPerPlaneIn, SourceStartingOrder, SourceIncrements))\n        return;\n    if (!ComputeComponentIncrements(p->OutputFormat, Stride->BytesPerPlaneOut, DestStartingOrder, DestIncrements))\n        return;\n\n    // Check for conversions 8, 16, half, float, dbl\n    copyValueFn = _cmsGetFormatterAlpha(p->ContextID, p->InputFormat, p->OutputFormat);\n    if (copyValueFn == NULL) \n        return;\n\n    if (nExtra == 1) { // Optimized routine for copying a single extra channel quickly\n\n        cmsUInt8Number* SourcePtr;\n        cmsUInt8Number* DestPtr;\n\n        size_t SourceStrideIncrement = 0;\n        size_t DestStrideIncrement = 0;\n\n        // The loop itself\n        for (i = 0; i < LineCount; i++) {\n\n            // Prepare pointers for the loop\n            SourcePtr = (cmsUInt8Number*)in + SourceStartingOrder[0] + SourceStrideIncrement;\n            DestPtr = (cmsUInt8Number*)out + DestStartingOrder[0] + DestStrideIncrement;\n\n            for (j = 0; j < PixelsPerLine; j++) {\n\n                copyValueFn(DestPtr, SourcePtr);\n\n                SourcePtr += SourceIncrements[0];\n                DestPtr += DestIncrements[0];\n            }\n\n            SourceStrideIncrement += Stride->BytesPerLineIn;\n            DestStrideIncrement += Stride->BytesPerLineOut;\n        }\n\n    }\n    else { // General case with more than one extra channel\n\n        cmsUInt8Number* SourcePtr[cmsMAXCHANNELS];\n        cmsUInt8Number* DestPtr[cmsMAXCHANNELS];\n\n        size_t SourceStrideIncrements[cmsMAXCHANNELS];\n        size_t DestStrideIncrements[cmsMAXCHANNELS];\n\n        memset(SourceStrideIncrements, 0, sizeof(SourceStrideIncrements));\n        memset(DestStrideIncrements, 0, sizeof(DestStrideIncrements));\n\n        // The loop itself       \n        for (i = 0; i < LineCount; i++) {\n\n            // Prepare pointers for the loop\n            for (j = 0; j < nExtra; j++) {\n\n                SourcePtr[j] = (cmsUInt8Number*)in + SourceStartingOrder[j] + SourceStrideIncrements[j];\n                DestPtr[j] = (cmsUInt8Number*)out + DestStartingOrder[j] + DestStrideIncrements[j];\n            }\n\n            for (j = 0; j < PixelsPerLine; j++) {\n\n                for (k = 0; k < nExtra; k++) {\n\n                    copyValueFn(DestPtr[k], SourcePtr[k]);\n\n                    SourcePtr[k] += SourceIncrements[k];\n                    DestPtr[k] += DestIncrements[k];\n                }\n            }\n\n            for (j = 0; j < nExtra; j++) {\n\n                SourceStrideIncrements[j] += Stride->BytesPerLineIn;\n                DestStrideIncrements[j] += Stride->BytesPerLineOut;\n            }\n        }\n    }\n}",
          "fn_code_pos": [
            [
              537,
              0
            ],
            [
              647,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsHandleExtraChannels",
            "parameters": {
              "p": "_cmsTRANSFORM",
              "in": "void",
              "out": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*cmsFormatterAlphaFn)(void* dst, const void* src)",
          "fn_dec_pos": [
            [
              62,
              12
            ],
            [
              62,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "dst": "void",
              "src": "void"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmssm.c": {
      "fn_def_list": [
        {
          "fn_code": "static\ncmsFloat64Number _cmsAtan2(cmsFloat64Number y, cmsFloat64Number x)\n{\n    cmsFloat64Number a;\n\n    // Deal with undefined case\n    if (x == 0.0 && y == 0.0) return 0;\n\n    a = (atan2(y, x) * 180.0) / M_PI;\n\n    while (a < 0) {\n        a += 360;\n    }\n\n    return a;\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAtan2",
            "parameters": {
              "y": "cmsFloat64Number",
              "x": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\nvoid ToSpherical(cmsSpherical* sp, const cmsVEC3* v)\n{\n\n    cmsFloat64Number L, a, b;\n\n    L = v ->n[VX];\n    a = v ->n[VY];\n    b = v ->n[VZ];\n\n    sp ->r = sqrt( L*L + a*a + b*b );\n\n   if (sp ->r == 0) {\n        sp ->alpha = sp ->theta = 0;\n        return;\n    }\n\n    sp ->alpha = _cmsAtan2(a, b);\n    sp ->theta = _cmsAtan2(sqrt(a*a + b*b), L);\n}",
          "fn_code_pos": [
            [
              117,
              0
            ],
            [
              136,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ToSpherical",
            "parameters": {
              "sp": "cmsSpherical",
              "v": "cmsVEC3"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid ToCartesian(cmsVEC3* v, const cmsSpherical* sp)\n{\n    cmsFloat64Number sin_alpha;\n    cmsFloat64Number cos_alpha;\n    cmsFloat64Number sin_theta;\n    cmsFloat64Number cos_theta;\n    cmsFloat64Number L, a, b;\n\n    sin_alpha = sin((M_PI * sp ->alpha) / 180.0);\n    cos_alpha = cos((M_PI * sp ->alpha) / 180.0);\n    sin_theta = sin((M_PI * sp ->theta) / 180.0);\n    cos_theta = cos((M_PI * sp ->theta) / 180.0);\n\n    a = sp ->r * sin_theta * sin_alpha;\n    b = sp ->r * sin_theta * cos_alpha;\n    L = sp ->r * cos_theta;\n\n    v ->n[VX] = L;\n    v ->n[VY] = a;\n    v ->n[VZ] = b;\n}",
          "fn_code_pos": [
            [
              140,
              0
            ],
            [
              161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ToCartesian",
            "parameters": {
              "v": "cmsVEC3",
              "sp": "cmsSpherical"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid QuantizeToSector(const cmsSpherical* sp, int* alpha, int* theta)\n{\n    *alpha = (int) floor(((sp->alpha * (SECTORS)) / 360.0) );\n    *theta = (int) floor(((sp->theta * (SECTORS)) / 180.0) );\n\n    if (*alpha >= SECTORS)\n        *alpha = SECTORS-1;\n    if (*theta >= SECTORS)\n        *theta = SECTORS-1;\n}",
          "fn_code_pos": [
            [
              166,
              0
            ],
            [
              176,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "QuantizeToSector",
            "parameters": {
              "sp": "cmsSpherical",
              "alpha": "int",
              "theta": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid LineOf2Points(cmsLine* line, cmsVEC3* a, cmsVEC3* b)\n{\n\n    _cmsVEC3init(&line ->a, a ->n[VX], a ->n[VY], a ->n[VZ]);\n    _cmsVEC3init(&line ->u, b ->n[VX] - a ->n[VX],\n                            b ->n[VY] - a ->n[VY],\n                            b ->n[VZ] - a ->n[VZ]);\n}",
          "fn_code_pos": [
            [
              180,
              0
            ],
            [
              188,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LineOf2Points",
            "parameters": {
              "line": "cmsLine",
              "a": "cmsVEC3",
              "b": "cmsVEC3"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid GetPointOfLine(cmsVEC3* p, const cmsLine* line, cmsFloat64Number t)\n{\n    p ->n[VX] = line ->a.n[VX] + t * line->u.n[VX];\n    p ->n[VY] = line ->a.n[VY] + t * line->u.n[VY];\n    p ->n[VZ] = line ->a.n[VZ] + t * line->u.n[VZ];\n}",
          "fn_code_pos": [
            [
              192,
              0
            ],
            [
              198,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetPointOfLine",
            "parameters": {
              "p": "cmsVEC3",
              "line": "cmsLine",
              "t": "cmsFloat64Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool ClosestLineToLine(cmsVEC3* r, const cmsLine* line1, const cmsLine* line2)\n{\n    cmsFloat64Number a, b, c, d, e, D;\n    cmsFloat64Number sc, sN, sD;\n    //cmsFloat64Number tc; // left for future use\n    cmsFloat64Number tN, tD;\n    cmsVEC3 w0;\n\n    _cmsVEC3minus(&w0, &line1 ->a, &line2 ->a);\n\n    a  = _cmsVEC3dot(&line1 ->u, &line1 ->u);\n    b  = _cmsVEC3dot(&line1 ->u, &line2 ->u);\n    c  = _cmsVEC3dot(&line2 ->u, &line2 ->u);\n    d  = _cmsVEC3dot(&line1 ->u, &w0);\n    e  = _cmsVEC3dot(&line2 ->u, &w0);\n\n    D  = a*c - b * b;      // Denominator\n    sD = tD = D;           // default sD = D >= 0\n\n    if (D <  MATRIX_DET_TOLERANCE) {   // the lines are almost parallel\n\n        sN = 0.0;        // force using point P0 on segment S1\n        sD = 1.0;        // to prevent possible division by 0.0 later\n        tN = e;\n        tD = c;\n    }\n    else {                // get the closest points on the infinite lines\n\n        sN = (b*e - c*d);\n        tN = (a*e - b*d);\n\n        if (sN < 0.0) {       // sc < 0 => the s=0 edge is visible\n\n            sN = 0.0;\n            tN = e;\n            tD = c;\n        }\n        else if (sN > sD) {   // sc > 1 => the s=1 edge is visible\n            sN = sD;\n            tN = e + b;\n            tD = c;\n        }\n    }\n\n    if (tN < 0.0) {           // tc < 0 => the t=0 edge is visible\n\n        tN = 0.0;\n        // recompute sc for this edge\n        if (-d < 0.0)\n            sN = 0.0;\n        else if (-d > a)\n            sN = sD;\n        else {\n            sN = -d;\n            sD = a;\n        }\n    }\n    else if (tN > tD) {      // tc > 1 => the t=1 edge is visible\n\n        tN = tD;\n\n        // recompute sc for this edge\n        if ((-d + b) < 0.0)\n            sN = 0;\n        else if ((-d + b) > a)\n            sN = sD;\n        else {\n            sN = (-d + b);\n            sD = a;\n        }\n    }\n    // finally do the division to get sc and tc\n    sc = (fabs(sN) < MATRIX_DET_TOLERANCE ? 0.0 : sN / sD);\n    //tc = (fabs(tN) < MATRIX_DET_TOLERANCE ? 0.0 : tN / tD); // left for future use.\n\n    GetPointOfLine(r, line1, sc);\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              215,
              0
            ],
            [
              293,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ClosestLineToLine",
            "parameters": {
              "r": "cmsVEC3",
              "line1": "cmsLine",
              "line2": "cmsLine"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsHANDLE  CMSEXPORT cmsGBDAlloc(cmsContext ContextID)\n{\n    cmsGDB* gbd = (cmsGDB*) _cmsMallocZero(ContextID, sizeof(cmsGDB));\n    if (gbd == NULL) return NULL;\n\n    gbd -> ContextID = ContextID;\n\n    return (cmsHANDLE) gbd;\n}",
          "fn_code_pos": [
            [
              301,
              0
            ],
            [
              309,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGBDAlloc",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "cmsHANDLE"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsGBDFree(cmsHANDLE hGBD)\n{\n    cmsGDB* gbd = (cmsGDB*) hGBD;\n    if (hGBD != NULL)\n        _cmsFree(gbd->ContextID, (void*) gbd);\n}",
          "fn_code_pos": [
            [
              312,
              0
            ],
            [
              317,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGBDFree",
            "parameters": {
              "hGBD": "cmsHANDLE"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "GetPoint(cmsGDB* gbd, const cmsCIELab* Lab, cmsSpherical* sp)",
          "fn_dec_pos": [
            [
              322,
              13
            ],
            [
              322,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetPoint",
            "parameters": {
              "gbd": "cmsGDB",
              "Lab": "cmsCIELab",
              "sp": "cmsSpherical"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\n    cmsFloat64Number r;\n    cmsFloat64Number alpha;\n    cmsFloat64Number theta;\n\n} cmsSpherical;",
          {
            "r": "cmsFloat64Number",
            "alpha": "cmsFloat64Number",
            "theta": "cmsFloat64Number"
          },
          "cmsSpherical",
          [
            41,
            0
          ],
          [
            47,
            15
          ]
        ],
        [
          "typedef struct {\n\n    GDBPointType Type;\n    cmsSpherical p;         // Keep also alpha & theta of maximum\n\n} cmsGDBPoint;",
          {
            "Type": "GDBPointType",
            "p": "cmsSpherical"
          },
          "cmsGDBPoint",
          [
            57,
            0
          ],
          [
            62,
            14
          ]
        ],
        [
          "typedef struct {\n\n    cmsContext ContextID;\n    cmsGDBPoint Gamut[SECTORS][SECTORS];\n\n} cmsGDB;",
          {
            "ContextID": "cmsContext",
            "Gamut[SECTORS][SECTORS]": "cmsGDBPoint"
          },
          "cmsGDB",
          [
            65,
            0
          ],
          [
            70,
            9
          ]
        ],
        [
          "typedef struct {\n\n    cmsVEC3 a;\n    cmsVEC3 u;\n\n} cmsLine;",
          {
            "a": "cmsVEC3",
            "u": "cmsVEC3"
          },
          "cmsLine",
          [
            75,
            0
          ],
          [
            80,
            10
          ]
        ],
        [
          "typedef struct {\n\n    cmsVEC3 b;\n    cmsVEC3 v;\n    cmsVEC3 w;\n\n} cmsPlane;",
          {
            "b": "cmsVEC3",
            "v": "cmsVEC3",
            "w": "cmsVEC3"
          },
          "cmsPlane",
          [
            85,
            0
          ],
          [
            91,
            11
          ]
        ],
        [
          "typedef struct {\n\n    cmsFloat64Number r;\n    cmsFloat64Number alpha;\n    cmsFloat64Number theta;\n\n} cmsSpherical;",
          {
            "r": "cmsFloat64Number",
            "alpha": "cmsFloat64Number",
            "theta": "cmsFloat64Number"
          },
          "cmsSpherical",
          [
            41,
            0
          ],
          [
            47,
            15
          ]
        ],
        [
          "typedef struct {\n\n    GDBPointType Type;\n    cmsSpherical p;         // Keep also alpha & theta of maximum\n\n} cmsGDBPoint;",
          {
            "Type": "GDBPointType",
            "p": "cmsSpherical"
          },
          "cmsGDBPoint",
          [
            57,
            0
          ],
          [
            62,
            14
          ]
        ],
        [
          "typedef struct {\n\n    cmsContext ContextID;\n    cmsGDBPoint Gamut[SECTORS][SECTORS];\n\n} cmsGDB;",
          {
            "ContextID": "cmsContext",
            "Gamut[SECTORS][SECTORS]": "cmsGDBPoint"
          },
          "cmsGDB",
          [
            65,
            0
          ],
          [
            70,
            9
          ]
        ],
        [
          "typedef struct {\n\n    cmsVEC3 a;\n    cmsVEC3 u;\n\n} cmsLine;",
          {
            "a": "cmsVEC3",
            "u": "cmsVEC3"
          },
          "cmsLine",
          [
            75,
            0
          ],
          [
            80,
            10
          ]
        ],
        [
          "typedef struct {\n\n    cmsVEC3 b;\n    cmsVEC3 v;\n    cmsVEC3 w;\n\n} cmsPlane;",
          {
            "b": "cmsVEC3",
            "v": "cmsVEC3",
            "w": "cmsVEC3"
          },
          "cmsPlane",
          [
            85,
            0
          ],
          [
            91,
            11
          ]
        ],
        [
          "struct _spiral",
          {},
          "",
          [
            436,
            40
          ],
          [
            436,
            54
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef  enum {\n        GP_EMPTY,\n        GP_SPECIFIED,\n        GP_MODELED\n\n    } GDBPointType;",
          {
            "GP_EMPTY": "",
            "GP_SPECIFIED": "",
            "GP_MODELED": ""
          },
          "GDBPointType",
          [
            49,
            0
          ],
          [
            54,
            19
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmsvirt.c": {
      "fn_def_list": [
        {
          "fn_code": "static\ncmsBool SetTextTags(cmsHPROFILE hProfile, const wchar_t* Description)\n{\n    cmsMLU *DescriptionMLU, *CopyrightMLU;\n    cmsBool  rc = FALSE;\n    cmsContext ContextID = cmsGetProfileContextID(hProfile);\n\n    DescriptionMLU  = cmsMLUalloc(ContextID, 1);\n    CopyrightMLU    = cmsMLUalloc(ContextID, 1);\n\n    if (DescriptionMLU == NULL || CopyrightMLU == NULL) goto Error;\n\n    if (!cmsMLUsetWide(DescriptionMLU,  \"en\", \"US\", Description)) goto Error;\n    if (!cmsMLUsetWide(CopyrightMLU,    \"en\", \"US\", L\"No copyright, use freely\")) goto Error;\n\n    if (!cmsWriteTag(hProfile, cmsSigProfileDescriptionTag,  DescriptionMLU)) goto Error;\n    if (!cmsWriteTag(hProfile, cmsSigCopyrightTag,           CopyrightMLU)) goto Error;\n\n    rc = TRUE;\n\nError:\n\n    if (DescriptionMLU)\n        cmsMLUfree(DescriptionMLU);\n    if (CopyrightMLU)\n        cmsMLUfree(CopyrightMLU);\n    return rc;\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              58,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetTextTags",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Description": "wchar_t"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool  SetSeqDescTag(cmsHPROFILE hProfile, const char* Model)\n{\n    cmsBool  rc = FALSE;\n    cmsContext ContextID = cmsGetProfileContextID(hProfile);\n    cmsSEQ* Seq = cmsAllocProfileSequenceDescription(ContextID, 1);\n\n    if (Seq == NULL) return FALSE;\n\n    Seq->seq[0].deviceMfg = (cmsSignature) 0;\n    Seq->seq[0].deviceModel = (cmsSignature) 0;\n\n#ifdef CMS_DONT_USE_INT64\n    Seq->seq[0].attributes[0] = 0;\n    Seq->seq[0].attributes[1] = 0;\n#else\n    Seq->seq[0].attributes = 0;\n#endif\n\n    Seq->seq[0].technology = (cmsTechnologySignature) 0;\n\n    cmsMLUsetASCII( Seq->seq[0].Manufacturer, cmsNoLanguage, cmsNoCountry, \"Little CMS\");\n    cmsMLUsetASCII( Seq->seq[0].Model,        cmsNoLanguage, cmsNoCountry, Model);\n\n    if (!_cmsWriteProfileSequence(hProfile, Seq)) goto Error;\n\n    rc = TRUE;\n\nError:\n    if (Seq)\n        cmsFreeProfileSequenceDescription(Seq);\n\n    return rc;\n}",
          "fn_code_pos": [
            [
              61,
              0
            ],
            [
              94,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetSeqDescTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Model": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateRGBProfileTHR(cmsContext ContextID,\n                                          const cmsCIExyY* WhitePoint,\n                                          const cmsCIExyYTRIPLE* Primaries,\n                                          cmsToneCurve* const TransferFunction[3])\n{\n    cmsHPROFILE hICC;\n    cmsMAT3 MColorants;\n    cmsCIEXYZTRIPLE Colorants;\n    cmsCIExyY MaxWhite;\n    cmsMAT3 CHAD;\n    cmsCIEXYZ WhitePointXYZ;\n\n    hICC = cmsCreateProfilePlaceholder(ContextID);\n    if (!hICC)                          // can't allocate\n        return NULL;\n\n    cmsSetProfileVersion(hICC, 4.4);\n\n    cmsSetDeviceClass(hICC,      cmsSigDisplayClass);\n    cmsSetColorSpace(hICC,       cmsSigRgbData);\n    cmsSetPCS(hICC,              cmsSigXYZData);\n\n    cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL);\n\n\n    // Implement profile using following tags:\n    //\n    //  1 cmsSigProfileDescriptionTag\n    //  2 cmsSigMediaWhitePointTag\n    //  3 cmsSigRedColorantTag\n    //  4 cmsSigGreenColorantTag\n    //  5 cmsSigBlueColorantTag\n    //  6 cmsSigRedTRCTag\n    //  7 cmsSigGreenTRCTag\n    //  8 cmsSigBlueTRCTag\n    //  9 Chromatic adaptation Tag\n    // This conforms a standard RGB DisplayProfile as says ICC, and then I add (As per addendum II)\n    // 10 cmsSigChromaticityTag\n\n\n    if (!SetTextTags(hICC, L\"RGB built-in\")) goto Error;\n\n    if (WhitePoint) {\n\n        if (!cmsWriteTag(hICC, cmsSigMediaWhitePointTag, cmsD50_XYZ())) goto Error;\n\n        cmsxyY2XYZ(&WhitePointXYZ, WhitePoint);\n        _cmsAdaptationMatrix(&CHAD, NULL, &WhitePointXYZ, cmsD50_XYZ());\n\n        // This is a V4 tag, but many CMM does read and understand it no matter which version\n        if (!cmsWriteTag(hICC, cmsSigChromaticAdaptationTag, (void*) &CHAD)) goto Error;\n    }\n\n    if (WhitePoint && Primaries) {\n\n        MaxWhite.x =  WhitePoint -> x;\n        MaxWhite.y =  WhitePoint -> y;\n        MaxWhite.Y =  1.0;\n\n        if (!_cmsBuildRGB2XYZtransferMatrix(&MColorants, &MaxWhite, Primaries)) goto Error;\n\n        Colorants.Red.X   = MColorants.v[0].n[0];\n        Colorants.Red.Y   = MColorants.v[1].n[0];\n        Colorants.Red.Z   = MColorants.v[2].n[0];\n\n        Colorants.Green.X = MColorants.v[0].n[1];\n        Colorants.Green.Y = MColorants.v[1].n[1];\n        Colorants.Green.Z = MColorants.v[2].n[1];\n\n        Colorants.Blue.X  = MColorants.v[0].n[2];\n        Colorants.Blue.Y  = MColorants.v[1].n[2];\n        Colorants.Blue.Z  = MColorants.v[2].n[2];\n\n        if (!cmsWriteTag(hICC, cmsSigRedColorantTag,   (void*) &Colorants.Red)) goto Error;\n        if (!cmsWriteTag(hICC, cmsSigBlueColorantTag,  (void*) &Colorants.Blue)) goto Error;\n        if (!cmsWriteTag(hICC, cmsSigGreenColorantTag, (void*) &Colorants.Green)) goto Error;\n    }\n\n\n    if (TransferFunction) {\n\n        // Tries to minimize space. Thanks to Richard Hughes for this nice idea         \n        if (!cmsWriteTag(hICC, cmsSigRedTRCTag,   (void*) TransferFunction[0])) goto Error;\n\n        if (TransferFunction[1] == TransferFunction[0]) {\n\n            if (!cmsLinkTag (hICC, cmsSigGreenTRCTag, cmsSigRedTRCTag)) goto Error;\n\n        } else {\n\n            if (!cmsWriteTag(hICC, cmsSigGreenTRCTag, (void*) TransferFunction[1])) goto Error;\n        }\n\n        if (TransferFunction[2] == TransferFunction[0]) {\n\n            if (!cmsLinkTag (hICC, cmsSigBlueTRCTag, cmsSigRedTRCTag)) goto Error;\n\n        } else {\n\n            if (!cmsWriteTag(hICC, cmsSigBlueTRCTag, (void*) TransferFunction[2])) goto Error;\n        }\n    }\n\n    if (Primaries) {\n        if (!cmsWriteTag(hICC, cmsSigChromaticityTag, (void*) Primaries)) goto Error;\n    }\n\n\n    return hICC;\n\nError:\n    if (hICC)\n        cmsCloseProfile(hICC);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              100,
              0
            ],
            [
              214,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateRGBProfileTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "WhitePoint": "cmsCIExyY",
              "Primaries": "cmsCIExyYTRIPLE",
              "TransferFunction": "cmsToneCurve"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateRGBProfile(const cmsCIExyY* WhitePoint,\n                                          const cmsCIExyYTRIPLE* Primaries,\n                                          cmsToneCurve* const TransferFunction[3])\n{\n    return cmsCreateRGBProfileTHR(NULL, WhitePoint, Primaries, TransferFunction);\n}",
          "fn_code_pos": [
            [
              216,
              0
            ],
            [
              221,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateRGBProfile",
            "parameters": {
              "WhitePoint": "cmsCIExyY",
              "Primaries": "cmsCIExyYTRIPLE",
              "TransferFunction": "cmsToneCurve"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateGrayProfileTHR(cmsContext ContextID,\n                                           const cmsCIExyY* WhitePoint,\n                                           const cmsToneCurve* TransferFunction)\n{\n    cmsHPROFILE hICC;\n    cmsCIEXYZ tmp;\n\n    hICC = cmsCreateProfilePlaceholder(ContextID);\n    if (!hICC)                          // can't allocate\n        return NULL;\n\n    cmsSetProfileVersion(hICC, 4.4);\n\n    cmsSetDeviceClass(hICC,      cmsSigDisplayClass);\n    cmsSetColorSpace(hICC,       cmsSigGrayData);\n    cmsSetPCS(hICC,              cmsSigXYZData);\n    cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL);\n\n\n    // Implement profile using following tags:\n    //\n    //  1 cmsSigProfileDescriptionTag\n    //  2 cmsSigMediaWhitePointTag\n    //  3 cmsSigGrayTRCTag\n\n    // This conforms a standard Gray DisplayProfile\n\n    // Fill-in the tags\n\n    if (!SetTextTags(hICC, L\"gray built-in\")) goto Error;\n\n\n    if (WhitePoint) {\n\n        cmsxyY2XYZ(&tmp, WhitePoint);\n        if (!cmsWriteTag(hICC, cmsSigMediaWhitePointTag, (void*) &tmp)) goto Error;\n    }\n\n    if (TransferFunction) {\n\n        if (!cmsWriteTag(hICC, cmsSigGrayTRCTag, (void*) TransferFunction)) goto Error;\n    }\n\n    return hICC;\n\nError:\n    if (hICC)\n        cmsCloseProfile(hICC);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              226,
              0
            ],
            [
              275,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateGrayProfileTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "WhitePoint": "cmsCIExyY",
              "TransferFunction": "cmsToneCurve"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateGrayProfile(const cmsCIExyY* WhitePoint,\n                                                    const cmsToneCurve* TransferFunction)\n{\n    return cmsCreateGrayProfileTHR(NULL, WhitePoint, TransferFunction);\n}",
          "fn_code_pos": [
            [
              279,
              0
            ],
            [
              283,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateGrayProfile",
            "parameters": {
              "WhitePoint": "cmsCIExyY",
              "TransferFunction": "cmsToneCurve"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateLinearizationDeviceLinkTHR(cmsContext ContextID,\n                                                          cmsColorSpaceSignature ColorSpace,\n                                                          cmsToneCurve* const TransferFunctions[])\n{\n    cmsHPROFILE hICC;\n    cmsPipeline* Pipeline;\n    cmsInt32Number nChannels;\n\n    hICC = cmsCreateProfilePlaceholder(ContextID);\n    if (!hICC)\n        return NULL;\n\n    cmsSetProfileVersion(hICC, 4.4);\n\n    cmsSetDeviceClass(hICC,      cmsSigLinkClass);\n    cmsSetColorSpace(hICC,       ColorSpace);\n    cmsSetPCS(hICC,              ColorSpace);\n\n    cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL);\n\n    // Set up channels\n    nChannels = cmsChannelsOfColorSpace(ColorSpace);\n\n    // Creates a Pipeline with prelinearization step only\n    Pipeline = cmsPipelineAlloc(ContextID, nChannels, nChannels);\n    if (Pipeline == NULL) goto Error;\n\n\n    // Copy tables to Pipeline\n    if (!cmsPipelineInsertStage(Pipeline, cmsAT_BEGIN, cmsStageAllocToneCurves(ContextID, nChannels, TransferFunctions)))\n        goto Error;\n\n    // Create tags\n    if (!SetTextTags(hICC, L\"Linearization built-in\")) goto Error;\n    if (!cmsWriteTag(hICC, cmsSigAToB0Tag, (void*) Pipeline)) goto Error;\n    if (!SetSeqDescTag(hICC, \"Linearization built-in\")) goto Error;\n\n    // Pipeline is already on virtual profile\n    cmsPipelineFree(Pipeline);\n\n    // Ok, done\n    return hICC;\n\nError:\n    cmsPipelineFree(Pipeline);\n    if (hICC)\n        cmsCloseProfile(hICC);\n\n\n    return NULL;\n}",
          "fn_code_pos": [
            [
              287,
              0
            ],
            [
              337,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateLinearizationDeviceLinkTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "ColorSpace": "cmsColorSpaceSignature",
              "TransferFunctions": "cmsToneCurve"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateLinearizationDeviceLink(cmsColorSpaceSignature ColorSpace,\n                                                                 cmsToneCurve* const TransferFunctions[])\n{\n    return cmsCreateLinearizationDeviceLinkTHR(NULL, ColorSpace, TransferFunctions);\n}",
          "fn_code_pos": [
            [
              339,
              0
            ],
            [
              343,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateLinearizationDeviceLink",
            "parameters": {
              "ColorSpace": "cmsColorSpaceSignature",
              "TransferFunctions": "cmsToneCurve"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "static\nint InkLimitingSampler(CMSREGISTER const cmsUInt16Number In[], CMSREGISTER cmsUInt16Number Out[], CMSREGISTER void* Cargo)\n{\n    cmsFloat64Number InkLimit = *(cmsFloat64Number *) Cargo;\n    cmsFloat64Number SumCMY, SumCMYK, Ratio;\n\n    InkLimit = (InkLimit * 655.35);\n\n    SumCMY   = (cmsFloat64Number) In[0]  + In[1] + In[2];\n    SumCMYK  = SumCMY + In[3];\n\n    if (SumCMYK > InkLimit) {\n\n        Ratio = 1 - ((SumCMYK - InkLimit) / SumCMY);\n        if (Ratio < 0)\n            Ratio = 0;\n    }\n    else Ratio = 1;\n\n    Out[0] = _cmsQuickSaturateWord(In[0] * Ratio);     // C\n    Out[1] = _cmsQuickSaturateWord(In[1] * Ratio);     // M\n    Out[2] = _cmsQuickSaturateWord(In[2] * Ratio);     // Y\n\n    Out[3] = In[3];                                    // K (untouched)\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              362,
              0
            ],
            [
              388,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "InkLimitingSampler",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateInkLimitingDeviceLinkTHR(cmsContext ContextID,\n                                                     cmsColorSpaceSignature ColorSpace,\n                                                     cmsFloat64Number Limit)\n{\n    cmsHPROFILE hICC;\n    cmsPipeline* LUT;\n    cmsStage* CLUT;\n    cmsInt32Number nChannels;\n\n    if (ColorSpace != cmsSigCmykData) {\n        cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, \"InkLimiting: Only CMYK currently supported\");\n        return NULL;\n    }\n\n    if (Limit < 1.0 || Limit > 400) {\n\n        cmsSignalError(ContextID, cmsERROR_RANGE, \"InkLimiting: Limit should be between 1..400\");\n        if (Limit < 1) Limit = 1;\n        if (Limit > 400) Limit = 400;\n    }\n\n    hICC = cmsCreateProfilePlaceholder(ContextID);\n    if (!hICC)                          // can't allocate\n        return NULL;\n\n    cmsSetProfileVersion(hICC, 4.4);\n\n    cmsSetDeviceClass(hICC,      cmsSigLinkClass);\n    cmsSetColorSpace(hICC,       ColorSpace);\n    cmsSetPCS(hICC,              ColorSpace);\n\n    cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL);\n\n\n    // Creates a Pipeline with 3D grid only\n    LUT = cmsPipelineAlloc(ContextID, 4, 4);\n    if (LUT == NULL) goto Error;\n\n\n    nChannels = cmsChannelsOf(ColorSpace);\n\n    CLUT = cmsStageAllocCLut16bit(ContextID, 17, nChannels, nChannels, NULL);\n    if (CLUT == NULL) goto Error;\n\n    if (!cmsStageSampleCLut16bit(CLUT, InkLimitingSampler, (void*) &Limit, 0)) goto Error;\n\n    if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, nChannels)) ||\n        !cmsPipelineInsertStage(LUT, cmsAT_END, CLUT) ||\n        !cmsPipelineInsertStage(LUT, cmsAT_END, _cmsStageAllocIdentityCurves(ContextID, nChannels)))\n        goto Error;\n\n    // Create tags\n    if (!SetTextTags(hICC, L\"ink-limiting built-in\")) goto Error;\n\n    if (!cmsWriteTag(hICC, cmsSigAToB0Tag, (void*) LUT))  goto Error;\n    if (!SetSeqDescTag(hICC, \"ink-limiting built-in\")) goto Error;\n\n    // cmsPipeline is already on virtual profile\n    cmsPipelineFree(LUT);\n\n    // Ok, done\n    return hICC;\n\nError:\n    if (LUT != NULL)\n        cmsPipelineFree(LUT);\n\n    if (hICC != NULL)\n        cmsCloseProfile(hICC);\n\n    return NULL;\n}",
          "fn_code_pos": [
            [
              392,
              0
            ],
            [
              463,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateInkLimitingDeviceLinkTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "ColorSpace": "cmsColorSpaceSignature",
              "Limit": "cmsFloat64Number"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateInkLimitingDeviceLink(cmsColorSpaceSignature ColorSpace, cmsFloat64Number Limit)\n{\n    return cmsCreateInkLimitingDeviceLinkTHR(NULL, ColorSpace, Limit);\n}",
          "fn_code_pos": [
            [
              465,
              0
            ],
            [
              468,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateInkLimitingDeviceLink",
            "parameters": {
              "ColorSpace": "cmsColorSpaceSignature",
              "Limit": "cmsFloat64Number"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateLab2ProfileTHR(cmsContext ContextID, const cmsCIExyY* WhitePoint)\n{\n    cmsHPROFILE hProfile;\n    cmsPipeline* LUT = NULL;\n\n    hProfile = cmsCreateRGBProfileTHR(ContextID, WhitePoint == NULL ? cmsD50_xyY() : WhitePoint, NULL, NULL);\n    if (hProfile == NULL) return NULL;\n\n    cmsSetProfileVersion(hProfile, 2.1);\n\n    cmsSetDeviceClass(hProfile, cmsSigAbstractClass);\n    cmsSetColorSpace(hProfile,  cmsSigLabData);\n    cmsSetPCS(hProfile,         cmsSigLabData);\n\n    if (!SetTextTags(hProfile, L\"Lab identity built-in\")) return NULL;\n\n    // An identity LUT is all we need\n    LUT = cmsPipelineAlloc(ContextID, 3, 3);\n    if (LUT == NULL) goto Error;\n\n    if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCLut(ContextID, 3)))\n        goto Error;\n\n    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, LUT)) goto Error;\n    cmsPipelineFree(LUT);\n\n    return hProfile;\n\nError:\n\n    if (LUT != NULL)\n        cmsPipelineFree(LUT);\n\n    if (hProfile != NULL)\n        cmsCloseProfile(hProfile);\n\n    return NULL;\n}",
          "fn_code_pos": [
            [
              472,
              0
            ],
            [
              509,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateLab2ProfileTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "WhitePoint": "cmsCIExyY"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateLab2Profile(const cmsCIExyY* WhitePoint)\n{\n    return cmsCreateLab2ProfileTHR(NULL, WhitePoint);\n}",
          "fn_code_pos": [
            [
              512,
              0
            ],
            [
              515,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateLab2Profile",
            "parameters": {
              "WhitePoint": "cmsCIExyY"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateLab4ProfileTHR(cmsContext ContextID, const cmsCIExyY* WhitePoint)\n{\n    cmsHPROFILE hProfile;\n    cmsPipeline* LUT = NULL;\n\n    hProfile = cmsCreateRGBProfileTHR(ContextID, WhitePoint == NULL ? cmsD50_xyY() : WhitePoint, NULL, NULL);\n    if (hProfile == NULL) return NULL;\n\n    cmsSetProfileVersion(hProfile, 4.4);\n\n    cmsSetDeviceClass(hProfile, cmsSigAbstractClass);\n    cmsSetColorSpace(hProfile,  cmsSigLabData);\n    cmsSetPCS(hProfile,         cmsSigLabData);\n\n    if (!SetTextTags(hProfile, L\"Lab identity built-in\")) goto Error;\n\n    // An empty LUTs is all we need\n    LUT = cmsPipelineAlloc(ContextID, 3, 3);\n    if (LUT == NULL) goto Error;\n\n    if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, 3)))\n        goto Error;\n\n    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, LUT)) goto Error;\n    cmsPipelineFree(LUT);\n\n    return hProfile;\n\nError:\n\n    if (LUT != NULL)\n        cmsPipelineFree(LUT);\n\n    if (hProfile != NULL)\n        cmsCloseProfile(hProfile);\n\n    return NULL;\n}",
          "fn_code_pos": [
            [
              519,
              0
            ],
            [
              556,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateLab4ProfileTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "WhitePoint": "cmsCIExyY"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateLab4Profile(const cmsCIExyY* WhitePoint)\n{\n    return cmsCreateLab4ProfileTHR(NULL, WhitePoint);\n}",
          "fn_code_pos": [
            [
              558,
              0
            ],
            [
              561,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateLab4Profile",
            "parameters": {
              "WhitePoint": "cmsCIExyY"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateXYZProfileTHR(cmsContext ContextID)\n{\n    cmsHPROFILE hProfile;\n    cmsPipeline* LUT = NULL;\n\n    hProfile = cmsCreateRGBProfileTHR(ContextID, cmsD50_xyY(), NULL, NULL);\n    if (hProfile == NULL) return NULL;\n\n    cmsSetProfileVersion(hProfile, 4.4);\n\n    cmsSetDeviceClass(hProfile, cmsSigAbstractClass);\n    cmsSetColorSpace(hProfile,  cmsSigXYZData);\n    cmsSetPCS(hProfile,         cmsSigXYZData);\n\n    if (!SetTextTags(hProfile, L\"XYZ identity built-in\")) goto Error;\n\n    // An identity LUT is all we need\n    LUT = cmsPipelineAlloc(ContextID, 3, 3);\n    if (LUT == NULL) goto Error;\n\n    if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, 3)))\n        goto Error;\n\n    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, LUT)) goto Error;\n    cmsPipelineFree(LUT);\n\n    return hProfile;\n\nError:\n\n    if (LUT != NULL)\n        cmsPipelineFree(LUT);\n\n    if (hProfile != NULL)\n        cmsCloseProfile(hProfile);\n\n    return NULL;\n}",
          "fn_code_pos": [
            [
              565,
              0
            ],
            [
              602,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateXYZProfileTHR",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateXYZProfile(void)\n{\n    return cmsCreateXYZProfileTHR(NULL);\n}",
          "fn_code_pos": [
            [
              605,
              0
            ],
            [
              608,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateXYZProfile",
            "parameters": {},
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "static\ncmsToneCurve* Build_sRGBGamma(cmsContext ContextID)\n{\n    cmsFloat64Number Parameters[5];\n\n    Parameters[0] = 2.4;\n    Parameters[1] = 1. / 1.055;\n    Parameters[2] = 0.055 / 1.055;\n    Parameters[3] = 1. / 12.92;\n    Parameters[4] = 0.04045;\n\n    return cmsBuildParametricToneCurve(ContextID, 4, Parameters);\n}",
          "fn_code_pos": [
            [
              626,
              0
            ],
            [
              638,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Build_sRGBGamma",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "cmsToneCurve"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreate_sRGBProfileTHR(cmsContext ContextID)\n{\n       cmsCIExyY       D65 = { 0.3127, 0.3290, 1.0 };\n       cmsCIExyYTRIPLE Rec709Primaries = {\n                                   {0.6400, 0.3300, 1.0},\n                                   {0.3000, 0.6000, 1.0},\n                                   {0.1500, 0.0600, 1.0}\n                                   };\n       cmsToneCurve* Gamma22[3];\n       cmsHPROFILE  hsRGB;\n\n      // cmsWhitePointFromTemp(&D65, 6504);\n       Gamma22[0] = Gamma22[1] = Gamma22[2] = Build_sRGBGamma(ContextID);\n       if (Gamma22[0] == NULL) return NULL;\n\n       hsRGB = cmsCreateRGBProfileTHR(ContextID, &D65, &Rec709Primaries, Gamma22);\n       cmsFreeToneCurve(Gamma22[0]);\n       if (hsRGB == NULL) return NULL;\n\n       if (!SetTextTags(hsRGB, L\"sRGB built-in\")) {\n           cmsCloseProfile(hsRGB);\n           return NULL;\n       }\n\n       return hsRGB;\n}",
          "fn_code_pos": [
            [
              641,
              0
            ],
            [
              666,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreate_sRGBProfileTHR",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreate_sRGBProfile(void)\n{\n    return cmsCreate_sRGBProfileTHR(NULL);\n}",
          "fn_code_pos": [
            [
              668,
              0
            ],
            [
              671,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreate_sRGBProfile",
            "parameters": {},
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreate_OkLabProfile(cmsContext ctx)\n{\n    cmsStage* XYZPCS = _cmsStageNormalizeFromXyzFloat(ctx);\n    cmsStage* PCSXYZ = _cmsStageNormalizeToXyzFloat(ctx);\n\n    const double M_D65_D50[] =\n    {\n       1.047886, 0.022919, -0.050216,\n       0.029582, 0.990484, -0.017079,\n      -0.009252, 0.015073,  0.751678\n    };\n\n    const double M_D50_D65[] =\n    {\n         0.955512609517083, -0.023073214184645,  0.063308961782107,\n        -0.028324949364887,  1.009942432477107,  0.021054814890112,\n         0.012328875695483, -0.020535835374141,  1.330713916450354\n    };\n\n    cmsStage* D65toD50 = cmsStageAllocMatrix(ctx, 3, 3, M_D65_D50, NULL);\n    cmsStage* D50toD65 = cmsStageAllocMatrix(ctx, 3, 3, M_D50_D65, NULL);\n\n    const double M_D65_LMS[] =\n    {\n        0.8189330101, 0.3618667424, -0.1288597137,\n        0.0329845436, 0.9293118715,  0.0361456387,\n        0.0482003018, 0.2643662691,  0.6338517070\n    };\n   \n    const double M_LMS_D65[] =\n    {\n        1.227013851103521, -0.557799980651822,  0.281256148966468,\n       -0.040580178423281,  1.112256869616830, -0.071676678665601,\n       -0.076381284505707, -0.421481978418013,  1.586163220440795\n    };\n\n    cmsStage* D65toLMS = cmsStageAllocMatrix(ctx, 3, 3, M_D65_LMS, NULL);\n    cmsStage* LMStoD65 = cmsStageAllocMatrix(ctx, 3, 3, M_LMS_D65, NULL);\n\n    cmsToneCurve* CubeRoot = cmsBuildGamma(ctx, 1.0 / 3.0);\n    cmsToneCurve* Cube     = cmsBuildGamma(ctx,  3.0);\n\n    cmsToneCurve* Roots[3] = { CubeRoot, CubeRoot, CubeRoot };\n    cmsToneCurve* Cubes[3] = { Cube, Cube, Cube };\n\n    cmsStage* NonLinearityFw = cmsStageAllocToneCurves(ctx, 3, Roots);\n    cmsStage* NonLinearityRv = cmsStageAllocToneCurves(ctx, 3, Cubes);\n\n    const double M_LMSprime_OkLab[] =\n    {\n        0.2104542553,  0.7936177850, -0.0040720468,\n        1.9779984951, -2.4285922050,  0.4505937099,\n        0.0259040371,  0.7827717662, -0.8086757660\n    };\n\n    const double M_OkLab_LMSprime[] =\n    {\n        0.999999998450520,  0.396337792173768,  0.215803758060759,\n        1.000000008881761, -0.105561342323656, -0.063854174771706,\n        1.000000054672411, -0.089484182094966, -1.291485537864092\n    };\n    \n    cmsStage* LMSprime_OkLab = cmsStageAllocMatrix(ctx, 3, 3, M_LMSprime_OkLab, NULL);\n    cmsStage* OkLab_LMSprime = cmsStageAllocMatrix(ctx, 3, 3, M_OkLab_LMSprime, NULL);\n\n    cmsPipeline* AToB = cmsPipelineAlloc(ctx, 3, 3);\n    cmsPipeline* BToA = cmsPipelineAlloc(ctx, 3, 3);\n\n    cmsHPROFILE hProfile = cmsCreateProfilePlaceholder(ctx);\n    if (!hProfile)            // can't allocate\n        goto error;\n  \n    cmsSetProfileVersion(hProfile, 4.4);\n\n    cmsSetDeviceClass(hProfile, cmsSigColorSpaceClass);\n    cmsSetColorSpace(hProfile, cmsSig3colorData);\n    cmsSetPCS(hProfile, cmsSigXYZData);\n\n    cmsSetHeaderRenderingIntent(hProfile, INTENT_RELATIVE_COLORIMETRIC);\n\n    /**\n    * Conversion PCS (XYZ/D50) to OkLab \n    */\n    if (!cmsPipelineInsertStage(BToA, cmsAT_END, PCSXYZ)) goto error;\n    if (!cmsPipelineInsertStage(BToA, cmsAT_END, D50toD65)) goto error;\n    if (!cmsPipelineInsertStage(BToA, cmsAT_END, D65toLMS)) goto error;\n    if (!cmsPipelineInsertStage(BToA, cmsAT_END, NonLinearityFw)) goto error;\n    if (!cmsPipelineInsertStage(BToA, cmsAT_END, LMSprime_OkLab)) goto error;\n\n    if (!cmsWriteTag(hProfile, cmsSigBToA0Tag, BToA)) goto error;\n    \n    if (!cmsPipelineInsertStage(AToB, cmsAT_END, OkLab_LMSprime)) goto error;\n    if (!cmsPipelineInsertStage(AToB, cmsAT_END, NonLinearityRv)) goto error;\n    if (!cmsPipelineInsertStage(AToB, cmsAT_END, LMStoD65)) goto error;\n    if (!cmsPipelineInsertStage(AToB, cmsAT_END, D65toD50)) goto error;\n    if (!cmsPipelineInsertStage(AToB, cmsAT_END, XYZPCS)) goto error;\n\n    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, AToB)) goto error;\n\n    cmsPipelineFree(BToA);\n    cmsPipelineFree(AToB);\n\n    cmsFreeToneCurve(CubeRoot);\n    cmsFreeToneCurve(Cube);\n\n    return hProfile;\n\nerror:\n    cmsPipelineFree(BToA);\n    cmsPipelineFree(AToB);\n\n    cmsFreeToneCurve(CubeRoot);\n    cmsFreeToneCurve(Cube);\n    cmsCloseProfile(hProfile);\n\n    return NULL;\n\n}",
          "fn_code_pos": [
            [
              678,
              0
            ],
            [
              795,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreate_OkLabProfile",
            "parameters": {
              "ctx": "cmsContext"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "static\nint bchswSampler(CMSREGISTER const cmsUInt16Number In[], CMSREGISTER cmsUInt16Number Out[], CMSREGISTER void* Cargo)\n{\n    cmsCIELab LabIn, LabOut;\n    cmsCIELCh LChIn, LChOut;\n    cmsCIEXYZ XYZ;\n    LPBCHSWADJUSTS bchsw = (LPBCHSWADJUSTS) Cargo;\n\n\n    cmsLabEncoded2Float(&LabIn, In);\n\n\n    cmsLab2LCh(&LChIn, &LabIn);\n\n    // Do some adjusts on LCh\n\n    LChOut.L = LChIn.L * bchsw ->Contrast + bchsw ->Brightness;\n    LChOut.C = LChIn.C + bchsw -> Saturation;\n    LChOut.h = LChIn.h + bchsw -> Hue;\n\n\n    cmsLCh2Lab(&LabOut, &LChOut);\n\n    // Move white point in Lab\n    if (bchsw->lAdjustWP) {\n           cmsLab2XYZ(&bchsw->WPsrc, &XYZ, &LabOut);\n           cmsXYZ2Lab(&bchsw->WPdest, &LabOut, &XYZ);\n    }\n\n    // Back to encoded\n\n    cmsFloat2LabEncoded(Out, &LabOut);\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              809,
              0
            ],
            [
              843,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bchswSampler",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateBCHSWabstractProfileTHR(cmsContext ContextID,\n                                                       cmsUInt32Number nLUTPoints,\n                                                       cmsFloat64Number Bright,\n                                                       cmsFloat64Number Contrast,\n                                                       cmsFloat64Number Hue,\n                                                       cmsFloat64Number Saturation,\n                                                       cmsUInt32Number TempSrc,\n                                                       cmsUInt32Number TempDest)\n{\n    cmsHPROFILE hICC;\n    cmsPipeline* Pipeline;\n    BCHSWADJUSTS bchsw;\n    cmsCIExyY WhitePnt;\n    cmsStage* CLUT;\n    cmsUInt32Number Dimensions[MAX_INPUT_DIMENSIONS];\n    cmsUInt32Number i;\n\n    bchsw.Brightness = Bright;\n    bchsw.Contrast   = Contrast;\n    bchsw.Hue        = Hue;\n    bchsw.Saturation = Saturation;\n    if (TempSrc == TempDest) {\n\n           bchsw.lAdjustWP = FALSE;\n    }\n    else {\n           bchsw.lAdjustWP = TRUE;\n           cmsWhitePointFromTemp(&WhitePnt, TempSrc);\n           cmsxyY2XYZ(&bchsw.WPsrc, &WhitePnt);\n           cmsWhitePointFromTemp(&WhitePnt, TempDest);\n           cmsxyY2XYZ(&bchsw.WPdest, &WhitePnt);\n     \n    }\n\n    hICC = cmsCreateProfilePlaceholder(ContextID);\n    if (!hICC)                          // can't allocate\n        return NULL;\n\n    cmsSetDeviceClass(hICC,      cmsSigAbstractClass);\n    cmsSetColorSpace(hICC,       cmsSigLabData);\n    cmsSetPCS(hICC,              cmsSigLabData);\n\n    cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL);\n\n    // Creates a Pipeline with 3D grid only\n    Pipeline = cmsPipelineAlloc(ContextID, 3, 3);\n    if (Pipeline == NULL) {\n        cmsCloseProfile(hICC);\n        return NULL;\n    }\n\n    for (i=0; i < MAX_INPUT_DIMENSIONS; i++) Dimensions[i] = nLUTPoints;\n    CLUT = cmsStageAllocCLut16bitGranular(ContextID, Dimensions, 3, 3, NULL);\n    if (CLUT == NULL) goto Error;\n\n\n    if (!cmsStageSampleCLut16bit(CLUT, bchswSampler, (void*) &bchsw, 0)) {\n\n        // Shouldn't reach here\n        goto Error;\n    }\n\n    if (!cmsPipelineInsertStage(Pipeline, cmsAT_END, CLUT)) {\n        goto Error;\n    }\n\n    // Create tags\n    if (!SetTextTags(hICC, L\"BCHS built-in\")) return NULL;\n\n    cmsWriteTag(hICC, cmsSigMediaWhitePointTag, (void*) cmsD50_XYZ());\n\n    cmsWriteTag(hICC, cmsSigAToB0Tag, (void*) Pipeline);\n\n    // Pipeline is already on virtual profile\n    cmsPipelineFree(Pipeline);\n\n    // Ok, done\n    return hICC;\n\nError:\n    cmsPipelineFree(Pipeline);\n    cmsCloseProfile(hICC);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              849,
              0
            ],
            [
              932,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateBCHSWabstractProfileTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "nLUTPoints": "cmsUInt32Number",
              "Bright": "cmsFloat64Number",
              "Contrast": "cmsFloat64Number",
              "Hue": "cmsFloat64Number",
              "Saturation": "cmsFloat64Number",
              "TempSrc": "cmsUInt32Number",
              "TempDest": "cmsUInt32Number"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "CMSAPI cmsHPROFILE   CMSEXPORT cmsCreateBCHSWabstractProfile(cmsUInt32Number nLUTPoints,\n                                                             cmsFloat64Number Bright,\n                                                             cmsFloat64Number Contrast,\n                                                             cmsFloat64Number Hue,\n                                                             cmsFloat64Number Saturation,\n                                                             cmsUInt32Number TempSrc,\n                                                             cmsUInt32Number TempDest)\n{\n    return cmsCreateBCHSWabstractProfileTHR(NULL, nLUTPoints, Bright, Contrast, Hue, Saturation, TempSrc, TempDest);\n}",
          "fn_code_pos": [
            [
              935,
              0
            ],
            [
              944,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateBCHSWabstractProfile",
            "parameters": {
              "nLUTPoints": "cmsUInt32Number",
              "Bright": "cmsFloat64Number",
              "Contrast": "cmsFloat64Number",
              "Hue": "cmsFloat64Number",
              "Saturation": "cmsFloat64Number",
              "TempSrc": "cmsUInt32Number",
              "TempDest": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateNULLProfileTHR(cmsContext ContextID)\n{\n    cmsHPROFILE hProfile;\n    cmsPipeline* LUT = NULL;\n    cmsStage* PostLin;\n    cmsStage* OutLin;\n    cmsToneCurve* EmptyTab[3];\n    cmsUInt16Number Zero[2] = { 0, 0 };\n    const cmsFloat64Number PickLstarMatrix[] = { 1, 0, 0 };\n\n    hProfile = cmsCreateProfilePlaceholder(ContextID);\n    if (!hProfile)                          // can't allocate\n        return NULL;\n\n    cmsSetProfileVersion(hProfile, 4.4);\n\n    if (!SetTextTags(hProfile, L\"NULL profile built-in\")) goto Error;\n\n\n    cmsSetDeviceClass(hProfile, cmsSigOutputClass);\n    cmsSetColorSpace(hProfile,  cmsSigGrayData);\n    cmsSetPCS(hProfile,         cmsSigLabData);\n\n    // Create a valid ICC 4 structure\n    LUT = cmsPipelineAlloc(ContextID, 3, 1);\n    if (LUT == NULL) goto Error;\n    \n    EmptyTab[0] = EmptyTab[1] = EmptyTab[2] = cmsBuildTabulatedToneCurve16(ContextID, 2, Zero);\n    PostLin = cmsStageAllocToneCurves(ContextID, 3, EmptyTab);\n    OutLin  = cmsStageAllocToneCurves(ContextID, 1, EmptyTab);\n    cmsFreeToneCurve(EmptyTab[0]);\n\n    if (!cmsPipelineInsertStage(LUT, cmsAT_END, PostLin))\n        goto Error;\n\n    if (!cmsPipelineInsertStage(LUT, cmsAT_END, cmsStageAllocMatrix(ContextID, 1, 3, PickLstarMatrix, NULL)))\n        goto Error;\n\n    if (!cmsPipelineInsertStage(LUT, cmsAT_END, OutLin))\n        goto Error;\n\n    if (!cmsWriteTag(hProfile, cmsSigBToA0Tag, (void*) LUT)) goto Error;\n    if (!cmsWriteTag(hProfile, cmsSigMediaWhitePointTag, cmsD50_XYZ())) goto Error;\n\n    cmsPipelineFree(LUT);\n    return hProfile;\n\nError:\n\n    if (LUT != NULL)\n        cmsPipelineFree(LUT);\n\n    if (hProfile != NULL)\n        cmsCloseProfile(hProfile);\n\n    return NULL;\n}",
          "fn_code_pos": [
            [
              949,
              0
            ],
            [
              1005,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateNULLProfileTHR",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateNULLProfile(void)\n{\n    return cmsCreateNULLProfileTHR(NULL);\n}",
          "fn_code_pos": [
            [
              1007,
              0
            ],
            [
              1010,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateNULLProfile",
            "parameters": {},
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "static\nint IsPCS(cmsColorSpaceSignature ColorSpace)\n{\n    return (ColorSpace == cmsSigXYZData ||\n            ColorSpace == cmsSigLabData);\n}",
          "fn_code_pos": [
            [
              1013,
              0
            ],
            [
              1018,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsPCS",
            "parameters": {
              "ColorSpace": "cmsColorSpaceSignature"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nvoid FixColorSpaces(cmsHPROFILE hProfile,\n                              cmsColorSpaceSignature ColorSpace,\n                              cmsColorSpaceSignature PCS,\n                              cmsUInt32Number dwFlags)\n{\n    if (dwFlags & cmsFLAGS_GUESSDEVICECLASS) {\n\n            if (IsPCS(ColorSpace) && IsPCS(PCS)) {\n\n                    cmsSetDeviceClass(hProfile,      cmsSigAbstractClass);\n                    cmsSetColorSpace(hProfile,       ColorSpace);\n                    cmsSetPCS(hProfile,              PCS);\n                    return;\n            }\n\n            if (IsPCS(ColorSpace) && !IsPCS(PCS)) {\n\n                    cmsSetDeviceClass(hProfile, cmsSigOutputClass);\n                    cmsSetPCS(hProfile,         ColorSpace);\n                    cmsSetColorSpace(hProfile,  PCS);\n                    return;\n            }\n\n            if (IsPCS(PCS) && !IsPCS(ColorSpace)) {\n\n                   cmsSetDeviceClass(hProfile,  cmsSigInputClass);\n                   cmsSetColorSpace(hProfile,   ColorSpace);\n                   cmsSetPCS(hProfile,          PCS);\n                   return;\n            }\n    }\n\n    cmsSetDeviceClass(hProfile,      cmsSigLinkClass);\n    cmsSetColorSpace(hProfile,       ColorSpace);\n    cmsSetPCS(hProfile,              PCS);\n}",
          "fn_code_pos": [
            [
              1021,
              0
            ],
            [
              1057,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FixColorSpaces",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "ColorSpace": "cmsColorSpaceSignature",
              "PCS": "cmsColorSpaceSignature",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsHPROFILE CreateNamedColorDevicelink(cmsHTRANSFORM xform)\n{\n    _cmsTRANSFORM* v = (_cmsTRANSFORM*) xform;\n    cmsHPROFILE hICC = NULL;\n    cmsUInt32Number i, nColors;\n    cmsNAMEDCOLORLIST *nc2 = NULL, *Original = NULL;\n\n    // Create an empty placeholder\n    hICC = cmsCreateProfilePlaceholder(v->ContextID);\n    if (hICC == NULL) return NULL;\n\n    // Critical information\n    cmsSetDeviceClass(hICC, cmsSigNamedColorClass);\n    cmsSetColorSpace(hICC, v ->ExitColorSpace);\n    cmsSetPCS(hICC, cmsSigLabData);\n\n    // Tag profile with information\n    if (!SetTextTags(hICC, L\"Named color devicelink\")) goto Error;\n\n    Original = cmsGetNamedColorList(xform);\n    if (Original == NULL) goto Error;\n\n    nColors = cmsNamedColorCount(Original);\n    nc2     = cmsDupNamedColorList(Original);\n    if (nc2 == NULL) goto Error;\n\n    // Colorant count now depends on the output space\n    nc2 ->ColorantCount = cmsPipelineOutputChannels(v ->Lut);\n\n    // Make sure we have proper formatters\n    cmsChangeBuffersFormat(xform, TYPE_NAMED_COLOR_INDEX,\n        FLOAT_SH(0) | COLORSPACE_SH(_cmsLCMScolorSpace(v ->ExitColorSpace))\n        | BYTES_SH(2) | CHANNELS_SH(cmsChannelsOfColorSpace(v ->ExitColorSpace)));\n\n    // Apply the transfor to colorants.\n    for (i=0; i < nColors; i++) {\n        cmsDoTransform(xform, &i, nc2 ->List[i].DeviceColorant, 1);\n    }\n\n    if (!cmsWriteTag(hICC, cmsSigNamedColor2Tag, (void*) nc2)) goto Error;\n    cmsFreeNamedColorList(nc2);\n\n    return hICC;\n\nError:\n    if (hICC != NULL) cmsCloseProfile(hICC);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              1065,
              0
            ],
            [
              1113,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CreateNamedColorDevicelink",
            "parameters": {
              "xform": "cmsHTRANSFORM"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "static\ncmsBool CheckOne(const cmsAllowedLUT* Tab, const cmsPipeline* Lut)\n{\n    cmsStage* mpe;\n    int n;\n\n    for (n=0, mpe = Lut ->Elements; mpe != NULL; mpe = mpe ->Next, n++) {\n\n        if (n >= Tab ->nTypes) return FALSE;\n        if (cmsStageType(mpe) != Tab ->MpeTypes[n]) return FALSE;\n    }\n\n    return (n == Tab ->nTypes);\n}",
          "fn_code_pos": [
            [
              1147,
              0
            ],
            [
              1160,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckOne",
            "parameters": {
              "Tab": "cmsAllowedLUT",
              "Lut": "cmsPipeline"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nconst cmsAllowedLUT* FindCombination(const cmsPipeline* Lut, cmsBool IsV4, cmsTagSignature DestinationTag)\n{\n    cmsUInt32Number n;\n\n    for (n=0; n < SIZE_OF_ALLOWED_LUT; n++) {\n\n        const cmsAllowedLUT* Tab = AllowedLUTTypes + n;\n\n        if (IsV4 ^ Tab -> IsV4) continue;\n        if ((Tab ->RequiredTag != 0) && (Tab ->RequiredTag != DestinationTag)) continue;\n\n        if (CheckOne(Tab, Lut)) return Tab;\n    }\n\n    return NULL;\n}",
          "fn_code_pos": [
            [
              1163,
              0
            ],
            [
              1179,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FindCombination",
            "parameters": {
              "Lut": "cmsPipeline",
              "IsV4": "cmsBool",
              "DestinationTag": "cmsTagSignature"
            },
            "return_type": "cmsAllowedLUT"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsTransform2DeviceLink(cmsHTRANSFORM hTransform, cmsFloat64Number Version, cmsUInt32Number dwFlags)\n{\n    cmsHPROFILE hProfile = NULL;\n    cmsUInt32Number FrmIn, FrmOut;\n    cmsInt32Number ChansIn, ChansOut;\n    int ColorSpaceBitsIn, ColorSpaceBitsOut;\n    _cmsTRANSFORM* xform = (_cmsTRANSFORM*) hTransform;\n    cmsPipeline* LUT = NULL;\n    cmsStage* mpe;\n    cmsContext ContextID = cmsGetTransformContextID(hTransform);\n    const cmsAllowedLUT* AllowedLUT;\n    cmsTagSignature DestinationTag;\n    cmsProfileClassSignature deviceClass; \n\n    _cmsAssert(hTransform != NULL);\n\n    // Check if the pipeline holding is valid\n    if (xform -> Lut == NULL) return NULL;\n\n    // Get the first mpe to check for named color\n    mpe = cmsPipelineGetPtrToFirstStage(xform ->Lut);\n\n    // Check if is a named color transform\n    if (mpe != NULL) {\n\n        if (cmsStageType(mpe) == cmsSigNamedColorElemType) {\n            return CreateNamedColorDevicelink(hTransform);\n        }\n    }\n\n    // First thing to do is to get a copy of the transformation\n    LUT = cmsPipelineDup(xform ->Lut);\n    if (LUT == NULL) return NULL;\n\n    // Time to fix the Lab2/Lab4 issue.\n    if ((xform ->EntryColorSpace == cmsSigLabData) && (Version < 4.0)) {\n\n        if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocLabV2ToV4curves(ContextID)))\n            goto Error;\n    }\n\n    // On the output side too. Note that due to V2/V4 PCS encoding on lab we cannot fix white misalignments\n    if ((xform ->ExitColorSpace) == cmsSigLabData && (Version < 4.0)) {\n\n        dwFlags |= cmsFLAGS_NOWHITEONWHITEFIXUP;\n        if (!cmsPipelineInsertStage(LUT, cmsAT_END, _cmsStageAllocLabV4ToV2(ContextID)))\n            goto Error;\n    }\n\n\n    hProfile = cmsCreateProfilePlaceholder(ContextID);\n    if (!hProfile) goto Error;                    // can't allocate\n\n    cmsSetProfileVersion(hProfile, Version);\n\n    FixColorSpaces(hProfile, xform -> EntryColorSpace, xform -> ExitColorSpace, dwFlags);\n\n    // Optimize the LUT and precalculate a devicelink\n\n    ChansIn  = cmsChannelsOfColorSpace(xform -> EntryColorSpace);\n    ChansOut = cmsChannelsOfColorSpace(xform -> ExitColorSpace);\n\n    ColorSpaceBitsIn  = _cmsLCMScolorSpace(xform -> EntryColorSpace);\n    ColorSpaceBitsOut = _cmsLCMScolorSpace(xform -> ExitColorSpace);\n\n    FrmIn  = COLORSPACE_SH(ColorSpaceBitsIn) | CHANNELS_SH(ChansIn)|BYTES_SH(2);\n    FrmOut = COLORSPACE_SH(ColorSpaceBitsOut) | CHANNELS_SH(ChansOut)|BYTES_SH(2);\n\n    deviceClass = cmsGetDeviceClass(hProfile);\n\n     if (deviceClass == cmsSigOutputClass)\n         DestinationTag = cmsSigBToA0Tag;\n     else\n         DestinationTag = cmsSigAToB0Tag;\n\n    // Check if the profile/version can store the result\n    if (dwFlags & cmsFLAGS_FORCE_CLUT)\n        AllowedLUT = NULL;\n    else\n        AllowedLUT = FindCombination(LUT, Version >= 4.0, DestinationTag);\n\n    if (AllowedLUT == NULL) {\n\n        // Try to optimize\n        _cmsOptimizePipeline(ContextID, &LUT, xform ->RenderingIntent, &FrmIn, &FrmOut, &dwFlags);\n        AllowedLUT = FindCombination(LUT, Version >= 4.0, DestinationTag);\n\n    }\n\n    // If no way, then force CLUT that for sure can be written\n    if (AllowedLUT == NULL) {\n\n        cmsStage* FirstStage;\n        cmsStage* LastStage;\n\n        dwFlags |= cmsFLAGS_FORCE_CLUT;\n        _cmsOptimizePipeline(ContextID, &LUT, xform ->RenderingIntent, &FrmIn, &FrmOut, &dwFlags);\n\n        // Put identity curves if needed\n        FirstStage = cmsPipelineGetPtrToFirstStage(LUT);\n        if (FirstStage != NULL && FirstStage ->Type != cmsSigCurveSetElemType)\n             if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, ChansIn)))\n                 goto Error;\n\n        LastStage = cmsPipelineGetPtrToLastStage(LUT);\n        if (LastStage != NULL && LastStage ->Type != cmsSigCurveSetElemType)\n             if (!cmsPipelineInsertStage(LUT, cmsAT_END,   _cmsStageAllocIdentityCurves(ContextID, ChansOut)))\n                 goto Error;\n\n        AllowedLUT = FindCombination(LUT, Version >= 4.0, DestinationTag);\n    }\n\n    // Somethings is wrong...\n    if (AllowedLUT == NULL) {\n        goto Error;\n    }\n\n\n    if (dwFlags & cmsFLAGS_8BITS_DEVICELINK)\n                     cmsPipelineSetSaveAs8bitsFlag(LUT, TRUE);\n\n    // Tag profile with information\n    if (!SetTextTags(hProfile, L\"devicelink\")) goto Error;\n\n    // Store result\n    if (!cmsWriteTag(hProfile, DestinationTag, LUT)) goto Error;\n\n\n    if (xform -> InputColorant != NULL) {\n           if (!cmsWriteTag(hProfile, cmsSigColorantTableTag, xform->InputColorant)) goto Error;\n    }\n\n    if (xform -> OutputColorant != NULL) {\n           if (!cmsWriteTag(hProfile, cmsSigColorantTableOutTag, xform->OutputColorant)) goto Error;\n    }\n\n    if ((deviceClass == cmsSigLinkClass) && (xform ->Sequence != NULL)) {\n        if (!_cmsWriteProfileSequence(hProfile, xform ->Sequence)) goto Error;\n    }\n\n    // Set the white point\n    if (deviceClass == cmsSigInputClass) {\n        if (!cmsWriteTag(hProfile, cmsSigMediaWhitePointTag, &xform ->EntryWhitePoint)) goto Error;\n    }\n    else {\n         if (!cmsWriteTag(hProfile, cmsSigMediaWhitePointTag, &xform ->ExitWhitePoint)) goto Error;\n    }\n\n  \n    // Per 7.2.15 in spec 4.3\n    cmsSetHeaderRenderingIntent(hProfile, xform ->RenderingIntent);\n\n    cmsPipelineFree(LUT);\n    return hProfile;\n\nError:\n    if (LUT != NULL) cmsPipelineFree(LUT);\n    cmsCloseProfile(hProfile);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              1183,
              0
            ],
            [
              1342,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsTransform2DeviceLink",
            "parameters": {
              "hTransform": "cmsHTRANSFORM",
              "Version": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsHPROFILE"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "Build_sRGBGamma(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              627,
              14
            ],
            [
              627,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Build_sRGBGamma",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FindCombination(const cmsPipeline* Lut, cmsBool IsV4, cmsTagSignature DestinationTag)",
          "fn_dec_pos": [
            [
              1164,
              21
            ],
            [
              1164,
              106
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FindCombination",
            "parameters": {
              "Lut": "cmsPipeline",
              "IsV4": "cmsBool",
              "DestinationTag": "cmsTagSignature"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n                cmsFloat64Number Brightness;\n                cmsFloat64Number Contrast;\n                cmsFloat64Number Hue;\n                cmsFloat64Number Saturation;\n                cmsBool          lAdjustWP;\n                cmsCIEXYZ WPsrc, WPdest;\n\n} BCHSWADJUSTS, *LPBCHSWADJUSTS;",
          {
            "Brightness": "cmsFloat64Number",
            "Contrast": "cmsFloat64Number",
            "Hue": "cmsFloat64Number",
            "Saturation": "cmsFloat64Number",
            "lAdjustWP": "cmsBool",
            "WPsrc": "cmsCIEXYZ"
          },
          "BCHSWADJUSTS",
          [
            798,
            0
          ],
          [
            806,
            32
          ]
        ],
        [
          "typedef struct {\n                cmsFloat64Number Brightness;\n                cmsFloat64Number Contrast;\n                cmsFloat64Number Hue;\n                cmsFloat64Number Saturation;\n                cmsBool          lAdjustWP;\n                cmsCIEXYZ WPsrc, WPdest;\n\n} BCHSWADJUSTS, *LPBCHSWADJUSTS;",
          {
            "Brightness": "cmsFloat64Number",
            "Contrast": "cmsFloat64Number",
            "Hue": "cmsFloat64Number",
            "Saturation": "cmsFloat64Number",
            "lAdjustWP": "cmsBool",
            "WPsrc": "cmsCIEXYZ"
          },
          "LPBCHSWADJUSTS",
          [
            798,
            0
          ],
          [
            806,
            32
          ]
        ],
        [
          "typedef struct {\n    cmsBool              IsV4;             // Is a V4 tag?\n    cmsTagSignature      RequiredTag;      // Set to 0 for both types\n    cmsTagTypeSignature  LutType;          // The LUT type\n    int                  nTypes;           // Number of types (up to 5)\n    cmsStageSignature    MpeTypes[5];      // 5 is the maximum number\n\n} cmsAllowedLUT;",
          {
            "IsV4": "cmsBool",
            "RequiredTag": "cmsTagSignature",
            "LutType": "cmsTagTypeSignature",
            "nTypes": "int",
            "MpeTypes[5]": "cmsStageSignature"
          },
          "cmsAllowedLUT",
          [
            1118,
            0
          ],
          [
            1125,
            16
          ]
        ],
        [
          "typedef struct {\n                cmsFloat64Number Brightness;\n                cmsFloat64Number Contrast;\n                cmsFloat64Number Hue;\n                cmsFloat64Number Saturation;\n                cmsBool          lAdjustWP;\n                cmsCIEXYZ WPsrc, WPdest;\n\n} BCHSWADJUSTS, *LPBCHSWADJUSTS;",
          {
            "Brightness": "cmsFloat64Number",
            "Contrast": "cmsFloat64Number",
            "Hue": "cmsFloat64Number",
            "Saturation": "cmsFloat64Number",
            "lAdjustWP": "cmsBool",
            "WPsrc": "cmsCIEXYZ"
          },
          "BCHSWADJUSTS",
          [
            798,
            0
          ],
          [
            806,
            32
          ]
        ],
        [
          "typedef struct {\n                cmsFloat64Number Brightness;\n                cmsFloat64Number Contrast;\n                cmsFloat64Number Hue;\n                cmsFloat64Number Saturation;\n                cmsBool          lAdjustWP;\n                cmsCIEXYZ WPsrc, WPdest;\n\n} BCHSWADJUSTS, *LPBCHSWADJUSTS;",
          {
            "Brightness": "cmsFloat64Number",
            "Contrast": "cmsFloat64Number",
            "Hue": "cmsFloat64Number",
            "Saturation": "cmsFloat64Number",
            "lAdjustWP": "cmsBool",
            "WPsrc": "cmsCIEXYZ"
          },
          "LPBCHSWADJUSTS",
          [
            798,
            0
          ],
          [
            806,
            32
          ]
        ],
        [
          "typedef struct {\n    cmsBool              IsV4;             // Is a V4 tag?\n    cmsTagSignature      RequiredTag;      // Set to 0 for both types\n    cmsTagTypeSignature  LutType;          // The LUT type\n    int                  nTypes;           // Number of types (up to 5)\n    cmsStageSignature    MpeTypes[5];      // 5 is the maximum number\n\n} cmsAllowedLUT;",
          {
            "IsV4": "cmsBool",
            "RequiredTag": "cmsTagSignature",
            "LutType": "cmsTagTypeSignature",
            "nTypes": "int",
            "MpeTypes[5]": "cmsStageSignature"
          },
          "cmsAllowedLUT",
          [
            1118,
            0
          ],
          [
            1125,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmslut.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nvoid EvaluateIdentity(const cmsFloat32Number In[],\n                            cmsFloat32Number Out[],\n                      const cmsStage *mpe)\n{\n    memmove(Out, In, mpe ->InputChannels * sizeof(cmsFloat32Number));\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              66,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EvaluateIdentity",
            "parameters": {
              "In": "cmsFloat32Number",
              "Out": "cmsFloat32Number",
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid FromFloatTo16(const cmsFloat32Number In[], cmsUInt16Number Out[], cmsUInt32Number n)\n{\n    cmsUInt32Number i;\n\n    for (i=0; i < n; i++) {\n        Out[i] = _cmsQuickSaturateWord(In[i] * 65535.0);\n    }\n}",
          "fn_code_pos": [
            [
              81,
              0
            ],
            [
              89,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FromFloatTo16",
            "parameters": {
              "In": "cmsFloat32Number",
              "Out": "cmsUInt16Number",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid From16ToFloat(const cmsUInt16Number In[], cmsFloat32Number Out[], cmsUInt32Number n)\n{\n    cmsUInt32Number i;\n\n    for (i=0; i < n; i++) {\n        Out[i] = (cmsFloat32Number) In[i] / 65535.0F;\n    }\n}",
          "fn_code_pos": [
            [
              92,
              0
            ],
            [
              100,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "From16ToFloat",
            "parameters": {
              "In": "cmsUInt16Number",
              "Out": "cmsFloat32Number",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT cmsPipelineCheckAndRetreiveStages(const cmsPipeline* Lut, cmsUInt32Number n, ...)\n{\n    va_list args;\n    cmsUInt32Number i;\n    cmsStage* mpe;\n    cmsStageSignature Type;\n    void** ElemPtr;\n\n    // Make sure same number of elements\n    if (cmsPipelineStageCount(Lut) != n) return FALSE;\n\n    va_start(args, n);\n\n    // Iterate across asked types\n    mpe = Lut ->Elements;\n    for (i=0; i < n; i++) {\n\n        // Get asked type. cmsStageSignature is promoted to int by compiler\n        Type  = (cmsStageSignature)va_arg(args, int);\n        if (mpe ->Type != Type) {\n\n            va_end(args);       // Mismatch. We are done.\n            return FALSE;\n        }\n        mpe = mpe ->Next;\n    }\n\n    // Found a combination, fill pointers if not NULL\n    mpe = Lut ->Elements;\n    for (i=0; i < n; i++) {\n\n        ElemPtr = va_arg(args, void**);\n        if (ElemPtr != NULL)\n            *ElemPtr = mpe;\n\n        mpe = mpe ->Next;\n    }\n\n    va_end(args);\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              109,
              0
            ],
            [
              149,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineCheckAndRetreiveStages",
            "parameters": {
              "Lut": "cmsPipeline",
              "n": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsToneCurve** _cmsStageGetPtrToCurveSet(const cmsStage* mpe)\n{\n    _cmsStageToneCurvesData* Data = (_cmsStageToneCurvesData*) mpe ->Data;\n\n    return Data ->TheCurves;\n}",
          "fn_code_pos": [
            [
              158,
              0
            ],
            [
              163,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "cmsToneCurve"
          }
        },
        {
          "fn_code": "static\nvoid EvaluateCurves(const cmsFloat32Number In[],\n                    cmsFloat32Number Out[],\n                    const cmsStage *mpe)\n{\n    _cmsStageToneCurvesData* Data;\n    cmsUInt32Number i;\n\n    _cmsAssert(mpe != NULL);\n\n    Data = (_cmsStageToneCurvesData*) mpe ->Data;\n    if (Data == NULL) return;\n\n    if (Data ->TheCurves == NULL) return;\n\n    for (i=0; i < Data ->nCurves; i++) {\n        Out[i] = cmsEvalToneCurveFloat(Data ->TheCurves[i], In[i]);\n    }\n}",
          "fn_code_pos": [
            [
              165,
              0
            ],
            [
              183,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EvaluateCurves",
            "parameters": {
              "In": "cmsFloat32Number",
              "Out": "cmsFloat32Number",
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid CurveSetElemTypeFree(cmsStage* mpe)\n{\n    _cmsStageToneCurvesData* Data;\n    cmsUInt32Number i;\n\n    _cmsAssert(mpe != NULL);\n\n    Data = (_cmsStageToneCurvesData*) mpe ->Data;\n    if (Data == NULL) return;\n\n    if (Data ->TheCurves != NULL) {\n        for (i=0; i < Data ->nCurves; i++) {\n            if (Data ->TheCurves[i] != NULL)\n                cmsFreeToneCurve(Data ->TheCurves[i]);\n        }\n    }\n    _cmsFree(mpe ->ContextID, Data ->TheCurves);\n    _cmsFree(mpe ->ContextID, Data);\n}",
          "fn_code_pos": [
            [
              185,
              0
            ],
            [
              204,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CurveSetElemTypeFree",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* CurveSetDup(cmsStage* mpe)\n{\n    _cmsStageToneCurvesData* Data = (_cmsStageToneCurvesData*) mpe ->Data;\n    _cmsStageToneCurvesData* NewElem;\n    cmsUInt32Number i;\n\n    NewElem = (_cmsStageToneCurvesData*) _cmsMallocZero(mpe ->ContextID, sizeof(_cmsStageToneCurvesData));\n    if (NewElem == NULL) return NULL;\n\n    NewElem ->nCurves   = Data ->nCurves;\n    NewElem ->TheCurves = (cmsToneCurve**) _cmsCalloc(mpe ->ContextID, NewElem ->nCurves, sizeof(cmsToneCurve*));\n\n    if (NewElem ->TheCurves == NULL) goto Error;\n\n    for (i=0; i < NewElem ->nCurves; i++) {\n\n        // Duplicate each curve. It may fail.\n        NewElem ->TheCurves[i] = cmsDupToneCurve(Data ->TheCurves[i]);\n        if (NewElem ->TheCurves[i] == NULL) goto Error;\n\n\n    }\n    return (void*) NewElem;\n\nError:\n\n    if (NewElem ->TheCurves != NULL) {\n        for (i=0; i < NewElem ->nCurves; i++) {\n            if (NewElem ->TheCurves[i])\n                cmsFreeToneCurve(NewElem ->TheCurves[i]);\n        }\n    }\n    _cmsFree(mpe ->ContextID, NewElem ->TheCurves);\n    _cmsFree(mpe ->ContextID, NewElem);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              207,
              0
            ],
            [
              243,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CurveSetDup",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid EvaluateMatrix(const cmsFloat32Number In[],\n                    cmsFloat32Number Out[],\n                    const cmsStage *mpe)\n{\n    cmsUInt32Number i, j;\n    _cmsStageMatrixData* Data = (_cmsStageMatrixData*) mpe ->Data;\n    cmsFloat64Number Tmp;\n\n    // Input is already in 0..1.0 notation\n    for (i=0; i < mpe ->OutputChannels; i++) {\n\n        Tmp = 0;\n        for (j=0; j < mpe->InputChannels; j++) {\n            Tmp += In[j] * Data->Double[i*mpe->InputChannels + j];\n        }\n\n        if (Data ->Offset != NULL)\n            Tmp += Data->Offset[i];\n\n        Out[i] = (cmsFloat32Number) Tmp;\n    }\n\n\n    // Output in 0..1.0 domain\n}",
          "fn_code_pos": [
            [
              310,
              0
            ],
            [
              335,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EvaluateMatrix",
            "parameters": {
              "In": "cmsFloat32Number",
              "Out": "cmsFloat32Number",
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* MatrixElemDup(cmsStage* mpe)\n{\n    _cmsStageMatrixData* Data = (_cmsStageMatrixData*) mpe ->Data;\n    _cmsStageMatrixData* NewElem;\n    cmsUInt32Number sz;\n\n    NewElem = (_cmsStageMatrixData*) _cmsMallocZero(mpe ->ContextID, sizeof(_cmsStageMatrixData));\n    if (NewElem == NULL) return NULL;\n\n    sz = mpe ->InputChannels * mpe ->OutputChannels;\n\n    NewElem ->Double = (cmsFloat64Number*) _cmsDupMem(mpe ->ContextID, Data ->Double, sz * sizeof(cmsFloat64Number)) ;\n\n    if (Data ->Offset)\n        NewElem ->Offset = (cmsFloat64Number*) _cmsDupMem(mpe ->ContextID,\n                                                Data ->Offset, mpe -> OutputChannels * sizeof(cmsFloat64Number)) ;\n\n    return (void*) NewElem;\n}",
          "fn_code_pos": [
            [
              339,
              0
            ],
            [
              358,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MatrixElemDup",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid MatrixElemTypeFree(cmsStage* mpe)\n{\n    _cmsStageMatrixData* Data = (_cmsStageMatrixData*) mpe ->Data;\n    if (Data == NULL)\n        return;\n    if (Data ->Double)\n        _cmsFree(mpe ->ContextID, Data ->Double);\n\n    if (Data ->Offset)\n        _cmsFree(mpe ->ContextID, Data ->Offset);\n\n    _cmsFree(mpe ->ContextID, mpe ->Data);\n}",
          "fn_code_pos": [
            [
              361,
              0
            ],
            [
              374,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MatrixElemTypeFree",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid EvaluateCLUTfloat(const cmsFloat32Number In[], cmsFloat32Number Out[], const cmsStage *mpe)\n{\n    _cmsStageCLutData* Data = (_cmsStageCLutData*) mpe ->Data;\n\n    Data -> Params ->Interpolation.LerpFloat(In, Out, Data->Params);\n}",
          "fn_code_pos": [
            [
              433,
              0
            ],
            [
              439,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EvaluateCLUTfloat",
            "parameters": {
              "In": "cmsFloat32Number",
              "Out": "cmsFloat32Number",
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid EvaluateCLUTfloatIn16(const cmsFloat32Number In[], cmsFloat32Number Out[], const cmsStage *mpe)\n{\n    _cmsStageCLutData* Data = (_cmsStageCLutData*) mpe ->Data;\n    cmsUInt16Number In16[MAX_STAGE_CHANNELS], Out16[MAX_STAGE_CHANNELS];\n\n    _cmsAssert(mpe ->InputChannels  <= MAX_STAGE_CHANNELS);\n    _cmsAssert(mpe ->OutputChannels <= MAX_STAGE_CHANNELS);\n\n    FromFloatTo16(In, In16, mpe ->InputChannels);\n    Data -> Params ->Interpolation.Lerp16(In16, Out16, Data->Params);\n    From16ToFloat(Out16, Out,  mpe ->OutputChannels);\n}",
          "fn_code_pos": [
            [
              443,
              0
            ],
            [
              455,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EvaluateCLUTfloatIn16",
            "parameters": {
              "In": "cmsFloat32Number",
              "Out": "cmsFloat32Number",
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number CubeSize(const cmsUInt32Number Dims[], cmsUInt32Number b)\n{\n    cmsUInt32Number rv, dim;\n\n    _cmsAssert(Dims != NULL);\n\n    for (rv = 1; b > 0; b--) {\n\n        dim = Dims[b-1];\n        if (dim <= 1) return 0;  // Error\n\n        rv *= dim;\n\n        // Check for overflow\n        if (rv > UINT_MAX / dim) return 0;\n    }\n\n    // Again, prevent overflow\n    if (rv > UINT_MAX / 15) return 0;\n\n    return rv;\n}",
          "fn_code_pos": [
            [
              459,
              0
            ],
            [
              481,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CubeSize",
            "parameters": {
              "Dims": "cmsUInt32Number",
              "b": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid* CLUTElemDup(cmsStage* mpe)\n{\n    _cmsStageCLutData* Data = (_cmsStageCLutData*) mpe ->Data;\n    _cmsStageCLutData* NewElem;\n\n\n    NewElem = (_cmsStageCLutData*) _cmsMallocZero(mpe ->ContextID, sizeof(_cmsStageCLutData));\n    if (NewElem == NULL) return NULL;\n\n    NewElem ->nEntries       = Data ->nEntries;\n    NewElem ->HasFloatValues = Data ->HasFloatValues;\n\n    if (Data ->Tab.T) {\n\n        if (Data ->HasFloatValues) {\n            NewElem ->Tab.TFloat = (cmsFloat32Number*) _cmsDupMem(mpe ->ContextID, Data ->Tab.TFloat, Data ->nEntries * sizeof (cmsFloat32Number));\n            if (NewElem ->Tab.TFloat == NULL)\n                goto Error;\n        } else {\n            NewElem ->Tab.T = (cmsUInt16Number*) _cmsDupMem(mpe ->ContextID, Data ->Tab.T, Data ->nEntries * sizeof (cmsUInt16Number));\n            if (NewElem ->Tab.T == NULL)\n                goto Error;\n        }\n    }\n\n    NewElem ->Params   = _cmsComputeInterpParamsEx(mpe ->ContextID,\n                                                   Data ->Params ->nSamples,\n                                                   Data ->Params ->nInputs,\n                                                   Data ->Params ->nOutputs,\n                                                   NewElem ->Tab.T,\n                                                   Data ->Params ->dwFlags);\n    if (NewElem->Params != NULL)\n        return (void*) NewElem;\n Error:\n    if (NewElem->Tab.T)\n        // This works for both types\n        _cmsFree(mpe ->ContextID, NewElem -> Tab.T);\n    _cmsFree(mpe ->ContextID, NewElem);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              483,
              0
            ],
            [
              523,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CLUTElemDup",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid CLutElemTypeFree(cmsStage* mpe)\n{\n\n    _cmsStageCLutData* Data = (_cmsStageCLutData*) mpe ->Data;\n\n    // Already empty\n    if (Data == NULL) return;\n\n    // This works for both types\n    if (Data -> Tab.T)\n        _cmsFree(mpe ->ContextID, Data -> Tab.T);\n\n    _cmsFreeInterpParams(Data ->Params);\n    _cmsFree(mpe ->ContextID, mpe ->Data);\n}",
          "fn_code_pos": [
            [
              526,
              0
            ],
            [
              541,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CLutElemTypeFree",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nint IdentitySampler(CMSREGISTER const cmsUInt16Number In[], CMSREGISTER cmsUInt16Number Out[], CMSREGISTER void * Cargo)\n{\n    int nChan = *(int*) Cargo;\n    int i;\n\n    for (i=0; i < nChan; i++)\n        Out[i] = In[i];\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              698,
              0
            ],
            [
              708,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IdentitySampler",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "cmsUInt16Number CMSEXPORT _cmsQuantizeVal(cmsFloat64Number i, cmsUInt32Number MaxSamples)\n{\n    cmsFloat64Number x;\n\n    x = ((cmsFloat64Number) i * 65535.) / (cmsFloat64Number) (MaxSamples - 1);\n    return _cmsQuickSaturateWord(x);\n}",
          "fn_code_pos": [
            [
              735,
              0
            ],
            [
              741,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsQuantizeVal",
            "parameters": {
              "i": "cmsFloat64Number",
              "MaxSamples": "cmsUInt32Number"
            },
            "return_type": "cmsUInt16Number"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsStageSampleCLut16bit(cmsStage* mpe, cmsSAMPLER16 Sampler, void * Cargo, cmsUInt32Number dwFlags)\n{\n    int i, t, index, rest;\n    cmsUInt32Number nTotalPoints;\n    cmsUInt32Number nInputs, nOutputs;\n    cmsUInt32Number* nSamples;\n    cmsUInt16Number In[MAX_INPUT_DIMENSIONS+1], Out[MAX_STAGE_CHANNELS];\n    _cmsStageCLutData* clut;\n\n    if (mpe == NULL) return FALSE;\n\n    clut = (_cmsStageCLutData*) mpe->Data;\n\n    if (clut == NULL) return FALSE;\n\n    nSamples = clut->Params ->nSamples;\n    nInputs  = clut->Params ->nInputs;\n    nOutputs = clut->Params ->nOutputs;\n\n    if (nInputs <= 0) return FALSE;\n    if (nOutputs <= 0) return FALSE;\n    if (nInputs > MAX_INPUT_DIMENSIONS) return FALSE;\n    if (nOutputs >= MAX_STAGE_CHANNELS) return FALSE;\n\n    memset(In, 0, sizeof(In));\n    memset(Out, 0, sizeof(Out));\n\n    nTotalPoints = CubeSize(nSamples, nInputs);\n    if (nTotalPoints == 0) return FALSE;\n\n    index = 0;\n    for (i = 0; i < (int) nTotalPoints; i++) {\n\n        rest = i;\n        for (t = (int)nInputs - 1; t >= 0; --t) {\n\n            cmsUInt32Number  Colorant = rest % nSamples[t];\n\n            rest /= nSamples[t];\n\n            In[t] = _cmsQuantizeVal(Colorant, nSamples[t]);\n        }\n\n        if (clut ->Tab.T != NULL) {\n            for (t = 0; t < (int)nOutputs; t++)\n                Out[t] = clut->Tab.T[index + t];\n        }\n\n        if (!Sampler(In, Out, Cargo))\n            return FALSE;\n\n        if (!(dwFlags & SAMPLER_INSPECT)) {\n\n            if (clut ->Tab.T != NULL) {\n                for (t=0; t < (int) nOutputs; t++)\n                    clut->Tab.T[index + t] = Out[t];\n            }\n        }\n\n        index += nOutputs;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              746,
              0
            ],
            [
              809,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageSampleCLut16bit",
            "parameters": {
              "mpe": "cmsStage",
              "Sampler": "cmsSAMPLER16",
              "Cargo": "void",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsStageSampleCLutFloat(cmsStage* mpe, cmsSAMPLERFLOAT Sampler, void * Cargo, cmsUInt32Number dwFlags)\n{\n    int i, t, index, rest;\n    cmsUInt32Number nTotalPoints;\n    cmsUInt32Number nInputs, nOutputs;\n    cmsUInt32Number* nSamples;\n    cmsFloat32Number In[MAX_INPUT_DIMENSIONS+1], Out[MAX_STAGE_CHANNELS];\n    _cmsStageCLutData* clut;\n\n    if (mpe == NULL) return FALSE;\n\n    clut = (_cmsStageCLutData*)mpe->Data;\n\n    if (clut == NULL) return FALSE;\n\n    nSamples = clut->Params ->nSamples;\n    nInputs  = clut->Params ->nInputs;\n    nOutputs = clut->Params ->nOutputs;\n\n    if (nInputs <= 0) return FALSE;\n    if (nOutputs <= 0) return FALSE;\n    if (nInputs  > MAX_INPUT_DIMENSIONS) return FALSE;\n    if (nOutputs >= MAX_STAGE_CHANNELS) return FALSE;\n\n    nTotalPoints = CubeSize(nSamples, nInputs);\n    if (nTotalPoints == 0) return FALSE;\n\n    index = 0;\n    for (i = 0; i < (int)nTotalPoints; i++) {\n\n        rest = i;\n        for (t = (int) nInputs-1; t >=0; --t) {\n\n            cmsUInt32Number  Colorant = rest % nSamples[t];\n\n            rest /= nSamples[t];\n\n            In[t] =  (cmsFloat32Number) (_cmsQuantizeVal(Colorant, nSamples[t]) / 65535.0);\n        }\n\n        if (clut ->Tab.TFloat != NULL) {\n            for (t=0; t < (int) nOutputs; t++)\n                Out[t] = clut->Tab.TFloat[index + t];\n        }\n\n        if (!Sampler(In, Out, Cargo))\n            return FALSE;\n\n        if (!(dwFlags & SAMPLER_INSPECT)) {\n\n            if (clut ->Tab.TFloat != NULL) {\n                for (t=0; t < (int) nOutputs; t++)\n                    clut->Tab.TFloat[index + t] = Out[t];\n            }\n        }\n\n        index += nOutputs;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              812,
              0
            ],
            [
              872,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageSampleCLutFloat",
            "parameters": {
              "mpe": "cmsStage",
              "Sampler": "cmsSAMPLERFLOAT",
              "Cargo": "void",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsSliceSpace16(cmsUInt32Number nInputs, const cmsUInt32Number clutPoints[],\n                                         cmsSAMPLER16 Sampler, void * Cargo)\n{\n    int i, t, rest;\n    cmsUInt32Number nTotalPoints;\n    cmsUInt16Number In[cmsMAXCHANNELS];\n\n    if (nInputs >= cmsMAXCHANNELS) return FALSE;\n\n    nTotalPoints = CubeSize(clutPoints, nInputs);\n    if (nTotalPoints == 0) return FALSE;\n\n    for (i = 0; i < (int) nTotalPoints; i++) {\n\n        rest = i;\n        for (t = (int) nInputs-1; t >=0; --t) {\n\n            cmsUInt32Number  Colorant = rest % clutPoints[t];\n\n            rest /= clutPoints[t];\n            In[t] = _cmsQuantizeVal(Colorant, clutPoints[t]);\n\n        }\n\n        if (!Sampler(In, NULL, Cargo))\n            return FALSE;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              878,
              0
            ],
            [
              907,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSliceSpace16",
            "parameters": {
              "nInputs": "cmsUInt32Number",
              "clutPoints": "cmsUInt32Number",
              "Sampler": "cmsSAMPLER16",
              "Cargo": "void"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsInt32Number CMSEXPORT cmsSliceSpaceFloat(cmsUInt32Number nInputs, const cmsUInt32Number clutPoints[],\n                                            cmsSAMPLERFLOAT Sampler, void * Cargo)\n{\n    int i, t, rest;\n    cmsUInt32Number nTotalPoints;\n    cmsFloat32Number In[cmsMAXCHANNELS];\n\n    if (nInputs >= cmsMAXCHANNELS) return FALSE;\n\n    nTotalPoints = CubeSize(clutPoints, nInputs);\n    if (nTotalPoints == 0) return FALSE;\n\n    for (i = 0; i < (int) nTotalPoints; i++) {\n\n        rest = i;\n        for (t = (int) nInputs-1; t >=0; --t) {\n\n            cmsUInt32Number  Colorant = rest % clutPoints[t];\n\n            rest /= clutPoints[t];\n            In[t] =  (cmsFloat32Number) (_cmsQuantizeVal(Colorant, clutPoints[t]) / 65535.0);\n\n        }\n\n        if (!Sampler(In, NULL, Cargo))\n            return FALSE;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              909,
              0
            ],
            [
              938,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSliceSpaceFloat",
            "parameters": {
              "nInputs": "cmsUInt32Number",
              "clutPoints": "cmsUInt32Number",
              "Sampler": "cmsSAMPLERFLOAT",
              "Cargo": "void"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid EvaluateLab2XYZ(const cmsFloat32Number In[],\n                     cmsFloat32Number Out[],\n                     const cmsStage *mpe)\n{\n    cmsCIELab Lab;\n    cmsCIEXYZ XYZ;\n    const cmsFloat64Number XYZadj = MAX_ENCODEABLE_XYZ;\n\n    // V4 rules\n    Lab.L = In[0] * 100.0;\n    Lab.a = In[1] * 255.0 - 128.0;\n    Lab.b = In[2] * 255.0 - 128.0;\n\n    cmsLab2XYZ(NULL, &XYZ, &Lab);\n\n    // From XYZ, range 0..19997 to 0..1.0, note that 1.99997 comes from 0xffff\n    // encoded as 1.15 fixed point, so 1 + (32767.0 / 32768.0)\n\n    Out[0] = (cmsFloat32Number) ((cmsFloat64Number) XYZ.X / XYZadj);\n    Out[1] = (cmsFloat32Number) ((cmsFloat64Number) XYZ.Y / XYZadj);\n    Out[2] = (cmsFloat32Number) ((cmsFloat64Number) XYZ.Z / XYZadj);\n    return;\n\n    cmsUNUSED_PARAMETER(mpe);\n}",
          "fn_code_pos": [
            [
              945,
              0
            ],
            [
              970,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EvaluateLab2XYZ",
            "parameters": {
              "In": "cmsFloat32Number",
              "Out": "cmsFloat32Number",
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsStage* _cmsStageAllocLabV2ToV4curves(cmsContext ContextID)\n{\n    cmsStage* mpe;\n    cmsToneCurve* LabTable[3];\n    int i, j;\n\n    LabTable[0] = cmsBuildTabulatedToneCurve16(ContextID, 258, NULL);\n    LabTable[1] = cmsBuildTabulatedToneCurve16(ContextID, 258, NULL);\n    LabTable[2] = cmsBuildTabulatedToneCurve16(ContextID, 258, NULL);\n\n    for (j=0; j < 3; j++) {\n\n        if (LabTable[j] == NULL) {\n            cmsFreeToneCurveTriple(LabTable);\n            return NULL;\n        }\n\n        // We need to map * (0xffff / 0xff00), that's same as (257 / 256)\n        // So we can use 258-entry tables to do the trick (i / 257) * (255 * 257) * (257 / 256);\n        for (i=0; i < 257; i++)  {\n\n            LabTable[j]->Table16[i] = (cmsUInt16Number) ((i * 0xffff + 0x80) >> 8);\n        }\n\n        LabTable[j] ->Table16[257] = 0xffff;\n    }\n\n    mpe = cmsStageAllocToneCurves(ContextID, 3, LabTable);\n    cmsFreeToneCurveTriple(LabTable);\n\n    if (mpe == NULL) return NULL;\n    mpe ->Implements = cmsSigLabV2toV4;\n    return mpe;\n}",
          "fn_code_pos": [
            [
              987,
              0
            ],
            [
              1020,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageAllocLabV2ToV4curves",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "cmsStage"
          }
        },
        {
          "fn_code": "cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext ContextID)\n{\n    static const cmsFloat64Number a1[] = {\n        1.0/100.0, 0, 0,\n        0, 1.0/255.0, 0,\n        0, 0, 1.0/255.0\n    };\n\n    static const cmsFloat64Number o1[] = {\n        0,\n        128.0/255.0,\n        128.0/255.0\n    };\n\n    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);\n\n    if (mpe == NULL) return mpe;\n    mpe ->Implements = cmsSigLab2FloatPCS;\n    return mpe;\n}",
          "fn_code_pos": [
            [
              1061,
              0
            ],
            [
              1080,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageNormalizeFromLabFloat",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "cmsStage"
          }
        },
        {
          "fn_code": "cmsStage* _cmsStageNormalizeFromXyzFloat(cmsContext ContextID)\n{\n#define n (32768.0/65535.0)\n    static const cmsFloat64Number a1[] = {\n        n, 0, 0,\n        0, n, 0,\n        0, 0, n\n    };\n#undef n\n\n    cmsStage *mpe =  cmsStageAllocMatrix(ContextID, 3, 3, a1, NULL);\n\n    if (mpe == NULL) return mpe;\n    mpe ->Implements = cmsSigXYZ2FloatPCS;\n    return mpe;\n}",
          "fn_code_pos": [
            [
              1083,
              0
            ],
            [
              1098,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageNormalizeFromXyzFloat",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "cmsStage"
          }
        },
        {
          "fn_code": "cmsStage* _cmsStageNormalizeToLabFloat(cmsContext ContextID)\n{\n    static const cmsFloat64Number a1[] = {\n        100.0, 0, 0,\n        0, 255.0, 0,\n        0, 0, 255.0\n    };\n\n    static const cmsFloat64Number o1[] = {\n        0,\n        -128.0,\n        -128.0\n    };\n\n    cmsStage *mpe =  cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);\n    if (mpe == NULL) return mpe;\n    mpe ->Implements = cmsSigFloatPCS2Lab;\n    return mpe;\n}",
          "fn_code_pos": [
            [
              1100,
              0
            ],
            [
              1118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageNormalizeToLabFloat",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "cmsStage"
          }
        },
        {
          "fn_code": "cmsStage* _cmsStageNormalizeToXyzFloat(cmsContext ContextID)\n{\n#define n (65535.0/32768.0)\n\n    static const cmsFloat64Number a1[] = {\n        n, 0, 0,\n        0, n, 0,\n        0, 0, n\n    };\n#undef n\n\n    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, NULL);\n    if (mpe == NULL) return mpe;\n    mpe ->Implements = cmsSigFloatPCS2XYZ;\n    return mpe;\n}",
          "fn_code_pos": [
            [
              1120,
              0
            ],
            [
              1135,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageNormalizeToXyzFloat",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "cmsStage"
          }
        },
        {
          "fn_code": "static\nvoid Clipper(const cmsFloat32Number In[], cmsFloat32Number Out[], const cmsStage *mpe)\n{\n       cmsUInt32Number i;\n       for (i = 0; i < mpe->InputChannels; i++) {\n\n              cmsFloat32Number n = In[i];\n              Out[i] = n < 0 ? 0 : n;\n       }\n}",
          "fn_code_pos": [
            [
              1138,
              0
            ],
            [
              1147,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Clipper",
            "parameters": {
              "In": "cmsFloat32Number",
              "Out": "cmsFloat32Number",
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsStage*  _cmsStageClipNegatives(cmsContext ContextID, cmsUInt32Number nChannels)\n{\n       return _cmsStageAllocPlaceholder(ContextID, cmsSigClipNegativesElemType,\n              nChannels, nChannels, Clipper, NULL, NULL, NULL);\n}",
          "fn_code_pos": [
            [
              1149,
              0
            ],
            [
              1153,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageClipNegatives",
            "parameters": {
              "ContextID": "cmsContext",
              "nChannels": "cmsUInt32Number"
            },
            "return_type": "cmsStage"
          }
        },
        {
          "fn_code": "static\nvoid EvaluateXYZ2Lab(const cmsFloat32Number In[], cmsFloat32Number Out[], const cmsStage *mpe)\n{\n    cmsCIELab Lab;\n    cmsCIEXYZ XYZ;\n    const cmsFloat64Number XYZadj = MAX_ENCODEABLE_XYZ;\n\n    // From 0..1.0 to XYZ\n\n    XYZ.X = In[0] * XYZadj;\n    XYZ.Y = In[1] * XYZadj;\n    XYZ.Z = In[2] * XYZadj;\n\n    cmsXYZ2Lab(NULL, &Lab, &XYZ);\n\n    // From V4 Lab to 0..1.0\n\n    Out[0] = (cmsFloat32Number) (Lab.L / 100.0);\n    Out[1] = (cmsFloat32Number) ((Lab.a + 128.0) / 255.0);\n    Out[2] = (cmsFloat32Number) ((Lab.b + 128.0) / 255.0);\n    return;\n\n    cmsUNUSED_PARAMETER(mpe);\n}",
          "fn_code_pos": [
            [
              1159,
              0
            ],
            [
              1182,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EvaluateXYZ2Lab",
            "parameters": {
              "In": "cmsFloat32Number",
              "Out": "cmsFloat32Number",
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsStage* _cmsStageAllocLabPrelin(cmsContext ContextID)\n{\n    cmsToneCurve* LabTable[3];\n    cmsFloat64Number Params[1] =  {2.4} ;\n\n    LabTable[0] = cmsBuildGamma(ContextID, 1.0);\n    LabTable[1] = cmsBuildParametricToneCurve(ContextID, 108, Params);\n    LabTable[2] = cmsBuildParametricToneCurve(ContextID, 108, Params);\n\n    return cmsStageAllocToneCurves(ContextID, 3, LabTable);\n}",
          "fn_code_pos": [
            [
              1194,
              0
            ],
            [
              1204,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageAllocLabPrelin",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "cmsStage"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsStageFree(cmsStage* mpe)\n{\n    if (mpe ->FreePtr)\n        mpe ->FreePtr(mpe);\n\n    _cmsFree(mpe ->ContextID, mpe);\n}",
          "fn_code_pos": [
            [
              1208,
              0
            ],
            [
              1214,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageFree",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsUInt32Number  CMSEXPORT cmsStageInputChannels(const cmsStage* mpe)\n{\n    return mpe ->InputChannels;\n}",
          "fn_code_pos": [
            [
              1217,
              0
            ],
            [
              1220,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageInputChannels",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number  CMSEXPORT cmsStageOutputChannels(const cmsStage* mpe)\n{\n    return mpe ->OutputChannels;\n}",
          "fn_code_pos": [
            [
              1222,
              0
            ],
            [
              1225,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageOutputChannels",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsStageSignature CMSEXPORT cmsStageType(const cmsStage* mpe)\n{\n    return mpe -> Type;\n}",
          "fn_code_pos": [
            [
              1227,
              0
            ],
            [
              1230,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageType",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "cmsStageSignature"
          }
        },
        {
          "fn_code": "void* CMSEXPORT cmsStageData(const cmsStage* mpe)\n{\n    return mpe -> Data;\n}",
          "fn_code_pos": [
            [
              1232,
              0
            ],
            [
              1235,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageData",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsContext CMSEXPORT cmsGetStageContextID(const cmsStage* mpe)\n{\n    return mpe -> ContextID;\n}",
          "fn_code_pos": [
            [
              1237,
              0
            ],
            [
              1240,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetStageContextID",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "cmsContext"
          }
        },
        {
          "fn_code": "static\ncmsBool BlessLUT(cmsPipeline* lut)\n{\n    // We can set the input/output channels only if we have elements.\n    if (lut ->Elements != NULL) {\n\n        cmsStage* prev;\n        cmsStage* next;\n        cmsStage* First;\n        cmsStage* Last;\n\n        First  = cmsPipelineGetPtrToFirstStage(lut);\n        Last   = cmsPipelineGetPtrToLastStage(lut);\n\n        if (First == NULL || Last == NULL) return FALSE;\n\n        lut->InputChannels = First->InputChannels;\n        lut->OutputChannels = Last->OutputChannels;\n\n        // Check chain consistency\n        prev = First;\n        next = prev->Next;\n\n        while (next != NULL)\n        {\n            if (next->InputChannels != prev->OutputChannels)\n                return FALSE;\n\n            next = next->Next;\n            prev = prev->Next;\n    }\n}\n\n    return TRUE;    \n}",
          "fn_code_pos": [
            [
              1288,
              0
            ],
            [
              1322,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BlessLUT",
            "parameters": {
              "lut": "cmsPipeline"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid _LUTeval16(CMSREGISTER const cmsUInt16Number In[], CMSREGISTER cmsUInt16Number Out[],  CMSREGISTER const void* D)\n{\n    cmsPipeline* lut = (cmsPipeline*) D;\n    cmsStage *mpe;\n    cmsFloat32Number Storage[2][MAX_STAGE_CHANNELS];\n    int Phase = 0, NextPhase;\n\n    From16ToFloat(In, &Storage[Phase][0], lut ->InputChannels);\n\n    for (mpe = lut ->Elements;\n         mpe != NULL;\n         mpe = mpe ->Next) {\n\n             NextPhase = Phase ^ 1;\n             mpe ->EvalPtr(&Storage[Phase][0], &Storage[NextPhase][0], mpe);\n             Phase = NextPhase;\n    }\n\n\n    FromFloatTo16(&Storage[Phase][0], Out, lut ->OutputChannels);\n}",
          "fn_code_pos": [
            [
              1326,
              0
            ],
            [
              1347,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_LUTeval16",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid _LUTevalFloat(const cmsFloat32Number In[], cmsFloat32Number Out[], const void* D)\n{\n    cmsPipeline* lut = (cmsPipeline*) D;\n    cmsStage *mpe;\n    cmsFloat32Number Storage[2][MAX_STAGE_CHANNELS];\n    int Phase = 0, NextPhase;\n\n    memmove(&Storage[Phase][0], In, lut ->InputChannels  * sizeof(cmsFloat32Number));\n\n    for (mpe = lut ->Elements;\n         mpe != NULL;\n         mpe = mpe ->Next) {\n\n              NextPhase = Phase ^ 1;\n              mpe ->EvalPtr(&Storage[Phase][0], &Storage[NextPhase][0], mpe);\n              Phase = NextPhase;\n    }\n\n    memmove(Out, &Storage[Phase][0], lut ->OutputChannels * sizeof(cmsFloat32Number));\n}",
          "fn_code_pos": [
            [
              1352,
              0
            ],
            [
              1372,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_LUTevalFloat",
            "parameters": {
              "In": "cmsFloat32Number",
              "Out": "cmsFloat32Number",
              "D": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsContext CMSEXPORT cmsGetPipelineContextID(const cmsPipeline* lut)\n{\n    _cmsAssert(lut != NULL);\n    return lut ->ContextID;\n}",
          "fn_code_pos": [
            [
              1406,
              0
            ],
            [
              1410,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetPipelineContextID",
            "parameters": {
              "lut": "cmsPipeline"
            },
            "return_type": "cmsContext"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsPipelineInputChannels(const cmsPipeline* lut)\n{\n    _cmsAssert(lut != NULL);\n    return lut ->InputChannels;\n}",
          "fn_code_pos": [
            [
              1412,
              0
            ],
            [
              1416,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineInputChannels",
            "parameters": {
              "lut": "cmsPipeline"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsPipelineOutputChannels(const cmsPipeline* lut)\n{\n    _cmsAssert(lut != NULL);\n    return lut ->OutputChannels;\n}",
          "fn_code_pos": [
            [
              1418,
              0
            ],
            [
              1422,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineOutputChannels",
            "parameters": {
              "lut": "cmsPipeline"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsPipelineFree(cmsPipeline* lut)\n{\n    cmsStage *mpe, *Next;\n\n    if (lut == NULL) return;\n\n    for (mpe = lut ->Elements;\n        mpe != NULL;\n        mpe = Next) {\n\n            Next = mpe ->Next;\n            cmsStageFree(mpe);\n    }\n\n    if (lut ->FreeDataFn) lut ->FreeDataFn(lut ->ContextID, lut ->Data);\n\n    _cmsFree(lut ->ContextID, lut);\n}",
          "fn_code_pos": [
            [
              1425,
              0
            ],
            [
              1442,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineFree",
            "parameters": {
              "lut": "cmsPipeline"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsPipelineEval16(const cmsUInt16Number In[], cmsUInt16Number Out[],  const cmsPipeline* lut)\n{\n    _cmsAssert(lut != NULL);\n    lut ->Eval16Fn(In, Out, lut->Data);\n}",
          "fn_code_pos": [
            [
              1446,
              0
            ],
            [
              1450,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineEval16",
            "parameters": {
              "In": "cmsUInt16Number",
              "Out": "cmsUInt16Number",
              "lut": "cmsPipeline"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsPipelineEvalFloat(const cmsFloat32Number In[], cmsFloat32Number Out[], const cmsPipeline* lut)\n{\n    _cmsAssert(lut != NULL);\n    lut ->EvalFloatFn(In, Out, lut);\n}",
          "fn_code_pos": [
            [
              1454,
              0
            ],
            [
              1458,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineEvalFloat",
            "parameters": {
              "In": "cmsFloat32Number",
              "Out": "cmsFloat32Number",
              "lut": "cmsPipeline"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage* mpe)\n{\n    cmsStage* Anterior = NULL, *pt;\n\n    if (lut == NULL || mpe == NULL)\n        return FALSE;\n\n    switch (loc) {\n\n        case cmsAT_BEGIN:\n            mpe ->Next = lut ->Elements;\n            lut ->Elements = mpe;\n            break;\n\n        case cmsAT_END:\n\n            if (lut ->Elements == NULL)\n                lut ->Elements = mpe;\n            else {\n\n                for (pt = lut ->Elements;\n                     pt != NULL;\n                     pt = pt -> Next) Anterior = pt;\n                \n                Anterior ->Next = mpe;\n                mpe ->Next = NULL;\n            }\n            break;\n        default:;\n            return FALSE;\n    }\n\n    return BlessLUT(lut);    \n}",
          "fn_code_pos": [
            [
              1518,
              0
            ],
            [
              1551,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineInsertStage",
            "parameters": {
              "lut": "cmsPipeline",
              "loc": "cmsStageLoc",
              "mpe": "cmsStage"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsPipelineUnlinkStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage** mpe)\n{\n    cmsStage *Anterior, *pt, *Last;\n    cmsStage *Unlinked = NULL;\n\n\n    // If empty LUT, there is nothing to remove\n    if (lut ->Elements == NULL) {\n        if (mpe) *mpe = NULL;\n        return;\n    }\n\n    // On depending on the strategy...\n    switch (loc) {\n\n        case cmsAT_BEGIN:\n            {\n                cmsStage* elem = lut ->Elements;\n\n                lut ->Elements = elem -> Next;\n                elem ->Next = NULL;\n                Unlinked = elem;\n\n            }\n            break;\n\n        case cmsAT_END:\n            Anterior = Last = NULL;\n            for (pt = lut ->Elements;\n                pt != NULL;\n                pt = pt -> Next) {\n                    Anterior = Last;\n                    Last = pt;\n            }\n\n            Unlinked = Last;  // Next already points to NULL\n\n            // Truncate the chain\n            if (Anterior)\n                Anterior ->Next = NULL;\n            else\n                lut ->Elements = NULL;\n            break;\n        default:;\n    }\n\n    if (mpe)\n        *mpe = Unlinked;\n    else\n        cmsStageFree(Unlinked);\n\n    // May fail, but we ignore it\n    BlessLUT(lut);\n}",
          "fn_code_pos": [
            [
              1554,
              0
            ],
            [
              1607,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineUnlinkStage",
            "parameters": {
              "lut": "cmsPipeline",
              "loc": "cmsStageLoc",
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT cmsPipelineCat(cmsPipeline* l1, const cmsPipeline* l2)\n{\n    cmsStage* mpe;\n\n    // If both LUTS does not have elements, we need to inherit\n    // the number of channels\n    if (l1 ->Elements == NULL && l2 ->Elements == NULL) {\n        l1 ->InputChannels  = l2 ->InputChannels;\n        l1 ->OutputChannels = l2 ->OutputChannels;\n    }\n\n    // Cat second\n    for (mpe = l2 ->Elements;\n         mpe != NULL;\n         mpe = mpe ->Next) {\n\n            // We have to dup each element\n            if (!cmsPipelineInsertStage(l1, cmsAT_END, cmsStageDup(mpe)))\n                return FALSE;\n    }\n\n    return BlessLUT(l1);    \n}",
          "fn_code_pos": [
            [
              1611,
              0
            ],
            [
              1633,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineCat",
            "parameters": {
              "l1": "cmsPipeline",
              "l2": "cmsPipeline"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsPipelineSetSaveAs8bitsFlag(cmsPipeline* lut, cmsBool On)\n{\n    cmsBool Anterior = lut ->SaveAs8Bits;\n\n    lut ->SaveAs8Bits = On;\n    return Anterior;\n}",
          "fn_code_pos": [
            [
              1636,
              0
            ],
            [
              1642,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineSetSaveAs8bitsFlag",
            "parameters": {
              "lut": "cmsPipeline",
              "On": "cmsBool"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsPipelineStageCount(const cmsPipeline* lut)\n{\n    cmsStage *mpe;\n    cmsUInt32Number n;\n\n    for (n=0, mpe = lut ->Elements; mpe != NULL; mpe = mpe ->Next)\n            n++;\n\n    return n;\n}",
          "fn_code_pos": [
            [
              1660,
              0
            ],
            [
              1669,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineStageCount",
            "parameters": {
              "lut": "cmsPipeline"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT _cmsPipelineSetOptimizationParameters(cmsPipeline* Lut,\n                                        _cmsPipelineEval16Fn Eval16,\n                                        void* PrivateData,\n                                        _cmsFreeUserDataFn FreePrivateDataFn,\n                                        _cmsDupUserDataFn  DupPrivateDataFn)\n{\n\n    Lut ->Eval16Fn = Eval16;\n    Lut ->DupDataFn = DupPrivateDataFn;\n    Lut ->FreeDataFn = FreePrivateDataFn;\n    Lut ->Data = PrivateData;\n}",
          "fn_code_pos": [
            [
              1673,
              0
            ],
            [
              1684,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsPipelineSetOptimizationParameters",
            "parameters": {
              "Lut": "cmsPipeline",
              "Eval16": "_cmsPipelineEval16Fn",
              "PrivateData": "void",
              "FreePrivateDataFn": "_cmsFreeUserDataFn",
              "DupPrivateDataFn": "_cmsDupUserDataFn"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid IncDelta(cmsFloat32Number *Val)\n{\n    if (*Val < (1.0 - JACOBIAN_EPSILON))\n\n        *Val += JACOBIAN_EPSILON;\n\n    else\n        *Val -= JACOBIAN_EPSILON;\n\n}",
          "fn_code_pos": [
            [
              1713,
              0
            ],
            [
              1723,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IncDelta",
            "parameters": {
              "Val": "cmsFloat32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsFloat32Number EuclideanDistance(cmsFloat32Number a[], cmsFloat32Number b[], int n)\n{\n    cmsFloat32Number sum = 0;\n    int i;\n\n    for (i=0; i < n; i++) {\n        cmsFloat32Number dif = b[i] - a[i];\n        sum +=  dif * dif;\n    }\n\n    return sqrtf(sum);\n}",
          "fn_code_pos": [
            [
              1728,
              0
            ],
            [
              1740,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EuclideanDistance",
            "parameters": {
              "a": "cmsFloat32Number",
              "b": "cmsFloat32Number",
              "n": "int"
            },
            "return_type": "cmsFloat32Number"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsPipelineEvalReverseFloat(cmsFloat32Number Target[],\n                                              cmsFloat32Number Result[],\n                                              cmsFloat32Number Hint[],\n                                              const cmsPipeline* lut)\n{\n    cmsUInt32Number  i, j;\n    cmsFloat64Number  error, LastError = 1E20;\n    cmsFloat32Number  fx[4], x[4], xd[4], fxd[4];\n    cmsVEC3 tmp, tmp2;\n    cmsMAT3 Jacobian;\n    \n    // Only 3->3 and 4->3 are supported\n    if (lut ->InputChannels != 3 && lut ->InputChannels != 4) return FALSE;\n    if (lut ->OutputChannels != 3) return FALSE;\n   \n    // Take the hint as starting point if specified\n    if (Hint == NULL) {\n\n        // Begin at any point, we choose 1/3 of CMY axis\n        x[0] = x[1] = x[2] = 0.3f;\n    }\n    else {\n\n        // Only copy 3 channels from hint...\n        for (j=0; j < 3; j++)\n            x[j] = Hint[j];\n    }\n\n    // If Lut is 4-dimensions, then grab target[3], which is fixed\n    if (lut ->InputChannels == 4) {\n        x[3] = Target[3];\n    }\n    else x[3] = 0; // To keep lint happy\n\n\n    // Iterate\n    for (i = 0; i < INVERSION_MAX_ITERATIONS; i++) {\n\n        // Get beginning fx\n        cmsPipelineEvalFloat(x, fx, lut);\n\n        // Compute error\n        error = EuclideanDistance(fx, Target, 3);\n\n        // If not convergent, return last safe value\n        if (error >= LastError)\n            break;\n\n        // Keep latest values\n        LastError     = error;\n        for (j=0; j < lut ->InputChannels; j++)\n                Result[j] = x[j];\n\n        // Found an exact match?\n        if (error <= 0)\n            break;\n\n        // Obtain slope (the Jacobian)\n        for (j = 0; j < 3; j++) {\n\n            xd[0] = x[0];\n            xd[1] = x[1];\n            xd[2] = x[2];\n            xd[3] = x[3];  // Keep fixed channel\n\n            IncDelta(&xd[j]);\n\n            cmsPipelineEvalFloat(xd, fxd, lut);\n\n            Jacobian.v[0].n[j] = ((fxd[0] - fx[0]) / JACOBIAN_EPSILON);\n            Jacobian.v[1].n[j] = ((fxd[1] - fx[1]) / JACOBIAN_EPSILON);\n            Jacobian.v[2].n[j] = ((fxd[2] - fx[2]) / JACOBIAN_EPSILON);\n        }\n\n        // Solve system\n        tmp2.n[0] = fx[0] - Target[0];\n        tmp2.n[1] = fx[1] - Target[1];\n        tmp2.n[2] = fx[2] - Target[2];\n\n        if (!_cmsMAT3solve(&tmp, &Jacobian, &tmp2))\n            return FALSE;\n\n        // Move our guess\n        x[0] -= (cmsFloat32Number) tmp.n[0];\n        x[1] -= (cmsFloat32Number) tmp.n[1];\n        x[2] -= (cmsFloat32Number) tmp.n[2];\n\n        // Some clipping....\n        for (j=0; j < 3; j++) {\n            if (x[j] < 0) x[j] = 0;\n            else\n                if (x[j] > 1.0) x[j] = 1.0;\n        }\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1752,
              0
            ],
            [
              1848,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineEvalReverseFloat",
            "parameters": {
              "Target": "cmsFloat32Number",
              "Result": "cmsFloat32Number",
              "Hint": "cmsFloat32Number",
              "lut": "cmsPipeline"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "_cmsStageGetPtrToCurveSet(const cmsStage* mpe)",
          "fn_dec_pos": [
            [
              158,
              15
            ],
            [
              158,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageGetPtrToCurveSet",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CurveSetDup(cmsStage* mpe)",
          "fn_dec_pos": [
            [
              208,
              6
            ],
            [
              208,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CurveSetDup",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "MatrixElemDup(cmsStage* mpe)",
          "fn_dec_pos": [
            [
              340,
              6
            ],
            [
              340,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MatrixElemDup",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CLUTElemDup(cmsStage* mpe)",
          "fn_dec_pos": [
            [
              484,
              6
            ],
            [
              484,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CLUTElemDup",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageAllocLabV2ToV4curves(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              987,
              10
            ],
            [
              987,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageAllocLabV2ToV4curves",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageNormalizeFromLabFloat(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              1061,
              10
            ],
            [
              1061,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageNormalizeFromLabFloat",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageNormalizeFromXyzFloat(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              1083,
              10
            ],
            [
              1083,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageNormalizeFromXyzFloat",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageNormalizeToLabFloat(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              1100,
              10
            ],
            [
              1100,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageNormalizeToLabFloat",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageNormalizeToXyzFloat(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              1120,
              10
            ],
            [
              1120,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageNormalizeToXyzFloat",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageClipNegatives(cmsContext ContextID, cmsUInt32Number nChannels)",
          "fn_dec_pos": [
            [
              1149,
              11
            ],
            [
              1149,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageClipNegatives",
            "parameters": {
              "ContextID": "cmsContext",
              "nChannels": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageAllocLabPrelin(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              1194,
              10
            ],
            [
              1194,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageAllocLabPrelin",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsStageData(const cmsStage* mpe)",
          "fn_dec_pos": [
            [
              1232,
              16
            ],
            [
              1232,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageData",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmspack.c": {
      "fn_def_list": [
        {
          "fn_code": "cmsINLINE cmsUInt16Number FomLabV2ToLabV4(cmsUInt16Number x)\n{\n    int a = (x << 8 | x) >> 8;  // * 257 / 256\n    if ( a > 0xffff) return 0xffff;\n    return (cmsUInt16Number) a;\n}",
          "fn_code_pos": [
            [
              44,
              0
            ],
            [
              49,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsUInt16Number FomLabV2ToLabV4",
            "parameters": {
              "x": "cmsUInt16Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE cmsUInt16Number FomLabV4ToLabV2(cmsUInt16Number x)\n{\n    return (cmsUInt16Number) (((x << 8) + 0x80) / 257);\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsUInt16Number FomLabV4ToLabV2",
            "parameters": {
              "x": "cmsUInt16Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollChunkyBytes(CMSREGISTER _cmsTRANSFORM* info,\n                                  CMSREGISTER cmsUInt16Number wIn[],\n                                  CMSREGISTER cmsUInt8Number* accum,\n                                  CMSREGISTER cmsUInt32Number Stride)\n{\n    cmsUInt32Number nChan      = T_CHANNELS(info -> InputFormat);\n    cmsUInt32Number DoSwap     = T_DOSWAP(info ->InputFormat);\n    cmsUInt32Number Reverse    = T_FLAVOR(info ->InputFormat);\n    cmsUInt32Number SwapFirst  = T_SWAPFIRST(info -> InputFormat);\n    cmsUInt32Number Extra      = T_EXTRA(info -> InputFormat);\n    cmsUInt32Number Premul     = T_PREMUL(info->InputFormat);\n\n    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n    cmsUInt32Number v;\n    cmsUInt32Number i;  \n    cmsUInt32Number alpha_factor = 1;\n\n    if (ExtraFirst) {\n        \n        if (Premul && Extra)\n            alpha_factor = _cmsToFixedDomain(FROM_8_TO_16(accum[0]));\n\n        accum += Extra;\n    }\n    else\n    {\n        if (Premul && Extra)        \n            alpha_factor = _cmsToFixedDomain(FROM_8_TO_16(accum[nChan]));\n    }\n\n    for (i=0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n        v = FROM_8_TO_16(*accum);\n        v = Reverse ? REVERSE_FLAVOR_16(v) : v;\n\n        if (Premul && alpha_factor > 0)\n        {\n            v = ((cmsUInt32Number)((cmsUInt32Number)v << 16) / alpha_factor);\n            if (v > 0xffff) v = 0xffff;\n        }\n\n        wIn[index] = (cmsUInt16Number) v;\n        accum++;\n    }\n\n    if (!ExtraFirst) {\n        accum += Extra;\n    }\n\n    if (Extra == 0 && SwapFirst) {\n        cmsUInt16Number tmp = wIn[0];\n\n        memmove(&wIn[0], &wIn[1], (nChan-1) * sizeof(cmsUInt16Number));\n        wIn[nChan-1] = tmp;\n    }\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n\n}",
          "fn_code_pos": [
            [
              94,
              0
            ],
            [
              158,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollChunkyBytes",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollPlanarBytes(CMSREGISTER _cmsTRANSFORM* info,\n                                  CMSREGISTER cmsUInt16Number wIn[],\n                                  CMSREGISTER cmsUInt8Number* accum,\n                                  CMSREGISTER cmsUInt32Number Stride)\n{\n    cmsUInt32Number nChan     = T_CHANNELS(info -> InputFormat);\n    cmsUInt32Number DoSwap    = T_DOSWAP(info ->InputFormat);\n    cmsUInt32Number SwapFirst = T_SWAPFIRST(info ->InputFormat);\n    cmsUInt32Number Reverse   = T_FLAVOR(info ->InputFormat);\n    cmsUInt32Number i;\n    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n    cmsUInt32Number Extra = T_EXTRA(info->InputFormat);\n    cmsUInt32Number Premul = T_PREMUL(info->InputFormat);\n    cmsUInt8Number* Init = accum;\n    cmsUInt32Number alpha_factor = 1;\n\n    if (ExtraFirst) {\n\n        if (Premul && Extra)        \n            alpha_factor = _cmsToFixedDomain(FROM_8_TO_16(accum[0]));\n\n\n        accum += Extra * Stride;\n    }\n    else\n    {\n        if (Premul && Extra)\n            alpha_factor = _cmsToFixedDomain(FROM_8_TO_16(accum[nChan * Stride]));\n    }\n\n    for (i=0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n        cmsUInt32Number v = FROM_8_TO_16(*accum);\n        \n        v = Reverse ? REVERSE_FLAVOR_16(v) : v;\n\n        if (Premul && alpha_factor > 0)\n        {\n            v = ((cmsUInt32Number)((cmsUInt32Number)v << 16) / alpha_factor);\n            if (v > 0xffff) v = 0xffff;\n        }\n\n        wIn[index] = (cmsUInt16Number) v;\n        accum += Stride;\n    }\n\n    return (Init + 1);\n}",
          "fn_code_pos": [
            [
              162,
              0
            ],
            [
              211,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollPlanarBytes",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll4Bytes(CMSREGISTER _cmsTRANSFORM* info,\n                             CMSREGISTER cmsUInt16Number wIn[],\n                             CMSREGISTER cmsUInt8Number* accum,\n                             CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[0] = FROM_8_TO_16(*accum); accum++; // C\n    wIn[1] = FROM_8_TO_16(*accum); accum++; // M\n    wIn[2] = FROM_8_TO_16(*accum); accum++; // Y\n    wIn[3] = FROM_8_TO_16(*accum); accum++; // K\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              215,
              0
            ],
            [
              230,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4Bytes",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll4BytesReverse(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wIn[],\n                                    CMSREGISTER cmsUInt8Number* accum,\n                                    CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[0] = FROM_8_TO_16(REVERSE_FLAVOR_8(*accum)); accum++; // C\n    wIn[1] = FROM_8_TO_16(REVERSE_FLAVOR_8(*accum)); accum++; // M\n    wIn[2] = FROM_8_TO_16(REVERSE_FLAVOR_8(*accum)); accum++; // Y\n    wIn[3] = FROM_8_TO_16(REVERSE_FLAVOR_8(*accum)); accum++; // K\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              232,
              0
            ],
            [
              247,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4BytesReverse",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll4BytesSwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                      CMSREGISTER cmsUInt16Number wIn[],\n                                      CMSREGISTER cmsUInt8Number* accum,\n                                      CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[3] = FROM_8_TO_16(*accum); accum++; // K\n    wIn[0] = FROM_8_TO_16(*accum); accum++; // C\n    wIn[1] = FROM_8_TO_16(*accum); accum++; // M\n    wIn[2] = FROM_8_TO_16(*accum); accum++; // Y\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              249,
              0
            ],
            [
              264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4BytesSwapFirst",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll4BytesSwap(CMSREGISTER _cmsTRANSFORM* info,\n                                 CMSREGISTER cmsUInt16Number wIn[],\n                                 CMSREGISTER cmsUInt8Number* accum,\n                                 CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[3] = FROM_8_TO_16(*accum); accum++;  // K\n    wIn[2] = FROM_8_TO_16(*accum); accum++;  // Y\n    wIn[1] = FROM_8_TO_16(*accum); accum++;  // M\n    wIn[0] = FROM_8_TO_16(*accum); accum++;  // C\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              267,
              0
            ],
            [
              282,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4BytesSwap",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll4BytesSwapSwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                          CMSREGISTER cmsUInt16Number wIn[],\n                                          CMSREGISTER cmsUInt8Number* accum,\n                                          CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[2] = FROM_8_TO_16(*accum); accum++;  // K\n    wIn[1] = FROM_8_TO_16(*accum); accum++;  // Y\n    wIn[0] = FROM_8_TO_16(*accum); accum++;  // M\n    wIn[3] = FROM_8_TO_16(*accum); accum++;  // C\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              284,
              0
            ],
            [
              299,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4BytesSwapSwapFirst",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll3Bytes(CMSREGISTER _cmsTRANSFORM* info,\n                             CMSREGISTER cmsUInt16Number wIn[],\n                             CMSREGISTER cmsUInt8Number* accum,\n                             CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[0] = FROM_8_TO_16(*accum); accum++;     // R\n    wIn[1] = FROM_8_TO_16(*accum); accum++;     // G\n    wIn[2] = FROM_8_TO_16(*accum); accum++;     // B\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              301,
              0
            ],
            [
              315,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll3Bytes",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll3BytesSkip1Swap(CMSREGISTER _cmsTRANSFORM* info,\n                                      CMSREGISTER cmsUInt16Number wIn[],\n                                      CMSREGISTER cmsUInt8Number* accum,\n                                      CMSREGISTER cmsUInt32Number Stride)\n{\n    accum++; // A\n    wIn[2] = FROM_8_TO_16(*accum); accum++; // B\n    wIn[1] = FROM_8_TO_16(*accum); accum++; // G\n    wIn[0] = FROM_8_TO_16(*accum); accum++; // R\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              317,
              0
            ],
            [
              332,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll3BytesSkip1Swap",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll3BytesSkip1SwapSwapFirst(CMSREGISTER _cmsTRANSFORM* info, \n                                              CMSREGISTER cmsUInt16Number wIn[], \n                                              CMSREGISTER cmsUInt8Number* accum,\n                                              CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[2] = FROM_8_TO_16(*accum); accum++; // B\n    wIn[1] = FROM_8_TO_16(*accum); accum++; // G\n    wIn[0] = FROM_8_TO_16(*accum); accum++; // R\n    accum++; // A\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              334,
              0
            ],
            [
              349,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll3BytesSkip1SwapSwapFirst",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll3BytesSkip1SwapFirst(CMSREGISTER _cmsTRANSFORM* info, \n                                           CMSREGISTER cmsUInt16Number wIn[], \n                                           CMSREGISTER cmsUInt8Number* accum,\n                                           CMSREGISTER cmsUInt32Number Stride)\n{\n    accum++; // A\n    wIn[0] = FROM_8_TO_16(*accum); accum++; // R\n    wIn[1] = FROM_8_TO_16(*accum); accum++; // G\n    wIn[2] = FROM_8_TO_16(*accum); accum++; // B\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              351,
              0
            ],
            [
              366,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll3BytesSkip1SwapFirst",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll3BytesSwap(CMSREGISTER _cmsTRANSFORM* info,\n                                 CMSREGISTER cmsUInt16Number wIn[],\n                                 CMSREGISTER cmsUInt8Number* accum,\n                                 CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[2] = FROM_8_TO_16(*accum); accum++;     // B\n    wIn[1] = FROM_8_TO_16(*accum); accum++;     // G\n    wIn[0] = FROM_8_TO_16(*accum); accum++;     // R\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              370,
              0
            ],
            [
              384,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll3BytesSwap",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollLabV2_8(CMSREGISTER _cmsTRANSFORM* info,\n                              CMSREGISTER cmsUInt16Number wIn[],\n                              CMSREGISTER cmsUInt8Number* accum,\n                              CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[0] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     // L\n    wIn[1] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     // a\n    wIn[2] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     // b\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              386,
              0
            ],
            [
              400,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollLabV2_8",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollALabV2_8(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wIn[],\n                               CMSREGISTER cmsUInt8Number* accum,\n                               CMSREGISTER cmsUInt32Number Stride)\n{\n    accum++;  // A\n    wIn[0] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     // L\n    wIn[1] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     // a\n    wIn[2] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     // b\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              402,
              0
            ],
            [
              417,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollALabV2_8",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollLabV2_16(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wIn[],\n                               CMSREGISTER cmsUInt8Number* accum,\n                               CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[0] = FomLabV2ToLabV4(*(cmsUInt16Number*) accum); accum += 2;     // L\n    wIn[1] = FomLabV2ToLabV4(*(cmsUInt16Number*) accum); accum += 2;     // a\n    wIn[2] = FomLabV2ToLabV4(*(cmsUInt16Number*) accum); accum += 2;     // b\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              419,
              0
            ],
            [
              433,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollLabV2_16",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll2Bytes(CMSREGISTER _cmsTRANSFORM* info,\n                                     CMSREGISTER cmsUInt16Number wIn[],\n                                     CMSREGISTER cmsUInt8Number* accum,\n                                     CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[0] = FROM_8_TO_16(*accum); accum++;     // ch1\n    wIn[1] = FROM_8_TO_16(*accum); accum++;     // ch2\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              436,
              0
            ],
            [
              449,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll2Bytes",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll1Byte(CMSREGISTER _cmsTRANSFORM* info,\n                            CMSREGISTER cmsUInt16Number wIn[],\n                            CMSREGISTER cmsUInt8Number* accum,\n                            CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[0] = wIn[1] = wIn[2] = FROM_8_TO_16(*accum); accum++;     // L\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              455,
              0
            ],
            [
              467,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll1Byte",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll1ByteSkip1(CMSREGISTER _cmsTRANSFORM* info,\n                                 CMSREGISTER cmsUInt16Number wIn[],\n                                 CMSREGISTER cmsUInt8Number* accum,\n                                 CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[0] = wIn[1] = wIn[2] = FROM_8_TO_16(*accum); accum++;     // L\n    accum += 1;\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              470,
              0
            ],
            [
              483,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll1ByteSkip1",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll1ByteSkip2(CMSREGISTER _cmsTRANSFORM* info,\n                                 CMSREGISTER cmsUInt16Number wIn[],\n                                 CMSREGISTER cmsUInt8Number* accum,\n                                 CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[0] = wIn[1] = wIn[2] = FROM_8_TO_16(*accum); accum++;     // L\n    accum += 2;\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              485,
              0
            ],
            [
              498,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll1ByteSkip2",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll1ByteReversed(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wIn[],\n                                    CMSREGISTER cmsUInt8Number* accum,\n                                    CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[0] = wIn[1] = wIn[2] = REVERSE_FLAVOR_16(FROM_8_TO_16(*accum)); accum++;     // L\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              500,
              0
            ],
            [
              512,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll1ByteReversed",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollAnyWords(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wIn[],\n                               CMSREGISTER cmsUInt8Number* accum,\n                               CMSREGISTER cmsUInt32Number Stride)\n{\n   cmsUInt32Number nChan       = T_CHANNELS(info -> InputFormat);\n   cmsUInt32Number SwapEndian  = T_ENDIAN16(info -> InputFormat);\n   cmsUInt32Number DoSwap      = T_DOSWAP(info ->InputFormat);\n   cmsUInt32Number Reverse     = T_FLAVOR(info ->InputFormat);\n   cmsUInt32Number SwapFirst   = T_SWAPFIRST(info -> InputFormat);\n   cmsUInt32Number Extra       = T_EXTRA(info -> InputFormat);\n   cmsUInt32Number ExtraFirst  = DoSwap ^ SwapFirst;\n   cmsUInt32Number i;\n\n    if (ExtraFirst) {\n        accum += Extra * sizeof(cmsUInt16Number);\n    }\n\n    for (i=0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n        cmsUInt16Number v = *(cmsUInt16Number*) accum;\n\n        if (SwapEndian)\n            v = CHANGE_ENDIAN(v);\n\n        wIn[index] = Reverse ? REVERSE_FLAVOR_16(v) : v;\n\n        accum += sizeof(cmsUInt16Number);\n    }\n\n    if (!ExtraFirst) {\n        accum += Extra * sizeof(cmsUInt16Number);\n    }\n\n    if (Extra == 0 && SwapFirst) {\n\n        cmsUInt16Number tmp = wIn[0];\n\n        memmove(&wIn[0], &wIn[1], (nChan-1) * sizeof(cmsUInt16Number));\n        wIn[nChan-1] = tmp;\n    }\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              515,
              0
            ],
            [
              562,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollAnyWords",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollAnyWordsPremul(CMSREGISTER _cmsTRANSFORM* info,\n                                     CMSREGISTER cmsUInt16Number wIn[],\n                                     CMSREGISTER cmsUInt8Number* accum,\n                                     CMSREGISTER cmsUInt32Number Stride)\n{\n   cmsUInt32Number nChan       = T_CHANNELS(info -> InputFormat);\n   cmsUInt32Number SwapEndian  = T_ENDIAN16(info -> InputFormat);\n   cmsUInt32Number DoSwap      = T_DOSWAP(info ->InputFormat);\n   cmsUInt32Number Reverse     = T_FLAVOR(info ->InputFormat);\n   cmsUInt32Number SwapFirst   = T_SWAPFIRST(info -> InputFormat);   \n   cmsUInt32Number ExtraFirst  = DoSwap ^ SwapFirst;\n   cmsUInt32Number i;\n\n   cmsUInt16Number alpha = (ExtraFirst ? ((cmsUInt16Number*)accum)[0] : ((cmsUInt16Number*)accum)[nChan]);\n   cmsUInt32Number alpha_factor = _cmsToFixedDomain(alpha);\n\n    if (ExtraFirst) {\n        accum += sizeof(cmsUInt16Number);\n    }\n\n    for (i=0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n        cmsUInt32Number v = *(cmsUInt16Number*) accum;\n\n        if (SwapEndian)\n            v = CHANGE_ENDIAN(v);\n\n        if (alpha_factor > 0) {\n\n            v = (v << 16) / alpha_factor;\n            if (v > 0xffff) v = 0xffff;\n        }\n\n        wIn[index] = (cmsUInt16Number) (Reverse ? REVERSE_FLAVOR_16(v) : v);\n\n        accum += sizeof(cmsUInt16Number);\n    }\n\n    if (!ExtraFirst) {\n        accum += sizeof(cmsUInt16Number);\n    }\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              565,
              0
            ],
            [
              612,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollAnyWordsPremul",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollPlanarWords(CMSREGISTER _cmsTRANSFORM* info,\n                                  CMSREGISTER cmsUInt16Number wIn[],\n                                  CMSREGISTER cmsUInt8Number* accum,\n                                  CMSREGISTER cmsUInt32Number Stride)\n{\n    cmsUInt32Number nChan = T_CHANNELS(info -> InputFormat);\n    cmsUInt32Number DoSwap= T_DOSWAP(info ->InputFormat);\n    cmsUInt32Number Reverse= T_FLAVOR(info ->InputFormat);\n    cmsUInt32Number SwapEndian = T_ENDIAN16(info -> InputFormat);\n    cmsUInt32Number i;\n    cmsUInt8Number* Init = accum;\n\n    if (DoSwap) {\n        accum += T_EXTRA(info -> InputFormat) * Stride;\n    }\n\n    for (i=0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n        cmsUInt16Number v = *(cmsUInt16Number*) accum;\n\n        if (SwapEndian)\n            v = CHANGE_ENDIAN(v);\n\n        wIn[index] = Reverse ? REVERSE_FLAVOR_16(v) : v;\n\n        accum +=  Stride;\n    }\n\n    return (Init + sizeof(cmsUInt16Number));\n}",
          "fn_code_pos": [
            [
              616,
              0
            ],
            [
              647,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollPlanarWords",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollPlanarWordsPremul(CMSREGISTER _cmsTRANSFORM* info,\n                                        CMSREGISTER cmsUInt16Number wIn[],\n                                        CMSREGISTER cmsUInt8Number* accum,\n                                        CMSREGISTER cmsUInt32Number Stride)\n{\n    cmsUInt32Number nChan = T_CHANNELS(info -> InputFormat);\n    cmsUInt32Number DoSwap= T_DOSWAP(info ->InputFormat);\n    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->InputFormat);\n    cmsUInt32Number Reverse= T_FLAVOR(info ->InputFormat);\n    cmsUInt32Number SwapEndian = T_ENDIAN16(info -> InputFormat);\n    cmsUInt32Number i;\n    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n    cmsUInt8Number* Init = accum;\n    \n    cmsUInt16Number alpha = (ExtraFirst ? ((cmsUInt16Number*)accum)[0] : ((cmsUInt16Number*)accum)[nChan * Stride / 2]);\n    cmsUInt32Number alpha_factor = _cmsToFixedDomain(alpha);\n\n    if (ExtraFirst) {\n        accum += Stride;\n    }\n\n    for (i=0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n        cmsUInt32Number v = (cmsUInt32Number) *(cmsUInt16Number*) accum;\n\n        if (SwapEndian)\n            v = CHANGE_ENDIAN(v);\n\n        if (alpha_factor > 0) {\n\n            v = (v << 16) / alpha_factor;\n            if (v > 0xffff) v = 0xffff;\n        }\n\n        wIn[index] = (cmsUInt16Number) (Reverse ? REVERSE_FLAVOR_16(v) : v);\n\n        accum +=  Stride;\n    }\n\n    return (Init + sizeof(cmsUInt16Number));\n}",
          "fn_code_pos": [
            [
              649,
              0
            ],
            [
              691,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollPlanarWordsPremul",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll4Words(CMSREGISTER _cmsTRANSFORM* info,\n                             CMSREGISTER cmsUInt16Number wIn[],\n                             CMSREGISTER cmsUInt8Number* accum,\n                             CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[0] = *(cmsUInt16Number*) accum; accum+= 2; // C\n    wIn[1] = *(cmsUInt16Number*) accum; accum+= 2; // M\n    wIn[2] = *(cmsUInt16Number*) accum; accum+= 2; // Y\n    wIn[3] = *(cmsUInt16Number*) accum; accum+= 2; // K\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              693,
              0
            ],
            [
              708,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4Words",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll4WordsReverse(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wIn[],\n                                    CMSREGISTER cmsUInt8Number* accum,\n                                    CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[0] = REVERSE_FLAVOR_16(*(cmsUInt16Number*) accum); accum+= 2; // C\n    wIn[1] = REVERSE_FLAVOR_16(*(cmsUInt16Number*) accum); accum+= 2; // M\n    wIn[2] = REVERSE_FLAVOR_16(*(cmsUInt16Number*) accum); accum+= 2; // Y\n    wIn[3] = REVERSE_FLAVOR_16(*(cmsUInt16Number*) accum); accum+= 2; // K\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              710,
              0
            ],
            [
              725,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4WordsReverse",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll4WordsSwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                      CMSREGISTER cmsUInt16Number wIn[],\n                                      CMSREGISTER cmsUInt8Number* accum,\n                                      CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[3] = *(cmsUInt16Number*) accum; accum+= 2; // K\n    wIn[0] = *(cmsUInt16Number*) accum; accum+= 2; // C\n    wIn[1] = *(cmsUInt16Number*) accum; accum+= 2; // M\n    wIn[2] = *(cmsUInt16Number*) accum; accum+= 2; // Y\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              727,
              0
            ],
            [
              742,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4WordsSwapFirst",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll4WordsSwap(CMSREGISTER _cmsTRANSFORM* info,\n                                 CMSREGISTER cmsUInt16Number wIn[],\n                                 CMSREGISTER cmsUInt8Number* accum,\n                                 CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[3] = *(cmsUInt16Number*) accum; accum+= 2; // K\n    wIn[2] = *(cmsUInt16Number*) accum; accum+= 2; // Y\n    wIn[1] = *(cmsUInt16Number*) accum; accum+= 2; // M\n    wIn[0] = *(cmsUInt16Number*) accum; accum+= 2; // C\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              745,
              0
            ],
            [
              760,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4WordsSwap",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll4WordsSwapSwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                          CMSREGISTER cmsUInt16Number wIn[],\n                                          CMSREGISTER cmsUInt8Number* accum,\n                                          CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[2] = *(cmsUInt16Number*) accum; accum+= 2; // K\n    wIn[1] = *(cmsUInt16Number*) accum; accum+= 2; // Y\n    wIn[0] = *(cmsUInt16Number*) accum; accum+= 2; // M\n    wIn[3] = *(cmsUInt16Number*) accum; accum+= 2; // C\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              762,
              0
            ],
            [
              777,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4WordsSwapSwapFirst",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll3Words(CMSREGISTER _cmsTRANSFORM* info,\n                             CMSREGISTER cmsUInt16Number wIn[],\n                             CMSREGISTER cmsUInt8Number* accum,\n                             CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[0] = *(cmsUInt16Number*) accum; accum+= 2;  // C R\n    wIn[1] = *(cmsUInt16Number*) accum; accum+= 2;  // M G\n    wIn[2] = *(cmsUInt16Number*) accum; accum+= 2;  // Y B\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              779,
              0
            ],
            [
              793,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll3Words",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll3WordsSwap(CMSREGISTER _cmsTRANSFORM* info,\n                                 CMSREGISTER cmsUInt16Number wIn[],\n                                 CMSREGISTER cmsUInt8Number* accum,\n                                 CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[2] = *(cmsUInt16Number*) accum; accum+= 2;  // C R\n    wIn[1] = *(cmsUInt16Number*) accum; accum+= 2;  // M G\n    wIn[0] = *(cmsUInt16Number*) accum; accum+= 2;  // Y B\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              795,
              0
            ],
            [
              809,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll3WordsSwap",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll3WordsSkip1Swap(CMSREGISTER _cmsTRANSFORM* info,\n                                      CMSREGISTER cmsUInt16Number wIn[],\n                                      CMSREGISTER cmsUInt8Number* accum,\n                                      CMSREGISTER cmsUInt32Number Stride)\n{\n    accum += 2; // A\n    wIn[2] = *(cmsUInt16Number*) accum; accum += 2; // R\n    wIn[1] = *(cmsUInt16Number*) accum; accum += 2; // G\n    wIn[0] = *(cmsUInt16Number*) accum; accum += 2; // B\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              811,
              0
            ],
            [
              826,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll3WordsSkip1Swap",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll3WordsSkip1SwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                           CMSREGISTER cmsUInt16Number wIn[],\n                                           CMSREGISTER cmsUInt8Number* accum,\n                                           CMSREGISTER cmsUInt32Number Stride)\n{\n    accum += 2; // A\n    wIn[0] = *(cmsUInt16Number*) accum; accum += 2; // R\n    wIn[1] = *(cmsUInt16Number*) accum; accum += 2; // G\n    wIn[2] = *(cmsUInt16Number*) accum; accum += 2; // B\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              828,
              0
            ],
            [
              843,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll3WordsSkip1SwapFirst",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll1Word(CMSREGISTER _cmsTRANSFORM* info,\n                            CMSREGISTER cmsUInt16Number wIn[],\n                            CMSREGISTER cmsUInt8Number* accum,\n                            CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[0] = wIn[1] = wIn[2] = *(cmsUInt16Number*) accum; accum+= 2;   // L\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              845,
              0
            ],
            [
              857,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll1Word",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll1WordReversed(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wIn[],\n                                    CMSREGISTER cmsUInt8Number* accum,\n                                    CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[0] = wIn[1] = wIn[2] = REVERSE_FLAVOR_16(*(cmsUInt16Number*) accum); accum+= 2;\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              859,
              0
            ],
            [
              871,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll1WordReversed",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll1WordSkip3(CMSREGISTER _cmsTRANSFORM* info,\n                                 CMSREGISTER cmsUInt16Number wIn[],\n                                 CMSREGISTER cmsUInt8Number* accum,\n                                 CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[0] = wIn[1] = wIn[2] = *(cmsUInt16Number*) accum;\n\n    accum += 8;\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              873,
              0
            ],
            [
              887,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll1WordSkip3",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll2Words(CMSREGISTER _cmsTRANSFORM* info,\n                                     CMSREGISTER cmsUInt16Number wIn[],\n                                     CMSREGISTER cmsUInt8Number* accum,\n                                     CMSREGISTER cmsUInt32Number Stride)\n{\n    wIn[0] = *(cmsUInt16Number*) accum; accum += 2;    // ch1\n    wIn[1] = *(cmsUInt16Number*) accum; accum += 2;    // ch2\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              889,
              0
            ],
            [
              902,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll2Words",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollLabDoubleTo16(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wIn[],\n                                    CMSREGISTER cmsUInt8Number* accum,\n                                    CMSREGISTER cmsUInt32Number  Stride)\n{\n    if (T_PLANAR(info -> InputFormat)) {\n\n        cmsCIELab Lab;\n        cmsUInt8Number* pos_L;\n        cmsUInt8Number* pos_a;\n        cmsUInt8Number* pos_b;\n        \n        pos_L = accum;\n        pos_a = accum + Stride;\n        pos_b = accum + Stride * 2;\n\n        Lab.L = *(cmsFloat64Number*) pos_L;\n        Lab.a = *(cmsFloat64Number*) pos_a;\n        Lab.b = *(cmsFloat64Number*) pos_b;\n\n        cmsFloat2LabEncoded(wIn, &Lab);\n        return accum + sizeof(cmsFloat64Number);\n    }\n    else {\n\n        cmsFloat2LabEncoded(wIn, (cmsCIELab*) accum);\n        accum += sizeof(cmsCIELab) + T_EXTRA(info ->InputFormat) * sizeof(cmsFloat64Number);\n        return accum;\n    }\n}",
          "fn_code_pos": [
            [
              906,
              0
            ],
            [
              936,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollLabDoubleTo16",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollLabFloatTo16(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wIn[],\n                                    CMSREGISTER cmsUInt8Number* accum,\n                                    CMSREGISTER cmsUInt32Number  Stride)\n{\n    cmsCIELab Lab;\n    \n    if (T_PLANAR(info -> InputFormat)) {\n\n        cmsUInt8Number* pos_L;\n        cmsUInt8Number* pos_a;\n        cmsUInt8Number* pos_b;\n\n        pos_L = accum;\n        pos_a = accum + Stride;\n        pos_b = accum + Stride * 2;\n\n        Lab.L = *(cmsFloat32Number*)pos_L;\n        Lab.a = *(cmsFloat32Number*)pos_a;\n        Lab.b = *(cmsFloat32Number*)pos_b;\n\n        cmsFloat2LabEncoded(wIn, &Lab);\n        return accum + sizeof(cmsFloat32Number);\n    }\n    else {\n \n        Lab.L = ((cmsFloat32Number*) accum)[0];\n        Lab.a = ((cmsFloat32Number*) accum)[1];\n        Lab.b = ((cmsFloat32Number*) accum)[2];\n\n        cmsFloat2LabEncoded(wIn, &Lab);\n        accum += (3 + T_EXTRA(info ->InputFormat)) * sizeof(cmsFloat32Number);\n        return accum;\n    }\n}",
          "fn_code_pos": [
            [
              940,
              0
            ],
            [
              975,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollLabFloatTo16",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollXYZDoubleTo16(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wIn[],\n                                    CMSREGISTER cmsUInt8Number* accum,\n                                    CMSREGISTER cmsUInt32Number Stride)\n{\n    if (T_PLANAR(info -> InputFormat)) {\n\n        cmsCIEXYZ XYZ;\n        cmsUInt8Number* pos_X;\n        cmsUInt8Number* pos_Y;\n        cmsUInt8Number* pos_Z;\n\n        pos_X = accum;\n        pos_Y = accum + Stride;\n        pos_Z = accum + Stride * 2;\n\n        XYZ.X = *(cmsFloat64Number*)pos_X;\n        XYZ.Y = *(cmsFloat64Number*)pos_Y;\n        XYZ.Z = *(cmsFloat64Number*)pos_Z;\n\n        cmsFloat2XYZEncoded(wIn, &XYZ);\n\n        return accum + sizeof(cmsFloat64Number);\n\n    }\n\n    else {\n        cmsFloat2XYZEncoded(wIn, (cmsCIEXYZ*) accum);\n        accum += sizeof(cmsCIEXYZ) + T_EXTRA(info ->InputFormat) * sizeof(cmsFloat64Number);\n\n        return accum;\n    }\n}",
          "fn_code_pos": [
            [
              978,
              0
            ],
            [
              1011,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollXYZDoubleTo16",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollXYZFloatTo16(CMSREGISTER _cmsTRANSFORM* info,\n                                   CMSREGISTER cmsUInt16Number wIn[],\n                                   CMSREGISTER cmsUInt8Number* accum,\n                                   CMSREGISTER cmsUInt32Number Stride)\n{\n    if (T_PLANAR(info -> InputFormat)) {\n\n        cmsCIEXYZ XYZ;\n        cmsUInt8Number* pos_X;\n        cmsUInt8Number* pos_Y;\n        cmsUInt8Number* pos_Z;\n\n        pos_X = accum;\n        pos_Y = accum + Stride;\n        pos_Z = accum + Stride * 2;\n\n        XYZ.X = *(cmsFloat32Number*)pos_X;\n        XYZ.Y = *(cmsFloat32Number*)pos_Y;\n        XYZ.Z = *(cmsFloat32Number*)pos_Z;\n\n        cmsFloat2XYZEncoded(wIn, &XYZ);\n\n        return accum + sizeof(cmsFloat32Number);\n\n    }\n\n    else {\n        cmsFloat32Number* Pt = (cmsFloat32Number*) accum;\n        cmsCIEXYZ XYZ;\n\n        XYZ.X = Pt[0];\n        XYZ.Y = Pt[1];\n        XYZ.Z = Pt[2];\n        cmsFloat2XYZEncoded(wIn, &XYZ);\n\n        accum += 3 * sizeof(cmsFloat32Number) + T_EXTRA(info ->InputFormat) * sizeof(cmsFloat32Number);\n\n        return accum;\n    }\n}",
          "fn_code_pos": [
            [
              1014,
              0
            ],
            [
              1054,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollXYZFloatTo16",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "cmsINLINE cmsBool IsInkSpace(cmsUInt32Number Type)\n{\n    switch (T_COLORSPACE(Type)) {\n\n     case PT_CMY:\n     case PT_CMYK:\n     case PT_MCH5:\n     case PT_MCH6:\n     case PT_MCH7:\n     case PT_MCH8:\n     case PT_MCH9:\n     case PT_MCH10:\n     case PT_MCH11:\n     case PT_MCH12:\n     case PT_MCH13:\n     case PT_MCH14:\n     case PT_MCH15: return TRUE;\n\n     default: return FALSE;\n    }\n}",
          "fn_code_pos": [
            [
              1057,
              0
            ],
            [
              1077,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsInkSpace",
            "parameters": {
              "Type": "cmsUInt32Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE cmsUInt32Number PixelSize(cmsUInt32Number Format)\n{\n    cmsUInt32Number fmt_bytes = T_BYTES(Format);\n\n    // For double, the T_BYTES field is zero\n    if (fmt_bytes == 0)\n        return sizeof(cmsUInt64Number);\n\n    // Otherwise, it is already correct for all formats\n    return fmt_bytes;\n}",
          "fn_code_pos": [
            [
              1080,
              0
            ],
            [
              1090,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsUInt32Number PixelSize",
            "parameters": {
              "Format": "cmsUInt32Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollDoubleTo16(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wIn[],\n                                CMSREGISTER cmsUInt8Number* accum,\n                                CMSREGISTER cmsUInt32Number Stride)\n{\n\n    cmsUInt32Number nChan      = T_CHANNELS(info -> InputFormat);\n    cmsUInt32Number DoSwap     = T_DOSWAP(info ->InputFormat);\n    cmsUInt32Number Reverse    = T_FLAVOR(info ->InputFormat);\n    cmsUInt32Number SwapFirst  = T_SWAPFIRST(info -> InputFormat);\n    cmsUInt32Number Extra      = T_EXTRA(info -> InputFormat);\n    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n    cmsUInt32Number Planar     = T_PLANAR(info -> InputFormat);\n    cmsFloat64Number v;\n    cmsUInt16Number  vi;\n    cmsUInt32Number i, start = 0;\n    cmsFloat64Number maximum = IsInkSpace(info ->InputFormat) ? 655.35 : 65535.0;\n\n\n    Stride /= PixelSize(info->InputFormat);\n\n    if (ExtraFirst)\n            start = Extra;\n\n    for (i=0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n        if (Planar)\n            v = (cmsFloat32Number) ((cmsFloat64Number*) accum)[(i + start) * Stride];\n        else\n            v = (cmsFloat32Number) ((cmsFloat64Number*) accum)[i + start];\n\n        vi = _cmsQuickSaturateWord(v * maximum);\n\n        if (Reverse)\n            vi = REVERSE_FLAVOR_16(vi);\n\n        wIn[index] = vi;\n    }\n\n\n    if (Extra == 0 && SwapFirst) {\n        cmsUInt16Number tmp = wIn[0];\n\n        memmove(&wIn[0], &wIn[1], (nChan-1) * sizeof(cmsUInt16Number));\n        wIn[nChan-1] = tmp;\n    }\n\n    if (T_PLANAR(info -> InputFormat))\n        return accum + sizeof(cmsFloat64Number);\n    else\n        return accum + (nChan + Extra) * sizeof(cmsFloat64Number);\n}",
          "fn_code_pos": [
            [
              1093,
              0
            ],
            [
              1147,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollDoubleTo16",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollFloatTo16(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wIn[],\n                                CMSREGISTER cmsUInt8Number* accum,\n                                CMSREGISTER cmsUInt32Number Stride)\n{\n\n    cmsUInt32Number nChan  = T_CHANNELS(info -> InputFormat);\n    cmsUInt32Number DoSwap   = T_DOSWAP(info ->InputFormat);\n    cmsUInt32Number Reverse    = T_FLAVOR(info ->InputFormat);\n    cmsUInt32Number SwapFirst  = T_SWAPFIRST(info -> InputFormat);\n    cmsUInt32Number Extra   = T_EXTRA(info -> InputFormat);\n    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n    cmsUInt32Number Planar     = T_PLANAR(info -> InputFormat);\n    cmsFloat32Number v;\n    cmsUInt16Number  vi;\n    cmsUInt32Number i, start = 0;\n    cmsFloat64Number maximum = IsInkSpace(info ->InputFormat) ? 655.35 : 65535.0;\n\n    Stride /= PixelSize(info->InputFormat);\n\n    if (ExtraFirst)\n            start = Extra;\n\n    for (i=0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n        if (Planar)\n            v = (cmsFloat32Number) ((cmsFloat32Number*) accum)[(i + start) * Stride];\n        else\n            v = (cmsFloat32Number) ((cmsFloat32Number*) accum)[i + start];\n\n        vi = _cmsQuickSaturateWord(v * maximum);\n\n        if (Reverse)\n            vi = REVERSE_FLAVOR_16(vi);\n\n        wIn[index] = vi;\n    }\n\n\n    if (Extra == 0 && SwapFirst) {\n        cmsUInt16Number tmp = wIn[0];\n\n        memmove(&wIn[0], &wIn[1], (nChan-1) * sizeof(cmsUInt16Number));\n        wIn[nChan-1] = tmp;\n    }\n\n    if (T_PLANAR(info -> InputFormat))\n        return accum + sizeof(cmsFloat32Number);\n    else\n        return accum + (nChan + Extra) * sizeof(cmsFloat32Number);\n}",
          "fn_code_pos": [
            [
              1151,
              0
            ],
            [
              1204,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollFloatTo16",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollDouble1Chan(CMSREGISTER _cmsTRANSFORM* info,\n                                  CMSREGISTER cmsUInt16Number wIn[],\n                                  CMSREGISTER cmsUInt8Number* accum,\n                                  CMSREGISTER cmsUInt32Number Stride)\n{\n    cmsFloat64Number* Inks = (cmsFloat64Number*) accum;\n\n    wIn[0] = wIn[1] = wIn[2] = _cmsQuickSaturateWord(Inks[0] * 65535.0);\n\n    return accum + sizeof(cmsFloat64Number);\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              1210,
              0
            ],
            [
              1224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollDouble1Chan",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll8ToFloat(_cmsTRANSFORM* info,\n                               cmsFloat32Number wIn[],\n                               cmsUInt8Number* accum,\n                               cmsUInt32Number Stride)\n{\n\n    cmsUInt32Number nChan = T_CHANNELS(info->InputFormat);\n    cmsUInt32Number DoSwap = T_DOSWAP(info->InputFormat);\n    cmsUInt32Number Reverse = T_FLAVOR(info->InputFormat);\n    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->InputFormat);\n    cmsUInt32Number Extra = T_EXTRA(info->InputFormat);\n    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n    cmsUInt32Number Planar = T_PLANAR(info->InputFormat);\n    cmsFloat32Number v;\n    cmsUInt32Number i, start = 0;\n    \n    Stride /= PixelSize(info->InputFormat);\n\n    if (ExtraFirst)\n        start = Extra;\n\n    for (i = 0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n        if (Planar)\n            v = (cmsFloat32Number) ((cmsUInt8Number *)accum)[(i + start) * Stride];\n        else\n            v = (cmsFloat32Number) ((cmsUInt8Number *)accum)[i + start];\n\n        v /= 255.0F;\n\n        wIn[index] = Reverse ? 1 - v : v;\n    }\n\n\n    if (Extra == 0 && SwapFirst) {\n        cmsFloat32Number tmp = wIn[0];\n\n        memmove(&wIn[0], &wIn[1], (nChan - 1) * sizeof(cmsFloat32Number));\n        wIn[nChan - 1] = tmp;\n    }\n\n    if (T_PLANAR(info->InputFormat))\n        return accum + sizeof(cmsUInt8Number);\n    else\n        return accum + (nChan + Extra) * sizeof(cmsUInt8Number);\n}",
          "fn_code_pos": [
            [
              1229,
              0
            ],
            [
              1277,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll8ToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Unroll16ToFloat(_cmsTRANSFORM* info,\n                                cmsFloat32Number wIn[],\n                                cmsUInt8Number* accum,\n                                cmsUInt32Number Stride)\n{\n\n    cmsUInt32Number nChan = T_CHANNELS(info->InputFormat);\n    cmsUInt32Number DoSwap = T_DOSWAP(info->InputFormat);\n    cmsUInt32Number Reverse = T_FLAVOR(info->InputFormat);\n    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->InputFormat);\n    cmsUInt32Number Extra = T_EXTRA(info->InputFormat);\n    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n    cmsUInt32Number Planar = T_PLANAR(info->InputFormat);\n    cmsFloat32Number v;\n    cmsUInt32Number i, start = 0;\n\n    Stride /= PixelSize(info->InputFormat);\n\n    if (ExtraFirst)\n        start = Extra;\n\n    for (i = 0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n        if (Planar)\n            v = (cmsFloat32Number)((cmsUInt16Number*)accum)[(i + start) * Stride];\n        else\n            v = (cmsFloat32Number)((cmsUInt16Number*)accum)[i + start];\n\n        v /= 65535.0F;\n\n        wIn[index] = Reverse ? 1 - v : v;\n    }\n\n\n    if (Extra == 0 && SwapFirst) {\n        cmsFloat32Number tmp = wIn[0];\n\n        memmove(&wIn[0], &wIn[1], (nChan - 1) * sizeof(cmsFloat32Number));\n        wIn[nChan - 1] = tmp;\n    }\n\n    if (T_PLANAR(info->InputFormat))\n        return accum + sizeof(cmsUInt16Number);\n    else\n        return accum + (nChan + Extra) * sizeof(cmsUInt16Number);\n}",
          "fn_code_pos": [
            [
              1281,
              0
            ],
            [
              1329,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll16ToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollFloatsToFloat(_cmsTRANSFORM* info,\n                                    cmsFloat32Number wIn[],\n                                    cmsUInt8Number* accum,\n                                    cmsUInt32Number Stride)\n{\n\n    cmsUInt32Number nChan = T_CHANNELS(info->InputFormat);\n    cmsUInt32Number DoSwap = T_DOSWAP(info->InputFormat);\n    cmsUInt32Number Reverse = T_FLAVOR(info->InputFormat);\n    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->InputFormat);\n    cmsUInt32Number Extra = T_EXTRA(info->InputFormat);\n    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n    cmsUInt32Number Planar = T_PLANAR(info->InputFormat);\n    cmsUInt32Number Premul = T_PREMUL(info->InputFormat);\n    cmsFloat32Number v;\n    cmsUInt32Number i, start = 0;\n    cmsFloat32Number maximum = IsInkSpace(info->InputFormat) ? 100.0F : 1.0F;\n    cmsFloat32Number alpha_factor = 1.0f;\n    cmsFloat32Number* ptr = (cmsFloat32Number*)accum;\n\n    Stride /= PixelSize(info->InputFormat);\n\n    if (Premul && Extra)\n    {        \n        if (Planar)\n            alpha_factor = (ExtraFirst ? ptr[0] : ptr[nChan * Stride]) / maximum;\n        else\n            alpha_factor = (ExtraFirst ? ptr[0] : ptr[nChan]) / maximum;        \n    }\n\n    if (ExtraFirst)\n            start = Extra;\n\n    for (i=0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n        if (Planar)\n            v = ptr[(i + start) * Stride];\n        else\n            v = ptr[i + start];\n\n        if (Premul && alpha_factor > 0)\n            v /= alpha_factor;\n\n        v /= maximum;\n\n        wIn[index] = Reverse ? 1 - v : v;\n    }\n\n\n    if (Extra == 0 && SwapFirst) {\n        cmsFloat32Number tmp = wIn[0];\n\n        memmove(&wIn[0], &wIn[1], (nChan-1) * sizeof(cmsFloat32Number));\n        wIn[nChan-1] = tmp;\n    }\n\n    if (T_PLANAR(info -> InputFormat))\n        return accum + sizeof(cmsFloat32Number);\n    else\n        return accum + (nChan + Extra) * sizeof(cmsFloat32Number);\n}",
          "fn_code_pos": [
            [
              1333,
              0
            ],
            [
              1396,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollFloatsToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollDoublesToFloat(_cmsTRANSFORM* info,\n                                    cmsFloat32Number wIn[],\n                                    cmsUInt8Number* accum,\n                                    cmsUInt32Number Stride)\n{\n\n    cmsUInt32Number nChan = T_CHANNELS(info->InputFormat);\n    cmsUInt32Number DoSwap = T_DOSWAP(info->InputFormat);\n    cmsUInt32Number Reverse = T_FLAVOR(info->InputFormat);\n    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->InputFormat);\n    cmsUInt32Number Extra = T_EXTRA(info->InputFormat);\n    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n    cmsUInt32Number Planar = T_PLANAR(info->InputFormat);\n    cmsUInt32Number Premul = T_PREMUL(info->InputFormat);\n    cmsFloat64Number v;\n    cmsUInt32Number i, start = 0;\n    cmsFloat64Number maximum = IsInkSpace(info ->InputFormat) ? 100.0 : 1.0;\n    cmsFloat64Number alpha_factor = 1.0;\n    cmsFloat64Number* ptr = (cmsFloat64Number*)accum;\n\n    Stride /= PixelSize(info->InputFormat);\n\n    if (Premul && Extra)\n    {\n        if (Planar)\n            alpha_factor = (ExtraFirst ? ptr[0] : ptr[nChan * Stride]) / maximum;\n        else\n            alpha_factor = (ExtraFirst ? ptr[0] : ptr[nChan]) / maximum;\n    }\n   \n    if (ExtraFirst)\n            start = Extra;\n\n    for (i=0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n        if (Planar)\n            v = (cmsFloat64Number) ((cmsFloat64Number*) accum)[(i + start)  * Stride];\n        else\n            v = (cmsFloat64Number) ((cmsFloat64Number*) accum)[i + start];\n\n\n        if (Premul && alpha_factor > 0)\n            v /= alpha_factor;\n\n        v /= maximum;\n\n        wIn[index] = (cmsFloat32Number) (Reverse ? 1.0 - v : v);\n    }\n\n\n    if (Extra == 0 && SwapFirst) {\n        cmsFloat32Number tmp = wIn[0];\n\n        memmove(&wIn[0], &wIn[1], (nChan-1) * sizeof(cmsFloat32Number));\n        wIn[nChan-1] = tmp;\n    }\n\n    if (T_PLANAR(info -> InputFormat))\n        return accum + sizeof(cmsFloat64Number);\n    else\n        return accum + (nChan + Extra) * sizeof(cmsFloat64Number);\n}",
          "fn_code_pos": [
            [
              1400,
              0
            ],
            [
              1464,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollDoublesToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollLabDoubleToFloat(_cmsTRANSFORM* info,\n                                       cmsFloat32Number wIn[],\n                                       cmsUInt8Number* accum,\n                                       cmsUInt32Number Stride)\n{\n    cmsFloat64Number* Pt = (cmsFloat64Number*) accum;\n\n    if (T_PLANAR(info -> InputFormat)) {\n\n        Stride /= PixelSize(info->InputFormat);\n\n        wIn[0] = (cmsFloat32Number) (Pt[0] / 100.0);                 // from 0..100 to 0..1\n        wIn[1] = (cmsFloat32Number) ((Pt[Stride] + 128) / 255.0);    // form -128..+127 to 0..1\n        wIn[2] = (cmsFloat32Number) ((Pt[Stride*2] + 128) / 255.0);\n\n        return accum + sizeof(cmsFloat64Number);\n    }\n    else {\n\n        wIn[0] = (cmsFloat32Number) (Pt[0] / 100.0);            // from 0..100 to 0..1\n        wIn[1] = (cmsFloat32Number) ((Pt[1] + 128) / 255.0);    // form -128..+127 to 0..1\n        wIn[2] = (cmsFloat32Number) ((Pt[2] + 128) / 255.0);\n\n        accum += sizeof(cmsFloat64Number)*(3 + T_EXTRA(info ->InputFormat));\n        return accum;\n    }\n}",
          "fn_code_pos": [
            [
              1469,
              0
            ],
            [
              1496,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollLabDoubleToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollLabFloatToFloat(_cmsTRANSFORM* info,\n                                      cmsFloat32Number wIn[],\n                                      cmsUInt8Number* accum,\n                                      cmsUInt32Number Stride)\n{\n    cmsFloat32Number* Pt = (cmsFloat32Number*) accum;\n\n    if (T_PLANAR(info -> InputFormat)) {\n\n        Stride /= PixelSize(info->InputFormat);\n\n        wIn[0] = (cmsFloat32Number) (Pt[0] / 100.0);                 // from 0..100 to 0..1\n        wIn[1] = (cmsFloat32Number) ((Pt[Stride] + 128) / 255.0);    // form -128..+127 to 0..1\n        wIn[2] = (cmsFloat32Number) ((Pt[Stride*2] + 128) / 255.0);\n\n        return accum + sizeof(cmsFloat32Number);\n    }\n    else {\n\n        wIn[0] = (cmsFloat32Number) (Pt[0] / 100.0);            // from 0..100 to 0..1\n        wIn[1] = (cmsFloat32Number) ((Pt[1] + 128) / 255.0);    // form -128..+127 to 0..1\n        wIn[2] = (cmsFloat32Number) ((Pt[2] + 128) / 255.0);\n\n        accum += sizeof(cmsFloat32Number)*(3 + T_EXTRA(info ->InputFormat));\n        return accum;\n    }\n}",
          "fn_code_pos": [
            [
              1499,
              0
            ],
            [
              1526,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollLabFloatToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollXYZDoubleToFloat(_cmsTRANSFORM* info,\n                                       cmsFloat32Number wIn[],\n                                       cmsUInt8Number* accum,\n                                       cmsUInt32Number Stride)\n{\n    cmsFloat64Number* Pt = (cmsFloat64Number*) accum;\n\n    if (T_PLANAR(info -> InputFormat)) {\n\n        Stride /= PixelSize(info->InputFormat);\n\n        wIn[0] = (cmsFloat32Number) (Pt[0] / MAX_ENCODEABLE_XYZ);\n        wIn[1] = (cmsFloat32Number) (Pt[Stride] / MAX_ENCODEABLE_XYZ);\n        wIn[2] = (cmsFloat32Number) (Pt[Stride*2] / MAX_ENCODEABLE_XYZ);\n\n        return accum + sizeof(cmsFloat64Number);\n    }\n    else {\n\n        wIn[0] = (cmsFloat32Number) (Pt[0] / MAX_ENCODEABLE_XYZ);\n        wIn[1] = (cmsFloat32Number) (Pt[1] / MAX_ENCODEABLE_XYZ);\n        wIn[2] = (cmsFloat32Number) (Pt[2] / MAX_ENCODEABLE_XYZ);\n\n        accum += sizeof(cmsFloat64Number)*(3 + T_EXTRA(info ->InputFormat));\n        return accum;\n    }\n}",
          "fn_code_pos": [
            [
              1529,
              0
            ],
            [
              1556,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollXYZDoubleToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollXYZFloatToFloat(_cmsTRANSFORM* info,\n                                      cmsFloat32Number wIn[],\n                                      cmsUInt8Number* accum,\n                                      cmsUInt32Number Stride)\n{\n    cmsFloat32Number* Pt = (cmsFloat32Number*) accum;\n\n    if (T_PLANAR(info -> InputFormat)) {\n\n        Stride /= PixelSize(info->InputFormat);\n\n        wIn[0] = (cmsFloat32Number) (Pt[0] / MAX_ENCODEABLE_XYZ);\n        wIn[1] = (cmsFloat32Number) (Pt[Stride] / MAX_ENCODEABLE_XYZ);\n        wIn[2] = (cmsFloat32Number) (Pt[Stride*2] / MAX_ENCODEABLE_XYZ);\n\n        return accum + sizeof(cmsFloat32Number);\n    }\n    else {\n\n        wIn[0] = (cmsFloat32Number) (Pt[0] / MAX_ENCODEABLE_XYZ);\n        wIn[1] = (cmsFloat32Number) (Pt[1] / MAX_ENCODEABLE_XYZ);\n        wIn[2] = (cmsFloat32Number) (Pt[2] / MAX_ENCODEABLE_XYZ);\n\n        accum += sizeof(cmsFloat32Number)*(3 + T_EXTRA(info ->InputFormat));\n        return accum;\n    }\n}",
          "fn_code_pos": [
            [
              1558,
              0
            ],
            [
              1585,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollXYZFloatToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "cmsINLINE void lab4toFloat(cmsFloat32Number wIn[], cmsUInt16Number lab4[3])\n{        \n    cmsFloat32Number L = (cmsFloat32Number) lab4[0] / 655.35F;\n    cmsFloat32Number a = ((cmsFloat32Number) lab4[1] / 257.0F) - 128.0F;\n    cmsFloat32Number b = ((cmsFloat32Number) lab4[2] / 257.0F) - 128.0F;\n    \n    wIn[0] = (L / 100.0F);                    // from 0..100 to 0..1\n    wIn[1] = ((a + 128.0F) / 255.0F);         // form -128..+127 to 0..1\n    wIn[2] = ((b + 128.0F) / 255.0F);\n\n}",
          "fn_code_pos": [
            [
              1588,
              0
            ],
            [
              1598,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lab4toFloat",
            "parameters": {
              "wIn": "cmsFloat32Number",
              "lab4": "cmsUInt16Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollLabV2_8ToFloat(_cmsTRANSFORM* info,\n                                      cmsFloat32Number wIn[],\n                                      cmsUInt8Number* accum,\n                                      cmsUInt32Number Stride)\n{\n    cmsUInt16Number lab4[3];\n\n    lab4[0] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     // L\n    lab4[1] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     // a\n    lab4[2] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     // b\n\n    lab4toFloat(wIn, lab4);\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              1600,
              0
            ],
            [
              1618,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollLabV2_8ToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollALabV2_8ToFloat(_cmsTRANSFORM* info,\n                                      cmsFloat32Number wIn[],\n                                      cmsUInt8Number* accum,\n                                      cmsUInt32Number Stride)\n{\n    cmsUInt16Number lab4[3];\n\n    accum++;  // A\n    lab4[0] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     // L\n    lab4[1] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     // a\n    lab4[2] = FomLabV2ToLabV4(FROM_8_TO_16(*accum)); accum++;     // b\n\n    lab4toFloat(wIn, lab4);\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              1620,
              0
            ],
            [
              1639,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollALabV2_8ToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollLabV2_16ToFloat(_cmsTRANSFORM* info,\n                                      cmsFloat32Number wIn[],\n                                      cmsUInt8Number* accum,\n                                      cmsUInt32Number Stride)\n{\n    cmsUInt16Number lab4[3];\n\n    lab4[0] = FomLabV2ToLabV4(*(cmsUInt16Number*) accum); accum += 2;     // L\n    lab4[1] = FomLabV2ToLabV4(*(cmsUInt16Number*) accum); accum += 2;     // a\n    lab4[2] = FomLabV2ToLabV4(*(cmsUInt16Number*) accum); accum += 2;     // b\n\n    lab4toFloat(wIn, lab4);\n\n    return accum;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              1641,
              0
            ],
            [
              1659,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollLabV2_16ToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackChunkyBytes(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wOut[],\n                                CMSREGISTER cmsUInt8Number* output,\n                                CMSREGISTER cmsUInt32Number Stride)\n{\n    cmsUInt32Number nChan = T_CHANNELS(info->OutputFormat);\n    cmsUInt32Number DoSwap = T_DOSWAP(info->OutputFormat);\n    cmsUInt32Number Reverse = T_FLAVOR(info->OutputFormat);\n    cmsUInt32Number Extra = T_EXTRA(info->OutputFormat);\n    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->OutputFormat);\n    cmsUInt32Number Premul = T_PREMUL(info->OutputFormat);\n    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n    cmsUInt8Number* swap1;\n    cmsUInt16Number v = 0;\n    cmsUInt32Number i;\n    cmsUInt32Number alpha_factor = 0;\n\n    swap1 = output;\n\n    if (ExtraFirst) {\n        \n        if (Premul && Extra)\n            alpha_factor = _cmsToFixedDomain(FROM_8_TO_16(output[0]));\n\n        output += Extra;\n    }\n    else\n    {\n        if (Premul && Extra)\n            alpha_factor = _cmsToFixedDomain(FROM_8_TO_16(output[nChan]));\n    }\n\n    for (i=0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n        v = wOut[index];\n\n        if (Reverse)\n            v = REVERSE_FLAVOR_16(v);\n\n        if (Premul)\n        {\n            v = (cmsUInt16Number)((cmsUInt32Number)((cmsUInt32Number)v * alpha_factor + 0x8000) >> 16);            \n        }\n\n        *output++ = FROM_16_TO_8(v);\n    }\n\n    if (!ExtraFirst) {\n        output += Extra;\n    }\n\n    if (Extra == 0 && SwapFirst) {\n\n        memmove(swap1 + 1, swap1, nChan-1);\n        *swap1 = FROM_16_TO_8(v);\n    }\n\n    return output;\n\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              1666,
              0
            ],
            [
              1729,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackChunkyBytes",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackChunkyWords(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wOut[],\n                                CMSREGISTER cmsUInt8Number* output,\n                                CMSREGISTER cmsUInt32Number Stride)\n{\n    cmsUInt32Number nChan = T_CHANNELS(info->OutputFormat);\n    cmsUInt32Number SwapEndian = T_ENDIAN16(info->OutputFormat);\n    cmsUInt32Number DoSwap = T_DOSWAP(info->OutputFormat);\n    cmsUInt32Number Reverse = T_FLAVOR(info->OutputFormat);\n    cmsUInt32Number Extra = T_EXTRA(info->OutputFormat);\n    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->OutputFormat);\n    cmsUInt32Number Premul = T_PREMUL(info->OutputFormat);\n    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n    cmsUInt16Number* swap1;\n    cmsUInt16Number v = 0;\n    cmsUInt32Number i;\n    cmsUInt32Number alpha_factor = 0;\n    \n    swap1 = (cmsUInt16Number*) output;\n\n    if (ExtraFirst) {\n\n        if (Premul && Extra)\n            alpha_factor = _cmsToFixedDomain(*(cmsUInt16Number*) output);\n\n        output += Extra * sizeof(cmsUInt16Number);\n    }\n    else\n    {\n        if (Premul && Extra)\n            alpha_factor = _cmsToFixedDomain(((cmsUInt16Number*) output)[nChan]);\n    }\n\n    for (i=0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n        v = wOut[index];\n\n        if (SwapEndian)\n            v = CHANGE_ENDIAN(v);\n\n        if (Reverse)\n            v = REVERSE_FLAVOR_16(v);\n\n        if (Premul)\n        {\n            v = (cmsUInt16Number)((cmsUInt32Number)((cmsUInt32Number)v * alpha_factor + 0x8000) >> 16);\n        }\n\n        *(cmsUInt16Number*) output = v;\n\n        output += sizeof(cmsUInt16Number);\n    }\n\n    if (!ExtraFirst) {\n        output += Extra * sizeof(cmsUInt16Number);\n    }\n\n    if (Extra == 0 && SwapFirst) {\n\n        memmove(swap1 + 1, swap1, (nChan-1)* sizeof(cmsUInt16Number));\n        *swap1 = v;\n    }\n\n    return output;\n\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              1731,
              0
            ],
            [
              1800,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackChunkyWords",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackPlanarBytes(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wOut[],\n                                CMSREGISTER cmsUInt8Number* output,\n                                CMSREGISTER cmsUInt32Number Stride)\n{\n    cmsUInt32Number nChan = T_CHANNELS(info->OutputFormat);\n    cmsUInt32Number DoSwap = T_DOSWAP(info->OutputFormat);\n    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->OutputFormat);\n    cmsUInt32Number Reverse = T_FLAVOR(info->OutputFormat);\n    cmsUInt32Number Extra = T_EXTRA(info->OutputFormat);\n    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n    cmsUInt32Number Premul = T_PREMUL(info->OutputFormat);\n    cmsUInt32Number i;\n    cmsUInt8Number* Init = output;\n    cmsUInt32Number alpha_factor = 0;\n\n\n    if (ExtraFirst) {\n\n        if (Premul && Extra)\n            alpha_factor = _cmsToFixedDomain(FROM_8_TO_16(output[0]));\n\n        output += Extra * Stride;\n    }\n    else\n    {\n        if (Premul && Extra)\n            alpha_factor = _cmsToFixedDomain(FROM_8_TO_16(output[nChan * Stride]));\n    }\n\n\n    for (i=0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n        cmsUInt16Number v = wOut[index];\n\n        if (Reverse)\n            v = REVERSE_FLAVOR_16(v);\n\n        if (Premul)\n        {\n            v = (cmsUInt16Number)((cmsUInt32Number)((cmsUInt32Number)v * alpha_factor + 0x8000) >> 16);\n        }\n\n        *(cmsUInt8Number*)output = FROM_16_TO_8(v);\n\n        output += Stride;\n    }\n\n    return (Init + 1);\n\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              1804,
              0
            ],
            [
              1857,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackPlanarBytes",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackPlanarWords(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wOut[],\n                                CMSREGISTER cmsUInt8Number* output,\n                                CMSREGISTER cmsUInt32Number Stride)\n{\n    cmsUInt32Number nChan = T_CHANNELS(info->OutputFormat);\n    cmsUInt32Number DoSwap = T_DOSWAP(info->OutputFormat);\n    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->OutputFormat);\n    cmsUInt32Number Reverse = T_FLAVOR(info->OutputFormat);\n    cmsUInt32Number Extra = T_EXTRA(info->OutputFormat);\n    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n    cmsUInt32Number Premul = T_PREMUL(info->OutputFormat);\n    cmsUInt32Number SwapEndian = T_ENDIAN16(info->OutputFormat);\n    cmsUInt32Number i;\n    cmsUInt8Number* Init = output;\n    cmsUInt16Number v;\n    cmsUInt32Number alpha_factor = 0;\n\n    if (ExtraFirst) {\n\n        if (Premul && Extra)\n            alpha_factor = _cmsToFixedDomain(((cmsUInt16Number*) output)[0]);\n\n        output += Extra * Stride;\n    }\n    else\n    {\n        if (Premul && Extra)\n            alpha_factor = _cmsToFixedDomain(((cmsUInt16Number*)output)[nChan * Stride]);\n    }\n\n    for (i=0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n        v = wOut[index];\n\n        if (SwapEndian)\n            v = CHANGE_ENDIAN(v);\n\n        if (Reverse)\n            v =  REVERSE_FLAVOR_16(v);\n\n        if (Premul)\n        {\n            v = (cmsUInt16Number)((cmsUInt32Number)((cmsUInt32Number)v * alpha_factor + 0x8000) >> 16);\n        }\n\n        *(cmsUInt16Number*) output = v;\n        output += Stride;\n    }\n\n    return (Init + sizeof(cmsUInt16Number));\n}",
          "fn_code_pos": [
            [
              1860,
              0
            ],
            [
              1914,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackPlanarWords",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack6Bytes(CMSREGISTER _cmsTRANSFORM* info,\n                           CMSREGISTER cmsUInt16Number wOut[],\n                           CMSREGISTER cmsUInt8Number* output,\n                           CMSREGISTER cmsUInt32Number Stride)\n{\n    *output++ = FROM_16_TO_8(wOut[0]);\n    *output++ = FROM_16_TO_8(wOut[1]);\n    *output++ = FROM_16_TO_8(wOut[2]);\n    *output++ = FROM_16_TO_8(wOut[3]);\n    *output++ = FROM_16_TO_8(wOut[4]);\n    *output++ = FROM_16_TO_8(wOut[5]);\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              1918,
              0
            ],
            [
              1935,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack6Bytes",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack6BytesSwap(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wOut[],\n                               CMSREGISTER cmsUInt8Number* output,\n                               CMSREGISTER cmsUInt32Number Stride)\n{\n    *output++ = FROM_16_TO_8(wOut[5]);\n    *output++ = FROM_16_TO_8(wOut[4]);\n    *output++ = FROM_16_TO_8(wOut[3]);\n    *output++ = FROM_16_TO_8(wOut[2]);\n    *output++ = FROM_16_TO_8(wOut[1]);\n    *output++ = FROM_16_TO_8(wOut[0]);\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              1939,
              0
            ],
            [
              1956,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack6BytesSwap",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack6Words(CMSREGISTER _cmsTRANSFORM* info,\n                           CMSREGISTER cmsUInt16Number wOut[],\n                           CMSREGISTER cmsUInt8Number* output,\n                           CMSREGISTER cmsUInt32Number Stride)\n{\n    *(cmsUInt16Number*) output = wOut[0];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[1];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[2];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[3];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[4];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[5];\n    output+= 2;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              1959,
              0
            ],
            [
              1982,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack6Words",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack6WordsSwap(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wOut[],\n                               CMSREGISTER cmsUInt8Number* output,\n                               CMSREGISTER cmsUInt32Number Stride)\n{\n    *(cmsUInt16Number*) output = wOut[5];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[4];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[3];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[2];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[1];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[0];\n    output+= 2;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              1985,
              0
            ],
            [
              2008,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack6WordsSwap",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack4Bytes(CMSREGISTER _cmsTRANSFORM* info,\n                           CMSREGISTER cmsUInt16Number wOut[],\n                           CMSREGISTER cmsUInt8Number* output,\n                           CMSREGISTER cmsUInt32Number Stride)\n{\n    *output++ = FROM_16_TO_8(wOut[0]);\n    *output++ = FROM_16_TO_8(wOut[1]);\n    *output++ = FROM_16_TO_8(wOut[2]);\n    *output++ = FROM_16_TO_8(wOut[3]);\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2011,
              0
            ],
            [
              2026,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack4Bytes",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack4BytesReverse(CMSREGISTER _cmsTRANSFORM* info,\n                                  CMSREGISTER cmsUInt16Number wOut[],\n                                  CMSREGISTER cmsUInt8Number* output,\n                                  CMSREGISTER cmsUInt32Number Stride)\n{\n    *output++ = REVERSE_FLAVOR_8(FROM_16_TO_8(wOut[0]));\n    *output++ = REVERSE_FLAVOR_8(FROM_16_TO_8(wOut[1]));\n    *output++ = REVERSE_FLAVOR_8(FROM_16_TO_8(wOut[2]));\n    *output++ = REVERSE_FLAVOR_8(FROM_16_TO_8(wOut[3]));\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2028,
              0
            ],
            [
              2043,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack4BytesReverse",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack4BytesSwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wOut[],\n                                    CMSREGISTER cmsUInt8Number* output,\n                                    CMSREGISTER cmsUInt32Number Stride)\n{\n    *output++ = FROM_16_TO_8(wOut[3]);\n    *output++ = FROM_16_TO_8(wOut[0]);\n    *output++ = FROM_16_TO_8(wOut[1]);\n    *output++ = FROM_16_TO_8(wOut[2]);\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2046,
              0
            ],
            [
              2061,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack4BytesSwapFirst",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack4BytesSwap(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wOut[],\n                               CMSREGISTER cmsUInt8Number* output,\n                               CMSREGISTER cmsUInt32Number Stride)\n{\n    *output++ = FROM_16_TO_8(wOut[3]);\n    *output++ = FROM_16_TO_8(wOut[2]);\n    *output++ = FROM_16_TO_8(wOut[1]);\n    *output++ = FROM_16_TO_8(wOut[0]);\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2064,
              0
            ],
            [
              2079,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack4BytesSwap",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack4BytesSwapSwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                        CMSREGISTER cmsUInt16Number wOut[],\n                                        CMSREGISTER cmsUInt8Number* output,\n                                        CMSREGISTER cmsUInt32Number Stride)\n{\n    *output++ = FROM_16_TO_8(wOut[2]);\n    *output++ = FROM_16_TO_8(wOut[1]);\n    *output++ = FROM_16_TO_8(wOut[0]);\n    *output++ = FROM_16_TO_8(wOut[3]);\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2081,
              0
            ],
            [
              2096,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack4BytesSwapSwapFirst",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack4Words(CMSREGISTER _cmsTRANSFORM* info,\n                           CMSREGISTER cmsUInt16Number wOut[],\n                           CMSREGISTER cmsUInt8Number* output,\n                           CMSREGISTER cmsUInt32Number Stride)\n{\n    *(cmsUInt16Number*) output = wOut[0];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[1];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[2];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[3];\n    output+= 2;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2098,
              0
            ],
            [
              2117,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack4Words",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack4WordsReverse(CMSREGISTER _cmsTRANSFORM* info,\n                                  CMSREGISTER cmsUInt16Number wOut[],\n                                  CMSREGISTER cmsUInt8Number* output,\n                                  CMSREGISTER cmsUInt32Number Stride)\n{\n    *(cmsUInt16Number*) output = REVERSE_FLAVOR_16(wOut[0]);\n    output+= 2;\n    *(cmsUInt16Number*) output = REVERSE_FLAVOR_16(wOut[1]);\n    output+= 2;\n    *(cmsUInt16Number*) output = REVERSE_FLAVOR_16(wOut[2]);\n    output+= 2;\n    *(cmsUInt16Number*) output = REVERSE_FLAVOR_16(wOut[3]);\n    output+= 2;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2119,
              0
            ],
            [
              2138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack4WordsReverse",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack4WordsSwap(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wOut[],\n                               CMSREGISTER cmsUInt8Number* output,\n                               CMSREGISTER cmsUInt32Number Stride)\n{\n    *(cmsUInt16Number*) output = wOut[3];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[2];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[1];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[0];\n    output+= 2;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2141,
              0
            ],
            [
              2160,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack4WordsSwap",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack4WordsBigEndian(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wOut[],\n                                    CMSREGISTER cmsUInt8Number* output,\n                                    CMSREGISTER cmsUInt32Number Stride)\n{\n    *(cmsUInt16Number*) output = CHANGE_ENDIAN(wOut[0]);\n    output+= 2;\n    *(cmsUInt16Number*) output = CHANGE_ENDIAN(wOut[1]);\n    output+= 2;\n    *(cmsUInt16Number*) output = CHANGE_ENDIAN(wOut[2]);\n    output+= 2;\n    *(cmsUInt16Number*) output = CHANGE_ENDIAN(wOut[3]);\n    output+= 2;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2163,
              0
            ],
            [
              2182,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack4WordsBigEndian",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackLabV2_8(CMSREGISTER _cmsTRANSFORM* info,\n                            CMSREGISTER cmsUInt16Number wOut[],\n                            CMSREGISTER cmsUInt8Number* output,\n                            CMSREGISTER cmsUInt32Number Stride)\n{\n    *output++ = FROM_16_TO_8(FomLabV4ToLabV2(wOut[0]));\n    *output++ = FROM_16_TO_8(FomLabV4ToLabV2(wOut[1]));\n    *output++ = FROM_16_TO_8(FomLabV4ToLabV2(wOut[2]));\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2185,
              0
            ],
            [
              2199,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackLabV2_8",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackALabV2_8(CMSREGISTER _cmsTRANSFORM* info,\n                             CMSREGISTER cmsUInt16Number wOut[],\n                             CMSREGISTER cmsUInt8Number* output,\n                             CMSREGISTER cmsUInt32Number Stride)\n{\n    output++;\n    *output++ = FROM_16_TO_8(FomLabV4ToLabV2(wOut[0]));\n    *output++ = FROM_16_TO_8(FomLabV4ToLabV2(wOut[1]));\n    *output++ = FROM_16_TO_8(FomLabV4ToLabV2(wOut[2]));\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2201,
              0
            ],
            [
              2216,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackALabV2_8",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackLabV2_16(CMSREGISTER _cmsTRANSFORM* info,\n                             CMSREGISTER cmsUInt16Number wOut[],\n                             CMSREGISTER cmsUInt8Number* output,\n                             CMSREGISTER cmsUInt32Number Stride)\n{\n    *(cmsUInt16Number*) output = FomLabV4ToLabV2(wOut[0]);\n    output += 2;\n    *(cmsUInt16Number*) output = FomLabV4ToLabV2(wOut[1]);\n    output += 2;\n    *(cmsUInt16Number*) output = FomLabV4ToLabV2(wOut[2]);\n    output += 2;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2218,
              0
            ],
            [
              2235,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackLabV2_16",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack3Bytes(CMSREGISTER _cmsTRANSFORM* info,\n                           CMSREGISTER cmsUInt16Number wOut[],\n                           CMSREGISTER cmsUInt8Number* output,\n                           CMSREGISTER cmsUInt32Number Stride)\n{\n    *output++ = FROM_16_TO_8(wOut[0]);\n    *output++ = FROM_16_TO_8(wOut[1]);\n    *output++ = FROM_16_TO_8(wOut[2]);\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2237,
              0
            ],
            [
              2251,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3Bytes",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack3BytesOptimized(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wOut[],\n                                    CMSREGISTER cmsUInt8Number* output,\n                                    CMSREGISTER cmsUInt32Number Stride)\n{\n    *output++ = (wOut[0] & 0xFFU);\n    *output++ = (wOut[1] & 0xFFU);\n    *output++ = (wOut[2] & 0xFFU);\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2253,
              0
            ],
            [
              2267,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesOptimized",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack3BytesSwap(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wOut[],\n                               CMSREGISTER cmsUInt8Number* output,\n                               CMSREGISTER cmsUInt32Number Stride)\n{\n    *output++ = FROM_16_TO_8(wOut[2]);\n    *output++ = FROM_16_TO_8(wOut[1]);\n    *output++ = FROM_16_TO_8(wOut[0]);\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2269,
              0
            ],
            [
              2283,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesSwap",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack3BytesSwapOptimized(CMSREGISTER _cmsTRANSFORM* info,\n                                        CMSREGISTER cmsUInt16Number wOut[],\n                                        CMSREGISTER cmsUInt8Number* output,\n                                        CMSREGISTER cmsUInt32Number Stride)\n{\n    *output++ = (wOut[2] & 0xFFU);\n    *output++ = (wOut[1] & 0xFFU);\n    *output++ = (wOut[0] & 0xFFU);\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2285,
              0
            ],
            [
              2299,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesSwapOptimized",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack3Words(CMSREGISTER _cmsTRANSFORM* info,\n                           CMSREGISTER cmsUInt16Number wOut[],\n                           CMSREGISTER cmsUInt8Number* output,\n                           CMSREGISTER cmsUInt32Number Stride)\n{\n    *(cmsUInt16Number*) output = wOut[0];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[1];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[2];\n    output+= 2;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2302,
              0
            ],
            [
              2319,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3Words",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack3WordsSwap(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wOut[],\n                               CMSREGISTER cmsUInt8Number* output,\n                               CMSREGISTER cmsUInt32Number Stride)\n{\n    *(cmsUInt16Number*) output = wOut[2];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[1];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[0];\n    output+= 2;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2321,
              0
            ],
            [
              2338,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3WordsSwap",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack3WordsBigEndian(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wOut[],\n                                    CMSREGISTER cmsUInt8Number* output,\n                                    CMSREGISTER cmsUInt32Number Stride)\n{\n    *(cmsUInt16Number*) output = CHANGE_ENDIAN(wOut[0]);\n    output+= 2;\n    *(cmsUInt16Number*) output = CHANGE_ENDIAN(wOut[1]);\n    output+= 2;\n    *(cmsUInt16Number*) output = CHANGE_ENDIAN(wOut[2]);\n    output+= 2;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2340,
              0
            ],
            [
              2357,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3WordsBigEndian",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack3BytesAndSkip1(CMSREGISTER _cmsTRANSFORM* info,\n                                   CMSREGISTER cmsUInt16Number wOut[],\n                                   CMSREGISTER cmsUInt8Number* output,\n                                   CMSREGISTER cmsUInt32Number Stride)\n{\n    *output++ = FROM_16_TO_8(wOut[0]);\n    *output++ = FROM_16_TO_8(wOut[1]);\n    *output++ = FROM_16_TO_8(wOut[2]);\n    output++;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2359,
              0
            ],
            [
              2374,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesAndSkip1",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack3BytesAndSkip1Optimized(CMSREGISTER _cmsTRANSFORM* info,\n                                            CMSREGISTER cmsUInt16Number wOut[],\n                                            CMSREGISTER cmsUInt8Number* output,\n                                            CMSREGISTER cmsUInt32Number Stride)\n{\n    *output++ = (wOut[0] & 0xFFU);\n    *output++ = (wOut[1] & 0xFFU);\n    *output++ = (wOut[2] & 0xFFU);\n    output++;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2376,
              0
            ],
            [
              2391,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesAndSkip1Optimized",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack3BytesAndSkip1SwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                            CMSREGISTER cmsUInt16Number wOut[],\n                                            CMSREGISTER cmsUInt8Number* output,\n                                            CMSREGISTER cmsUInt32Number Stride)\n{\n    output++;\n    *output++ = FROM_16_TO_8(wOut[0]);\n    *output++ = FROM_16_TO_8(wOut[1]);\n    *output++ = FROM_16_TO_8(wOut[2]);\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2394,
              0
            ],
            [
              2409,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesAndSkip1SwapFirst",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack3BytesAndSkip1SwapFirstOptimized(CMSREGISTER _cmsTRANSFORM* info,\n                                                     CMSREGISTER cmsUInt16Number wOut[],\n                                                     CMSREGISTER cmsUInt8Number* output,\n                                                     CMSREGISTER cmsUInt32Number Stride)\n{\n    output++;\n    *output++ = (wOut[0] & 0xFFU);\n    *output++ = (wOut[1] & 0xFFU);\n    *output++ = (wOut[2] & 0xFFU);\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2411,
              0
            ],
            [
              2426,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesAndSkip1SwapFirstOptimized",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack3BytesAndSkip1Swap(CMSREGISTER _cmsTRANSFORM* info,\n                                       CMSREGISTER cmsUInt16Number wOut[],\n                                       CMSREGISTER cmsUInt8Number* output,\n                                       CMSREGISTER cmsUInt32Number Stride)\n{\n    output++;\n    *output++ = FROM_16_TO_8(wOut[2]);\n    *output++ = FROM_16_TO_8(wOut[1]);\n    *output++ = FROM_16_TO_8(wOut[0]);\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2428,
              0
            ],
            [
              2443,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesAndSkip1Swap",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack3BytesAndSkip1SwapOptimized(CMSREGISTER _cmsTRANSFORM* info,\n                                                CMSREGISTER cmsUInt16Number wOut[],\n                                                CMSREGISTER cmsUInt8Number* output,\n                                                CMSREGISTER cmsUInt32Number Stride)\n{\n    output++;\n    *output++ = (wOut[2] & 0xFFU);\n    *output++ = (wOut[1] & 0xFFU);\n    *output++ = (wOut[0] & 0xFFU);\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2445,
              0
            ],
            [
              2460,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesAndSkip1SwapOptimized",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack3BytesAndSkip1SwapSwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                                CMSREGISTER cmsUInt16Number wOut[],\n                                                CMSREGISTER cmsUInt8Number* output,\n                                                CMSREGISTER cmsUInt32Number Stride)\n{\n    *output++ = FROM_16_TO_8(wOut[2]);\n    *output++ = FROM_16_TO_8(wOut[1]);\n    *output++ = FROM_16_TO_8(wOut[0]);\n    output++;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2463,
              0
            ],
            [
              2478,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesAndSkip1SwapSwapFirst",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack3BytesAndSkip1SwapSwapFirstOptimized(CMSREGISTER _cmsTRANSFORM* info,\n                                                         CMSREGISTER cmsUInt16Number wOut[],\n                                                         CMSREGISTER cmsUInt8Number* output,\n                                                         CMSREGISTER cmsUInt32Number Stride)\n{\n    *output++ = (wOut[2] & 0xFFU);\n    *output++ = (wOut[1] & 0xFFU);\n    *output++ = (wOut[0] & 0xFFU);\n    output++;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2480,
              0
            ],
            [
              2495,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesAndSkip1SwapSwapFirstOptimized",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack3WordsAndSkip1(CMSREGISTER _cmsTRANSFORM* info,\n                                   CMSREGISTER cmsUInt16Number wOut[],\n                                   CMSREGISTER cmsUInt8Number* output,\n                                   CMSREGISTER cmsUInt32Number Stride)\n{\n    *(cmsUInt16Number*) output = wOut[0];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[1];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[2];\n    output+= 2;\n    output+= 2;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2497,
              0
            ],
            [
              2515,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3WordsAndSkip1",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack3WordsAndSkip1Swap(CMSREGISTER _cmsTRANSFORM* info,\n                                       CMSREGISTER cmsUInt16Number wOut[],\n                                       CMSREGISTER cmsUInt8Number* output,\n                                       CMSREGISTER cmsUInt32Number Stride)\n{\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[2];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[1];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[0];\n    output+= 2;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2517,
              0
            ],
            [
              2535,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3WordsAndSkip1Swap",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack3WordsAndSkip1SwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                            CMSREGISTER cmsUInt16Number wOut[],\n                                            CMSREGISTER cmsUInt8Number* output,\n                                            CMSREGISTER cmsUInt32Number Stride)\n{\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[0];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[1];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[2];\n    output+= 2;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2538,
              0
            ],
            [
              2556,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3WordsAndSkip1SwapFirst",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack3WordsAndSkip1SwapSwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                                CMSREGISTER cmsUInt16Number wOut[],\n                                                CMSREGISTER cmsUInt8Number* output,\n                                                CMSREGISTER cmsUInt32Number Stride)\n{\n    *(cmsUInt16Number*) output = wOut[2];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[1];\n    output+= 2;\n    *(cmsUInt16Number*) output = wOut[0];\n    output+= 2;\n    output+= 2;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2559,
              0
            ],
            [
              2577,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3WordsAndSkip1SwapSwapFirst",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack1Byte(CMSREGISTER _cmsTRANSFORM* info,\n                          CMSREGISTER cmsUInt16Number wOut[],\n                          CMSREGISTER cmsUInt8Number* output,\n                          CMSREGISTER cmsUInt32Number Stride)\n{\n    *output++ = FROM_16_TO_8(wOut[0]);\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2581,
              0
            ],
            [
              2593,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack1Byte",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack1ByteReversed(CMSREGISTER _cmsTRANSFORM* info,\n                                  CMSREGISTER cmsUInt16Number wOut[],\n                                  CMSREGISTER cmsUInt8Number* output,\n                                  CMSREGISTER cmsUInt32Number Stride)\n{\n    *output++ = FROM_16_TO_8(REVERSE_FLAVOR_16(wOut[0]));\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2596,
              0
            ],
            [
              2608,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack1ByteReversed",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack1ByteSkip1(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wOut[],\n                               CMSREGISTER cmsUInt8Number* output,\n                               CMSREGISTER cmsUInt32Number Stride)\n{\n    *output++ = FROM_16_TO_8(wOut[0]);\n    output++;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2611,
              0
            ],
            [
              2624,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack1ByteSkip1",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack1ByteSkip1SwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                        CMSREGISTER cmsUInt16Number wOut[],\n                                        CMSREGISTER cmsUInt8Number* output,\n                                        CMSREGISTER cmsUInt32Number Stride)\n{\n    output++;\n    *output++ = FROM_16_TO_8(wOut[0]);\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2627,
              0
            ],
            [
              2640,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack1ByteSkip1SwapFirst",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack1Word(CMSREGISTER _cmsTRANSFORM* info,\n                          CMSREGISTER cmsUInt16Number wOut[],\n                          CMSREGISTER cmsUInt8Number* output,\n                          CMSREGISTER cmsUInt32Number Stride)\n{\n    *(cmsUInt16Number*) output = wOut[0];\n    output+= 2;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2642,
              0
            ],
            [
              2655,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack1Word",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack1WordReversed(CMSREGISTER _cmsTRANSFORM* info,\n                                  CMSREGISTER cmsUInt16Number wOut[],\n                                  CMSREGISTER cmsUInt8Number* output,\n                                  CMSREGISTER cmsUInt32Number Stride)\n{\n    *(cmsUInt16Number*) output = REVERSE_FLAVOR_16(wOut[0]);\n    output+= 2;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2658,
              0
            ],
            [
              2671,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack1WordReversed",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack1WordBigEndian(CMSREGISTER _cmsTRANSFORM* info,\n                                   CMSREGISTER cmsUInt16Number wOut[],\n                                   CMSREGISTER cmsUInt8Number* output,\n                                   CMSREGISTER cmsUInt32Number Stride)\n{\n    *(cmsUInt16Number*) output = CHANGE_ENDIAN(wOut[0]);\n    output+= 2;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2673,
              0
            ],
            [
              2686,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack1WordBigEndian",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack1WordSkip1(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wOut[],\n                               CMSREGISTER cmsUInt8Number* output,\n                               CMSREGISTER cmsUInt32Number Stride)\n{\n    *(cmsUInt16Number*) output = wOut[0];\n    output+= 4;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2689,
              0
            ],
            [
              2702,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack1WordSkip1",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* Pack1WordSkip1SwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                        CMSREGISTER cmsUInt16Number wOut[],\n                                        CMSREGISTER cmsUInt8Number* output,\n                                        CMSREGISTER cmsUInt32Number Stride)\n{\n    output += 2;\n    *(cmsUInt16Number*) output = wOut[0];\n    output+= 2;\n\n    return output;\n\n    cmsUNUSED_PARAMETER(info);\n    cmsUNUSED_PARAMETER(Stride);\n}",
          "fn_code_pos": [
            [
              2704,
              0
            ],
            [
              2718,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack1WordSkip1SwapFirst",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackLabDoubleFrom16(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wOut[],\n                                    CMSREGISTER cmsUInt8Number* output,\n                                    CMSREGISTER cmsUInt32Number Stride)\n{\n\n    if (T_PLANAR(info -> OutputFormat)) {\n\n        cmsCIELab  Lab;\n        cmsFloat64Number* Out = (cmsFloat64Number*) output;\n        cmsLabEncoded2Float(&Lab, wOut);\n\n        Out[0]        = Lab.L;\n        Out[Stride]   = Lab.a;\n        Out[Stride*2] = Lab.b;\n\n        return output + sizeof(cmsFloat64Number);\n    }\n    else {\n\n        cmsLabEncoded2Float((cmsCIELab*) output, wOut);\n        return output + (sizeof(cmsCIELab) + T_EXTRA(info ->OutputFormat) * sizeof(cmsFloat64Number));\n    }\n}",
          "fn_code_pos": [
            [
              2722,
              0
            ],
            [
              2746,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackLabDoubleFrom16",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackLabFloatFrom16(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wOut[],\n                                    CMSREGISTER cmsUInt8Number* output,\n                                    CMSREGISTER cmsUInt32Number Stride)\n{\n    cmsCIELab  Lab;\n    cmsLabEncoded2Float(&Lab, wOut);\n\n    if (T_PLANAR(info -> OutputFormat)) {\n       \n        cmsFloat32Number* Out = (cmsFloat32Number*) output;\n    \n        Stride /= PixelSize(info->OutputFormat);\n\n        Out[0]        = (cmsFloat32Number)Lab.L;\n        Out[Stride]   = (cmsFloat32Number)Lab.a;\n        Out[Stride*2] = (cmsFloat32Number)Lab.b;\n\n        return output + sizeof(cmsFloat32Number);\n    }\n    else {\n\n       ((cmsFloat32Number*) output)[0] = (cmsFloat32Number) Lab.L;\n       ((cmsFloat32Number*) output)[1] = (cmsFloat32Number) Lab.a;\n       ((cmsFloat32Number*) output)[2] = (cmsFloat32Number) Lab.b;\n\n        return output + (3 + T_EXTRA(info ->OutputFormat)) * sizeof(cmsFloat32Number);\n    }\n}",
          "fn_code_pos": [
            [
              2749,
              0
            ],
            [
              2778,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackLabFloatFrom16",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackXYZDoubleFrom16(CMSREGISTER _cmsTRANSFORM* Info,\n                                    CMSREGISTER cmsUInt16Number wOut[],\n                                    CMSREGISTER cmsUInt8Number* output,\n                                    CMSREGISTER cmsUInt32Number Stride)\n{\n    if (T_PLANAR(Info -> OutputFormat)) {\n\n        cmsCIEXYZ XYZ;\n        cmsFloat64Number* Out = (cmsFloat64Number*) output;\n        cmsXYZEncoded2Float(&XYZ, wOut);\n\n        Stride /= PixelSize(Info->OutputFormat);\n\n        Out[0]        = XYZ.X;\n        Out[Stride]   = XYZ.Y;\n        Out[Stride*2] = XYZ.Z;\n\n        return output + sizeof(cmsFloat64Number);\n\n    }\n    else {\n\n        cmsXYZEncoded2Float((cmsCIEXYZ*) output, wOut);\n\n        return output + (sizeof(cmsCIEXYZ) + T_EXTRA(Info ->OutputFormat) * sizeof(cmsFloat64Number));\n    }\n}",
          "fn_code_pos": [
            [
              2780,
              0
            ],
            [
              2807,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackXYZDoubleFrom16",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackXYZFloatFrom16(CMSREGISTER _cmsTRANSFORM* Info,\n                                   CMSREGISTER cmsUInt16Number wOut[],\n                                   CMSREGISTER cmsUInt8Number* output,\n                                   CMSREGISTER cmsUInt32Number Stride)\n{\n    if (T_PLANAR(Info -> OutputFormat)) {\n\n        cmsCIEXYZ XYZ;\n        cmsFloat32Number* Out = (cmsFloat32Number*) output;\n        cmsXYZEncoded2Float(&XYZ, wOut);\n\n        Stride /= PixelSize(Info->OutputFormat);\n\n        Out[0]        = (cmsFloat32Number) XYZ.X;\n        Out[Stride]   = (cmsFloat32Number) XYZ.Y;\n        Out[Stride*2] = (cmsFloat32Number) XYZ.Z;\n\n        return output + sizeof(cmsFloat32Number);\n\n    }\n    else {\n\n        cmsCIEXYZ XYZ;\n        cmsFloat32Number* Out = (cmsFloat32Number*) output;\n        cmsXYZEncoded2Float(&XYZ, wOut);\n\n        Out[0] = (cmsFloat32Number) XYZ.X;\n        Out[1] = (cmsFloat32Number) XYZ.Y;\n        Out[2] = (cmsFloat32Number) XYZ.Z;\n\n        return output + (3 * sizeof(cmsFloat32Number) + T_EXTRA(Info ->OutputFormat) * sizeof(cmsFloat32Number));\n    }\n}",
          "fn_code_pos": [
            [
              2809,
              0
            ],
            [
              2842,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackXYZFloatFrom16",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackDoubleFrom16(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wOut[],\n                                CMSREGISTER cmsUInt8Number* output,\n                                CMSREGISTER cmsUInt32Number Stride)\n{\n    cmsUInt32Number nChan      = T_CHANNELS(info -> OutputFormat);\n    cmsUInt32Number DoSwap     = T_DOSWAP(info ->OutputFormat);\n    cmsUInt32Number Reverse    = T_FLAVOR(info ->OutputFormat);\n    cmsUInt32Number Extra      = T_EXTRA(info -> OutputFormat);\n    cmsUInt32Number SwapFirst  = T_SWAPFIRST(info -> OutputFormat);\n    cmsUInt32Number Planar     = T_PLANAR(info -> OutputFormat);\n    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n    cmsFloat64Number maximum = IsInkSpace(info ->OutputFormat) ? 655.35 : 65535.0;\n    cmsFloat64Number v = 0;\n    cmsFloat64Number* swap1 = (cmsFloat64Number*) output;\n    cmsUInt32Number i, start = 0;\n\n    Stride /= PixelSize(info->OutputFormat);\n\n    if (ExtraFirst)\n        start = Extra;\n\n    for (i=0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n        v = (cmsFloat64Number) wOut[index] / maximum;\n\n        if (Reverse)\n            v = maximum - v;\n\n        if (Planar)\n            ((cmsFloat64Number*) output)[(i + start)  * Stride]= v;\n        else\n            ((cmsFloat64Number*) output)[i + start] = v;\n    }\n\n\n    if (Extra == 0 && SwapFirst) {\n\n         memmove(swap1 + 1, swap1, (nChan-1)* sizeof(cmsFloat64Number));\n        *swap1 = v;\n    }\n\n    if (T_PLANAR(info -> OutputFormat))\n        return output + sizeof(cmsFloat64Number);\n    else\n        return output + (nChan + Extra) * sizeof(cmsFloat64Number);\n\n}",
          "fn_code_pos": [
            [
              2844,
              0
            ],
            [
              2894,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackDoubleFrom16",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackFloatFrom16(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wOut[],\n                                CMSREGISTER cmsUInt8Number* output,\n                                CMSREGISTER cmsUInt32Number Stride)\n{\n       cmsUInt32Number nChan      = T_CHANNELS(info->OutputFormat);\n       cmsUInt32Number DoSwap     = T_DOSWAP(info->OutputFormat);\n       cmsUInt32Number Reverse    = T_FLAVOR(info->OutputFormat);\n       cmsUInt32Number Extra      = T_EXTRA(info->OutputFormat);\n       cmsUInt32Number SwapFirst  = T_SWAPFIRST(info->OutputFormat);\n       cmsUInt32Number Planar     = T_PLANAR(info->OutputFormat);\n       cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n       cmsFloat64Number maximum = IsInkSpace(info->OutputFormat) ? 655.35 : 65535.0;\n       cmsFloat64Number v = 0;\n       cmsFloat32Number* swap1 = (cmsFloat32Number*)output;\n       cmsUInt32Number i, start = 0;\n\n       Stride /= PixelSize(info->OutputFormat);\n\n       if (ExtraFirst)\n              start = Extra;\n\n       for (i = 0; i < nChan; i++) {\n\n              cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n              v = (cmsFloat64Number)wOut[index] / maximum;\n\n              if (Reverse)\n                     v = maximum - v;\n\n              if (Planar)\n                     ((cmsFloat32Number*)output)[(i + start) * Stride] = (cmsFloat32Number)v;\n              else\n                     ((cmsFloat32Number*)output)[i + start] = (cmsFloat32Number)v;\n       }\n\n       \n       if (Extra == 0 && SwapFirst) {\n\n              memmove(swap1 + 1, swap1, (nChan - 1)* sizeof(cmsFloat32Number));\n              *swap1 = (cmsFloat32Number)v;\n       }\n\n       if (T_PLANAR(info->OutputFormat))\n              return output + sizeof(cmsFloat32Number);\n       else\n              return output + (nChan + Extra) * sizeof(cmsFloat32Number);\n}",
          "fn_code_pos": [
            [
              2897,
              0
            ],
            [
              2946,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackFloatFrom16",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackBytesFromFloat(_cmsTRANSFORM* info,\n                                    cmsFloat32Number wOut[],\n                                    cmsUInt8Number* output,\n                                    cmsUInt32Number Stride)\n{\n    cmsUInt32Number nChan = T_CHANNELS(info->OutputFormat);\n    cmsUInt32Number DoSwap = T_DOSWAP(info->OutputFormat);\n    cmsUInt32Number Reverse = T_FLAVOR(info->OutputFormat);\n    cmsUInt32Number Extra = T_EXTRA(info->OutputFormat);\n    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->OutputFormat);\n    cmsUInt32Number Planar = T_PLANAR(info->OutputFormat);\n    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;    \n    cmsUInt8Number* swap1 = (cmsUInt8Number*)output;\n    cmsFloat64Number v = 0;\n    cmsUInt8Number vv = 0;\n    cmsUInt32Number i, start = 0;\n    \n    if (ExtraFirst)\n        start = Extra;\n\n    for (i = 0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n        v = wOut[index] * 65535.0;\n\n        if (Reverse)\n            v = 65535.0 - v;\n        \n        vv =  FROM_16_TO_8(_cmsQuickSaturateWord(v));\n\n        if (Planar)\n            ((cmsUInt8Number*)output)[(i + start) * Stride] = vv;\n        else\n            ((cmsUInt8Number*)output)[i + start] = vv;\n    }\n\n\n    if (Extra == 0 && SwapFirst) {\n\n        memmove(swap1 + 1, swap1, (nChan - 1) * sizeof(cmsUInt8Number));\n        *swap1 = vv;\n    }\n\n    if (T_PLANAR(info->OutputFormat))\n        return output + sizeof(cmsUInt8Number);\n    else\n        return output + (nChan + Extra) * sizeof(cmsUInt8Number);\n}",
          "fn_code_pos": [
            [
              2952,
              0
            ],
            [
              3001,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackBytesFromFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackWordsFromFloat(_cmsTRANSFORM* info,\n                                    cmsFloat32Number wOut[],\n                                    cmsUInt8Number* output,\n                                    cmsUInt32Number Stride)\n{\n    cmsUInt32Number nChan = T_CHANNELS(info->OutputFormat);\n    cmsUInt32Number DoSwap = T_DOSWAP(info->OutputFormat);\n    cmsUInt32Number Reverse = T_FLAVOR(info->OutputFormat);\n    cmsUInt32Number Extra = T_EXTRA(info->OutputFormat);\n    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->OutputFormat);\n    cmsUInt32Number Planar = T_PLANAR(info->OutputFormat);\n    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;    \n    cmsUInt16Number* swap1 = (cmsUInt16Number*)output;\n    cmsFloat64Number v = 0;\n    cmsUInt16Number vv = 0;\n    cmsUInt32Number i, start = 0;\n    \n    if (ExtraFirst)\n        start = Extra;\n\n    Stride /= 2;\n    for (i = 0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n        v = wOut[index] * 65535.0;\n\n        if (Reverse)\n            v = 65535.0 - v;\n\n        vv = _cmsQuickSaturateWord(v);\n\n        if (Planar)\n            ((cmsUInt16Number*)output)[(i + start) * Stride] = vv;\n        else\n            ((cmsUInt16Number*)output)[i + start] = vv;\n    }\n\n    if (Extra == 0 && SwapFirst) {\n\n        memmove(swap1 + 1, swap1, (nChan - 1) * sizeof(cmsUInt16Number));\n        *swap1 = vv;\n    }\n\n    if (T_PLANAR(info->OutputFormat))\n        return output + sizeof(cmsUInt16Number);\n    else\n        return output + (nChan + Extra) * sizeof(cmsUInt16Number);\n}",
          "fn_code_pos": [
            [
              3003,
              0
            ],
            [
              3052,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackWordsFromFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackFloatsFromFloat(_cmsTRANSFORM* info,\n                                    cmsFloat32Number wOut[],\n                                    cmsUInt8Number* output,\n                                    cmsUInt32Number Stride)\n{\n       cmsUInt32Number nChan = T_CHANNELS(info->OutputFormat);\n       cmsUInt32Number DoSwap = T_DOSWAP(info->OutputFormat);\n       cmsUInt32Number Reverse = T_FLAVOR(info->OutputFormat);\n       cmsUInt32Number Extra = T_EXTRA(info->OutputFormat);\n       cmsUInt32Number SwapFirst = T_SWAPFIRST(info->OutputFormat);\n       cmsUInt32Number Planar = T_PLANAR(info->OutputFormat);\n       cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n       cmsFloat64Number maximum = IsInkSpace(info->OutputFormat) ? 100.0 : 1.0;\n       cmsFloat32Number* swap1 = (cmsFloat32Number*)output;\n       cmsFloat64Number v = 0;\n       cmsUInt32Number i, start = 0;\n\n       Stride /= PixelSize(info->OutputFormat);\n\n       if (ExtraFirst)\n              start = Extra;\n\n       for (i = 0; i < nChan; i++) {\n\n              cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n              v = wOut[index] * maximum;\n\n              if (Reverse)\n                     v = maximum - v;\n\n              if (Planar)\n                     ((cmsFloat32Number*)output)[(i + start) * Stride] = (cmsFloat32Number)v;\n              else\n                     ((cmsFloat32Number*)output)[i + start] = (cmsFloat32Number)v;\n       }\n\n\n       if (Extra == 0 && SwapFirst) {\n\n              memmove(swap1 + 1, swap1, (nChan - 1)* sizeof(cmsFloat32Number));\n              *swap1 = (cmsFloat32Number)v;\n       }\n\n       if (T_PLANAR(info->OutputFormat))\n              return output + sizeof(cmsFloat32Number);\n       else\n              return output + (nChan + Extra) * sizeof(cmsFloat32Number);\n}",
          "fn_code_pos": [
            [
              3055,
              0
            ],
            [
              3104,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackFloatsFromFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackDoublesFromFloat(_cmsTRANSFORM* info,\n                                    cmsFloat32Number wOut[],\n                                    cmsUInt8Number* output,\n                                    cmsUInt32Number Stride)\n{\n       cmsUInt32Number nChan      = T_CHANNELS(info->OutputFormat);\n       cmsUInt32Number DoSwap     = T_DOSWAP(info->OutputFormat);\n       cmsUInt32Number Reverse    = T_FLAVOR(info->OutputFormat);\n       cmsUInt32Number Extra      = T_EXTRA(info->OutputFormat);\n       cmsUInt32Number SwapFirst  = T_SWAPFIRST(info->OutputFormat);\n       cmsUInt32Number Planar     = T_PLANAR(info->OutputFormat);\n       cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n       cmsFloat64Number maximum = IsInkSpace(info->OutputFormat) ? 100.0 : 1.0;\n       cmsFloat64Number v = 0;\n       cmsFloat64Number* swap1 = (cmsFloat64Number*)output;\n       cmsUInt32Number i, start = 0;\n\n       Stride /= PixelSize(info->OutputFormat);\n\n       if (ExtraFirst)\n              start = Extra;\n\n       for (i = 0; i < nChan; i++) {\n\n              cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n              v = wOut[index] * maximum;\n\n              if (Reverse)\n                     v = maximum - v;\n\n              if (Planar)\n                     ((cmsFloat64Number*)output)[(i + start) * Stride] = v;\n              else\n                     ((cmsFloat64Number*)output)[i + start] = v;\n       }\n\n       if (Extra == 0 && SwapFirst) {\n\n              memmove(swap1 + 1, swap1, (nChan - 1)* sizeof(cmsFloat64Number));\n              *swap1 = v;\n       }\n\n\n       if (T_PLANAR(info->OutputFormat))\n              return output + sizeof(cmsFloat64Number);\n       else\n              return output + (nChan + Extra) * sizeof(cmsFloat64Number);\n\n}",
          "fn_code_pos": [
            [
              3106,
              0
            ],
            [
              3156,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackDoublesFromFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackLabFloatFromFloat(_cmsTRANSFORM* Info,\n                                      cmsFloat32Number wOut[],\n                                      cmsUInt8Number* output,\n                                      cmsUInt32Number Stride)\n{\n    cmsFloat32Number* Out = (cmsFloat32Number*) output;\n\n    if (T_PLANAR(Info -> OutputFormat)) {\n\n        Stride /= PixelSize(Info->OutputFormat);\n\n        Out[0]        = (cmsFloat32Number) (wOut[0] * 100.0);\n        Out[Stride]   = (cmsFloat32Number) (wOut[1] * 255.0 - 128.0);\n        Out[Stride*2] = (cmsFloat32Number) (wOut[2] * 255.0 - 128.0);\n\n        return output + sizeof(cmsFloat32Number);\n    }\n    else {\n\n        Out[0] = (cmsFloat32Number) (wOut[0] * 100.0);\n        Out[1] = (cmsFloat32Number) (wOut[1] * 255.0 - 128.0);\n        Out[2] = (cmsFloat32Number) (wOut[2] * 255.0 - 128.0);\n\n        return output + (sizeof(cmsFloat32Number)*3 + T_EXTRA(Info ->OutputFormat) * sizeof(cmsFloat32Number));\n    }\n\n}",
          "fn_code_pos": [
            [
              3158,
              0
            ],
            [
              3185,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackLabFloatFromFloat",
            "parameters": {
              "Info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackLabDoubleFromFloat(_cmsTRANSFORM* Info,\n                                       cmsFloat32Number wOut[],\n                                       cmsUInt8Number* output,\n                                       cmsUInt32Number Stride)\n{\n    cmsFloat64Number* Out = (cmsFloat64Number*) output;\n\n    if (T_PLANAR(Info -> OutputFormat)) {\n\n        Stride /= PixelSize(Info->OutputFormat);\n\n        Out[0]        = (cmsFloat64Number) (wOut[0] * 100.0);\n        Out[Stride]   = (cmsFloat64Number) (wOut[1] * 255.0 - 128.0);\n        Out[Stride*2] = (cmsFloat64Number) (wOut[2] * 255.0 - 128.0);\n\n        return output + sizeof(cmsFloat64Number);\n    }\n    else {\n\n        Out[0] = (cmsFloat64Number) (wOut[0] * 100.0);\n        Out[1] = (cmsFloat64Number) (wOut[1] * 255.0 - 128.0);\n        Out[2] = (cmsFloat64Number) (wOut[2] * 255.0 - 128.0);\n\n        return output + (sizeof(cmsFloat64Number)*3 + T_EXTRA(Info ->OutputFormat) * sizeof(cmsFloat64Number));\n    }\n\n}",
          "fn_code_pos": [
            [
              3188,
              0
            ],
            [
              3215,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackLabDoubleFromFloat",
            "parameters": {
              "Info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackEncodedBytesLabV2FromFloat(_cmsTRANSFORM* Info,\n                                           cmsFloat32Number wOut[],\n                                           cmsUInt8Number* output,\n                                           cmsUInt32Number Stride)\n{    \n    cmsCIELab Lab;\n    cmsUInt16Number wlab[3];\n\n    Lab.L = (cmsFloat64Number)(wOut[0] * 100.0);\n    Lab.a = (cmsFloat64Number)(wOut[1] * 255.0 - 128.0);\n    Lab.b = (cmsFloat64Number)(wOut[2] * 255.0 - 128.0);\n\n    cmsFloat2LabEncoded(wlab, &Lab);\n    \n    if (T_PLANAR(Info -> OutputFormat)) {\n\n        Stride /= PixelSize(Info->OutputFormat);       \n    \n        output[0]        = wlab[0] >> 8;\n        output[Stride]   = wlab[1] >> 8;\n        output[Stride*2] = wlab[2] >> 8;\n\n        return output + 1;\n    }\n    else {\n\n        output[0] = wlab[0] >> 8;\n        output[1] = wlab[1] >> 8;\n        output[2] = wlab[2] >> 8;\n\n        return output + (3 + T_EXTRA(Info ->OutputFormat));\n    }\n}",
          "fn_code_pos": [
            [
              3218,
              0
            ],
            [
              3251,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackEncodedBytesLabV2FromFloat",
            "parameters": {
              "Info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackEncodedWordsLabV2FromFloat(_cmsTRANSFORM* Info,\n                                           cmsFloat32Number wOut[],\n                                           cmsUInt8Number* output,\n                                           cmsUInt32Number Stride)\n{    \n    cmsCIELab Lab;\n    cmsUInt16Number wlab[3];\n\n    Lab.L = (cmsFloat64Number)(wOut[0] * 100.0);\n    Lab.a = (cmsFloat64Number)(wOut[1] * 255.0 - 128.0);\n    Lab.b = (cmsFloat64Number)(wOut[2] * 255.0 - 128.0);\n\n    cmsFloat2LabEncodedV2(wlab, &Lab);\n    \n    if (T_PLANAR(Info -> OutputFormat)) {\n\n        Stride /= PixelSize(Info->OutputFormat);       \n    \n        ((cmsUInt16Number*) output)[0]        = wlab[0];\n        ((cmsUInt16Number*) output)[Stride]   = wlab[1];\n        ((cmsUInt16Number*) output)[Stride*2] = wlab[2];\n\n        return output + sizeof(cmsUInt16Number);\n    }\n    else {\n\n         ((cmsUInt16Number*) output)[0] = wlab[0];\n         ((cmsUInt16Number*) output)[1] = wlab[1];\n         ((cmsUInt16Number*) output)[2] = wlab[2];\n\n        return output + (3 + T_EXTRA(Info ->OutputFormat)) * sizeof(cmsUInt16Number);\n    }\n}",
          "fn_code_pos": [
            [
              3253,
              0
            ],
            [
              3286,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackEncodedWordsLabV2FromFloat",
            "parameters": {
              "Info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackXYZFloatFromFloat(_cmsTRANSFORM* Info,\n                                      cmsFloat32Number wOut[],\n                                      cmsUInt8Number* output,\n                                      cmsUInt32Number Stride)\n{\n    cmsFloat32Number* Out = (cmsFloat32Number*) output;\n\n    if (T_PLANAR(Info -> OutputFormat)) {\n\n        Stride /= PixelSize(Info->OutputFormat);\n\n        Out[0]        = (cmsFloat32Number) (wOut[0] * MAX_ENCODEABLE_XYZ);\n        Out[Stride]   = (cmsFloat32Number) (wOut[1] * MAX_ENCODEABLE_XYZ);\n        Out[Stride*2] = (cmsFloat32Number) (wOut[2] * MAX_ENCODEABLE_XYZ);\n\n        return output + sizeof(cmsFloat32Number);\n    }\n    else {\n\n        Out[0] = (cmsFloat32Number) (wOut[0] * MAX_ENCODEABLE_XYZ);\n        Out[1] = (cmsFloat32Number) (wOut[1] * MAX_ENCODEABLE_XYZ);\n        Out[2] = (cmsFloat32Number) (wOut[2] * MAX_ENCODEABLE_XYZ);\n\n        return output + (sizeof(cmsFloat32Number)*3 + T_EXTRA(Info ->OutputFormat) * sizeof(cmsFloat32Number));\n    }\n\n}",
          "fn_code_pos": [
            [
              3290,
              0
            ],
            [
              3317,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackXYZFloatFromFloat",
            "parameters": {
              "Info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackXYZDoubleFromFloat(_cmsTRANSFORM* Info,\n                                       cmsFloat32Number wOut[],\n                                       cmsUInt8Number* output,\n                                       cmsUInt32Number Stride)\n{\n    cmsFloat64Number* Out = (cmsFloat64Number*) output;\n\n    if (T_PLANAR(Info -> OutputFormat)) {\n\n        Stride /= PixelSize(Info->OutputFormat);\n\n        Out[0]        = (cmsFloat64Number) (wOut[0] * MAX_ENCODEABLE_XYZ);\n        Out[Stride]   = (cmsFloat64Number) (wOut[1] * MAX_ENCODEABLE_XYZ);\n        Out[Stride*2] = (cmsFloat64Number) (wOut[2] * MAX_ENCODEABLE_XYZ);\n\n        return output + sizeof(cmsFloat64Number);\n    }\n    else {\n\n        Out[0] = (cmsFloat64Number) (wOut[0] * MAX_ENCODEABLE_XYZ);\n        Out[1] = (cmsFloat64Number) (wOut[1] * MAX_ENCODEABLE_XYZ);\n        Out[2] = (cmsFloat64Number) (wOut[2] * MAX_ENCODEABLE_XYZ);\n\n        return output + (sizeof(cmsFloat64Number)*3 + T_EXTRA(Info ->OutputFormat) * sizeof(cmsFloat64Number));\n    }\n\n}",
          "fn_code_pos": [
            [
              3320,
              0
            ],
            [
              3347,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackXYZDoubleFromFloat",
            "parameters": {
              "Info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollHalfTo16(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wIn[],\n                                CMSREGISTER cmsUInt8Number* accum,\n                                CMSREGISTER cmsUInt32Number Stride)\n{\n\n    cmsUInt32Number nChan      = T_CHANNELS(info -> InputFormat);\n    cmsUInt32Number DoSwap     = T_DOSWAP(info ->InputFormat);\n    cmsUInt32Number Reverse    = T_FLAVOR(info ->InputFormat);\n    cmsUInt32Number SwapFirst  = T_SWAPFIRST(info -> InputFormat);\n    cmsUInt32Number Extra      = T_EXTRA(info -> InputFormat);\n    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n    cmsUInt32Number Planar     = T_PLANAR(info -> InputFormat);\n    cmsFloat32Number v;\n    cmsUInt32Number i, start = 0;\n    cmsFloat32Number maximum = IsInkSpace(info ->InputFormat) ? 655.35F : 65535.0F;\n\n\n    Stride /= PixelSize(info->OutputFormat);\n\n    if (ExtraFirst)\n            start = Extra;\n\n    for (i=0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n        if (Planar)\n            v = _cmsHalf2Float ( ((cmsUInt16Number*) accum)[(i + start) * Stride] );\n        else\n            v = _cmsHalf2Float ( ((cmsUInt16Number*) accum)[i + start] ) ;\n\n        if (Reverse) v = maximum - v;\n\n        wIn[index] = _cmsQuickSaturateWord((cmsFloat64Number) v * maximum);\n    }\n\n\n    if (Extra == 0 && SwapFirst) {\n        cmsUInt16Number tmp = wIn[0];\n\n        memmove(&wIn[0], &wIn[1], (nChan-1) * sizeof(cmsUInt16Number));\n        wIn[nChan-1] = tmp;\n    }\n\n    if (T_PLANAR(info -> InputFormat))\n        return accum + sizeof(cmsUInt16Number);\n    else\n        return accum + (nChan + Extra) * sizeof(cmsUInt16Number);\n}",
          "fn_code_pos": [
            [
              3356,
              0
            ],
            [
              3406,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollHalfTo16",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* UnrollHalfToFloat(_cmsTRANSFORM* info,\n                                    cmsFloat32Number wIn[],\n                                    cmsUInt8Number* accum,\n                                    cmsUInt32Number Stride)\n{\n\n    cmsUInt32Number nChan      = T_CHANNELS(info -> InputFormat);\n    cmsUInt32Number DoSwap     = T_DOSWAP(info ->InputFormat);\n    cmsUInt32Number Reverse    = T_FLAVOR(info ->InputFormat);\n    cmsUInt32Number SwapFirst  = T_SWAPFIRST(info -> InputFormat);\n    cmsUInt32Number Extra      = T_EXTRA(info -> InputFormat);\n    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n    cmsUInt32Number Planar     = T_PLANAR(info -> InputFormat);\n    cmsFloat32Number v;\n    cmsUInt32Number i, start = 0;\n    cmsFloat32Number maximum = IsInkSpace(info ->InputFormat) ? 100.0F : 1.0F;\n\n    Stride /= PixelSize(info->InputFormat);\n\n    if (ExtraFirst)\n            start = Extra;\n\n    for (i=0; i < nChan; i++) {\n\n        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n        if (Planar)\n            v =  _cmsHalf2Float ( ((cmsUInt16Number*) accum)[(i + start) * Stride] );\n        else\n            v =  _cmsHalf2Float ( ((cmsUInt16Number*) accum)[i + start] ) ;\n\n        v /= maximum;\n\n        wIn[index] = Reverse ? 1 - v : v;\n    }\n\n\n    if (Extra == 0 && SwapFirst) {\n        cmsFloat32Number tmp = wIn[0];\n\n        memmove(&wIn[0], &wIn[1], (nChan-1) * sizeof(cmsFloat32Number));\n        wIn[nChan-1] = tmp;\n    }\n\n    if (T_PLANAR(info -> InputFormat))\n        return accum + sizeof(cmsUInt16Number);\n    else\n        return accum + (nChan + Extra) * sizeof(cmsUInt16Number);\n}",
          "fn_code_pos": [
            [
              3410,
              0
            ],
            [
              3459,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollHalfToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackHalfFrom16(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wOut[],\n                                CMSREGISTER cmsUInt8Number* output,\n                                CMSREGISTER cmsUInt32Number Stride)\n{\n       cmsUInt32Number nChan      = T_CHANNELS(info->OutputFormat);\n       cmsUInt32Number DoSwap     = T_DOSWAP(info->OutputFormat);\n       cmsUInt32Number Reverse    = T_FLAVOR(info->OutputFormat);\n       cmsUInt32Number Extra      = T_EXTRA(info->OutputFormat);\n       cmsUInt32Number SwapFirst  = T_SWAPFIRST(info->OutputFormat);\n       cmsUInt32Number Planar     = T_PLANAR(info->OutputFormat);\n       cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n       cmsFloat32Number maximum = IsInkSpace(info->OutputFormat) ? 655.35F : 65535.0F;\n       cmsFloat32Number v = 0;\n       cmsUInt16Number* swap1 = (cmsUInt16Number*)output;\n       cmsUInt32Number i, start = 0;\n\n       Stride /= PixelSize(info->OutputFormat);\n\n       if (ExtraFirst)\n              start = Extra;\n\n       for (i = 0; i < nChan; i++) {\n\n              cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n              v = (cmsFloat32Number)wOut[index] / maximum;\n\n              if (Reverse)\n                     v = maximum - v;\n\n              if (Planar)\n                     ((cmsUInt16Number*)output)[(i + start) * Stride] = _cmsFloat2Half(v);\n              else\n                     ((cmsUInt16Number*)output)[i + start] = _cmsFloat2Half(v);\n       }\n\n\n       if (Extra == 0 && SwapFirst) {\n\n              memmove(swap1 + 1, swap1, (nChan - 1)* sizeof(cmsUInt16Number));\n              *swap1 = _cmsFloat2Half(v);\n       }\n\n       if (T_PLANAR(info->OutputFormat))\n              return output + sizeof(cmsUInt16Number);\n       else\n              return output + (nChan + Extra) * sizeof(cmsUInt16Number);\n}",
          "fn_code_pos": [
            [
              3462,
              0
            ],
            [
              3511,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackHalfFrom16",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt8Number* PackHalfFromFloat(_cmsTRANSFORM* info,\n                                    cmsFloat32Number wOut[],\n                                    cmsUInt8Number* output,\n                                    cmsUInt32Number Stride)\n{\n       cmsUInt32Number nChan      = T_CHANNELS(info->OutputFormat);\n       cmsUInt32Number DoSwap     = T_DOSWAP(info->OutputFormat);\n       cmsUInt32Number Reverse    = T_FLAVOR(info->OutputFormat);\n       cmsUInt32Number Extra      = T_EXTRA(info->OutputFormat);\n       cmsUInt32Number SwapFirst  = T_SWAPFIRST(info->OutputFormat);\n       cmsUInt32Number Planar     = T_PLANAR(info->OutputFormat);\n       cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n       cmsFloat32Number maximum = IsInkSpace(info->OutputFormat) ? 100.0F : 1.0F;\n       cmsUInt16Number* swap1 = (cmsUInt16Number*)output;\n       cmsFloat32Number v = 0;\n       cmsUInt32Number i, start = 0;\n\n       Stride /= PixelSize(info->OutputFormat);\n\n       if (ExtraFirst)\n              start = Extra;\n\n       for (i = 0; i < nChan; i++) {\n\n           cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n\n              v = wOut[index] * maximum;\n\n              if (Reverse)\n                     v = maximum - v;\n\n              if (Planar)\n                     ((cmsUInt16Number*)output)[(i + start)* Stride] = _cmsFloat2Half(v);\n              else\n                     ((cmsUInt16Number*)output)[i + start] = _cmsFloat2Half(v);\n       }\n\n\n       if (Extra == 0 && SwapFirst) {\n\n              memmove(swap1 + 1, swap1, (nChan - 1)* sizeof(cmsUInt16Number));\n              *swap1 = (cmsUInt16Number)_cmsFloat2Half(v);\n       }\n\n       if (T_PLANAR(info->OutputFormat))\n              return output + sizeof(cmsUInt16Number);\n       else\n              return output + (nChan + Extra)* sizeof(cmsUInt16Number);\n}",
          "fn_code_pos": [
            [
              3515,
              0
            ],
            [
              3564,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackHalfFromFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "static\ncmsFormatter _cmsGetStockInputFormatter(cmsUInt32Number dwInput, cmsUInt32Number dwFlags)\n{\n    cmsUInt32Number i;\n    cmsFormatter fr;\n\n    switch (dwFlags) {\n\n    case CMS_PACK_FLAGS_16BITS: {\n        for (i=0; i < sizeof(InputFormatters16) / sizeof(cmsFormatters16); i++) {\n            const cmsFormatters16* f = InputFormatters16 + i;\n\n            if ((dwInput & ~f ->Mask) == f ->Type) {\n                fr.Fmt16 = f ->Frm;\n                return fr;\n            }\n        }\n    }\n    break;\n\n    case CMS_PACK_FLAGS_FLOAT: {\n        for (i=0; i < sizeof(InputFormattersFloat) / sizeof(cmsFormattersFloat); i++) {\n            const cmsFormattersFloat* f = InputFormattersFloat + i;\n\n            if ((dwInput & ~f ->Mask) == f ->Type) {\n                fr.FmtFloat = f ->Frm;\n                return fr;\n            }\n        }\n    }\n    break;\n\n    default:;\n\n    }\n\n    fr.Fmt16 = NULL;\n    return fr;\n}",
          "fn_code_pos": [
            [
              3679,
              0
            ],
            [
              3717,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetStockInputFormatter",
            "parameters": {
              "dwInput": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsFormatter"
          }
        },
        {
          "fn_code": "static\ncmsFormatter _cmsGetStockOutputFormatter(cmsUInt32Number dwInput, cmsUInt32Number dwFlags)\n{\n    cmsUInt32Number i;\n    cmsFormatter fr;\n\n    // Optimization is only a hint\n    dwInput &= ~OPTIMIZED_SH(1);\n\n    switch (dwFlags)\n    {\n\n     case CMS_PACK_FLAGS_16BITS: {\n\n        for (i=0; i < sizeof(OutputFormatters16) / sizeof(cmsFormatters16); i++) {\n            const cmsFormatters16* f = OutputFormatters16 + i;\n\n            if ((dwInput & ~f ->Mask) == f ->Type) {\n                fr.Fmt16 = f ->Frm;\n                return fr;\n            }\n        }\n        }\n        break;\n\n    case CMS_PACK_FLAGS_FLOAT: {\n\n        for (i=0; i < sizeof(OutputFormattersFloat) / sizeof(cmsFormattersFloat); i++) {\n            const cmsFormattersFloat* f = OutputFormattersFloat + i;\n\n            if ((dwInput & ~f ->Mask) == f ->Type) {\n                fr.FmtFloat = f ->Frm;\n                return fr;\n            }\n        }\n        }\n        break;\n\n    default:;\n\n    }\n\n    fr.Fmt16 = NULL;\n    return fr;\n}",
          "fn_code_pos": [
            [
              3845,
              0
            ],
            [
              3889,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetStockOutputFormatter",
            "parameters": {
              "dwInput": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsFormatter"
          }
        },
        {
          "fn_code": "static\nvoid DupFormatterFactoryList(struct _cmsContext_struct* ctx, \n                                               const struct _cmsContext_struct* src)\n{\n   _cmsFormattersPluginChunkType newHead = { NULL };\n   cmsFormattersFactoryList*  entry;\n   cmsFormattersFactoryList*  Anterior = NULL;\n   _cmsFormattersPluginChunkType* head = (_cmsFormattersPluginChunkType*) src->chunks[FormattersPlugin];\n\n     _cmsAssert(head != NULL);\n\n   // Walk the list copying all nodes\n   for (entry = head->FactoryList;\n       entry != NULL;\n       entry = entry ->Next) {\n\n           cmsFormattersFactoryList *newEntry = ( cmsFormattersFactoryList *) _cmsSubAllocDup(ctx ->MemPool, entry, sizeof(cmsFormattersFactoryList));\n\n           if (newEntry == NULL) \n               return;\n\n           // We want to keep the linked list order, so this is a little bit tricky\n           newEntry -> Next = NULL;\n           if (Anterior)\n               Anterior -> Next = newEntry;\n\n           Anterior = newEntry;\n\n           if (newHead.FactoryList == NULL)\n               newHead.FactoryList = newEntry;\n   }\n\n   ctx ->chunks[FormattersPlugin] = _cmsSubAllocDup(ctx->MemPool, &newHead, sizeof(_cmsFormattersPluginChunkType));\n}",
          "fn_code_pos": [
            [
              3903,
              0
            ],
            [
              3936,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DupFormatterFactoryList",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void _cmsAllocFormattersPluginChunk(struct _cmsContext_struct* ctx, \n                                    const struct _cmsContext_struct* src)\n{\n      _cmsAssert(ctx != NULL);\n\n     if (src != NULL) {\n        \n         // Duplicate the LIST\n         DupFormatterFactoryList(ctx, src);\n     }\n     else {\n          static _cmsFormattersPluginChunkType FormattersPluginChunk = { NULL };\n          ctx ->chunks[FormattersPlugin] = _cmsSubAllocDup(ctx ->MemPool, &FormattersPluginChunk, sizeof(_cmsFormattersPluginChunkType));\n     }\n}",
          "fn_code_pos": [
            [
              3939,
              0
            ],
            [
              3953,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocFormattersPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool  _cmsRegisterFormattersPlugin(cmsContext ContextID, cmsPluginBase* Data)\n{\n    _cmsFormattersPluginChunkType* ctx = ( _cmsFormattersPluginChunkType*) _cmsContextGetClientChunk(ContextID, FormattersPlugin);\n    cmsPluginFormatters* Plugin = (cmsPluginFormatters*) Data;\n    cmsFormattersFactoryList* fl ;\n\n    // Reset to built-in defaults\n    if (Data == NULL) {\n\n          ctx ->FactoryList = NULL;\n          return TRUE;\n    }\n\n    fl = (cmsFormattersFactoryList*) _cmsPluginMalloc(ContextID, sizeof(cmsFormattersFactoryList));\n    if (fl == NULL) return FALSE;\n\n    fl ->Factory    = Plugin ->FormattersFactory;\n\n    fl ->Next = ctx -> FactoryList;\n    ctx ->FactoryList = fl;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              3958,
              0
            ],
            [
              3980,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterFormattersPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Data": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsFormatter CMSEXPORT _cmsGetFormatter(cmsContext ContextID,\n                                        cmsUInt32Number Type,         // Specific type, i.e. TYPE_RGB_8\n                                        cmsFormatterDirection Dir,\n                                        cmsUInt32Number dwFlags)\n{\n    _cmsFormattersPluginChunkType* ctx = ( _cmsFormattersPluginChunkType*) _cmsContextGetClientChunk(ContextID, FormattersPlugin);\n    cmsFormattersFactoryList* f;\n\n    if (T_CHANNELS(Type) == 0) {\n        static const cmsFormatter nullFormatter = { 0 };\n        return nullFormatter;\n    }\n\n    for (f =ctx->FactoryList; f != NULL; f = f ->Next) {\n\n        cmsFormatter fn = f ->Factory(Type, Dir, dwFlags);\n        if (fn.Fmt16 != NULL) return fn;\n    }\n\n    // Revert to default\n    if (Dir == cmsFormatterInput)\n        return _cmsGetStockInputFormatter(Type, dwFlags);\n    else\n        return _cmsGetStockOutputFormatter(Type, dwFlags);\n}",
          "fn_code_pos": [
            [
              3982,
              0
            ],
            [
              4006,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetFormatter",
            "parameters": {
              "ContextID": "cmsContext",
              "Type": "cmsUInt32Number",
              "Dir": "cmsFormatterDirection",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsFormatter"
          }
        },
        {
          "fn_code": "cmsBool  _cmsFormatterIsFloat(cmsUInt32Number Type)\n{\n    return T_FLOAT(Type) ? TRUE : FALSE;\n}",
          "fn_code_pos": [
            [
              4010,
              0
            ],
            [
              4013,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsFormatterIsFloat",
            "parameters": {
              "Type": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool  _cmsFormatterIs8bit(cmsUInt32Number Type)\n{\n    cmsUInt32Number Bytes = T_BYTES(Type);\n\n    return (Bytes == 1);\n}",
          "fn_code_pos": [
            [
              4016,
              0
            ],
            [
              4021,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsFormatterIs8bit",
            "parameters": {
              "Type": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsFormatterForColorspaceOfProfile(cmsHPROFILE hProfile, cmsUInt32Number nBytes, cmsBool lIsFloat)\n{\n\n    cmsColorSpaceSignature ColorSpace      = cmsGetColorSpace(hProfile);\n    cmsUInt32Number        ColorSpaceBits  = (cmsUInt32Number) _cmsLCMScolorSpace(ColorSpace);\n    cmsInt32Number         nOutputChans    = cmsChannelsOfColorSpace(ColorSpace);\n    cmsUInt32Number        Float           = lIsFloat ? 1U : 0;\n\n    // Unsupported color space?\n    if (nOutputChans < 0) return 0;\n\n    // Create a fake formatter for result\n    return FLOAT_SH(Float) | COLORSPACE_SH(ColorSpaceBits) | BYTES_SH(nBytes) | CHANNELS_SH(nOutputChans);\n}",
          "fn_code_pos": [
            [
              4024,
              0
            ],
            [
              4037,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFormatterForColorspaceOfProfile",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "nBytes": "cmsUInt32Number",
              "lIsFloat": "cmsBool"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsFormatterForPCSOfProfile(cmsHPROFILE hProfile, cmsUInt32Number nBytes, cmsBool lIsFloat)\n{\n\n    cmsColorSpaceSignature ColorSpace = cmsGetPCS(hProfile);\n\n    cmsUInt32Number ColorSpaceBits = (cmsUInt32Number) _cmsLCMScolorSpace(ColorSpace);\n    cmsInt32Number  nOutputChans = cmsChannelsOfColorSpace(ColorSpace);\n    cmsUInt32Number Float = lIsFloat ? 1U : 0;\n\n    // Unsupported color space?\n    if (nOutputChans < 0) return 0;\n\n    // Create a fake formatter for result\n    return FLOAT_SH(Float) | COLORSPACE_SH(ColorSpaceBits) | BYTES_SH(nBytes) | CHANNELS_SH(nOutputChans);\n}",
          "fn_code_pos": [
            [
              4040,
              0
            ],
            [
              4054,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFormatterForPCSOfProfile",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "nBytes": "cmsUInt32Number",
              "lIsFloat": "cmsBool"
            },
            "return_type": "cmsUInt32Number"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "UnrollChunkyBytes(CMSREGISTER _cmsTRANSFORM* info,\n                                  CMSREGISTER cmsUInt16Number wIn[],\n                                  CMSREGISTER cmsUInt8Number* accum,\n                                  CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              95,
              16
            ],
            [
              98,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollChunkyBytes",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollPlanarBytes(CMSREGISTER _cmsTRANSFORM* info,\n                                  CMSREGISTER cmsUInt16Number wIn[],\n                                  CMSREGISTER cmsUInt8Number* accum,\n                                  CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              163,
              16
            ],
            [
              166,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollPlanarBytes",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll4Bytes(CMSREGISTER _cmsTRANSFORM* info,\n                             CMSREGISTER cmsUInt16Number wIn[],\n                             CMSREGISTER cmsUInt8Number* accum,\n                             CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              216,
              16
            ],
            [
              219,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4Bytes",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll4BytesReverse(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wIn[],\n                                    CMSREGISTER cmsUInt8Number* accum,\n                                    CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              233,
              16
            ],
            [
              236,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4BytesReverse",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll4BytesSwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                      CMSREGISTER cmsUInt16Number wIn[],\n                                      CMSREGISTER cmsUInt8Number* accum,\n                                      CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              250,
              16
            ],
            [
              253,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4BytesSwapFirst",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll4BytesSwap(CMSREGISTER _cmsTRANSFORM* info,\n                                 CMSREGISTER cmsUInt16Number wIn[],\n                                 CMSREGISTER cmsUInt8Number* accum,\n                                 CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              268,
              16
            ],
            [
              271,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4BytesSwap",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll4BytesSwapSwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                          CMSREGISTER cmsUInt16Number wIn[],\n                                          CMSREGISTER cmsUInt8Number* accum,\n                                          CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              285,
              16
            ],
            [
              288,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4BytesSwapSwapFirst",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll3Bytes(CMSREGISTER _cmsTRANSFORM* info,\n                             CMSREGISTER cmsUInt16Number wIn[],\n                             CMSREGISTER cmsUInt8Number* accum,\n                             CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              302,
              16
            ],
            [
              305,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll3Bytes",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll3BytesSkip1Swap(CMSREGISTER _cmsTRANSFORM* info,\n                                      CMSREGISTER cmsUInt16Number wIn[],\n                                      CMSREGISTER cmsUInt8Number* accum,\n                                      CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              318,
              16
            ],
            [
              321,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll3BytesSkip1Swap",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll3BytesSkip1SwapSwapFirst(CMSREGISTER _cmsTRANSFORM* info, \n                                              CMSREGISTER cmsUInt16Number wIn[], \n                                              CMSREGISTER cmsUInt8Number* accum,\n                                              CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              335,
              16
            ],
            [
              338,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll3BytesSkip1SwapSwapFirst",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll3BytesSkip1SwapFirst(CMSREGISTER _cmsTRANSFORM* info, \n                                           CMSREGISTER cmsUInt16Number wIn[], \n                                           CMSREGISTER cmsUInt8Number* accum,\n                                           CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              352,
              16
            ],
            [
              355,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll3BytesSkip1SwapFirst",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll3BytesSwap(CMSREGISTER _cmsTRANSFORM* info,\n                                 CMSREGISTER cmsUInt16Number wIn[],\n                                 CMSREGISTER cmsUInt8Number* accum,\n                                 CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              371,
              16
            ],
            [
              374,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll3BytesSwap",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollLabV2_8(CMSREGISTER _cmsTRANSFORM* info,\n                              CMSREGISTER cmsUInt16Number wIn[],\n                              CMSREGISTER cmsUInt8Number* accum,\n                              CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              387,
              16
            ],
            [
              390,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollLabV2_8",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollALabV2_8(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wIn[],\n                               CMSREGISTER cmsUInt8Number* accum,\n                               CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              403,
              16
            ],
            [
              406,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollALabV2_8",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollLabV2_16(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wIn[],\n                               CMSREGISTER cmsUInt8Number* accum,\n                               CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              420,
              16
            ],
            [
              423,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollLabV2_16",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll2Bytes(CMSREGISTER _cmsTRANSFORM* info,\n                                     CMSREGISTER cmsUInt16Number wIn[],\n                                     CMSREGISTER cmsUInt8Number* accum,\n                                     CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              437,
              16
            ],
            [
              440,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll2Bytes",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll1Byte(CMSREGISTER _cmsTRANSFORM* info,\n                            CMSREGISTER cmsUInt16Number wIn[],\n                            CMSREGISTER cmsUInt8Number* accum,\n                            CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              456,
              16
            ],
            [
              459,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll1Byte",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll1ByteSkip1(CMSREGISTER _cmsTRANSFORM* info,\n                                 CMSREGISTER cmsUInt16Number wIn[],\n                                 CMSREGISTER cmsUInt8Number* accum,\n                                 CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              471,
              16
            ],
            [
              474,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll1ByteSkip1",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll1ByteSkip2(CMSREGISTER _cmsTRANSFORM* info,\n                                 CMSREGISTER cmsUInt16Number wIn[],\n                                 CMSREGISTER cmsUInt8Number* accum,\n                                 CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              486,
              16
            ],
            [
              489,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll1ByteSkip2",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll1ByteReversed(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wIn[],\n                                    CMSREGISTER cmsUInt8Number* accum,\n                                    CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              501,
              16
            ],
            [
              504,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll1ByteReversed",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollAnyWords(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wIn[],\n                               CMSREGISTER cmsUInt8Number* accum,\n                               CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              516,
              16
            ],
            [
              519,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollAnyWords",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollAnyWordsPremul(CMSREGISTER _cmsTRANSFORM* info,\n                                     CMSREGISTER cmsUInt16Number wIn[],\n                                     CMSREGISTER cmsUInt8Number* accum,\n                                     CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              566,
              16
            ],
            [
              569,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollAnyWordsPremul",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollPlanarWords(CMSREGISTER _cmsTRANSFORM* info,\n                                  CMSREGISTER cmsUInt16Number wIn[],\n                                  CMSREGISTER cmsUInt8Number* accum,\n                                  CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              617,
              16
            ],
            [
              620,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollPlanarWords",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollPlanarWordsPremul(CMSREGISTER _cmsTRANSFORM* info,\n                                        CMSREGISTER cmsUInt16Number wIn[],\n                                        CMSREGISTER cmsUInt8Number* accum,\n                                        CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              650,
              16
            ],
            [
              653,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollPlanarWordsPremul",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll4Words(CMSREGISTER _cmsTRANSFORM* info,\n                             CMSREGISTER cmsUInt16Number wIn[],\n                             CMSREGISTER cmsUInt8Number* accum,\n                             CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              694,
              16
            ],
            [
              697,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4Words",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll4WordsReverse(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wIn[],\n                                    CMSREGISTER cmsUInt8Number* accum,\n                                    CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              711,
              16
            ],
            [
              714,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4WordsReverse",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll4WordsSwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                      CMSREGISTER cmsUInt16Number wIn[],\n                                      CMSREGISTER cmsUInt8Number* accum,\n                                      CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              728,
              16
            ],
            [
              731,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4WordsSwapFirst",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll4WordsSwap(CMSREGISTER _cmsTRANSFORM* info,\n                                 CMSREGISTER cmsUInt16Number wIn[],\n                                 CMSREGISTER cmsUInt8Number* accum,\n                                 CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              746,
              16
            ],
            [
              749,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4WordsSwap",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll4WordsSwapSwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                          CMSREGISTER cmsUInt16Number wIn[],\n                                          CMSREGISTER cmsUInt8Number* accum,\n                                          CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              763,
              16
            ],
            [
              766,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll4WordsSwapSwapFirst",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll3Words(CMSREGISTER _cmsTRANSFORM* info,\n                             CMSREGISTER cmsUInt16Number wIn[],\n                             CMSREGISTER cmsUInt8Number* accum,\n                             CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              780,
              16
            ],
            [
              783,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll3Words",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll3WordsSwap(CMSREGISTER _cmsTRANSFORM* info,\n                                 CMSREGISTER cmsUInt16Number wIn[],\n                                 CMSREGISTER cmsUInt8Number* accum,\n                                 CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              796,
              16
            ],
            [
              799,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll3WordsSwap",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll3WordsSkip1Swap(CMSREGISTER _cmsTRANSFORM* info,\n                                      CMSREGISTER cmsUInt16Number wIn[],\n                                      CMSREGISTER cmsUInt8Number* accum,\n                                      CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              812,
              16
            ],
            [
              815,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll3WordsSkip1Swap",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll3WordsSkip1SwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                           CMSREGISTER cmsUInt16Number wIn[],\n                                           CMSREGISTER cmsUInt8Number* accum,\n                                           CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              829,
              16
            ],
            [
              832,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll3WordsSkip1SwapFirst",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll1Word(CMSREGISTER _cmsTRANSFORM* info,\n                            CMSREGISTER cmsUInt16Number wIn[],\n                            CMSREGISTER cmsUInt8Number* accum,\n                            CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              846,
              16
            ],
            [
              849,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll1Word",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll1WordReversed(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wIn[],\n                                    CMSREGISTER cmsUInt8Number* accum,\n                                    CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              860,
              16
            ],
            [
              863,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll1WordReversed",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll1WordSkip3(CMSREGISTER _cmsTRANSFORM* info,\n                                 CMSREGISTER cmsUInt16Number wIn[],\n                                 CMSREGISTER cmsUInt8Number* accum,\n                                 CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              874,
              16
            ],
            [
              877,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll1WordSkip3",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll2Words(CMSREGISTER _cmsTRANSFORM* info,\n                                     CMSREGISTER cmsUInt16Number wIn[],\n                                     CMSREGISTER cmsUInt8Number* accum,\n                                     CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              890,
              16
            ],
            [
              893,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll2Words",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollLabDoubleTo16(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wIn[],\n                                    CMSREGISTER cmsUInt8Number* accum,\n                                    CMSREGISTER cmsUInt32Number  Stride)",
          "fn_dec_pos": [
            [
              907,
              16
            ],
            [
              910,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollLabDoubleTo16",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollLabFloatTo16(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wIn[],\n                                    CMSREGISTER cmsUInt8Number* accum,\n                                    CMSREGISTER cmsUInt32Number  Stride)",
          "fn_dec_pos": [
            [
              941,
              16
            ],
            [
              944,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollLabFloatTo16",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollXYZDoubleTo16(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wIn[],\n                                    CMSREGISTER cmsUInt8Number* accum,\n                                    CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              979,
              16
            ],
            [
              982,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollXYZDoubleTo16",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollXYZFloatTo16(CMSREGISTER _cmsTRANSFORM* info,\n                                   CMSREGISTER cmsUInt16Number wIn[],\n                                   CMSREGISTER cmsUInt8Number* accum,\n                                   CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1015,
              16
            ],
            [
              1018,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollXYZFloatTo16",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollDoubleTo16(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wIn[],\n                                CMSREGISTER cmsUInt8Number* accum,\n                                CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1094,
              16
            ],
            [
              1097,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollDoubleTo16",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollFloatTo16(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wIn[],\n                                CMSREGISTER cmsUInt8Number* accum,\n                                CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1152,
              16
            ],
            [
              1155,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollFloatTo16",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollDouble1Chan(CMSREGISTER _cmsTRANSFORM* info,\n                                  CMSREGISTER cmsUInt16Number wIn[],\n                                  CMSREGISTER cmsUInt8Number* accum,\n                                  CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1211,
              16
            ],
            [
              1214,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollDouble1Chan",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll8ToFloat(_cmsTRANSFORM* info,\n                               cmsFloat32Number wIn[],\n                               cmsUInt8Number* accum,\n                               cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1230,
              16
            ],
            [
              1233,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll8ToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Unroll16ToFloat(_cmsTRANSFORM* info,\n                                cmsFloat32Number wIn[],\n                                cmsUInt8Number* accum,\n                                cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1282,
              16
            ],
            [
              1285,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Unroll16ToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollFloatsToFloat(_cmsTRANSFORM* info,\n                                    cmsFloat32Number wIn[],\n                                    cmsUInt8Number* accum,\n                                    cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1334,
              16
            ],
            [
              1337,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollFloatsToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollDoublesToFloat(_cmsTRANSFORM* info,\n                                    cmsFloat32Number wIn[],\n                                    cmsUInt8Number* accum,\n                                    cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1401,
              16
            ],
            [
              1404,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollDoublesToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollLabDoubleToFloat(_cmsTRANSFORM* info,\n                                       cmsFloat32Number wIn[],\n                                       cmsUInt8Number* accum,\n                                       cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1470,
              16
            ],
            [
              1473,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollLabDoubleToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollLabFloatToFloat(_cmsTRANSFORM* info,\n                                      cmsFloat32Number wIn[],\n                                      cmsUInt8Number* accum,\n                                      cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1500,
              16
            ],
            [
              1503,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollLabFloatToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollXYZDoubleToFloat(_cmsTRANSFORM* info,\n                                       cmsFloat32Number wIn[],\n                                       cmsUInt8Number* accum,\n                                       cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1530,
              16
            ],
            [
              1533,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollXYZDoubleToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollXYZFloatToFloat(_cmsTRANSFORM* info,\n                                      cmsFloat32Number wIn[],\n                                      cmsUInt8Number* accum,\n                                      cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1559,
              16
            ],
            [
              1562,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollXYZFloatToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollLabV2_8ToFloat(_cmsTRANSFORM* info,\n                                      cmsFloat32Number wIn[],\n                                      cmsUInt8Number* accum,\n                                      cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1601,
              16
            ],
            [
              1604,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollLabV2_8ToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollALabV2_8ToFloat(_cmsTRANSFORM* info,\n                                      cmsFloat32Number wIn[],\n                                      cmsUInt8Number* accum,\n                                      cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1621,
              16
            ],
            [
              1624,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollALabV2_8ToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollLabV2_16ToFloat(_cmsTRANSFORM* info,\n                                      cmsFloat32Number wIn[],\n                                      cmsUInt8Number* accum,\n                                      cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1642,
              16
            ],
            [
              1645,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollLabV2_16ToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackChunkyBytes(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wOut[],\n                                CMSREGISTER cmsUInt8Number* output,\n                                CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1667,
              16
            ],
            [
              1670,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackChunkyBytes",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackChunkyWords(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wOut[],\n                                CMSREGISTER cmsUInt8Number* output,\n                                CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1732,
              16
            ],
            [
              1735,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackChunkyWords",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackPlanarBytes(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wOut[],\n                                CMSREGISTER cmsUInt8Number* output,\n                                CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1805,
              16
            ],
            [
              1808,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackPlanarBytes",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackPlanarWords(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wOut[],\n                                CMSREGISTER cmsUInt8Number* output,\n                                CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1861,
              16
            ],
            [
              1864,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackPlanarWords",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack6Bytes(CMSREGISTER _cmsTRANSFORM* info,\n                           CMSREGISTER cmsUInt16Number wOut[],\n                           CMSREGISTER cmsUInt8Number* output,\n                           CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1919,
              16
            ],
            [
              1922,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack6Bytes",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack6BytesSwap(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wOut[],\n                               CMSREGISTER cmsUInt8Number* output,\n                               CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1940,
              16
            ],
            [
              1943,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack6BytesSwap",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack6Words(CMSREGISTER _cmsTRANSFORM* info,\n                           CMSREGISTER cmsUInt16Number wOut[],\n                           CMSREGISTER cmsUInt8Number* output,\n                           CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1960,
              16
            ],
            [
              1963,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack6Words",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack6WordsSwap(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wOut[],\n                               CMSREGISTER cmsUInt8Number* output,\n                               CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1986,
              16
            ],
            [
              1989,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack6WordsSwap",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack4Bytes(CMSREGISTER _cmsTRANSFORM* info,\n                           CMSREGISTER cmsUInt16Number wOut[],\n                           CMSREGISTER cmsUInt8Number* output,\n                           CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2012,
              16
            ],
            [
              2015,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack4Bytes",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack4BytesReverse(CMSREGISTER _cmsTRANSFORM* info,\n                                  CMSREGISTER cmsUInt16Number wOut[],\n                                  CMSREGISTER cmsUInt8Number* output,\n                                  CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2029,
              16
            ],
            [
              2032,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack4BytesReverse",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack4BytesSwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wOut[],\n                                    CMSREGISTER cmsUInt8Number* output,\n                                    CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2047,
              16
            ],
            [
              2050,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack4BytesSwapFirst",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack4BytesSwap(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wOut[],\n                               CMSREGISTER cmsUInt8Number* output,\n                               CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2065,
              16
            ],
            [
              2068,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack4BytesSwap",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack4BytesSwapSwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                        CMSREGISTER cmsUInt16Number wOut[],\n                                        CMSREGISTER cmsUInt8Number* output,\n                                        CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2082,
              16
            ],
            [
              2085,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack4BytesSwapSwapFirst",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack4Words(CMSREGISTER _cmsTRANSFORM* info,\n                           CMSREGISTER cmsUInt16Number wOut[],\n                           CMSREGISTER cmsUInt8Number* output,\n                           CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2099,
              16
            ],
            [
              2102,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack4Words",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack4WordsReverse(CMSREGISTER _cmsTRANSFORM* info,\n                                  CMSREGISTER cmsUInt16Number wOut[],\n                                  CMSREGISTER cmsUInt8Number* output,\n                                  CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2120,
              16
            ],
            [
              2123,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack4WordsReverse",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack4WordsSwap(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wOut[],\n                               CMSREGISTER cmsUInt8Number* output,\n                               CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2142,
              16
            ],
            [
              2145,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack4WordsSwap",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack4WordsBigEndian(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wOut[],\n                                    CMSREGISTER cmsUInt8Number* output,\n                                    CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2164,
              16
            ],
            [
              2167,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack4WordsBigEndian",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackLabV2_8(CMSREGISTER _cmsTRANSFORM* info,\n                            CMSREGISTER cmsUInt16Number wOut[],\n                            CMSREGISTER cmsUInt8Number* output,\n                            CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2186,
              16
            ],
            [
              2189,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackLabV2_8",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackALabV2_8(CMSREGISTER _cmsTRANSFORM* info,\n                             CMSREGISTER cmsUInt16Number wOut[],\n                             CMSREGISTER cmsUInt8Number* output,\n                             CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2202,
              16
            ],
            [
              2205,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackALabV2_8",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackLabV2_16(CMSREGISTER _cmsTRANSFORM* info,\n                             CMSREGISTER cmsUInt16Number wOut[],\n                             CMSREGISTER cmsUInt8Number* output,\n                             CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2219,
              16
            ],
            [
              2222,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackLabV2_16",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack3Bytes(CMSREGISTER _cmsTRANSFORM* info,\n                           CMSREGISTER cmsUInt16Number wOut[],\n                           CMSREGISTER cmsUInt8Number* output,\n                           CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2238,
              16
            ],
            [
              2241,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3Bytes",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack3BytesOptimized(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wOut[],\n                                    CMSREGISTER cmsUInt8Number* output,\n                                    CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2254,
              16
            ],
            [
              2257,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesOptimized",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack3BytesSwap(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wOut[],\n                               CMSREGISTER cmsUInt8Number* output,\n                               CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2270,
              16
            ],
            [
              2273,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesSwap",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack3BytesSwapOptimized(CMSREGISTER _cmsTRANSFORM* info,\n                                        CMSREGISTER cmsUInt16Number wOut[],\n                                        CMSREGISTER cmsUInt8Number* output,\n                                        CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2286,
              16
            ],
            [
              2289,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesSwapOptimized",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack3Words(CMSREGISTER _cmsTRANSFORM* info,\n                           CMSREGISTER cmsUInt16Number wOut[],\n                           CMSREGISTER cmsUInt8Number* output,\n                           CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2303,
              16
            ],
            [
              2306,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3Words",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack3WordsSwap(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wOut[],\n                               CMSREGISTER cmsUInt8Number* output,\n                               CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2322,
              16
            ],
            [
              2325,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3WordsSwap",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack3WordsBigEndian(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wOut[],\n                                    CMSREGISTER cmsUInt8Number* output,\n                                    CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2341,
              16
            ],
            [
              2344,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3WordsBigEndian",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack3BytesAndSkip1(CMSREGISTER _cmsTRANSFORM* info,\n                                   CMSREGISTER cmsUInt16Number wOut[],\n                                   CMSREGISTER cmsUInt8Number* output,\n                                   CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2360,
              16
            ],
            [
              2363,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesAndSkip1",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack3BytesAndSkip1Optimized(CMSREGISTER _cmsTRANSFORM* info,\n                                            CMSREGISTER cmsUInt16Number wOut[],\n                                            CMSREGISTER cmsUInt8Number* output,\n                                            CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2377,
              16
            ],
            [
              2380,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesAndSkip1Optimized",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack3BytesAndSkip1SwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                            CMSREGISTER cmsUInt16Number wOut[],\n                                            CMSREGISTER cmsUInt8Number* output,\n                                            CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2395,
              16
            ],
            [
              2398,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesAndSkip1SwapFirst",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack3BytesAndSkip1SwapFirstOptimized(CMSREGISTER _cmsTRANSFORM* info,\n                                                     CMSREGISTER cmsUInt16Number wOut[],\n                                                     CMSREGISTER cmsUInt8Number* output,\n                                                     CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2412,
              16
            ],
            [
              2415,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesAndSkip1SwapFirstOptimized",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack3BytesAndSkip1Swap(CMSREGISTER _cmsTRANSFORM* info,\n                                       CMSREGISTER cmsUInt16Number wOut[],\n                                       CMSREGISTER cmsUInt8Number* output,\n                                       CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2429,
              16
            ],
            [
              2432,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesAndSkip1Swap",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack3BytesAndSkip1SwapOptimized(CMSREGISTER _cmsTRANSFORM* info,\n                                                CMSREGISTER cmsUInt16Number wOut[],\n                                                CMSREGISTER cmsUInt8Number* output,\n                                                CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2446,
              16
            ],
            [
              2449,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesAndSkip1SwapOptimized",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack3BytesAndSkip1SwapSwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                                CMSREGISTER cmsUInt16Number wOut[],\n                                                CMSREGISTER cmsUInt8Number* output,\n                                                CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2464,
              16
            ],
            [
              2467,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesAndSkip1SwapSwapFirst",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack3BytesAndSkip1SwapSwapFirstOptimized(CMSREGISTER _cmsTRANSFORM* info,\n                                                         CMSREGISTER cmsUInt16Number wOut[],\n                                                         CMSREGISTER cmsUInt8Number* output,\n                                                         CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2481,
              16
            ],
            [
              2484,
              92
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3BytesAndSkip1SwapSwapFirstOptimized",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack3WordsAndSkip1(CMSREGISTER _cmsTRANSFORM* info,\n                                   CMSREGISTER cmsUInt16Number wOut[],\n                                   CMSREGISTER cmsUInt8Number* output,\n                                   CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2498,
              16
            ],
            [
              2501,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3WordsAndSkip1",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack3WordsAndSkip1Swap(CMSREGISTER _cmsTRANSFORM* info,\n                                       CMSREGISTER cmsUInt16Number wOut[],\n                                       CMSREGISTER cmsUInt8Number* output,\n                                       CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2518,
              16
            ],
            [
              2521,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3WordsAndSkip1Swap",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack3WordsAndSkip1SwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                            CMSREGISTER cmsUInt16Number wOut[],\n                                            CMSREGISTER cmsUInt8Number* output,\n                                            CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2539,
              16
            ],
            [
              2542,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3WordsAndSkip1SwapFirst",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack3WordsAndSkip1SwapSwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                                CMSREGISTER cmsUInt16Number wOut[],\n                                                CMSREGISTER cmsUInt8Number* output,\n                                                CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2560,
              16
            ],
            [
              2563,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack3WordsAndSkip1SwapSwapFirst",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack1Byte(CMSREGISTER _cmsTRANSFORM* info,\n                          CMSREGISTER cmsUInt16Number wOut[],\n                          CMSREGISTER cmsUInt8Number* output,\n                          CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2582,
              16
            ],
            [
              2585,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack1Byte",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack1ByteReversed(CMSREGISTER _cmsTRANSFORM* info,\n                                  CMSREGISTER cmsUInt16Number wOut[],\n                                  CMSREGISTER cmsUInt8Number* output,\n                                  CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2597,
              16
            ],
            [
              2600,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack1ByteReversed",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack1ByteSkip1(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wOut[],\n                               CMSREGISTER cmsUInt8Number* output,\n                               CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2612,
              16
            ],
            [
              2615,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack1ByteSkip1",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack1ByteSkip1SwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                        CMSREGISTER cmsUInt16Number wOut[],\n                                        CMSREGISTER cmsUInt8Number* output,\n                                        CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2628,
              16
            ],
            [
              2631,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack1ByteSkip1SwapFirst",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack1Word(CMSREGISTER _cmsTRANSFORM* info,\n                          CMSREGISTER cmsUInt16Number wOut[],\n                          CMSREGISTER cmsUInt8Number* output,\n                          CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2643,
              16
            ],
            [
              2646,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack1Word",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack1WordReversed(CMSREGISTER _cmsTRANSFORM* info,\n                                  CMSREGISTER cmsUInt16Number wOut[],\n                                  CMSREGISTER cmsUInt8Number* output,\n                                  CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2659,
              16
            ],
            [
              2662,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack1WordReversed",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack1WordBigEndian(CMSREGISTER _cmsTRANSFORM* info,\n                                   CMSREGISTER cmsUInt16Number wOut[],\n                                   CMSREGISTER cmsUInt8Number* output,\n                                   CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2674,
              16
            ],
            [
              2677,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack1WordBigEndian",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack1WordSkip1(CMSREGISTER _cmsTRANSFORM* info,\n                               CMSREGISTER cmsUInt16Number wOut[],\n                               CMSREGISTER cmsUInt8Number* output,\n                               CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2690,
              16
            ],
            [
              2693,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack1WordSkip1",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Pack1WordSkip1SwapFirst(CMSREGISTER _cmsTRANSFORM* info,\n                                        CMSREGISTER cmsUInt16Number wOut[],\n                                        CMSREGISTER cmsUInt8Number* output,\n                                        CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2705,
              16
            ],
            [
              2708,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Pack1WordSkip1SwapFirst",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackLabDoubleFrom16(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wOut[],\n                                    CMSREGISTER cmsUInt8Number* output,\n                                    CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2723,
              16
            ],
            [
              2726,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackLabDoubleFrom16",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackLabFloatFrom16(CMSREGISTER _cmsTRANSFORM* info,\n                                    CMSREGISTER cmsUInt16Number wOut[],\n                                    CMSREGISTER cmsUInt8Number* output,\n                                    CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2750,
              16
            ],
            [
              2753,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackLabFloatFrom16",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackXYZDoubleFrom16(CMSREGISTER _cmsTRANSFORM* Info,\n                                    CMSREGISTER cmsUInt16Number wOut[],\n                                    CMSREGISTER cmsUInt8Number* output,\n                                    CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2781,
              16
            ],
            [
              2784,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackXYZDoubleFrom16",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackXYZFloatFrom16(CMSREGISTER _cmsTRANSFORM* Info,\n                                   CMSREGISTER cmsUInt16Number wOut[],\n                                   CMSREGISTER cmsUInt8Number* output,\n                                   CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2810,
              16
            ],
            [
              2813,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackXYZFloatFrom16",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackDoubleFrom16(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wOut[],\n                                CMSREGISTER cmsUInt8Number* output,\n                                CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2845,
              16
            ],
            [
              2848,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackDoubleFrom16",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackFloatFrom16(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wOut[],\n                                CMSREGISTER cmsUInt8Number* output,\n                                CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2898,
              16
            ],
            [
              2901,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackFloatFrom16",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackBytesFromFloat(_cmsTRANSFORM* info,\n                                    cmsFloat32Number wOut[],\n                                    cmsUInt8Number* output,\n                                    cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              2953,
              16
            ],
            [
              2956,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackBytesFromFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackWordsFromFloat(_cmsTRANSFORM* info,\n                                    cmsFloat32Number wOut[],\n                                    cmsUInt8Number* output,\n                                    cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              3004,
              16
            ],
            [
              3007,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackWordsFromFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackFloatsFromFloat(_cmsTRANSFORM* info,\n                                    cmsFloat32Number wOut[],\n                                    cmsUInt8Number* output,\n                                    cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              3056,
              16
            ],
            [
              3059,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackFloatsFromFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackDoublesFromFloat(_cmsTRANSFORM* info,\n                                    cmsFloat32Number wOut[],\n                                    cmsUInt8Number* output,\n                                    cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              3107,
              16
            ],
            [
              3110,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackDoublesFromFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackLabFloatFromFloat(_cmsTRANSFORM* Info,\n                                      cmsFloat32Number wOut[],\n                                      cmsUInt8Number* output,\n                                      cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              3159,
              16
            ],
            [
              3162,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackLabFloatFromFloat",
            "parameters": {
              "Info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackLabDoubleFromFloat(_cmsTRANSFORM* Info,\n                                       cmsFloat32Number wOut[],\n                                       cmsUInt8Number* output,\n                                       cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              3189,
              16
            ],
            [
              3192,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackLabDoubleFromFloat",
            "parameters": {
              "Info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackEncodedBytesLabV2FromFloat(_cmsTRANSFORM* Info,\n                                           cmsFloat32Number wOut[],\n                                           cmsUInt8Number* output,\n                                           cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              3219,
              16
            ],
            [
              3222,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackEncodedBytesLabV2FromFloat",
            "parameters": {
              "Info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackEncodedWordsLabV2FromFloat(_cmsTRANSFORM* Info,\n                                           cmsFloat32Number wOut[],\n                                           cmsUInt8Number* output,\n                                           cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              3254,
              16
            ],
            [
              3257,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackEncodedWordsLabV2FromFloat",
            "parameters": {
              "Info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackXYZFloatFromFloat(_cmsTRANSFORM* Info,\n                                      cmsFloat32Number wOut[],\n                                      cmsUInt8Number* output,\n                                      cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              3291,
              16
            ],
            [
              3294,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackXYZFloatFromFloat",
            "parameters": {
              "Info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackXYZDoubleFromFloat(_cmsTRANSFORM* Info,\n                                       cmsFloat32Number wOut[],\n                                       cmsUInt8Number* output,\n                                       cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              3321,
              16
            ],
            [
              3324,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackXYZDoubleFromFloat",
            "parameters": {
              "Info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollHalfTo16(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wIn[],\n                                CMSREGISTER cmsUInt8Number* accum,\n                                CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              3357,
              16
            ],
            [
              3360,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollHalfTo16",
            "parameters": {
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UnrollHalfToFloat(_cmsTRANSFORM* info,\n                                    cmsFloat32Number wIn[],\n                                    cmsUInt8Number* accum,\n                                    cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              3411,
              16
            ],
            [
              3414,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnrollHalfToFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wIn": "cmsFloat32Number",
              "accum": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackHalfFrom16(CMSREGISTER _cmsTRANSFORM* info,\n                                CMSREGISTER cmsUInt16Number wOut[],\n                                CMSREGISTER cmsUInt8Number* output,\n                                CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              3463,
              16
            ],
            [
              3466,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackHalfFrom16",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PackHalfFromFloat(_cmsTRANSFORM* info,\n                                    cmsFloat32Number wOut[],\n                                    cmsUInt8Number* output,\n                                    cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              3516,
              16
            ],
            [
              3519,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackHalfFromFloat",
            "parameters": {
              "info": "_cmsTRANSFORM",
              "wOut": "cmsFloat32Number",
              "output": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n    cmsUInt32Number Type;\n    cmsUInt32Number Mask;\n    cmsFormatter16  Frm;\n\n} cmsFormatters16;",
          {
            "Type": "cmsUInt32Number",
            "Mask": "cmsUInt32Number",
            "Frm": "cmsFormatter16"
          },
          "cmsFormatters16",
          [
            58,
            0
          ],
          [
            63,
            18
          ]
        ],
        [
          "typedef struct {\n    cmsUInt32Number    Type;\n    cmsUInt32Number    Mask;\n    cmsFormatterFloat  Frm;\n\n} cmsFormattersFloat;",
          {
            "Type": "cmsUInt32Number",
            "Mask": "cmsUInt32Number",
            "Frm": "cmsFormatterFloat"
          },
          "cmsFormattersFloat",
          [
            65,
            0
          ],
          [
            70,
            21
          ]
        ],
        [
          "typedef struct _cms_formatters_factory_list {\n\n    cmsFormatterFactory Factory;\n    struct _cms_formatters_factory_list *Next;\n\n} cmsFormattersFactoryList;",
          {
            "Factory": "cmsFormatterFactory",
            "*Next": "struct _cms_formatters_factory_list"
          },
          "cmsFormattersFactoryList",
          [
            3892,
            0
          ],
          [
            3897,
            27
          ]
        ],
        [
          "typedef struct {\n    cmsUInt32Number Type;\n    cmsUInt32Number Mask;\n    cmsFormatter16  Frm;\n\n} cmsFormatters16;",
          {
            "Type": "cmsUInt32Number",
            "Mask": "cmsUInt32Number",
            "Frm": "cmsFormatter16"
          },
          "cmsFormatters16",
          [
            58,
            0
          ],
          [
            63,
            18
          ]
        ],
        [
          "typedef struct {\n    cmsUInt32Number    Type;\n    cmsUInt32Number    Mask;\n    cmsFormatterFloat  Frm;\n\n} cmsFormattersFloat;",
          {
            "Type": "cmsUInt32Number",
            "Mask": "cmsUInt32Number",
            "Frm": "cmsFormatterFloat"
          },
          "cmsFormattersFloat",
          [
            65,
            0
          ],
          [
            70,
            21
          ]
        ],
        [
          "typedef struct _cms_formatters_factory_list {\n\n    cmsFormatterFactory Factory;\n    struct _cms_formatters_factory_list *Next;\n\n} cmsFormattersFactoryList;",
          {
            "Factory": "cmsFormatterFactory",
            "*Next": "struct _cms_formatters_factory_list"
          },
          "cmsFormattersFactoryList",
          [
            3892,
            0
          ],
          [
            3897,
            27
          ]
        ],
        [
          "struct _cms_formatters_factory_list",
          {},
          "",
          [
            3895,
            4
          ],
          [
            3895,
            39
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            3904,
            29
          ],
          [
            3904,
            54
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            3905,
            53
          ],
          [
            3905,
            78
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            3939,
            36
          ],
          [
            3939,
            61
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            3940,
            42
          ],
          [
            3940,
            67
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmsio0.c": {
      "fn_def_list": [
        {
          "fn_code": "static\ncmsUInt32Number NULLRead(cmsIOHANDLER* iohandler, void *Buffer, cmsUInt32Number size, cmsUInt32Number count)\n{\n    FILENULL* ResData = (FILENULL*) iohandler ->stream;\n\n    cmsUInt32Number len = size * count;\n    ResData -> Pointer += len;\n    return count;\n\n    cmsUNUSED_PARAMETER(Buffer);\n}",
          "fn_code_pos": [
            [
              46,
              0
            ],
            [
              56,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NULLRead",
            "parameters": {
              "iohandler": "cmsIOHANDLER",
              "Buffer": "void",
              "size": "cmsUInt32Number",
              "count": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsBool  NULLSeek(cmsIOHANDLER* iohandler, cmsUInt32Number offset)\n{\n    FILENULL* ResData = (FILENULL*) iohandler ->stream;\n\n    ResData ->Pointer = offset;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NULLSeek",
            "parameters": {
              "iohandler": "cmsIOHANDLER",
              "offset": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number NULLTell(cmsIOHANDLER* iohandler)\n{\n    FILENULL* ResData = (FILENULL*) iohandler ->stream;\n    return ResData -> Pointer;\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              72,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NULLTell",
            "parameters": {
              "iohandler": "cmsIOHANDLER"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsBool  NULLWrite(cmsIOHANDLER* iohandler, cmsUInt32Number size, const void *Ptr)\n{\n    FILENULL* ResData = (FILENULL*) iohandler ->stream;\n\n    ResData ->Pointer += size;\n    if (ResData ->Pointer > iohandler->UsedSpace)\n        iohandler->UsedSpace = ResData ->Pointer;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(Ptr);\n}",
          "fn_code_pos": [
            [
              74,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NULLWrite",
            "parameters": {
              "iohandler": "cmsIOHANDLER",
              "size": "cmsUInt32Number",
              "Ptr": "void"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool  NULLClose(cmsIOHANDLER* iohandler)\n{\n    FILENULL* ResData = (FILENULL*) iohandler ->stream;\n\n    _cmsFree(iohandler ->ContextID, ResData);\n    _cmsFree(iohandler ->ContextID, iohandler);\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              88,
              0
            ],
            [
              96,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NULLClose",
            "parameters": {
              "iohandler": "cmsIOHANDLER"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number MemoryRead(struct _cms_io_handler* iohandler, void *Buffer, cmsUInt32Number size, cmsUInt32Number count)\n{\n    FILEMEM* ResData = (FILEMEM*) iohandler ->stream;\n    cmsUInt8Number* Ptr;\n    cmsUInt32Number len = size * count;\n\n    if (ResData -> Pointer + len > ResData -> Size){\n\n        len = (ResData -> Size - ResData -> Pointer);\n        cmsSignalError(iohandler ->ContextID, cmsERROR_READ, \"Read from memory error. Got %d bytes, block should be of %d bytes\", len, count * size);\n        return 0;\n    }\n\n    Ptr  = ResData -> Block;\n    Ptr += ResData -> Pointer;\n    memmove(Buffer, Ptr, len);\n    ResData -> Pointer += len;\n\n    return count;\n}",
          "fn_code_pos": [
            [
              145,
              0
            ],
            [
              165,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MemoryRead",
            "parameters": {
              "iohandler": "struct _cms_io_handler",
              "Buffer": "void",
              "size": "cmsUInt32Number",
              "count": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsBool  MemorySeek(struct _cms_io_handler* iohandler, cmsUInt32Number offset)\n{\n    FILEMEM* ResData = (FILEMEM*) iohandler ->stream;\n\n    if (offset > ResData ->Size) {\n        cmsSignalError(iohandler ->ContextID, cmsERROR_SEEK,  \"Too few data; probably corrupted profile\");\n        return FALSE;\n    }\n\n    ResData ->Pointer = offset;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              168,
              0
            ],
            [
              180,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MemorySeek",
            "parameters": {
              "iohandler": "struct _cms_io_handler",
              "offset": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number MemoryTell(struct _cms_io_handler* iohandler)\n{\n    FILEMEM* ResData = (FILEMEM*) iohandler ->stream;\n\n    if (ResData == NULL) return 0;\n    return ResData -> Pointer;\n}",
          "fn_code_pos": [
            [
              183,
              0
            ],
            [
              190,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MemoryTell",
            "parameters": {
              "iohandler": "struct _cms_io_handler"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsBool MemoryWrite(struct _cms_io_handler* iohandler, cmsUInt32Number size, const void *Ptr)\n{\n    FILEMEM* ResData = (FILEMEM*) iohandler ->stream;\n\n    if (ResData == NULL) return FALSE; // Housekeeping\n\n    // Check for available space. Clip.\n    if (ResData->Pointer + size > ResData->Size) {\n        size = ResData ->Size - ResData->Pointer;\n    }\n      \n    if (size == 0) return TRUE;     // Write zero bytes is ok, but does nothing\n\n    memmove(ResData ->Block + ResData ->Pointer, Ptr, size);\n    ResData ->Pointer += size;\n\n    if (ResData ->Pointer > iohandler->UsedSpace)\n        iohandler->UsedSpace = ResData ->Pointer;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              194,
              0
            ],
            [
              215,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MemoryWrite",
            "parameters": {
              "iohandler": "struct _cms_io_handler",
              "size": "cmsUInt32Number",
              "Ptr": "void"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool  MemoryClose(struct _cms_io_handler* iohandler)\n{\n    FILEMEM* ResData = (FILEMEM*) iohandler ->stream;\n\n    if (ResData ->FreeBlockOnClose) {\n\n        if (ResData ->Block) _cmsFree(iohandler ->ContextID, ResData ->Block);\n    }\n\n    _cmsFree(iohandler ->ContextID, ResData);\n    _cmsFree(iohandler ->ContextID, iohandler);\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              218,
              0
            ],
            [
              232,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MemoryClose",
            "parameters": {
              "iohandler": "struct _cms_io_handler"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number FileRead(cmsIOHANDLER* iohandler, void *Buffer, cmsUInt32Number size, cmsUInt32Number count)\n{\n    cmsUInt32Number nReaded = (cmsUInt32Number) fread(Buffer, size, count, (FILE*) iohandler->stream);\n\n    if (nReaded != count) {\n            cmsSignalError(iohandler ->ContextID, cmsERROR_FILE, \"Read error. Got %d bytes, block should be of %d bytes\", nReaded * size, count * size);\n            return 0;\n    }\n\n    return nReaded;\n}",
          "fn_code_pos": [
            [
              318,
              0
            ],
            [
              329,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FileRead",
            "parameters": {
              "iohandler": "cmsIOHANDLER",
              "Buffer": "void",
              "size": "cmsUInt32Number",
              "count": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsBool  FileSeek(cmsIOHANDLER* iohandler, cmsUInt32Number offset)\n{\n    if (fseek((FILE*) iohandler ->stream, (long) offset, SEEK_SET) != 0) {\n\n       cmsSignalError(iohandler ->ContextID, cmsERROR_FILE, \"Seek error; probably corrupted file\");\n       return FALSE;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              332,
              0
            ],
            [
              342,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FileSeek",
            "parameters": {
              "iohandler": "cmsIOHANDLER",
              "offset": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number FileTell(cmsIOHANDLER* iohandler)\n{\n    long t = ftell((FILE*)iohandler ->stream);\n    if (t == -1L) {\n        cmsSignalError(iohandler->ContextID, cmsERROR_FILE, \"Tell error; probably corrupted file\");\n        return 0;\n    }\n\n    return (cmsUInt32Number)t;\n}",
          "fn_code_pos": [
            [
              345,
              0
            ],
            [
              355,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FileTell",
            "parameters": {
              "iohandler": "cmsIOHANDLER"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsBool  FileWrite(cmsIOHANDLER* iohandler, cmsUInt32Number size, const void* Buffer)\n{\n    if (size == 0) return TRUE;  // We allow to write 0 bytes, but nothing is written\n\n    iohandler->UsedSpace += size;\n    return (fwrite(Buffer, size, 1, (FILE*)iohandler->stream) == 1);\n}",
          "fn_code_pos": [
            [
              358,
              0
            ],
            [
              365,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FileWrite",
            "parameters": {
              "iohandler": "cmsIOHANDLER",
              "size": "cmsUInt32Number",
              "Buffer": "void"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool  FileClose(cmsIOHANDLER* iohandler)\n{\n    if (fclose((FILE*) iohandler ->stream) != 0) return FALSE;\n    _cmsFree(iohandler ->ContextID, iohandler);\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              368,
              0
            ],
            [
              374,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FileClose",
            "parameters": {
              "iohandler": "cmsIOHANDLER"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsCloseIOhandler(cmsIOHANDLER* io)\n{\n    return io -> Close(io);\n}",
          "fn_code_pos": [
            [
              509,
              0
            ],
            [
              512,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCloseIOhandler",
            "parameters": {
              "io": "cmsIOHANDLER"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsCreateProfilePlaceholder(cmsContext ContextID)\n{\n    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) _cmsMallocZero(ContextID, sizeof(_cmsICCPROFILE));\n    if (Icc == NULL) return NULL;\n\n    Icc ->ContextID = ContextID;\n\n    // Set it to empty\n    Icc -> TagCount   = 0;\n\n    // Set default version\n    Icc ->Version =  0x02100000;\n\n    // Set default CMM (that's me!)\n    Icc ->CMM = lcmsSignature;\n\n    // Set default creator\n    // Created by LittleCMS (that's me!)\n    Icc ->creator = lcmsSignature;\n\n    // Set default platform\n#ifdef CMS_IS_WINDOWS_\n    Icc ->platform = cmsSigMicrosoft;\n#else\n    Icc ->platform = cmsSigMacintosh;\n#endif\n\n    // Set default device class\n    Icc->DeviceClass = cmsSigDisplayClass;\n\n    // Set creation date/time\n    if (!_cmsGetTime(&Icc->Created))\n        goto Error;\n\n    // Create a mutex if the user provided proper plugin. NULL otherwise\n    Icc ->UsrMutex = _cmsCreateMutex(ContextID);\n\n    // Return the handle\n    return (cmsHPROFILE) Icc;\n\nError:\n    _cmsFree(ContextID, Icc);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              525,
              0
            ],
            [
              568,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateProfilePlaceholder",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsContext CMSEXPORT cmsGetProfileContextID(cmsHPROFILE hProfile)\n{\n     _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;\n\n    if (Icc == NULL) return NULL;\n    return Icc -> ContextID;\n}",
          "fn_code_pos": [
            [
              570,
              0
            ],
            [
              576,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetProfileContextID",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsContext"
          }
        },
        {
          "fn_code": "cmsInt32Number CMSEXPORT cmsGetTagCount(cmsHPROFILE hProfile)\n{\n    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;\n    if (Icc == NULL) return -1;\n\n    return  (cmsInt32Number) Icc->TagCount;\n}",
          "fn_code_pos": [
            [
              580,
              0
            ],
            [
              586,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetTagCount",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "cmsTagSignature CMSEXPORT cmsGetTagSignature(cmsHPROFILE hProfile, cmsUInt32Number n)\n{\n    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;\n\n    if (n > Icc->TagCount) return (cmsTagSignature) 0;  // Mark as not available\n    if (n >= MAX_TABLE_TAG) return (cmsTagSignature) 0; // As double check\n\n    return Icc ->TagNames[n];\n}",
          "fn_code_pos": [
            [
              589,
              0
            ],
            [
              597,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetTagSignature",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "n": "cmsUInt32Number"
            },
            "return_type": "cmsTagSignature"
          }
        },
        {
          "fn_code": "static\nint SearchOneTag(_cmsICCPROFILE* Profile, cmsTagSignature sig)\n{\n    int i;\n\n    for (i=0; i < (int) Profile -> TagCount; i++) {\n\n        if (sig == Profile -> TagNames[i])\n            return i;\n    }\n\n    return -1;\n}",
          "fn_code_pos": [
            [
              600,
              0
            ],
            [
              612,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SearchOneTag",
            "parameters": {
              "Profile": "_cmsICCPROFILE",
              "sig": "cmsTagSignature"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int _cmsSearchTag(_cmsICCPROFILE* Icc, cmsTagSignature sig, cmsBool lFollowLinks)\n{\n    int n;\n    cmsTagSignature LinkedSig;\n\n    do {\n\n        // Search for given tag in ICC profile directory\n        n = SearchOneTag(Icc, sig);\n        if (n < 0)\n            return -1;        // Not found\n\n        if (!lFollowLinks)\n            return n;         // Found, don't follow links\n\n        // Is this a linked tag?\n        LinkedSig = Icc ->TagLinked[n];\n\n        // Yes, follow link\n        if (LinkedSig != (cmsTagSignature) 0) {\n            sig = LinkedSig;\n        }\n\n    } while (LinkedSig != (cmsTagSignature) 0);\n\n    return n;\n}",
          "fn_code_pos": [
            [
              616,
              0
            ],
            [
              642,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsSearchTag",
            "parameters": {
              "Icc": "_cmsICCPROFILE",
              "sig": "cmsTagSignature",
              "lFollowLinks": "cmsBool"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nvoid _cmsDeleteTagByPos(_cmsICCPROFILE* Icc, int i)\n{\n    _cmsAssert(Icc != NULL);\n    _cmsAssert(i >= 0);\n\n   \n    if (Icc -> TagPtrs[i] != NULL) {\n\n        // Free previous version\n        if (Icc ->TagSaveAsRaw[i]) {\n            _cmsFree(Icc ->ContextID, Icc ->TagPtrs[i]);\n        }\n        else {\n            cmsTagTypeHandler* TypeHandler = Icc ->TagTypeHandlers[i];\n\n            if (TypeHandler != NULL) {\n\n                cmsTagTypeHandler LocalTypeHandler = *TypeHandler;\n                LocalTypeHandler.ContextID = Icc ->ContextID;              // As an additional parameter\n                LocalTypeHandler.ICCVersion = Icc ->Version;\n                LocalTypeHandler.FreePtr(&LocalTypeHandler, Icc -> TagPtrs[i]);\n                Icc ->TagPtrs[i] = NULL;\n            }\n        }\n\n    } \n}",
          "fn_code_pos": [
            [
              646,
              0
            ],
            [
              673,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsDeleteTagByPos",
            "parameters": {
              "Icc": "_cmsICCPROFILE",
              "i": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool _cmsNewTag(_cmsICCPROFILE* Icc, cmsTagSignature sig, int* NewPos)\n{\n    int i;\n\n    // Search for the tag\n    i = _cmsSearchTag(Icc, sig, FALSE);\n    if (i >= 0) {\n\n        // Already exists? delete it\n        _cmsDeleteTagByPos(Icc, i);\n        *NewPos = i;\n    }\n    else  {\n\n        // No, make a new one\n        if (Icc -> TagCount >= MAX_TABLE_TAG) {\n            cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, \"Too many tags (%d)\", MAX_TABLE_TAG);\n            return FALSE;\n        }\n\n        *NewPos = (int) Icc ->TagCount;\n        Icc -> TagCount++;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              677,
              0
            ],
            [
              703,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsNewTag",
            "parameters": {
              "Icc": "_cmsICCPROFILE",
              "sig": "cmsTagSignature",
              "NewPos": "int"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsIsTag(cmsHPROFILE hProfile, cmsTagSignature sig)\n{\n       _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) (void*) hProfile;\n       return _cmsSearchTag(Icc, sig, FALSE) >= 0;\n}",
          "fn_code_pos": [
            [
              707,
              0
            ],
            [
              711,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIsTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsTagSignature"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool CompatibleTypes(const cmsTagDescriptor* desc1, const cmsTagDescriptor* desc2)\n{\n    cmsUInt32Number i;\n\n    if (desc1 == NULL || desc2 == NULL) return FALSE;\n\n    if (desc1->nSupportedTypes != desc2->nSupportedTypes) return FALSE;\n    if (desc1->ElemCount != desc2->ElemCount) return FALSE;\n\n    for (i = 0; i < desc1->nSupportedTypes; i++)\n    {\n        if (desc1->SupportedTypes[i] != desc2->SupportedTypes[i]) return FALSE;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              716,
              0
            ],
            [
              732,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CompatibleTypes",
            "parameters": {
              "desc1": "cmsTagDescriptor",
              "desc2": "cmsTagDescriptor"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static \ncmsUInt32Number _validatedVersion(cmsUInt32Number DWord)\n{\n    cmsUInt8Number* pByte = (cmsUInt8Number*) &DWord;\n    cmsUInt8Number temp1;\n    cmsUInt8Number temp2;\n\n    if (*pByte > 0x09) *pByte = (cmsUInt8Number) 0x09;\n    temp1 = (cmsUInt8Number) (*(pByte+1) & 0xf0);\n    temp2 = (cmsUInt8Number) (*(pByte+1) & 0x0f);\n    if (temp1 > 0x90U) temp1 = 0x90U;\n    if (temp2 > 0x09U) temp2 = 0x09U;\n    *(pByte+1) = (cmsUInt8Number)(temp1 | temp2);\n    *(pByte+2) = (cmsUInt8Number)0;\n    *(pByte+3) = (cmsUInt8Number)0;\n\n    return DWord;\n}",
          "fn_code_pos": [
            [
              740,
              0
            ],
            [
              757,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_validatedVersion",
            "parameters": {
              "DWord": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static \ncmsBool validDeviceClass(cmsProfileClassSignature cl)\n{\n    if ((int)cl == 0) return TRUE; // We allow zero because older lcms versions defaulted to that.\n\n    switch (cl)\n    {    \n    case cmsSigInputClass:\n    case cmsSigDisplayClass:\n    case cmsSigOutputClass:\n    case cmsSigLinkClass:\n    case cmsSigAbstractClass:\n    case cmsSigColorSpaceClass:\n    case cmsSigNamedColorClass:\n        return TRUE;\n\n    default:\n        return FALSE;\n    }\n\n}",
          "fn_code_pos": [
            [
              760,
              0
            ],
            [
              780,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "validDeviceClass",
            "parameters": {
              "cl": "cmsProfileClassSignature"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool _cmsReadHeader(_cmsICCPROFILE* Icc)\n{\n    cmsTagEntry Tag;\n    cmsICCHeader Header;\n    cmsUInt32Number i, j;\n    cmsUInt32Number HeaderSize;\n    cmsIOHANDLER* io = Icc ->IOhandler;\n    cmsUInt32Number TagCount;\n\n\n    // Read the header\n    if (io -> Read(io, &Header, sizeof(cmsICCHeader), 1) != 1) {\n        return FALSE;\n    }\n\n    // Validate file as an ICC profile\n    if (_cmsAdjustEndianess32(Header.magic) != cmsMagicNumber) {\n        cmsSignalError(Icc ->ContextID, cmsERROR_BAD_SIGNATURE, \"not an ICC profile, invalid signature\");\n        return FALSE;\n    }\n\n    // Adjust endianness of the used parameters\n    Icc -> CMM             = _cmsAdjustEndianess32(Header.cmmId);\n    Icc -> DeviceClass     = (cmsProfileClassSignature) _cmsAdjustEndianess32(Header.deviceClass);\n    Icc -> ColorSpace      = (cmsColorSpaceSignature)   _cmsAdjustEndianess32(Header.colorSpace);\n    Icc -> PCS             = (cmsColorSpaceSignature)   _cmsAdjustEndianess32(Header.pcs);\n   \n    Icc -> RenderingIntent = _cmsAdjustEndianess32(Header.renderingIntent);\n    Icc -> platform        = (cmsPlatformSignature)_cmsAdjustEndianess32(Header.platform);\n    Icc -> flags           = _cmsAdjustEndianess32(Header.flags);\n    Icc -> manufacturer    = _cmsAdjustEndianess32(Header.manufacturer);\n    Icc -> model           = _cmsAdjustEndianess32(Header.model);\n    Icc -> creator         = _cmsAdjustEndianess32(Header.creator);\n\n    _cmsAdjustEndianess64(&Icc -> attributes, &Header.attributes);\n    Icc -> Version         = _cmsAdjustEndianess32(_validatedVersion(Header.version));\n\n    if (Icc->Version > 0x5000000) {\n        cmsSignalError(Icc->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported profile version '0x%x'\", Icc->Version);\n        return FALSE;\n    }\n\n    if (!validDeviceClass(Icc->DeviceClass)) {\n        cmsSignalError(Icc->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported device class '0x%x'\", Icc->DeviceClass);\n        return FALSE;\n    }\n\n    // Get size as reported in header\n    HeaderSize = _cmsAdjustEndianess32(Header.size);\n\n    // Make sure HeaderSize is lower than profile size\n    if (HeaderSize >= Icc ->IOhandler ->ReportedSize)\n            HeaderSize = Icc ->IOhandler ->ReportedSize;\n\n\n    // Get creation date/time\n    _cmsDecodeDateTimeNumber(&Header.date, &Icc ->Created);\n\n    // The profile ID are 32 raw bytes\n    memmove(Icc ->ProfileID.ID32, Header.profileID.ID32, 16);\n\n\n    // Read tag directory\n    if (!_cmsReadUInt32Number(io, &TagCount)) return FALSE;\n    if (TagCount > MAX_TABLE_TAG) {\n\n        cmsSignalError(Icc ->ContextID, cmsERROR_RANGE, \"Too many tags (%d)\", TagCount);\n        return FALSE;\n    }\n\n\n    // Read tag directory\n    Icc -> TagCount = 0;\n    for (i=0; i < TagCount; i++) {\n\n        if (!_cmsReadUInt32Number(io, (cmsUInt32Number *) &Tag.sig)) return FALSE;\n        if (!_cmsReadUInt32Number(io, &Tag.offset)) return FALSE;\n        if (!_cmsReadUInt32Number(io, &Tag.size)) return FALSE;\n\n        // Perform some sanity check. Offset + size should fall inside file.\n        if (Tag.size == 0 || Tag.offset == 0) continue;\n        if (Tag.offset + Tag.size > HeaderSize ||\n            Tag.offset + Tag.size < Tag.offset)\n                  continue;\n\n        Icc -> TagNames[Icc ->TagCount]   = Tag.sig;\n        Icc -> TagOffsets[Icc ->TagCount] = Tag.offset;\n        Icc -> TagSizes[Icc ->TagCount]   = Tag.size;\n\n       // Search for links\n        for (j=0; j < Icc ->TagCount; j++) {\n           \n            if ((Icc ->TagOffsets[j] == Tag.offset) &&\n                (Icc ->TagSizes[j]   == Tag.size)) {\n\n                // Check types. \n                if (CompatibleTypes(_cmsGetTagDescriptor(Icc->ContextID, Icc->TagNames[j]),\n                                    _cmsGetTagDescriptor(Icc->ContextID, Tag.sig))) {\n\n                    Icc->TagLinked[Icc->TagCount] = Icc->TagNames[j];\n                }\n            }\n\n        }\n\n        Icc ->TagCount++;\n    }\n\n\n    for (i = 0; i < Icc->TagCount; i++) {\n        for (j = 0; j < Icc->TagCount; j++) {\n\n            // Tags cannot be duplicate\n            if ((i != j) && (Icc->TagNames[i] == Icc->TagNames[j])) {\n                cmsSignalError(Icc->ContextID, cmsERROR_RANGE, \"Duplicate tag found\");\n                return FALSE;\n            }\n\n        }\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              783,
              0
            ],
            [
              905,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadHeader",
            "parameters": {
              "Icc": "_cmsICCPROFILE"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool _cmsWriteHeader(_cmsICCPROFILE* Icc, cmsUInt32Number UsedSpace)\n{\n    cmsICCHeader Header;\n    cmsUInt32Number i;\n    cmsTagEntry Tag;\n    cmsUInt32Number Count;\n\n    Header.size        = _cmsAdjustEndianess32(UsedSpace);\n    Header.cmmId       = _cmsAdjustEndianess32(Icc ->CMM);\n    Header.version     = _cmsAdjustEndianess32(Icc ->Version);\n\n    Header.deviceClass = (cmsProfileClassSignature) _cmsAdjustEndianess32(Icc -> DeviceClass);\n    Header.colorSpace  = (cmsColorSpaceSignature) _cmsAdjustEndianess32(Icc -> ColorSpace);\n    Header.pcs         = (cmsColorSpaceSignature) _cmsAdjustEndianess32(Icc -> PCS);\n\n    //   NOTE: in v4 Timestamp must be in UTC rather than in local time\n    _cmsEncodeDateTimeNumber(&Header.date, &Icc ->Created);\n\n    Header.magic       = _cmsAdjustEndianess32(cmsMagicNumber);\n\n    Header.platform    = (cmsPlatformSignature) _cmsAdjustEndianess32(Icc -> platform);\n\n    Header.flags        = _cmsAdjustEndianess32(Icc -> flags);\n    Header.manufacturer = _cmsAdjustEndianess32(Icc -> manufacturer);\n    Header.model        = _cmsAdjustEndianess32(Icc -> model);\n\n    _cmsAdjustEndianess64(&Header.attributes, &Icc -> attributes);\n\n    // Rendering intent in the header (for embedded profiles)\n    Header.renderingIntent = _cmsAdjustEndianess32(Icc -> RenderingIntent);\n\n    // Illuminant is always D50\n    Header.illuminant.X = (cmsS15Fixed16Number) _cmsAdjustEndianess32((cmsUInt32Number) _cmsDoubleTo15Fixed16(cmsD50_XYZ()->X));\n    Header.illuminant.Y = (cmsS15Fixed16Number) _cmsAdjustEndianess32((cmsUInt32Number) _cmsDoubleTo15Fixed16(cmsD50_XYZ()->Y));\n    Header.illuminant.Z = (cmsS15Fixed16Number) _cmsAdjustEndianess32((cmsUInt32Number) _cmsDoubleTo15Fixed16(cmsD50_XYZ()->Z));\n\n    Header.creator      = _cmsAdjustEndianess32(Icc ->creator);\n\n    memset(&Header.reserved, 0, sizeof(Header.reserved));\n\n    // Set profile ID. Endianness is always big endian\n    memmove(&Header.profileID, &Icc ->ProfileID, 16);\n\n    // Dump the header\n    if (!Icc -> IOhandler->Write(Icc->IOhandler, sizeof(cmsICCHeader), &Header)) return FALSE;\n\n    // Saves Tag directory\n\n    // Get true count\n    Count = 0;\n    for (i=0;  i < Icc -> TagCount; i++) {\n        if (Icc ->TagNames[i] != (cmsTagSignature) 0)\n            Count++;\n    }\n\n    // Store number of tags\n    if (!_cmsWriteUInt32Number(Icc ->IOhandler, Count)) return FALSE;\n\n    for (i=0; i < Icc -> TagCount; i++) {\n\n        if (Icc ->TagNames[i] == (cmsTagSignature) 0) continue;   // It is just a placeholder\n\n        Tag.sig    = (cmsTagSignature) _cmsAdjustEndianess32((cmsUInt32Number) Icc -> TagNames[i]);\n        Tag.offset = _cmsAdjustEndianess32((cmsUInt32Number) Icc -> TagOffsets[i]);\n        Tag.size   = _cmsAdjustEndianess32((cmsUInt32Number) Icc -> TagSizes[i]);\n\n        if (!Icc ->IOhandler -> Write(Icc-> IOhandler, sizeof(cmsTagEntry), &Tag)) return FALSE;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              908,
              0
            ],
            [
              978,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteHeader",
            "parameters": {
              "Icc": "_cmsICCPROFILE",
              "UsedSpace": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsGetHeaderRenderingIntent(cmsHPROFILE hProfile)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    return Icc -> RenderingIntent;\n}",
          "fn_code_pos": [
            [
              983,
              0
            ],
            [
              987,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetHeaderRenderingIntent",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsSetHeaderRenderingIntent(cmsHPROFILE hProfile, cmsUInt32Number RenderingIntent)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    Icc -> RenderingIntent = RenderingIntent;\n}",
          "fn_code_pos": [
            [
              989,
              0
            ],
            [
              993,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetHeaderRenderingIntent",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "RenderingIntent": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsGetHeaderFlags(cmsHPROFILE hProfile)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    return (cmsUInt32Number) Icc -> flags;\n}",
          "fn_code_pos": [
            [
              995,
              0
            ],
            [
              999,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetHeaderFlags",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsSetHeaderFlags(cmsHPROFILE hProfile, cmsUInt32Number Flags)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    Icc -> flags = (cmsUInt32Number) Flags;\n}",
          "fn_code_pos": [
            [
              1001,
              0
            ],
            [
              1005,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetHeaderFlags",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Flags": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsGetHeaderManufacturer(cmsHPROFILE hProfile)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    return Icc ->manufacturer;\n}",
          "fn_code_pos": [
            [
              1007,
              0
            ],
            [
              1011,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetHeaderManufacturer",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsSetHeaderManufacturer(cmsHPROFILE hProfile, cmsUInt32Number manufacturer)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    Icc -> manufacturer = manufacturer;\n}",
          "fn_code_pos": [
            [
              1013,
              0
            ],
            [
              1017,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetHeaderManufacturer",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "manufacturer": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsGetHeaderCreator(cmsHPROFILE hProfile)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    return Icc ->creator;\n}",
          "fn_code_pos": [
            [
              1019,
              0
            ],
            [
              1023,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetHeaderCreator",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsGetHeaderModel(cmsHPROFILE hProfile)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    return Icc ->model;\n}",
          "fn_code_pos": [
            [
              1025,
              0
            ],
            [
              1029,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetHeaderModel",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsSetHeaderModel(cmsHPROFILE hProfile, cmsUInt32Number model)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    Icc -> model = model;\n}",
          "fn_code_pos": [
            [
              1031,
              0
            ],
            [
              1035,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetHeaderModel",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "model": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsGetHeaderAttributes(cmsHPROFILE hProfile, cmsUInt64Number* Flags)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    memmove(Flags, &Icc -> attributes, sizeof(cmsUInt64Number));\n}",
          "fn_code_pos": [
            [
              1037,
              0
            ],
            [
              1041,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetHeaderAttributes",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Flags": "cmsUInt64Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsSetHeaderAttributes(cmsHPROFILE hProfile, cmsUInt64Number Flags)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    memmove(&Icc -> attributes, &Flags, sizeof(cmsUInt64Number));\n}",
          "fn_code_pos": [
            [
              1043,
              0
            ],
            [
              1047,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetHeaderAttributes",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Flags": "cmsUInt64Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsGetHeaderProfileID(cmsHPROFILE hProfile, cmsUInt8Number* ProfileID)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    memmove(ProfileID, Icc ->ProfileID.ID8, 16);\n}",
          "fn_code_pos": [
            [
              1049,
              0
            ],
            [
              1053,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetHeaderProfileID",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "ProfileID": "cmsUInt8Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsSetHeaderProfileID(cmsHPROFILE hProfile, cmsUInt8Number* ProfileID)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    memmove(&Icc -> ProfileID, ProfileID, 16);\n}",
          "fn_code_pos": [
            [
              1055,
              0
            ],
            [
              1059,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetHeaderProfileID",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "ProfileID": "cmsUInt8Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT cmsGetHeaderCreationDateTime(cmsHPROFILE hProfile, struct tm *Dest)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    memmove(Dest, &Icc ->Created, sizeof(struct tm));\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1061,
              0
            ],
            [
              1066,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetHeaderCreationDateTime",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Dest": "struct tm"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsColorSpaceSignature CMSEXPORT cmsGetPCS(cmsHPROFILE hProfile)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    return Icc -> PCS;\n}",
          "fn_code_pos": [
            [
              1068,
              0
            ],
            [
              1072,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetPCS",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsColorSpaceSignature"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsSetPCS(cmsHPROFILE hProfile, cmsColorSpaceSignature pcs)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    Icc -> PCS = pcs;\n}",
          "fn_code_pos": [
            [
              1074,
              0
            ],
            [
              1078,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetPCS",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "pcs": "cmsColorSpaceSignature"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsColorSpaceSignature CMSEXPORT cmsGetColorSpace(cmsHPROFILE hProfile)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    return Icc -> ColorSpace;\n}",
          "fn_code_pos": [
            [
              1080,
              0
            ],
            [
              1084,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetColorSpace",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsColorSpaceSignature"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsSetColorSpace(cmsHPROFILE hProfile, cmsColorSpaceSignature sig)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    Icc -> ColorSpace = sig;\n}",
          "fn_code_pos": [
            [
              1086,
              0
            ],
            [
              1090,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetColorSpace",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsColorSpaceSignature"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsProfileClassSignature CMSEXPORT cmsGetDeviceClass(cmsHPROFILE hProfile)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    return Icc -> DeviceClass;\n}",
          "fn_code_pos": [
            [
              1092,
              0
            ],
            [
              1096,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetDeviceClass",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsProfileClassSignature"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsSetDeviceClass(cmsHPROFILE hProfile, cmsProfileClassSignature sig)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    Icc -> DeviceClass = sig;\n}",
          "fn_code_pos": [
            [
              1098,
              0
            ],
            [
              1102,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetDeviceClass",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsProfileClassSignature"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsGetEncodedICCversion(cmsHPROFILE hProfile)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    return Icc -> Version;\n}",
          "fn_code_pos": [
            [
              1104,
              0
            ],
            [
              1108,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetEncodedICCversion",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsSetEncodedICCversion(cmsHPROFILE hProfile, cmsUInt32Number Version)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    Icc -> Version = Version;\n}",
          "fn_code_pos": [
            [
              1110,
              0
            ],
            [
              1114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetEncodedICCversion",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Version": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number BaseToBase(cmsUInt32Number in, int BaseIn, int BaseOut)\n{\n    char Buff[100];\n    int i, len;\n    cmsUInt32Number out;\n\n    for (len=0; in > 0 && len < 100; len++) {\n\n        Buff[len] = (char) (in % BaseIn);\n        in /= BaseIn;\n    }\n\n    for (i=len-1, out=0; i >= 0; --i) {\n        out = out * BaseOut + Buff[i];\n    }\n\n    return out;\n}",
          "fn_code_pos": [
            [
              1117,
              0
            ],
            [
              1135,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BaseToBase",
            "parameters": {
              "in": "cmsUInt32Number",
              "BaseIn": "int",
              "BaseOut": "int"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "void  CMSEXPORT cmsSetProfileVersion(cmsHPROFILE hProfile, cmsFloat64Number Version)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n\n    // 4.2 -> 0x4200000\n\n    Icc -> Version = BaseToBase((cmsUInt32Number) floor(Version * 100.0 + 0.5), 10, 16) << 16;\n}",
          "fn_code_pos": [
            [
              1137,
              0
            ],
            [
              1144,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetProfileVersion",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Version": "cmsFloat64Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsFloat64Number CMSEXPORT cmsGetProfileVersion(cmsHPROFILE hProfile)\n{\n    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;\n    cmsUInt32Number n = Icc -> Version >> 16;\n\n    return BaseToBase(n, 16, 10) / 100.0;\n}",
          "fn_code_pos": [
            [
              1146,
              0
            ],
            [
              1152,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetProfileVersion",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsOpenProfileFromIOhandlerTHR(cmsContext ContextID, cmsIOHANDLER* io)\n{\n    _cmsICCPROFILE* NewIcc;\n    cmsHPROFILE hEmpty = cmsCreateProfilePlaceholder(ContextID);\n\n    if (hEmpty == NULL) return NULL;\n\n    NewIcc = (_cmsICCPROFILE*) hEmpty;\n\n    NewIcc ->IOhandler = io;\n    if (!_cmsReadHeader(NewIcc)) goto Error;\n    return hEmpty;\n\nError:\n    cmsCloseProfile(hEmpty);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              1157,
              0
            ],
            [
              1173,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsOpenProfileFromIOhandlerTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "io": "cmsIOHANDLER"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsOpenProfileFromIOhandler2THR(cmsContext ContextID, cmsIOHANDLER* io, cmsBool write)\n{\n    _cmsICCPROFILE* NewIcc;\n    cmsHPROFILE hEmpty = cmsCreateProfilePlaceholder(ContextID);\n\n    if (hEmpty == NULL) return NULL;\n\n    NewIcc = (_cmsICCPROFILE*) hEmpty;\n\n    NewIcc ->IOhandler = io;\n    if (write) {\n\n        NewIcc -> IsWrite = TRUE;\n        return hEmpty;\n    }\n\n    if (!_cmsReadHeader(NewIcc)) goto Error;\n    return hEmpty;\n\nError:\n    cmsCloseProfile(hEmpty);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              1176,
              0
            ],
            [
              1198,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsOpenProfileFromIOhandler2THR",
            "parameters": {
              "ContextID": "cmsContext",
              "io": "cmsIOHANDLER",
              "write": "cmsBool"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsOpenProfileFromFileTHR(cmsContext ContextID, const char *lpFileName, const char *sAccess)\n{\n    _cmsICCPROFILE* NewIcc;\n    cmsHPROFILE hEmpty = cmsCreateProfilePlaceholder(ContextID);\n\n    if (hEmpty == NULL) return NULL;\n\n    NewIcc = (_cmsICCPROFILE*) hEmpty;\n\n    NewIcc ->IOhandler = cmsOpenIOhandlerFromFile(ContextID, lpFileName, sAccess);\n    if (NewIcc ->IOhandler == NULL) goto Error;\n\n    if (*sAccess == 'W' || *sAccess == 'w') {\n\n        NewIcc -> IsWrite = TRUE;\n\n        return hEmpty;\n    }\n\n    if (!_cmsReadHeader(NewIcc)) goto Error;\n    return hEmpty;\n\nError:\n    cmsCloseProfile(hEmpty);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              1202,
              0
            ],
            [
              1227,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsOpenProfileFromFileTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "lpFileName": "char",
              "sAccess": "char"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsOpenProfileFromFile(const char *ICCProfile, const char *sAccess)\n{\n    return cmsOpenProfileFromFileTHR(NULL, ICCProfile, sAccess);\n}",
          "fn_code_pos": [
            [
              1230,
              0
            ],
            [
              1233,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsOpenProfileFromFile",
            "parameters": {
              "ICCProfile": "char",
              "sAccess": "char"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE  CMSEXPORT cmsOpenProfileFromStreamTHR(cmsContext ContextID, FILE* ICCProfile, const char *sAccess)\n{\n    _cmsICCPROFILE* NewIcc;\n    cmsHPROFILE hEmpty = cmsCreateProfilePlaceholder(ContextID);\n\n    if (hEmpty == NULL) return NULL;\n\n    NewIcc = (_cmsICCPROFILE*) hEmpty;\n\n    NewIcc ->IOhandler = cmsOpenIOhandlerFromStream(ContextID, ICCProfile);\n    if (NewIcc ->IOhandler == NULL) goto Error;\n\n    if (*sAccess == 'w') {\n\n        NewIcc -> IsWrite = TRUE;\n        return hEmpty;\n    }\n\n    if (!_cmsReadHeader(NewIcc)) goto Error;\n    return hEmpty;\n\nError:\n    cmsCloseProfile(hEmpty);\n    return NULL;\n\n}",
          "fn_code_pos": [
            [
              1236,
              0
            ],
            [
              1261,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsOpenProfileFromStreamTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "ICCProfile": "FILE",
              "sAccess": "char"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE  CMSEXPORT cmsOpenProfileFromStream(FILE* ICCProfile, const char *sAccess)\n{\n    return cmsOpenProfileFromStreamTHR(NULL, ICCProfile, sAccess);\n}",
          "fn_code_pos": [
            [
              1263,
              0
            ],
            [
              1266,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsOpenProfileFromStream",
            "parameters": {
              "ICCProfile": "FILE",
              "sAccess": "char"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsOpenProfileFromMemTHR(cmsContext ContextID, const void* MemPtr, cmsUInt32Number dwSize)\n{\n    _cmsICCPROFILE* NewIcc;\n    cmsHPROFILE hEmpty;\n\n    hEmpty = cmsCreateProfilePlaceholder(ContextID);\n    if (hEmpty == NULL) return NULL;\n\n    NewIcc = (_cmsICCPROFILE*) hEmpty;\n\n    // Ok, in this case const void* is casted to void* just because open IO handler\n    // shares read and writing modes. Don't abuse this feature!\n    NewIcc ->IOhandler = cmsOpenIOhandlerFromMem(ContextID, (void*) MemPtr, dwSize, \"r\");\n    if (NewIcc ->IOhandler == NULL) goto Error;\n\n    if (!_cmsReadHeader(NewIcc)) goto Error;\n\n    return hEmpty;\n\nError:\n    cmsCloseProfile(hEmpty);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              1270,
              0
            ],
            [
              1292,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsOpenProfileFromMemTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "MemPtr": "void",
              "dwSize": "cmsUInt32Number"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "cmsHPROFILE CMSEXPORT cmsOpenProfileFromMem(const void* MemPtr, cmsUInt32Number dwSize)\n{\n    return cmsOpenProfileFromMemTHR(NULL, MemPtr, dwSize);\n}",
          "fn_code_pos": [
            [
              1294,
              0
            ],
            [
              1297,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsOpenProfileFromMem",
            "parameters": {
              "MemPtr": "void",
              "dwSize": "cmsUInt32Number"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "static\ncmsBool SaveTags(_cmsICCPROFILE* Icc, _cmsICCPROFILE* FileOrig)\n{\n    cmsUInt8Number* Data;\n    cmsUInt32Number i;\n    cmsUInt32Number Begin;\n    cmsIOHANDLER* io = Icc ->IOhandler;\n    cmsTagDescriptor* TagDescriptor;\n    cmsTagTypeSignature TypeBase;\n    cmsTagTypeSignature Type;\n    cmsTagTypeHandler* TypeHandler;\n    cmsFloat64Number   Version = cmsGetProfileVersion((cmsHPROFILE) Icc);\n    cmsTagTypeHandler LocalTypeHandler;\n\n    for (i=0; i < Icc -> TagCount; i++) {\n\n        if (Icc ->TagNames[i] == (cmsTagSignature) 0) continue;\n\n        // Linked tags are not written\n        if (Icc ->TagLinked[i] != (cmsTagSignature) 0) continue;\n\n        Icc -> TagOffsets[i] = Begin = io ->UsedSpace;\n\n        Data = (cmsUInt8Number*)  Icc -> TagPtrs[i];\n\n        if (!Data) {\n\n            // Reach here if we are copying a tag from a disk-based ICC profile which has not been modified by user.\n            // In this case a blind copy of the block data is performed\n            if (FileOrig != NULL && Icc -> TagOffsets[i]) {\n\n                if (FileOrig->IOhandler != NULL)\n                {\n                    cmsUInt32Number TagSize = FileOrig->TagSizes[i];\n                    cmsUInt32Number TagOffset = FileOrig->TagOffsets[i];\n                    void* Mem;\n\n                    if (!FileOrig->IOhandler->Seek(FileOrig->IOhandler, TagOffset)) return FALSE;\n\n                    Mem = _cmsMalloc(Icc->ContextID, TagSize);\n                    if (Mem == NULL) return FALSE;\n\n                    if (FileOrig->IOhandler->Read(FileOrig->IOhandler, Mem, TagSize, 1) != 1) return FALSE;\n                    if (!io->Write(io, TagSize, Mem)) return FALSE;\n                    _cmsFree(Icc->ContextID, Mem);\n\n                    Icc->TagSizes[i] = (io->UsedSpace - Begin);\n\n\n                    // Align to 32 bit boundary.\n                    if (!_cmsWriteAlignment(io))\n                        return FALSE;\n                }\n            }\n\n            continue;\n        }\n\n\n        // Should this tag be saved as RAW? If so, tagsizes should be specified in advance (no further cooking is done)\n        if (Icc ->TagSaveAsRaw[i]) {\n\n            if (io -> Write(io, Icc ->TagSizes[i], Data) != 1) return FALSE;\n        }\n        else {\n\n            // Search for support on this tag\n            TagDescriptor = _cmsGetTagDescriptor(Icc-> ContextID, Icc -> TagNames[i]);\n            if (TagDescriptor == NULL) continue;                        // Unsupported, ignore it\n           \n            if (TagDescriptor ->DecideType != NULL) {\n\n                Type = TagDescriptor ->DecideType(Version, Data);\n            }\n            else {\n\n                Type = TagDescriptor ->SupportedTypes[0];\n            }\n\n            TypeHandler =  _cmsGetTagTypeHandler(Icc->ContextID, Type);\n\n            if (TypeHandler == NULL) {\n                cmsSignalError(Icc ->ContextID, cmsERROR_INTERNAL, \"(Internal) no handler for tag %x\", Icc -> TagNames[i]);\n                continue;\n            }\n\n            TypeBase = TypeHandler ->Signature;\n            if (!_cmsWriteTypeBase(io, TypeBase))\n                return FALSE;\n\n            LocalTypeHandler = *TypeHandler;\n            LocalTypeHandler.ContextID  = Icc ->ContextID;\n            LocalTypeHandler.ICCVersion = Icc ->Version;\n            if (!LocalTypeHandler.WritePtr(&LocalTypeHandler, io, Data, TagDescriptor ->ElemCount)) {\n\n                char String[5];\n\n                _cmsTagSignature2String(String, (cmsTagSignature) TypeBase);\n                cmsSignalError(Icc ->ContextID, cmsERROR_WRITE, \"Couldn't write type '%s'\", String);\n                return FALSE;\n            }\n        }\n\n\n        Icc -> TagSizes[i] = (io ->UsedSpace - Begin);\n\n        // Align to 32 bit boundary.\n        if (! _cmsWriteAlignment(io))\n            return FALSE;\n    }\n\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1302,
              0
            ],
            [
              1415,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SaveTags",
            "parameters": {
              "Icc": "_cmsICCPROFILE",
              "FileOrig": "_cmsICCPROFILE"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool SetLinks( _cmsICCPROFILE* Icc)\n{\n    cmsUInt32Number i;\n\n    for (i=0; i < Icc -> TagCount; i++) {\n\n        cmsTagSignature lnk = Icc ->TagLinked[i];\n        if (lnk != (cmsTagSignature) 0) {\n\n            int j = _cmsSearchTag(Icc, lnk, FALSE);\n            if (j >= 0) {\n\n                Icc ->TagOffsets[i] = Icc ->TagOffsets[j];\n                Icc ->TagSizes[i]   = Icc ->TagSizes[j];\n            }\n\n        }\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1419,
              0
            ],
            [
              1440,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetLinks",
            "parameters": {
              "Icc": "_cmsICCPROFILE"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsSaveProfileToIOhandler(cmsHPROFILE hProfile, cmsIOHANDLER* io)\n{\n    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;\n    _cmsICCPROFILE Keep;\n    cmsIOHANDLER* PrevIO = NULL;\n    cmsUInt32Number UsedSpace;\n    cmsContext ContextID;\n\n    _cmsAssert(hProfile != NULL);\n    \n    if (!_cmsLockMutex(Icc->ContextID, Icc->UsrMutex)) return 0;\n    memmove(&Keep, Icc, sizeof(_cmsICCPROFILE));\n\n    ContextID = cmsGetProfileContextID(hProfile);\n    PrevIO = Icc ->IOhandler = cmsOpenIOhandlerFromNULL(ContextID);\n    if (PrevIO == NULL) {\n        _cmsUnlockMutex(Icc->ContextID, Icc->UsrMutex);\n        return 0;\n    }\n\n    // Pass #1 does compute offsets\n\n    if (!_cmsWriteHeader(Icc, 0)) goto Error;\n    if (!SaveTags(Icc, &Keep)) goto Error;\n\n    UsedSpace = PrevIO ->UsedSpace;\n\n    // Pass #2 does save to iohandler\n\n    if (io != NULL) {\n\n        Icc ->IOhandler = io;\n        if (!SetLinks(Icc)) goto Error;\n        if (!_cmsWriteHeader(Icc, UsedSpace)) goto Error;\n        if (!SaveTags(Icc, &Keep)) goto Error;\n    }\n\n    memmove(Icc, &Keep, sizeof(_cmsICCPROFILE));\n    if (!cmsCloseIOhandler(PrevIO)) \n        UsedSpace = 0; // As a error marker\n\n    _cmsUnlockMutex(Icc->ContextID, Icc->UsrMutex);\n\n    return UsedSpace;\n\n\nError:\n    cmsCloseIOhandler(PrevIO);\n    memmove(Icc, &Keep, sizeof(_cmsICCPROFILE));\n    _cmsUnlockMutex(Icc->ContextID, Icc->UsrMutex);\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              1445,
              0
            ],
            [
              1497,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSaveProfileToIOhandler",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "io": "cmsIOHANDLER"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT cmsSaveProfileToFile(cmsHPROFILE hProfile, const char* FileName)\n{\n    cmsContext ContextID = cmsGetProfileContextID(hProfile);\n    cmsIOHANDLER* io = cmsOpenIOhandlerFromFile(ContextID, FileName, \"w\");\n    cmsBool rc;\n\n    if (io == NULL) return FALSE;\n\n    rc = (cmsSaveProfileToIOhandler(hProfile, io) != 0);\n    rc &= cmsCloseIOhandler(io);\n\n    if (rc == FALSE) {          // remove() is C99 per 7.19.4.1\n            remove(FileName);   // We have to IGNORE return value in this case\n    }\n    return rc;\n}",
          "fn_code_pos": [
            [
              1501,
              0
            ],
            [
              1516,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSaveProfileToFile",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "FileName": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsSaveProfileToStream(cmsHPROFILE hProfile, FILE* Stream)\n{\n    cmsBool rc;\n    cmsContext ContextID = cmsGetProfileContextID(hProfile);\n    cmsIOHANDLER* io = cmsOpenIOhandlerFromStream(ContextID, Stream);\n\n    if (io == NULL) return FALSE;\n\n    rc = (cmsSaveProfileToIOhandler(hProfile, io) != 0);\n    rc &= cmsCloseIOhandler(io);\n\n    return rc;\n}",
          "fn_code_pos": [
            [
              1519,
              0
            ],
            [
              1531,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSaveProfileToStream",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Stream": "FILE"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsSaveProfileToMem(cmsHPROFILE hProfile, void *MemPtr, cmsUInt32Number* BytesNeeded)\n{\n    cmsBool rc;\n    cmsIOHANDLER* io;\n    cmsContext ContextID = cmsGetProfileContextID(hProfile);\n\n    _cmsAssert(BytesNeeded != NULL);\n\n    // Should we just calculate the needed space?\n    if (MemPtr == NULL) {\n\n           *BytesNeeded =  cmsSaveProfileToIOhandler(hProfile, NULL);\n            return (*BytesNeeded == 0) ? FALSE : TRUE;\n    }\n\n    // That is a real write operation\n    io =  cmsOpenIOhandlerFromMem(ContextID, MemPtr, *BytesNeeded, \"w\");\n    if (io == NULL) return FALSE;\n\n    rc = (cmsSaveProfileToIOhandler(hProfile, io) != 0);\n    rc &= cmsCloseIOhandler(io);\n\n    return rc;\n}",
          "fn_code_pos": [
            [
              1535,
              0
            ],
            [
              1558,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSaveProfileToMem",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "MemPtr": "void",
              "BytesNeeded": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid freeOneTag(_cmsICCPROFILE* Icc, cmsUInt32Number i)\n{\n    if (Icc->TagPtrs[i]) {\n\n        cmsTagTypeHandler* TypeHandler = Icc->TagTypeHandlers[i];\n\n        if (TypeHandler != NULL) {\n            cmsTagTypeHandler LocalTypeHandler = *TypeHandler;\n\n            LocalTypeHandler.ContextID = Icc->ContextID;             \n            LocalTypeHandler.ICCVersion = Icc->Version;\n            LocalTypeHandler.FreePtr(&LocalTypeHandler, Icc->TagPtrs[i]);\n        }\n        else\n            _cmsFree(Icc->ContextID, Icc->TagPtrs[i]);\n    }\n}",
          "fn_code_pos": [
            [
              1561,
              0
            ],
            [
              1578,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "freeOneTag",
            "parameters": {
              "Icc": "_cmsICCPROFILE",
              "i": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT cmsCloseProfile(cmsHPROFILE hProfile)\n{\n    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;\n    cmsBool  rc = TRUE;\n    cmsUInt32Number i;\n\n    if (!Icc) return FALSE;\n\n    // Was open in write mode?\n    if (Icc ->IsWrite) {\n\n        Icc ->IsWrite = FALSE;      // Assure no further writing\n        rc &= cmsSaveProfileToFile(hProfile, Icc ->IOhandler->PhysicalFile);\n    }\n\n    for (i=0; i < Icc -> TagCount; i++) {\n\n        freeOneTag(Icc, i);        \n    }\n\n    if (Icc ->IOhandler != NULL) {\n        rc &= cmsCloseIOhandler(Icc->IOhandler);\n    }\n\n    _cmsDestroyMutex(Icc->ContextID, Icc->UsrMutex);\n\n    _cmsFree(Icc ->ContextID, Icc);   // Free placeholder memory\n\n    return rc;\n}",
          "fn_code_pos": [
            [
              1581,
              0
            ],
            [
              1610,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCloseProfile",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool IsTypeSupported(cmsTagDescriptor* TagDescriptor, cmsTagTypeSignature Type)\n{\n    cmsUInt32Number i, nMaxTypes;\n\n    nMaxTypes = TagDescriptor->nSupportedTypes;\n    if (nMaxTypes >= MAX_TYPES_IN_LCMS_PLUGIN)\n        nMaxTypes = MAX_TYPES_IN_LCMS_PLUGIN;\n\n    for (i=0; i < nMaxTypes; i++) {\n        if (Type == TagDescriptor ->SupportedTypes[i]) return TRUE;\n    }\n\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              1617,
              0
            ],
            [
              1631,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsTypeSupported",
            "parameters": {
              "TagDescriptor": "cmsTagDescriptor",
              "Type": "cmsTagTypeSignature"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "void* CMSEXPORT cmsReadTag(cmsHPROFILE hProfile, cmsTagSignature sig)\n{\n    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;\n    cmsIOHANDLER* io;\n    cmsTagTypeHandler* TypeHandler;\n    cmsTagTypeHandler LocalTypeHandler;\n    cmsTagDescriptor*  TagDescriptor;\n    cmsTagTypeSignature BaseType;\n    cmsUInt32Number Offset, TagSize;\n    cmsUInt32Number ElemCount;\n    int n;\n\n    if (!_cmsLockMutex(Icc->ContextID, Icc ->UsrMutex)) return NULL;\n\n    n = _cmsSearchTag(Icc, sig, TRUE);\n    if (n < 0)\n    {\n        // Not found, return NULL\n        _cmsUnlockMutex(Icc->ContextID, Icc->UsrMutex);\n        return NULL;\n    }\n\n    // If the element is already in memory, return the pointer\n    if (Icc -> TagPtrs[n]) {\n\n        if (Icc->TagTypeHandlers[n] == NULL) goto Error;\n\n        // Sanity check\n        BaseType = Icc->TagTypeHandlers[n]->Signature;\n        if (BaseType == 0) goto Error;\n\n        TagDescriptor = _cmsGetTagDescriptor(Icc->ContextID, sig);\n        if (TagDescriptor == NULL) goto Error;\n\n        if (!IsTypeSupported(TagDescriptor, BaseType)) goto Error;\n\n        if (Icc ->TagSaveAsRaw[n]) goto Error;  // We don't support read raw tags as cooked\n\n        _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);\n        return Icc -> TagPtrs[n];\n    }\n\n    // We need to read it. Get the offset and size to the file\n    Offset    = Icc -> TagOffsets[n];\n    TagSize   = Icc -> TagSizes[n];\n\n    if (TagSize < 8) goto Error;\n\n    io = Icc ->IOhandler;\n\n    if (io == NULL) { // This is a built-in profile that has been manipulated, abort early\n\n        cmsSignalError(Icc->ContextID, cmsERROR_CORRUPTION_DETECTED, \"Corrupted built-in profile.\");\n        goto Error;\n    }\n\n    // Seek to its location\n    if (!io -> Seek(io, Offset))\n        goto Error;\n\n    // Search for support on this tag\n    TagDescriptor = _cmsGetTagDescriptor(Icc-> ContextID, sig);\n    if (TagDescriptor == NULL) {\n\n        char String[5];\n\n        _cmsTagSignature2String(String, sig);\n\n        // An unknown element was found.\n        cmsSignalError(Icc ->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unknown tag type '%s' found.\", String);\n        goto Error;     // Unsupported.\n    }\n\n    // if supported, get type and check if in list\n    BaseType = _cmsReadTypeBase(io);\n    if (BaseType == 0) goto Error;\n\n    if (!IsTypeSupported(TagDescriptor, BaseType)) goto Error;\n   \n    TagSize  -= 8;       // Already read by the type base logic\n\n    // Get type handler\n    TypeHandler = _cmsGetTagTypeHandler(Icc ->ContextID, BaseType);\n    if (TypeHandler == NULL) goto Error;\n    LocalTypeHandler = *TypeHandler;\n\n\n    // Read the tag\n    Icc -> TagTypeHandlers[n] = TypeHandler;\n\n    LocalTypeHandler.ContextID = Icc ->ContextID;\n    LocalTypeHandler.ICCVersion = Icc ->Version;\n    Icc -> TagPtrs[n] = LocalTypeHandler.ReadPtr(&LocalTypeHandler, io, &ElemCount, TagSize);\n\n    // The tag type is supported, but something wrong happened and we cannot read the tag.\n    // let know the user about this (although it is just a warning)\n    if (Icc -> TagPtrs[n] == NULL) {\n\n        char String[5];\n\n        _cmsTagSignature2String(String, sig);\n        cmsSignalError(Icc ->ContextID, cmsERROR_CORRUPTION_DETECTED, \"Corrupted tag '%s'\", String);\n        goto Error;\n    }\n\n    // This is a weird error that may be a symptom of something more serious, the number of\n    // stored item is actually less than the number of required elements.\n    if (ElemCount < TagDescriptor ->ElemCount) {\n\n        char String[5];\n\n        _cmsTagSignature2String(String, sig);\n        cmsSignalError(Icc ->ContextID, cmsERROR_CORRUPTION_DETECTED, \"'%s' Inconsistent number of items: expected %d, got %d\",\n            String, TagDescriptor ->ElemCount, ElemCount);\n        goto Error;\n    }\n\n\n    // Return the data\n    _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);\n    return Icc -> TagPtrs[n];\n\n\n    // Return error and unlock the data\nError:\n\n    freeOneTag(Icc, n);    \n    Icc->TagPtrs[n] = NULL;\n    \n    _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              1635,
              0
            ],
            [
              1766,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsReadTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsTagSignature"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsTagTypeSignature _cmsGetTagTrueType(cmsHPROFILE hProfile, cmsTagSignature sig)\n{\n    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;\n    cmsTagTypeHandler* TypeHandler;\n    int n;\n\n    // Search for given tag in ICC profile directory\n    n = _cmsSearchTag(Icc, sig, TRUE);\n    if (n < 0) return (cmsTagTypeSignature) 0;                // Not found, return NULL\n\n    // Get the handler. The true type is there\n    TypeHandler =  Icc -> TagTypeHandlers[n];\n    return TypeHandler ->Signature;\n}",
          "fn_code_pos": [
            [
              1770,
              0
            ],
            [
              1783,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTagTrueType",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsTagSignature"
            },
            "return_type": "cmsTagTypeSignature"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsWriteTag(cmsHPROFILE hProfile, cmsTagSignature sig, const void* data)\n{\n    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;\n    cmsTagTypeHandler* TypeHandler = NULL;\n    cmsTagTypeHandler LocalTypeHandler;\n    cmsTagDescriptor* TagDescriptor = NULL;\n    cmsTagTypeSignature Type;\n    int i;\n    cmsFloat64Number Version;\n    char TypeString[5], SigString[5];\n\n    if (!_cmsLockMutex(Icc->ContextID, Icc ->UsrMutex)) return FALSE;\n\n    // To delete tags.\n    if (data == NULL) {\n\n         // Delete the tag\n         i = _cmsSearchTag(Icc, sig, FALSE);\n         if (i >= 0) {\n                \n             // Use zero as a mark of deleted \n             _cmsDeleteTagByPos(Icc, i);\n             Icc ->TagNames[i] = (cmsTagSignature) 0;\n             _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);\n             return TRUE;\n         }\n         // Didn't find the tag\n        goto Error;\n    }\n\n    if (!_cmsNewTag(Icc, sig, &i)) goto Error;\n\n    // This is not raw\n    Icc ->TagSaveAsRaw[i] = FALSE;\n\n    // This is not a link\n    Icc ->TagLinked[i] = (cmsTagSignature) 0;\n\n    // Get information about the TAG.\n    TagDescriptor = _cmsGetTagDescriptor(Icc-> ContextID, sig);\n    if (TagDescriptor == NULL){\n         cmsSignalError(Icc ->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported tag '%x'\", sig);\n        goto Error;\n    }\n\n\n    // Now we need to know which type to use. It depends on the version.\n    Version = cmsGetProfileVersion(hProfile);\n\n    if (TagDescriptor ->DecideType != NULL) {\n\n        // Let the tag descriptor to decide the type base on depending on\n        // the data. This is useful for example on parametric curves, where\n        // curves specified by a table cannot be saved as parametric and needs\n        // to be casted to single v2-curves, even on v4 profiles.\n\n        Type = TagDescriptor ->DecideType(Version, data);\n    }\n    else {\n\n        Type = TagDescriptor ->SupportedTypes[0];\n    }\n\n    // Does the tag support this type?\n    if (!IsTypeSupported(TagDescriptor, Type)) {\n\n        _cmsTagSignature2String(TypeString, (cmsTagSignature) Type);\n        _cmsTagSignature2String(SigString,  sig);\n\n        cmsSignalError(Icc ->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported type '%s' for tag '%s'\", TypeString, SigString);\n        goto Error;\n    }\n\n    // Does we have a handler for this type?\n    TypeHandler =  _cmsGetTagTypeHandler(Icc->ContextID, Type);\n    if (TypeHandler == NULL) {\n\n        _cmsTagSignature2String(TypeString, (cmsTagSignature) Type);\n        _cmsTagSignature2String(SigString,  sig);\n\n        cmsSignalError(Icc ->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported type '%s' for tag '%s'\", TypeString, SigString);\n        goto Error;           // Should never happen\n    }\n\n\n    // Fill fields on icc structure\n    Icc ->TagTypeHandlers[i]  = TypeHandler;\n    Icc ->TagNames[i]         = sig;\n    Icc ->TagSizes[i]         = 0;\n    Icc ->TagOffsets[i]       = 0;\n\n    LocalTypeHandler = *TypeHandler;\n    LocalTypeHandler.ContextID  = Icc ->ContextID;\n    LocalTypeHandler.ICCVersion = Icc ->Version;\n    Icc ->TagPtrs[i]            = LocalTypeHandler.DupPtr(&LocalTypeHandler, data, TagDescriptor ->ElemCount);\n\n    if (Icc ->TagPtrs[i] == NULL)  {\n\n        _cmsTagSignature2String(TypeString, (cmsTagSignature) Type);\n        _cmsTagSignature2String(SigString,  sig);\n        cmsSignalError(Icc ->ContextID, cmsERROR_CORRUPTION_DETECTED, \"Malformed struct in type '%s' for tag '%s'\", TypeString, SigString);\n\n        goto Error;\n    }\n\n    _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);\n    return TRUE;\n\nError:\n    _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);\n    return FALSE;\n\n}",
          "fn_code_pos": [
            [
              1788,
              0
            ],
            [
              1900,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsWriteTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsTagSignature",
              "data": "void"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsReadRawTag(cmsHPROFILE hProfile, cmsTagSignature sig, void* data, cmsUInt32Number BufferSize)\n{\n    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;\n    void *Object;\n    int i;\n    cmsIOHANDLER* MemIO;\n    cmsTagTypeHandler* TypeHandler = NULL;\n    cmsTagTypeHandler LocalTypeHandler;\n    cmsTagDescriptor* TagDescriptor = NULL;\n    cmsUInt32Number rc;\n    cmsUInt32Number Offset, TagSize;\n\n    // Sanity check\n    if (data != NULL && BufferSize == 0) return 0;\n\n    if (!_cmsLockMutex(Icc->ContextID, Icc ->UsrMutex)) return 0;\n\n    // Search for given tag in ICC profile directory\n    \n    i = _cmsSearchTag(Icc, sig, TRUE);\n    if (i < 0) goto Error;                 // Not found, \n\n    // It is already read?\n    if (Icc -> TagPtrs[i] == NULL) {\n\n        // Not yet, get original position\n        Offset   = Icc ->TagOffsets[i];\n        TagSize  = Icc ->TagSizes[i];\n\n        // read the data directly, don't keep copy\n        \n        if (data != NULL) {\n\n            if (BufferSize < TagSize)\n                TagSize = BufferSize;\n\n            if (!Icc ->IOhandler ->Seek(Icc ->IOhandler, Offset)) goto Error;\n            if (!Icc ->IOhandler ->Read(Icc ->IOhandler, data, 1, TagSize)) goto Error;\n\n            _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);\n            return TagSize;\n        }\n\n        _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);\n        return Icc ->TagSizes[i];\n    }\n\n    // The data has been already read, or written. But wait!, maybe the user choose to save as\n    // raw data. In this case, return the raw data directly\n    \n    if (Icc ->TagSaveAsRaw[i]) {\n\n        if (data != NULL)  {\n\n            TagSize  = Icc ->TagSizes[i];\n            if (BufferSize < TagSize)\n                TagSize = BufferSize;\n\n            memmove(data, Icc ->TagPtrs[i], TagSize);\n\n            _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);\n            return TagSize;\n        }\n\n        _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);\n        return Icc ->TagSizes[i];\n    }\n\n    // Already read, or previously set by cmsWriteTag(). We need to serialize that\n    // data to raw to get something that makes sense\n    \n    _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);\n    Object = cmsReadTag(hProfile, sig);\n    if (!_cmsLockMutex(Icc->ContextID, Icc ->UsrMutex)) return 0;\n\n    if (Object == NULL) goto Error;\n\n    // Now we need to serialize to a memory block: just use a memory iohandler\n\n    if (data == NULL) {\n        MemIO = cmsOpenIOhandlerFromNULL(cmsGetProfileContextID(hProfile));\n    } else{\n        MemIO = cmsOpenIOhandlerFromMem(cmsGetProfileContextID(hProfile), data, BufferSize, \"w\");\n    }\n    if (MemIO == NULL) goto Error;\n\n    // Obtain type handling for the tag\n    TypeHandler = Icc ->TagTypeHandlers[i];\n    TagDescriptor = _cmsGetTagDescriptor(Icc-> ContextID, sig);\n    if (TagDescriptor == NULL) {\n        cmsCloseIOhandler(MemIO);\n        goto Error;\n    }\n    \n    if (TypeHandler == NULL) goto Error;\n\n    // Serialize\n    LocalTypeHandler = *TypeHandler;\n    LocalTypeHandler.ContextID  = Icc ->ContextID;\n    LocalTypeHandler.ICCVersion = Icc ->Version;\n\n    if (!_cmsWriteTypeBase(MemIO, TypeHandler ->Signature)) {\n        cmsCloseIOhandler(MemIO);\n        goto Error;\n    }\n\n    if (!LocalTypeHandler.WritePtr(&LocalTypeHandler, MemIO, Object, TagDescriptor ->ElemCount)) {\n        cmsCloseIOhandler(MemIO);\n        goto Error;\n    }\n\n    // Get Size and close\n    rc = MemIO ->Tell(MemIO);\n    cmsCloseIOhandler(MemIO);      // Ignore return code this time\n\n    _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);\n    return rc;\n\nError:\n    _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);\n    return 0;\n}",
          "fn_code_pos": [
            [
              1906,
              0
            ],
            [
              2027,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsReadRawTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsTagSignature",
              "data": "void",
              "BufferSize": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsWriteRawTag(cmsHPROFILE hProfile, cmsTagSignature sig, const void* data, cmsUInt32Number Size)\n{\n    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;\n    int i;\n\n    if (!_cmsLockMutex(Icc->ContextID, Icc ->UsrMutex)) return 0;\n\n    if (!_cmsNewTag(Icc, sig, &i)) {\n        _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);\n         return FALSE;\n    }\n\n    // Mark the tag as being written as RAW\n    Icc ->TagSaveAsRaw[i] = TRUE;\n    Icc ->TagNames[i]     = sig;\n    Icc ->TagLinked[i]    = (cmsTagSignature) 0;\n\n    // Keep a copy of the block\n    Icc ->TagPtrs[i]  = _cmsDupMem(Icc ->ContextID, data, Size);\n    Icc ->TagSizes[i] = Size;\n\n    _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);\n\n    if (Icc->TagPtrs[i] == NULL) {           \n           Icc->TagNames[i] = (cmsTagSignature) 0;\n           return FALSE;\n    }\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              2033,
              0
            ],
            [
              2061,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsWriteRawTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsTagSignature",
              "data": "void",
              "Size": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsLinkTag(cmsHPROFILE hProfile, cmsTagSignature sig, cmsTagSignature dest)\n{\n    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;\n    int i;\n\n     if (!_cmsLockMutex(Icc->ContextID, Icc ->UsrMutex)) return FALSE;\n\n    if (!_cmsNewTag(Icc, sig, &i)) {\n        _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);\n        return FALSE;\n    }\n\n    // Keep necessary information\n    Icc ->TagSaveAsRaw[i] = FALSE;\n    Icc ->TagNames[i]     = sig;\n    Icc ->TagLinked[i]    = dest;\n\n    Icc ->TagPtrs[i]    = NULL;\n    Icc ->TagSizes[i]   = 0;\n    Icc ->TagOffsets[i] = 0;\n\n    _cmsUnlockMutex(Icc->ContextID, Icc ->UsrMutex);\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              2064,
              0
            ],
            [
              2087,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsLinkTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsTagSignature",
              "dest": "cmsTagSignature"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsTagSignature  CMSEXPORT cmsTagLinkedTo(cmsHPROFILE hProfile, cmsTagSignature sig)\n{\n    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;\n    int i;\n\n    // Search for given tag in ICC profile directory\n    i = _cmsSearchTag(Icc, sig, FALSE);\n    if (i < 0) return (cmsTagSignature) 0;                 // Not found, return 0\n\n    return Icc -> TagLinked[i];\n}",
          "fn_code_pos": [
            [
              2091,
              0
            ],
            [
              2101,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsTagLinkedTo",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsTagSignature"
            },
            "return_type": "cmsTagSignature"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "cmsReadTag(cmsHPROFILE hProfile, cmsTagSignature sig)",
          "fn_dec_pos": [
            [
              1635,
              16
            ],
            [
              1635,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsReadTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsTagSignature"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n    cmsUInt32Number Pointer;         // Points to current location\n} FILENULL;",
          {
            "Pointer": "cmsUInt32Number"
          },
          "FILENULL",
          [
            42,
            0
          ],
          [
            44,
            11
          ]
        ],
        [
          "typedef struct {\n    cmsUInt8Number* Block;    // Points to allocated memory\n    cmsUInt32Number Size;     // Size of allocated memory\n    cmsUInt32Number Pointer;  // Points to current location\n    int FreeBlockOnClose;     // As title\n\n} FILEMEM;",
          {
            "* Block": "cmsUInt8Number",
            "Size": "cmsUInt32Number",
            "Pointer": "cmsUInt32Number",
            "FreeBlockOnClose": "int"
          },
          "FILEMEM",
          [
            137,
            0
          ],
          [
            143,
            10
          ]
        ],
        [
          "typedef struct {\n    cmsUInt32Number Pointer;         // Points to current location\n} FILENULL;",
          {
            "Pointer": "cmsUInt32Number"
          },
          "FILENULL",
          [
            42,
            0
          ],
          [
            44,
            11
          ]
        ],
        [
          "struct _cms_io_handler",
          {},
          "",
          [
            101,
            4
          ],
          [
            101,
            26
          ]
        ],
        [
          "struct _cms_io_handler",
          {},
          "",
          [
            104,
            17
          ],
          [
            104,
            39
          ]
        ],
        [
          "struct _cms_io_handler",
          {},
          "",
          [
            104,
            75
          ],
          [
            104,
            97
          ]
        ],
        [
          "typedef struct {\n    cmsUInt8Number* Block;    // Points to allocated memory\n    cmsUInt32Number Size;     // Size of allocated memory\n    cmsUInt32Number Pointer;  // Points to current location\n    int FreeBlockOnClose;     // As title\n\n} FILEMEM;",
          {
            "* Block": "cmsUInt8Number",
            "Size": "cmsUInt32Number",
            "Pointer": "cmsUInt32Number",
            "FreeBlockOnClose": "int"
          },
          "FILEMEM",
          [
            137,
            0
          ],
          [
            143,
            10
          ]
        ],
        [
          "struct _cms_io_handler",
          {},
          "",
          [
            146,
            27
          ],
          [
            146,
            49
          ]
        ],
        [
          "struct _cms_io_handler",
          {},
          "",
          [
            169,
            20
          ],
          [
            169,
            42
          ]
        ],
        [
          "struct _cms_io_handler",
          {},
          "",
          [
            184,
            27
          ],
          [
            184,
            49
          ]
        ],
        [
          "struct _cms_io_handler",
          {},
          "",
          [
            195,
            20
          ],
          [
            195,
            42
          ]
        ],
        [
          "struct _cms_io_handler",
          {},
          "",
          [
            219,
            21
          ],
          [
            219,
            43
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            1061,
            70
          ],
          [
            1061,
            79
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            1064,
            41
          ],
          [
            1064,
            50
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmsmtrx.c": {
      "fn_def_list": [
        {
          "fn_code": "void CMSEXPORT _cmsVEC3init(cmsVEC3* r, cmsFloat64Number x, cmsFloat64Number y, cmsFloat64Number z)\n{\n    r -> n[VX] = x;\n    r -> n[VY] = y;\n    r -> n[VZ] = z;\n}",
          "fn_code_pos": [
            [
              33,
              0
            ],
            [
              38,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsVEC3init",
            "parameters": {
              "r": "cmsVEC3",
              "x": "cmsFloat64Number",
              "y": "cmsFloat64Number",
              "z": "cmsFloat64Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT _cmsVEC3minus(cmsVEC3* r, const cmsVEC3* a, const cmsVEC3* b)\n{\n  r -> n[VX] = a -> n[VX] - b -> n[VX];\n  r -> n[VY] = a -> n[VY] - b -> n[VY];\n  r -> n[VZ] = a -> n[VZ] - b -> n[VZ];\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              46,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsVEC3minus",
            "parameters": {
              "r": "cmsVEC3",
              "a": "cmsVEC3",
              "b": "cmsVEC3"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT _cmsVEC3cross(cmsVEC3* r, const cmsVEC3* u, const cmsVEC3* v)\n{\n    r ->n[VX] = u->n[VY] * v->n[VZ] - v->n[VY] * u->n[VZ];\n    r ->n[VY] = u->n[VZ] * v->n[VX] - v->n[VZ] * u->n[VX];\n    r ->n[VZ] = u->n[VX] * v->n[VY] - v->n[VX] * u->n[VY];\n}",
          "fn_code_pos": [
            [
              49,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsVEC3cross",
            "parameters": {
              "r": "cmsVEC3",
              "u": "cmsVEC3",
              "v": "cmsVEC3"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsFloat64Number CMSEXPORT _cmsVEC3dot(const cmsVEC3* u, const cmsVEC3* v)\n{\n    return u->n[VX] * v->n[VX] + u->n[VY] * v->n[VY] + u->n[VZ] * v->n[VZ];\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsVEC3dot",
            "parameters": {
              "u": "cmsVEC3",
              "v": "cmsVEC3"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "cmsFloat64Number CMSEXPORT _cmsVEC3length(const cmsVEC3* a)\n{\n    return sqrt(a ->n[VX] * a ->n[VX] +\n                a ->n[VY] * a ->n[VY] +\n                a ->n[VZ] * a ->n[VZ]);\n}",
          "fn_code_pos": [
            [
              63,
              0
            ],
            [
              68,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsVEC3length",
            "parameters": {
              "a": "cmsVEC3"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "cmsFloat64Number CMSEXPORT _cmsVEC3distance(const cmsVEC3* a, const cmsVEC3* b)\n{\n    cmsFloat64Number d1 = a ->n[VX] - b ->n[VX];\n    cmsFloat64Number d2 = a ->n[VY] - b ->n[VY];\n    cmsFloat64Number d3 = a ->n[VZ] - b ->n[VZ];\n\n    return sqrt(d1*d1 + d2*d2 + d3*d3);\n}",
          "fn_code_pos": [
            [
              71,
              0
            ],
            [
              78,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsVEC3distance",
            "parameters": {
              "a": "cmsVEC3",
              "b": "cmsVEC3"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "void CMSEXPORT _cmsMAT3identity(cmsMAT3* a)\n{\n    _cmsVEC3init(&a-> v[0], 1.0, 0.0, 0.0);\n    _cmsVEC3init(&a-> v[1], 0.0, 1.0, 0.0);\n    _cmsVEC3init(&a-> v[2], 0.0, 0.0, 1.0);\n}",
          "fn_code_pos": [
            [
              83,
              0
            ],
            [
              88,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMAT3identity",
            "parameters": {
              "a": "cmsMAT3"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool CloseEnough(cmsFloat64Number a, cmsFloat64Number b)\n{\n    return fabs(b - a) < (1.0 / 65535.0);\n}",
          "fn_code_pos": [
            [
              90,
              0
            ],
            [
              94,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CloseEnough",
            "parameters": {
              "a": "cmsFloat64Number",
              "b": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT _cmsMAT3isIdentity(const cmsMAT3* a)\n{\n    cmsMAT3 Identity;\n    int i, j;\n\n    _cmsMAT3identity(&Identity);\n\n    for (i=0; i < 3; i++)\n        for (j=0; j < 3; j++)\n            if (!CloseEnough(a ->v[i].n[j], Identity.v[i].n[j])) return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              97,
              0
            ],
            [
              109,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMAT3isIdentity",
            "parameters": {
              "a": "cmsMAT3"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "void CMSEXPORT _cmsMAT3per(cmsMAT3* r, const cmsMAT3* a, const cmsMAT3* b)\n{\n#define ROWCOL(i, j) \\\n    a->v[i].n[0]*b->v[0].n[j] + a->v[i].n[1]*b->v[1].n[j] + a->v[i].n[2]*b->v[2].n[j]\n\n    _cmsVEC3init(&r-> v[0], ROWCOL(0,0), ROWCOL(0,1), ROWCOL(0,2));\n    _cmsVEC3init(&r-> v[1], ROWCOL(1,0), ROWCOL(1,1), ROWCOL(1,2));\n    _cmsVEC3init(&r-> v[2], ROWCOL(2,0), ROWCOL(2,1), ROWCOL(2,2));\n\n#undef ROWCOL //(i, j)\n}",
          "fn_code_pos": [
            [
              113,
              0
            ],
            [
              123,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMAT3per",
            "parameters": {
              "r": "cmsMAT3",
              "a": "cmsMAT3",
              "b": "cmsMAT3"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT _cmsMAT3inverse(const cmsMAT3* a, cmsMAT3* b)\n{\n   cmsFloat64Number det, c0, c1, c2;\n\n   c0 =  a -> v[1].n[1]*a -> v[2].n[2] - a -> v[1].n[2]*a -> v[2].n[1];\n   c1 = -a -> v[1].n[0]*a -> v[2].n[2] + a -> v[1].n[2]*a -> v[2].n[0];\n   c2 =  a -> v[1].n[0]*a -> v[2].n[1] - a -> v[1].n[1]*a -> v[2].n[0];\n\n   det = a -> v[0].n[0]*c0 + a -> v[0].n[1]*c1 + a -> v[0].n[2]*c2;\n\n   if (fabs(det) < MATRIX_DET_TOLERANCE) return FALSE;  // singular matrix; can't invert\n\n   b -> v[0].n[0] = c0/det;\n   b -> v[0].n[1] = (a -> v[0].n[2]*a -> v[2].n[1] - a -> v[0].n[1]*a -> v[2].n[2])/det;\n   b -> v[0].n[2] = (a -> v[0].n[1]*a -> v[1].n[2] - a -> v[0].n[2]*a -> v[1].n[1])/det;\n   b -> v[1].n[0] = c1/det;\n   b -> v[1].n[1] = (a -> v[0].n[0]*a -> v[2].n[2] - a -> v[0].n[2]*a -> v[2].n[0])/det;\n   b -> v[1].n[2] = (a -> v[0].n[2]*a -> v[1].n[0] - a -> v[0].n[0]*a -> v[1].n[2])/det;\n   b -> v[2].n[0] = c2/det;\n   b -> v[2].n[1] = (a -> v[0].n[1]*a -> v[2].n[0] - a -> v[0].n[0]*a -> v[2].n[1])/det;\n   b -> v[2].n[2] = (a -> v[0].n[0]*a -> v[1].n[1] - a -> v[0].n[1]*a -> v[1].n[0])/det;\n\n   return TRUE;\n}",
          "fn_code_pos": [
            [
              128,
              0
            ],
            [
              151,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMAT3inverse",
            "parameters": {
              "a": "cmsMAT3",
              "b": "cmsMAT3"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT _cmsMAT3solve(cmsVEC3* x, cmsMAT3* a, cmsVEC3* b)\n{\n    cmsMAT3 m, a_1;\n\n    memmove(&m, a, sizeof(cmsMAT3));\n\n    if (!_cmsMAT3inverse(&m, &a_1)) return FALSE;  // Singular matrix\n\n    _cmsMAT3eval(x, &a_1, b);\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              155,
              0
            ],
            [
              165,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMAT3solve",
            "parameters": {
              "x": "cmsVEC3",
              "a": "cmsMAT3",
              "b": "cmsVEC3"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "void CMSEXPORT _cmsMAT3eval(cmsVEC3* r, const cmsMAT3* a, const cmsVEC3* v)\n{\n    r->n[VX] = a->v[0].n[VX]*v->n[VX] + a->v[0].n[VY]*v->n[VY] + a->v[0].n[VZ]*v->n[VZ];\n    r->n[VY] = a->v[1].n[VX]*v->n[VX] + a->v[1].n[VY]*v->n[VY] + a->v[1].n[VZ]*v->n[VZ];\n    r->n[VZ] = a->v[2].n[VX]*v->n[VX] + a->v[2].n[VY]*v->n[VY] + a->v[2].n[VZ]*v->n[VZ];\n}",
          "fn_code_pos": [
            [
              168,
              0
            ],
            [
              173,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMAT3eval",
            "parameters": {
              "r": "cmsVEC3",
              "a": "cmsMAT3",
              "v": "cmsVEC3"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmscam02.c": {
      "fn_def_list": [
        {
          "fn_code": "static\ncmsFloat64Number compute_n(cmsCIECAM02* pMod)\n{\n    return (pMod -> Yb / pMod -> adoptedWhite.XYZ[1]);\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compute_n",
            "parameters": {
              "pMod": "cmsCIECAM02"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number compute_z(cmsCIECAM02* pMod)\n{\n    return (1.48 + pow(pMod -> n, 0.5));\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              69,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compute_z",
            "parameters": {
              "pMod": "cmsCIECAM02"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number computeNbb(cmsCIECAM02* pMod)\n{\n    return (0.725 * pow((1.0 / pMod -> n), 0.2));\n}",
          "fn_code_pos": [
            [
              71,
              0
            ],
            [
              75,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "computeNbb",
            "parameters": {
              "pMod": "cmsCIECAM02"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number computeFL(cmsCIECAM02* pMod)\n{\n    cmsFloat64Number k, FL;\n\n    k = 1.0 / ((5.0 * pMod->LA) + 1.0);\n    FL = 0.2 * pow(k, 4.0) * (5.0 * pMod->LA) + 0.1 *\n        (pow((1.0 - pow(k, 4.0)), 2.0)) *\n        (pow((5.0 * pMod->LA), (1.0 / 3.0)));\n\n    return FL;\n}",
          "fn_code_pos": [
            [
              77,
              0
            ],
            [
              88,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "computeFL",
            "parameters": {
              "pMod": "cmsCIECAM02"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static cmsFloat64Number computeD(cmsCIECAM02* pMod) \n{\n    cmsFloat64Number D, temp;\n\n    temp = 1.0 - ((1.0 / 3.6) * exp((-pMod->LA - 42) / 92.0));\n    \n    D = pMod->F * temp;\n    return D;\n}",
          "fn_code_pos": [
            [
              90,
              0
            ],
            [
              98,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "computeD",
            "parameters": {
              "pMod": "cmsCIECAM02"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\nCAM02COLOR XYZtoCAT02(CAM02COLOR clr)\n{\n    clr.RGB[0] = (clr.XYZ[0] *  0.7328) + (clr.XYZ[1] *  0.4296) + (clr.XYZ[2] * -0.1624);\n    clr.RGB[1] = (clr.XYZ[0] * -0.7036) + (clr.XYZ[1] *  1.6975) + (clr.XYZ[2] *  0.0061);\n    clr.RGB[2] = (clr.XYZ[0] *  0.0030) + (clr.XYZ[1] *  0.0136) + (clr.XYZ[2] *  0.9834);\n\n    return clr;\n}",
          "fn_code_pos": [
            [
              100,
              0
            ],
            [
              108,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "XYZtoCAT02",
            "parameters": {
              "clr": "CAM02COLOR"
            },
            "return_type": "CAM02COLOR"
          }
        },
        {
          "fn_code": "static\nCAM02COLOR ChromaticAdaptation(CAM02COLOR clr, cmsCIECAM02* pMod)\n{\n    cmsUInt32Number i;\n\n    for (i = 0; i < 3; i++) {\n        clr.RGBc[i] = ((pMod -> adoptedWhite.XYZ[1] *\n            (pMod->D / pMod -> adoptedWhite.RGB[i])) +\n            (1.0 - pMod->D)) * clr.RGB[i];\n    }\n\n    return clr;\n}",
          "fn_code_pos": [
            [
              110,
              0
            ],
            [
              122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ChromaticAdaptation",
            "parameters": {
              "clr": "CAM02COLOR",
              "pMod": "cmsCIECAM02"
            },
            "return_type": "CAM02COLOR"
          }
        },
        {
          "fn_code": "static\nCAM02COLOR CAT02toHPE(CAM02COLOR clr)\n{\n    cmsFloat64Number M[9];\n\n    M[0] =(( 0.38971 *  1.096124) + (0.68898 * 0.454369) + (-0.07868 * -0.009628));\n    M[1] =(( 0.38971 * -0.278869) + (0.68898 * 0.473533) + (-0.07868 * -0.005698));\n    M[2] =(( 0.38971 *  0.182745) + (0.68898 * 0.072098) + (-0.07868 *  1.015326));\n    M[3] =((-0.22981 *  1.096124) + (1.18340 * 0.454369) + ( 0.04641 * -0.009628));\n    M[4] =((-0.22981 * -0.278869) + (1.18340 * 0.473533) + ( 0.04641 * -0.005698));\n    M[5] =((-0.22981 *  0.182745) + (1.18340 * 0.072098) + ( 0.04641 *  1.015326));\n    M[6] =(-0.009628);\n    M[7] =(-0.005698);\n    M[8] =( 1.015326);\n\n    clr.RGBp[0] = (clr.RGBc[0] * M[0]) +  (clr.RGBc[1] * M[1]) + (clr.RGBc[2] * M[2]);\n    clr.RGBp[1] = (clr.RGBc[0] * M[3]) +  (clr.RGBc[1] * M[4]) + (clr.RGBc[2] * M[5]);\n    clr.RGBp[2] = (clr.RGBc[0] * M[6]) +  (clr.RGBc[1] * M[7]) + (clr.RGBc[2] * M[8]);\n\n    return  clr;\n}",
          "fn_code_pos": [
            [
              125,
              0
            ],
            [
              145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CAT02toHPE",
            "parameters": {
              "clr": "CAM02COLOR"
            },
            "return_type": "CAM02COLOR"
          }
        },
        {
          "fn_code": "static\nCAM02COLOR NonlinearCompression(CAM02COLOR clr, cmsCIECAM02* pMod)\n{\n    cmsUInt32Number i;\n    cmsFloat64Number temp;\n\n    for (i = 0; i < 3; i++) {\n        if (clr.RGBp[i] < 0) {\n\n            temp = pow((-1.0 * pMod->FL * clr.RGBp[i] / 100.0), 0.42);\n            clr.RGBpa[i] = (-1.0 * 400.0 * temp) / (temp + 27.13) + 0.1;\n        }\n        else {\n            temp = pow((pMod->FL * clr.RGBp[i] / 100.0), 0.42);\n            clr.RGBpa[i] = (400.0 * temp) / (temp + 27.13) + 0.1;\n        }\n    }\n\n    clr.A = (((2.0 * clr.RGBpa[0]) + clr.RGBpa[1] +\n        (clr.RGBpa[2] / 20.0)) - 0.305) * pMod->Nbb;\n\n    return clr;\n}",
          "fn_code_pos": [
            [
              147,
              0
            ],
            [
              169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NonlinearCompression",
            "parameters": {
              "clr": "CAM02COLOR",
              "pMod": "cmsCIECAM02"
            },
            "return_type": "CAM02COLOR"
          }
        },
        {
          "fn_code": "static\nCAM02COLOR ComputeCorrelates(CAM02COLOR clr, cmsCIECAM02* pMod)\n{\n    cmsFloat64Number a, b, temp, e, t, r2d, d2r;\n\n    a = clr.RGBpa[0] - (12.0 * clr.RGBpa[1] / 11.0) + (clr.RGBpa[2] / 11.0);\n    b = (clr.RGBpa[0] + clr.RGBpa[1] - (2.0 * clr.RGBpa[2])) / 9.0;\n\n    r2d = (180.0 / 3.141592654);\n    if (a == 0) {\n        if (b == 0)     clr.h = 0;\n        else if (b > 0) clr.h = 90;\n        else            clr.h = 270;\n    }\n    else if (a > 0) {\n        temp = b / a;\n        if (b > 0)       clr.h = (r2d * atan(temp));\n        else if (b == 0) clr.h = 0;\n        else             clr.h = (r2d * atan(temp)) + 360;\n    }\n    else {\n        temp = b / a;\n        clr.h = (r2d * atan(temp)) + 180;\n    }\n\n    d2r = (3.141592654 / 180.0);\n    e = ((12500.0 / 13.0) * pMod->Nc * pMod->Ncb) *\n        (cos((clr.h * d2r + 2.0)) + 3.8);\n\n    if (clr.h < 20.14) {\n        temp = ((clr.h + 122.47)/1.2) + ((20.14 - clr.h)/0.8);\n        clr.H = 300 + (100*((clr.h + 122.47)/1.2)) / temp;\n    }\n    else if (clr.h < 90.0) {\n        temp = ((clr.h - 20.14)/0.8) + ((90.00 - clr.h)/0.7);\n        clr.H = (100*((clr.h - 20.14)/0.8)) / temp;\n    }\n    else if (clr.h < 164.25) {\n        temp = ((clr.h - 90.00)/0.7) + ((164.25 - clr.h)/1.0);\n        clr.H = 100 + ((100*((clr.h - 90.00)/0.7)) / temp);\n    }\n    else if (clr.h < 237.53) {\n        temp = ((clr.h - 164.25)/1.0) + ((237.53 - clr.h)/1.2);\n        clr.H = 200 + ((100*((clr.h - 164.25)/1.0)) / temp);\n    }\n    else {\n        temp = ((clr.h - 237.53)/1.2) + ((360 - clr.h + 20.14)/0.8);\n        clr.H = 300 + ((100*((clr.h - 237.53)/1.2)) / temp);\n    }\n\n    clr.J = 100.0 * pow((clr.A / pMod->adoptedWhite.A),\n        (pMod->c * pMod->z));\n\n    clr.Q = (4.0 / pMod->c) * pow((clr.J / 100.0), 0.5) *\n        (pMod->adoptedWhite.A + 4.0) * pow(pMod->FL, 0.25);\n\n    t = (e * pow(((a * a) + (b * b)), 0.5)) /\n        (clr.RGBpa[0] + clr.RGBpa[1] +\n        ((21.0 / 20.0) * clr.RGBpa[2]));\n\n    clr.C = pow(t, 0.9) * pow((clr.J / 100.0), 0.5) *\n        pow((1.64 - pow(0.29, pMod->n)), 0.73);\n\n    clr.M = clr.C * pow(pMod->FL, 0.25);\n    clr.s = 100.0 * pow((clr.M / clr.Q), 0.5);\n\n    return clr;\n}",
          "fn_code_pos": [
            [
              171,
              0
            ],
            [
              238,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComputeCorrelates",
            "parameters": {
              "clr": "CAM02COLOR",
              "pMod": "cmsCIECAM02"
            },
            "return_type": "CAM02COLOR"
          }
        },
        {
          "fn_code": "static\nCAM02COLOR InverseCorrelates(CAM02COLOR clr, cmsCIECAM02* pMod)\n{\n\n    cmsFloat64Number t, e, p1, p2, p3, p4, p5, hr, d2r;\n    d2r = 3.141592654 / 180.0;\n\n    t = pow( (clr.C / (pow((clr.J / 100.0), 0.5) *\n        (pow((1.64 - pow(0.29, pMod->n)), 0.73)))),\n        (1.0 / 0.9) );\n    e = ((12500.0 / 13.0) * pMod->Nc * pMod->Ncb) *\n        (cos((clr.h * d2r + 2.0)) + 3.8);\n\n    clr.A = pMod->adoptedWhite.A * pow(\n           (clr.J / 100.0),\n           (1.0 / (pMod->c * pMod->z)));\n\n    p1 = e / t;\n    p2 = (clr.A / pMod->Nbb) + 0.305;\n    p3 = 21.0 / 20.0;\n\n    hr = clr.h * d2r;\n\n    if (fabs(sin(hr)) >= fabs(cos(hr))) {\n        p4 = p1 / sin(hr);\n        clr.b = (p2 * (2.0 + p3) * (460.0 / 1403.0)) /\n            (p4 + (2.0 + p3) * (220.0 / 1403.0) *\n            (cos(hr) / sin(hr)) - (27.0 / 1403.0) +\n            p3 * (6300.0 / 1403.0));\n        clr.a = clr.b * (cos(hr) / sin(hr));\n    }\n    else {\n        p5 = p1 / cos(hr);\n        clr.a = (p2 * (2.0 + p3) * (460.0 / 1403.0)) /\n            (p5 + (2.0 + p3) * (220.0 / 1403.0) -\n            ((27.0 / 1403.0) - p3 * (6300.0 / 1403.0)) *\n            (sin(hr) / cos(hr)));\n        clr.b = clr.a * (sin(hr) / cos(hr));\n    }\n\n    clr.RGBpa[0] = ((460.0 / 1403.0) * p2) +\n              ((451.0 / 1403.0) * clr.a) +\n              ((288.0 / 1403.0) * clr.b);\n    clr.RGBpa[1] = ((460.0 / 1403.0) * p2) -\n              ((891.0 / 1403.0) * clr.a) -\n              ((261.0 / 1403.0) * clr.b);\n    clr.RGBpa[2] = ((460.0 / 1403.0) * p2) -\n              ((220.0 / 1403.0) * clr.a) -\n              ((6300.0 / 1403.0) * clr.b);\n\n    return clr;\n}",
          "fn_code_pos": [
            [
              241,
              0
            ],
            [
              292,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "InverseCorrelates",
            "parameters": {
              "clr": "CAM02COLOR",
              "pMod": "cmsCIECAM02"
            },
            "return_type": "CAM02COLOR"
          }
        },
        {
          "fn_code": "static\nCAM02COLOR InverseNonlinearity(CAM02COLOR clr, cmsCIECAM02* pMod)\n{\n    cmsUInt32Number i;\n    cmsFloat64Number c1;\n\n    for (i = 0; i < 3; i++) {\n        if ((clr.RGBpa[i] - 0.1) < 0) c1 = -1;\n        else                               c1 = 1;\n        clr.RGBp[i] = c1 * (100.0 / pMod->FL) *\n            pow(((27.13 * fabs(clr.RGBpa[i] - 0.1)) /\n            (400.0 - fabs(clr.RGBpa[i] - 0.1))),\n            (1.0 / 0.42));\n    }\n\n    return clr;\n}",
          "fn_code_pos": [
            [
              294,
              0
            ],
            [
              310,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "InverseNonlinearity",
            "parameters": {
              "clr": "CAM02COLOR",
              "pMod": "cmsCIECAM02"
            },
            "return_type": "CAM02COLOR"
          }
        },
        {
          "fn_code": "static\nCAM02COLOR HPEtoCAT02(CAM02COLOR clr)\n{\n    cmsFloat64Number M[9];\n\n    M[0] = (( 0.7328 *  1.910197) + (0.4296 * 0.370950));\n    M[1] = (( 0.7328 * -1.112124) + (0.4296 * 0.629054));\n    M[2] = (( 0.7328 *  0.201908) + (0.4296 * 0.000008) - 0.1624);\n    M[3] = ((-0.7036 *  1.910197) + (1.6975 * 0.370950));\n    M[4] = ((-0.7036 * -1.112124) + (1.6975 * 0.629054));\n    M[5] = ((-0.7036 *  0.201908) + (1.6975 * 0.000008) + 0.0061);\n    M[6] = (( 0.0030 *  1.910197) + (0.0136 * 0.370950));\n    M[7] = (( 0.0030 * -1.112124) + (0.0136 * 0.629054));\n    M[8] = (( 0.0030 *  0.201908) + (0.0136 * 0.000008) + 0.9834);\n\n    clr.RGBc[0] = (clr.RGBp[0] * M[0]) + (clr.RGBp[1] * M[1]) + (clr.RGBp[2] * M[2]);\n    clr.RGBc[1] = (clr.RGBp[0] * M[3]) + (clr.RGBp[1] * M[4]) + (clr.RGBp[2] * M[5]);\n    clr.RGBc[2] = (clr.RGBp[0] * M[6]) + (clr.RGBp[1] * M[7]) + (clr.RGBp[2] * M[8]);\n    return clr;\n}",
          "fn_code_pos": [
            [
              312,
              0
            ],
            [
              331,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HPEtoCAT02",
            "parameters": {
              "clr": "CAM02COLOR"
            },
            "return_type": "CAM02COLOR"
          }
        },
        {
          "fn_code": "static\nCAM02COLOR InverseChromaticAdaptation(CAM02COLOR clr,  cmsCIECAM02* pMod)\n{\n    cmsUInt32Number i;\n    for (i = 0; i < 3; i++) {\n        clr.RGB[i] = clr.RGBc[i] /\n            ((pMod->adoptedWhite.XYZ[1] * pMod->D / pMod->adoptedWhite.RGB[i]) + 1.0 - pMod->D);\n    }\n    return clr;\n}",
          "fn_code_pos": [
            [
              334,
              0
            ],
            [
              343,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "InverseChromaticAdaptation",
            "parameters": {
              "clr": "CAM02COLOR",
              "pMod": "cmsCIECAM02"
            },
            "return_type": "CAM02COLOR"
          }
        },
        {
          "fn_code": "static\nCAM02COLOR CAT02toXYZ(CAM02COLOR clr)\n{\n    clr.XYZ[0] = (clr.RGB[0] *  1.096124) + (clr.RGB[1] * -0.278869) + (clr.RGB[2] *  0.182745);\n    clr.XYZ[1] = (clr.RGB[0] *  0.454369) + (clr.RGB[1] *  0.473533) + (clr.RGB[2] *  0.072098);\n    clr.XYZ[2] = (clr.RGB[0] * -0.009628) + (clr.RGB[1] * -0.005698) + (clr.RGB[2] *  1.015326);\n\n    return clr;\n}",
          "fn_code_pos": [
            [
              346,
              0
            ],
            [
              354,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CAT02toXYZ",
            "parameters": {
              "clr": "CAM02COLOR"
            },
            "return_type": "CAM02COLOR"
          }
        },
        {
          "fn_code": "cmsHANDLE  CMSEXPORT cmsCIECAM02Init(cmsContext ContextID, const cmsViewingConditions* pVC)\n{\n    cmsCIECAM02* lpMod;\n\n    _cmsAssert(pVC != NULL);\n\n    if((lpMod = (cmsCIECAM02*) _cmsMallocZero(ContextID, sizeof(cmsCIECAM02))) == NULL) {\n        return NULL;\n    }\n\n    lpMod ->ContextID = ContextID;\n\n    lpMod ->adoptedWhite.XYZ[0] = pVC ->whitePoint.X;\n    lpMod ->adoptedWhite.XYZ[1] = pVC ->whitePoint.Y;\n    lpMod ->adoptedWhite.XYZ[2] = pVC ->whitePoint.Z;\n\n    lpMod -> LA       = pVC ->La;\n    lpMod -> Yb       = pVC ->Yb;\n    lpMod -> D        = pVC ->D_value;\n    lpMod -> surround = pVC ->surround;\n\n    switch (lpMod -> surround) {\n\n\n    case CUTSHEET_SURROUND:\n        lpMod->F = 0.8;\n        lpMod->c = 0.41;\n        lpMod->Nc = 0.8;\n        break;\n\n    case DARK_SURROUND:\n        lpMod -> F  = 0.8;\n        lpMod -> c  = 0.525;\n        lpMod -> Nc = 0.8;\n        break;\n\n    case DIM_SURROUND:\n        lpMod -> F  = 0.9;\n        lpMod -> c  = 0.59;\n        lpMod -> Nc = 0.95;\n        break;\n\n    default:\n        // Average surround\n        lpMod -> F  = 1.0;\n        lpMod -> c  = 0.69;\n        lpMod -> Nc = 1.0;\n    }\n\n    lpMod -> n   = compute_n(lpMod);\n    lpMod -> z   = compute_z(lpMod);\n    lpMod -> Nbb = computeNbb(lpMod);\n    lpMod -> FL  = computeFL(lpMod);\n\n    if (lpMod -> D == D_CALCULATE) {\n        lpMod -> D   = computeD(lpMod);\n    }\n\n    lpMod -> Ncb = lpMod -> Nbb;\n\n    lpMod -> adoptedWhite = XYZtoCAT02(lpMod -> adoptedWhite);\n    lpMod -> adoptedWhite = ChromaticAdaptation(lpMod -> adoptedWhite, lpMod);\n    lpMod -> adoptedWhite = CAT02toHPE(lpMod -> adoptedWhite);\n    lpMod -> adoptedWhite = NonlinearCompression(lpMod -> adoptedWhite, lpMod);\n\n    return (cmsHANDLE) lpMod;\n\n}",
          "fn_code_pos": [
            [
              357,
              0
            ],
            [
              424,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCIECAM02Init",
            "parameters": {
              "ContextID": "cmsContext",
              "pVC": "cmsViewingConditions"
            },
            "return_type": "cmsHANDLE"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsCIECAM02Done(cmsHANDLE hModel)\n{\n    cmsCIECAM02* lpMod = (cmsCIECAM02*) hModel;\n\n    if (lpMod) _cmsFree(lpMod ->ContextID, lpMod);\n}",
          "fn_code_pos": [
            [
              426,
              0
            ],
            [
              431,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCIECAM02Done",
            "parameters": {
              "hModel": "cmsHANDLE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsCIECAM02Forward(cmsHANDLE hModel, const cmsCIEXYZ* pIn, cmsJCh* pOut)\n{\n    CAM02COLOR clr;\n    cmsCIECAM02* lpMod = (cmsCIECAM02*) hModel;\n  \n    _cmsAssert(lpMod != NULL);\n    _cmsAssert(pIn != NULL);\n    _cmsAssert(pOut != NULL);\n\n    memset(&clr, 0, sizeof(clr));\n\n    clr.XYZ[0] = pIn ->X;\n    clr.XYZ[1] = pIn ->Y;\n    clr.XYZ[2] = pIn ->Z;\n\n    clr = XYZtoCAT02(clr);\n    clr = ChromaticAdaptation(clr, lpMod);\n    clr = CAT02toHPE(clr);\n    clr = NonlinearCompression(clr, lpMod);\n    clr = ComputeCorrelates(clr, lpMod);\n\n    pOut ->J = clr.J;\n    pOut ->C = clr.C;\n    pOut ->h = clr.h;\n}",
          "fn_code_pos": [
            [
              434,
              0
            ],
            [
              458,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCIECAM02Forward",
            "parameters": {
              "hModel": "cmsHANDLE",
              "pIn": "cmsCIEXYZ",
              "pOut": "cmsJCh"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsCIECAM02Reverse(cmsHANDLE hModel, const cmsJCh* pIn, cmsCIEXYZ* pOut)\n{\n    CAM02COLOR clr;\n    cmsCIECAM02* lpMod = (cmsCIECAM02*) hModel;\n    \n    _cmsAssert(lpMod != NULL);\n    _cmsAssert(pIn != NULL);\n    _cmsAssert(pOut != NULL);\n\n    memset(&clr, 0, sizeof(clr));\n\n    clr.J = pIn -> J;\n    clr.C = pIn -> C;\n    clr.h = pIn -> h;\n\n    clr = InverseCorrelates(clr, lpMod);\n    clr = InverseNonlinearity(clr, lpMod);\n    clr = HPEtoCAT02(clr);\n    clr = InverseChromaticAdaptation(clr, lpMod);\n    clr = CAT02toXYZ(clr);\n\n    pOut ->X = clr.XYZ[0];\n    pOut ->Y = clr.XYZ[1];\n    pOut ->Z = clr.XYZ[2];\n}",
          "fn_code_pos": [
            [
              460,
              0
            ],
            [
              484,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCIECAM02Reverse",
            "parameters": {
              "hModel": "cmsHANDLE",
              "pIn": "cmsJCh",
              "pOut": "cmsCIEXYZ"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct  {\n\n    cmsFloat64Number XYZ[3];\n    cmsFloat64Number RGB[3];\n    cmsFloat64Number RGBc[3];\n    cmsFloat64Number RGBp[3];\n    cmsFloat64Number RGBpa[3];\n    cmsFloat64Number a, b, h, e, H, A, J, Q, s, t, C, M;\n    cmsFloat64Number abC[2];\n    cmsFloat64Number abs[2];\n    cmsFloat64Number abM[2];\n\n} CAM02COLOR;",
          {
            "XYZ[3]": "cmsFloat64Number",
            "RGB[3]": "cmsFloat64Number",
            "RGBc[3]": "cmsFloat64Number",
            "RGBp[3]": "cmsFloat64Number",
            "RGBpa[3]": "cmsFloat64Number",
            "a": "cmsFloat64Number",
            "abC[2]": "cmsFloat64Number",
            "abs[2]": "cmsFloat64Number",
            "abM[2]": "cmsFloat64Number"
          },
          "CAM02COLOR",
          [
            32,
            0
          ],
          [
            44,
            13
          ]
        ],
        [
          "typedef struct  {\n\n    CAM02COLOR adoptedWhite;\n    cmsFloat64Number LA, Yb;\n    cmsFloat64Number F, c, Nc;\n    cmsUInt32Number surround;\n    cmsFloat64Number n, Nbb, Ncb, z, FL, D;\n\n    cmsContext ContextID;\n\n} cmsCIECAM02;",
          {
            "adoptedWhite": "CAM02COLOR",
            "LA": "cmsFloat64Number",
            "F": "cmsFloat64Number",
            "surround": "cmsUInt32Number",
            "n": "cmsFloat64Number",
            "ContextID": "cmsContext"
          },
          "cmsCIECAM02",
          [
            46,
            0
          ],
          [
            56,
            14
          ]
        ],
        [
          "typedef struct  {\n\n    cmsFloat64Number XYZ[3];\n    cmsFloat64Number RGB[3];\n    cmsFloat64Number RGBc[3];\n    cmsFloat64Number RGBp[3];\n    cmsFloat64Number RGBpa[3];\n    cmsFloat64Number a, b, h, e, H, A, J, Q, s, t, C, M;\n    cmsFloat64Number abC[2];\n    cmsFloat64Number abs[2];\n    cmsFloat64Number abM[2];\n\n} CAM02COLOR;",
          {
            "XYZ[3]": "cmsFloat64Number",
            "RGB[3]": "cmsFloat64Number",
            "RGBc[3]": "cmsFloat64Number",
            "RGBp[3]": "cmsFloat64Number",
            "RGBpa[3]": "cmsFloat64Number",
            "a": "cmsFloat64Number",
            "abC[2]": "cmsFloat64Number",
            "abs[2]": "cmsFloat64Number",
            "abM[2]": "cmsFloat64Number"
          },
          "CAM02COLOR",
          [
            32,
            0
          ],
          [
            44,
            13
          ]
        ],
        [
          "typedef struct  {\n\n    CAM02COLOR adoptedWhite;\n    cmsFloat64Number LA, Yb;\n    cmsFloat64Number F, c, Nc;\n    cmsUInt32Number surround;\n    cmsFloat64Number n, Nbb, Ncb, z, FL, D;\n\n    cmsContext ContextID;\n\n} cmsCIECAM02;",
          {
            "adoptedWhite": "CAM02COLOR",
            "LA": "cmsFloat64Number",
            "F": "cmsFloat64Number",
            "surround": "cmsUInt32Number",
            "n": "cmsFloat64Number",
            "ContextID": "cmsContext"
          },
          "cmsCIECAM02",
          [
            46,
            0
          ],
          [
            56,
            14
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmsnamed.c": {
      "fn_def_list": [
        {
          "fn_code": "static\ncmsBool GrowMLUpool(cmsMLU* mlu)\n{\n    cmsUInt32Number size;\n    void *NewPtr;\n\n    // Sanity check\n    if (mlu == NULL) return FALSE;\n\n    if (mlu ->PoolSize == 0)\n        size = 256;\n    else\n        size = mlu ->PoolSize * 2;\n\n    // Check for overflow\n    if (size < mlu ->PoolSize) return FALSE;\n\n    // Reallocate the pool\n    NewPtr = _cmsRealloc(mlu ->ContextID, mlu ->MemPool, size);\n    if (NewPtr == NULL) return FALSE;\n\n\n    mlu ->MemPool  = NewPtr;\n    mlu ->PoolSize = size;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              61,
              0
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GrowMLUpool",
            "parameters": {
              "mlu": "cmsMLU"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool GrowMLUtable(cmsMLU* mlu)\n{\n    cmsUInt32Number AllocatedEntries;\n    _cmsMLUentry *NewPtr;\n\n    // Sanity check\n    if (mlu == NULL) return FALSE;\n\n    AllocatedEntries = mlu ->AllocatedEntries * 2;\n\n    // Check for overflow\n    if (AllocatedEntries / 2 != mlu ->AllocatedEntries) return FALSE;\n\n    // Reallocate the memory\n    NewPtr = (_cmsMLUentry*)_cmsRealloc(mlu ->ContextID, mlu ->Entries, AllocatedEntries*sizeof(_cmsMLUentry));\n    if (NewPtr == NULL) return FALSE;\n\n    mlu ->Entries          = NewPtr;\n    mlu ->AllocatedEntries = AllocatedEntries;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              91,
              0
            ],
            [
              113,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GrowMLUtable",
            "parameters": {
              "mlu": "cmsMLU"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nint SearchMLUEntry(cmsMLU* mlu, cmsUInt16Number LanguageCode, cmsUInt16Number CountryCode)\n{\n    cmsUInt32Number i;\n\n    // Sanity check\n    if (mlu == NULL) return -1;\n\n    // Iterate whole table\n    for (i=0; i < mlu ->UsedEntries; i++) {\n\n        if (mlu ->Entries[i].Country  == CountryCode &&\n            mlu ->Entries[i].Language == LanguageCode) return (int) i;\n    }\n\n    // Not found\n    return -1;\n}",
          "fn_code_pos": [
            [
              117,
              0
            ],
            [
              134,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SearchMLUEntry",
            "parameters": {
              "mlu": "cmsMLU",
              "LanguageCode": "cmsUInt16Number",
              "CountryCode": "cmsUInt16Number"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\ncmsBool AddMLUBlock(cmsMLU* mlu, cmsUInt32Number size, const wchar_t *Block,\n                     cmsUInt16Number LanguageCode, cmsUInt16Number CountryCode)\n{\n    cmsUInt32Number Offset;\n    cmsUInt8Number* Ptr;\n\n    // Sanity check\n    if (mlu == NULL) return FALSE;\n\n    // Is there any room available?\n    if (mlu ->UsedEntries >= mlu ->AllocatedEntries) {\n        if (!GrowMLUtable(mlu)) return FALSE;\n    }\n\n    // Only one ASCII string\n    if (SearchMLUEntry(mlu, LanguageCode, CountryCode) >= 0) return FALSE;  // Only one  is allowed!\n\n    // Check for size\n    while ((mlu ->PoolSize - mlu ->PoolUsed) < size) {\n\n            if (!GrowMLUpool(mlu)) return FALSE;\n    }\n\n    Offset = mlu ->PoolUsed;\n\n    Ptr = (cmsUInt8Number*) mlu ->MemPool;\n    if (Ptr == NULL) return FALSE;\n\n    // Set the entry\n    memmove(Ptr + Offset, Block, size);\n    mlu ->PoolUsed += size;\n\n    mlu ->Entries[mlu ->UsedEntries].StrW     = Offset;\n    mlu ->Entries[mlu ->UsedEntries].Len      = size;\n    mlu ->Entries[mlu ->UsedEntries].Country  = CountryCode;\n    mlu ->Entries[mlu ->UsedEntries].Language = LanguageCode;\n    mlu ->UsedEntries++;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              138,
              0
            ],
            [
              178,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddMLUBlock",
            "parameters": {
              "mlu": "cmsMLU",
              "size": "cmsUInt32Number",
              "Block": "wchar_t",
              "LanguageCode": "cmsUInt16Number",
              "CountryCode": "cmsUInt16Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsUInt16Number strTo16(const char str[3])\n{   \n    const cmsUInt8Number* ptr8;\n    cmsUInt16Number n;\n\n    // For non-existent strings\n    if (str == NULL) return 0;\n    ptr8 = (const cmsUInt8Number*)str;\n    n = (cmsUInt16Number)(((cmsUInt16Number)ptr8[0] << 8) | ptr8[1]);\n\n    return n;\n}",
          "fn_code_pos": [
            [
              182,
              0
            ],
            [
              194,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strTo16",
            "parameters": {
              "str": "char"
            },
            "return_type": "cmsUInt16Number"
          }
        },
        {
          "fn_code": "static\nvoid strFrom16(char str[3], cmsUInt16Number n)\n{\n    str[0] = (char)(n >> 8);\n    str[1] = (char)n;\n    str[2] = (char)0;\n}",
          "fn_code_pos": [
            [
              196,
              0
            ],
            [
              202,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strFrom16",
            "parameters": {
              "str": "char",
              "n": "cmsUInt16Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number decodeUTF8(wchar_t* out, const char* in)\n{    \n    cmsUInt32Number codepoint = 0;    \n    cmsUInt32Number size = 0;\n\n    while (*in)\n    {\n        cmsUInt8Number ch = (cmsUInt8Number) *in;\n\n        if (ch <= 0x7f)\n        {\n            codepoint = ch;\n        }\n        else if (ch <= 0xbf)\n        {\n            codepoint = (codepoint << 6) | (ch & 0x3f);\n        }\n        else if (ch <= 0xdf)\n        {\n            codepoint = ch & 0x1f;\n        }\n        else if (ch <= 0xef)\n        {\n            codepoint = ch & 0x0f;\n        }\n        else\n        {\n            codepoint = ch & 0x07;\n        }\n\n        in++; \n\n        if (((*in & 0xc0) != 0x80) && (codepoint <= 0x10ffff))\n        {\n            if (sizeof(wchar_t) > 2)\n            {\n                if (out) *out++ = (wchar_t) codepoint;\n                size++;\n            }\n            else\n                if (codepoint > 0xffff)\n                {\n                    if (out)\n                    {\n                        *out++ = (wchar_t)(0xd800 + (codepoint >> 10));\n                        *out++ = (wchar_t)(0xdc00 + (codepoint & 0x03ff));\n                        size += 2;\n                    }\n                }\n                else\n                    if (codepoint < 0xd800 || codepoint >= 0xe000)\n                    {\n                        if (out) *out++ = (wchar_t) codepoint;\n                        size++;\n                    }\n        }\n    }   \n    \n    return size;\n}",
          "fn_code_pos": [
            [
              206,
              0
            ],
            [
              266,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "decodeUTF8",
            "parameters": {
              "out": "wchar_t",
              "in": "char"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "static \ncmsUInt32Number encodeUTF8(char* out, const wchar_t* in, cmsUInt32Number max_wchars, cmsUInt32Number max_chars)\n{       \n    cmsUInt32Number codepoint = 0;\n    cmsUInt32Number size = 0;\n    cmsUInt32Number len_w = 0;\n        \n    while (*in && len_w < max_wchars)\n    {\n        if (*in >= 0xd800 && *in <= 0xdbff)\n            codepoint = ((*in - 0xd800) << 10) + 0x10000;\n        else\n        {\n            if (*in >= 0xdc00 && *in <= 0xdfff)\n                codepoint |= *in - 0xdc00;\n            else\n                codepoint = *in;\n\n            if (codepoint <= 0x7f)\n            {\n                if (out && (size + 1 < max_chars)) *out++ = (char)codepoint;\n                size++;\n            }\n\n            else if (codepoint <= 0x7ff)\n            {\n                if (out && (max_chars > 0) && (size + 2 < max_chars))\n                {\n                    *out++ = (char)(cmsUInt32Number)(0xc0 | ((codepoint >> 6) & 0x1f));\n                    *out++ = (char)(cmsUInt32Number)(0x80 | (codepoint & 0x3f));                    \n                }\n                size += 2;\n            }\n            else if (codepoint <= 0xffff)\n            {\n                if (out && (max_chars > 0) && (size + 3 < max_chars))\n                {\n                    *out++ = (char)(cmsUInt32Number)(0xe0 | ((codepoint >> 12) & 0x0f));\n                    *out++ = (char)(cmsUInt32Number)(0x80 | ((codepoint >> 6) & 0x3f));\n                    *out++ = (char)(cmsUInt32Number)(0x80 | (codepoint & 0x3f));\n                }\n                size += 3;\n            }\n            else\n            {\n                if (out && (max_chars > 0) && (size + 4 < max_chars))\n                {\n                    *out++ = (char)(cmsUInt32Number)(0xf0 | ((codepoint >> 18) & 0x07));\n                    *out++ = (char)(cmsUInt32Number)(0x80 | ((codepoint >> 12) & 0x3f));\n                    *out++ = (char)(cmsUInt32Number)(0x80 | ((codepoint >> 6) & 0x3f));\n                    *out++ = (char)(cmsUInt32Number)(0x80 | (codepoint & 0x3f));\n                }\n                size += 4;\n            }\n\n            codepoint = 0;\n        }\n\n        in++; len_w++;         \n    }\n\n    return size;\n}",
          "fn_code_pos": [
            [
              269,
              0
            ],
            [
              331,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "encodeUTF8",
            "parameters": {
              "out": "char",
              "in": "wchar_t",
              "max_wchars": "cmsUInt32Number",
              "max_chars": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsMLUsetASCII(cmsMLU* mlu, const char LanguageCode[3], const char CountryCode[3], const char* ASCIIString)\n{\n    cmsUInt32Number i, len = (cmsUInt32Number)strlen(ASCIIString);\n    wchar_t* WStr;\n    cmsBool  rc;\n    cmsUInt16Number Lang = strTo16(LanguageCode);\n    cmsUInt16Number Cntry = strTo16(CountryCode);\n\n    if (mlu == NULL) return FALSE;\n\n    // len == 0 would prevent operation, so we set a empty string pointing to zero\n    if (len == 0)\n    {\n        wchar_t empty = 0;\n        return AddMLUBlock(mlu, sizeof(wchar_t), &empty, Lang, Cntry);\n    }\n\n    WStr = (wchar_t*)_cmsCalloc(mlu->ContextID, len, sizeof(wchar_t));\n    if (WStr == NULL) return FALSE;\n\n    for (i = 0; i < len; i++)\n        WStr[i] = (wchar_t)ASCIIString[i];\n\n    rc = AddMLUBlock(mlu, len * sizeof(wchar_t), WStr, Lang, Cntry);\n\n    _cmsFree(mlu->ContextID, WStr);\n    return rc;\n\n}",
          "fn_code_pos": [
            [
              335,
              0
            ],
            [
              363,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUsetASCII",
            "parameters": {
              "mlu": "cmsMLU",
              "LanguageCode": "char",
              "CountryCode": "char",
              "ASCIIString": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsMLUsetUTF8(cmsMLU* mlu, const char LanguageCode[3], const char CountryCode[3], const char* UTF8String)\n{\n    cmsUInt32Number UTF8len;\n    wchar_t* WStr;\n    cmsBool  rc;\n    cmsUInt16Number Lang  = strTo16(LanguageCode);\n    cmsUInt16Number Cntry = strTo16(CountryCode);\n\n    if (mlu == NULL) return FALSE;\n\n    if (*UTF8String == '\\0')\n    {\n        wchar_t empty = 0;\n        return AddMLUBlock(mlu, sizeof(wchar_t), &empty, Lang, Cntry);\n    }\n    \n    // Len excluding terminator 0\n    UTF8len = decodeUTF8(NULL, UTF8String);\n    \n    // Get space for dest\n    WStr = (wchar_t*) _cmsCalloc(mlu ->ContextID, UTF8len,  sizeof(wchar_t));\n    if (WStr == NULL) return FALSE;\n\n    decodeUTF8(WStr, UTF8String);\n    \n    rc = AddMLUBlock(mlu, UTF8len  * sizeof(wchar_t), WStr, Lang, Cntry);\n\n    _cmsFree(mlu ->ContextID, WStr);\n    return rc;\n}",
          "fn_code_pos": [
            [
              367,
              0
            ],
            [
              396,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUsetUTF8",
            "parameters": {
              "mlu": "cmsMLU",
              "LanguageCode": "char",
              "CountryCode": "char",
              "UTF8String": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsUInt32Number mywcslen(const wchar_t *s)\n{\n    const wchar_t *p;\n\n    p = s;\n    while (*p)\n        p++;\n\n    return (cmsUInt32Number)(p - s);\n}",
          "fn_code_pos": [
            [
              399,
              0
            ],
            [
              409,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mywcslen",
            "parameters": {
              "s": "wchar_t"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT cmsMLUsetWide(cmsMLU* mlu, const char Language[3], const char Country[3], const wchar_t* WideString)\n{\n    cmsUInt16Number Lang  = strTo16(Language);\n    cmsUInt16Number Cntry = strTo16(Country);\n    cmsUInt32Number len;\n\n    if (mlu == NULL) return FALSE;\n    if (WideString == NULL) return FALSE;\n\n    len = (cmsUInt32Number) (mywcslen(WideString)) * sizeof(wchar_t);\n    if (len == 0)\n        len = sizeof(wchar_t);\n\n    return AddMLUBlock(mlu, len, WideString, Lang, Cntry);\n}",
          "fn_code_pos": [
            [
              412,
              0
            ],
            [
              426,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUsetWide",
            "parameters": {
              "mlu": "cmsMLU",
              "Language": "char",
              "Country": "char",
              "WideString": "wchar_t"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsMLUfree(cmsMLU* mlu)\n{\n    if (mlu) {\n\n        if (mlu -> Entries) _cmsFree(mlu ->ContextID, mlu->Entries);\n        if (mlu -> MemPool) _cmsFree(mlu ->ContextID, mlu->MemPool);\n\n        _cmsFree(mlu ->ContextID, mlu);\n    }\n}",
          "fn_code_pos": [
            [
              475,
              0
            ],
            [
              484,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUfree",
            "parameters": {
              "mlu": "cmsMLU"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nconst wchar_t* _cmsMLUgetWide(const cmsMLU* mlu,\n                              cmsUInt32Number *len,\n                              cmsUInt16Number LanguageCode, cmsUInt16Number CountryCode,\n                              cmsUInt16Number* UsedLanguageCode, cmsUInt16Number* UsedCountryCode)\n{\n    cmsUInt32Number i;\n    int Best = -1;\n    _cmsMLUentry* v;\n\n    if (mlu == NULL) return NULL;\n\n    if (mlu -> AllocatedEntries <= 0) return NULL;\n\n    for (i=0; i < mlu ->UsedEntries; i++) {\n\n        v = mlu ->Entries + i;\n\n        if (v -> Language == LanguageCode) {\n\n            if (Best == -1) Best = (int) i;\n\n            if (v -> Country == CountryCode) {\n\n                if (UsedLanguageCode != NULL) *UsedLanguageCode = v ->Language;\n                if (UsedCountryCode  != NULL) *UsedCountryCode = v ->Country;\n\n                if (len != NULL) *len = v ->Len;\n\n                return (wchar_t*) ((cmsUInt8Number*) mlu ->MemPool + v -> StrW);        // Found exact match\n            }\n        }\n    }\n\n    // No string found. Return First one\n    if (Best == -1)\n        Best = 0;\n\n    v = mlu ->Entries + Best;\n\n    if (UsedLanguageCode != NULL) *UsedLanguageCode = v ->Language;\n    if (UsedCountryCode  != NULL) *UsedCountryCode = v ->Country;\n\n    if (len != NULL) *len   = v ->Len;\n\n    if (v->StrW + v->Len > mlu->PoolSize) return NULL;\n\n    return (wchar_t*) ((cmsUInt8Number*) mlu ->MemPool + v ->StrW);\n}",
          "fn_code_pos": [
            [
              489,
              0
            ],
            [
              537,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMLUgetWide",
            "parameters": {
              "mlu": "cmsMLU",
              "len": "cmsUInt32Number",
              "LanguageCode": "cmsUInt16Number",
              "CountryCode": "cmsUInt16Number",
              "UsedLanguageCode": "cmsUInt16Number",
              "UsedCountryCode": "cmsUInt16Number"
            },
            "return_type": "wchar_t"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsMLUgetASCII(const cmsMLU* mlu,\n                                       const char LanguageCode[3], const char CountryCode[3],\n                                       char* Buffer, cmsUInt32Number BufferSize)\n{\n    const wchar_t *Wide;\n    cmsUInt32Number  StrLen = 0;\n    cmsUInt32Number ASCIIlen, i;\n\n    cmsUInt16Number Lang  = strTo16(LanguageCode);\n    cmsUInt16Number Cntry = strTo16(CountryCode);\n\n    // Sanitize\n    if (mlu == NULL) return 0;\n\n    // Get WideChar\n    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);\n    if (Wide == NULL) return 0;\n\n    ASCIIlen = StrLen / sizeof(wchar_t);\n\n    // Maybe we want only to know the len?\n    if (Buffer == NULL) return ASCIIlen + 1; // Note the zero at the end\n\n    // No buffer size means no data\n    if (BufferSize <= 0) return 0;\n\n    // Some clipping may be required\n    if (BufferSize < ASCIIlen + 1)\n        ASCIIlen = BufferSize - 1;\n\n    // Process each character\n    for (i=0; i < ASCIIlen; i++) {\n\n        wchar_t wc = Wide[i];\n\n        if (wc < 0xff)\n            Buffer[i] = (char)wc;\n        else\n            Buffer[i] = '?';\n    }\n\n    // We put a termination \"\\0\"\n    Buffer[ASCIIlen] = 0;\n    return ASCIIlen + 1;\n}",
          "fn_code_pos": [
            [
              541,
              0
            ],
            [
              585,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUgetASCII",
            "parameters": {
              "mlu": "cmsMLU",
              "LanguageCode": "char",
              "CountryCode": "char",
              "Buffer": "char",
              "BufferSize": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsMLUgetUTF8(const cmsMLU* mlu,\n                                       const char LanguageCode[3], const char CountryCode[3],\n                                       char* Buffer, cmsUInt32Number BufferSize)\n{\n    const wchar_t *Wide;\n    cmsUInt32Number  StrLen = 0;\n    cmsUInt32Number UTF8len;\n\n    cmsUInt16Number Lang  = strTo16(LanguageCode);\n    cmsUInt16Number Cntry = strTo16(CountryCode);\n\n    // Sanitize\n    if (mlu == NULL) return 0;\n\n    // Get WideChar\n    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);\n    if (Wide == NULL) return 0;\n\n    UTF8len = encodeUTF8(NULL, Wide, StrLen / sizeof(wchar_t), BufferSize);\n       \n    // Maybe we want only to know the len?\n    if (Buffer == NULL) return UTF8len + 1; // Note the zero at the end\n\n    // No buffer size means no data\n    if (BufferSize <= 0) return 0;\n\n    // Some clipping may be required\n    if (BufferSize < UTF8len + 1)\n        UTF8len = BufferSize - 1;\n\n    // Process it\n    encodeUTF8(Buffer, Wide, StrLen / sizeof(wchar_t), BufferSize);    \n\n    // We put a termination \"\\0\"\n    Buffer[UTF8len] = 0;\n    return UTF8len + 1;\n}",
          "fn_code_pos": [
            [
              589,
              0
            ],
            [
              625,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUgetUTF8",
            "parameters": {
              "mlu": "cmsMLU",
              "LanguageCode": "char",
              "CountryCode": "char",
              "Buffer": "char",
              "BufferSize": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsMLUgetWide(const cmsMLU* mlu,\n                                      const char LanguageCode[3], const char CountryCode[3],\n                                      wchar_t* Buffer, cmsUInt32Number BufferSize)\n{\n    const wchar_t *Wide;\n    cmsUInt32Number  StrLen = 0;\n\n    cmsUInt16Number Lang  = strTo16(LanguageCode);\n    cmsUInt16Number Cntry = strTo16(CountryCode);\n\n    // Sanitize\n    if (mlu == NULL) return 0;\n\n    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);\n    if (Wide == NULL) return 0;\n\n    // Maybe we want only to know the len?\n    if (Buffer == NULL) return StrLen + sizeof(wchar_t);\n\n    // Invalid buffer size means no data\n    if (BufferSize < sizeof(wchar_t)) return 0;\n\n    // Some clipping may be required\n    if (BufferSize < StrLen + sizeof(wchar_t))\n        StrLen = BufferSize - sizeof(wchar_t);\n\n    memmove(Buffer, Wide, StrLen);\n    Buffer[StrLen / sizeof(wchar_t)] = 0;\n\n    return StrLen + sizeof(wchar_t);\n}",
          "fn_code_pos": [
            [
              628,
              0
            ],
            [
              658,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUgetWide",
            "parameters": {
              "mlu": "cmsMLU",
              "LanguageCode": "char",
              "CountryCode": "char",
              "Buffer": "wchar_t",
              "BufferSize": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "CMSAPI cmsBool CMSEXPORT cmsMLUgetTranslation(const cmsMLU* mlu,\n                                              const char LanguageCode[3], const char CountryCode[3],\n                                              char ObtainedLanguage[3], char ObtainedCountry[3])\n{\n    const wchar_t *Wide;\n\n    cmsUInt16Number Lang  = strTo16(LanguageCode);\n    cmsUInt16Number Cntry = strTo16(CountryCode);\n    cmsUInt16Number ObtLang, ObtCode;\n\n    // Sanitize\n    if (mlu == NULL) return FALSE;\n\n    Wide = _cmsMLUgetWide(mlu, NULL, Lang, Cntry, &ObtLang, &ObtCode);\n    if (Wide == NULL) return FALSE;\n\n    // Get used language and code\n    strFrom16(ObtainedLanguage, ObtLang);\n    strFrom16(ObtainedCountry, ObtCode);\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              662,
              0
            ],
            [
              683,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUgetTranslation",
            "parameters": {
              "mlu": "cmsMLU",
              "LanguageCode": "char",
              "CountryCode": "char",
              "ObtainedLanguage": "char",
              "ObtainedCountry": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsMLUtranslationsCount(const cmsMLU* mlu)\n{\n    if (mlu == NULL) return 0;\n    return mlu->UsedEntries;\n}",
          "fn_code_pos": [
            [
              688,
              0
            ],
            [
              692,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUtranslationsCount",
            "parameters": {
              "mlu": "cmsMLU"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsMLUtranslationsCodes(const cmsMLU* mlu,\n                                          cmsUInt32Number idx,\n                                          char LanguageCode[3],\n                                          char CountryCode[3])\n{\n    _cmsMLUentry *entry;\n\n    if (mlu == NULL) return FALSE;\n\n    if (idx >= mlu->UsedEntries) return FALSE;\n\n    entry = &mlu->Entries[idx];\n    \n    strFrom16(LanguageCode, entry->Language);\n    strFrom16(CountryCode, entry->Country);\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              695,
              0
            ],
            [
              712,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUtranslationsCodes",
            "parameters": {
              "mlu": "cmsMLU",
              "idx": "cmsUInt32Number",
              "LanguageCode": "char",
              "CountryCode": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool  GrowNamedColorList(cmsNAMEDCOLORLIST* v)\n{\n    cmsUInt32Number size;\n    _cmsNAMEDCOLOR * NewPtr;\n\n    if (v == NULL) return FALSE;\n\n    if (v ->Allocated == 0)\n        size = 64;   // Initial guess\n    else\n        size = v ->Allocated * 2;\n\n    // Keep a maximum color lists can grow, 100K entries seems reasonable\n    if (size > 1024 * 100) {\n        _cmsFree(v->ContextID, (void*) v->List);\n        v->List = NULL;\n        return FALSE;\n    }\n\n    NewPtr = (_cmsNAMEDCOLOR*) _cmsRealloc(v ->ContextID, v ->List, size * sizeof(_cmsNAMEDCOLOR));\n    if (NewPtr == NULL)\n        return FALSE;\n\n    v ->List      = NewPtr;\n    v ->Allocated = size;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              718,
              0
            ],
            [
              745,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GrowNamedColorList",
            "parameters": {
              "v": "cmsNAMEDCOLORLIST"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsFreeNamedColorList(cmsNAMEDCOLORLIST* v)\n{\n    if (v == NULL) return;\n    if (v ->List) _cmsFree(v ->ContextID, v ->List);\n    _cmsFree(v ->ContextID, v);\n}",
          "fn_code_pos": [
            [
              779,
              0
            ],
            [
              784,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFreeNamedColorList",
            "parameters": {
              "v": "cmsNAMEDCOLORLIST"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT cmsAppendNamedColor(cmsNAMEDCOLORLIST* NamedColorList,\n                                       const char* Name,\n                                       cmsUInt16Number PCS[3], cmsUInt16Number Colorant[cmsMAXCHANNELS])\n{\n    cmsUInt32Number i;\n\n    if (NamedColorList == NULL) return FALSE;\n\n    if (NamedColorList ->nColors + 1 > NamedColorList ->Allocated) {\n        if (!GrowNamedColorList(NamedColorList)) return FALSE;\n    }\n\n    for (i=0; i < NamedColorList ->ColorantCount; i++)\n        NamedColorList ->List[NamedColorList ->nColors].DeviceColorant[i] = Colorant == NULL ? (cmsUInt16Number)0 : Colorant[i];\n\n    for (i=0; i < 3; i++)\n        NamedColorList ->List[NamedColorList ->nColors].PCS[i] = PCS == NULL ? (cmsUInt16Number) 0 : PCS[i];\n\n    if (Name != NULL) {\n\n        strncpy(NamedColorList ->List[NamedColorList ->nColors].Name, Name, cmsMAX_PATH-1);\n        NamedColorList ->List[NamedColorList ->nColors].Name[cmsMAX_PATH-1] = 0;\n\n    }\n    else\n        NamedColorList ->List[NamedColorList ->nColors].Name[0] = 0;\n\n\n    NamedColorList ->nColors++;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              814,
              0
            ],
            [
              844,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsAppendNamedColor",
            "parameters": {
              "NamedColorList": "cmsNAMEDCOLORLIST",
              "Name": "char",
              "PCS": "cmsUInt16Number",
              "Colorant": "cmsUInt16Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsUInt32Number CMSEXPORT cmsNamedColorCount(const cmsNAMEDCOLORLIST* NamedColorList)\n{\n     if (NamedColorList == NULL) return 0;\n     return NamedColorList ->nColors;\n}",
          "fn_code_pos": [
            [
              847,
              0
            ],
            [
              851,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsNamedColorCount",
            "parameters": {
              "NamedColorList": "cmsNAMEDCOLORLIST"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT cmsNamedColorInfo(const cmsNAMEDCOLORLIST* NamedColorList, cmsUInt32Number nColor,\n                                     char* Name,\n                                     char* Prefix,\n                                     char* Suffix,\n                                     cmsUInt16Number* PCS,\n                                     cmsUInt16Number* Colorant)\n{\n    if (NamedColorList == NULL) return FALSE;\n\n    if (nColor >= cmsNamedColorCount(NamedColorList)) return FALSE;\n\n    // strcpy instead of strncpy because many apps are using small buffers\n    if (Name) strcpy(Name, NamedColorList->List[nColor].Name);\n    if (Prefix) strcpy(Prefix, NamedColorList->Prefix);\n    if (Suffix) strcpy(Suffix, NamedColorList->Suffix);\n    if (PCS)\n        memmove(PCS, NamedColorList ->List[nColor].PCS, 3*sizeof(cmsUInt16Number));\n\n    if (Colorant)\n        memmove(Colorant, NamedColorList ->List[nColor].DeviceColorant,\n                                sizeof(cmsUInt16Number) * NamedColorList ->ColorantCount);\n\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              854,
              0
            ],
            [
              878,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsNamedColorInfo",
            "parameters": {
              "NamedColorList": "cmsNAMEDCOLORLIST",
              "nColor": "cmsUInt32Number",
              "Name": "char",
              "Prefix": "char",
              "Suffix": "char",
              "PCS": "cmsUInt16Number",
              "Colorant": "cmsUInt16Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsInt32Number CMSEXPORT cmsNamedColorIndex(const cmsNAMEDCOLORLIST* NamedColorList, const char* Name)\n{\n    cmsUInt32Number i;\n    cmsUInt32Number n;\n\n    if (NamedColorList == NULL) return -1;\n    n = cmsNamedColorCount(NamedColorList);\n    for (i=0; i < n; i++) {\n        if (cmsstrcasecmp(Name,  NamedColorList->List[i].Name) == 0)\n            return (cmsInt32Number) i;\n    }\n\n    return -1;\n}",
          "fn_code_pos": [
            [
              881,
              0
            ],
            [
              894,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsNamedColorIndex",
            "parameters": {
              "NamedColorList": "cmsNAMEDCOLORLIST",
              "Name": "char"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid FreeNamedColorList(cmsStage* mpe)\n{\n    cmsNAMEDCOLORLIST* List = (cmsNAMEDCOLORLIST*) mpe ->Data;\n    cmsFreeNamedColorList(List);\n}",
          "fn_code_pos": [
            [
              898,
              0
            ],
            [
              903,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FreeNamedColorList",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* DupNamedColorList(cmsStage* mpe)\n{\n    cmsNAMEDCOLORLIST* List = (cmsNAMEDCOLORLIST*) mpe ->Data;\n    return cmsDupNamedColorList(List);\n}",
          "fn_code_pos": [
            [
              905,
              0
            ],
            [
              910,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DupNamedColorList",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid EvalNamedColorPCS(const cmsFloat32Number In[], cmsFloat32Number Out[], const cmsStage *mpe)\n{\n    cmsNAMEDCOLORLIST* NamedColorList = (cmsNAMEDCOLORLIST*) mpe ->Data;\n    cmsUInt16Number index = (cmsUInt16Number) _cmsQuickSaturateWord(In[0] * 65535.0);\n\n    if (index >= NamedColorList-> nColors) {\n        cmsSignalError(NamedColorList ->ContextID, cmsERROR_RANGE, \"Color %d out of range\", index);\n        Out[0] = Out[1] = Out[2] = 0.0f;\n    }\n    else {\n\n            // Named color always uses Lab\n            Out[0] = (cmsFloat32Number) (NamedColorList->List[index].PCS[0] / 65535.0);\n            Out[1] = (cmsFloat32Number) (NamedColorList->List[index].PCS[1] / 65535.0);\n            Out[2] = (cmsFloat32Number) (NamedColorList->List[index].PCS[2] / 65535.0);\n    }\n}",
          "fn_code_pos": [
            [
              912,
              0
            ],
            [
              929,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EvalNamedColorPCS",
            "parameters": {
              "In": "cmsFloat32Number",
              "Out": "cmsFloat32Number",
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid EvalNamedColor(const cmsFloat32Number In[], cmsFloat32Number Out[], const cmsStage *mpe)\n{\n    cmsNAMEDCOLORLIST* NamedColorList = (cmsNAMEDCOLORLIST*) mpe ->Data;\n    cmsUInt16Number index = (cmsUInt16Number) _cmsQuickSaturateWord(In[0] * 65535.0);\n    cmsUInt32Number j;\n\n    if (index >= NamedColorList-> nColors) {\n        cmsSignalError(NamedColorList ->ContextID, cmsERROR_RANGE, \"Color %d out of range\", index);\n        for (j = 0; j < NamedColorList->ColorantCount; j++)\n            Out[j] = 0.0f;\n\n    }\n    else {\n        for (j=0; j < NamedColorList ->ColorantCount; j++)\n            Out[j] = (cmsFloat32Number) (NamedColorList->List[index].DeviceColorant[j] / 65535.0);\n    }\n}",
          "fn_code_pos": [
            [
              931,
              0
            ],
            [
              948,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EvalNamedColor",
            "parameters": {
              "In": "cmsFloat32Number",
              "Out": "cmsFloat32Number",
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsFreeProfileSequenceDescription(cmsSEQ* pseq)\n{\n    cmsUInt32Number i;\n\n    if (pseq == NULL)\n        return;\n\n    if (pseq ->seq != NULL) {\n        for (i=0; i < pseq ->n; i++) {\n            if (pseq ->seq[i].Manufacturer != NULL) cmsMLUfree(pseq ->seq[i].Manufacturer);\n            if (pseq ->seq[i].Model != NULL) cmsMLUfree(pseq ->seq[i].Model);\n            if (pseq ->seq[i].Description != NULL) cmsMLUfree(pseq ->seq[i].Description);\n        }\n\n        _cmsFree(pseq ->ContextID, pseq ->seq);\n    }\n\n    _cmsFree(pseq -> ContextID, pseq);\n}",
          "fn_code_pos": [
            [
              1016,
              0
            ],
            [
              1034,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFreeProfileSequenceDescription",
            "parameters": {
              "pseq": "cmsSEQ"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsHANDLE CMSEXPORT cmsDictAlloc(cmsContext ContextID)\n{\n    _cmsDICT* dict = (_cmsDICT*) _cmsMallocZero(ContextID, sizeof(_cmsDICT));\n    if (dict == NULL) return NULL;\n\n    dict ->ContextID = ContextID;\n    return (cmsHANDLE) dict;\n\n}",
          "fn_code_pos": [
            [
              1089,
              0
            ],
            [
              1097,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDictAlloc",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "cmsHANDLE"
          }
        },
        {
          "fn_code": "void CMSEXPORT cmsDictFree(cmsHANDLE hDict)\n{\n    _cmsDICT* dict = (_cmsDICT*) hDict;\n    cmsDICTentry *entry, *next;\n\n    _cmsAssert(dict != NULL);\n\n    // Walk the list freeing all nodes\n    entry = dict ->head;\n    while (entry != NULL) {\n\n            if (entry ->DisplayName  != NULL) cmsMLUfree(entry ->DisplayName);\n            if (entry ->DisplayValue != NULL) cmsMLUfree(entry ->DisplayValue);\n            if (entry ->Name != NULL) _cmsFree(dict ->ContextID, entry -> Name);\n            if (entry ->Value != NULL) _cmsFree(dict ->ContextID, entry -> Value);\n\n            // Don't fall in the habitual trap...\n            next = entry ->Next;\n            _cmsFree(dict ->ContextID, entry);\n\n            entry = next;\n    }\n\n    _cmsFree(dict ->ContextID, dict);\n}",
          "fn_code_pos": [
            [
              1100,
              0
            ],
            [
              1124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDictFree",
            "parameters": {
              "hDict": "cmsHANDLE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nwchar_t* DupWcs(cmsContext ContextID, const wchar_t* ptr)\n{\n    if (ptr == NULL) return NULL;\n    return (wchar_t*) _cmsDupMem(ContextID, ptr, (mywcslen(ptr) + 1) * sizeof(wchar_t));\n}",
          "fn_code_pos": [
            [
              1128,
              0
            ],
            [
              1133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DupWcs",
            "parameters": {
              "ContextID": "cmsContext",
              "ptr": "wchar_t"
            },
            "return_type": "wchar_t"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsDictAddEntry(cmsHANDLE hDict, const wchar_t* Name, const wchar_t* Value, const cmsMLU *DisplayName, const cmsMLU *DisplayValue)\n{\n    _cmsDICT* dict = (_cmsDICT*) hDict;\n    cmsDICTentry *entry;\n\n    _cmsAssert(dict != NULL);\n    _cmsAssert(Name != NULL);\n\n    entry = (cmsDICTentry*) _cmsMallocZero(dict ->ContextID, sizeof(cmsDICTentry));\n    if (entry == NULL) return FALSE;\n\n    entry ->DisplayName  = cmsMLUdup(DisplayName);\n    entry ->DisplayValue = cmsMLUdup(DisplayValue);\n    entry ->Name         = DupWcs(dict ->ContextID, Name);\n    entry ->Value        = DupWcs(dict ->ContextID, Value);\n\n    entry ->Next = dict ->head;\n    dict ->head = entry;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1136,
              0
            ],
            [
              1156,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDictAddEntry",
            "parameters": {
              "hDict": "cmsHANDLE",
              "Name": "wchar_t",
              "Value": "wchar_t",
              "DisplayName": "cmsMLU",
              "DisplayValue": "cmsMLU"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsHANDLE CMSEXPORT cmsDictDup(cmsHANDLE hDict)\n{\n    _cmsDICT* old_dict = (_cmsDICT*) hDict;\n    cmsHANDLE hNew;\n    cmsDICTentry *entry;\n\n    _cmsAssert(old_dict != NULL);\n\n    hNew  = cmsDictAlloc(old_dict ->ContextID);\n    if (hNew == NULL) return NULL;\n\n    // Walk the list freeing all nodes\n    entry = old_dict ->head;\n    while (entry != NULL) {\n\n        if (!cmsDictAddEntry(hNew, entry ->Name, entry ->Value, entry ->DisplayName, entry ->DisplayValue)) {\n\n            cmsDictFree(hNew);\n            return NULL;\n        }\n\n        entry = entry -> Next;\n    }\n\n    return hNew;\n}",
          "fn_code_pos": [
            [
              1160,
              0
            ],
            [
              1185,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDictDup",
            "parameters": {
              "hDict": "cmsHANDLE"
            },
            "return_type": "cmsHANDLE"
          }
        },
        {
          "fn_code": "const cmsDICTentry* CMSEXPORT cmsDictGetEntryList(cmsHANDLE hDict)\n{\n    _cmsDICT* dict = (_cmsDICT*) hDict;\n\n    if (dict == NULL) return NULL;\n    return dict ->head;\n}",
          "fn_code_pos": [
            [
              1188,
              0
            ],
            [
              1194,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDictGetEntryList",
            "parameters": {
              "hDict": "cmsHANDLE"
            },
            "return_type": "cmsDICTentry"
          }
        },
        {
          "fn_code": "const cmsDICTentry* CMSEXPORT cmsDictNextEntry(const cmsDICTentry* e)\n{\n     if (e == NULL) return NULL;\n     return e ->Next;\n}",
          "fn_code_pos": [
            [
              1197,
              0
            ],
            [
              1201,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDictNextEntry",
            "parameters": {
              "e": "cmsDICTentry"
            },
            "return_type": "cmsDICTentry"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "_cmsMLUgetWide(const cmsMLU* mlu,\n                              cmsUInt32Number *len,\n                              cmsUInt16Number LanguageCode, cmsUInt16Number CountryCode,\n                              cmsUInt16Number* UsedLanguageCode, cmsUInt16Number* UsedCountryCode)",
          "fn_dec_pos": [
            [
              490,
              15
            ],
            [
              493,
              98
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMLUgetWide",
            "parameters": {
              "mlu": "cmsMLU",
              "len": "cmsUInt32Number",
              "LanguageCode": "cmsUInt16Number",
              "CountryCode": "cmsUInt16Number",
              "UsedLanguageCode": "cmsUInt16Number",
              "UsedCountryCode": "cmsUInt16Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DupNamedColorList(cmsStage* mpe)",
          "fn_dec_pos": [
            [
              906,
              6
            ],
            [
              906,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DupNamedColorList",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DupWcs(cmsContext ContextID, const wchar_t* ptr)",
          "fn_dec_pos": [
            [
              1129,
              9
            ],
            [
              1129,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DupWcs",
            "parameters": {
              "ContextID": "cmsContext",
              "ptr": "wchar_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsDictGetEntryList(cmsHANDLE hDict)",
          "fn_dec_pos": [
            [
              1188,
              30
            ],
            [
              1188,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDictGetEntryList",
            "parameters": {
              "hDict": "cmsHANDLE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsDictNextEntry(const cmsDICTentry* e)",
          "fn_dec_pos": [
            [
              1197,
              30
            ],
            [
              1197,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDictNextEntry",
            "parameters": {
              "e": "cmsDICTentry"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct _cmsDICT_struct {\n    cmsDICTentry* head;\n    cmsContext ContextID;\n} _cmsDICT;",
          {
            "* head": "cmsDICTentry",
            "ContextID": "cmsContext"
          },
          "_cmsDICT",
          [
            1082,
            0
          ],
          [
            1085,
            11
          ]
        ],
        [
          "typedef struct _cmsDICT_struct {\n    cmsDICTentry* head;\n    cmsContext ContextID;\n} _cmsDICT;",
          {
            "* head": "cmsDICTentry",
            "ContextID": "cmsContext"
          },
          "_cmsDICT",
          [
            1082,
            0
          ],
          [
            1085,
            11
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmswtpnt.c": {
      "fn_def_list": [
        {
          "fn_code": "const cmsCIEXYZ* CMSEXPORT cmsD50_XYZ(void)\n{\n    static cmsCIEXYZ D50XYZ = {cmsD50X, cmsD50Y, cmsD50Z};\n\n    return &D50XYZ;\n}",
          "fn_code_pos": [
            [
              30,
              0
            ],
            [
              35,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsD50_XYZ",
            "parameters": {},
            "return_type": "cmsCIEXYZ"
          }
        },
        {
          "fn_code": "const cmsCIExyY* CMSEXPORT cmsD50_xyY(void)\n{\n    static cmsCIExyY D50xyY;\n\n    cmsXYZ2xyY(&D50xyY, cmsD50_XYZ());\n\n    return &D50xyY;\n}",
          "fn_code_pos": [
            [
              37,
              0
            ],
            [
              44,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsD50_xyY",
            "parameters": {},
            "return_type": "cmsCIExyY"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT cmsWhitePointFromTemp(cmsCIExyY* WhitePoint, cmsFloat64Number TempK)\n{\n    cmsFloat64Number x, y;\n    cmsFloat64Number T, T2, T3;\n    // cmsFloat64Number M1, M2;\n\n    _cmsAssert(WhitePoint != NULL);\n\n    T = TempK;\n    T2 = T*T;            // Square\n    T3 = T2*T;           // Cube\n\n    // For correlated color temperature (T) between 4000K and 7000K:\n\n    if (T >= 4000. && T <= 7000.)\n    {\n        x = -4.6070*(1E9/T3) + 2.9678*(1E6/T2) + 0.09911*(1E3/T) + 0.244063;\n    }\n    else\n        // or for correlated color temperature (T) between 7000K and 25000K:\n\n        if (T > 7000.0 && T <= 25000.0)\n        {\n            x = -2.0064*(1E9/T3) + 1.9018*(1E6/T2) + 0.24748*(1E3/T) + 0.237040;\n        }\n        else {\n            cmsSignalError(0, cmsERROR_RANGE, \"cmsWhitePointFromTemp: invalid temp\");\n            return FALSE;\n        }\n\n    // Obtain y(x)\n    y = -3.000*(x*x) + 2.870*x - 0.275;\n\n    // wave factors (not used, but here for futures extensions)\n\n    // M1 = (-1.3515 - 1.7703*x + 5.9114 *y)/(0.0241 + 0.2562*x - 0.7341*y);\n    // M2 = (0.0300 - 31.4424*x + 30.0717*y)/(0.0241 + 0.2562*x - 0.7341*y);\n\n    WhitePoint -> x = x;\n    WhitePoint -> y = y;\n    WhitePoint -> Y = 1.0;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              90,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsWhitePointFromTemp",
            "parameters": {
              "WhitePoint": "cmsCIExyY",
              "TempK": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool  CMSEXPORT cmsTempFromWhitePoint(cmsFloat64Number* TempK, const cmsCIExyY* WhitePoint)\n{\n    cmsUInt32Number j;\n    cmsFloat64Number us,vs;\n    cmsFloat64Number uj,vj,tj,di,dj,mi,mj;\n    cmsFloat64Number xs, ys;\n\n    _cmsAssert(WhitePoint != NULL);\n    _cmsAssert(TempK != NULL);\n\n    di = mi = 0;\n    xs = WhitePoint -> x;\n    ys = WhitePoint -> y;\n\n    // convert (x,y) to CIE 1960 (u,WhitePoint)\n\n    us = (2*xs) / (-xs + 6*ys + 1.5);\n    vs = (3*ys) / (-xs + 6*ys + 1.5);\n\n\n    for (j=0; j < NISO; j++) {\n\n        uj = isotempdata[j].ut;\n        vj = isotempdata[j].vt;\n        tj = isotempdata[j].tt;\n        mj = isotempdata[j].mirek;\n\n        dj = ((vs - vj) - tj * (us - uj)) / sqrt(1.0 + tj * tj);\n\n        if ((j != 0) && (di/dj < 0.0)) {\n\n            // Found a match\n            *TempK = 1000000.0 / (mi + (di / (di - dj)) * (mj - mi));\n            return TRUE;\n        }\n\n        di = dj;\n        mi = mj;\n    }\n\n    // Not found\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              142,
              0
            ],
            [
              184,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsTempFromWhitePoint",
            "parameters": {
              "TempK": "cmsFloat64Number",
              "WhitePoint": "cmsCIExyY"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool ComputeChromaticAdaptation(cmsMAT3* Conversion,\n                                const cmsCIEXYZ* SourceWhitePoint,\n                                const cmsCIEXYZ* DestWhitePoint,\n                                const cmsMAT3* Chad)\n\n{\n\n    cmsMAT3 Chad_Inv;\n    cmsVEC3 ConeSourceXYZ, ConeSourceRGB;\n    cmsVEC3 ConeDestXYZ, ConeDestRGB;\n    cmsMAT3 Cone, Tmp;\n\n\n    Tmp = *Chad;\n    if (!_cmsMAT3inverse(&Tmp, &Chad_Inv)) return FALSE;\n\n    _cmsVEC3init(&ConeSourceXYZ, SourceWhitePoint -> X,\n                             SourceWhitePoint -> Y,\n                             SourceWhitePoint -> Z);\n\n    _cmsVEC3init(&ConeDestXYZ,   DestWhitePoint -> X,\n                             DestWhitePoint -> Y,\n                             DestWhitePoint -> Z);\n\n    _cmsMAT3eval(&ConeSourceRGB, Chad, &ConeSourceXYZ);\n    _cmsMAT3eval(&ConeDestRGB,   Chad, &ConeDestXYZ);\n\n    if ((fabs(ConeSourceRGB.n[0]) < MATRIX_DET_TOLERANCE) ||\n        (fabs(ConeSourceRGB.n[1]) < MATRIX_DET_TOLERANCE) ||\n        (fabs(ConeSourceRGB.n[2]) < MATRIX_DET_TOLERANCE)) return FALSE;\n\n    // Build matrix\n    _cmsVEC3init(&Cone.v[0], ConeDestRGB.n[0]/ConeSourceRGB.n[0],    0.0,  0.0);\n    _cmsVEC3init(&Cone.v[1], 0.0,   ConeDestRGB.n[1]/ConeSourceRGB.n[1],   0.0);\n    _cmsVEC3init(&Cone.v[2], 0.0,   0.0,   ConeDestRGB.n[2]/ConeSourceRGB.n[2]);\n\n    // Normalize\n    _cmsMAT3per(&Tmp, &Cone, Chad);\n    _cmsMAT3per(Conversion, &Chad_Inv, &Tmp);\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              189,
              0
            ],
            [
              231,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ComputeChromaticAdaptation",
            "parameters": {
              "Conversion": "cmsMAT3",
              "SourceWhitePoint": "cmsCIEXYZ",
              "DestWhitePoint": "cmsCIEXYZ",
              "Chad": "cmsMAT3"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool  _cmsAdaptationMatrix(cmsMAT3* r, const cmsMAT3* ConeMatrix, const cmsCIEXYZ* FromIll, const cmsCIEXYZ* ToIll)\n{\n    cmsMAT3 LamRigg   = {{ // Bradford matrix\n        {{  0.8951,  0.2664, -0.1614 }},\n        {{ -0.7502,  1.7135,  0.0367 }},\n        {{  0.0389, -0.0685,  1.0296 }}\n    }};\n\n    if (ConeMatrix == NULL)\n        ConeMatrix = &LamRigg;\n\n    return ComputeChromaticAdaptation(r, FromIll, ToIll, ConeMatrix);\n}",
          "fn_code_pos": [
            [
              235,
              0
            ],
            [
              247,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAdaptationMatrix",
            "parameters": {
              "r": "cmsMAT3",
              "ConeMatrix": "cmsMAT3",
              "FromIll": "cmsCIEXYZ",
              "ToIll": "cmsCIEXYZ"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool _cmsAdaptMatrixToD50(cmsMAT3* r, const cmsCIExyY* SourceWhitePt)\n{\n    cmsCIEXYZ Dn;\n    cmsMAT3 Bradford;\n    cmsMAT3 Tmp;\n\n    cmsxyY2XYZ(&Dn, SourceWhitePt);\n\n    if (!_cmsAdaptationMatrix(&Bradford, NULL, &Dn, cmsD50_XYZ())) return FALSE;\n\n    Tmp = *r;\n    _cmsMAT3per(r, &Bradford, &Tmp);\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              250,
              0
            ],
            [
              265,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAdaptMatrixToD50",
            "parameters": {
              "r": "cmsMAT3",
              "SourceWhitePt": "cmsCIExyY"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool _cmsBuildRGB2XYZtransferMatrix(cmsMAT3* r, const cmsCIExyY* WhitePt, const cmsCIExyYTRIPLE* Primrs)\n{\n    cmsVEC3 WhitePoint, Coef;\n    cmsMAT3 Result, Primaries;\n    cmsFloat64Number xn, yn;\n    cmsFloat64Number xr, yr;\n    cmsFloat64Number xg, yg;\n    cmsFloat64Number xb, yb;\n\n    xn = WhitePt -> x;\n    yn = WhitePt -> y;\n    xr = Primrs -> Red.x;\n    yr = Primrs -> Red.y;\n    xg = Primrs -> Green.x;\n    yg = Primrs -> Green.y;\n    xb = Primrs -> Blue.x;\n    yb = Primrs -> Blue.y;\n\n    // Build Primaries matrix\n    _cmsVEC3init(&Primaries.v[0], xr,        xg,         xb);\n    _cmsVEC3init(&Primaries.v[1], yr,        yg,         yb);\n    _cmsVEC3init(&Primaries.v[2], (1-xr-yr), (1-xg-yg),  (1-xb-yb));\n\n\n    // Result = Primaries ^ (-1) inverse matrix\n    if (!_cmsMAT3inverse(&Primaries, &Result))\n        return FALSE;\n\n\n    _cmsVEC3init(&WhitePoint, xn/yn, 1.0, (1.0-xn-yn)/yn);\n\n    // Across inverse primaries ...\n    _cmsMAT3eval(&Coef, &Result, &WhitePoint);\n\n    // Give us the Coefs, then I build transformation matrix\n    _cmsVEC3init(&r -> v[0], Coef.n[VX]*xr,          Coef.n[VY]*xg,          Coef.n[VZ]*xb);\n    _cmsVEC3init(&r -> v[1], Coef.n[VX]*yr,          Coef.n[VY]*yg,          Coef.n[VZ]*yb);\n    _cmsVEC3init(&r -> v[2], Coef.n[VX]*(1.0-xr-yr), Coef.n[VY]*(1.0-xg-yg), Coef.n[VZ]*(1.0-xb-yb));\n\n\n    return _cmsAdaptMatrixToD50(r, WhitePt);\n\n}",
          "fn_code_pos": [
            [
              280,
              0
            ],
            [
              322,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsBuildRGB2XYZtransferMatrix",
            "parameters": {
              "r": "cmsMAT3",
              "WhitePt": "cmsCIExyY",
              "Primrs": "cmsCIExyYTRIPLE"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool CMSEXPORT cmsAdaptToIlluminant(cmsCIEXYZ* Result,\n                                       const cmsCIEXYZ* SourceWhitePt,\n                                       const cmsCIEXYZ* Illuminant,\n                                       const cmsCIEXYZ* Value)\n{\n    cmsMAT3 Bradford;\n    cmsVEC3 In, Out;\n\n    _cmsAssert(Result != NULL);\n    _cmsAssert(SourceWhitePt != NULL);\n    _cmsAssert(Illuminant != NULL);\n    _cmsAssert(Value != NULL);\n\n    if (!_cmsAdaptationMatrix(&Bradford, NULL, SourceWhitePt, Illuminant)) return FALSE;\n\n    _cmsVEC3init(&In, Value -> X, Value -> Y, Value -> Z);\n    _cmsMAT3eval(&Out, &Bradford, &In);\n\n    Result -> X = Out.n[0];\n    Result -> Y = Out.n[1];\n    Result -> Z = Out.n[2];\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              327,
              0
            ],
            [
              350,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsAdaptToIlluminant",
            "parameters": {
              "Result": "cmsCIEXYZ",
              "SourceWhitePt": "cmsCIEXYZ",
              "Illuminant": "cmsCIEXYZ",
              "Value": "cmsCIEXYZ"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "cmsD50_XYZ(void)",
          "fn_dec_pos": [
            [
              30,
              27
            ],
            [
              30,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsD50_XYZ",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "cmsD50_xyY(void)",
          "fn_dec_pos": [
            [
              37,
              27
            ],
            [
              37,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsD50_xyY",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\n    cmsFloat64Number mirek;  // temp (in microreciprocal kelvin)\n    cmsFloat64Number ut;     // u coord of intersection w/ blackbody locus\n    cmsFloat64Number vt;     // v coord of intersection w/ blackbody locus\n    cmsFloat64Number tt;     // slope of ISOTEMPERATURE. line\n\n    } ISOTEMPERATURE;",
          {
            "mirek": "cmsFloat64Number",
            "ut": "cmsFloat64Number",
            "vt": "cmsFloat64Number",
            "tt": "cmsFloat64Number"
          },
          "ISOTEMPERATURE",
          [
            94,
            0
          ],
          [
            101,
            21
          ]
        ],
        [
          "typedef struct {\n\n    cmsFloat64Number mirek;  // temp (in microreciprocal kelvin)\n    cmsFloat64Number ut;     // u coord of intersection w/ blackbody locus\n    cmsFloat64Number vt;     // v coord of intersection w/ blackbody locus\n    cmsFloat64Number tt;     // slope of ISOTEMPERATURE. line\n\n    } ISOTEMPERATURE;",
          {
            "mirek": "cmsFloat64Number",
            "ut": "cmsFloat64Number",
            "vt": "cmsFloat64Number",
            "tt": "cmsFloat64Number"
          },
          "ISOTEMPERATURE",
          [
            94,
            0
          ],
          [
            101,
            21
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/cmsintrp.c": {
      "fn_def_list": [
        {
          "fn_code": "void _cmsAllocInterpPluginChunk(struct _cmsContext_struct* ctx, const struct _cmsContext_struct* src)\n{\n    void* from;\n\n    _cmsAssert(ctx != NULL);\n\n    if (src != NULL) {\n        from = src ->chunks[InterpPlugin];       \n    }\n    else { \n        static _cmsInterpPluginChunkType InterpPluginChunk = { NULL };\n\n        from = &InterpPluginChunk;\n    }\n\n    _cmsAssert(from != NULL);\n    ctx ->chunks[InterpPlugin] = _cmsSubAllocDup(ctx ->MemPool, from, sizeof(_cmsInterpPluginChunkType));\n}",
          "fn_code_pos": [
            [
              45,
              0
            ],
            [
              62,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocInterpPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool  _cmsRegisterInterpPlugin(cmsContext ContextID, cmsPluginBase* Data)\n{\n    cmsPluginInterpolation* Plugin = (cmsPluginInterpolation*) Data;\n    _cmsInterpPluginChunkType* ptr = (_cmsInterpPluginChunkType*) _cmsContextGetClientChunk(ContextID, InterpPlugin);\n\n    if (Data == NULL) {\n\n        ptr ->Interpolators = NULL;\n        return TRUE;\n    }\n\n    // Set replacement functions\n    ptr ->Interpolators = Plugin ->InterpolatorsFactory;\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              80,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterInterpPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Data": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool _cmsSetInterpolationRoutine(cmsContext ContextID, cmsInterpParams* p)\n{      \n    _cmsInterpPluginChunkType* ptr = (_cmsInterpPluginChunkType*) _cmsContextGetClientChunk(ContextID, InterpPlugin);\n\n    p ->Interpolation.Lerp16 = NULL;\n\n   // Invoke factory, possibly in the Plug-in\n    if (ptr ->Interpolators != NULL)\n        p ->Interpolation = ptr->Interpolators(p -> nInputs, p ->nOutputs, p ->dwFlags);\n    \n    // If unsupported by the plug-in, go for the LittleCMS default.\n    // If happens only if an extern plug-in is being used\n    if (p ->Interpolation.Lerp16 == NULL)\n        p ->Interpolation = DefaultInterpolatorsFactory(p ->nInputs, p ->nOutputs, p ->dwFlags);\n\n    // Check for valid interpolator (we just check one member of the union)\n    if (p ->Interpolation.Lerp16 == NULL) {\n            return FALSE;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsSetInterpolationRoutine",
            "parameters": {
              "ContextID": "cmsContext",
              "p": "cmsInterpParams"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsInterpParams* _cmsComputeInterpParamsEx(cmsContext ContextID,\n                                           const cmsUInt32Number nSamples[],\n                                           cmsUInt32Number InputChan, cmsUInt32Number OutputChan,\n                                           const void *Table,\n                                           cmsUInt32Number dwFlags)\n{\n    cmsInterpParams* p;\n    cmsUInt32Number i;\n\n    // Check for maximum inputs\n    if (InputChan > MAX_INPUT_DIMENSIONS) {\n             cmsSignalError(ContextID, cmsERROR_RANGE, \"Too many input channels (%d channels, max=%d)\", InputChan, MAX_INPUT_DIMENSIONS);\n            return NULL;\n    }\n\n    // Creates an empty object\n    p = (cmsInterpParams*) _cmsMallocZero(ContextID, sizeof(cmsInterpParams));\n    if (p == NULL) return NULL;\n\n    // Keep original parameters\n    p -> dwFlags  = dwFlags;\n    p -> nInputs  = InputChan;\n    p -> nOutputs = OutputChan;\n    p ->Table     = Table;\n    p ->ContextID  = ContextID;\n\n    // Fill samples per input direction and domain (which is number of nodes minus one)\n    for (i=0; i < InputChan; i++) {\n\n        p -> nSamples[i] = nSamples[i];\n        p -> Domain[i]   = nSamples[i] - 1;\n    }\n\n    // Compute factors to apply to each component to index the grid array\n    p -> opta[0] = p -> nOutputs;\n    for (i=1; i < InputChan; i++)\n        p ->opta[i] = p ->opta[i-1] * nSamples[InputChan-i];\n\n\n    if (!_cmsSetInterpolationRoutine(ContextID, p)) {\n         cmsSignalError(ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Unsupported interpolation (%d->%d channels)\", InputChan, OutputChan);\n        _cmsFree(ContextID, p);\n        return NULL;\n    }\n\n    // All seems ok\n    return p;\n}",
          "fn_code_pos": [
            [
              109,
              0
            ],
            [
              156,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsComputeInterpParamsEx",
            "parameters": {
              "ContextID": "cmsContext",
              "nSamples": "cmsUInt32Number",
              "InputChan": "cmsUInt32Number",
              "OutputChan": "cmsUInt32Number",
              "Table": "void",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsInterpParams"
          }
        },
        {
          "fn_code": "void CMSEXPORT _cmsFreeInterpParams(cmsInterpParams* p)\n{\n    if (p != NULL) _cmsFree(p ->ContextID, p);\n}",
          "fn_code_pos": [
            [
              176,
              0
            ],
            [
              179,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsFreeInterpParams",
            "parameters": {
              "p": "cmsInterpParams"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsINLINE CMS_NO_SANITIZE cmsUInt16Number LinearInterp(cmsS15Fixed16Number a, cmsS15Fixed16Number l, cmsS15Fixed16Number h)\n{\n    cmsUInt32Number dif = (cmsUInt32Number) (h - l) * a + 0x8000;\n    dif = (dif >> 16) + l;\n    return (cmsUInt16Number) (dif);\n}",
          "fn_code_pos": [
            [
              183,
              0
            ],
            [
              188,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LinearInterp",
            "parameters": {
              "a": "cmsS15Fixed16Number",
              "l": "cmsS15Fixed16Number",
              "h": "cmsS15Fixed16Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "static\nvoid LinLerp1D(CMSREGISTER const cmsUInt16Number Value[],\n               CMSREGISTER cmsUInt16Number Output[],\n               CMSREGISTER const cmsInterpParams* p)\n{\n    cmsUInt16Number y1, y0;\n    int cell0, rest;\n    int val3;\n    const cmsUInt16Number* LutTable = (cmsUInt16Number*) p ->Table;\n\n    // if last value or just one point\n    if (Value[0] == 0xffff || p->Domain[0] == 0) {\n\n        Output[0] = LutTable[p -> Domain[0]];      \n    }\n    else\n    {\n        val3 = p->Domain[0] * Value[0];\n        val3 = _cmsToFixedDomain(val3);    // To fixed 15.16\n\n        cell0 = FIXED_TO_INT(val3);             // Cell is 16 MSB bits\n        rest = FIXED_REST_TO_INT(val3);        // Rest is 16 LSB bits\n\n        y0 = LutTable[cell0];\n        y1 = LutTable[cell0 + 1];\n\n        Output[0] = LinearInterp(rest, y0, y1);\n    }\n}",
          "fn_code_pos": [
            [
              192,
              0
            ],
            [
              220,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LinLerp1D",
            "parameters": {
              "Value": "CMSREGISTER",
              "Output": "CMSREGISTER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsINLINE cmsFloat32Number fclamp(cmsFloat32Number v) \n{\n    return ((v < 1.0e-9f) || isnan(v)) ? 0.0f : (v > 1.0f ? 1.0f : v);\n}",
          "fn_code_pos": [
            [
              223,
              0
            ],
            [
              226,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFloat32Number fclamp",
            "parameters": {
              "v": "cmsFloat32Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "static\nvoid LinLerp1Dfloat(const cmsFloat32Number Value[],\n                    cmsFloat32Number Output[],\n                    const cmsInterpParams* p)\n{\n       cmsFloat32Number y1, y0;\n       cmsFloat32Number val2, rest;\n       int cell0, cell1;\n       const cmsFloat32Number* LutTable = (cmsFloat32Number*) p ->Table;\n\n       val2 = fclamp(Value[0]);\n\n       // if last value...\n       if (val2 == 1.0 || p->Domain[0] == 0) {\n           Output[0] = LutTable[p -> Domain[0]];          \n       }\n       else\n       {\n           val2 *= p->Domain[0];\n\n           cell0 = (int)floor(val2);\n           cell1 = (int)ceil(val2);\n\n           // Rest is 16 LSB bits\n           rest = val2 - cell0;\n\n           y0 = LutTable[cell0];\n           y1 = LutTable[cell1];\n\n           Output[0] = y0 + (y1 - y0) * rest;\n       }\n}",
          "fn_code_pos": [
            [
              229,
              0
            ],
            [
              260,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LinLerp1Dfloat",
            "parameters": {
              "Value": "cmsFloat32Number",
              "Output": "cmsFloat32Number",
              "p": "cmsInterpParams"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static CMS_NO_SANITIZE\nvoid Eval1Input(CMSREGISTER const cmsUInt16Number Input[],\n                CMSREGISTER cmsUInt16Number Output[],\n                CMSREGISTER const cmsInterpParams* p16)\n{\n       cmsS15Fixed16Number fk;\n       cmsS15Fixed16Number k0, k1, rk, K0, K1;\n       int v;\n       cmsUInt32Number OutChan;\n       const cmsUInt16Number* LutTable = (cmsUInt16Number*) p16 -> Table;\n\n\n       // if last value...\n       if (Input[0] == 0xffff || p16->Domain[0] == 0) {\n\n           cmsUInt32Number y0 = p16->Domain[0] * p16->opta[0];\n           \n           for (OutChan = 0; OutChan < p16->nOutputs; OutChan++) {\n               Output[OutChan] = LutTable[y0 + OutChan];\n           }\n       }\n       else\n       {\n\n           v = Input[0] * p16->Domain[0];\n           fk = _cmsToFixedDomain(v);\n\n           k0 = FIXED_TO_INT(fk);\n           rk = (cmsUInt16Number)FIXED_REST_TO_INT(fk);\n\n           k1 = k0 + (Input[0] != 0xFFFFU ? 1 : 0);\n\n           K0 = p16->opta[0] * k0;\n           K1 = p16->opta[0] * k1;\n\n           for (OutChan = 0; OutChan < p16->nOutputs; OutChan++) {\n\n               Output[OutChan] = LinearInterp(rk, LutTable[K0 + OutChan], LutTable[K1 + OutChan]);\n           }\n       }\n}",
          "fn_code_pos": [
            [
              265,
              0
            ],
            [
              305,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Eval1Input",
            "parameters": {
              "Input": "CMSREGISTER",
              "Output": "CMSREGISTER"
            },
            "return_type": "CMS_NO_SANITIZE"
          }
        },
        {
          "fn_code": "static\nvoid Eval1InputFloat(const cmsFloat32Number Value[],\n                     cmsFloat32Number Output[],\n                     const cmsInterpParams* p)\n{\n    cmsFloat32Number y1, y0;\n    cmsFloat32Number val2, rest;\n    int cell0, cell1;\n    cmsUInt32Number OutChan;\n    const cmsFloat32Number* LutTable = (cmsFloat32Number*) p ->Table;\n\n    val2 = fclamp(Value[0]);\n\n    // if last value...\n    if (val2 == 1.0 || p->Domain[0] == 0) {\n\n        cmsUInt32Number start = p->Domain[0] * p->opta[0];\n\n        for (OutChan = 0; OutChan < p->nOutputs; OutChan++) {\n            Output[OutChan] = LutTable[start + OutChan];\n        }        \n    }\n    else\n    {\n        val2 *= p->Domain[0];\n\n        cell0 = (int)floor(val2);\n        cell1 = (int)ceil(val2);\n\n        // Rest is 16 LSB bits\n        rest = val2 - cell0;\n\n        cell0 *= p->opta[0];\n        cell1 *= p->opta[0];\n\n        for (OutChan = 0; OutChan < p->nOutputs; OutChan++) {\n\n            y0 = LutTable[cell0 + OutChan];\n            y1 = LutTable[cell1 + OutChan];\n\n            Output[OutChan] = y0 + (y1 - y0) * rest;\n        }\n    }\n}",
          "fn_code_pos": [
            [
              310,
              0
            ],
            [
              353,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Eval1InputFloat",
            "parameters": {
              "Value": "cmsFloat32Number",
              "Output": "cmsFloat32Number",
              "p": "cmsInterpParams"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid BilinearInterpFloat(const cmsFloat32Number Input[],\n                         cmsFloat32Number Output[],\n                         const cmsInterpParams* p)\n\n{\n#   define LERP(a,l,h)    (cmsFloat32Number) ((l)+(((h)-(l))*(a)))\n#   define DENS(i,j)      (LutTable[(i)+(j)+OutChan])\n\n    const cmsFloat32Number* LutTable = (cmsFloat32Number*) p ->Table;\n    cmsFloat32Number      px, py;\n    int        x0, y0,\n               X0, Y0, X1, Y1;\n    int        TotalOut, OutChan;\n    cmsFloat32Number      fx, fy,\n        d00, d01, d10, d11,\n        dx0, dx1,\n        dxy;\n\n    TotalOut   = p -> nOutputs;\n    px = fclamp(Input[0]) * p->Domain[0];\n    py = fclamp(Input[1]) * p->Domain[1];\n\n    x0 = (int) _cmsQuickFloor(px); fx = px - (cmsFloat32Number) x0;\n    y0 = (int) _cmsQuickFloor(py); fy = py - (cmsFloat32Number) y0;\n\n    X0 = p -> opta[1] * x0;\n    X1 = X0 + (fclamp(Input[0]) >= 1.0 ? 0 : p->opta[1]);\n\n    Y0 = p -> opta[0] * y0;\n    Y1 = Y0 + (fclamp(Input[1]) >= 1.0 ? 0 : p->opta[0]);\n\n    for (OutChan = 0; OutChan < TotalOut; OutChan++) {\n\n        d00 = DENS(X0, Y0);\n        d01 = DENS(X0, Y1);\n        d10 = DENS(X1, Y0);\n        d11 = DENS(X1, Y1);\n\n        dx0 = LERP(fx, d00, d10);\n        dx1 = LERP(fx, d01, d11);\n\n        dxy = LERP(fy, dx0, dx1);\n\n        Output[OutChan] = dxy;\n    }\n\n\n#   undef LERP\n#   undef DENS\n}",
          "fn_code_pos": [
            [
              356,
              0
            ],
            [
              406,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BilinearInterpFloat",
            "parameters": {
              "Input": "cmsFloat32Number",
              "Output": "cmsFloat32Number",
              "p": "cmsInterpParams"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static CMS_NO_SANITIZE\nvoid BilinearInterp16(CMSREGISTER const cmsUInt16Number Input[],\n                      CMSREGISTER cmsUInt16Number Output[],\n                      CMSREGISTER const cmsInterpParams* p)\n\n{\n#define DENS(i,j) (LutTable[(i)+(j)+OutChan])\n#define LERP(a,l,h)     (cmsUInt16Number) (l + ROUND_FIXED_TO_INT(((h-l)*a)))\n\n           const cmsUInt16Number* LutTable = (cmsUInt16Number*) p ->Table;\n           int        OutChan, TotalOut;\n           cmsS15Fixed16Number    fx, fy;\n           CMSREGISTER int        rx, ry;\n           int                    x0, y0;\n           CMSREGISTER int        X0, X1, Y0, Y1;\n\n           int                    d00, d01, d10, d11,\n                                  dx0, dx1,\n                                  dxy;\n\n    TotalOut   = p -> nOutputs;\n\n    fx = _cmsToFixedDomain((int) Input[0] * p -> Domain[0]);\n    x0  = FIXED_TO_INT(fx);\n    rx  = FIXED_REST_TO_INT(fx);    // Rest in 0..1.0 domain\n\n\n    fy = _cmsToFixedDomain((int) Input[1] * p -> Domain[1]);\n    y0  = FIXED_TO_INT(fy);\n    ry  = FIXED_REST_TO_INT(fy);\n\n\n    X0 = p -> opta[1] * x0;\n    X1 = X0 + (Input[0] == 0xFFFFU ? 0 : p->opta[1]);\n\n    Y0 = p -> opta[0] * y0;\n    Y1 = Y0 + (Input[1] == 0xFFFFU ? 0 : p->opta[0]);\n\n    for (OutChan = 0; OutChan < TotalOut; OutChan++) {\n\n        d00 = DENS(X0, Y0);\n        d01 = DENS(X0, Y1);\n        d10 = DENS(X1, Y0);\n        d11 = DENS(X1, Y1);\n\n        dx0 = LERP(rx, d00, d10);\n        dx1 = LERP(rx, d01, d11);\n\n        dxy = LERP(ry, dx0, dx1);\n\n        Output[OutChan] = (cmsUInt16Number) dxy;\n    }\n\n\n#   undef LERP\n#   undef DENS\n}",
          "fn_code_pos": [
            [
              409,
              0
            ],
            [
              465,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BilinearInterp16",
            "parameters": {
              "Input": "CMSREGISTER",
              "Output": "CMSREGISTER"
            },
            "return_type": "CMS_NO_SANITIZE"
          }
        },
        {
          "fn_code": "static\nvoid TrilinearInterpFloat(const cmsFloat32Number Input[],\n                          cmsFloat32Number Output[],\n                          const cmsInterpParams* p)\n\n{\n#   define LERP(a,l,h)      (cmsFloat32Number) ((l)+(((h)-(l))*(a)))\n#   define DENS(i,j,k)      (LutTable[(i)+(j)+(k)+OutChan])\n\n    const cmsFloat32Number* LutTable = (cmsFloat32Number*) p ->Table;\n    cmsFloat32Number      px, py, pz;\n    int        x0, y0, z0,\n               X0, Y0, Z0, X1, Y1, Z1;\n    int        TotalOut, OutChan;\n\n    cmsFloat32Number      fx, fy, fz,\n                          d000, d001, d010, d011,\n                          d100, d101, d110, d111,\n                          dx00, dx01, dx10, dx11,\n                          dxy0, dxy1, dxyz;\n\n    TotalOut   = p -> nOutputs;\n\n    // We need some clipping here\n    px = fclamp(Input[0]) * p->Domain[0];\n    py = fclamp(Input[1]) * p->Domain[1];\n    pz = fclamp(Input[2]) * p->Domain[2];\n\n    x0 = (int) floor(px); fx = px - (cmsFloat32Number) x0;  // We need full floor functionality here\n    y0 = (int) floor(py); fy = py - (cmsFloat32Number) y0;\n    z0 = (int) floor(pz); fz = pz - (cmsFloat32Number) z0;\n\n    X0 = p -> opta[2] * x0;\n    X1 = X0 + (fclamp(Input[0]) >= 1.0 ? 0 : p->opta[2]);\n\n    Y0 = p -> opta[1] * y0;\n    Y1 = Y0 + (fclamp(Input[1]) >= 1.0 ? 0 : p->opta[1]);\n\n    Z0 = p -> opta[0] * z0;\n    Z1 = Z0 + (fclamp(Input[2]) >= 1.0 ? 0 : p->opta[0]);\n\n    for (OutChan = 0; OutChan < TotalOut; OutChan++) {\n\n        d000 = DENS(X0, Y0, Z0);\n        d001 = DENS(X0, Y0, Z1);\n        d010 = DENS(X0, Y1, Z0);\n        d011 = DENS(X0, Y1, Z1);\n\n        d100 = DENS(X1, Y0, Z0);\n        d101 = DENS(X1, Y0, Z1);\n        d110 = DENS(X1, Y1, Z0);\n        d111 = DENS(X1, Y1, Z1);\n\n\n        dx00 = LERP(fx, d000, d100);\n        dx01 = LERP(fx, d001, d101);\n        dx10 = LERP(fx, d010, d110);\n        dx11 = LERP(fx, d011, d111);\n\n        dxy0 = LERP(fy, dx00, dx10);\n        dxy1 = LERP(fy, dx01, dx11);\n\n        dxyz = LERP(fz, dxy0, dxy1);\n\n        Output[OutChan] = dxyz;\n    }\n\n\n#   undef LERP\n#   undef DENS\n}",
          "fn_code_pos": [
            [
              469,
              0
            ],
            [
              539,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TrilinearInterpFloat",
            "parameters": {
              "Input": "cmsFloat32Number",
              "Output": "cmsFloat32Number",
              "p": "cmsInterpParams"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static CMS_NO_SANITIZE\nvoid TrilinearInterp16(CMSREGISTER const cmsUInt16Number Input[],\n                       CMSREGISTER cmsUInt16Number Output[],\n                       CMSREGISTER const cmsInterpParams* p)\n\n{\n#define DENS(i,j,k) (LutTable[(i)+(j)+(k)+OutChan])\n#define LERP(a,l,h)     (cmsUInt16Number) (l + ROUND_FIXED_TO_INT(((h-l)*a)))\n\n           const cmsUInt16Number* LutTable = (cmsUInt16Number*) p ->Table;\n           int        OutChan, TotalOut;\n           cmsS15Fixed16Number    fx, fy, fz;\n           CMSREGISTER int        rx, ry, rz;\n           int                    x0, y0, z0;\n           CMSREGISTER int        X0, X1, Y0, Y1, Z0, Z1;\n           int                    d000, d001, d010, d011,\n                                  d100, d101, d110, d111,\n                                  dx00, dx01, dx10, dx11,\n                                  dxy0, dxy1, dxyz;\n\n    TotalOut   = p -> nOutputs;\n\n    fx = _cmsToFixedDomain((int) Input[0] * p -> Domain[0]);\n    x0  = FIXED_TO_INT(fx);\n    rx  = FIXED_REST_TO_INT(fx);    // Rest in 0..1.0 domain\n\n\n    fy = _cmsToFixedDomain((int) Input[1] * p -> Domain[1]);\n    y0  = FIXED_TO_INT(fy);\n    ry  = FIXED_REST_TO_INT(fy);\n\n    fz = _cmsToFixedDomain((int) Input[2] * p -> Domain[2]);\n    z0 = FIXED_TO_INT(fz);\n    rz = FIXED_REST_TO_INT(fz);\n\n\n    X0 = p -> opta[2] * x0;\n    X1 = X0 + (Input[0] == 0xFFFFU ? 0 : p->opta[2]);\n\n    Y0 = p -> opta[1] * y0;\n    Y1 = Y0 + (Input[1] == 0xFFFFU ? 0 : p->opta[1]);\n\n    Z0 = p -> opta[0] * z0;\n    Z1 = Z0 + (Input[2] == 0xFFFFU ? 0 : p->opta[0]);\n\n    for (OutChan = 0; OutChan < TotalOut; OutChan++) {\n\n        d000 = DENS(X0, Y0, Z0);\n        d001 = DENS(X0, Y0, Z1);\n        d010 = DENS(X0, Y1, Z0);\n        d011 = DENS(X0, Y1, Z1);\n\n        d100 = DENS(X1, Y0, Z0);\n        d101 = DENS(X1, Y0, Z1);\n        d110 = DENS(X1, Y1, Z0);\n        d111 = DENS(X1, Y1, Z1);\n\n\n        dx00 = LERP(rx, d000, d100);\n        dx01 = LERP(rx, d001, d101);\n        dx10 = LERP(rx, d010, d110);\n        dx11 = LERP(rx, d011, d111);\n\n        dxy0 = LERP(ry, dx00, dx10);\n        dxy1 = LERP(ry, dx01, dx11);\n\n        dxyz = LERP(rz, dxy0, dxy1);\n\n        Output[OutChan] = (cmsUInt16Number) dxyz;\n    }\n\n\n#   undef LERP\n#   undef DENS\n}",
          "fn_code_pos": [
            [
              542,
              0
            ],
            [
              616,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TrilinearInterp16",
            "parameters": {
              "Input": "CMSREGISTER",
              "Output": "CMSREGISTER"
            },
            "return_type": "CMS_NO_SANITIZE"
          }
        },
        {
          "fn_code": "static\nvoid TetrahedralInterpFloat(const cmsFloat32Number Input[],\n                            cmsFloat32Number Output[],\n                            const cmsInterpParams* p)\n{\n    const cmsFloat32Number* LutTable = (cmsFloat32Number*) p -> Table;\n    cmsFloat32Number     px, py, pz;\n    int                  x0, y0, z0,\n                         X0, Y0, Z0, X1, Y1, Z1;\n    cmsFloat32Number     rx, ry, rz;\n    cmsFloat32Number     c0, c1=0, c2=0, c3=0;\n    int                  OutChan, TotalOut;\n\n    TotalOut   = p -> nOutputs;\n\n    // We need some clipping here\n    px = fclamp(Input[0]) * p->Domain[0];\n    py = fclamp(Input[1]) * p->Domain[1];\n    pz = fclamp(Input[2]) * p->Domain[2];\n\n    x0 = (int) floor(px); rx = (px - (cmsFloat32Number) x0);  // We need full floor functionality here\n    y0 = (int) floor(py); ry = (py - (cmsFloat32Number) y0);\n    z0 = (int) floor(pz); rz = (pz - (cmsFloat32Number) z0);\n\n\n    X0 = p -> opta[2] * x0;\n    X1 = X0 + (fclamp(Input[0]) >= 1.0 ? 0 : p->opta[2]);\n\n    Y0 = p -> opta[1] * y0;\n    Y1 = Y0 + (fclamp(Input[1]) >= 1.0 ? 0 : p->opta[1]);\n\n    Z0 = p -> opta[0] * z0;\n    Z1 = Z0 + (fclamp(Input[2]) >= 1.0 ? 0 : p->opta[0]);\n\n    for (OutChan=0; OutChan < TotalOut; OutChan++) {\n\n       // These are the 6 Tetrahedral\n\n        c0 = DENS(X0, Y0, Z0);\n\n        if (rx >= ry && ry >= rz) {\n\n            c1 = DENS(X1, Y0, Z0) - c0;\n            c2 = DENS(X1, Y1, Z0) - DENS(X1, Y0, Z0);\n            c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);\n\n        }\n        else\n            if (rx >= rz && rz >= ry) {\n\n                c1 = DENS(X1, Y0, Z0) - c0;\n                c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);\n                c3 = DENS(X1, Y0, Z1) - DENS(X1, Y0, Z0);\n\n            }\n            else\n                if (rz >= rx && rx >= ry) {\n\n                    c1 = DENS(X1, Y0, Z1) - DENS(X0, Y0, Z1);\n                    c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);\n                    c3 = DENS(X0, Y0, Z1) - c0;\n\n                }\n                else\n                    if (ry >= rx && rx >= rz) {\n\n                        c1 = DENS(X1, Y1, Z0) - DENS(X0, Y1, Z0);\n                        c2 = DENS(X0, Y1, Z0) - c0;\n                        c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);\n\n                    }\n                    else\n                        if (ry >= rz && rz >= rx) {\n\n                            c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);\n                            c2 = DENS(X0, Y1, Z0) - c0;\n                            c3 = DENS(X0, Y1, Z1) - DENS(X0, Y1, Z0);\n\n                        }\n                        else\n                            if (rz >= ry && ry >= rx) {\n\n                                c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);\n                                c2 = DENS(X0, Y1, Z1) - DENS(X0, Y0, Z1);\n                                c3 = DENS(X0, Y0, Z1) - c0;\n\n                            }\n                            else  {\n                                c1 = c2 = c3 = 0;\n                            }\n\n       Output[OutChan] = c0 + c1 * rx + c2 * ry + c3 * rz;\n       }\n\n}",
          "fn_code_pos": [
            [
              621,
              0
            ],
            [
              715,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TetrahedralInterpFloat",
            "parameters": {
              "Input": "cmsFloat32Number",
              "Output": "cmsFloat32Number",
              "p": "cmsInterpParams"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static CMS_NO_SANITIZE\nvoid TetrahedralInterp16(CMSREGISTER const cmsUInt16Number Input[],\n                         CMSREGISTER cmsUInt16Number Output[],\n                         CMSREGISTER const cmsInterpParams* p)\n{\n    const cmsUInt16Number* LutTable = (cmsUInt16Number*) p -> Table;\n    cmsS15Fixed16Number fx, fy, fz;\n    cmsS15Fixed16Number rx, ry, rz;\n    int x0, y0, z0;\n    cmsS15Fixed16Number c0, c1, c2, c3, Rest;\n    cmsUInt32Number X0, X1, Y0, Y1, Z0, Z1;\n    cmsUInt32Number TotalOut = p -> nOutputs;\n\n    fx = _cmsToFixedDomain((int) Input[0] * p -> Domain[0]);\n    fy = _cmsToFixedDomain((int) Input[1] * p -> Domain[1]);\n    fz = _cmsToFixedDomain((int) Input[2] * p -> Domain[2]);\n\n    x0 = FIXED_TO_INT(fx);\n    y0 = FIXED_TO_INT(fy);\n    z0 = FIXED_TO_INT(fz);\n\n    rx = FIXED_REST_TO_INT(fx);\n    ry = FIXED_REST_TO_INT(fy);\n    rz = FIXED_REST_TO_INT(fz);\n\n    X0 = p -> opta[2] * x0;\n    X1 = (Input[0] == 0xFFFFU ? 0 : p->opta[2]);\n\n    Y0 = p -> opta[1] * y0;\n    Y1 = (Input[1] == 0xFFFFU ? 0 : p->opta[1]);\n\n    Z0 = p -> opta[0] * z0;\n    Z1 = (Input[2] == 0xFFFFU ? 0 : p->opta[0]);\n    \n    LutTable += X0+Y0+Z0;\n\n    // Output should be computed as x = ROUND_FIXED_TO_INT(_cmsToFixedDomain(Rest))\n    // which expands as: x = (Rest + ((Rest+0x7fff)/0xFFFF) + 0x8000)>>16\n    // This can be replaced by: t = Rest+0x8001, x = (t + (t>>16))>>16\n    // at the cost of being off by one at 7fff and 17ffe.\n\n    if (rx >= ry) {\n        if (ry >= rz) {\n            Y1 += X1;\n            Z1 += Y1;\n            for (; TotalOut; TotalOut--) {\n                c1 = LutTable[X1];\n                c2 = LutTable[Y1];\n                c3 = LutTable[Z1];\n                c0 = *LutTable++;\n                c3 -= c2;\n                c2 -= c1;\n                c1 -= c0;\n                Rest = c1 * rx + c2 * ry + c3 * rz + 0x8001;\n                *Output++ = (cmsUInt16Number) c0 + ((Rest + (Rest>>16))>>16);\n            }\n        } else if (rz >= rx) {\n            X1 += Z1;\n            Y1 += X1;\n            for (; TotalOut; TotalOut--) {\n                c1 = LutTable[X1];\n                c2 = LutTable[Y1];\n                c3 = LutTable[Z1];\n                c0 = *LutTable++;\n                c2 -= c1;\n                c1 -= c3;\n                c3 -= c0;\n                Rest = c1 * rx + c2 * ry + c3 * rz + 0x8001;\n                *Output++ = (cmsUInt16Number) c0 + ((Rest + (Rest>>16))>>16);\n            }\n        } else {\n            Z1 += X1;\n            Y1 += Z1;\n            for (; TotalOut; TotalOut--) {\n                c1 = LutTable[X1];\n                c2 = LutTable[Y1];\n                c3 = LutTable[Z1];\n                c0 = *LutTable++;\n                c2 -= c3;\n                c3 -= c1;\n                c1 -= c0;\n                Rest = c1 * rx + c2 * ry + c3 * rz + 0x8001;\n                *Output++ = (cmsUInt16Number) c0 + ((Rest + (Rest>>16))>>16);\n            }\n        }\n    } else {\n        if (rx >= rz) {\n            X1 += Y1;\n            Z1 += X1;\n            for (; TotalOut; TotalOut--) {\n                c1 = LutTable[X1];\n                c2 = LutTable[Y1];\n                c3 = LutTable[Z1];\n                c0 = *LutTable++;\n                c3 -= c1;\n                c1 -= c2;\n                c2 -= c0;\n                Rest = c1 * rx + c2 * ry + c3 * rz + 0x8001;\n                *Output++ = (cmsUInt16Number) c0 + ((Rest + (Rest>>16))>>16);\n            }\n        } else if (ry >= rz) {\n            Z1 += Y1;\n            X1 += Z1;\n            for (; TotalOut; TotalOut--) {\n                c1 = LutTable[X1];\n                c2 = LutTable[Y1];\n                c3 = LutTable[Z1];\n                c0 = *LutTable++;\n                c1 -= c3;\n                c3 -= c2;\n                c2 -= c0;\n                Rest = c1 * rx + c2 * ry + c3 * rz + 0x8001;\n                *Output++ = (cmsUInt16Number) c0 + ((Rest + (Rest>>16))>>16);\n            }\n        } else {\n            Y1 += Z1;\n            X1 += Y1;\n            for (; TotalOut; TotalOut--) {\n                c1 = LutTable[X1];\n                c2 = LutTable[Y1];\n                c3 = LutTable[Z1];\n                c0 = *LutTable++;\n                c1 -= c2;\n                c2 -= c3;\n                c3 -= c0;\n                Rest = c1 * rx + c2 * ry + c3 * rz + 0x8001;\n                *Output++ = (cmsUInt16Number) c0 + ((Rest + (Rest>>16))>>16);\n            }\n        }\n    }\n}",
          "fn_code_pos": [
            [
              719,
              0
            ],
            [
              849,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TetrahedralInterp16",
            "parameters": {
              "Input": "CMSREGISTER",
              "Output": "CMSREGISTER"
            },
            "return_type": "CMS_NO_SANITIZE"
          }
        },
        {
          "fn_code": "static CMS_NO_SANITIZE\nvoid Eval4Inputs(CMSREGISTER const cmsUInt16Number Input[],\n                     CMSREGISTER cmsUInt16Number Output[],\n                     CMSREGISTER const cmsInterpParams* p16)\n{\n    const cmsUInt16Number* LutTable;\n    cmsS15Fixed16Number fk;\n    cmsS15Fixed16Number k0, rk;\n    int K0, K1;\n    cmsS15Fixed16Number    fx, fy, fz;\n    cmsS15Fixed16Number    rx, ry, rz;\n    int                    x0, y0, z0;\n    cmsS15Fixed16Number    X0, X1, Y0, Y1, Z0, Z1;\n    cmsUInt32Number i;\n    cmsS15Fixed16Number    c0, c1, c2, c3, Rest;\n    cmsUInt32Number        OutChan;\n    cmsUInt16Number        Tmp1[MAX_STAGE_CHANNELS], Tmp2[MAX_STAGE_CHANNELS];\n\n\n    fk  = _cmsToFixedDomain((int) Input[0] * p16 -> Domain[0]);\n    fx  = _cmsToFixedDomain((int) Input[1] * p16 -> Domain[1]);\n    fy  = _cmsToFixedDomain((int) Input[2] * p16 -> Domain[2]);\n    fz  = _cmsToFixedDomain((int) Input[3] * p16 -> Domain[3]);\n\n    k0  = FIXED_TO_INT(fk);\n    x0  = FIXED_TO_INT(fx);\n    y0  = FIXED_TO_INT(fy);\n    z0  = FIXED_TO_INT(fz);\n\n    rk  = FIXED_REST_TO_INT(fk);\n    rx  = FIXED_REST_TO_INT(fx);\n    ry  = FIXED_REST_TO_INT(fy);\n    rz  = FIXED_REST_TO_INT(fz);\n\n    K0 = p16 -> opta[3] * k0;\n    K1 = K0 + (Input[0] == 0xFFFFU ? 0 : p16->opta[3]);\n\n    X0 = p16 -> opta[2] * x0;\n    X1 = X0 + (Input[1] == 0xFFFFU ? 0 : p16->opta[2]);\n\n    Y0 = p16 -> opta[1] * y0;\n    Y1 = Y0 + (Input[2] == 0xFFFFU ? 0 : p16->opta[1]);\n\n    Z0 = p16 -> opta[0] * z0;\n    Z1 = Z0 + (Input[3] == 0xFFFFU ? 0 : p16->opta[0]);\n\n    LutTable = (cmsUInt16Number*) p16 -> Table;\n    LutTable += K0;\n\n    for (OutChan=0; OutChan < p16 -> nOutputs; OutChan++) {\n\n        c0 = DENS(X0, Y0, Z0);\n\n        if (rx >= ry && ry >= rz) {\n\n            c1 = DENS(X1, Y0, Z0) - c0;\n            c2 = DENS(X1, Y1, Z0) - DENS(X1, Y0, Z0);\n            c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);\n\n        }\n        else\n            if (rx >= rz && rz >= ry) {\n\n                c1 = DENS(X1, Y0, Z0) - c0;\n                c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);\n                c3 = DENS(X1, Y0, Z1) - DENS(X1, Y0, Z0);\n\n            }\n            else\n                if (rz >= rx && rx >= ry) {\n\n                    c1 = DENS(X1, Y0, Z1) - DENS(X0, Y0, Z1);\n                    c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);\n                    c3 = DENS(X0, Y0, Z1) - c0;\n\n                }\n                else\n                    if (ry >= rx && rx >= rz) {\n\n                        c1 = DENS(X1, Y1, Z0) - DENS(X0, Y1, Z0);\n                        c2 = DENS(X0, Y1, Z0) - c0;\n                        c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);\n\n                    }\n                    else\n                        if (ry >= rz && rz >= rx) {\n\n                            c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);\n                            c2 = DENS(X0, Y1, Z0) - c0;\n                            c3 = DENS(X0, Y1, Z1) - DENS(X0, Y1, Z0);\n\n                        }\n                        else\n                            if (rz >= ry && ry >= rx) {\n\n                                c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);\n                                c2 = DENS(X0, Y1, Z1) - DENS(X0, Y0, Z1);\n                                c3 = DENS(X0, Y0, Z1) - c0;\n\n                            }\n                            else {\n                                c1 = c2 = c3 = 0;\n                            }\n\n        Rest = c1 * rx + c2 * ry + c3 * rz;\n\n        Tmp1[OutChan] = (cmsUInt16Number)(c0 + ROUND_FIXED_TO_INT(_cmsToFixedDomain(Rest)));\n    }\n\n\n    LutTable = (cmsUInt16Number*) p16 -> Table;\n    LutTable += K1;\n\n    for (OutChan=0; OutChan < p16 -> nOutputs; OutChan++) {\n\n        c0 = DENS(X0, Y0, Z0);\n\n        if (rx >= ry && ry >= rz) {\n\n            c1 = DENS(X1, Y0, Z0) - c0;\n            c2 = DENS(X1, Y1, Z0) - DENS(X1, Y0, Z0);\n            c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);\n\n        }\n        else\n            if (rx >= rz && rz >= ry) {\n\n                c1 = DENS(X1, Y0, Z0) - c0;\n                c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);\n                c3 = DENS(X1, Y0, Z1) - DENS(X1, Y0, Z0);\n\n            }\n            else\n                if (rz >= rx && rx >= ry) {\n\n                    c1 = DENS(X1, Y0, Z1) - DENS(X0, Y0, Z1);\n                    c2 = DENS(X1, Y1, Z1) - DENS(X1, Y0, Z1);\n                    c3 = DENS(X0, Y0, Z1) - c0;\n\n                }\n                else\n                    if (ry >= rx && rx >= rz) {\n\n                        c1 = DENS(X1, Y1, Z0) - DENS(X0, Y1, Z0);\n                        c2 = DENS(X0, Y1, Z0) - c0;\n                        c3 = DENS(X1, Y1, Z1) - DENS(X1, Y1, Z0);\n\n                    }\n                    else\n                        if (ry >= rz && rz >= rx) {\n\n                            c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);\n                            c2 = DENS(X0, Y1, Z0) - c0;\n                            c3 = DENS(X0, Y1, Z1) - DENS(X0, Y1, Z0);\n\n                        }\n                        else\n                            if (rz >= ry && ry >= rx) {\n\n                                c1 = DENS(X1, Y1, Z1) - DENS(X0, Y1, Z1);\n                                c2 = DENS(X0, Y1, Z1) - DENS(X0, Y0, Z1);\n                                c3 = DENS(X0, Y0, Z1) - c0;\n\n                            }\n                            else  {\n                                c1 = c2 = c3 = 0;\n                            }\n\n        Rest = c1 * rx + c2 * ry + c3 * rz;\n\n        Tmp2[OutChan] = (cmsUInt16Number) (c0 + ROUND_FIXED_TO_INT(_cmsToFixedDomain(Rest)));\n    }\n\n\n\n    for (i=0; i < p16 -> nOutputs; i++) {\n        Output[i] = LinearInterp(rk, Tmp1[i], Tmp2[i]);\n    }\n}",
          "fn_code_pos": [
            [
              853,
              0
            ],
            [
              1031,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Eval4Inputs",
            "parameters": {
              "Input": "CMSREGISTER",
              "Output": "CMSREGISTER"
            },
            "return_type": "CMS_NO_SANITIZE"
          }
        },
        {
          "fn_code": "static\nvoid Eval4InputsFloat(const cmsFloat32Number Input[],\n                      cmsFloat32Number Output[],\n                      const cmsInterpParams* p)\n{\n       const cmsFloat32Number* LutTable = (cmsFloat32Number*) p -> Table;\n       cmsFloat32Number rest;\n       cmsFloat32Number pk;\n       int k0, K0, K1;\n       const cmsFloat32Number* T;\n       cmsUInt32Number i;\n       cmsFloat32Number Tmp1[MAX_STAGE_CHANNELS], Tmp2[MAX_STAGE_CHANNELS];\n       cmsInterpParams p1;\n\n       pk = fclamp(Input[0]) * p->Domain[0];\n       k0 = _cmsQuickFloor(pk);\n       rest = pk - (cmsFloat32Number) k0;\n\n       K0 = p -> opta[3] * k0;\n       K1 = K0 + (fclamp(Input[0]) >= 1.0 ? 0 : p->opta[3]);\n\n       p1 = *p;\n       memmove(&p1.Domain[0], &p ->Domain[1], 3*sizeof(cmsUInt32Number));\n\n       T = LutTable + K0;\n       p1.Table = T;\n\n       TetrahedralInterpFloat(Input + 1,  Tmp1, &p1);\n\n       T = LutTable + K1;\n       p1.Table = T;\n       TetrahedralInterpFloat(Input + 1,  Tmp2, &p1);\n\n       for (i=0; i < p -> nOutputs; i++)\n       {\n              cmsFloat32Number y0 = Tmp1[i];\n              cmsFloat32Number y1 = Tmp2[i];\n\n              Output[i] = y0 + (y1 - y0) * rest;\n       }\n}",
          "fn_code_pos": [
            [
              1037,
              0
            ],
            [
              1077,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Eval4InputsFloat",
            "parameters": {
              "Input": "cmsFloat32Number",
              "Output": "cmsFloat32Number",
              "p": "cmsInterpParams"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsInterpFunction DefaultInterpolatorsFactory(cmsUInt32Number nInputChannels, cmsUInt32Number nOutputChannels, cmsUInt32Number dwFlags)\n{\n\n    cmsInterpFunction Interpolation;\n    cmsBool  IsFloat     = (dwFlags & CMS_LERP_FLAGS_FLOAT);\n    cmsBool  IsTrilinear = (dwFlags & CMS_LERP_FLAGS_TRILINEAR);\n\n    memset(&Interpolation, 0, sizeof(Interpolation));\n\n    // Safety check\n    if (nInputChannels >= 4 && nOutputChannels >= MAX_STAGE_CHANNELS)\n        return Interpolation;\n\n    switch (nInputChannels) {\n\n           case 1: // Gray LUT / linear\n\n               if (nOutputChannels == 1) {\n\n                   if (IsFloat)\n                       Interpolation.LerpFloat = LinLerp1Dfloat;\n                   else\n                       Interpolation.Lerp16 = LinLerp1D;\n\n               }\n               else {\n\n                   if (IsFloat)\n                       Interpolation.LerpFloat = Eval1InputFloat;\n                   else\n                       Interpolation.Lerp16 = Eval1Input;\n               }\n               break;\n\n           case 2: // Duotone\n               if (IsFloat)\n                      Interpolation.LerpFloat =  BilinearInterpFloat;\n               else\n                      Interpolation.Lerp16    =  BilinearInterp16;\n               break;\n\n           case 3:  // RGB et al\n\n               if (IsTrilinear) {\n\n                   if (IsFloat)\n                       Interpolation.LerpFloat = TrilinearInterpFloat;\n                   else\n                       Interpolation.Lerp16 = TrilinearInterp16;\n               }\n               else {\n\n                   if (IsFloat)\n                       Interpolation.LerpFloat = TetrahedralInterpFloat;\n                   else {\n\n                       Interpolation.Lerp16 = TetrahedralInterp16;\n                   }\n               }\n               break;\n\n           case 4:  // CMYK lut\n\n               if (IsFloat)\n                   Interpolation.LerpFloat =  Eval4InputsFloat;\n               else\n                   Interpolation.Lerp16    =  Eval4Inputs;\n               break;\n\n           case 5: // 5 Inks\n               if (IsFloat)\n                   Interpolation.LerpFloat =  Eval5InputsFloat;\n               else\n                   Interpolation.Lerp16    =  Eval5Inputs;\n               break;\n\n           case 6: // 6 Inks\n               if (IsFloat)\n                   Interpolation.LerpFloat =  Eval6InputsFloat;\n               else\n                   Interpolation.Lerp16    =  Eval6Inputs;\n               break;\n\n           case 7: // 7 inks\n               if (IsFloat)\n                   Interpolation.LerpFloat =  Eval7InputsFloat;\n               else\n                   Interpolation.Lerp16    =  Eval7Inputs;\n               break;\n\n           case 8: // 8 inks\n               if (IsFloat)\n                   Interpolation.LerpFloat =  Eval8InputsFloat;\n               else\n                   Interpolation.Lerp16    =  Eval8Inputs;\n               break;\n\n           case 9: \n               if (IsFloat)\n                   Interpolation.LerpFloat = Eval9InputsFloat;\n               else\n                   Interpolation.Lerp16 = Eval9Inputs;\n               break;\n\n           case 10: \n               if (IsFloat)\n                   Interpolation.LerpFloat = Eval10InputsFloat;\n               else\n                   Interpolation.Lerp16 = Eval10Inputs;\n               break;\n\n           case 11:\n               if (IsFloat)\n                   Interpolation.LerpFloat = Eval11InputsFloat;\n               else\n                   Interpolation.Lerp16 = Eval11Inputs;\n               break;\n\n           case 12: \n               if (IsFloat)\n                   Interpolation.LerpFloat = Eval12InputsFloat;\n               else\n                   Interpolation.Lerp16 = Eval12Inputs;\n               break;\n\n           case 13: \n               if (IsFloat)\n                   Interpolation.LerpFloat = Eval13InputsFloat;\n               else\n                   Interpolation.Lerp16 = Eval13Inputs;\n               break;\n\n           case 14: \n               if (IsFloat)\n                   Interpolation.LerpFloat = Eval14InputsFloat;\n               else\n                   Interpolation.Lerp16 = Eval14Inputs;\n               break;\n\n           case 15: \n               if (IsFloat)\n                   Interpolation.LerpFloat = Eval15InputsFloat;\n               else\n                   Interpolation.Lerp16 = Eval15Inputs;\n               break;\n\n           default:\n               Interpolation.Lerp16 = NULL;\n    }\n\n    return Interpolation;\n}",
          "fn_code_pos": [
            [
              1177,
              0
            ],
            [
              1329,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DefaultInterpolatorsFactory",
            "parameters": {
              "nInputChannels": "cmsUInt32Number",
              "nOutputChannels": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsInterpFunction"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "DefaultInterpolatorsFactory(cmsUInt32Number nInputChannels, cmsUInt32Number nOutputChannels, cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              39,
              25
            ],
            [
              39,
              142
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DefaultInterpolatorsFactory",
            "parameters": {
              "nInputChannels": "cmsUInt32Number",
              "nOutputChannels": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsInterpFunction"
          }
        },
        {
          "fn_code": "_cmsComputeInterpParamsEx(cmsContext ContextID,\n                                           const cmsUInt32Number nSamples[],\n                                           cmsUInt32Number InputChan, cmsUInt32Number OutputChan,\n                                           const void *Table,\n                                           cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              109,
              17
            ],
            [
              113,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsComputeInterpParamsEx",
            "parameters": {
              "ContextID": "cmsContext",
              "nSamples": "cmsUInt32Number",
              "InputChan": "cmsUInt32Number",
              "OutputChan": "cmsUInt32Number",
              "Table": "void",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            45,
            32
          ],
          [
            45,
            57
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            45,
            70
          ],
          [
            45,
            95
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/testbed/zoo_icc.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nvoid ReadAllTags(cmsHPROFILE h)\n{\n    cmsInt32Number i, n;\n    cmsTagSignature sig;\n\n    n = cmsGetTagCount(h);\n    for (i=0; i < n; i++) {\n\n        sig = cmsGetTagSignature(h, i);\n        if (cmsReadTag(h, sig) == NULL) return;\n    }\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              53,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadAllTags",
            "parameters": {
              "h": "cmsHPROFILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid ReadAllRAWTags(cmsHPROFILE h)\n{\n    cmsInt32Number i, n;\n    cmsTagSignature sig;\n    \n    n = cmsGetTagCount(h);\n    for (i=0; i < n; i++) {\n\n        sig = cmsGetTagSignature(h, i);\n        cmsReadRawTag(h, sig, NULL, 0);\n    }\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              69,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadAllRAWTags",
            "parameters": {
              "h": "cmsHPROFILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid PrintInfo(cmsHPROFILE h, cmsInfoType Info)\n{\n    wchar_t* text;\n    cmsInt32Number len;\n    cmsContext id = 0;\n\n    len = cmsGetProfileInfo(h, Info, \"en\", \"US\", NULL, 0);\n    if (len == 0) return;\n\n    text = (wchar_t*) _cmsMalloc(id, len);\n    cmsGetProfileInfo(h, Info, \"en\", \"US\", text, len);\n\n    wprintf(L\"%s\\n\", text);\n    _cmsFree(id, text);\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintInfo",
            "parameters": {
              "h": "cmsHPROFILE",
              "Info": "cmsInfoType"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid PrintAllInfos(cmsHPROFILE h)\n{\n     PrintInfo(h, cmsInfoDescription);\n     PrintInfo(h, cmsInfoManufacturer);\n     PrintInfo(h, cmsInfoModel);\n     PrintInfo(h, cmsInfoCopyright);\n     printf(\"\\n\\n\");\n}",
          "fn_code_pos": [
            [
              90,
              0
            ],
            [
              98,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintAllInfos",
            "parameters": {
              "h": "cmsHPROFILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid ReadAllLUTS(cmsHPROFILE h)\n{\n    cmsPipeline* a;\n    cmsCIEXYZ Black;\n\n    a = _cmsReadInputLUT(h, INTENT_PERCEPTUAL);\n    if (a) cmsPipelineFree(a);\n\n    a = _cmsReadInputLUT(h, INTENT_RELATIVE_COLORIMETRIC);\n    if (a) cmsPipelineFree(a);\n\n    a = _cmsReadInputLUT(h, INTENT_SATURATION);\n    if (a) cmsPipelineFree(a);\n\n    a = _cmsReadInputLUT(h, INTENT_ABSOLUTE_COLORIMETRIC);\n    if (a) cmsPipelineFree(a);\n\n\n    a = _cmsReadOutputLUT(h, INTENT_PERCEPTUAL);\n    if (a) cmsPipelineFree(a);\n\n    a = _cmsReadOutputLUT(h, INTENT_RELATIVE_COLORIMETRIC);\n    if (a) cmsPipelineFree(a);\n\n    a = _cmsReadOutputLUT(h, INTENT_SATURATION);\n    if (a) cmsPipelineFree(a);\n\n    a = _cmsReadOutputLUT(h, INTENT_ABSOLUTE_COLORIMETRIC);\n    if (a) cmsPipelineFree(a);\n\n\n    a = _cmsReadDevicelinkLUT(h, INTENT_PERCEPTUAL);\n    if (a) cmsPipelineFree(a);\n\n    a = _cmsReadDevicelinkLUT(h, INTENT_RELATIVE_COLORIMETRIC);\n    if (a) cmsPipelineFree(a);\n\n    a = _cmsReadDevicelinkLUT(h, INTENT_SATURATION);\n    if (a) cmsPipelineFree(a);\n\n    a = _cmsReadDevicelinkLUT(h, INTENT_ABSOLUTE_COLORIMETRIC);\n    if (a) cmsPipelineFree(a);\n\n\n    cmsDetectDestinationBlackPoint(&Black, h, INTENT_PERCEPTUAL, 0);\n    cmsDetectDestinationBlackPoint(&Black, h, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsDetectDestinationBlackPoint(&Black, h, INTENT_SATURATION, 0);\n    cmsDetectDestinationBlackPoint(&Black, h, INTENT_ABSOLUTE_COLORIMETRIC, 0);\n    cmsDetectTAC(h);\n}",
          "fn_code_pos": [
            [
              100,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadAllLUTS",
            "parameters": {
              "h": "cmsHPROFILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckSingleSpecimen(const char* Profile)\n{\n    char BuffSrc[256];\n    char BuffDst[256];\n    cmsHPROFILE h;\n\n    sprintf(BuffSrc, \"%s%s\", ZOOfolder, Profile);\n    sprintf(BuffDst, \"%s%s\", ZOOwrite,  Profile);\n\n    h = cmsOpenProfileFromFile(BuffSrc, \"r\");\n    if (h == NULL) return 0;\n\n    printf(\"%s\\n\", Profile);\n\n    PrintAllInfos(h);  \n    ReadAllTags(h);    \n    ReadAllLUTS(h);\n // ReadAllRAWTags(h);\n\n\n    cmsSaveProfileToFile(h, BuffDst);\n    cmsCloseProfile(h);\n\n    h = cmsOpenProfileFromFile(BuffDst, \"r\");\n    if (h == NULL) return 0;\n    ReadAllTags(h);\n\n\n    cmsCloseProfile(h);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              154,
              0
            ],
            [
              186,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckSingleSpecimen",
            "parameters": {
              "Profile": "char"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckRAWSpecimen(const char* Profile)\n{\n    char BuffSrc[256];\n    char BuffDst[256];\n    cmsHPROFILE h;\n\n    sprintf(BuffSrc, \"%s%s\", ZOOfolder, Profile);\n    sprintf(BuffDst, \"%s%s\", ZOORawWrite,  Profile);\n\n    h = cmsOpenProfileFromFile(BuffSrc, \"r\");\n    if (h == NULL) return 0;\n\n    ReadAllTags(h);\n    ReadAllRAWTags(h);\n    cmsSaveProfileToFile(h, BuffDst);\n    cmsCloseProfile(h);\n\n    h = cmsOpenProfileFromFile(BuffDst, \"r\");\n    if (h == NULL) return 0;\n    ReadAllTags(h);\n    cmsCloseProfile(h);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              188,
              0
            ],
            [
              212,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckRAWSpecimen",
            "parameters": {
              "Profile": "char"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nint count_stats(const char* Profile)\n{\n    char BuffSrc[256];\n    cmsHPROFILE h;\n    cmsCIEXYZ Black;\n\n    sprintf(BuffSrc, \"%s%s\", ZOOfolder, Profile);\n   \n    h = cmsOpenProfileFromFile(BuffSrc, \"r\");\n    if (h == NULL) return 0;\n\n  \n    switch (cmsGetDeviceClass(h)) { \n\n    case cmsSigInputClass        : input++; break;\n    case cmsSigDisplayClass      : disp++; break;\n    case cmsSigOutputClass       : output++; break;\n    case cmsSigLinkClass         : link++;  break;\n    case cmsSigAbstractClass     : abst++; break;\n    case cmsSigColorSpaceClass   : color++; break;\n    case cmsSigNamedColorClass   : named ++; break;\n    }\n\n\n    switch (cmsGetColorSpace(h)) {\n\n    case cmsSigRgbData: rgb++; break;\n    case cmsSigCmykData: cmyk++; break;\n    case cmsSigGrayData: gray++; break;\n    default: other++;\n    }\n\n    cmsDetectDestinationBlackPoint(&Black, h, INTENT_PERCEPTUAL, 0);\n    cmsDetectDestinationBlackPoint(&Black, h, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsDetectDestinationBlackPoint(&Black, h, INTENT_SATURATION, 0);\n   \n    cmsCloseProfile(h);\n   \n    return 1;\n}",
          "fn_code_pos": [
            [
              230,
              0
            ],
            [
              270,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "count_stats",
            "parameters": {
              "Profile": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void CheckProfileZOO(void)\n{\n\n    struct _finddata_t c_file;\n    intptr_t hFile;\n\n    cmsSetLogErrorHandler(NULL);\n\n    if ( (hFile = _findfirst(\"c:\\\\colormaps\\\\*.*\", &c_file)) == -1L )\n        printf(\"No files in current directory\");\n    else\n    {\n        do\n        {\n            if (strcmp(c_file.name, \".\") != 0 &&\n                strcmp(c_file.name, \"..\") != 0) {\n\n                    CheckSingleSpecimen( c_file.name);\n                    CheckRAWSpecimen( c_file.name);\n\n                    count_stats(c_file.name);\n\n                    TestMemoryLeaks(FALSE);\n\n            }\n\n        } while ( _findnext(hFile, &c_file) == 0 );\n\n        _findclose(hFile);\n    }\n\n     ResetFatalError();\n}",
          "fn_code_pos": [
            [
              274,
              0
            ],
            [
              306,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckProfileZOO",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct _finddata_t",
          {},
          "",
          [
            277,
            4
          ],
          [
            277,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"testcms2.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/testbed/testthread.cpp": {
      "fn_def_list": [
        {
          "fn_code": "static\nvoid* MyMtxCreate(cmsContext id)\n{\n   return (void*) CreateMutex( NULL, FALSE, NULL);   \n}",
          "fn_code_pos": [
            [
              9,
              0
            ],
            [
              13,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MyMtxCreate",
            "parameters": {
              "id": "cmsContext"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid MyMtxDestroy(cmsContext id, void* mtx)\n{\n    CloseHandle((HANDLE) mtx);\n}",
          "fn_code_pos": [
            [
              15,
              0
            ],
            [
              19,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MyMtxDestroy",
            "parameters": {
              "id": "cmsContext",
              "mtx": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool MyMtxLock(cmsContext id, void* mtx)\n{\n    WaitForSingleObject((HANDLE) mtx, INFINITE);\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              21,
              0
            ],
            [
              26,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MyMtxLock",
            "parameters": {
              "id": "cmsContext",
              "mtx": "void"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid MyMtxUnlock(cmsContext id, void* mtx)\n{\n    ReleaseMutex((HANDLE) mtx);\n}",
          "fn_code_pos": [
            [
              28,
              0
            ],
            [
              32,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MyMtxUnlock",
            "parameters": {
              "id": "cmsContext",
              "mtx": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static DWORD WINAPI one_thread(LPVOID lpParameter)\n{\n    int i, j;\n    cmsUInt8Number rgb[3*1000];\n    cmsUInt8Number cmyk[4*1000];\n\n    Sleep(rand() % 500 );\n    cmsHTRANSFORM xform = cmsCreateTransformTHR(ctx, prof_rgb, TYPE_RGB_8, prof_cmyk, TYPE_CMYK_8, 0, 0);\n\n    for (i=0; i < 100000; i++) {\n\n        for (j=0; j < 1000; j++) \n        {\n            rgb[j * 3    ] = 189;\n            rgb[j * 3 + 1] = 100;\n            rgb[j * 3 + 2] = 75;\n        }\n        cmsDoTransform(xform, rgb, cmyk, 1000);\n        for (j=0; j < 1000; j++) \n        {\n            if (cmyk[j * 4 ] != 37 ||\n                cmyk[j * 4 + 1 ] != 188 ||\n                cmyk[j * 4 + 2 ] != 195 ||\n                cmyk[j * 4 + 3 ] != 7) \n            {\n                OutputDebugString(L\"ERROR\\n\"); \n                rc = 1;\n            }\n\n        }\n\n    }\n        \n    cmsDeleteTransform(xform);\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              43,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "one_thread",
            "parameters": {
              "lpParameter": "LPVOID"
            },
            "return_type": "DWORD"
          }
        },
        {
          "fn_code": "int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)\n{\n    int i;\n    cmsContext ctx;\n\n    OutputDebugString(L\"Test in progress...\\n\"); \n\n    ctx = cmsCreateContext(NULL, 0);\n\n    prof_cmyk = cmsOpenProfileFromFileTHR(ctx, \"USWebCoatedSWOP.icc\", \"r\");\n    prof_rgb = cmsOpenProfileFromFileTHR(ctx, \"AdobeRGB1998.icc\",\"r\");\n   \n\n#define NWORKERS 10\n\n    HANDLE workers[NWORKERS];\n\n\n    for (int i=0; i<NWORKERS; ++i)\n    {\n        DWORD threadid;\n\n        workers[i] = CreateThread(NULL,0,one_thread,NULL,0,&threadid);\n    }\n\n    WaitForMultipleObjects(NWORKERS,workers,TRUE,INFINITE);\n\n    for ( i=0;i<NWORKERS;++i)\n        CloseHandle(workers[i]);\n\n\n    cmsCloseProfile(prof_rgb);\n    cmsCloseProfile(prof_cmyk);\n    cmsDeleteContext(ctx);\n\n    OutputDebugString(L\"Test Done\\n\"); \n\n    return rc;\n}",
          "fn_code_pos": [
            [
              81,
              0
            ],
            [
              119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WinMain",
            "parameters": {
              "hInstance": "HINSTANCE",
              "hPrevInstance": "HINSTANCE",
              "lpCmdLine": "LPSTR",
              "nCmdShow": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "MyMtxCreate(cmsContext id)",
          "fn_dec_pos": [
            [
              10,
              6
            ],
            [
              10,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MyMtxCreate",
            "parameters": {
              "id": "cmsContext"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <windows.h>\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ],
        [
          "#include \"lcms2_plugin.h\"\n",
          [
            2,
            0
          ],
          [
            3,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/testbed/testplugin.c": {
      "fn_def_list": [
        {
          "fn_code": "static\ncmsContext DupContext(cmsContext src, void* Data)\n{\n    cmsContext cpy = cmsDupContext(src, Data);\n\n    DebugMemDontCheckThis(cpy);\n\n    return cpy;\n}",
          "fn_code_pos": [
            [
              33,
              0
            ],
            [
              41,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DupContext",
            "parameters": {
              "src": "cmsContext",
              "Data": "void"
            },
            "return_type": "cmsContext"
          }
        },
        {
          "fn_code": "cmsInt32Number CheckAllocContext(void)\n{\n     cmsContext c1, c2, c3, c4;\n\n\n     c1 = cmsCreateContext(NULL, NULL);                 // This creates a context by using the normal malloc\n     DebugMemDontCheckThis(c1);\n     cmsDeleteContext(c1); \n\n     c2 = cmsCreateContext(PluginMemHandler(), NULL);   // This creates a context by using the debug malloc\n     DebugMemDontCheckThis(c2);\n     cmsDeleteContext(c2); \n\n     c1 = cmsCreateContext(NULL, NULL); \n     DebugMemDontCheckThis(c1);\n\n     c2 = cmsCreateContext(PluginMemHandler(), NULL);  \n     DebugMemDontCheckThis(c2);\n\n     cmsPluginTHR(c1, PluginMemHandler()); // Now the context have custom allocators\n\n     c3 = DupContext(c1, NULL);     \n     c4 = DupContext(c2, NULL);\n     \n\n\n     cmsDeleteContext(c1);  // Should be deleted by using normal malloc\n     cmsDeleteContext(c2);  // Should be deleted by using debug malloc\n     cmsDeleteContext(c3);  // Should be deleted by using normal malloc\n     cmsDeleteContext(c4);  // Should be deleted by using debug malloc\n\n     return 1;\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              80,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckAllocContext",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "cmsInt32Number CheckSimpleContext(void)\n{\n    int a = 1;\n    int b = 32;\n    cmsInt32Number rc = 0;\n\n    cmsContext c1, c2, c3;\n\n    // This function creates a context with a special \n    // memory manager that check allocation\n    c1 = WatchDogContext(&a);\n    cmsDeleteContext(c1);\n\n    c1 = WatchDogContext(&a);\n    \n    // Let's check duplication\n    c2 = DupContext(c1, NULL);    \n    c3 = DupContext(c2, NULL);    \n\n    // User data should have been propagated\n    rc = (*(int*) cmsGetContextUserData(c3)) == 1 ;\n\n    // Free resources\n    cmsDeleteContext(c1);\n    cmsDeleteContext(c2);\n    cmsDeleteContext(c3);\n\n    if (!rc) {\n        Fail(\"Creation of user data failed\");\n        return 0;\n    }\n\n    // Back to create 3 levels of inherance\n    c1 = cmsCreateContext(NULL, &a);\n    DebugMemDontCheckThis(c1);\n\n    c2 = DupContext(c1, NULL);\n    c3 = DupContext(c2, &b);    \n\n    rc = (*(int*) cmsGetContextUserData(c3)) == 32 ;\n\n    cmsDeleteContext(c1);\n    cmsDeleteContext(c2);\n    cmsDeleteContext(c3);\n\n    if (!rc) {\n        Fail(\"Modification of user data failed\");\n        return 0;\n    }\n\n    // All seems ok\n    return rc;\n}",
          "fn_code_pos": [
            [
              83,
              0
            ],
            [
              135,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckSimpleContext",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "cmsInt32Number CheckAlarmColorsContext(void)\n{\n    cmsInt32Number rc = 0;\n    const cmsUInt16Number codes[] = {0x0000, 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888, 0x9999, 0xaaaa, 0xbbbb, 0xcccc, 0xdddd, 0xeeee, 0xffff};\n    cmsUInt16Number out[16];\n    cmsContext c1, c2, c3;\n    int i;\n\n    c1 = WatchDogContext(NULL);\n\n    cmsSetAlarmCodesTHR(c1, codes);\n    c2 = DupContext(c1, NULL);\n    c3 = DupContext(c2, NULL);\n    \n    cmsGetAlarmCodesTHR(c3, out);\n\n    rc = 1;\n    for (i=0; i < 16; i++) {\n        if (out[i] != codes[i]) {\n            Fail(\"Bad alarm code %x != %x\", out[i], codes[i]);\n            rc = 0;\n            break;\n        }\n    }\n\n    cmsDeleteContext(c1);\n    cmsDeleteContext(c2);\n    cmsDeleteContext(c3);\n\n    return rc;\n}",
          "fn_code_pos": [
            [
              145,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckAlarmColorsContext",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "cmsInt32Number CheckAdaptationStateContext(void)\n{\n    cmsInt32Number rc = 0;\n    cmsContext c1, c2, c3;\n    cmsFloat64Number old1, old2;\n\n    old1 =  cmsSetAdaptationStateTHR(NULL, -1);\n\n    c1 = WatchDogContext(NULL);\n\n    cmsSetAdaptationStateTHR(c1, 0.7);\n\n    c2 = DupContext(c1, NULL);    \n    c3 = DupContext(c2, NULL);\n    \n    rc = IsGoodVal(\"Adaptation state\", cmsSetAdaptationStateTHR(c3, -1), 0.7, 0.001);\n\n    cmsDeleteContext(c1);\n    cmsDeleteContext(c2);\n    cmsDeleteContext(c3);\n   \n    old2 =  cmsSetAdaptationStateTHR(NULL, -1);\n\n    if (old1 != old2) {\n        Fail(\"Adaptation state has changed\");\n        return 0;\n    }\n\n    return rc;\n}",
          "fn_code_pos": [
            [
              183,
              0
            ],
            [
              212,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckAdaptationStateContext",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid Fake1Dfloat(const cmsFloat32Number Value[], \n                    cmsFloat32Number Output[],  \n                    const cmsInterpParams* p)\n{\n       cmsFloat32Number val2;\n       int cell;\n       const cmsFloat32Number* LutTable = (const cmsFloat32Number*) p ->Table;\n\n       // Clip upper values\n       if (Value[0] >= 1.0) {\n           Output[0] = LutTable[p -> Domain[0]]; \n           return; \n       }\n\n       val2 = p -> Domain[0] * Value[0];\n       cell = (int) floor(val2);\n       Output[0] =  LutTable[cell] ;\n}",
          "fn_code_pos": [
            [
              219,
              0
            ],
            [
              237,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fake1Dfloat",
            "parameters": {
              "Value": "cmsFloat32Number",
              "Output": "cmsFloat32Number",
              "p": "cmsInterpParams"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Fake3D16(CMSREGISTER const cmsUInt16Number Input[],\n              CMSREGISTER cmsUInt16Number Output[],\n              CMSREGISTER const struct _cms_interp_struc* p)\n{\n       Output[0] =  0xFFFF - Input[2];\n       Output[1] =  0xFFFF - Input[1];\n       Output[2] =  0xFFFF - Input[0];\n}",
          "fn_code_pos": [
            [
              240,
              0
            ],
            [
              248,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fake3D16",
            "parameters": {
              "Input": "CMSREGISTER",
              "Output": "CMSREGISTER",
              "struct": "CMSREGISTER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsInterpFunction my_Interpolators_Factory(cmsUInt32Number nInputChannels, \n                                           cmsUInt32Number nOutputChannels, \n                                           cmsUInt32Number dwFlags)\n{\n    cmsInterpFunction Interpolation;\n    cmsBool  IsFloat = (dwFlags & CMS_LERP_FLAGS_FLOAT);\n\n    // Initialize the return to zero as a non-supported mark\n    memset(&Interpolation, 0, sizeof(Interpolation));\n\n    // For 1D to 1D and floating point\n    if (nInputChannels == 1 && nOutputChannels == 1 && IsFloat) {\n\n        Interpolation.LerpFloat = Fake1Dfloat;\n    }\n    else\n    if (nInputChannels == 3 && nOutputChannels == 3 && !IsFloat) {\n    \n        // For 3D to 3D and 16 bits\n        Interpolation.Lerp16 = Fake3D16;\n    }\n\n    // Here is the interpolation \n    return Interpolation;\n}",
          "fn_code_pos": [
            [
              251,
              0
            ],
            [
              275,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "my_Interpolators_Factory",
            "parameters": {
              "nInputChannels": "cmsUInt32Number",
              "nOutputChannels": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsInterpFunction"
          }
        },
        {
          "fn_code": "cmsInt32Number CheckInterp1DPlugin(void)\n{\n    cmsToneCurve* Sampled1D = NULL;\n    cmsContext ctx = NULL;\n    cmsContext cpy = NULL;\n    const cmsFloat32Number tab[] = { 0.0f, 0.10f, 0.20f, 0.30f, 0.40f, 0.50f, 0.60f, 0.70f, 0.80f, 0.90f, 1.00f };  // A straight line\n\n    // 1st level context\n    ctx = WatchDogContext(NULL);\n    if (ctx == NULL) {\n        Fail(\"Cannot create context\");\n        goto Error;\n    }\n\n    cmsPluginTHR(ctx, &InterpPluginSample);\n\n    cpy = DupContext(ctx, NULL);    \n     if (cpy == NULL) {\n        Fail(\"Cannot create context (2)\");\n        goto Error;\n    }\n\n    Sampled1D = cmsBuildTabulatedToneCurveFloat(cpy, 11, tab);\n    if (Sampled1D == NULL) {\n        Fail(\"Cannot create tone curve (1)\");\n        goto Error;\n    }\n    \n    // Do some interpolations with the plugin\n    if (!IsGoodVal(\"0.10\", cmsEvalToneCurveFloat(Sampled1D, 0.10f), 0.10, 0.01)) goto Error;\n    if (!IsGoodVal(\"0.13\", cmsEvalToneCurveFloat(Sampled1D, 0.13f), 0.10, 0.01)) goto Error;\n    if (!IsGoodVal(\"0.55\", cmsEvalToneCurveFloat(Sampled1D, 0.55f), 0.50, 0.01)) goto Error;\n    if (!IsGoodVal(\"0.9999\", cmsEvalToneCurveFloat(Sampled1D, 0.9999f), 0.90, 0.01)) goto Error;\n\n    cmsFreeToneCurve(Sampled1D);\n    cmsDeleteContext(ctx);\n    cmsDeleteContext(cpy);\n   \n    // Now in global context\n    Sampled1D = cmsBuildTabulatedToneCurveFloat(NULL, 11, tab);\n    if (Sampled1D == NULL) {\n        Fail(\"Cannot create tone curve (2)\");\n        goto Error;\n    }\n    \n    // Now without the plug-in\n    if (!IsGoodVal(\"0.10\", cmsEvalToneCurveFloat(Sampled1D, 0.10f), 0.10, 0.001)) goto Error;\n    if (!IsGoodVal(\"0.13\", cmsEvalToneCurveFloat(Sampled1D, 0.13f), 0.13, 0.001)) goto Error;\n    if (!IsGoodVal(\"0.55\", cmsEvalToneCurveFloat(Sampled1D, 0.55f), 0.55, 0.001)) goto Error;\n    if (!IsGoodVal(\"0.9999\", cmsEvalToneCurveFloat(Sampled1D, 0.9999f), 0.9999, 0.001)) goto Error;\n\n    cmsFreeToneCurve(Sampled1D);\n    return 1;\n\nError:\n    if (ctx != NULL) cmsDeleteContext(ctx);\n     if (cpy != NULL) cmsDeleteContext(ctx);\n    if (Sampled1D != NULL) cmsFreeToneCurve(Sampled1D);\n    return 0;\n\n}",
          "fn_code_pos": [
            [
              287,
              0
            ],
            [
              347,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckInterp1DPlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "cmsInt32Number CheckInterp3DPlugin(void)\n{\n\n    cmsPipeline* p;\n    cmsStage* clut;\n    cmsContext ctx;\n    cmsUInt16Number In[3], Out[3];\n    cmsUInt16Number identity[] = { \n\n       0,       0,       0,      \n       0,       0,       0xffff, \n       0,       0xffff,  0,      \n       0,       0xffff,  0xffff, \n       0xffff,  0,       0,      \n       0xffff,  0,       0xffff, \n       0xffff,  0xffff,  0,      \n       0xffff,  0xffff,  0xffff \n    };\n\n\n    ctx = WatchDogContext(NULL);\n    if (ctx == NULL) {\n        Fail(\"Cannot create context\");\n       return 0;\n    }\n\n\n    cmsPluginTHR(ctx, &InterpPluginSample);\n\n\n    p =  cmsPipelineAlloc(ctx, 3, 3);\n    clut = cmsStageAllocCLut16bit(ctx, 2, 3, 3, identity);\n    cmsPipelineInsertStage(p, cmsAT_BEGIN, clut);\n\n    // Do some interpolations with the plugin\n\n    In[0] = 0; In[1] = 0; In[2] = 0;\n    cmsPipelineEval16(In, Out, p);\n\n    if (!IsGoodWord(\"0\", Out[0], 0xFFFF - 0)) goto Error;\n    if (!IsGoodWord(\"1\", Out[1], 0xFFFF - 0)) goto Error;\n    if (!IsGoodWord(\"2\", Out[2], 0xFFFF - 0)) goto Error;\n\n    In[0] = 0x1234; In[1] = 0x5678; In[2] = 0x9ABC;\n    cmsPipelineEval16(In, Out, p);\n\n    if (!IsGoodWord(\"0\", 0xFFFF - 0x9ABC, Out[0])) goto Error;\n    if (!IsGoodWord(\"1\", 0xFFFF - 0x5678, Out[1])) goto Error;\n    if (!IsGoodWord(\"2\", 0xFFFF - 0x1234, Out[2])) goto Error;\n\n    cmsPipelineFree(p);\n    cmsDeleteContext(ctx);\n\n    // Now without the plug-in\n\n    p =  cmsPipelineAlloc(NULL, 3, 3);\n    clut = cmsStageAllocCLut16bit(NULL, 2, 3, 3, identity);\n    cmsPipelineInsertStage(p, cmsAT_BEGIN, clut);\n\n    In[0] = 0; In[1] = 0; In[2] = 0;\n    cmsPipelineEval16(In, Out, p);\n\n    if (!IsGoodWord(\"0\", 0, Out[0])) goto Error;\n    if (!IsGoodWord(\"1\", 0, Out[1])) goto Error;\n    if (!IsGoodWord(\"2\", 0, Out[2])) goto Error;\n\n    In[0] = 0x1234; In[1] = 0x5678; In[2] = 0x9ABC;\n    cmsPipelineEval16(In, Out, p);\n\n    if (!IsGoodWord(\"0\", 0x1234, Out[0])) goto Error;\n    if (!IsGoodWord(\"1\", 0x5678, Out[1])) goto Error;\n    if (!IsGoodWord(\"2\", 0x9ABC, Out[2])) goto Error;\n\n    cmsPipelineFree(p);\n    return 1;\n\nError:\n    cmsPipelineFree(p);\n    return 0;\n\n}",
          "fn_code_pos": [
            [
              350,
              0
            ],
            [
              430,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckInterp3DPlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static cmsFloat64Number my_fns(cmsInt32Number Type, \n                        const cmsFloat64Number Params[], \n                        cmsFloat64Number R)\n{\n    cmsFloat64Number Val;\n    switch (Type) {\n\n    case TYPE_SIN:     \n        Val = Params[0]* sin(R * M_PI);\n        break;\n\n    case -TYPE_SIN:\n        Val = asin(R) / (M_PI * Params[0]);\n        break;\n\n    case TYPE_COS:     \n        Val = Params[0]* cos(R * M_PI);\n        break;\n\n    case -TYPE_COS:\n        Val = acos(R) / (M_PI * Params[0]);\n        break;\n\n    default: return -1.0;\n\n     }\n\n   return Val;\n}",
          "fn_code_pos": [
            [
              441,
              0
            ],
            [
              469,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "my_fns",
            "parameters": {
              "Type": "cmsInt32Number",
              "Params": "cmsFloat64Number",
              "R": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static \ncmsFloat64Number my_fns2(cmsInt32Number Type, \n                        const cmsFloat64Number Params[], \n                        cmsFloat64Number R)\n{\n    cmsFloat64Number Val;\n    switch (Type) {\n\n    case TYPE_TAN:     \n        Val = Params[0]* tan(R * M_PI);\n        break;\n\n    case -TYPE_TAN:\n        Val = atan(R) / (M_PI * Params[0]);\n        break;\n\n     default: return -1.0;\n     }\n\n   return Val;\n}",
          "fn_code_pos": [
            [
              471,
              0
            ],
            [
              491,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "my_fns2",
            "parameters": {
              "Type": "cmsInt32Number",
              "Params": "cmsFloat64Number",
              "R": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static double Rec709Math(int Type, const double Params[], double R)\n{ \n    double Fun = 0;\n\n    switch (Type)\n    {\n    case 709:\n\n        if (R <= (Params[3]*Params[4])) Fun = R / Params[3];\n        else Fun = pow(((R - Params[2])/Params[1]), Params[0]);\n        break;\n\n    case -709:\n\n        if (R <= Params[4]) Fun = R * Params[3];\n        else Fun = Params[1] * pow(R, (1/Params[0])) + Params[2];\n        break;\n    }\n    return Fun;\n}",
          "fn_code_pos": [
            [
              494,
              0
            ],
            [
              513,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Rec709Math",
            "parameters": {
              "Type": "int",
              "Params": "double",
              "R": "double"
            },
            "return_type": "double"
          }
        },
        {
          "fn_code": "cmsInt32Number CheckParametricCurvePlugin(void)\n{\n    cmsContext ctx = NULL;\n    cmsContext cpy = NULL;\n    cmsContext cpy2 = NULL;\n    cmsToneCurve* sinus;\n    cmsToneCurve* cosinus;\n    cmsToneCurve* tangent;\n    cmsToneCurve* reverse_sinus;\n    cmsToneCurve* reverse_cosinus;\n    cmsFloat64Number scale = 1.0;\n\n\n    ctx = WatchDogContext(NULL);\n\n    cmsPluginTHR(ctx, &CurvePluginSample);\n\n    cpy = DupContext(ctx, NULL);\n    \n    cmsPluginTHR(cpy, &CurvePluginSample2);\n\n    cpy2 =  DupContext(cpy, NULL);\n    \n    cmsPluginTHR(cpy2, &Rec709Plugin);\n    \n\n    sinus = cmsBuildParametricToneCurve(cpy, TYPE_SIN, &scale);\n    cosinus = cmsBuildParametricToneCurve(cpy, TYPE_COS, &scale);\n    tangent = cmsBuildParametricToneCurve(cpy, TYPE_TAN, &scale);\n    reverse_sinus = cmsReverseToneCurve(sinus);\n    reverse_cosinus = cmsReverseToneCurve(cosinus);\n\n\n     if (!IsGoodVal(\"0.10\", cmsEvalToneCurveFloat(sinus, 0.10f), sin(0.10 * M_PI) , 0.001)) goto Error;\n     if (!IsGoodVal(\"0.60\", cmsEvalToneCurveFloat(sinus, 0.60f), sin(0.60* M_PI), 0.001)) goto Error;\n     if (!IsGoodVal(\"0.90\", cmsEvalToneCurveFloat(sinus, 0.90f), sin(0.90* M_PI), 0.001)) goto Error;\n\n     if (!IsGoodVal(\"0.10\", cmsEvalToneCurveFloat(cosinus, 0.10f), cos(0.10* M_PI), 0.001)) goto Error;\n     if (!IsGoodVal(\"0.60\", cmsEvalToneCurveFloat(cosinus, 0.60f), cos(0.60* M_PI), 0.001)) goto Error;\n     if (!IsGoodVal(\"0.90\", cmsEvalToneCurveFloat(cosinus, 0.90f), cos(0.90* M_PI), 0.001)) goto Error;\n\n     if (!IsGoodVal(\"0.10\", cmsEvalToneCurveFloat(tangent, 0.10f), tan(0.10* M_PI), 0.001)) goto Error;\n     if (!IsGoodVal(\"0.60\", cmsEvalToneCurveFloat(tangent, 0.60f), tan(0.60* M_PI), 0.001)) goto Error;\n     if (!IsGoodVal(\"0.90\", cmsEvalToneCurveFloat(tangent, 0.90f), tan(0.90* M_PI), 0.001)) goto Error;\n\n     \n     if (!IsGoodVal(\"0.10\", cmsEvalToneCurveFloat(reverse_sinus, 0.10f), asin(0.10)/M_PI, 0.001)) goto Error;\n     if (!IsGoodVal(\"0.60\", cmsEvalToneCurveFloat(reverse_sinus, 0.60f), asin(0.60)/M_PI, 0.001)) goto Error;\n     if (!IsGoodVal(\"0.90\", cmsEvalToneCurveFloat(reverse_sinus, 0.90f), asin(0.90)/M_PI, 0.001)) goto Error;\n\n     if (!IsGoodVal(\"0.10\", cmsEvalToneCurveFloat(reverse_cosinus, 0.10f), acos(0.10)/M_PI, 0.001)) goto Error;\n     if (!IsGoodVal(\"0.60\", cmsEvalToneCurveFloat(reverse_cosinus, 0.60f), acos(0.60)/M_PI, 0.001)) goto Error;\n     if (!IsGoodVal(\"0.90\", cmsEvalToneCurveFloat(reverse_cosinus, 0.90f), acos(0.90)/M_PI, 0.001)) goto Error;\n\n     cmsFreeToneCurve(sinus);\n     cmsFreeToneCurve(cosinus);\n     cmsFreeToneCurve(tangent);\n     cmsFreeToneCurve(reverse_sinus);\n     cmsFreeToneCurve(reverse_cosinus);\n\n     cmsDeleteContext(ctx);\n     cmsDeleteContext(cpy);\n     cmsDeleteContext(cpy2);\n\n     return 1;\n\nError:\n     \n     cmsFreeToneCurve(sinus);\n     cmsFreeToneCurve(reverse_sinus);\n     cmsFreeToneCurve(cosinus);\n     cmsFreeToneCurve(reverse_cosinus);\n\n     if (ctx != NULL) cmsDeleteContext(ctx);\n     if (cpy != NULL) cmsDeleteContext(cpy);\n     if (cpy2 != NULL) cmsDeleteContext(cpy2);\n     return 0;\n}",
          "fn_code_pos": [
            [
              550,
              0
            ],
            [
              627,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckParametricCurvePlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "cmsUInt8Number* my_Unroll565(CMSREGISTER struct _cmstransform_struct* nfo, \n                            CMSREGISTER cmsUInt16Number wIn[], \n                            CMSREGISTER cmsUInt8Number* accum,\n                            CMSREGISTER cmsUInt32Number Stride)\n{\n    cmsUInt16Number pixel = *(cmsUInt16Number*) accum;  // Take whole pixel\n\n    double r = floor(((double) (pixel & 31) * 65535.0) / 31.0 + 0.5);\n    double g = floor((((pixel >> 5) & 63) * 65535.0) / 63.0 + 0.5);\n    double b = floor((((pixel >> 11) & 31) * 65535.0) / 31.0 + 0.5);\n    \n    wIn[2] = (cmsUInt16Number) r;\n    wIn[1] = (cmsUInt16Number) g;\n    wIn[0] = (cmsUInt16Number) b;\n    \n    return accum + 2;\n}",
          "fn_code_pos": [
            [
              637,
              0
            ],
            [
              653,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "my_Unroll565",
            "parameters": {
              "struct": "CMSREGISTER",
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "cmsUInt8Number* my_Pack565(CMSREGISTER _cmsTRANSFORM* info, \n                           CMSREGISTER cmsUInt16Number wOut[],\n                           CMSREGISTER cmsUInt8Number* output,\n                           CMSREGISTER cmsUInt32Number Stride)\n{\n\n    CMSREGISTER cmsUInt16Number pixel;\n    int r, g, b;\n\n    r = (int) floor(( wOut[2] * 31) / 65535.0 + 0.5);\n    g = (int) floor(( wOut[1] * 63) / 65535.0 + 0.5);\n    b = (int) floor(( wOut[0] * 31) / 65535.0 + 0.5);\n\n\n    pixel = (r & 31)  | (( g & 63) << 5) | ((b & 31) << 11);\n\n    \n    *(cmsUInt16Number*) output = pixel;\n    return output + 2;\n}",
          "fn_code_pos": [
            [
              655,
              0
            ],
            [
              674,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "my_Pack565",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": "cmsUInt8Number"
          }
        },
        {
          "fn_code": "cmsFormatter my_FormatterFactory(cmsUInt32Number Type, \n                                  cmsFormatterDirection Dir, \n                                  cmsUInt32Number dwFlags)\n{\n    cmsFormatter Result = { NULL };\n\n    if ((Type == TYPE_RGB_565) && \n        !(dwFlags & CMS_PACK_FLAGS_FLOAT) &&\n        (Dir == cmsFormatterInput)) {\n            Result.Fmt16 = my_Unroll565;       \n    }\n    return Result;\n}",
          "fn_code_pos": [
            [
              677,
              0
            ],
            [
              689,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "my_FormatterFactory",
            "parameters": {
              "Type": "cmsUInt32Number",
              "Dir": "cmsFormatterDirection",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsFormatter"
          }
        },
        {
          "fn_code": "cmsFormatter my_FormatterFactory2(cmsUInt32Number Type, \n                                  cmsFormatterDirection Dir, \n                                  cmsUInt32Number dwFlags)\n{\n    cmsFormatter Result = { NULL };\n\n    if ((Type == TYPE_RGB_565) && \n        !(dwFlags & CMS_PACK_FLAGS_FLOAT) &&\n        (Dir == cmsFormatterOutput)) {\n            Result.Fmt16 = my_Pack565;       \n    }\n    return Result;\n}",
          "fn_code_pos": [
            [
              692,
              0
            ],
            [
              704,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "my_FormatterFactory2",
            "parameters": {
              "Type": "cmsUInt32Number",
              "Dir": "cmsFormatterDirection",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsFormatter"
          }
        },
        {
          "fn_code": "cmsInt32Number CheckFormattersPlugin(void)\n{\n    cmsContext ctx = WatchDogContext(NULL);\n    cmsContext cpy;\n    cmsContext cpy2;\n    cmsHTRANSFORM xform;\n    cmsUInt16Number stream[]= { 0xffffU, 0x1234U, 0x0000U, 0x33ddU };\n    cmsUInt16Number result[4];\n    int i;\n\n    \n    cmsPluginTHR(ctx, &FormattersPluginSample);\n\n    cpy = DupContext(ctx, NULL);\n    \n    cmsPluginTHR(cpy, &FormattersPluginSample2);\n\n    cpy2 = DupContext(cpy, NULL);\n    \n    xform = cmsCreateTransformTHR(cpy2, NULL, TYPE_RGB_565, NULL, TYPE_RGB_565, INTENT_PERCEPTUAL, cmsFLAGS_NULLTRANSFORM);\n\n    cmsDoTransform(xform, stream, result, 4);\n\n    cmsDeleteTransform(xform);\n    cmsDeleteContext(ctx);\n    cmsDeleteContext(cpy);\n    cmsDeleteContext(cpy2);\n\n    for (i=0; i < 4; i++)\n        if (stream[i] != result[i]) return 0;\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              723,
              0
            ],
            [
              755,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckFormattersPlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid *Type_int_Read(struct _cms_typehandler_struct* self,\n \t\t\t    cmsIOHANDLER* io, \n               cmsUInt32Number* nItems, \n               cmsUInt32Number SizeOfTag)\n{\n    cmsUInt32Number* Ptr = (cmsUInt32Number*) _cmsMalloc(self ->ContextID, sizeof(cmsUInt32Number));\n    if (Ptr == NULL) return NULL;\n    if (!_cmsReadUInt32Number(io, Ptr)) return NULL;\n    *nItems = 1;\n    return Ptr;\n}",
          "fn_code_pos": [
            [
              766,
              0
            ],
            [
              777,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_int_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_int_Write(struct _cms_typehandler_struct* self,\n                        cmsIOHANDLER* io, \n                        void* Ptr, cmsUInt32Number nItems)\n{\n    return _cmsWriteUInt32Number(io, *(cmsUInt32Number*) Ptr);\n}",
          "fn_code_pos": [
            [
              779,
              0
            ],
            [
              785,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_int_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid* Type_int_Dup(struct _cms_typehandler_struct* self, \n                   const void *Ptr, cmsUInt32Number n)\n{\n    return _cmsDupMem(self ->ContextID, Ptr, n * sizeof(cmsUInt32Number));\n}",
          "fn_code_pos": [
            [
              787,
              0
            ],
            [
              792,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_int_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Type_int_Free(struct _cms_typehandler_struct* self, \n                   void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}",
          "fn_code_pos": [
            [
              794,
              0
            ],
            [
              798,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_int_Free",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsInt32Number CheckTagTypePlugin(void)\n{\n    cmsContext ctx = NULL;\n    cmsContext cpy = NULL;\n    cmsContext cpy2 = NULL;\n    cmsHPROFILE h = NULL;\n    cmsUInt32Number myTag = 1234;\n    cmsUInt32Number myTag32 = 5678;\n    cmsUInt32Number rc = 0;\n    char* data = NULL;\n    cmsUInt32Number *ptr = NULL;\n    cmsUInt32Number clen = 0;\n\n\n    ctx = WatchDogContext(NULL);\n    cmsPluginTHR(ctx, &TagTypePluginSample);\n\n    cpy = DupContext(ctx, NULL);    \n    cpy2 = DupContext(cpy, NULL);\n    \n    cmsDeleteContext(ctx);\n    cmsDeleteContext(cpy);\n    \n    h = cmsCreateProfilePlaceholder(cpy2);\n    if (h == NULL) {\n        Fail(\"Create placeholder failed\");\n        goto Error;\n    }\n\n\n    if (!cmsWriteTag(h, SigInt, &myTag)) {\n        Fail(\"Plug-in failed\");\n        goto Error;\n    }\n\n    if (!cmsWriteTag(h, SigInt32, &myTag32)) {\n        Fail(\"Plug-in failed\");\n        goto Error;\n    }\n\n\n    rc = cmsSaveProfileToMem(h, NULL, &clen);\n    if (!rc) {\n        Fail(\"Fetch mem size failed\");\n        goto Error;        \n    }\n\n\n    data = (char*) malloc(clen);\n    if (data == NULL) {\n        Fail(\"malloc failed ?!?\");\n        goto Error;\n    }\n\n\n    rc = cmsSaveProfileToMem(h, data, &clen);\n    if (!rc) {\n        Fail(\"Save to mem failed\");\n        goto Error;\n    }\n\n    cmsCloseProfile(h);\n\n    cmsSetLogErrorHandler(NULL);\n    h = cmsOpenProfileFromMem(data, clen);    \n    if (h == NULL) {\n        Fail(\"Open profile failed\");\n        goto Error;\n    }\n\n    ptr = (cmsUInt32Number*) cmsReadTag(h, SigInt);\n    if (ptr != NULL) {\n\n        Fail(\"read tag/context switching failed\");\n        goto Error;\n    }\n\n    ptr = (cmsUInt32Number*)cmsReadTag(h, SigInt32);\n    if (ptr != NULL) {\n\n        Fail(\"read tag/context switching failed\");\n        goto Error;\n    }\n\n\n    cmsCloseProfile(h);\n    ResetFatalError();\n\n    h = cmsOpenProfileFromMemTHR(cpy2, data, clen);    \n    if (h == NULL) {\n        Fail(\"Open profile from mem failed\");\n        goto Error;\n    }\n\n    // Get rid of data\n    free(data); data = NULL;\n\n    ptr = (cmsUInt32Number*) cmsReadTag(h, SigInt);\n    if (ptr == NULL) {        \n        Fail(\"Read tag/context switching failed (2)\");\n        return 0;\n    }\n   \n    rc = (*ptr == 1234);\n\n    ptr = (cmsUInt32Number*)cmsReadTag(h, SigInt32);\n    if (ptr == NULL) {\n\n        Fail(\"read tag/context switching failed (2)\");\n        goto Error;\n    }\n\n    rc &= (*ptr == 5678);\n\n    cmsCloseProfile(h);\n\n    cmsDeleteContext(cpy2);\n\n    return rc;\n\nError:\n\n    if (h != NULL) cmsCloseProfile(h);\n    if (ctx != NULL) cmsDeleteContext(ctx);\n    if (cpy != NULL) cmsDeleteContext(cpy);\n    if (cpy2 != NULL) cmsDeleteContext(cpy2);\n    if (data) free(data);\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              821,
              0
            ],
            [
              950,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckTagTypePlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid EvaluateNegate(const cmsFloat32Number In[], \n                     cmsFloat32Number Out[], \n                     const cmsStage *mpe)\n{\n    Out[0] = 1.0f - In[0];\n    Out[1] = 1.0f - In[1];\n    Out[2] = 1.0f - In[2];\n}",
          "fn_code_pos": [
            [
              957,
              0
            ],
            [
              965,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EvaluateNegate",
            "parameters": {
              "In": "cmsFloat32Number",
              "Out": "cmsFloat32Number",
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsStage* StageAllocNegate(cmsContext ContextID)\n{\n    return _cmsStageAllocPlaceholder(ContextID,\n                 SigNegateType, 3, 3, EvaluateNegate, \n                 NULL, NULL, NULL);\n}",
          "fn_code_pos": [
            [
              967,
              0
            ],
            [
              973,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "StageAllocNegate",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "cmsStage"
          }
        },
        {
          "fn_code": "static\nvoid *Type_negate_Read(struct _cms_typehandler_struct* self,\n \t\t\t    cmsIOHANDLER* io, \n                cmsUInt32Number* nItems, \n                cmsUInt32Number SizeOfTag)\n{\n    cmsUInt16Number   Chans;\n    if (!_cmsReadUInt16Number(io, &Chans)) return NULL;\n    if (Chans != 3) return NULL;\n\n    *nItems = 1;\n    return StageAllocNegate(self -> ContextID);\n}",
          "fn_code_pos": [
            [
              975,
              0
            ],
            [
              987,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_negate_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool Type_negate_Write(struct _cms_typehandler_struct* self,\n                        cmsIOHANDLER* io, \n                        void* Ptr, cmsUInt32Number nItems)\n{\n\n    if (!_cmsWriteUInt16Number(io, 3)) return FALSE;    \n    return TRUE;\n}",
          "fn_code_pos": [
            [
              989,
              0
            ],
            [
              997,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_negate_Write",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsInt32Number CheckMPEPlugin(void)\n{\n    cmsContext ctx = NULL;\n    cmsContext cpy = NULL;\n    cmsContext cpy2 = NULL;\n    cmsHPROFILE h = NULL;\n    cmsUInt32Number rc = 0;\n    char* data = NULL;\n    cmsUInt32Number clen = 0;\n    cmsFloat32Number In[3], Out[3];\n    cmsPipeline* pipe;\n\n    ctx = WatchDogContext(NULL);\n    cmsPluginTHR(ctx, &MPEPluginSample);\n\n    cpy =  DupContext(ctx, NULL);    \n    cpy2 = DupContext(cpy, NULL);\n    \n    cmsDeleteContext(ctx);\n    cmsDeleteContext(cpy);\n    \n    h = cmsCreateProfilePlaceholder(cpy2);\n    if (h == NULL) {\n        Fail(\"Create placeholder failed\");\n        goto Error;\n    }\n    \n    pipe = cmsPipelineAlloc(cpy2, 3, 3);\n    cmsPipelineInsertStage(pipe, cmsAT_BEGIN, StageAllocNegate(cpy2));\n\n\n    In[0] = 0.3f; In[1] = 0.2f; In[2] = 0.9f;\n    cmsPipelineEvalFloat(In, Out, pipe);\n\n    rc = (IsGoodVal(\"0\", Out[0], 1.0-In[0], 0.001) && \n           IsGoodVal(\"1\", Out[1], 1.0-In[1], 0.001) && \n           IsGoodVal(\"2\", Out[2], 1.0-In[2], 0.001));\n\n    if (!rc) {\n        Fail(\"Pipeline failed\");\n        goto Error;    \n    }\n\n    if (!cmsWriteTag(h, cmsSigDToB3Tag, pipe)) {\n        Fail(\"Plug-in failed\");\n        goto Error;\n    }\n\n    // This cleans the stage as well\n    cmsPipelineFree(pipe);\n\n    rc = cmsSaveProfileToMem(h, NULL, &clen);\n    if (!rc) {\n        Fail(\"Fetch mem size failed\");\n        goto Error;        \n    }\n\n\n    data = (char*) malloc(clen);\n    if (data == NULL) {\n        Fail(\"malloc failed ?!?\");\n        goto Error;\n    }\n\n\n    rc = cmsSaveProfileToMem(h, data, &clen);\n    if (!rc) {\n        Fail(\"Save to mem failed\");\n        goto Error;\n    }\n\n    cmsCloseProfile(h);\n\n\n    cmsSetLogErrorHandler(NULL);\n    h = cmsOpenProfileFromMem(data, clen);    \n    if (h == NULL) {\n        Fail(\"Open profile failed\");\n        goto Error;\n    } \n\n    pipe = (cmsPipeline*) cmsReadTag(h, cmsSigDToB3Tag);\n    if (pipe != NULL) {\n\n        // Unsupported stage, should fail\n        Fail(\"read tag/context switching failed\");\n        goto Error;\n    }\n\n    cmsCloseProfile(h);\n\n    ResetFatalError();\n\n    h = cmsOpenProfileFromMemTHR(cpy2, data, clen);    \n    if (h == NULL) {\n        Fail(\"Open profile from mem failed\");\n        goto Error;\n    }\n\n    // Get rid of data\n    free(data); data = NULL;\n\n    pipe = (cmsPipeline*) cmsReadTag(h, cmsSigDToB3Tag);\n    if (pipe == NULL) {        \n        Fail(\"Read tag/context switching failed (2)\");\n        return 0;\n    }\n   \n    // Evaluate for negation\n    In[0] = 0.3f; In[1] = 0.2f; In[2] = 0.9f;\n    cmsPipelineEvalFloat(In, Out, pipe);\n\n     rc = (IsGoodVal(\"0\", Out[0], 1.0-In[0], 0.001) && \n           IsGoodVal(\"1\", Out[1], 1.0-In[1], 0.001) && \n           IsGoodVal(\"2\", Out[2], 1.0-In[2], 0.001));\n        \n    cmsCloseProfile(h);\n\n    cmsDeleteContext(cpy2);\n\n    return rc;\n\nError:\n\n    if (h != NULL) cmsCloseProfile(h);\n    if (ctx != NULL) cmsDeleteContext(ctx);\n    if (cpy != NULL) cmsDeleteContext(cpy);\n    if (cpy2 != NULL) cmsDeleteContext(cpy2);\n    if (data) free(data);\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              1008,
              0
            ],
            [
              1139,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMPEPlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid FastEvaluateCurves(CMSREGISTER const cmsUInt16Number In[],\n                        CMSREGISTER cmsUInt16Number Out[],\n                        CMSREGISTER const void* Data)\n{\n    Out[0] = In[0];\n}",
          "fn_code_pos": [
            [
              1146,
              0
            ],
            [
              1152,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FastEvaluateCurves",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool MyOptimize(cmsPipeline** Lut, \n                   cmsUInt32Number  Intent, \n                   cmsUInt32Number* InputFormat, \n                   cmsUInt32Number* OutputFormat, \n                   cmsUInt32Number* dwFlags)\n{\n    cmsStage* mpe;\n     _cmsStageToneCurvesData* Data;\n\n    //  Only curves in this LUT? All are identities?\n    for (mpe = cmsPipelineGetPtrToFirstStage(*Lut);\n         mpe != NULL;\n         mpe = cmsStageNext(mpe)) {\n\n            if (cmsStageType(mpe) != cmsSigCurveSetElemType) return FALSE;\n\n            // Check for identity\n            Data = (_cmsStageToneCurvesData*) cmsStageData(mpe);\n            if (Data ->nCurves != 1) return FALSE;\n            if (cmsEstimateGamma(Data->TheCurves[0], 0.1) > 1.0) return FALSE;\n          \n    }\n\n    *dwFlags |= cmsFLAGS_NOCACHE;\n    _cmsPipelineSetOptimizationParameters(*Lut, FastEvaluateCurves, NULL, NULL, NULL);\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1154,
              0
            ],
            [
              1182,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MyOptimize",
            "parameters": {
              "Lut": "cmsPipeline",
              "Intent": "cmsUInt32Number",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsInt32Number CheckOptimizationPlugin(void)\n{\n    cmsContext ctx = WatchDogContext(NULL);\n    cmsContext cpy;\n    cmsContext cpy2;\n    cmsHTRANSFORM xform;\n    cmsUInt8Number In[]= { 10, 20, 30, 40 };\n    cmsUInt8Number Out[4];\n    cmsToneCurve* Linear[1];\n    cmsHPROFILE h;\n    int i;\n    \n    cmsPluginTHR(ctx, &OptimizationPluginSample);\n\n    cpy = DupContext(ctx, NULL);\n    cpy2 = DupContext(cpy, NULL);\n    \n    Linear[0] = cmsBuildGamma(cpy2, 1.0);\n    h = cmsCreateLinearizationDeviceLinkTHR(cpy2, cmsSigGrayData, Linear);\n    cmsFreeToneCurve(Linear[0]);\n\n    xform = cmsCreateTransformTHR(cpy2, h, TYPE_GRAY_8, h, TYPE_GRAY_8, INTENT_PERCEPTUAL, 0);\n    cmsCloseProfile(h);\n\n    cmsDoTransform(xform, In, Out, 4);\n\n    cmsDeleteTransform(xform);\n    cmsDeleteContext(ctx);\n    cmsDeleteContext(cpy);\n    cmsDeleteContext(cpy2);\n\n    for (i=0; i < 4; i++)\n        if (In[i] != Out[i]) return 0;\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              1191,
              0
            ],
            [
              1226,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckOptimizationPlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsPipeline*  MyNewIntent(cmsContext      ContextID, \n                          cmsUInt32Number nProfiles,\n                          cmsUInt32Number TheIntents[], \n                          cmsHPROFILE     hProfiles[], \n                          cmsBool         BPC[],\n                          cmsFloat64Number AdaptationStates[],\n                          cmsUInt32Number dwFlags)\n{\n    cmsPipeline*    Result;\n    cmsUInt32Number ICCIntents[256];\n    cmsUInt32Number i;\n\n for (i=0; i < nProfiles; i++) \n        ICCIntents[i] = (TheIntents[i] == INTENT_DECEPTIVE) ? INTENT_PERCEPTUAL : \n                                                 TheIntents[i];\n\n if (cmsGetColorSpace(hProfiles[0]) != cmsSigGrayData ||\n     cmsGetColorSpace(hProfiles[nProfiles-1]) != cmsSigGrayData) \n           return _cmsDefaultICCintents(ContextID, nProfiles, \n                                   ICCIntents, hProfiles, \n                                   BPC, AdaptationStates, \n                                   dwFlags);\n\n    Result = cmsPipelineAlloc(ContextID, 1, 1);\n    if (Result == NULL) return NULL;\n\n    cmsPipelineInsertStage(Result, cmsAT_BEGIN,\n                            cmsStageAllocIdentity(ContextID, 1));\n\n    return Result;\n}",
          "fn_code_pos": [
            [
              1242,
              0
            ],
            [
              1273,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MyNewIntent",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "TheIntents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsPipeline"
          }
        },
        {
          "fn_code": "cmsInt32Number CheckIntentPlugin(void)\n{\n    cmsContext ctx = WatchDogContext(NULL);\n    cmsContext cpy;\n    cmsContext cpy2;\n    cmsHTRANSFORM xform;\n    cmsHPROFILE h1, h2;\n    cmsToneCurve* Linear1;\n    cmsToneCurve* Linear2;\n    cmsUInt8Number In[]= { 10, 20, 30, 40 };\n    cmsUInt8Number Out[4];\n    int i;\n    \n    cmsPluginTHR(ctx, &IntentPluginSample);\n\n    cpy  = DupContext(ctx, NULL);    \n    cpy2 = DupContext(cpy, NULL);\n    \n    Linear1 = cmsBuildGamma(cpy2, 3.0);\n    Linear2 = cmsBuildGamma(cpy2, 0.1);\n    h1 = cmsCreateLinearizationDeviceLinkTHR(cpy2, cmsSigGrayData, &Linear1);\n    h2 = cmsCreateLinearizationDeviceLinkTHR(cpy2, cmsSigGrayData, &Linear2);\n\n    cmsFreeToneCurve(Linear1);\n    cmsFreeToneCurve(Linear2);\n\n    xform = cmsCreateTransformTHR(cpy2, h1, TYPE_GRAY_8, h2, TYPE_GRAY_8, INTENT_DECEPTIVE, 0);\n    cmsCloseProfile(h1); cmsCloseProfile(h2);\n\n    cmsDoTransform(xform, In, Out, 4);\n\n    cmsDeleteTransform(xform);\n    cmsDeleteContext(ctx);\n    cmsDeleteContext(cpy);\n    cmsDeleteContext(cpy2);\n\n    for (i=0; i < 4; i++)\n        if (Out[i] != In[i]) return 0;\n\n    return 1;    \n}",
          "fn_code_pos": [
            [
              1282,
              0
            ],
            [
              1322,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckIntentPlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid TrancendentalTransform(struct _cmstransform_struct * CMM,\n                              const void* InputBuffer,\n                              void* OutputBuffer,\n                              cmsUInt32Number Size,\n                              cmsUInt32Number Stride)\n{\n    cmsUInt32Number i;\n\n    for (i=0; i < Size; i++)\n    {\n        ((cmsUInt8Number*) OutputBuffer)[i] = 0x42;\n    }\n\n}",
          "fn_code_pos": [
            [
              1330,
              0
            ],
            [
              1344,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TrancendentalTransform",
            "parameters": {
              "CMM": "struct _cmstransform_struct",
              "InputBuffer": "void",
              "OutputBuffer": "void",
              "Size": "cmsUInt32Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsBool  TransformFactory(_cmsTransformFn* xformPtr,\n                          void** UserData,\n                           _cmsFreeUserDataFn* FreePrivateDataFn,\n                           cmsPipeline** Lut,\n                           cmsUInt32Number* InputFormat,\n                           cmsUInt32Number* OutputFormat,\n                           cmsUInt32Number* dwFlags)\n\n{\n    if (*OutputFormat == TYPE_GRAY_8)\n    {\n        // *Lut holds the pipeline to be applied\n        *xformPtr = TrancendentalTransform;\n        return TRUE;\n    }\n\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              1347,
              0
            ],
            [
              1364,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TransformFactory",
            "parameters": {
              "xformPtr": "_cmsTransformFn",
              "UserData": "void",
              "FreePrivateDataFn": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsInt32Number CheckTransformPlugin(void)\n{\n    cmsContext ctx = WatchDogContext(NULL);\n    cmsContext cpy;\n    cmsContext cpy2;\n    cmsHTRANSFORM xform;\n    cmsUInt8Number In[]= { 10, 20, 30, 40 };\n    cmsUInt8Number Out[4];\n    cmsToneCurve* Linear;\n    cmsHPROFILE h;\n    int i;\n\n    \n    cmsPluginTHR(ctx, &FullTransformPluginSample);\n\n    cpy  = DupContext(ctx, NULL);\n    cpy2 = DupContext(cpy, NULL);\n    \n    Linear = cmsBuildGamma(cpy2, 1.0);\n    h = cmsCreateLinearizationDeviceLinkTHR(cpy2, cmsSigGrayData, &Linear);\n    cmsFreeToneCurve(Linear);\n\n    xform = cmsCreateTransformTHR(cpy2, h, TYPE_GRAY_8, h, TYPE_GRAY_8, INTENT_PERCEPTUAL, 0);\n    cmsCloseProfile(h);\n\n    cmsDoTransform(xform, In, Out, 4);\n\n\n    cmsDeleteTransform(xform);\n    cmsDeleteContext(ctx);\n    cmsDeleteContext(cpy);\n    cmsDeleteContext(cpy2);\n\n    for (i=0; i < 4; i++)\n        if (Out[i] != 0x42) return 0;\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              1375,
              0
            ],
            [
              1412,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckTransformPlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid* MyMtxCreate(cmsContext id)\n{\n   MyMtx* mtx = (MyMtx*) _cmsMalloc(id, sizeof(MyMtx));\n   mtx ->nlocks = 0;\n   return mtx;\n}",
          "fn_code_pos": [
            [
              1424,
              0
            ],
            [
              1430,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MyMtxCreate",
            "parameters": {
              "id": "cmsContext"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid MyMtxDestroy(cmsContext id, void* mtx)\n{\n    MyMtx* mtx_ = (MyMtx*) mtx;\n\n    if (mtx_->nlocks != 0)\n        Die(\"Locks != 0 when setting free a mutex\");\n\n    _cmsFree(id, mtx);\n\n}",
          "fn_code_pos": [
            [
              1432,
              0
            ],
            [
              1442,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MyMtxDestroy",
            "parameters": {
              "id": "cmsContext",
              "mtx": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool MyMtxLock(cmsContext id, void* mtx)\n{\n    MyMtx* mtx_ = (MyMtx*) mtx;\n    mtx_->nlocks++;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1444,
              0
            ],
            [
              1451,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MyMtxLock",
            "parameters": {
              "id": "cmsContext",
              "mtx": "void"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid MyMtxUnlock(cmsContext id, void* mtx)\n{\n    MyMtx* mtx_ = (MyMtx*) mtx;\n    mtx_->nlocks--;\n\n}",
          "fn_code_pos": [
            [
              1453,
              0
            ],
            [
              1459,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MyMtxUnlock",
            "parameters": {
              "id": "cmsContext",
              "mtx": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsInt32Number CheckMutexPlugin(void)\n{\n    cmsContext ctx = WatchDogContext(NULL);\n    cmsContext cpy;\n    cmsContext cpy2;\n    cmsHTRANSFORM xform;\n    cmsUInt8Number In[]= { 10, 20, 30, 40 };\n    cmsUInt8Number Out[4];\n    cmsToneCurve* Linear;\n    cmsHPROFILE h;\n    int i;\n\n    \n    cmsPluginTHR(ctx, &MutexPluginSample);\n\n    cpy  = DupContext(ctx, NULL);\n    cpy2 = DupContext(cpy, NULL);\n    \n    Linear = cmsBuildGamma(cpy2, 1.0);\n    h = cmsCreateLinearizationDeviceLinkTHR(cpy2, cmsSigGrayData, &Linear);\n    cmsFreeToneCurve(Linear);\n\n    xform = cmsCreateTransformTHR(cpy2, h, TYPE_GRAY_8, h, TYPE_GRAY_8, INTENT_PERCEPTUAL, 0);\n    cmsCloseProfile(h);\n\n    cmsDoTransform(xform, In, Out, 4);\n\n\n    cmsDeleteTransform(xform);\n    cmsDeleteContext(ctx);\n    cmsDeleteContext(cpy);\n    cmsDeleteContext(cpy2);\n\n    for (i=0; i < 4; i++)\n        if (Out[i] != In[i]) return 0;\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              1470,
              0
            ],
            [
              1507,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMutexPlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "cmsInt32Number CheckMethodPackDoublesFromFloat(void)\n{\n\n    cmsContext ctx = WatchDogContext(NULL);\n\n    cmsHTRANSFORM xform; \n    cmsHTRANSFORM l_pFakeProfileLAB;\n\n    cmsFloat64Number l_D_OutputColorArrayBlack[8];\n    cmsFloat64Number l_D_OutputColorArrayBlue[8];\n\n    cmsCIELab LabInBlack; \n    cmsCIELab LabInBlue;\n\n    cmsUInt16Number Lab_UI16_Black[3];\n    cmsUInt16Number Lab_UI16_Blue[3];\n\n    cmsHPROFILE OutputCMYKProfile;\n    cmsUInt32Number l_UI32_OutputFormat;\n\n\n    cmsPluginTHR(ctx, &FullTransformPluginSample);\n\n\n    l_pFakeProfileLAB = cmsCreateLab2ProfileTHR(ctx, NULL);\n\n    if (l_pFakeProfileLAB == NULL)\n        return 0;\n\n    OutputCMYKProfile = cmsOpenProfileFromFileTHR(ctx, \"TestCLT.icc\", \"r\");\n\n    if (OutputCMYKProfile == NULL)\n        return 0;\n\n    l_UI32_OutputFormat = 0;\n    l_UI32_OutputFormat |= COLORSPACE_SH(PT_CMYK);\n    l_UI32_OutputFormat |= PLANAR_SH(1);\n    l_UI32_OutputFormat |= CHANNELS_SH(4);\n    l_UI32_OutputFormat |= BYTES_SH(0);\n    l_UI32_OutputFormat |= FLOAT_SH(1);\n\n\n    xform = cmsCreateTransformTHR(ctx, l_pFakeProfileLAB, TYPE_Lab_DBL, OutputCMYKProfile, l_UI32_OutputFormat, INTENT_PERCEPTUAL, 0);\n    cmsCloseProfile(OutputCMYKProfile);\n    cmsCloseProfile(l_pFakeProfileLAB);\n\n    Lab_UI16_Black[0] = 0;\n    Lab_UI16_Black[1] = 32768;\n    Lab_UI16_Black[2] = 32768;\n\n    Lab_UI16_Blue[0] = 0;\n    Lab_UI16_Blue[1] = 8192;\n    Lab_UI16_Blue[2] = 8192;\n\n    cmsLabEncoded2Float(&LabInBlack, Lab_UI16_Black);\n    cmsLabEncoded2Float(&LabInBlue, Lab_UI16_Blue);\n\n    memset(l_D_OutputColorArrayBlack, 0, sizeof(l_D_OutputColorArrayBlack));\n    memset(l_D_OutputColorArrayBlue, 0, sizeof(l_D_OutputColorArrayBlue));\n\n    cmsDoTransform(xform, &LabInBlack, l_D_OutputColorArrayBlack, 1);\n    cmsDoTransform(xform, &LabInBlue, l_D_OutputColorArrayBlue, 1);\n\n\n    cmsDeleteTransform(xform);\n    cmsDeleteContext(ctx);\n    \n    return 1;\n}",
          "fn_code_pos": [
            [
              1510,
              0
            ],
            [
              1578,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMethodPackDoublesFromFloat",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "my_Unroll565(CMSREGISTER struct _cmstransform_struct* nfo, \n                            CMSREGISTER cmsUInt16Number wIn[], \n                            CMSREGISTER cmsUInt8Number* accum,\n                            CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              637,
              16
            ],
            [
              640,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "my_Unroll565",
            "parameters": {
              "struct": "CMSREGISTER",
              "wIn": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "my_Pack565(CMSREGISTER _cmsTRANSFORM* info, \n                           CMSREGISTER cmsUInt16Number wOut[],\n                           CMSREGISTER cmsUInt8Number* output,\n                           CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              655,
              16
            ],
            [
              658,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "my_Pack565",
            "parameters": {
              "wOut": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_int_Read(struct _cms_typehandler_struct* self,\n \t\t\t    cmsIOHANDLER* io, \n               cmsUInt32Number* nItems, \n               cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              767,
              6
            ],
            [
              770,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_int_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_int_Dup(struct _cms_typehandler_struct* self, \n                   const void *Ptr, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              788,
              6
            ],
            [
              789,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_int_Dup",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "StageAllocNegate(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              968,
              10
            ],
            [
              968,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "StageAllocNegate",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type_negate_Read(struct _cms_typehandler_struct* self,\n \t\t\t    cmsIOHANDLER* io, \n                cmsUInt32Number* nItems, \n                cmsUInt32Number SizeOfTag)",
          "fn_dec_pos": [
            [
              976,
              6
            ],
            [
              979,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Type_negate_Read",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "MyNewIntent(cmsContext      ContextID, \n                          cmsUInt32Number nProfiles,\n                          cmsUInt32Number TheIntents[], \n                          cmsHPROFILE     hProfiles[], \n                          cmsBool         BPC[],\n                          cmsFloat64Number AdaptationStates[],\n                          cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              1243,
              14
            ],
            [
              1249,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MyNewIntent",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "TheIntents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "MyMtxCreate(cmsContext id)",
          "fn_dec_pos": [
            [
              1425,
              6
            ],
            [
              1425,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MyMtxCreate",
            "parameters": {
              "id": "cmsContext"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n    int nlocks;\n} MyMtx;",
          {
            "nlocks": "int"
          },
          "MyMtx",
          [
            1419,
            0
          ],
          [
            1421,
            8
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            767,
            20
          ],
          [
            767,
            50
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            780,
            23
          ],
          [
            780,
            53
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            788,
            19
          ],
          [
            788,
            49
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            794,
            19
          ],
          [
            794,
            49
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            976,
            23
          ],
          [
            976,
            53
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            990,
            26
          ],
          [
            990,
            56
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            1331,
            28
          ],
          [
            1331,
            55
          ]
        ],
        [
          "typedef struct {\n    int nlocks;\n} MyMtx;",
          {
            "nlocks": "int"
          },
          "MyMtx",
          [
            1419,
            0
          ],
          [
            1421,
            8
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"testcms2.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/testbed/testcms2.c": {
      "fn_def_list": [
        {
          "fn_code": "void Die(const char* Reason, ...)\n{\n    va_list args;\n    va_start(args, Reason);\n    vsprintf(ReasonToFailBuffer, Reason, args);\n    va_end(args);\n    printf(\"\\n%s\\n\", ReasonToFailBuffer);\n    fflush(stdout);\n    exit(1);\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              56,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Die",
            "parameters": {
              "Reason": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid* chknull(void* mem)\n{\n    if (mem == NULL)\n        Die(\"Memory may be corrupted\");\n\n    return mem;\n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "chknull",
            "parameters": {
              "mem": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsContext DbgThread(void)\n{\n    static cmsUInt32Number n = 1;\n\n    return (cmsContext) (void*) ((cmsUInt8Number*) NULL + (n++ % 0xff0));\n}",
          "fn_code_pos": [
            [
              100,
              0
            ],
            [
              106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DbgThread",
            "parameters": {},
            "return_type": "cmsContext"
          }
        },
        {
          "fn_code": "static\nvoid* DebugMalloc(cmsContext ContextID, cmsUInt32Number size)\n{\n    _cmsMemoryBlock* blk;\n\n    if (size <= 0) {\n       Die(\"malloc requested with zero bytes\");\n    }\n\n    TotalMemory += size;\n\n    if (TotalMemory > MaxAllocated)\n        MaxAllocated = TotalMemory;\n\n    if (size > SingleHit)\n        SingleHit = size;\n\n    blk = (_cmsMemoryBlock*) chknull(malloc(size + SIZE_OF_MEM_HEADER));\n    if (blk == NULL) return NULL;\n\n    blk ->KeepSize = size;\n    blk ->WhoAllocated = ContextID;\n    blk ->DontCheck = 0;\n\n    return (void*) ((cmsUInt8Number*) blk + SIZE_OF_MEM_HEADER);\n}",
          "fn_code_pos": [
            [
              109,
              0
            ],
            [
              134,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DebugMalloc",
            "parameters": {
              "ContextID": "cmsContext",
              "size": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid  DebugFree(cmsContext ContextID, void *Ptr)\n{\n    _cmsMemoryBlock* blk;\n\n    if (Ptr == NULL) {\n        Die(\"NULL free (which is a no-op in C, but may be an clue of something going wrong)\");\n    }\n\n    blk = (_cmsMemoryBlock*) (((cmsUInt8Number*) Ptr) - SIZE_OF_MEM_HEADER);\n    TotalMemory -= blk ->KeepSize;\n\n    if (blk ->WhoAllocated != ContextID && !blk->DontCheck) {\n        Die(\"Trying to free memory allocated by a different thread\");\n    }\n\n    free(blk);\n}",
          "fn_code_pos": [
            [
              138,
              0
            ],
            [
              155,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DebugFree",
            "parameters": {
              "ContextID": "cmsContext",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid * DebugRealloc(cmsContext ContextID, void* Ptr, cmsUInt32Number NewSize)\n{\n    _cmsMemoryBlock* blk;\n    void*  NewPtr;\n    cmsUInt32Number max_sz;\n\n    NewPtr = DebugMalloc(ContextID, NewSize);\n    if (Ptr == NULL) return NewPtr;\n\n    blk = (_cmsMemoryBlock*) (((cmsUInt8Number*) Ptr) - SIZE_OF_MEM_HEADER);\n    max_sz = blk -> KeepSize > NewSize ? NewSize : blk ->KeepSize;\n    memmove(NewPtr, Ptr, max_sz);\n    DebugFree(ContextID, Ptr);\n\n    return NewPtr;\n}",
          "fn_code_pos": [
            [
              159,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DebugRealloc",
            "parameters": {
              "ContextID": "cmsContext",
              "Ptr": "void",
              "NewSize": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid DebugMemPrintTotals(void)\n{\n    printf(\"[Memory statistics]\\n\");\n    printf(\"Allocated = %u MaxAlloc = %u Single block hit = %u\\n\", TotalMemory, MaxAllocated, SingleHit);\n}",
          "fn_code_pos": [
            [
              178,
              0
            ],
            [
              183,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DebugMemPrintTotals",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void DebugMemDontCheckThis(void *Ptr)\n{\n     _cmsMemoryBlock* blk = (_cmsMemoryBlock*) (((cmsUInt8Number*) Ptr) - SIZE_OF_MEM_HEADER);\n\n     blk ->DontCheck = 1;\n}",
          "fn_code_pos": [
            [
              186,
              0
            ],
            [
              191,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DebugMemDontCheckThis",
            "parameters": {
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nconst char* MemStr(cmsUInt32Number size)\n{\n    static char Buffer[1024];\n\n    if (size > 1024*1024) {\n        sprintf(Buffer, \"%g Mb\", (cmsFloat64Number) size / (1024.0*1024.0));\n    }\n    else\n        if (size > 1024) {\n            sprintf(Buffer, \"%g Kb\", (cmsFloat64Number) size / 1024.0);\n        }\n        else\n            sprintf(Buffer, \"%g bytes\", (cmsFloat64Number) size);\n\n    return Buffer;\n}",
          "fn_code_pos": [
            [
              195,
              0
            ],
            [
              211,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MemStr",
            "parameters": {
              "size": "cmsUInt32Number"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "void TestMemoryLeaks(cmsBool ok)\n{\n    if (TotalMemory > 0)\n        printf(\"Ok, but %s are left!\\n\", MemStr(TotalMemory));\n    else {\n        if (ok) printf(\"Ok.\\n\");\n    }\n}",
          "fn_code_pos": [
            [
              214,
              0
            ],
            [
              221,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestMemoryLeaks",
            "parameters": {
              "ok": "cmsBool"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void* PluginMemHandler(void)\n{\n    return (void*) &DebugMemHandler;\n}",
          "fn_code_pos": [
            [
              228,
              0
            ],
            [
              231,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PluginMemHandler",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsContext WatchDogContext(void* usr)\n{\n    cmsContext ctx;\n\n    ctx = cmsCreateContext(&DebugMemHandler, usr);\n\n    if (ctx == NULL)\n        Die(\"Unable to create memory managed context\");\n\n    DebugMemDontCheckThis(ctx);\n    return ctx;\n}",
          "fn_code_pos": [
            [
              233,
              0
            ],
            [
              244,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WatchDogContext",
            "parameters": {
              "usr": "void"
            },
            "return_type": "cmsContext"
          }
        },
        {
          "fn_code": "static\nvoid FatalErrorQuit(cmsContext ContextID, cmsUInt32Number ErrorCode, const char *Text)\n{\n    Die(Text);\n\n    cmsUNUSED_PARAMETER(ContextID);\n    cmsUNUSED_PARAMETER(ErrorCode);\n}",
          "fn_code_pos": [
            [
              248,
              0
            ],
            [
              255,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FatalErrorQuit",
            "parameters": {
              "ContextID": "cmsContext",
              "ErrorCode": "cmsUInt32Number",
              "Text": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ResetFatalError(void)\n{\n    cmsSetLogErrorHandler(FatalErrorQuit);\n}",
          "fn_code_pos": [
            [
              258,
              0
            ],
            [
              261,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ResetFatalError",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Dot(void)\n{\n    fprintf(stdout, \".\"); fflush(stdout);\n}",
          "fn_code_pos": [
            [
              265,
              0
            ],
            [
              268,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Dot",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Say(const char* str)\n{\n    fprintf(stdout, \"%s\", str); fflush(stdout);\n}",
          "fn_code_pos": [
            [
              270,
              0
            ],
            [
              273,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Say",
            "parameters": {
              "str": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Fail(const char* frm, ...)\n{\n    va_list args;\n    va_start(args, frm);\n    vsprintf(ReasonToFailBuffer, frm, args);\n    va_end(args);\n}",
          "fn_code_pos": [
            [
              278,
              0
            ],
            [
              284,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fail",
            "parameters": {
              "frm": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SubTest(const char* frm, ...)\n{\n    va_list args;\n\n    Dot();\n    va_start(args, frm);\n    vsprintf(SubTestBuffer, frm, args);\n    va_end(args);\n}",
          "fn_code_pos": [
            [
              288,
              0
            ],
            [
              296,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SubTest",
            "parameters": {
              "frm": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Check(const char* Title, TestFn Fn)\n{\n    printf(\"Checking %s ...\", Title);\n    fflush(stdout);\n\n    ReasonToFailBuffer[0] = 0;\n    SubTestBuffer[0] = 0;\n    TrappedError = FALSE;\n    SimultaneousErrors = 0;\n    TotalTests++;\n\n    if (Fn() && !TrappedError) {\n\n        // It is a good place to check memory\n        TestMemoryLeaks(TRUE);\n\n    }\n    else {\n        printf(\"FAIL!\\n\");\n\n        if (SubTestBuffer[0])\n            printf(\"%s: [%s]\\n\\t%s\\n\", Title, SubTestBuffer, ReasonToFailBuffer);\n        else\n            printf(\"%s:\\n\\t%s\\n\", Title, ReasonToFailBuffer);\n\n        if (SimultaneousErrors > 1)\n               printf(\"\\tMore than one (%d) errors were reported\\n\", SimultaneousErrors);\n\n        TotalFail++;\n    }\n    fflush(stdout);\n}",
          "fn_code_pos": [
            [
              299,
              0
            ],
            [
              331,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check",
            "parameters": {
              "Title": "char",
              "Fn": "TestFn"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void DumpToneCurve(cmsToneCurve* gamma, const char* FileName)\n{\n    cmsHANDLE hIT8;\n    cmsUInt32Number i;\n\n    hIT8 = cmsIT8Alloc(gamma ->InterpParams->ContextID);\n\n    cmsIT8SetPropertyDbl(hIT8, \"NUMBER_OF_FIELDS\", 2);\n    cmsIT8SetPropertyDbl(hIT8, \"NUMBER_OF_SETS\", gamma ->nEntries);\n\n    cmsIT8SetDataFormat(hIT8, 0, \"SAMPLE_ID\");\n    cmsIT8SetDataFormat(hIT8, 1, \"VALUE\");\n\n    for (i=0; i < gamma ->nEntries; i++) {\n        char Val[30];\n\n        sprintf(Val, \"%u\", i);\n        cmsIT8SetDataRowCol(hIT8, i, 0, Val);\n        sprintf(Val, \"0x%x\", gamma ->Table16[i]);\n        cmsIT8SetDataRowCol(hIT8, i, 1, Val);\n    }\n\n    cmsIT8SaveToFile(hIT8, FileName);\n    cmsIT8Free(hIT8);\n}",
          "fn_code_pos": [
            [
              334,
              0
            ],
            [
              358,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DumpToneCurve",
            "parameters": {
              "gamma": "cmsToneCurve",
              "FileName": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsHPROFILE Create_AboveRGB(void)\n{\n    cmsToneCurve* Curve[3];\n    cmsHPROFILE hProfile;\n    cmsCIExyY D65;\n    cmsCIExyYTRIPLE Primaries = {{0.64, 0.33, 1 },\n                                 {0.21, 0.71, 1 },\n                                 {0.15, 0.06, 1 }};\n\n    Curve[0] = Curve[1] = Curve[2] = cmsBuildGamma(DbgThread(), 2.19921875);\n\n    cmsWhitePointFromTemp(&D65, 6504);\n    hProfile = cmsCreateRGBProfileTHR(DbgThread(), &D65, &Primaries, Curve);\n    cmsFreeToneCurve(Curve[0]);\n\n    return hProfile;\n}",
          "fn_code_pos": [
            [
              366,
              0
            ],
            [
              383,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Create_AboveRGB",
            "parameters": {},
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "static\ncmsHPROFILE Create_Gray22(void)\n{\n    cmsHPROFILE hProfile;\n    cmsToneCurve* Curve = cmsBuildGamma(DbgThread(), 2.2);\n    if (Curve == NULL) return NULL;\n\n    hProfile = cmsCreateGrayProfileTHR(DbgThread(), cmsD50_xyY(), Curve);\n    cmsFreeToneCurve(Curve);\n\n    return hProfile;\n}",
          "fn_code_pos": [
            [
              386,
              0
            ],
            [
              397,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Create_Gray22",
            "parameters": {},
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "static\ncmsHPROFILE Create_Gray30(void)\n{\n    cmsHPROFILE hProfile;\n    cmsToneCurve* Curve = cmsBuildGamma(DbgThread(), 3.0);\n    if (Curve == NULL) return NULL;\n\n    hProfile = cmsCreateGrayProfileTHR(DbgThread(), cmsD50_xyY(), Curve);\n    cmsFreeToneCurve(Curve);\n\n    return hProfile;\n}",
          "fn_code_pos": [
            [
              400,
              0
            ],
            [
              411,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Create_Gray30",
            "parameters": {},
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "static\ncmsHPROFILE Create_GrayLab(void)\n{\n    cmsHPROFILE hProfile;\n    cmsToneCurve* Curve = cmsBuildGamma(DbgThread(), 1.0);\n    if (Curve == NULL) return NULL;\n\n    hProfile = cmsCreateGrayProfileTHR(DbgThread(), cmsD50_xyY(), Curve);\n    cmsFreeToneCurve(Curve);\n\n    cmsSetPCS(hProfile, cmsSigLabData);\n    return hProfile;\n}",
          "fn_code_pos": [
            [
              414,
              0
            ],
            [
              426,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Create_GrayLab",
            "parameters": {},
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "static\ncmsHPROFILE Create_CMYK_DeviceLink(void)\n{\n    cmsHPROFILE hProfile;\n    cmsToneCurve* Tab[4];\n    cmsToneCurve* Curve = cmsBuildGamma(DbgThread(), 3.0);\n    if (Curve == NULL) return NULL;\n\n    Tab[0] = Curve;\n    Tab[1] = Curve;\n    Tab[2] = Curve;\n    Tab[3] = Curve;\n\n    hProfile = cmsCreateLinearizationDeviceLinkTHR(DbgThread(), cmsSigCmykData, Tab);\n    if (hProfile == NULL) return NULL;\n\n    cmsFreeToneCurve(Curve);\n\n    return hProfile;\n}",
          "fn_code_pos": [
            [
              429,
              0
            ],
            [
              448,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Create_CMYK_DeviceLink",
            "parameters": {},
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "static\ncmsFloat64Number Clip(cmsFloat64Number v)\n{\n    if (v < 0) return 0;\n    if (v > 1) return 1;\n\n    return v;\n}",
          "fn_code_pos": [
            [
              461,
              0
            ],
            [
              468,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Clip",
            "parameters": {
              "v": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number ForwardSampler(CMSREGISTER const cmsUInt16Number In[], cmsUInt16Number Out[], void* Cargo)\n{\n    FakeCMYKParams* p = (FakeCMYKParams*) Cargo;\n    cmsFloat64Number rgb[3], cmyk[4];\n    cmsFloat64Number c, m, y, k;\n\n    cmsDoTransform(p ->hLab2sRGB, In, rgb, 1);\n\n    c = 1 - rgb[0];\n    m = 1 - rgb[1];\n    y = 1 - rgb[2];\n\n    k = (c < m ? cmsmin(c, y) : cmsmin(m, y));\n\n    // NONSENSE WARNING!: I'm doing this just because this is a test\n    // profile that may have ink limit up to 400%. There is no UCR here\n    // so the profile is basically useless for anything but testing.\n\n    cmyk[0] = c;\n    cmyk[1] = m;\n    cmyk[2] = y;\n    cmyk[3] = k;\n\n    cmsDoTransform(p ->hIlimit, cmyk, Out, 1);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              470,
              0
            ],
            [
              497,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ForwardSampler",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "cmsUInt16Number",
              "Cargo": "void"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number ReverseSampler(CMSREGISTER const cmsUInt16Number In[], CMSREGISTER cmsUInt16Number Out[], CMSREGISTER void* Cargo)\n{\n    FakeCMYKParams* p = (FakeCMYKParams*) Cargo;\n    cmsFloat64Number c, m, y, k, rgb[3];\n\n    c = In[0] / 65535.0;\n    m = In[1] / 65535.0;\n    y = In[2] / 65535.0;\n    k = In[3] / 65535.0;\n\n    if (k == 0) {\n\n        rgb[0] = Clip(1 - c);\n        rgb[1] = Clip(1 - m);\n        rgb[2] = Clip(1 - y);\n    }\n    else\n        if (k == 1) {\n\n            rgb[0] = rgb[1] = rgb[2] = 0;\n        }\n        else {\n\n            rgb[0] = Clip((1 - c) * (1 - k));\n            rgb[1] = Clip((1 - m) * (1 - k));\n            rgb[2] = Clip((1 - y) * (1 - k));\n        }\n\n    cmsDoTransform(p ->sRGB2Lab, rgb, Out, 1);\n    return 1;\n}",
          "fn_code_pos": [
            [
              500,
              0
            ],
            [
              531,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReverseSampler",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsHPROFILE CreateFakeCMYK(cmsFloat64Number InkLimit, cmsBool lUseAboveRGB)\n{\n    cmsHPROFILE hICC;\n    cmsPipeline* AToB0, *BToA0;\n    cmsStage* CLUT;\n    cmsContext ContextID;\n    FakeCMYKParams p;\n    cmsHPROFILE hLab, hsRGB, hLimit;\n    cmsUInt32Number cmykfrm;\n\n\n    if (lUseAboveRGB)\n        hsRGB = Create_AboveRGB();\n    else\n       hsRGB  = cmsCreate_sRGBProfile();\n\n    hLab   = cmsCreateLab4Profile(NULL);\n    hLimit = cmsCreateInkLimitingDeviceLink(cmsSigCmykData, InkLimit);\n\n    cmykfrm = FLOAT_SH(1) | BYTES_SH(0)|CHANNELS_SH(4);\n    p.hLab2sRGB = cmsCreateTransform(hLab,  TYPE_Lab_16,  hsRGB, TYPE_RGB_DBL, INTENT_PERCEPTUAL, cmsFLAGS_NOOPTIMIZE|cmsFLAGS_NOCACHE);\n    p.sRGB2Lab  = cmsCreateTransform(hsRGB, TYPE_RGB_DBL, hLab,  TYPE_Lab_16,  INTENT_PERCEPTUAL, cmsFLAGS_NOOPTIMIZE|cmsFLAGS_NOCACHE);\n    p.hIlimit   = cmsCreateTransform(hLimit, cmykfrm, NULL, TYPE_CMYK_16, INTENT_PERCEPTUAL, cmsFLAGS_NOOPTIMIZE|cmsFLAGS_NOCACHE);\n\n    cmsCloseProfile(hLab); cmsCloseProfile(hsRGB); cmsCloseProfile(hLimit);\n\n    ContextID = DbgThread();\n    hICC = cmsCreateProfilePlaceholder(ContextID);\n    if (!hICC) return NULL;\n\n    cmsSetProfileVersion(hICC, 4.3);\n\n    cmsSetDeviceClass(hICC, cmsSigOutputClass);\n    cmsSetColorSpace(hICC,  cmsSigCmykData);\n    cmsSetPCS(hICC,         cmsSigLabData);\n\n    BToA0 = cmsPipelineAlloc(ContextID, 3, 4);\n    if (BToA0 == NULL) return 0;\n    CLUT = cmsStageAllocCLut16bit(ContextID, 17, 3, 4, NULL);\n    if (CLUT == NULL) return 0;\n    if (!cmsStageSampleCLut16bit(CLUT, ForwardSampler, &p, 0)) return 0;\n\n    cmsPipelineInsertStage(BToA0, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, 3));\n    cmsPipelineInsertStage(BToA0, cmsAT_END, CLUT);\n    cmsPipelineInsertStage(BToA0, cmsAT_END, _cmsStageAllocIdentityCurves(ContextID, 4));\n\n    if (!cmsWriteTag(hICC, cmsSigBToA0Tag, (void*) BToA0)) return 0;\n    cmsPipelineFree(BToA0);\n\n    AToB0 = cmsPipelineAlloc(ContextID, 4, 3);\n    if (AToB0 == NULL) return 0;\n    CLUT = cmsStageAllocCLut16bit(ContextID, 17, 4, 3, NULL);\n    if (CLUT == NULL) return 0;\n    if (!cmsStageSampleCLut16bit(CLUT, ReverseSampler, &p, 0)) return 0;\n\n    cmsPipelineInsertStage(AToB0, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, 4));\n    cmsPipelineInsertStage(AToB0, cmsAT_END, CLUT);\n    cmsPipelineInsertStage(AToB0, cmsAT_END, _cmsStageAllocIdentityCurves(ContextID, 3));\n\n    if (!cmsWriteTag(hICC, cmsSigAToB0Tag, (void*) AToB0)) return 0;\n    cmsPipelineFree(AToB0);\n\n    cmsDeleteTransform(p.hLab2sRGB);\n    cmsDeleteTransform(p.sRGB2Lab);\n    cmsDeleteTransform(p.hIlimit);\n\n    cmsLinkTag(hICC, cmsSigAToB1Tag, cmsSigAToB0Tag);\n    cmsLinkTag(hICC, cmsSigAToB2Tag, cmsSigAToB0Tag);\n    cmsLinkTag(hICC, cmsSigBToA1Tag, cmsSigBToA0Tag);\n    cmsLinkTag(hICC, cmsSigBToA2Tag, cmsSigBToA0Tag);\n\n    return hICC;\n}",
          "fn_code_pos": [
            [
              535,
              0
            ],
            [
              608,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CreateFakeCMYK",
            "parameters": {
              "InkLimit": "cmsFloat64Number",
              "lUseAboveRGB": "cmsBool"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number OneVirtual(cmsHPROFILE h, const char* SubTestTxt, const char* FileName)\n{\n    SubTest(SubTestTxt);\n    if (h == NULL) return 0;\n\n    if (!cmsSaveProfileToFile(h, FileName)) return 0;\n    cmsCloseProfile(h);\n\n    h = cmsOpenProfileFromFile(FileName, \"r\");\n    if (h == NULL) return 0;\n    \n    cmsCloseProfile(h);\n    return 1;\n}",
          "fn_code_pos": [
            [
              613,
              0
            ],
            [
              627,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OneVirtual",
            "parameters": {
              "h": "cmsHPROFILE",
              "SubTestTxt": "char",
              "FileName": "char"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CreateTestProfiles(void)\n{\n    cmsHPROFILE h;\n\n    h = cmsCreate_sRGBProfileTHR(DbgThread());\n    if (!OneVirtual(h, \"sRGB profile\", \"sRGBlcms2.icc\")) return 0;\n\n    // ----\n\n    h = Create_AboveRGB();\n    if (!OneVirtual(h, \"aRGB profile\", \"aRGBlcms2.icc\")) return 0;\n\n    // ----\n\n    h = Create_Gray22();\n    if (!OneVirtual(h, \"Gray profile\", \"graylcms2.icc\")) return 0;\n\n    // ----\n\n    h = Create_Gray30();\n    if (!OneVirtual(h, \"Gray 3.0 profile\", \"gray3lcms2.icc\")) return 0;\n\n    // ----\n\n    h = Create_GrayLab();\n    if (!OneVirtual(h, \"Gray Lab profile\", \"glablcms2.icc\")) return 0;\n\n    // ----\n\n    h = Create_CMYK_DeviceLink();\n    if (!OneVirtual(h, \"Linearization profile\", \"linlcms2.icc\")) return 0;\n\n    // -------\n    h = cmsCreateInkLimitingDeviceLinkTHR(DbgThread(), cmsSigCmykData, 150);\n    if (h == NULL) return 0;\n    if (!OneVirtual(h, \"Ink-limiting profile\", \"limitlcms2.icc\")) return 0;\n\n    // ------\n\n    h = cmsCreateLab2ProfileTHR(DbgThread(), NULL);\n    if (!OneVirtual(h, \"Lab 2 identity profile\", \"labv2lcms2.icc\")) return 0;\n\n    // ----\n\n    h = cmsCreateLab4ProfileTHR(DbgThread(), NULL);\n    if (!OneVirtual(h, \"Lab 4 identity profile\", \"labv4lcms2.icc\")) return 0;\n\n    // ----\n\n    h = cmsCreateXYZProfileTHR(DbgThread());\n    if (!OneVirtual(h, \"XYZ identity profile\", \"xyzlcms2.icc\")) return 0;\n\n    // ----\n\n    h = cmsCreateNULLProfileTHR(DbgThread());\n    if (!OneVirtual(h, \"NULL profile\", \"nullcms2.icc\")) return 0;\n\n    // ---\n\n    h = cmsCreateBCHSWabstractProfileTHR(DbgThread(), 17, 0, 0, 0, 0, 5000, 6000);\n    if (!OneVirtual(h, \"BCHS profile\", \"bchslcms2.icc\")) return 0;\n\n    // ---\n\n    h = CreateFakeCMYK(300, FALSE);\n    if (!OneVirtual(h, \"Fake CMYK profile\", \"lcms2cmyk.icc\")) return 0;\n\n    // ---\n\n    h = cmsCreateBCHSWabstractProfileTHR(DbgThread(), 17, 0, 1.2, 0, 3, 5000, 5000);\n    if (!OneVirtual(h, \"Brightness\", \"brightness.icc\")) return 0;\n    return 1;\n}",
          "fn_code_pos": [
            [
              633,
              0
            ],
            [
              706,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CreateTestProfiles",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid RemoveTestProfiles(void)\n{\n    remove(\"sRGBlcms2.icc\");\n    remove(\"aRGBlcms2.icc\");\n    remove(\"graylcms2.icc\");\n    remove(\"gray3lcms2.icc\");\n    remove(\"linlcms2.icc\");\n    remove(\"limitlcms2.icc\");\n    remove(\"labv2lcms2.icc\");\n    remove(\"labv4lcms2.icc\");\n    remove(\"xyzlcms2.icc\");\n    remove(\"nullcms2.icc\");\n    remove(\"bchslcms2.icc\");\n    remove(\"lcms2cmyk.icc\");\n    remove(\"glablcms2.icc\");\n    remove(\"lcms2link.icc\");\n    remove(\"lcms2link2.icc\");\n    remove(\"brightness.icc\");\n}",
          "fn_code_pos": [
            [
              708,
              0
            ],
            [
              727,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RemoveTestProfiles",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckBaseTypes(void)\n{\n    // Ignore warnings about conditional expression\n#ifdef _MSC_VER\n#pragma warning(disable: 4127)\n#endif\n\n    if (sizeof(cmsUInt8Number) != 1) return 0;\n    if (sizeof(cmsInt8Number) != 1) return 0;\n    if (sizeof(cmsUInt16Number) != 2) return 0;\n    if (sizeof(cmsInt16Number) != 2) return 0;\n    if (sizeof(cmsUInt32Number) != 4) return 0;\n    if (sizeof(cmsInt32Number) != 4) return 0;\n    if (sizeof(cmsUInt64Number) != 8) return 0;\n    if (sizeof(cmsInt64Number) != 8) return 0;\n    if (sizeof(cmsFloat32Number) != 4) return 0;\n    if (sizeof(cmsFloat64Number) != 8) return 0;\n    if (sizeof(cmsSignature) != 4) return 0;\n    if (sizeof(cmsU8Fixed8Number) != 2) return 0;\n    if (sizeof(cmsS15Fixed16Number) != 4) return 0;\n    if (sizeof(cmsU16Fixed16Number) != 4) return 0;\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              732,
              0
            ],
            [
              756,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckBaseTypes",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckEndianness(void)\n{\n    cmsInt32Number BigEndian, IsOk;\n    union {\n        long l;\n        char c[sizeof (long)];\n    } u;\n\n    u.l = 1;\n    BigEndian = (u.c[sizeof (long) - 1] == 1);\n\n#ifdef CMS_USE_BIG_ENDIAN\n    IsOk = BigEndian;\n#else\n    IsOk = !BigEndian;\n#endif\n\n    if (!IsOk) {\n        Die(\"\\nOOOPPSS! You have CMS_USE_BIG_ENDIAN toggle misconfigured!\\n\\n\"\n            \"Please, edit lcms2.h and %s the CMS_USE_BIG_ENDIAN toggle.\\n\", BigEndian? \"uncomment\" : \"comment\");\n        return 0;\n    }\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              762,
              0
            ],
            [
              787,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckEndianness",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckQuickFloor(void)\n{\n    if ((_cmsQuickFloor(1.234) != 1) ||\n        (_cmsQuickFloor(32767.234) != 32767) ||\n        (_cmsQuickFloor(-1.234) != -2) ||\n        (_cmsQuickFloor(-32767.1) != -32768)) {\n\n            Die(\"\\nOOOPPSS! _cmsQuickFloor() does not work as expected in your machine!\\n\\n\"\n                \"Please, edit lcms2.h and uncomment the CMS_DONT_USE_FAST_FLOOR toggle.\\n\");\n            return 0;\n\n    }\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              790,
              0
            ],
            [
              805,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckQuickFloor",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckQuickFloorWord(void)\n{\n    cmsUInt32Number i;\n\n    for (i=0; i < 65535; i++) {\n\n        if (_cmsQuickFloorWord((cmsFloat64Number) i + 0.1234) != i) {\n\n            Die(\"\\nOOOPPSS! _cmsQuickFloorWord() does not work as expected in your machine!\\n\\n\"\n                \"Please, edit lcms2.h and uncomment the CMS_DONT_USE_FAST_FLOOR toggle.\\n\");\n            return 0;\n        }\n    }\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              808,
              0
            ],
            [
              824,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckQuickFloorWord",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "cmsBool IsGoodVal(const char *title, cmsFloat64Number in, cmsFloat64Number out, cmsFloat64Number max)\n{\n    cmsFloat64Number Err = fabs(in - out);\n\n    if (Err > MaxErr) MaxErr = Err;\n\n        if ((Err > max )) {\n\n              Fail(\"(%s): Must be %f, But is %f \", title, in, out);\n              return FALSE;\n              }\n\n       return TRUE;\n}",
          "fn_code_pos": [
            [
              841,
              0
            ],
            [
              854,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsGoodVal",
            "parameters": {
              "title": "char",
              "in": "cmsFloat64Number",
              "out": "cmsFloat64Number",
              "max": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool  IsGoodFixed15_16(const char *title, cmsFloat64Number in, cmsFloat64Number out)\n{\n    return IsGoodVal(title, in, out, FIXED_PRECISION_15_16);\n}",
          "fn_code_pos": [
            [
              857,
              0
            ],
            [
              860,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsGoodFixed15_16",
            "parameters": {
              "title": "char",
              "in": "cmsFloat64Number",
              "out": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool  IsGoodFixed8_8(const char *title, cmsFloat64Number in, cmsFloat64Number out)\n{\n    return IsGoodVal(title, in, out, FIXED_PRECISION_8_8);\n}",
          "fn_code_pos": [
            [
              863,
              0
            ],
            [
              866,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsGoodFixed8_8",
            "parameters": {
              "title": "char",
              "in": "cmsFloat64Number",
              "out": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool  IsGoodWord(const char *title, cmsUInt16Number in, cmsUInt16Number out)\n{\n    if ((abs(in - out) > 0 )) {\n\n        Fail(\"(%s): Must be %x, But is %x \", title, in, out);\n        return FALSE;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              868,
              0
            ],
            [
              877,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsGoodWord",
            "parameters": {
              "title": "char",
              "in": "cmsUInt16Number",
              "out": "cmsUInt16Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool  IsGoodWordPrec(const char *title, cmsUInt16Number in, cmsUInt16Number out, cmsUInt16Number maxErr)\n{\n    if ((abs(in - out) > maxErr )) {\n\n        Fail(\"(%s): Must be %x, But is %x \", title, in, out);\n        return FALSE;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              879,
              0
            ],
            [
              888,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsGoodWordPrec",
            "parameters": {
              "title": "char",
              "in": "cmsUInt16Number",
              "out": "cmsUInt16Number",
              "maxErr": "cmsUInt16Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number TestSingleFixed15_16(cmsFloat64Number d)\n{\n    cmsS15Fixed16Number f = _cmsDoubleTo15Fixed16(d);\n    cmsFloat64Number RoundTrip = _cms15Fixed16toDouble(f);\n    cmsFloat64Number Error     = fabs(d - RoundTrip);\n\n    return ( Error <= FIXED_PRECISION_15_16);\n}",
          "fn_code_pos": [
            [
              892,
              0
            ],
            [
              900,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestSingleFixed15_16",
            "parameters": {
              "d": "cmsFloat64Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckFixedPoint15_16(void)\n{\n    if (!TestSingleFixed15_16(1.0)) return 0;\n    if (!TestSingleFixed15_16(2.0)) return 0;\n    if (!TestSingleFixed15_16(1.23456)) return 0;\n    if (!TestSingleFixed15_16(0.99999)) return 0;\n    if (!TestSingleFixed15_16(0.1234567890123456789099999)) return 0;\n    if (!TestSingleFixed15_16(-1.0)) return 0;\n    if (!TestSingleFixed15_16(-2.0)) return 0;\n    if (!TestSingleFixed15_16(-1.23456)) return 0;\n    if (!TestSingleFixed15_16(-1.1234567890123456789099999)) return 0;\n    if (!TestSingleFixed15_16(+32767.1234567890123456789099999)) return 0;\n    if (!TestSingleFixed15_16(-32767.1234567890123456789099999)) return 0;\n    return 1;\n}",
          "fn_code_pos": [
            [
              902,
              0
            ],
            [
              917,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckFixedPoint15_16",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number TestSingleFixed8_8(cmsFloat64Number d)\n{\n    cmsS15Fixed16Number f = _cmsDoubleTo8Fixed8(d);\n    cmsFloat64Number RoundTrip = _cms8Fixed8toDouble((cmsUInt16Number) f);\n    cmsFloat64Number Error     = fabs(d - RoundTrip);\n\n    return ( Error <= FIXED_PRECISION_8_8);\n}",
          "fn_code_pos": [
            [
              919,
              0
            ],
            [
              927,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestSingleFixed8_8",
            "parameters": {
              "d": "cmsFloat64Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckFixedPoint8_8(void)\n{\n    if (!TestSingleFixed8_8(1.0)) return 0;\n    if (!TestSingleFixed8_8(2.0)) return 0;\n    if (!TestSingleFixed8_8(1.23456)) return 0;\n    if (!TestSingleFixed8_8(0.99999)) return 0;\n    if (!TestSingleFixed8_8(0.1234567890123456789099999)) return 0;\n    if (!TestSingleFixed8_8(+255.1234567890123456789099999)) return 0;\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              929,
              0
            ],
            [
              940,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckFixedPoint8_8",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckD50Roundtrip(void)\n{\n    cmsFloat64Number cmsD50X_2 =  0.96420288;\n    cmsFloat64Number cmsD50Y_2 =  1.0;\n    cmsFloat64Number cmsD50Z_2 = 0.82490540;\n\n    cmsS15Fixed16Number xe = _cmsDoubleTo15Fixed16(cmsD50X);\n    cmsS15Fixed16Number ye = _cmsDoubleTo15Fixed16(cmsD50Y);\n    cmsS15Fixed16Number ze = _cmsDoubleTo15Fixed16(cmsD50Z);\n\n    cmsFloat64Number x =  _cms15Fixed16toDouble(xe);\n    cmsFloat64Number y =  _cms15Fixed16toDouble(ye);\n    cmsFloat64Number z =  _cms15Fixed16toDouble(ze);\n\n    double dx = fabs(cmsD50X - x);\n    double dy = fabs(cmsD50Y - y);\n    double dz = fabs(cmsD50Z - z);\n\n    double euc = sqrt(dx*dx + dy*dy + dz* dz);\n\n    if (euc > 1E-5) {\n\n        Fail(\"D50 roundtrip |err| > (%f) \", euc);\n        return 0;\n    }\n\n    xe = _cmsDoubleTo15Fixed16(cmsD50X_2);\n    ye = _cmsDoubleTo15Fixed16(cmsD50Y_2);\n    ze = _cmsDoubleTo15Fixed16(cmsD50Z_2);\n\n    x =  _cms15Fixed16toDouble(xe);\n    y =  _cms15Fixed16toDouble(ye);\n    z =  _cms15Fixed16toDouble(ze);\n\n    dx = fabs(cmsD50X_2 - x);\n    dy = fabs(cmsD50Y_2 - y);\n    dz = fabs(cmsD50Z_2 - z);\n\n    euc = sqrt(dx*dx + dy*dy + dz* dz);\n\n    if (euc > 1E-5) {\n\n        Fail(\"D50 roundtrip |err| > (%f) \", euc);\n        return 0;\n    }\n\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              944,
              0
            ],
            [
              993,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckD50Roundtrip",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid BuildTable(cmsInt32Number n, cmsUInt16Number Tab[], cmsBool  Descending)\n{\n    cmsInt32Number i;\n\n    for (i=0; i < n; i++) {\n        cmsFloat64Number v = (cmsFloat64Number) ((cmsFloat64Number) 65535.0 * i ) / (n-1);\n\n        Tab[Descending ? (n - i - 1) : i ] = (cmsUInt16Number) floor(v + 0.5);\n    }\n}",
          "fn_code_pos": [
            [
              1003,
              0
            ],
            [
              1013,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BuildTable",
            "parameters": {
              "n": "cmsInt32Number",
              "Tab": "cmsUInt16Number",
              "Descending": "cmsBool"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check1D(cmsInt32Number nNodesToCheck, cmsBool  Down, cmsInt32Number max_err)\n{\n    cmsUInt32Number i;\n    cmsUInt16Number in, out;\n    cmsInterpParams* p;\n    cmsUInt16Number* Tab;\n\n    Tab = (cmsUInt16Number*) chknull(malloc(sizeof(cmsUInt16Number)* nNodesToCheck));\n    if (Tab == NULL) return 0;\n\n    p = _cmsComputeInterpParams(DbgThread(), nNodesToCheck, 1, 1, Tab, CMS_LERP_FLAGS_16BITS);\n    if (p == NULL) return 0;\n\n    BuildTable(nNodesToCheck, Tab, Down);\n\n    for (i=0; i <= 0xffff; i++) {\n\n        in = (cmsUInt16Number) i;\n        out = 0;\n\n        p ->Interpolation.Lerp16(&in, &out, p);\n\n        if (Down) out = 0xffff - out;\n\n        if (abs(out - in) > max_err) {\n\n            Fail(\"(%dp): Must be %x, But is %x : \", nNodesToCheck, in, out);\n            _cmsFreeInterpParams(p);\n            free(Tab);\n            return 0;\n        }\n    }\n\n    _cmsFreeInterpParams(p);\n    free(Tab);\n    return 1;\n}",
          "fn_code_pos": [
            [
              1021,
              0
            ],
            [
              1058,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check1D",
            "parameters": {
              "nNodesToCheck": "cmsInt32Number",
              "Down": "cmsBool",
              "max_err": "cmsInt32Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check1DLERP2(void)\n{\n    return Check1D(2, FALSE, 0);\n}",
          "fn_code_pos": [
            [
              1061,
              0
            ],
            [
              1065,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check1DLERP2",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check1DLERP3(void)\n{\n    return Check1D(3, FALSE, 1);\n}",
          "fn_code_pos": [
            [
              1068,
              0
            ],
            [
              1072,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check1DLERP3",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check1DLERP4(void)\n{\n    return Check1D(4, FALSE, 0);\n}",
          "fn_code_pos": [
            [
              1075,
              0
            ],
            [
              1079,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check1DLERP4",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check1DLERP6(void)\n{\n    return Check1D(6, FALSE, 0);\n}",
          "fn_code_pos": [
            [
              1081,
              0
            ],
            [
              1085,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check1DLERP6",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check1DLERP18(void)\n{\n    return Check1D(18, FALSE, 0);\n}",
          "fn_code_pos": [
            [
              1087,
              0
            ],
            [
              1091,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check1DLERP18",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check1DLERP2Down(void)\n{\n    return Check1D(2, TRUE, 0);\n}",
          "fn_code_pos": [
            [
              1094,
              0
            ],
            [
              1098,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check1DLERP2Down",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check1DLERP3Down(void)\n{\n    return Check1D(3, TRUE, 1);\n}",
          "fn_code_pos": [
            [
              1101,
              0
            ],
            [
              1105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check1DLERP3Down",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check1DLERP6Down(void)\n{\n    return Check1D(6, TRUE, 0);\n}",
          "fn_code_pos": [
            [
              1107,
              0
            ],
            [
              1111,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check1DLERP6Down",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check1DLERP18Down(void)\n{\n    return Check1D(18, TRUE, 0);\n}",
          "fn_code_pos": [
            [
              1113,
              0
            ],
            [
              1117,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check1DLERP18Down",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number ExhaustiveCheck1DLERP(void)\n{\n    cmsUInt32Number j;\n\n    printf(\"\\n\");\n    for (j=10; j <= 4096; j++) {\n\n        if ((j % 10) == 0) printf(\"%u    \\r\", j);\n\n        if (!Check1D(j, FALSE, 1)) return 0;\n    }\n\n    printf(\"\\rResult is \");\n    return 1;\n}",
          "fn_code_pos": [
            [
              1119,
              0
            ],
            [
              1134,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExhaustiveCheck1DLERP",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number ExhaustiveCheck1DLERPDown(void)\n{\n    cmsUInt32Number j;\n\n    printf(\"\\n\");\n    for (j=10; j <= 4096; j++) {\n\n        if ((j % 10) == 0) printf(\"%u    \\r\", j);\n\n        if (!Check1D(j, TRUE, 1)) return 0;\n    }\n\n\n    printf(\"\\rResult is \");\n    return 1;\n}",
          "fn_code_pos": [
            [
              1136,
              0
            ],
            [
              1152,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExhaustiveCheck1DLERPDown",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check3DinterpolationFloatTetrahedral(void)\n{\n    cmsInterpParams* p;\n    cmsInt32Number i;\n    cmsFloat32Number In[3], Out[3];\n    cmsFloat32Number FloatTable[] = { //R     G    B\n\n        0,    0,   0,     // B=0,G=0,R=0\n        0,    0,  .25,    // B=1,G=0,R=0\n\n        0,   .5,    0,    // B=0,G=1,R=0\n        0,   .5,  .25,    // B=1,G=1,R=0\n\n        1,    0,    0,    // B=0,G=0,R=1\n        1,    0,  .25,    // B=1,G=0,R=1\n\n        1,    .5,   0,    // B=0,G=1,R=1\n        1,    .5,  .25    // B=1,G=1,R=1\n\n    };\n\n    p = _cmsComputeInterpParams(DbgThread(), 2, 3, 3, FloatTable, CMS_LERP_FLAGS_FLOAT);\n\n\n    MaxErr = 0.0;\n     for (i=0; i < 0xffff; i++) {\n\n       In[0] = In[1] = In[2] = (cmsFloat32Number) ( (cmsFloat32Number) i / 65535.0F);\n\n        p ->Interpolation.LerpFloat(In, Out, p);\n\n       if (!IsGoodFixed15_16(\"Channel 1\", Out[0], In[0])) goto Error;\n       if (!IsGoodFixed15_16(\"Channel 2\", Out[1], (cmsFloat32Number) In[1] / 2.F)) goto Error;\n       if (!IsGoodFixed15_16(\"Channel 3\", Out[2], (cmsFloat32Number) In[2] / 4.F)) goto Error;\n     }\n\n    if (MaxErr > 0) printf(\"|Err|<%lf \", MaxErr);\n    _cmsFreeInterpParams(p);\n    return 1;\n\nError:\n    _cmsFreeInterpParams(p);\n    return 0;\n}",
          "fn_code_pos": [
            [
              1158,
              0
            ],
            [
              1202,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check3DinterpolationFloatTetrahedral",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check3DinterpolationFloatTrilinear(void)\n{\n    cmsInterpParams* p;\n    cmsInt32Number i;\n    cmsFloat32Number In[3], Out[3];\n    cmsFloat32Number FloatTable[] = { //R     G    B\n\n        0,    0,   0,     // B=0,G=0,R=0\n        0,    0,  .25,    // B=1,G=0,R=0\n\n        0,   .5,    0,    // B=0,G=1,R=0\n        0,   .5,  .25,    // B=1,G=1,R=0\n\n        1,    0,    0,    // B=0,G=0,R=1\n        1,    0,  .25,    // B=1,G=0,R=1\n\n        1,    .5,   0,    // B=0,G=1,R=1\n        1,    .5,  .25    // B=1,G=1,R=1\n\n    };\n\n    p = _cmsComputeInterpParams(DbgThread(), 2, 3, 3, FloatTable, CMS_LERP_FLAGS_FLOAT|CMS_LERP_FLAGS_TRILINEAR);\n\n    MaxErr = 0.0;\n     for (i=0; i < 0xffff; i++) {\n\n       In[0] = In[1] = In[2] = (cmsFloat32Number) ( (cmsFloat32Number) i / 65535.0F);\n\n        p ->Interpolation.LerpFloat(In, Out, p);\n\n       if (!IsGoodFixed15_16(\"Channel 1\", Out[0], In[0])) goto Error;\n       if (!IsGoodFixed15_16(\"Channel 2\", Out[1], (cmsFloat32Number) In[1] / 2.F)) goto Error;\n       if (!IsGoodFixed15_16(\"Channel 3\", Out[2], (cmsFloat32Number) In[2] / 4.F)) goto Error;\n     }\n\n    if (MaxErr > 0) printf(\"|Err|<%lf \", MaxErr);\n    _cmsFreeInterpParams(p);\n    return 1;\n\nError:\n    _cmsFreeInterpParams(p);\n    return 0;\n\n}",
          "fn_code_pos": [
            [
              1204,
              0
            ],
            [
              1248,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check3DinterpolationFloatTrilinear",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check3DinterpolationTetrahedral16(void)\n{\n    cmsInterpParams* p;\n    cmsInt32Number i;\n    cmsUInt16Number In[3], Out[3];\n    cmsUInt16Number Table[] = {\n\n        0,    0,   0,\n        0,    0,   0xffff,\n\n        0,    0xffff,    0,\n        0,    0xffff,    0xffff,\n\n        0xffff,    0,    0,\n        0xffff,    0,    0xffff,\n\n        0xffff,    0xffff,   0,\n        0xffff,    0xffff,   0xffff\n    };\n\n    p = _cmsComputeInterpParams(DbgThread(), 2, 3, 3, Table, CMS_LERP_FLAGS_16BITS);\n\n    MaxErr = 0.0;\n     for (i=0; i < 0xffff; i++) {\n\n       In[0] = In[1] = In[2] = (cmsUInt16Number) i;\n\n        p ->Interpolation.Lerp16(In, Out, p);\n\n       if (!IsGoodWord(\"Channel 1\", Out[0], In[0])) goto Error;\n       if (!IsGoodWord(\"Channel 2\", Out[1], In[1])) goto Error;\n       if (!IsGoodWord(\"Channel 3\", Out[2], In[2])) goto Error;\n     }\n\n    if (MaxErr > 0) printf(\"|Err|<%lf \", MaxErr);\n    _cmsFreeInterpParams(p);\n    return 1;\n\nError:\n    _cmsFreeInterpParams(p);\n    return 0;\n}",
          "fn_code_pos": [
            [
              1250,
              0
            ],
            [
              1292,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check3DinterpolationTetrahedral16",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check3DinterpolationTrilinear16(void)\n{\n    cmsInterpParams* p;\n    cmsInt32Number i;\n    cmsUInt16Number In[3], Out[3];\n    cmsUInt16Number Table[] = {\n\n        0,    0,   0,\n        0,    0,   0xffff,\n\n        0,    0xffff,    0,\n        0,    0xffff,    0xffff,\n\n        0xffff,    0,    0,\n        0xffff,    0,    0xffff,\n\n        0xffff,    0xffff,   0,\n        0xffff,    0xffff,   0xffff\n    };\n\n    p = _cmsComputeInterpParams(DbgThread(), 2, 3, 3, Table, CMS_LERP_FLAGS_TRILINEAR);\n\n    MaxErr = 0.0;\n     for (i=0; i < 0xffff; i++) {\n\n       In[0] = In[1] = In[2] = (cmsUInt16Number) i;\n\n        p ->Interpolation.Lerp16(In, Out, p);\n\n       if (!IsGoodWord(\"Channel 1\", Out[0], In[0])) goto Error;\n       if (!IsGoodWord(\"Channel 2\", Out[1], In[1])) goto Error;\n       if (!IsGoodWord(\"Channel 3\", Out[2], In[2])) goto Error;\n     }\n\n    if (MaxErr > 0) printf(\"|Err|<%lf \", MaxErr);\n    _cmsFreeInterpParams(p);\n    return 1;\n\nError:\n    _cmsFreeInterpParams(p);\n    return 0;\n}",
          "fn_code_pos": [
            [
              1294,
              0
            ],
            [
              1336,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check3DinterpolationTrilinear16",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number ExaustiveCheck3DinterpolationFloatTetrahedral(void)\n{\n    cmsInterpParams* p;\n    cmsInt32Number r, g, b;\n    cmsFloat32Number In[3], Out[3];\n    cmsFloat32Number FloatTable[] = { //R     G    B\n\n        0,    0,   0,     // B=0,G=0,R=0\n        0,    0,  .25,    // B=1,G=0,R=0\n\n        0,   .5,    0,    // B=0,G=1,R=0\n        0,   .5,  .25,    // B=1,G=1,R=0\n\n        1,    0,    0,    // B=0,G=0,R=1\n        1,    0,  .25,    // B=1,G=0,R=1\n\n        1,    .5,   0,    // B=0,G=1,R=1\n        1,    .5,  .25    // B=1,G=1,R=1\n\n    };\n\n    p = _cmsComputeInterpParams(DbgThread(), 2, 3, 3, FloatTable, CMS_LERP_FLAGS_FLOAT);\n\n    MaxErr = 0.0;\n    for (r=0; r < 0xff; r++)\n        for (g=0; g < 0xff; g++)\n            for (b=0; b < 0xff; b++)\n        {\n\n            In[0] = (cmsFloat32Number) r / 255.0F;\n            In[1] = (cmsFloat32Number) g / 255.0F;\n            In[2] = (cmsFloat32Number) b / 255.0F;\n\n\n        p ->Interpolation.LerpFloat(In, Out, p);\n\n       if (!IsGoodFixed15_16(\"Channel 1\", Out[0], In[0])) goto Error;\n       if (!IsGoodFixed15_16(\"Channel 2\", Out[1], (cmsFloat32Number) In[1] / 2.F)) goto Error;\n       if (!IsGoodFixed15_16(\"Channel 3\", Out[2], (cmsFloat32Number) In[2] / 4.F)) goto Error;\n     }\n\n    if (MaxErr > 0) printf(\"|Err|<%lf \", MaxErr);\n    _cmsFreeInterpParams(p);\n    return 1;\n\nError:\n    _cmsFreeInterpParams(p);\n    return 0;\n}",
          "fn_code_pos": [
            [
              1339,
              0
            ],
            [
              1388,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExaustiveCheck3DinterpolationFloatTetrahedral",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number ExaustiveCheck3DinterpolationFloatTrilinear(void)\n{\n    cmsInterpParams* p;\n    cmsInt32Number r, g, b;\n    cmsFloat32Number In[3], Out[3];\n    cmsFloat32Number FloatTable[] = { //R     G    B\n\n        0,    0,   0,     // B=0,G=0,R=0\n        0,    0,  .25,    // B=1,G=0,R=0\n\n        0,   .5,    0,    // B=0,G=1,R=0\n        0,   .5,  .25,    // B=1,G=1,R=0\n\n        1,    0,    0,    // B=0,G=0,R=1\n        1,    0,  .25,    // B=1,G=0,R=1\n\n        1,    .5,   0,    // B=0,G=1,R=1\n        1,    .5,  .25    // B=1,G=1,R=1\n\n    };\n\n    p = _cmsComputeInterpParams(DbgThread(), 2, 3, 3, FloatTable, CMS_LERP_FLAGS_FLOAT|CMS_LERP_FLAGS_TRILINEAR);\n\n    MaxErr = 0.0;\n    for (r=0; r < 0xff; r++)\n        for (g=0; g < 0xff; g++)\n            for (b=0; b < 0xff; b++)\n            {\n\n                In[0] = (cmsFloat32Number) r / 255.0F;\n                In[1] = (cmsFloat32Number) g / 255.0F;\n                In[2] = (cmsFloat32Number) b / 255.0F;\n\n\n                p ->Interpolation.LerpFloat(In, Out, p);\n\n                if (!IsGoodFixed15_16(\"Channel 1\", Out[0], In[0])) goto Error;\n                if (!IsGoodFixed15_16(\"Channel 2\", Out[1], (cmsFloat32Number) In[1] / 2.F)) goto Error;\n                if (!IsGoodFixed15_16(\"Channel 3\", Out[2], (cmsFloat32Number) In[2] / 4.F)) goto Error;\n            }\n\n    if (MaxErr > 0) printf(\"|Err|<%lf \", MaxErr);\n    _cmsFreeInterpParams(p);\n    return 1;\n\nError:\n    _cmsFreeInterpParams(p);\n    return 0;\n\n}",
          "fn_code_pos": [
            [
              1390,
              0
            ],
            [
              1440,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExaustiveCheck3DinterpolationFloatTrilinear",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number ExhaustiveCheck3DinterpolationTetrahedral16(void)\n{\n    cmsInterpParams* p;\n    cmsInt32Number r, g, b;\n    cmsUInt16Number In[3], Out[3];\n    cmsUInt16Number Table[] = {\n\n        0,    0,   0,\n        0,    0,   0xffff,\n\n        0,    0xffff,    0,\n        0,    0xffff,    0xffff,\n\n        0xffff,    0,    0,\n        0xffff,    0,    0xffff,\n\n        0xffff,    0xffff,   0,\n        0xffff,    0xffff,   0xffff\n    };\n\n    p = _cmsComputeInterpParams(DbgThread(), 2, 3, 3, Table, CMS_LERP_FLAGS_16BITS);\n\n    for (r=0; r < 0xff; r++)\n        for (g=0; g < 0xff; g++)\n            for (b=0; b < 0xff; b++)\n        {\n            In[0] = (cmsUInt16Number) r ;\n            In[1] = (cmsUInt16Number) g ;\n            In[2] = (cmsUInt16Number) b ;\n\n\n        p ->Interpolation.Lerp16(In, Out, p);\n\n       if (!IsGoodWord(\"Channel 1\", Out[0], In[0])) goto Error;\n       if (!IsGoodWord(\"Channel 2\", Out[1], In[1])) goto Error;\n       if (!IsGoodWord(\"Channel 3\", Out[2], In[2])) goto Error;\n     }\n\n    _cmsFreeInterpParams(p);\n    return 1;\n\nError:\n    _cmsFreeInterpParams(p);\n    return 0;\n}",
          "fn_code_pos": [
            [
              1442,
              0
            ],
            [
              1487,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExhaustiveCheck3DinterpolationTetrahedral16",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number ExhaustiveCheck3DinterpolationTrilinear16(void)\n{\n    cmsInterpParams* p;\n    cmsInt32Number r, g, b;\n    cmsUInt16Number In[3], Out[3];\n    cmsUInt16Number Table[] = {\n\n        0,    0,   0,\n        0,    0,   0xffff,\n\n        0,    0xffff,    0,\n        0,    0xffff,    0xffff,\n\n        0xffff,    0,    0,\n        0xffff,    0,    0xffff,\n\n        0xffff,    0xffff,   0,\n        0xffff,    0xffff,   0xffff\n    };\n\n    p = _cmsComputeInterpParams(DbgThread(), 2, 3, 3, Table, CMS_LERP_FLAGS_TRILINEAR);\n\n    for (r=0; r < 0xff; r++)\n        for (g=0; g < 0xff; g++)\n            for (b=0; b < 0xff; b++)\n        {\n            In[0] = (cmsUInt16Number) r ;\n            In[1] = (cmsUInt16Number)g ;\n            In[2] = (cmsUInt16Number)b ;\n\n\n        p ->Interpolation.Lerp16(In, Out, p);\n\n       if (!IsGoodWord(\"Channel 1\", Out[0], In[0])) goto Error;\n       if (!IsGoodWord(\"Channel 2\", Out[1], In[1])) goto Error;\n       if (!IsGoodWord(\"Channel 3\", Out[2], In[2])) goto Error;\n     }\n\n\n    _cmsFreeInterpParams(p);\n    return 1;\n\nError:\n    _cmsFreeInterpParams(p);\n    return 0;\n}",
          "fn_code_pos": [
            [
              1489,
              0
            ],
            [
              1535,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExhaustiveCheck3DinterpolationTrilinear16",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckReverseInterpolation3x3(void)\n{\n cmsPipeline* Lut;\n cmsStage* clut;\n cmsFloat32Number Target[4], Result[4], Hint[4];\n cmsFloat32Number err, max;\n cmsInt32Number i;\n cmsUInt16Number Table[] = {\n\n        0,    0,   0,                 // 0 0 0\n        0,    0,   0xffff,            // 0 0 1\n\n        0,    0xffff,    0,           // 0 1 0\n        0,    0xffff,    0xffff,      // 0 1 1\n\n        0xffff,    0,    0,           // 1 0 0\n        0xffff,    0,    0xffff,      // 1 0 1\n\n        0xffff,    0xffff,   0,       // 1 1 0\n        0xffff,    0xffff,   0xffff,  // 1 1 1\n    };\n\n\n\n   Lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n\n   clut = cmsStageAllocCLut16bit(DbgThread(), 2, 3, 3, Table);\n   cmsPipelineInsertStage(Lut, cmsAT_BEGIN, clut);\n\n   Target[0] = 0; Target[1] = 0; Target[2] = 0;\n   Hint[0] = 0; Hint[1] = 0; Hint[2] = 0;\n   cmsPipelineEvalReverseFloat(Target, Result, NULL, Lut);\n   if (Result[0] != 0 || Result[1] != 0 || Result[2] != 0){\n\n       Fail(\"Reverse interpolation didn't find zero\");\n       goto Error;\n   }\n\n   // Transverse identity\n   max = 0;\n   for (i=0; i <= 100; i++) {\n\n       cmsFloat32Number in = i / 100.0F;\n\n       Target[0] = in; Target[1] = 0; Target[2] = 0;\n       cmsPipelineEvalReverseFloat(Target, Result, Hint, Lut);\n\n       err = fabsf(in - Result[0]);\n       if (err > max) max = err;\n\n       memcpy(Hint, Result, sizeof(Hint));\n   }\n\n    cmsPipelineFree(Lut);\n    return (max <= FLOAT_PRECISSION);\n\nError:\n    cmsPipelineFree(Lut);\n    return 0;\n}",
          "fn_code_pos": [
            [
              1538,
              0
            ],
            [
              1598,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckReverseInterpolation3x3",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckReverseInterpolation4x3(void)\n{\n cmsPipeline* Lut;\n cmsStage* clut;\n cmsFloat32Number Target[4], Result[4], Hint[4];\n cmsFloat32Number err, max;\n cmsInt32Number i;\n\n // 4 -> 3, output gets 3 first channels copied\n cmsUInt16Number Table[] = {\n\n        0,         0,         0,          //  0 0 0 0   = ( 0, 0, 0)\n        0,         0,         0,          //  0 0 0 1   = ( 0, 0, 0)\n\n        0,         0,         0xffff,     //  0 0 1 0   = ( 0, 0, 1)\n        0,         0,         0xffff,     //  0 0 1 1   = ( 0, 0, 1)\n\n        0,         0xffff,    0,          //  0 1 0 0   = ( 0, 1, 0)\n        0,         0xffff,    0,          //  0 1 0 1   = ( 0, 1, 0)\n\n        0,         0xffff,    0xffff,     //  0 1 1 0    = ( 0, 1, 1)\n        0,         0xffff,    0xffff,     //  0 1 1 1    = ( 0, 1, 1)\n\n        0xffff,    0,         0,          //  1 0 0 0    = ( 1, 0, 0)\n        0xffff,    0,         0,          //  1 0 0 1    = ( 1, 0, 0)\n\n        0xffff,    0,         0xffff,     //  1 0 1 0    = ( 1, 0, 1)\n        0xffff,    0,         0xffff,     //  1 0 1 1    = ( 1, 0, 1)\n\n        0xffff,    0xffff,    0,          //  1 1 0 0    = ( 1, 1, 0)\n        0xffff,    0xffff,    0,          //  1 1 0 1    = ( 1, 1, 0)\n\n        0xffff,    0xffff,    0xffff,     //  1 1 1 0    = ( 1, 1, 1)\n        0xffff,    0xffff,    0xffff,     //  1 1 1 1    = ( 1, 1, 1)\n    };\n\n\n   Lut = cmsPipelineAlloc(DbgThread(), 4, 3);\n\n   clut = cmsStageAllocCLut16bit(DbgThread(), 2, 4, 3, Table);\n   cmsPipelineInsertStage(Lut, cmsAT_BEGIN, clut);\n\n   // Check if the LUT is behaving as expected\n   SubTest(\"4->3 feasibility\");\n   for (i=0; i <= 100; i++) {\n\n       Target[0] = i / 100.0F;\n       Target[1] = Target[0];\n       Target[2] = 0;\n       Target[3] = 12;\n\n       cmsPipelineEvalFloat(Target, Result, Lut);\n\n       if (!IsGoodFixed15_16(\"0\", Target[0], Result[0])) goto Error;\n       if (!IsGoodFixed15_16(\"1\", Target[1], Result[1])) goto Error;\n       if (!IsGoodFixed15_16(\"2\", Target[2], Result[2])) goto Error;\n   }\n\n   SubTest(\"4->3 zero\");\n   Target[0] = 0;\n   Target[1] = 0;\n   Target[2] = 0;\n\n   // This one holds the fixed K\n   Target[3] = 0;\n\n   // This is our hint (which is a big lie in this case)\n   Hint[0] = 0.1F; Hint[1] = 0.1F; Hint[2] = 0.1F;\n\n   cmsPipelineEvalReverseFloat(Target, Result, Hint, Lut);\n\n   if (Result[0] != 0 || Result[1] != 0 || Result[2] != 0 || Result[3] != 0){\n\n       Fail(\"Reverse interpolation didn't find zero\");\n       goto Error;\n   }\n\n   SubTest(\"4->3 find CMY\");\n   max = 0;\n   for (i=0; i <= 100; i++) {\n\n       cmsFloat32Number in = i / 100.0F;\n\n       Target[0] = in; Target[1] = 0; Target[2] = 0;\n       cmsPipelineEvalReverseFloat(Target, Result, Hint, Lut);\n\n       err = fabsf(in - Result[0]);\n       if (err > max) max = err;\n\n       memcpy(Hint, Result, sizeof(Hint));\n   }\n\n    cmsPipelineFree(Lut);\n    return (max <= FLOAT_PRECISSION);\n\nError:\n    cmsPipelineFree(Lut);\n    return 0;\n}",
          "fn_code_pos": [
            [
              1601,
              0
            ],
            [
              1700,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckReverseInterpolation4x3",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt16Number Fn8D1(cmsUInt16Number a1, cmsUInt16Number a2, cmsUInt16Number a3, cmsUInt16Number a4,\n                      cmsUInt16Number a5, cmsUInt16Number a6, cmsUInt16Number a7, cmsUInt16Number a8,\n                      cmsUInt32Number m)\n{\n    return (cmsUInt16Number) ((a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8) / m);\n}",
          "fn_code_pos": [
            [
              1706,
              0
            ],
            [
              1712,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fn8D1",
            "parameters": {
              "a1": "cmsUInt16Number",
              "a2": "cmsUInt16Number",
              "a3": "cmsUInt16Number",
              "a4": "cmsUInt16Number",
              "a5": "cmsUInt16Number",
              "a6": "cmsUInt16Number",
              "a7": "cmsUInt16Number",
              "a8": "cmsUInt16Number",
              "m": "cmsUInt32Number"
            },
            "return_type": "cmsUInt16Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt16Number Fn8D2(cmsUInt16Number a1, cmsUInt16Number a2, cmsUInt16Number a3, cmsUInt16Number a4,\n                      cmsUInt16Number a5, cmsUInt16Number a6, cmsUInt16Number a7, cmsUInt16Number a8,\n                      cmsUInt32Number m)\n{\n    return (cmsUInt16Number) ((a1 + 3* a2 + 3* a3 + a4 + a5 + a6 + a7 + a8 ) / (m + 4));\n}",
          "fn_code_pos": [
            [
              1715,
              0
            ],
            [
              1721,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fn8D2",
            "parameters": {
              "a1": "cmsUInt16Number",
              "a2": "cmsUInt16Number",
              "a3": "cmsUInt16Number",
              "a4": "cmsUInt16Number",
              "a5": "cmsUInt16Number",
              "a6": "cmsUInt16Number",
              "a7": "cmsUInt16Number",
              "a8": "cmsUInt16Number",
              "m": "cmsUInt32Number"
            },
            "return_type": "cmsUInt16Number"
          }
        },
        {
          "fn_code": "static\ncmsUInt16Number Fn8D3(cmsUInt16Number a1, cmsUInt16Number a2, cmsUInt16Number a3, cmsUInt16Number a4,\n                      cmsUInt16Number a5, cmsUInt16Number a6, cmsUInt16Number a7, cmsUInt16Number a8,\n                      cmsUInt32Number m)\n{\n    return (cmsUInt16Number) ((3*a1 + 2*a2 + 3*a3 + a4 + a5 + a6 + a7 + a8) / (m + 5));\n}",
          "fn_code_pos": [
            [
              1724,
              0
            ],
            [
              1730,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fn8D3",
            "parameters": {
              "a1": "cmsUInt16Number",
              "a2": "cmsUInt16Number",
              "a3": "cmsUInt16Number",
              "a4": "cmsUInt16Number",
              "a5": "cmsUInt16Number",
              "a6": "cmsUInt16Number",
              "a7": "cmsUInt16Number",
              "a8": "cmsUInt16Number",
              "m": "cmsUInt32Number"
            },
            "return_type": "cmsUInt16Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Sampler3D(CMSREGISTER const cmsUInt16Number In[],\n               CMSREGISTER cmsUInt16Number Out[],\n               CMSREGISTER void * Cargo)\n{\n\n    Out[0] = Fn8D1(In[0], In[1], In[2], 0, 0, 0, 0, 0, 3);\n    Out[1] = Fn8D2(In[0], In[1], In[2], 0, 0, 0, 0, 0, 3);\n    Out[2] = Fn8D3(In[0], In[1], In[2], 0, 0, 0, 0, 0, 3);\n\n    return 1;\n\n    cmsUNUSED_PARAMETER(Cargo);\n\n}",
          "fn_code_pos": [
            [
              1735,
              0
            ],
            [
              1749,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Sampler3D",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Sampler4D(CMSREGISTER const cmsUInt16Number In[],\n               CMSREGISTER cmsUInt16Number Out[],\n               CMSREGISTER void * Cargo)\n{\n\n    Out[0] = Fn8D1(In[0], In[1], In[2], In[3], 0, 0, 0, 0, 4);\n    Out[1] = Fn8D2(In[0], In[1], In[2], In[3], 0, 0, 0, 0, 4);\n    Out[2] = Fn8D3(In[0], In[1], In[2], In[3], 0, 0, 0, 0, 4);\n\n    return 1;\n\n    cmsUNUSED_PARAMETER(Cargo);\n}",
          "fn_code_pos": [
            [
              1751,
              0
            ],
            [
              1764,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Sampler4D",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Sampler5D(CMSREGISTER const cmsUInt16Number In[],\n               CMSREGISTER cmsUInt16Number Out[],\n               CMSREGISTER void * Cargo)\n{\n\n    Out[0] = Fn8D1(In[0], In[1], In[2], In[3], In[4], 0, 0, 0, 5);\n    Out[1] = Fn8D2(In[0], In[1], In[2], In[3], In[4], 0, 0, 0, 5);\n    Out[2] = Fn8D3(In[0], In[1], In[2], In[3], In[4], 0, 0, 0, 5);\n\n    return 1;\n\n    cmsUNUSED_PARAMETER(Cargo);\n}",
          "fn_code_pos": [
            [
              1766,
              0
            ],
            [
              1779,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Sampler5D",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Sampler6D(CMSREGISTER const cmsUInt16Number In[],\n               CMSREGISTER cmsUInt16Number Out[],\n               CMSREGISTER void * Cargo)\n{\n\n    Out[0] = Fn8D1(In[0], In[1], In[2], In[3], In[4], In[5], 0, 0, 6);\n    Out[1] = Fn8D2(In[0], In[1], In[2], In[3], In[4], In[5], 0, 0, 6);\n    Out[2] = Fn8D3(In[0], In[1], In[2], In[3], In[4], In[5], 0, 0, 6);\n\n    return 1;\n\n    cmsUNUSED_PARAMETER(Cargo);\n}",
          "fn_code_pos": [
            [
              1781,
              0
            ],
            [
              1794,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Sampler6D",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Sampler7D(CMSREGISTER const cmsUInt16Number In[],\n               CMSREGISTER cmsUInt16Number Out[],\n               CMSREGISTER void * Cargo)\n{\n\n    Out[0] = Fn8D1(In[0], In[1], In[2], In[3], In[4], In[5], In[6], 0, 7);\n    Out[1] = Fn8D2(In[0], In[1], In[2], In[3], In[4], In[5], In[6], 0, 7);\n    Out[2] = Fn8D3(In[0], In[1], In[2], In[3], In[4], In[5], In[6], 0, 7);\n\n    return 1;\n\n    cmsUNUSED_PARAMETER(Cargo);\n}",
          "fn_code_pos": [
            [
              1796,
              0
            ],
            [
              1809,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Sampler7D",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Sampler8D(CMSREGISTER const cmsUInt16Number In[],\n               CMSREGISTER cmsUInt16Number Out[],\n               CMSREGISTER void * Cargo)\n{\n\n    Out[0] = Fn8D1(In[0], In[1], In[2], In[3], In[4], In[5], In[6], In[7], 8);\n    Out[1] = Fn8D2(In[0], In[1], In[2], In[3], In[4], In[5], In[6], In[7], 8);\n    Out[2] = Fn8D3(In[0], In[1], In[2], In[3], In[4], In[5], In[6], In[7], 8);\n\n    return 1;\n\n    cmsUNUSED_PARAMETER(Cargo);\n}",
          "fn_code_pos": [
            [
              1811,
              0
            ],
            [
              1824,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Sampler8D",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsBool CheckOne3D(cmsPipeline* lut, cmsUInt16Number a1, cmsUInt16Number a2, cmsUInt16Number a3)\n{\n    cmsUInt16Number In[3], Out1[3], Out2[3];\n\n    In[0] = a1; In[1] = a2; In[2] = a3;\n\n    // This is the interpolated value\n    cmsPipelineEval16(In, Out1, lut);\n\n    // This is the real value\n    Sampler3D(In, Out2, NULL);\n\n    // Let's see the difference\n\n    if (!IsGoodWordPrec(\"Channel 1\", Out1[0], Out2[0], 2)) return FALSE;\n    if (!IsGoodWordPrec(\"Channel 2\", Out1[1], Out2[1], 2)) return FALSE;\n    if (!IsGoodWordPrec(\"Channel 3\", Out1[2], Out2[2], 2)) return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1826,
              0
            ],
            [
              1846,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckOne3D",
            "parameters": {
              "lut": "cmsPipeline",
              "a1": "cmsUInt16Number",
              "a2": "cmsUInt16Number",
              "a3": "cmsUInt16Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool CheckOne4D(cmsPipeline* lut, cmsUInt16Number a1, cmsUInt16Number a2, cmsUInt16Number a3, cmsUInt16Number a4)\n{\n    cmsUInt16Number In[4], Out1[3], Out2[3];\n\n    In[0] = a1; In[1] = a2; In[2] = a3; In[3] = a4;\n\n    // This is the interpolated value\n    cmsPipelineEval16(In, Out1, lut);\n\n    // This is the real value\n    Sampler4D(In, Out2, NULL);\n\n    // Let's see the difference\n\n    if (!IsGoodWordPrec(\"Channel 1\", Out1[0], Out2[0], 2)) return FALSE;\n    if (!IsGoodWordPrec(\"Channel 2\", Out1[1], Out2[1], 2)) return FALSE;\n    if (!IsGoodWordPrec(\"Channel 3\", Out1[2], Out2[2], 2)) return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1848,
              0
            ],
            [
              1868,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckOne4D",
            "parameters": {
              "lut": "cmsPipeline",
              "a1": "cmsUInt16Number",
              "a2": "cmsUInt16Number",
              "a3": "cmsUInt16Number",
              "a4": "cmsUInt16Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool CheckOne5D(cmsPipeline* lut, cmsUInt16Number a1, cmsUInt16Number a2,\n                                     cmsUInt16Number a3, cmsUInt16Number a4, cmsUInt16Number a5)\n{\n    cmsUInt16Number In[5], Out1[3], Out2[3];\n\n    In[0] = a1; In[1] = a2; In[2] = a3; In[3] = a4; In[4] = a5;\n\n    // This is the interpolated value\n    cmsPipelineEval16(In, Out1, lut);\n\n    // This is the real value\n    Sampler5D(In, Out2, NULL);\n\n    // Let's see the difference\n\n    if (!IsGoodWordPrec(\"Channel 1\", Out1[0], Out2[0], 2)) return FALSE;\n    if (!IsGoodWordPrec(\"Channel 2\", Out1[1], Out2[1], 2)) return FALSE;\n    if (!IsGoodWordPrec(\"Channel 3\", Out1[2], Out2[2], 2)) return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1870,
              0
            ],
            [
              1891,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckOne5D",
            "parameters": {
              "lut": "cmsPipeline",
              "a1": "cmsUInt16Number",
              "a2": "cmsUInt16Number",
              "a3": "cmsUInt16Number",
              "a4": "cmsUInt16Number",
              "a5": "cmsUInt16Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool CheckOne6D(cmsPipeline* lut, cmsUInt16Number a1, cmsUInt16Number a2,\n                                     cmsUInt16Number a3, cmsUInt16Number a4,\n                                     cmsUInt16Number a5, cmsUInt16Number a6)\n{\n    cmsUInt16Number In[6], Out1[3], Out2[3];\n\n    In[0] = a1; In[1] = a2; In[2] = a3; In[3] = a4; In[4] = a5; In[5] = a6;\n\n    // This is the interpolated value\n    cmsPipelineEval16(In, Out1, lut);\n\n    // This is the real value\n    Sampler6D(In, Out2, NULL);\n\n    // Let's see the difference\n\n    if (!IsGoodWordPrec(\"Channel 1\", Out1[0], Out2[0], 2)) return FALSE;\n    if (!IsGoodWordPrec(\"Channel 2\", Out1[1], Out2[1], 2)) return FALSE;\n    if (!IsGoodWordPrec(\"Channel 3\", Out1[2], Out2[2], 2)) return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1893,
              0
            ],
            [
              1915,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckOne6D",
            "parameters": {
              "lut": "cmsPipeline",
              "a1": "cmsUInt16Number",
              "a2": "cmsUInt16Number",
              "a3": "cmsUInt16Number",
              "a4": "cmsUInt16Number",
              "a5": "cmsUInt16Number",
              "a6": "cmsUInt16Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool CheckOne7D(cmsPipeline* lut, cmsUInt16Number a1, cmsUInt16Number a2,\n                                     cmsUInt16Number a3, cmsUInt16Number a4,\n                                     cmsUInt16Number a5, cmsUInt16Number a6,\n                                     cmsUInt16Number a7)\n{\n    cmsUInt16Number In[7], Out1[3], Out2[3];\n\n    In[0] = a1; In[1] = a2; In[2] = a3; In[3] = a4; In[4] = a5; In[5] = a6; In[6] = a7;\n\n    // This is the interpolated value\n    cmsPipelineEval16(In, Out1, lut);\n\n    // This is the real value\n    Sampler7D(In, Out2, NULL);\n\n    // Let's see the difference\n\n    if (!IsGoodWordPrec(\"Channel 1\", Out1[0], Out2[0], 2)) return FALSE;\n    if (!IsGoodWordPrec(\"Channel 2\", Out1[1], Out2[1], 2)) return FALSE;\n    if (!IsGoodWordPrec(\"Channel 3\", Out1[2], Out2[2], 2)) return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1918,
              0
            ],
            [
              1941,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckOne7D",
            "parameters": {
              "lut": "cmsPipeline",
              "a1": "cmsUInt16Number",
              "a2": "cmsUInt16Number",
              "a3": "cmsUInt16Number",
              "a4": "cmsUInt16Number",
              "a5": "cmsUInt16Number",
              "a6": "cmsUInt16Number",
              "a7": "cmsUInt16Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsBool CheckOne8D(cmsPipeline* lut, cmsUInt16Number a1, cmsUInt16Number a2,\n                                     cmsUInt16Number a3, cmsUInt16Number a4,\n                                     cmsUInt16Number a5, cmsUInt16Number a6,\n                                     cmsUInt16Number a7, cmsUInt16Number a8)\n{\n    cmsUInt16Number In[8], Out1[3], Out2[3];\n\n    In[0] = a1; In[1] = a2; In[2] = a3; In[3] = a4; In[4] = a5; In[5] = a6; In[6] = a7; In[7] = a8;\n\n    // This is the interpolated value\n    cmsPipelineEval16(In, Out1, lut);\n\n    // This is the real value\n    Sampler8D(In, Out2, NULL);\n\n    // Let's see the difference\n\n    if (!IsGoodWordPrec(\"Channel 1\", Out1[0], Out2[0], 2)) return FALSE;\n    if (!IsGoodWordPrec(\"Channel 2\", Out1[1], Out2[1], 2)) return FALSE;\n    if (!IsGoodWordPrec(\"Channel 3\", Out1[2], Out2[2], 2)) return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              1944,
              0
            ],
            [
              1967,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckOne8D",
            "parameters": {
              "lut": "cmsPipeline",
              "a1": "cmsUInt16Number",
              "a2": "cmsUInt16Number",
              "a3": "cmsUInt16Number",
              "a4": "cmsUInt16Number",
              "a5": "cmsUInt16Number",
              "a6": "cmsUInt16Number",
              "a7": "cmsUInt16Number",
              "a8": "cmsUInt16Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check3Dinterp(void)\n{\n    cmsPipeline* lut;\n    cmsStage* mpe;\n\n    lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n    mpe = cmsStageAllocCLut16bit(DbgThread(), 9, 3, 3, NULL);\n    cmsStageSampleCLut16bit(mpe, Sampler3D, NULL, 0);\n    cmsPipelineInsertStage(lut, cmsAT_BEGIN, mpe);\n\n    // Check accuracy\n\n    if (!CheckOne3D(lut, 0, 0, 0)) return 0;\n    if (!CheckOne3D(lut, 0xffff, 0xffff, 0xffff)) return 0;\n\n    if (!CheckOne3D(lut, 0x8080, 0x8080, 0x8080)) return 0;\n    if (!CheckOne3D(lut, 0x0000, 0xFE00, 0x80FF)) return 0;\n    if (!CheckOne3D(lut, 0x1111, 0x2222, 0x3333)) return 0;\n    if (!CheckOne3D(lut, 0x0000, 0x0012, 0x0013)) return 0;\n    if (!CheckOne3D(lut, 0x3141, 0x1415, 0x1592)) return 0;\n    if (!CheckOne3D(lut, 0xFF00, 0xFF01, 0xFF12)) return 0;\n\n    cmsPipelineFree(lut);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              1970,
              0
            ],
            [
              1996,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check3Dinterp",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check3DinterpGranular(void)\n{\n    cmsPipeline* lut;\n    cmsStage* mpe;\n    cmsUInt32Number Dimensions[] = { 7, 8, 9 };\n\n    lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n    mpe = cmsStageAllocCLut16bitGranular(DbgThread(), Dimensions, 3, 3, NULL);\n    cmsStageSampleCLut16bit(mpe, Sampler3D, NULL, 0);\n    cmsPipelineInsertStage(lut, cmsAT_BEGIN, mpe);\n\n    // Check accuracy\n\n    if (!CheckOne3D(lut, 0, 0, 0)) return 0;\n    if (!CheckOne3D(lut, 0xffff, 0xffff, 0xffff)) return 0;\n\n    if (!CheckOne3D(lut, 0x8080, 0x8080, 0x8080)) return 0;\n    if (!CheckOne3D(lut, 0x0000, 0xFE00, 0x80FF)) return 0;\n    if (!CheckOne3D(lut, 0x1111, 0x2222, 0x3333)) return 0;\n    if (!CheckOne3D(lut, 0x0000, 0x0012, 0x0013)) return 0;\n    if (!CheckOne3D(lut, 0x3141, 0x1415, 0x1592)) return 0;\n    if (!CheckOne3D(lut, 0xFF00, 0xFF01, 0xFF12)) return 0;\n\n    cmsPipelineFree(lut);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              1998,
              0
            ],
            [
              2025,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check3DinterpGranular",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check4Dinterp(void)\n{\n    cmsPipeline* lut;\n    cmsStage* mpe;\n\n    lut = cmsPipelineAlloc(DbgThread(), 4, 3);\n    mpe = cmsStageAllocCLut16bit(DbgThread(), 9, 4, 3, NULL);\n    cmsStageSampleCLut16bit(mpe, Sampler4D, NULL, 0);\n    cmsPipelineInsertStage(lut, cmsAT_BEGIN, mpe);\n\n    // Check accuracy\n\n    if (!CheckOne4D(lut, 0, 0, 0, 0)) return 0;\n    if (!CheckOne4D(lut, 0xffff, 0xffff, 0xffff, 0xffff)) return 0;\n\n    if (!CheckOne4D(lut, 0x8080, 0x8080, 0x8080, 0x8080)) return 0;\n    if (!CheckOne4D(lut, 0x0000, 0xFE00, 0x80FF, 0x8888)) return 0;\n    if (!CheckOne4D(lut, 0x1111, 0x2222, 0x3333, 0x4444)) return 0;\n    if (!CheckOne4D(lut, 0x0000, 0x0012, 0x0013, 0x0014)) return 0;\n    if (!CheckOne4D(lut, 0x3141, 0x1415, 0x1592, 0x9261)) return 0;\n    if (!CheckOne4D(lut, 0xFF00, 0xFF01, 0xFF12, 0xFF13)) return 0;\n\n    cmsPipelineFree(lut);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              2028,
              0
            ],
            [
              2054,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check4Dinterp",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check4DinterpGranular(void)\n{\n    cmsPipeline* lut;\n    cmsStage* mpe;\n    cmsUInt32Number Dimensions[] = { 9, 8, 7, 6 };\n\n    lut = cmsPipelineAlloc(DbgThread(), 4, 3);\n    mpe = cmsStageAllocCLut16bitGranular(DbgThread(), Dimensions, 4, 3, NULL);\n    cmsStageSampleCLut16bit(mpe, Sampler4D, NULL, 0);\n    cmsPipelineInsertStage(lut, cmsAT_BEGIN, mpe);\n\n    // Check accuracy\n\n    if (!CheckOne4D(lut, 0, 0, 0, 0)) return 0;\n    if (!CheckOne4D(lut, 0xffff, 0xffff, 0xffff, 0xffff)) return 0;\n\n    if (!CheckOne4D(lut, 0x8080, 0x8080, 0x8080, 0x8080)) return 0;\n    if (!CheckOne4D(lut, 0x0000, 0xFE00, 0x80FF, 0x8888)) return 0;\n    if (!CheckOne4D(lut, 0x1111, 0x2222, 0x3333, 0x4444)) return 0;\n    if (!CheckOne4D(lut, 0x0000, 0x0012, 0x0013, 0x0014)) return 0;\n    if (!CheckOne4D(lut, 0x3141, 0x1415, 0x1592, 0x9261)) return 0;\n    if (!CheckOne4D(lut, 0xFF00, 0xFF01, 0xFF12, 0xFF13)) return 0;\n\n    cmsPipelineFree(lut);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              2058,
              0
            ],
            [
              2085,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check4DinterpGranular",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check5DinterpGranular(void)\n{\n    cmsPipeline* lut;\n    cmsStage* mpe;\n    cmsUInt32Number Dimensions[] = { 3, 2, 2, 2, 2 };\n\n    lut = cmsPipelineAlloc(DbgThread(), 5, 3);\n    mpe = cmsStageAllocCLut16bitGranular(DbgThread(), Dimensions, 5, 3, NULL);\n    cmsStageSampleCLut16bit(mpe, Sampler5D, NULL, 0);\n    cmsPipelineInsertStage(lut, cmsAT_BEGIN, mpe);\n\n    // Check accuracy\n\n    if (!CheckOne5D(lut, 0, 0, 0, 0, 0)) return 0;\n    if (!CheckOne5D(lut, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff)) return 0;\n\n    if (!CheckOne5D(lut, 0x8080, 0x8080, 0x8080, 0x8080, 0x1234)) return 0;\n    if (!CheckOne5D(lut, 0x0000, 0xFE00, 0x80FF, 0x8888, 0x8078)) return 0;\n    if (!CheckOne5D(lut, 0x1111, 0x2222, 0x3333, 0x4444, 0x1455)) return 0;\n    if (!CheckOne5D(lut, 0x0000, 0x0012, 0x0013, 0x0014, 0x2333)) return 0;\n    if (!CheckOne5D(lut, 0x3141, 0x1415, 0x1592, 0x9261, 0x4567)) return 0;\n    if (!CheckOne5D(lut, 0xFF00, 0xFF01, 0xFF12, 0xFF13, 0xF344)) return 0;\n\n    cmsPipelineFree(lut);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              2088,
              0
            ],
            [
              2115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check5DinterpGranular",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check6DinterpGranular(void)\n{\n    cmsPipeline* lut;\n    cmsStage* mpe;\n    cmsUInt32Number Dimensions[] = { 4, 3, 3, 2, 2, 2 };\n\n    lut = cmsPipelineAlloc(DbgThread(), 6, 3);\n    mpe = cmsStageAllocCLut16bitGranular(DbgThread(), Dimensions, 6, 3, NULL);\n    cmsStageSampleCLut16bit(mpe, Sampler6D, NULL, 0);\n    cmsPipelineInsertStage(lut, cmsAT_BEGIN, mpe);\n\n    // Check accuracy\n\n    if (!CheckOne6D(lut, 0, 0, 0, 0, 0, 0)) return 0;\n    if (!CheckOne6D(lut, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff)) return 0;\n\n    if (!CheckOne6D(lut, 0x8080, 0x8080, 0x8080, 0x8080, 0x1234, 0x1122)) return 0;\n    if (!CheckOne6D(lut, 0x0000, 0xFE00, 0x80FF, 0x8888, 0x8078, 0x2233)) return 0;\n    if (!CheckOne6D(lut, 0x1111, 0x2222, 0x3333, 0x4444, 0x1455, 0x3344)) return 0;\n    if (!CheckOne6D(lut, 0x0000, 0x0012, 0x0013, 0x0014, 0x2333, 0x4455)) return 0;\n    if (!CheckOne6D(lut, 0x3141, 0x1415, 0x1592, 0x9261, 0x4567, 0x5566)) return 0;\n    if (!CheckOne6D(lut, 0xFF00, 0xFF01, 0xFF12, 0xFF13, 0xF344, 0x6677)) return 0;\n\n    cmsPipelineFree(lut);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              2117,
              0
            ],
            [
              2144,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check6DinterpGranular",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check7DinterpGranular(void)\n{\n    cmsPipeline* lut;\n    cmsStage* mpe;\n    cmsUInt32Number Dimensions[] = { 4, 3, 3, 2, 2, 2, 2 };\n\n    lut = cmsPipelineAlloc(DbgThread(), 7, 3);\n    mpe = cmsStageAllocCLut16bitGranular(DbgThread(), Dimensions, 7, 3, NULL);\n    cmsStageSampleCLut16bit(mpe, Sampler7D, NULL, 0);\n    cmsPipelineInsertStage(lut, cmsAT_BEGIN, mpe);\n\n    // Check accuracy\n\n    if (!CheckOne7D(lut, 0, 0, 0, 0, 0, 0, 0)) return 0;\n    if (!CheckOne7D(lut, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff)) return 0;\n\n    if (!CheckOne7D(lut, 0x8080, 0x8080, 0x8080, 0x8080, 0x1234, 0x1122, 0x0056)) return 0;\n    if (!CheckOne7D(lut, 0x0000, 0xFE00, 0x80FF, 0x8888, 0x8078, 0x2233, 0x0088)) return 0;\n    if (!CheckOne7D(lut, 0x1111, 0x2222, 0x3333, 0x4444, 0x1455, 0x3344, 0x1987)) return 0;\n    if (!CheckOne7D(lut, 0x0000, 0x0012, 0x0013, 0x0014, 0x2333, 0x4455, 0x9988)) return 0;\n    if (!CheckOne7D(lut, 0x3141, 0x1415, 0x1592, 0x9261, 0x4567, 0x5566, 0xfe56)) return 0;\n    if (!CheckOne7D(lut, 0xFF00, 0xFF01, 0xFF12, 0xFF13, 0xF344, 0x6677, 0xbabe)) return 0;\n\n    cmsPipelineFree(lut);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              2146,
              0
            ],
            [
              2173,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check7DinterpGranular",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check8DinterpGranular(void)\n{\n    cmsPipeline* lut;\n    cmsStage* mpe;\n    cmsUInt32Number Dimensions[] = { 4, 3, 3, 2, 2, 2, 2, 2 };\n\n    lut = cmsPipelineAlloc(DbgThread(), 8, 3);\n    mpe = cmsStageAllocCLut16bitGranular(DbgThread(), Dimensions, 8, 3, NULL);\n    cmsStageSampleCLut16bit(mpe, Sampler8D, NULL, 0);\n    cmsPipelineInsertStage(lut, cmsAT_BEGIN, mpe);\n\n    // Check accuracy\n\n    if (!CheckOne8D(lut, 0, 0, 0, 0, 0, 0, 0, 0)) return 0;\n    if (!CheckOne8D(lut, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff)) return 0;\n\n    if (!CheckOne8D(lut, 0x8080, 0x8080, 0x8080, 0x8080, 0x1234, 0x1122, 0x0056, 0x0011)) return 0;\n    if (!CheckOne8D(lut, 0x0000, 0xFE00, 0x80FF, 0x8888, 0x8078, 0x2233, 0x0088, 0x2020)) return 0;\n    if (!CheckOne8D(lut, 0x1111, 0x2222, 0x3333, 0x4444, 0x1455, 0x3344, 0x1987, 0x4532)) return 0;\n    if (!CheckOne8D(lut, 0x0000, 0x0012, 0x0013, 0x0014, 0x2333, 0x4455, 0x9988, 0x1200)) return 0;\n    if (!CheckOne8D(lut, 0x3141, 0x1415, 0x1592, 0x9261, 0x4567, 0x5566, 0xfe56, 0x6666)) return 0;\n    if (!CheckOne8D(lut, 0xFF00, 0xFF01, 0xFF12, 0xFF13, 0xF344, 0x6677, 0xbabe, 0xface)) return 0;\n\n    cmsPipelineFree(lut);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              2176,
              0
            ],
            [
              2203,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check8DinterpGranular",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckLab2LCh(void)\n{\n    cmsInt32Number l, a, b;\n    cmsFloat64Number dist, Max = 0;\n    cmsCIELab Lab, Lab2;\n    cmsCIELCh LCh;\n\n    for (l=0; l <= 100; l += 10) {\n\n        for (a=-128; a <= +128; a += 8) {\n\n            for (b=-128; b <= 128; b += 8) {\n\n                Lab.L = l;\n                Lab.a = a;\n                Lab.b = b;\n\n                cmsLab2LCh(&LCh, &Lab);\n                cmsLCh2Lab(&Lab2, &LCh);\n\n                dist = cmsDeltaE(&Lab, &Lab2);\n                if (dist > Max) Max = dist;\n            }\n        }\n    }\n\n    return Max < 1E-12;\n}",
          "fn_code_pos": [
            [
              2208,
              0
            ],
            [
              2236,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckLab2LCh",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckLab2XYZ(void)\n{\n    cmsInt32Number l, a, b;\n    cmsFloat64Number dist, Max = 0;\n    cmsCIELab Lab, Lab2;\n    cmsCIEXYZ XYZ;\n\n    for (l=0; l <= 100; l += 10) {\n\n        for (a=-128; a <= +128; a += 8) {\n\n            for (b=-128; b <= 128; b += 8) {\n\n                Lab.L = l;\n                Lab.a = a;\n                Lab.b = b;\n\n                cmsLab2XYZ(NULL, &XYZ, &Lab);\n                cmsXYZ2Lab(NULL, &Lab2, &XYZ);\n\n                dist = cmsDeltaE(&Lab, &Lab2);\n                if (dist > Max) Max = dist;\n\n            }\n        }\n    }\n\n    return Max < 1E-12;\n}",
          "fn_code_pos": [
            [
              2239,
              0
            ],
            [
              2268,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckLab2XYZ",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckLab2xyY(void)\n{\n    cmsInt32Number l, a, b;\n    cmsFloat64Number dist, Max = 0;\n    cmsCIELab Lab, Lab2;\n    cmsCIEXYZ XYZ;\n    cmsCIExyY xyY;\n\n    for (l=0; l <= 100; l += 10) {\n\n        for (a=-128; a <= +128; a += 8) {\n\n            for (b=-128; b <= 128; b += 8) {\n\n                Lab.L = l;\n                Lab.a = a;\n                Lab.b = b;\n\n                cmsLab2XYZ(NULL, &XYZ, &Lab);\n                cmsXYZ2xyY(&xyY, &XYZ);\n                cmsxyY2XYZ(&XYZ, &xyY);\n                cmsXYZ2Lab(NULL, &Lab2, &XYZ);\n\n                dist = cmsDeltaE(&Lab, &Lab2);\n                if (dist > Max) Max = dist;\n\n            }\n        }\n    }\n\n    return Max < 1E-12;\n}",
          "fn_code_pos": [
            [
              2271,
              0
            ],
            [
              2303,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckLab2xyY",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckLabV2encoding(void)\n{\n    cmsInt32Number n2, i, j;\n    cmsUInt16Number Inw[3], aw[3];\n    cmsCIELab Lab;\n\n    n2=0;\n\n    for (j=0; j < 65535; j++) {\n\n        Inw[0] = Inw[1] = Inw[2] = (cmsUInt16Number) j;\n\n        cmsLabEncoded2FloatV2(&Lab, Inw);\n        cmsFloat2LabEncodedV2(aw, &Lab);\n\n        for (i=0; i < 3; i++) {\n\n        if (aw[i] != j) {\n            n2++;\n        }\n        }\n\n    }\n\n    return (n2 == 0);\n}",
          "fn_code_pos": [
            [
              2306,
              0
            ],
            [
              2332,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckLabV2encoding",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckLabV4encoding(void)\n{\n    cmsInt32Number n2, i, j;\n    cmsUInt16Number Inw[3], aw[3];\n    cmsCIELab Lab;\n\n    n2=0;\n\n    for (j=0; j < 65535; j++) {\n\n        Inw[0] = Inw[1] = Inw[2] = (cmsUInt16Number) j;\n\n        cmsLabEncoded2Float(&Lab, Inw);\n        cmsFloat2LabEncoded(aw, &Lab);\n\n        for (i=0; i < 3; i++) {\n\n        if (aw[i] != j) {\n            n2++;\n        }\n        }\n\n    }\n\n    return (n2 == 0);\n}",
          "fn_code_pos": [
            [
              2334,
              0
            ],
            [
              2360,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckLabV4encoding",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckTemp2CHRM(void)\n{\n    cmsInt32Number j;\n    cmsFloat64Number d, v, Max = 0;\n    cmsCIExyY White;\n\n    for (j=4000; j < 25000; j++) {\n\n        cmsWhitePointFromTemp(&White, j);\n        if (!cmsTempFromWhitePoint(&v, &White)) return 0;\n\n        d = fabs(v - j);\n        if (d > Max) Max = d;\n    }\n\n    // 100 degree is the actual resolution\n    return (Max < 100);\n}",
          "fn_code_pos": [
            [
              2365,
              0
            ],
            [
              2383,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckTemp2CHRM",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckGammaEstimation(cmsToneCurve* c, cmsFloat64Number g)\n{\n    cmsFloat64Number est = cmsEstimateGamma(c, 0.001);\n\n    SubTest(\"Gamma estimation\");\n    if (fabs(est - g) > 0.001) return 0;\n    return 1;\n}",
          "fn_code_pos": [
            [
              2389,
              0
            ],
            [
              2397,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGammaEstimation",
            "parameters": {
              "c": "cmsToneCurve",
              "g": "cmsFloat64Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckGammaCreation16(void)\n{\n    cmsToneCurve* LinGamma = cmsBuildGamma(DbgThread(), 1.0);\n    cmsInt32Number i;\n    cmsUInt16Number in, out;\n\n    for (i=0; i < 0xffff; i++) {\n\n        in = (cmsUInt16Number) i;\n        out = cmsEvalToneCurve16(LinGamma, in);\n        if (in != out) {\n            Fail(\"(lin gamma): Must be %x, But is %x : \", in, out);\n            cmsFreeToneCurve(LinGamma);\n            return 0;\n        }\n    }\n\n    if (!CheckGammaEstimation(LinGamma, 1.0)) return 0;\n\n    cmsFreeToneCurve(LinGamma);\n    return 1;\n\n}",
          "fn_code_pos": [
            [
              2399,
              0
            ],
            [
              2422,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGammaCreation16",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckGammaCreationFlt(void)\n{\n    cmsToneCurve* LinGamma = cmsBuildGamma(DbgThread(), 1.0);\n    cmsInt32Number i;\n    cmsFloat32Number in, out;\n\n    for (i=0; i < 0xffff; i++) {\n\n        in = (cmsFloat32Number) (i / 65535.0);\n        out = cmsEvalToneCurveFloat(LinGamma, in);\n        if (fabs(in - out) > (1/65535.0)) {\n            Fail(\"(lin gamma): Must be %f, But is %f : \", in, out);\n            cmsFreeToneCurve(LinGamma);\n            return 0;\n        }\n    }\n\n    if (!CheckGammaEstimation(LinGamma, 1.0)) return 0;\n    cmsFreeToneCurve(LinGamma);\n    return 1;\n}",
          "fn_code_pos": [
            [
              2424,
              0
            ],
            [
              2445,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGammaCreationFlt",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckGammaFloat(cmsFloat64Number g)\n{\n    cmsToneCurve* Curve = cmsBuildGamma(DbgThread(), g);\n    cmsInt32Number i;\n    cmsFloat32Number in, out;\n    cmsFloat64Number val, Err;\n\n    MaxErr = 0.0;\n    for (i=0; i < 0xffff; i++) {\n\n        in = (cmsFloat32Number) (i / 65535.0);\n        out = cmsEvalToneCurveFloat(Curve, in);\n        val = pow((cmsFloat64Number) in, g);\n\n        Err = fabs( val - out);\n        if (Err > MaxErr) MaxErr = Err;\n    }\n\n    if (MaxErr > 0) printf(\"|Err|<%lf \", MaxErr * 65535.0);\n\n    if (!CheckGammaEstimation(Curve, g)) return 0;\n\n    cmsFreeToneCurve(Curve);\n    return 1;\n}",
          "fn_code_pos": [
            [
              2449,
              0
            ],
            [
              2474,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGammaFloat",
            "parameters": {
              "g": "cmsFloat64Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static cmsInt32Number CheckGamma18(void)\n{\n    return CheckGammaFloat(1.8);\n}",
          "fn_code_pos": [
            [
              2476,
              0
            ],
            [
              2479,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGamma18",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static cmsInt32Number CheckGamma22(void)\n{\n    return CheckGammaFloat(2.2);\n}",
          "fn_code_pos": [
            [
              2481,
              0
            ],
            [
              2484,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGamma22",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static cmsInt32Number CheckGamma30(void)\n{\n    return CheckGammaFloat(3.0);\n}",
          "fn_code_pos": [
            [
              2486,
              0
            ],
            [
              2489,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGamma30",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckGammaFloatTable(cmsFloat64Number g)\n{\n    cmsFloat32Number Values[1025];\n    cmsToneCurve* Curve;\n    cmsInt32Number i;\n    cmsFloat32Number in, out;\n    cmsFloat64Number val, Err;\n\n    for (i=0; i <= 1024; i++) {\n\n        in = (cmsFloat32Number) (i / 1024.0);\n        Values[i] = powf(in, (float) g);\n    }\n\n    Curve = cmsBuildTabulatedToneCurveFloat(DbgThread(), 1025, Values);\n\n    MaxErr = 0.0;\n    for (i=0; i <= 0xffff; i++) {\n\n        in = (cmsFloat32Number) (i / 65535.0);\n        out = cmsEvalToneCurveFloat(Curve, in);\n        val = pow(in, g);\n\n        Err = fabs(val - out);\n        if (Err > MaxErr) MaxErr = Err;\n    }\n\n    if (MaxErr > 0) printf(\"|Err|<%lf \", MaxErr * 65535.0);\n\n    if (!CheckGammaEstimation(Curve, g)) return 0;\n\n    cmsFreeToneCurve(Curve);\n    return 1;\n}",
          "fn_code_pos": [
            [
              2493,
              0
            ],
            [
              2527,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGammaFloatTable",
            "parameters": {
              "g": "cmsFloat64Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static cmsInt32Number CheckGamma18Table(void)\n{\n    return CheckGammaFloatTable(1.8);\n}",
          "fn_code_pos": [
            [
              2530,
              0
            ],
            [
              2533,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGamma18Table",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static cmsInt32Number CheckGamma22Table(void)\n{\n    return CheckGammaFloatTable(2.2);\n}",
          "fn_code_pos": [
            [
              2535,
              0
            ],
            [
              2538,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGamma22Table",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static cmsInt32Number CheckGamma30Table(void)\n{\n    return CheckGammaFloatTable(3.0);\n}",
          "fn_code_pos": [
            [
              2540,
              0
            ],
            [
              2543,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGamma30Table",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckGammaWordTable(cmsFloat64Number g)\n{\n    cmsUInt16Number Values[1025];\n    cmsToneCurve* Curve;\n    cmsInt32Number i;\n    cmsFloat32Number in, out;\n    cmsFloat64Number val, Err;\n\n    for (i=0; i <= 1024; i++) {\n\n        in = (cmsFloat32Number) (i / 1024.0);\n        Values[i] = (cmsUInt16Number) floor(pow(in, g) * 65535.0 + 0.5);\n    }\n\n    Curve = cmsBuildTabulatedToneCurve16(DbgThread(), 1025, Values);\n\n    MaxErr = 0.0;\n    for (i=0; i <= 0xffff; i++) {\n\n        in = (cmsFloat32Number) (i / 65535.0);\n        out = cmsEvalToneCurveFloat(Curve, in);\n        val = pow(in, g);\n\n        Err = fabs(val - out);\n        if (Err > MaxErr) MaxErr = Err;\n    }\n\n    if (MaxErr > 0) printf(\"|Err|<%lf \", MaxErr * 65535.0);\n\n    if (!CheckGammaEstimation(Curve, g)) return 0;\n\n    cmsFreeToneCurve(Curve);\n    return 1;\n}",
          "fn_code_pos": [
            [
              2546,
              0
            ],
            [
              2580,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGammaWordTable",
            "parameters": {
              "g": "cmsFloat64Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static cmsInt32Number CheckGamma18TableWord(void)\n{\n    return CheckGammaWordTable(1.8);\n}",
          "fn_code_pos": [
            [
              2582,
              0
            ],
            [
              2585,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGamma18TableWord",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static cmsInt32Number CheckGamma22TableWord(void)\n{\n    return CheckGammaWordTable(2.2);\n}",
          "fn_code_pos": [
            [
              2587,
              0
            ],
            [
              2590,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGamma22TableWord",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static cmsInt32Number CheckGamma30TableWord(void)\n{\n    return CheckGammaWordTable(3.0);\n}",
          "fn_code_pos": [
            [
              2592,
              0
            ],
            [
              2595,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGamma30TableWord",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckJointCurves(void)\n{\n    cmsToneCurve *Forward, *Reverse, *Result;\n    cmsBool  rc;\n\n    Forward = cmsBuildGamma(DbgThread(), 3.0);\n    Reverse = cmsBuildGamma(DbgThread(), 3.0);\n\n    Result = cmsJoinToneCurve(DbgThread(), Forward, Reverse, 256);\n\n    cmsFreeToneCurve(Forward); cmsFreeToneCurve(Reverse);\n\n    rc = cmsIsToneCurveLinear(Result);\n    cmsFreeToneCurve(Result);\n\n    if (!rc)\n        Fail(\"Joining same curve twice does not result in a linear ramp\");\n\n    return rc;\n}",
          "fn_code_pos": [
            [
              2600,
              0
            ],
            [
              2620,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckJointCurves",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsToneCurve* GammaTableLinear(cmsInt32Number nEntries, cmsBool Dir)\n{\n    cmsInt32Number i;\n    cmsToneCurve* g = cmsBuildTabulatedToneCurve16(DbgThread(), nEntries, NULL);\n\n    for (i=0; i < nEntries; i++) {\n\n        cmsInt32Number v = _cmsQuantizeVal(i, nEntries);\n\n        if (Dir)\n            g->Table16[i] = (cmsUInt16Number) v;\n        else\n            g->Table16[i] = (cmsUInt16Number) (0xFFFF - v);\n    }\n\n    return g;\n}",
          "fn_code_pos": [
            [
              2625,
              0
            ],
            [
              2642,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GammaTableLinear",
            "parameters": {
              "nEntries": "cmsInt32Number",
              "Dir": "cmsBool"
            },
            "return_type": "cmsToneCurve"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckJointCurvesDescending(void)\n{\n    cmsToneCurve *Forward, *Reverse, *Result;\n    cmsInt32Number i, rc;\n\n     Forward = cmsBuildGamma(DbgThread(), 2.2);\n\n    // Fake the curve to be table-based\n\n    for (i=0; i < 4096; i++)\n        Forward ->Table16[i] = 0xffff - Forward->Table16[i];\n    Forward ->Segments[0].Type = 0;\n\n    Reverse = cmsReverseToneCurve(Forward);\n\n    Result = cmsJoinToneCurve(DbgThread(), Reverse, Reverse, 256);\n\n    cmsFreeToneCurve(Forward);\n    cmsFreeToneCurve(Reverse);\n\n    rc = cmsIsToneCurveLinear(Result);\n    cmsFreeToneCurve(Result);\n\n    return rc;\n}",
          "fn_code_pos": [
            [
              2646,
              0
            ],
            [
              2671,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckJointCurvesDescending",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckFToneCurvePoint(cmsToneCurve* c, cmsUInt16Number Point, cmsInt32Number Value)\n{\n    cmsInt32Number Result;\n\n    Result = cmsEvalToneCurve16(c, Point);\n\n    return (abs(Value - Result) < 2);\n}",
          "fn_code_pos": [
            [
              2674,
              0
            ],
            [
              2682,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckFToneCurvePoint",
            "parameters": {
              "c": "cmsToneCurve",
              "Point": "cmsUInt16Number",
              "Value": "cmsInt32Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckReverseDegenerated(void)\n{\n    cmsToneCurve* p, *g;\n    cmsUInt16Number Tab[16];\n\n    Tab[0] = 0;\n    Tab[1] = 0;\n    Tab[2] = 0;\n    Tab[3] = 0;\n    Tab[4] = 0;\n    Tab[5] = 0x5555;\n    Tab[6] = 0x6666;\n    Tab[7] = 0x7777;\n    Tab[8] = 0x8888;\n    Tab[9] = 0x9999;\n    Tab[10]= 0xffff;\n    Tab[11]= 0xffff;\n    Tab[12]= 0xffff;\n    Tab[13]= 0xffff;\n    Tab[14]= 0xffff;\n    Tab[15]= 0xffff;\n\n    p = cmsBuildTabulatedToneCurve16(DbgThread(), 16, Tab);\n    g = cmsReverseToneCurve(p);\n\n    // Now let's check some points\n    if (!CheckFToneCurvePoint(g, 0x5555, 0x5555)) return 0;\n    if (!CheckFToneCurvePoint(g, 0x7777, 0x7777)) return 0;\n\n    // First point for zero\n    if (!CheckFToneCurvePoint(g, 0x0000, 0x4444)) return 0;\n\n    // Last point\n    if (!CheckFToneCurvePoint(g, 0xFFFF, 0xFFFF)) return 0;\n\n    cmsFreeToneCurve(p);\n    cmsFreeToneCurve(g);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              2684,
              0
            ],
            [
              2724,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckReverseDegenerated",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsToneCurve* Build_sRGBGamma(void)\n{\n    cmsFloat64Number Parameters[5];\n\n    Parameters[0] = 2.4;\n    Parameters[1] = 1. / 1.055;\n    Parameters[2] = 0.055 / 1.055;\n    Parameters[3] = 1. / 12.92;\n    Parameters[4] = 0.04045;    // d\n\n    return cmsBuildParametricToneCurve(DbgThread(), 4, Parameters);\n}",
          "fn_code_pos": [
            [
              2728,
              0
            ],
            [
              2740,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Build_sRGBGamma",
            "parameters": {},
            "return_type": "cmsToneCurve"
          }
        },
        {
          "fn_code": "static\ncmsToneCurve* CombineGammaFloat(cmsToneCurve* g1, cmsToneCurve* g2)\n{\n    cmsUInt16Number Tab[256];\n    cmsFloat32Number f;\n    cmsInt32Number i;\n\n    for (i=0; i < 256; i++) {\n\n        f = (cmsFloat32Number) i / 255.0F;\n        f = cmsEvalToneCurveFloat(g2, cmsEvalToneCurveFloat(g1, f));\n\n        Tab[i] = (cmsUInt16Number) floor(f * 65535.0 + 0.5);\n    }\n\n    return  cmsBuildTabulatedToneCurve16(DbgThread(), 256, Tab);\n}",
          "fn_code_pos": [
            [
              2745,
              0
            ],
            [
              2761,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CombineGammaFloat",
            "parameters": {
              "g1": "cmsToneCurve",
              "g2": "cmsToneCurve"
            },
            "return_type": "cmsToneCurve"
          }
        },
        {
          "fn_code": "static\ncmsToneCurve* CombineGamma16(cmsToneCurve* g1, cmsToneCurve* g2)\n{\n    cmsUInt16Number Tab[256];\n\n    cmsInt32Number i;\n\n    for (i=0; i < 256; i++) {\n\n        cmsUInt16Number wValIn;\n\n        wValIn = _cmsQuantizeVal(i, 256);\n        Tab[i] = cmsEvalToneCurve16(g2, cmsEvalToneCurve16(g1, wValIn));\n    }\n\n    return  cmsBuildTabulatedToneCurve16(DbgThread(), 256, Tab);\n}",
          "fn_code_pos": [
            [
              2764,
              0
            ],
            [
              2780,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CombineGamma16",
            "parameters": {
              "g1": "cmsToneCurve",
              "g2": "cmsToneCurve"
            },
            "return_type": "cmsToneCurve"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckJointFloatCurves_sRGB(void)\n{\n    cmsToneCurve *Forward, *Reverse, *Result;\n    cmsBool  rc;\n\n    Forward = Build_sRGBGamma();\n    Reverse = cmsReverseToneCurve(Forward);\n    Result = CombineGammaFloat(Forward, Reverse);\n    cmsFreeToneCurve(Forward); cmsFreeToneCurve(Reverse);\n\n    rc = cmsIsToneCurveLinear(Result);\n    cmsFreeToneCurve(Result);\n\n    return rc;\n}",
          "fn_code_pos": [
            [
              2782,
              0
            ],
            [
              2797,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckJointFloatCurves_sRGB",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckJoint16Curves_sRGB(void)\n{\n    cmsToneCurve *Forward, *Reverse, *Result;\n    cmsBool  rc;\n\n    Forward = Build_sRGBGamma();\n    Reverse = cmsReverseToneCurve(Forward);\n    Result = CombineGamma16(Forward, Reverse);\n    cmsFreeToneCurve(Forward); cmsFreeToneCurve(Reverse);\n\n    rc = cmsIsToneCurveLinear(Result);\n    cmsFreeToneCurve(Result);\n\n    return rc;\n}",
          "fn_code_pos": [
            [
              2799,
              0
            ],
            [
              2814,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckJoint16Curves_sRGB",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckJointCurvesSShaped(void)\n{\n    cmsFloat64Number p = 3.2;\n    cmsToneCurve *Forward, *Reverse, *Result;\n    cmsInt32Number rc;\n\n    Forward = cmsBuildParametricToneCurve(DbgThread(), 108, &p);\n    Reverse = cmsReverseToneCurve(Forward);\n    Result = cmsJoinToneCurve(DbgThread(), Forward, Forward, 4096);\n\n    cmsFreeToneCurve(Forward);\n    cmsFreeToneCurve(Reverse);\n\n    rc = cmsIsToneCurveLinear(Result);\n    cmsFreeToneCurve(Result);\n    return rc;\n}",
          "fn_code_pos": [
            [
              2818,
              0
            ],
            [
              2835,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckJointCurvesSShaped",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat32Number Gamma(cmsFloat32Number x, const cmsFloat64Number Params[])\n{\n    return (cmsFloat32Number) pow(x, Params[0]);\n}",
          "fn_code_pos": [
            [
              2841,
              0
            ],
            [
              2845,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Gamma",
            "parameters": {
              "x": "cmsFloat32Number",
              "Params": "cmsFloat64Number"
            },
            "return_type": "cmsFloat32Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat32Number CIE122(cmsFloat32Number x, const cmsFloat64Number Params[])\n\n{\n    cmsFloat64Number e, Val;\n\n    if (x >= -Params[2] / Params[1]) {\n\n        e = Params[1]*x + Params[2];\n\n        if (e > 0)\n            Val = pow(e, Params[0]);\n        else\n            Val = 0;\n    }\n    else\n        Val = 0;\n\n    return (cmsFloat32Number) Val;\n}",
          "fn_code_pos": [
            [
              2847,
              0
            ],
            [
              2866,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CIE122",
            "parameters": {
              "x": "cmsFloat32Number",
              "Params": "cmsFloat64Number"
            },
            "return_type": "cmsFloat32Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat32Number IEC61966_3(cmsFloat32Number x, const cmsFloat64Number Params[])\n{\n    cmsFloat64Number e, Val;\n\n    if (x >= -Params[2] / Params[1]) {\n\n        e = Params[1]*x + Params[2];\n\n        if (e > 0)\n            Val = pow(e, Params[0]) + Params[3];\n        else\n            Val = 0;\n    }\n    else\n        Val = Params[3];\n\n    return (cmsFloat32Number) Val;\n}",
          "fn_code_pos": [
            [
              2868,
              0
            ],
            [
              2886,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IEC61966_3",
            "parameters": {
              "x": "cmsFloat32Number",
              "Params": "cmsFloat64Number"
            },
            "return_type": "cmsFloat32Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat32Number IEC61966_21(cmsFloat32Number x, const cmsFloat64Number Params[])\n{\n    cmsFloat64Number e, Val;\n\n    if (x >= Params[4]) {\n\n        e = Params[1]*x + Params[2];\n\n        if (e > 0)\n            Val = pow(e, Params[0]);\n        else\n            Val = 0;\n    }\n    else\n        Val = x * Params[3];\n\n    return (cmsFloat32Number) Val;\n}",
          "fn_code_pos": [
            [
              2888,
              0
            ],
            [
              2906,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IEC61966_21",
            "parameters": {
              "x": "cmsFloat32Number",
              "Params": "cmsFloat64Number"
            },
            "return_type": "cmsFloat32Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat32Number param_5(cmsFloat32Number x, const cmsFloat64Number Params[])\n{\n    cmsFloat64Number e, Val;\n    // Y = (aX + b)^Gamma + e | X >= d\n    // Y = cX + f             | else\n    if (x >= Params[4]) {\n\n        e = Params[1]*x + Params[2];\n        if (e > 0)\n            Val = pow(e, Params[0]) + Params[5];\n        else\n            Val = 0;\n    }\n    else\n        Val = x*Params[3] + Params[6];\n\n    return (cmsFloat32Number) Val;\n}",
          "fn_code_pos": [
            [
              2908,
              0
            ],
            [
              2926,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "param_5",
            "parameters": {
              "x": "cmsFloat32Number",
              "Params": "cmsFloat64Number"
            },
            "return_type": "cmsFloat32Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat32Number param_6(cmsFloat32Number x, const cmsFloat64Number Params[])\n{\n    cmsFloat64Number e, Val;\n\n    e = Params[1]*x + Params[2];\n    if (e > 0)\n        Val = pow(e, Params[0]) + Params[3];\n    else\n        Val = 0;\n\n    return (cmsFloat32Number) Val;\n}",
          "fn_code_pos": [
            [
              2928,
              0
            ],
            [
              2940,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "param_6",
            "parameters": {
              "x": "cmsFloat32Number",
              "Params": "cmsFloat64Number"
            },
            "return_type": "cmsFloat32Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat32Number param_7(cmsFloat32Number x, const cmsFloat64Number Params[])\n{\n    cmsFloat64Number Val;\n\n\n    Val = Params[1]*log10(Params[2] * pow(x, Params[0]) + Params[3]) + Params[4];\n\n    return (cmsFloat32Number) Val;\n}",
          "fn_code_pos": [
            [
              2942,
              0
            ],
            [
              2951,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "param_7",
            "parameters": {
              "x": "cmsFloat32Number",
              "Params": "cmsFloat64Number"
            },
            "return_type": "cmsFloat32Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat32Number param_8(cmsFloat32Number x, const cmsFloat64Number Params[])\n{\n    cmsFloat64Number Val;\n\n    Val = (Params[0] * pow(Params[1], Params[2] * x + Params[3]) + Params[4]);\n\n    return (cmsFloat32Number) Val;\n}",
          "fn_code_pos": [
            [
              2954,
              0
            ],
            [
              2962,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "param_8",
            "parameters": {
              "x": "cmsFloat32Number",
              "Params": "cmsFloat64Number"
            },
            "return_type": "cmsFloat32Number"
          }
        },
        {
          "fn_code": "static\ncmsFloat32Number sigmoidal(cmsFloat32Number x, const cmsFloat64Number Params[])\n{\n    cmsFloat64Number Val;\n\n    Val = pow(1.0 - pow(1 - x, 1/Params[0]), 1/Params[0]);\n\n    return (cmsFloat32Number) Val;\n}",
          "fn_code_pos": [
            [
              2965,
              0
            ],
            [
              2973,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sigmoidal",
            "parameters": {
              "x": "cmsFloat32Number",
              "Params": "cmsFloat64Number"
            },
            "return_type": "cmsFloat32Number"
          }
        },
        {
          "fn_code": "static\ncmsBool CheckSingleParametric(const char* Name, dblfnptr fn, cmsInt32Number Type, const cmsFloat64Number Params[])\n{\n    cmsInt32Number i;\n    cmsToneCurve* tc;\n    cmsToneCurve* tc_1;\n    char InverseText[256];\n\n    tc = cmsBuildParametricToneCurve(DbgThread(), Type, Params);\n    tc_1 = cmsBuildParametricToneCurve(DbgThread(), -Type, Params);\n\n    for (i=0; i <= 1000; i++) {\n\n        cmsFloat32Number x = (cmsFloat32Number) i / 1000;\n        cmsFloat32Number y_fn, y_param, x_param, y_param2;\n\n        y_fn = fn(x, Params);\n        y_param = cmsEvalToneCurveFloat(tc, x);\n        x_param = cmsEvalToneCurveFloat(tc_1, y_param);\n\n        y_param2 = fn(x_param, Params);\n\n        if (!IsGoodVal(Name, y_fn, y_param, FIXED_PRECISION_15_16))\n            goto Error;\n\n        sprintf(InverseText, \"Inverse %s\", Name);\n        if (!IsGoodVal(InverseText, y_fn, y_param2, FIXED_PRECISION_15_16))\n            goto Error;\n    }\n\n    cmsFreeToneCurve(tc);\n    cmsFreeToneCurve(tc_1);\n    return TRUE;\n\nError:\n    cmsFreeToneCurve(tc);\n    cmsFreeToneCurve(tc_1);\n    return FALSE;\n}",
          "fn_code_pos": [
            [
              2976,
              0
            ],
            [
              3014,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckSingleParametric",
            "parameters": {
              "Name": "char",
              "fn": "dblfnptr",
              "Type": "cmsInt32Number",
              "Params": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckParametricToneCurves(void)\n{\n    cmsFloat64Number Params[10];\n\n     // 1) X = Y ^ Gamma\n\n     Params[0] = 2.2;\n\n     if (!CheckSingleParametric(\"Gamma\", Gamma, 1, Params)) return 0;\n\n     // 2) CIE 122-1966\n     // Y = (aX + b)^Gamma  | X >= -b/a\n     // Y = 0               | else\n\n     Params[0] = 2.2;\n     Params[1] = 1.5;\n     Params[2] = -0.5;\n\n     if (!CheckSingleParametric(\"CIE122-1966\", CIE122, 2, Params)) return 0;\n\n     // 3) IEC 61966-3\n     // Y = (aX + b)^Gamma | X <= -b/a\n     // Y = c              | else\n\n     Params[0] = 2.2;\n     Params[1] = 1.5;\n     Params[2] = -0.5;\n     Params[3] = 0.3;\n\n\n     if (!CheckSingleParametric(\"IEC 61966-3\", IEC61966_3, 3, Params)) return 0;\n\n     // 4) IEC 61966-2.1 (sRGB)\n     // Y = (aX + b)^Gamma | X >= d\n     // Y = cX             | X < d\n\n     Params[0] = 2.4;\n     Params[1] = 1. / 1.055;\n     Params[2] = 0.055 / 1.055;\n     Params[3] = 1. / 12.92;\n     Params[4] = 0.04045;\n\n     if (!CheckSingleParametric(\"IEC 61966-2.1\", IEC61966_21, 4, Params)) return 0;\n\n\n     // 5) Y = (aX + b)^Gamma + e | X >= d\n     // Y = cX + f             | else\n\n     Params[0] = 2.2;\n     Params[1] = 0.7;\n     Params[2] = 0.2;\n     Params[3] = 0.3;\n     Params[4] = 0.1;\n     Params[5] = 0.5;\n     Params[6] = 0.2;\n\n     if (!CheckSingleParametric(\"param_5\", param_5, 5, Params)) return 0;\n\n     // 6) Y = (aX + b) ^ Gamma + c\n\n     Params[0] = 2.2;\n     Params[1] = 0.7;\n     Params[2] = 0.2;\n     Params[3] = 0.3;\n\n     if (!CheckSingleParametric(\"param_6\", param_6, 6, Params)) return 0;\n\n     // 7) Y = a * log (b * X^Gamma + c) + d\n\n     Params[0] = 2.2;\n     Params[1] = 0.9;\n     Params[2] = 0.9;\n     Params[3] = 0.02;\n     Params[4] = 0.1;\n\n     if (!CheckSingleParametric(\"param_7\", param_7, 7, Params)) return 0;\n\n     // 8) Y = a * b ^ (c*X+d) + e\n\n     Params[0] = 0.9;\n     Params[1] = 0.9;\n     Params[2] = 1.02;\n     Params[3] = 0.1;\n     Params[4] = 0.2;\n\n     if (!CheckSingleParametric(\"param_8\", param_8, 8, Params)) return 0;\n\n     // 108: S-Shaped: (1 - (1-x)^1/g)^1/g\n\n     Params[0] = 1.9;\n     if (!CheckSingleParametric(\"sigmoidal\", sigmoidal, 108, Params)) return 0;\n\n     // All OK\n\n     return 1;\n}",
          "fn_code_pos": [
            [
              3017,
              0
            ],
            [
              3113,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckParametricToneCurves",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckLUTcreation(void)\n{\n    cmsPipeline* lut;\n    cmsPipeline* lut2;\n    cmsInt32Number n1, n2;\n\n    lut = cmsPipelineAlloc(DbgThread(), 1, 1);\n    n1 = cmsPipelineStageCount(lut);\n    lut2 = cmsPipelineDup(lut);\n    n2 = cmsPipelineStageCount(lut2);\n\n    cmsPipelineFree(lut);\n    cmsPipelineFree(lut2);\n\n    return (n1 == 0) && (n2 == 0);\n}",
          "fn_code_pos": [
            [
              3117,
              0
            ],
            [
              3133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckLUTcreation",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid AddIdentityMatrix(cmsPipeline* lut)\n{\n    const cmsFloat64Number Identity[] = { 1, 0, 0,\n                          0, 1, 0,\n                          0, 0, 1,\n                          0, 0, 0 };\n\n    cmsPipelineInsertStage(lut, cmsAT_END, cmsStageAllocMatrix(DbgThread(), 3, 3, Identity, NULL));\n}",
          "fn_code_pos": [
            [
              3136,
              0
            ],
            [
              3145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddIdentityMatrix",
            "parameters": {
              "lut": "cmsPipeline"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid AddIdentityCLUTfloat(cmsPipeline* lut)\n{\n    const cmsFloat32Number  Table[] = {\n\n        0,    0,    0,\n        0,    0,    1.0,\n\n        0,    1.0,    0,\n        0,    1.0,    1.0,\n\n        1.0,    0,    0,\n        1.0,    0,    1.0,\n\n        1.0,    1.0,    0,\n        1.0,    1.0,    1.0\n    };\n\n    cmsPipelineInsertStage(lut, cmsAT_END, cmsStageAllocCLutFloat(DbgThread(), 2, 3, 3, Table));\n}",
          "fn_code_pos": [
            [
              3148,
              0
            ],
            [
              3167,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddIdentityCLUTfloat",
            "parameters": {
              "lut": "cmsPipeline"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid AddIdentityCLUT16(cmsPipeline* lut)\n{\n    const cmsUInt16Number Table[] = {\n\n        0,    0,    0,\n        0,    0,    0xffff,\n\n        0,    0xffff,    0,\n        0,    0xffff,    0xffff,\n\n        0xffff,    0,    0,\n        0xffff,    0,    0xffff,\n\n        0xffff,    0xffff,    0,\n        0xffff,    0xffff,    0xffff\n    };\n\n\n    cmsPipelineInsertStage(lut, cmsAT_END, cmsStageAllocCLut16bit(DbgThread(), 2, 3, 3, Table));\n}",
          "fn_code_pos": [
            [
              3170,
              0
            ],
            [
              3190,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddIdentityCLUT16",
            "parameters": {
              "lut": "cmsPipeline"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid Add3GammaCurves(cmsPipeline* lut, cmsFloat64Number Curve)\n{\n    cmsToneCurve* id = cmsBuildGamma(DbgThread(), Curve);\n    cmsToneCurve* id3[3];\n\n    id3[0] = id;\n    id3[1] = id;\n    id3[2] = id;\n\n    cmsPipelineInsertStage(lut, cmsAT_END, cmsStageAllocToneCurves(DbgThread(), 3, id3));\n\n    cmsFreeToneCurve(id);\n}",
          "fn_code_pos": [
            [
              3195,
              0
            ],
            [
              3208,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Add3GammaCurves",
            "parameters": {
              "lut": "cmsPipeline",
              "Curve": "cmsFloat64Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckFloatLUT(cmsPipeline* lut)\n{\n    cmsInt32Number n1, i, j;\n    cmsFloat32Number Inf[3], Outf[3];\n\n    n1=0;\n\n    for (j=0; j < 65535; j++) {\n\n        cmsInt32Number af[3];\n\n        Inf[0] = Inf[1] = Inf[2] = (cmsFloat32Number) j / 65535.0F;\n        cmsPipelineEvalFloat(Inf, Outf, lut);\n\n        af[0] = (cmsInt32Number) floor(Outf[0]*65535.0 + 0.5);\n        af[1] = (cmsInt32Number) floor(Outf[1]*65535.0 + 0.5);\n        af[2] = (cmsInt32Number) floor(Outf[2]*65535.0 + 0.5);\n\n        for (i=0; i < 3; i++) {\n\n            if (af[i] != j) {\n                n1++;\n            }\n        }\n\n    }\n\n    return (n1 == 0);\n}",
          "fn_code_pos": [
            [
              3211,
              0
            ],
            [
              3240,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckFloatLUT",
            "parameters": {
              "lut": "cmsPipeline"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check16LUT(cmsPipeline* lut)\n{\n    cmsInt32Number n2, i, j;\n    cmsUInt16Number Inw[3], Outw[3];\n\n    n2=0;\n\n    for (j=0; j < 65535; j++) {\n\n        cmsInt32Number aw[3];\n\n        Inw[0] = Inw[1] = Inw[2] = (cmsUInt16Number) j;\n        cmsPipelineEval16(Inw, Outw, lut);\n        aw[0] = Outw[0];\n        aw[1] = Outw[1];\n        aw[2] = Outw[2];\n\n        for (i=0; i < 3; i++) {\n\n        if (aw[i] != j) {\n            n2++;\n        }\n        }\n\n    }\n\n    return (n2 == 0);\n}",
          "fn_code_pos": [
            [
              3243,
              0
            ],
            [
              3271,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check16LUT",
            "parameters": {
              "lut": "cmsPipeline"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckStagesLUT(cmsPipeline* lut, cmsInt32Number ExpectedStages)\n{\n\n    cmsInt32Number nInpChans, nOutpChans, nStages;\n\n    nInpChans  = cmsPipelineInputChannels(lut);\n    nOutpChans = cmsPipelineOutputChannels(lut);\n    nStages    = cmsPipelineStageCount(lut);\n\n    return (nInpChans == 3) && (nOutpChans == 3) && (nStages == ExpectedStages);\n}",
          "fn_code_pos": [
            [
              3275,
              0
            ],
            [
              3286,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckStagesLUT",
            "parameters": {
              "lut": "cmsPipeline",
              "ExpectedStages": "cmsInt32Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckFullLUT(cmsPipeline* lut, cmsInt32Number ExpectedStages)\n{\n    cmsInt32Number rc = CheckStagesLUT(lut, ExpectedStages) && Check16LUT(lut) && CheckFloatLUT(lut);\n\n    cmsPipelineFree(lut);\n    return rc;\n}",
          "fn_code_pos": [
            [
              3289,
              0
            ],
            [
              3296,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckFullLUT",
            "parameters": {
              "lut": "cmsPipeline",
              "ExpectedStages": "cmsInt32Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check1StageLUT(void)\n{\n    cmsPipeline* lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n\n    AddIdentityMatrix(lut);\n    return CheckFullLUT(lut, 1);\n}",
          "fn_code_pos": [
            [
              3299,
              0
            ],
            [
              3306,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check1StageLUT",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check2StageLUT(void)\n{\n    cmsPipeline* lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n\n    AddIdentityMatrix(lut);\n    AddIdentityCLUTfloat(lut);\n\n    return CheckFullLUT(lut, 2);\n}",
          "fn_code_pos": [
            [
              3310,
              0
            ],
            [
              3319,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check2StageLUT",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check2Stage16LUT(void)\n{\n    cmsPipeline* lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n\n    AddIdentityMatrix(lut);\n    AddIdentityCLUT16(lut);\n\n    return CheckFullLUT(lut, 2);\n}",
          "fn_code_pos": [
            [
              3321,
              0
            ],
            [
              3330,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check2Stage16LUT",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check3StageLUT(void)\n{\n    cmsPipeline* lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n\n    AddIdentityMatrix(lut);\n    AddIdentityCLUTfloat(lut);\n    Add3GammaCurves(lut, 1.0);\n\n    return CheckFullLUT(lut, 3);\n}",
          "fn_code_pos": [
            [
              3334,
              0
            ],
            [
              3344,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check3StageLUT",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check3Stage16LUT(void)\n{\n    cmsPipeline* lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n\n    AddIdentityMatrix(lut);\n    AddIdentityCLUT16(lut);\n    Add3GammaCurves(lut, 1.0);\n\n    return CheckFullLUT(lut, 3);\n}",
          "fn_code_pos": [
            [
              3346,
              0
            ],
            [
              3356,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check3Stage16LUT",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check4StageLUT(void)\n{\n    cmsPipeline* lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n\n    AddIdentityMatrix(lut);\n    AddIdentityCLUTfloat(lut);\n    Add3GammaCurves(lut, 1.0);\n    AddIdentityMatrix(lut);\n\n    return CheckFullLUT(lut, 4);\n}",
          "fn_code_pos": [
            [
              3360,
              0
            ],
            [
              3371,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check4StageLUT",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check4Stage16LUT(void)\n{\n    cmsPipeline* lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n\n    AddIdentityMatrix(lut);\n    AddIdentityCLUT16(lut);\n    Add3GammaCurves(lut, 1.0);\n    AddIdentityMatrix(lut);\n\n    return CheckFullLUT(lut, 4);\n}",
          "fn_code_pos": [
            [
              3373,
              0
            ],
            [
              3384,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check4Stage16LUT",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check5StageLUT(void)\n{\n    cmsPipeline* lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n\n    AddIdentityMatrix(lut);\n    AddIdentityCLUTfloat(lut);\n    Add3GammaCurves(lut, 1.0);\n    AddIdentityMatrix(lut);\n    Add3GammaCurves(lut, 1.0);\n\n    return CheckFullLUT(lut, 5);\n}",
          "fn_code_pos": [
            [
              3386,
              0
            ],
            [
              3398,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check5StageLUT",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check5Stage16LUT(void)\n{\n    cmsPipeline* lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n\n    AddIdentityMatrix(lut);\n    AddIdentityCLUT16(lut);\n    Add3GammaCurves(lut, 1.0);\n    AddIdentityMatrix(lut);\n    Add3GammaCurves(lut, 1.0);\n\n    return CheckFullLUT(lut, 5);\n}",
          "fn_code_pos": [
            [
              3401,
              0
            ],
            [
              3413,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check5Stage16LUT",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check6StageLUT(void)\n{\n    cmsPipeline* lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n\n    AddIdentityMatrix(lut);\n    Add3GammaCurves(lut, 1.0);\n    AddIdentityCLUTfloat(lut);\n    Add3GammaCurves(lut, 1.0);\n    AddIdentityMatrix(lut);\n    Add3GammaCurves(lut, 1.0);\n\n    return CheckFullLUT(lut, 6);\n}",
          "fn_code_pos": [
            [
              3415,
              0
            ],
            [
              3428,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check6StageLUT",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check6Stage16LUT(void)\n{\n    cmsPipeline* lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n\n    AddIdentityMatrix(lut);\n    Add3GammaCurves(lut, 1.0);\n    AddIdentityCLUT16(lut);\n    Add3GammaCurves(lut, 1.0);\n    AddIdentityMatrix(lut);\n    Add3GammaCurves(lut, 1.0);\n\n    return CheckFullLUT(lut, 6);\n}",
          "fn_code_pos": [
            [
              3430,
              0
            ],
            [
              3443,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check6Stage16LUT",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckLab2LabLUT(void)\n{\n    cmsPipeline* lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n    cmsInt32Number rc;\n\n    cmsPipelineInsertStage(lut, cmsAT_END, _cmsStageAllocLab2XYZ(DbgThread()));\n    cmsPipelineInsertStage(lut, cmsAT_END, _cmsStageAllocXYZ2Lab(DbgThread()));\n\n    rc = CheckFloatLUT(lut) && CheckStagesLUT(lut, 2);\n\n    cmsPipelineFree(lut);\n\n    return rc;\n}",
          "fn_code_pos": [
            [
              3446,
              0
            ],
            [
              3460,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckLab2LabLUT",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckXYZ2XYZLUT(void)\n{\n    cmsPipeline* lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n    cmsInt32Number rc;\n\n    cmsPipelineInsertStage(lut, cmsAT_END, _cmsStageAllocXYZ2Lab(DbgThread()));\n    cmsPipelineInsertStage(lut, cmsAT_END, _cmsStageAllocLab2XYZ(DbgThread()));\n\n    rc = CheckFloatLUT(lut) && CheckStagesLUT(lut, 2);\n\n    cmsPipelineFree(lut);\n\n    return rc;\n}",
          "fn_code_pos": [
            [
              3463,
              0
            ],
            [
              3477,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckXYZ2XYZLUT",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckLab2LabMatLUT(void)\n{\n    cmsPipeline* lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n    cmsInt32Number rc;\n\n    cmsPipelineInsertStage(lut, cmsAT_END, _cmsStageAllocLab2XYZ(DbgThread()));\n    AddIdentityMatrix(lut);\n    cmsPipelineInsertStage(lut, cmsAT_END, _cmsStageAllocXYZ2Lab(DbgThread()));\n\n    rc = CheckFloatLUT(lut) && CheckStagesLUT(lut, 3);\n\n    cmsPipelineFree(lut);\n\n    return rc;\n}",
          "fn_code_pos": [
            [
              3481,
              0
            ],
            [
              3496,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckLab2LabMatLUT",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckNamedColorLUT(void)\n{\n    cmsPipeline* lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n    cmsNAMEDCOLORLIST* nc;\n    cmsInt32Number i,j, rc = 1, n2;\n    cmsUInt16Number PCS[3];\n    cmsUInt16Number Colorant[cmsMAXCHANNELS];\n    char Name[255];\n    cmsUInt16Number Inw[3], Outw[3];\n\n\n\n    nc = cmsAllocNamedColorList(DbgThread(), 256, 3, \"pre\", \"post\");\n    if (nc == NULL) return 0;\n\n    for (i=0; i < 256; i++) {\n\n        PCS[0] = PCS[1] = PCS[2] = (cmsUInt16Number) i;\n        Colorant[0] = Colorant[1] = Colorant[2] = Colorant[3] = (cmsUInt16Number) i;\n\n        sprintf(Name, \"#%d\", i);\n        if (!cmsAppendNamedColor(nc, Name, PCS, Colorant)) { rc = 0; break; }\n    }\n\n    cmsPipelineInsertStage(lut, cmsAT_END, _cmsStageAllocNamedColor(nc, FALSE));\n\n    cmsFreeNamedColorList(nc);\n    if (rc == 0) return 0;\n\n    n2=0;\n\n    for (j=0; j < 256; j++) {\n\n        Inw[0] = (cmsUInt16Number) j;\n\n        cmsPipelineEval16(Inw, Outw, lut);\n        for (i=0; i < 3; i++) {\n\n            if (Outw[i] != j) {\n                n2++;\n            }\n        }\n\n    }\n\n    cmsPipelineFree(lut);\n    return (n2 == 0);\n}",
          "fn_code_pos": [
            [
              3498,
              0
            ],
            [
              3546,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckNamedColorLUT",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckMLU(void)\n{\n    cmsMLU* mlu, *mlu2, *mlu3;\n    char Buffer[256], Buffer2[256];\n    cmsInt32Number rc = 1;\n    cmsInt32Number i;\n    cmsHPROFILE h= NULL;\n\n    // Allocate a MLU structure, no preferred size\n    mlu = cmsMLUalloc(DbgThread(), 0);\n\n    // Add some localizations\n    cmsMLUsetWide(mlu, \"en\", \"US\", L\"Hello, world\");\n    cmsMLUsetWide(mlu, \"es\", \"ES\", L\"Hola, mundo\");\n    cmsMLUsetWide(mlu, \"fr\", \"FR\", L\"Bonjour, le monde\");\n    cmsMLUsetWide(mlu, \"ca\", \"CA\", L\"Hola, mon\");\n\n\n    // Check the returned string for each language\n\n    cmsMLUgetASCII(mlu, \"en\", \"US\", Buffer, 256);\n    if (strcmp(Buffer, \"Hello, world\") != 0) rc = 0;\n\n\n    cmsMLUgetASCII(mlu, \"es\", \"ES\", Buffer, 256);\n    if (strcmp(Buffer, \"Hola, mundo\") != 0) rc = 0;\n\n\n    cmsMLUgetASCII(mlu, \"fr\", \"FR\", Buffer, 256);\n    if (strcmp(Buffer, \"Bonjour, le monde\") != 0) rc = 0;\n\n\n    cmsMLUgetASCII(mlu, \"ca\", \"CA\", Buffer, 256);\n    if (strcmp(Buffer, \"Hola, mon\") != 0) rc = 0;\n\n    if (rc == 0)\n        Fail(\"Unexpected string '%s'\", Buffer);\n\n    // So far, so good.\n    cmsMLUfree(mlu);\n\n    // Now for performance, allocate an empty struct\n    mlu = cmsMLUalloc(DbgThread(), 0);\n\n    // Fill it with several thousands of different languages\n    for (i=0; i < 4096; i++) {\n\n        char Lang[3];\n\n        Lang[0] = (char) (i % 255);\n        Lang[1] = (char) (i / 255);\n        Lang[2] = 0;\n\n        sprintf(Buffer, \"String #%i\", i);\n        cmsMLUsetASCII(mlu, Lang, Lang, Buffer);\n    }\n\n    // Duplicate it\n    mlu2 = cmsMLUdup(mlu);\n\n    // Get rid of original\n    cmsMLUfree(mlu);\n\n    // Check all is still in place\n    for (i=0; i < 4096; i++) {\n\n        char Lang[3];\n\n        Lang[0] = (char)(i % 255);\n        Lang[1] = (char)(i / 255);\n        Lang[2] = 0;\n\n        cmsMLUgetASCII(mlu2, Lang, Lang, Buffer2, 256);\n        sprintf(Buffer, \"String #%i\", i);\n\n        if (strcmp(Buffer, Buffer2) != 0) { rc = 0; break; }\n    }\n\n    if (rc == 0)\n        Fail(\"Unexpected string '%s'\", Buffer2);\n\n    // Check profile IO\n\n    h = cmsOpenProfileFromFileTHR(DbgThread(), \"mlucheck.icc\", \"w\");\n\n    cmsSetProfileVersion(h, 4.3);\n\n    cmsWriteTag(h, cmsSigProfileDescriptionTag, mlu2);\n    cmsCloseProfile(h);\n    cmsMLUfree(mlu2);\n\n\n    h = cmsOpenProfileFromFileTHR(DbgThread(), \"mlucheck.icc\", \"r\");\n\n    mlu3 = (cmsMLU *) cmsReadTag(h, cmsSigProfileDescriptionTag); \n    if (mlu3 == NULL) { Fail(\"Profile didn't get the MLU\\n\"); rc = 0; goto Error; }\n\n    // Check all is still in place\n    for (i=0; i < 4096; i++) {\n\n        char Lang[3];\n\n        Lang[0] = (char) (i % 255);\n        Lang[1] = (char) (i / 255);\n        Lang[2] = 0;\n\n        cmsMLUgetASCII(mlu3, Lang, Lang, Buffer2, 256);\n        sprintf(Buffer, \"String #%i\", i);\n\n        if (strcmp(Buffer, Buffer2) != 0) { rc = 0; break; }\n    }\n\n    if (rc == 0) Fail(\"Unexpected string '%s'\", Buffer2);\n\nError:\n\n    if (h != NULL) cmsCloseProfile(h);\n    remove(\"mlucheck.icc\");\n\n    return rc;\n}",
          "fn_code_pos": [
            [
              3554,
              0
            ],
            [
              3675,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMLU",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckMLU_UTF8(void)\n{\n    cmsMLU* mlu;\n    char Buffer[256];\n    cmsInt32Number rc = 1;\n        \n    mlu = cmsMLUalloc(DbgThread(), 0);\n    \n    cmsMLUsetWide(mlu, \"en\", \"US\", L\"\\x3b2\\x14b\");\n\n    cmsMLUgetUTF8(mlu, \"en\", \"US\", Buffer, 256);\n    if (strcmp(Buffer, \"\\xce\\xb2\\xc5\\x8b\") != 0) rc = 0;\n\n    if (rc == 0)\n        Fail(\"Unexpected string '%s'\", Buffer);\n\n    cmsMLUfree(mlu);\n    return rc;\n}",
          "fn_code_pos": [
            [
              3679,
              0
            ],
            [
              3698,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMLU_UTF8",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckNamedColorList(void)\n{\n    cmsNAMEDCOLORLIST* nc = NULL, *nc2;\n    cmsInt32Number i, j, rc=1;\n    char Name[cmsMAX_PATH];\n    cmsUInt16Number PCS[3];\n    cmsUInt16Number Colorant[cmsMAXCHANNELS];\n    char CheckName[cmsMAX_PATH];\n    cmsUInt16Number CheckPCS[3];\n    cmsUInt16Number CheckColorant[cmsMAXCHANNELS];\n    cmsHPROFILE h;\n\n    nc = cmsAllocNamedColorList(DbgThread(), 0, 4, \"prefix\", \"suffix\");\n    if (nc == NULL) return 0;\n\n    for (i=0; i < 4096; i++) {\n\n\n        PCS[0] = PCS[1] = PCS[2] = (cmsUInt16Number) i;\n        Colorant[0] = Colorant[1] = Colorant[2] = Colorant[3] = (cmsUInt16Number) (4096 - i);\n\n        sprintf(Name, \"#%d\", i);\n        if (!cmsAppendNamedColor(nc, Name, PCS, Colorant)) { rc = 0; break; }\n    }\n\n    for (i=0; i < 4096; i++) {\n\n        CheckPCS[0] = CheckPCS[1] = CheckPCS[2] = (cmsUInt16Number) i;\n        CheckColorant[0] = CheckColorant[1] = CheckColorant[2] = CheckColorant[3] = (cmsUInt16Number) (4096 - i);\n\n        sprintf(CheckName, \"#%d\", i);\n        if (!cmsNamedColorInfo(nc, i, Name, NULL, NULL, PCS, Colorant)) { rc = 0; goto Error; }\n\n\n        for (j=0; j < 3; j++) {\n            if (CheckPCS[j] != PCS[j]) { rc = 0; Fail(\"Invalid PCS\"); goto Error; }\n        }\n\n        for (j=0; j < 4; j++) {\n            if (CheckColorant[j] != Colorant[j]) { rc = 0; Fail(\"Invalid Colorant\"); goto Error; };\n        }\n\n        if (strcmp(Name, CheckName) != 0) {rc = 0; Fail(\"Invalid Name\"); goto Error; };\n    }\n\n    h = cmsOpenProfileFromFileTHR(DbgThread(), \"namedcol.icc\", \"w\");\n    if (h == NULL) return 0;\n    if (!cmsWriteTag(h, cmsSigNamedColor2Tag, nc)) return 0;\n    cmsCloseProfile(h);\n    cmsFreeNamedColorList(nc);\n    nc = NULL;\n\n    h = cmsOpenProfileFromFileTHR(DbgThread(), \"namedcol.icc\", \"r\");\n    nc2 = (cmsNAMEDCOLORLIST *) cmsReadTag(h, cmsSigNamedColor2Tag); \n\n    if (cmsNamedColorCount(nc2) != 4096) { rc = 0; Fail(\"Invalid count\"); goto Error; }\n\n    i = cmsNamedColorIndex(nc2, \"#123\");\n    if (i != 123) { rc = 0; Fail(\"Invalid index\"); goto Error; }\n\n\n    for (i=0; i < 4096; i++) {\n\n        CheckPCS[0] = CheckPCS[1] = CheckPCS[2] = (cmsUInt16Number) i;\n        CheckColorant[0] = CheckColorant[1] = CheckColorant[2] = CheckColorant[3] = (cmsUInt16Number) (4096 - i);\n\n        sprintf(CheckName, \"#%d\", i);\n        if (!cmsNamedColorInfo(nc2, i, Name, NULL, NULL, PCS, Colorant)) { rc = 0; goto Error; }\n\n\n        for (j=0; j < 3; j++) {\n            if (CheckPCS[j] != PCS[j]) { rc = 0; Fail(\"Invalid PCS\"); goto Error; }\n        }\n\n        for (j=0; j < 4; j++) {\n            if (CheckColorant[j] != Colorant[j]) { rc = 0; Fail(\"Invalid Colorant\"); goto Error; };\n        }\n\n        if (strcmp(Name, CheckName) != 0) {rc = 0; Fail(\"Invalid Name\"); goto Error; };\n    }\n\n    cmsCloseProfile(h);\n    remove(\"namedcol.icc\");\n\nError:\n    if (nc != NULL) cmsFreeNamedColorList(nc);\n    return rc;\n}",
          "fn_code_pos": [
            [
              3703,
              0
            ],
            [
              3791,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckNamedColorList",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CreateNamedColorProfile(void)\n{     \n    // Color list database\n    cmsNAMEDCOLORLIST* colors = cmsAllocNamedColorList(0, 10, 4, \"PANTONE\", \"TCX\");\n\n    // Containers for names\n    cmsMLU* DescriptionMLU, *CopyrightMLU;\n\n    // Create n empty profile\n    cmsHPROFILE hProfile = cmsOpenProfileFromFile(\"named.icc\", \"w\");\n    \n    // Values\n    cmsCIELab Lab;\n    cmsUInt16Number PCS[3], Colorant[cmsMAXCHANNELS];\n\n    // Set profile class\n    cmsSetProfileVersion(hProfile, 4.3);\n    cmsSetDeviceClass(hProfile, cmsSigNamedColorClass);\n    cmsSetColorSpace(hProfile, cmsSigCmykData);\n    cmsSetPCS(hProfile, cmsSigLabData);\n    cmsSetHeaderRenderingIntent(hProfile, INTENT_PERCEPTUAL);\n        \n    // Add description and copyright only in english/US\n    DescriptionMLU = cmsMLUalloc(0, 1);\n    CopyrightMLU   = cmsMLUalloc(0, 1);\n\n    cmsMLUsetWide(DescriptionMLU, \"en\", \"US\", L\"Profile description\");\n    cmsMLUsetWide(CopyrightMLU,   \"en\", \"US\", L\"Profile copyright\");\n\n    cmsWriteTag(hProfile, cmsSigProfileDescriptionTag, DescriptionMLU);\n    cmsWriteTag(hProfile, cmsSigCopyrightTag, CopyrightMLU);\n\n    // Set the media white point\n    cmsWriteTag(hProfile, cmsSigMediaWhitePointTag, cmsD50_XYZ());\n\n\n    // Populate one value, Colorant = CMYK values in 16 bits, PCS[] = Encoded Lab values (in V2 format!!)\n    Lab.L = 50; Lab.a = 10; Lab.b = -10;\n    cmsFloat2LabEncodedV2(PCS, &Lab); \n    Colorant[0] = 10 * 257; Colorant[1] = 20 * 257; Colorant[2] = 30 * 257; Colorant[3] = 40 * 257;\n    cmsAppendNamedColor(colors, \"Hazelnut 14-1315\", PCS, Colorant);\n\n    // Another one. Consider to write a routine for that\n    Lab.L = 40; Lab.a = -5; Lab.b = 8;\n    cmsFloat2LabEncodedV2(PCS, &Lab);\n    Colorant[0] = 10 * 257; Colorant[1] = 20 * 257; Colorant[2] = 30 * 257; Colorant[3] = 40 * 257;\n    cmsAppendNamedColor(colors, \"Kale 18-0107\", PCS, Colorant);\n\n    // Write the colors database\n    cmsWriteTag(hProfile, cmsSigNamedColor2Tag, colors);\n\n    // That will create the file\n    cmsCloseProfile(hProfile);\n\n    // Free resources\n    cmsFreeNamedColorList(colors);\n    cmsMLUfree(DescriptionMLU);\n    cmsMLUfree(CopyrightMLU);\n\n    remove(\"named.icc\");\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              3796,
              0
            ],
            [
              3859,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CreateNamedColorProfile",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid CheckSingleFormatter16(cmsContext id, cmsUInt32Number Type, const char* Text)\n{\n    cmsUInt16Number Values[cmsMAXCHANNELS];\n    cmsUInt8Number Buffer[1024];\n    cmsFormatter f, b;\n    cmsInt32Number i, j, nChannels, bytes;\n    _cmsTRANSFORM info;\n\n    // Already failed?\n    if (FormatterFailed) return;\n\n    memset(&info, 0, sizeof(info));\n    info.OutputFormat = info.InputFormat = Type;\n\n    // Go forth and back\n    f = _cmsGetFormatter(id, Type,  cmsFormatterInput, CMS_PACK_FLAGS_16BITS);\n    b = _cmsGetFormatter(id, Type,  cmsFormatterOutput, CMS_PACK_FLAGS_16BITS);\n\n    if (f.Fmt16 == NULL || b.Fmt16 == NULL) {\n        Fail(\"no formatter for %s\", Text);\n        FormatterFailed = TRUE;\n\n        // Useful for debug\n        f = _cmsGetFormatter(id, Type,  cmsFormatterInput, CMS_PACK_FLAGS_16BITS);\n        b = _cmsGetFormatter(id, Type,  cmsFormatterOutput, CMS_PACK_FLAGS_16BITS);\n        return;\n    }\n\n    nChannels = T_CHANNELS(Type);\n    bytes     = T_BYTES(Type);\n\n    for (j=0; j < 5; j++) {\n\n        for (i=0; i < nChannels; i++) {\n            Values[i] = (cmsUInt16Number) (i+j);\n            // For 8-bit\n            if (bytes == 1)\n                Values[i] <<= 8;\n        }\n\n    b.Fmt16(&info, Values, Buffer, 2);\n    memset(Values, 0, sizeof(Values));\n    f.Fmt16(&info, Values, Buffer, 2);\n\n    for (i=0; i < nChannels; i++) {\n        if (bytes == 1)\n            Values[i] >>= 8;\n\n        if (Values[i] != i+j) {\n\n            Fail(\"%s failed\", Text);\n            FormatterFailed = TRUE;\n\n            // Useful for debug\n            for (i=0; i < nChannels; i++) {\n                Values[i] = (cmsUInt16Number) (i+j);\n                // For 8-bit\n                if (bytes == 1)\n                    Values[i] <<= 8;\n            }\n\n            b.Fmt16(&info, Values, Buffer, 1);\n            f.Fmt16(&info, Values, Buffer, 1);\n            return;\n        }\n    }\n    }\n}",
          "fn_code_pos": [
            [
              3868,
              0
            ],
            [
              3936,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckSingleFormatter16",
            "parameters": {
              "id": "cmsContext",
              "Type": "cmsUInt32Number",
              "Text": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckFormatters16(void)\n{\n    FormatterFailed = FALSE;\n\n   C( TYPE_GRAY_8            );\n   C( TYPE_GRAY_8_REV        );\n   C( TYPE_GRAY_16           );\n   C( TYPE_GRAY_16_REV       );\n   C( TYPE_GRAY_16_SE        );\n   C( TYPE_GRAYA_8           );\n   C( TYPE_GRAYA_16          );\n   C( TYPE_GRAYA_16_SE       );\n   C( TYPE_GRAYA_8_PLANAR    );\n   C( TYPE_GRAYA_16_PLANAR   );\n   C( TYPE_RGB_8             );\n   C( TYPE_RGB_8_PLANAR      );\n   C( TYPE_BGR_8             );\n   C( TYPE_BGR_8_PLANAR      );\n   C( TYPE_RGB_16            );\n   C( TYPE_RGB_16_PLANAR     );\n   C( TYPE_RGB_16_SE         );\n   C( TYPE_BGR_16            );\n   C( TYPE_BGR_16_PLANAR     );\n   C( TYPE_BGR_16_SE         );\n   C( TYPE_RGBA_8            );\n   C( TYPE_RGBA_8_PLANAR     );\n   C( TYPE_RGBA_16           );\n   C( TYPE_RGBA_16_PLANAR    );\n   C( TYPE_RGBA_16_SE        );\n   C( TYPE_ARGB_8            );\n   C( TYPE_ARGB_8_PLANAR     );\n   C( TYPE_ARGB_16           );\n   C( TYPE_ABGR_8            );\n   C( TYPE_ABGR_8_PLANAR     );\n   C( TYPE_ABGR_16           );\n   C( TYPE_ABGR_16_PLANAR    );\n   C( TYPE_ABGR_16_SE        );\n   C( TYPE_BGRA_8            );\n   C( TYPE_BGRA_8_PLANAR     );\n   C( TYPE_BGRA_16           );\n   C( TYPE_BGRA_16_SE        );\n   C( TYPE_CMY_8             );\n   C( TYPE_CMY_8_PLANAR      );\n   C( TYPE_CMY_16            );\n   C( TYPE_CMY_16_PLANAR     );\n   C( TYPE_CMY_16_SE         );\n   C( TYPE_CMYK_8            );\n   C( TYPE_CMYKA_8           );\n   C( TYPE_CMYK_8_REV        );\n   C( TYPE_YUVK_8            );\n   C( TYPE_CMYK_8_PLANAR     );\n   C( TYPE_CMYK_16           );\n   C( TYPE_CMYK_16_REV       );\n   C( TYPE_YUVK_16           );\n   C( TYPE_CMYK_16_PLANAR    );\n   C( TYPE_CMYK_16_SE        );\n   C( TYPE_KYMC_8            );\n   C( TYPE_KYMC_16           );\n   C( TYPE_KYMC_16_SE        );\n   C( TYPE_KCMY_8            );\n   C( TYPE_KCMY_8_REV        );\n   C( TYPE_KCMY_16           );\n   C( TYPE_KCMY_16_REV       );\n   C( TYPE_KCMY_16_SE        );\n   C( TYPE_CMYK5_8           );\n   C( TYPE_CMYK5_16          );\n   C( TYPE_CMYK5_16_SE       );\n   C( TYPE_KYMC5_8           );\n   C( TYPE_KYMC5_16          );\n   C( TYPE_KYMC5_16_SE       );\n   C( TYPE_CMYK6_8          );\n   C( TYPE_CMYK6_8_PLANAR   );\n   C( TYPE_CMYK6_16         );\n   C( TYPE_CMYK6_16_PLANAR  );\n   C( TYPE_CMYK6_16_SE      );\n   C( TYPE_CMYK7_8           );\n   C( TYPE_CMYK7_16          );\n   C( TYPE_CMYK7_16_SE       );\n   C( TYPE_KYMC7_8           );\n   C( TYPE_KYMC7_16          );\n   C( TYPE_KYMC7_16_SE       );\n   C( TYPE_CMYK8_8           );\n   C( TYPE_CMYK8_16          );\n   C( TYPE_CMYK8_16_SE       );\n   C( TYPE_KYMC8_8           );\n   C( TYPE_KYMC8_16          );\n   C( TYPE_KYMC8_16_SE       );\n   C( TYPE_CMYK9_8           );\n   C( TYPE_CMYK9_16          );\n   C( TYPE_CMYK9_16_SE       );\n   C( TYPE_KYMC9_8           );\n   C( TYPE_KYMC9_16          );\n   C( TYPE_KYMC9_16_SE       );\n   C( TYPE_CMYK10_8          );\n   C( TYPE_CMYK10_16         );\n   C( TYPE_CMYK10_16_SE      );\n   C( TYPE_KYMC10_8          );\n   C( TYPE_KYMC10_16         );\n   C( TYPE_KYMC10_16_SE      );\n   C( TYPE_CMYK11_8          );\n   C( TYPE_CMYK11_16         );\n   C( TYPE_CMYK11_16_SE      );\n   C( TYPE_KYMC11_8          );\n   C( TYPE_KYMC11_16         );\n   C( TYPE_KYMC11_16_SE      );\n   C( TYPE_CMYK12_8          );\n   C( TYPE_CMYK12_16         );\n   C( TYPE_CMYK12_16_SE      );\n   C( TYPE_KYMC12_8          );\n   C( TYPE_KYMC12_16         );\n   C( TYPE_KYMC12_16_SE      );\n   C( TYPE_XYZ_16            );\n   C( TYPE_Lab_8             );\n   C( TYPE_ALab_8            );\n   C( TYPE_Lab_16            );\n   C( TYPE_Yxy_16            );\n   C( TYPE_YCbCr_8           );\n   C( TYPE_YCbCr_8_PLANAR    );\n   C( TYPE_YCbCr_16          );\n   C( TYPE_YCbCr_16_PLANAR   );\n   C( TYPE_YCbCr_16_SE       );\n   C( TYPE_YUV_8             );\n   C( TYPE_YUV_8_PLANAR      );\n   C( TYPE_YUV_16            );\n   C( TYPE_YUV_16_PLANAR     );\n   C( TYPE_YUV_16_SE         );\n   C( TYPE_HLS_8             );\n   C( TYPE_HLS_8_PLANAR      );\n   C( TYPE_HLS_16            );\n   C( TYPE_HLS_16_PLANAR     );\n   C( TYPE_HLS_16_SE         );\n   C( TYPE_HSV_8             );\n   C( TYPE_HSV_8_PLANAR      );\n   C( TYPE_HSV_16            );\n   C( TYPE_HSV_16_PLANAR     );\n   C( TYPE_HSV_16_SE         );\n\n   C( TYPE_XYZ_FLT  );\n   C( TYPE_Lab_FLT  );\n   C( TYPE_GRAY_FLT );\n   C( TYPE_RGB_FLT  );\n   C( TYPE_BGR_FLT  );\n   C( TYPE_CMYK_FLT );\n   C( TYPE_LabA_FLT );\n   C( TYPE_RGBA_FLT );\n   C( TYPE_ARGB_FLT );\n   C( TYPE_BGRA_FLT );\n   C( TYPE_ABGR_FLT );\n\n\n   C( TYPE_XYZ_DBL  );\n   C( TYPE_Lab_DBL  );\n   C( TYPE_GRAY_DBL );\n   C( TYPE_RGB_DBL  );\n   C( TYPE_BGR_DBL  );\n   C( TYPE_CMYK_DBL );\n\n   C( TYPE_LabV2_8  );\n   C( TYPE_ALabV2_8 );\n   C( TYPE_LabV2_16 );\n\n#ifndef CMS_NO_HALF_SUPPORT \n\n   C( TYPE_GRAY_HALF_FLT );\n   C( TYPE_RGB_HALF_FLT  );\n   C( TYPE_CMYK_HALF_FLT );\n   C( TYPE_RGBA_HALF_FLT );\n\n   C( TYPE_RGBA_HALF_FLT );\n   C( TYPE_ARGB_HALF_FLT );\n   C( TYPE_BGR_HALF_FLT  );\n   C( TYPE_BGRA_HALF_FLT );\n   C( TYPE_ABGR_HALF_FLT );\n\n#endif\n\n   return FormatterFailed == 0 ? 1 : 0;\n}",
          "fn_code_pos": [
            [
              3942,
              0
            ],
            [
              4120,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckFormatters16",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid CheckSingleFormatterFloat(cmsUInt32Number Type, const char* Text)\n{\n    cmsFloat32Number Values[cmsMAXCHANNELS];\n    cmsUInt8Number Buffer[1024];\n    cmsFormatter f, b;\n    cmsInt32Number i, j, nChannels;\n    _cmsTRANSFORM info;\n\n    // Already failed?\n    if (FormatterFailed) return;\n\n    memset(&info, 0, sizeof(info));\n    info.OutputFormat = info.InputFormat = Type;\n\n    // Go forth and back\n    f = _cmsGetFormatter(0, Type,  cmsFormatterInput, CMS_PACK_FLAGS_FLOAT);\n    b = _cmsGetFormatter(0, Type,  cmsFormatterOutput, CMS_PACK_FLAGS_FLOAT);\n\n    if (f.FmtFloat == NULL || b.FmtFloat == NULL) {\n        Fail(\"no formatter for %s\", Text);\n        FormatterFailed = TRUE;\n\n        // Useful for debug\n        f = _cmsGetFormatter(0, Type,  cmsFormatterInput, CMS_PACK_FLAGS_FLOAT);\n        b = _cmsGetFormatter(0, Type,  cmsFormatterOutput, CMS_PACK_FLAGS_FLOAT);\n        return;\n    }\n\n    nChannels = T_CHANNELS(Type);\n\n    for (j=0; j < 5; j++) {\n\n        for (i=0; i < nChannels; i++) {\n            Values[i] = (cmsFloat32Number) (i+j);\n        }\n\n        b.FmtFloat(&info, Values, Buffer, 1);\n        memset(Values, 0, sizeof(Values));\n        f.FmtFloat(&info, Values, Buffer, 1);\n\n        for (i=0; i < nChannels; i++) {\n\n            cmsFloat64Number delta = fabs(Values[i] - ( i+j));\n\n            if (delta > 0.000000001) {\n\n                Fail(\"%s failed\", Text);\n                FormatterFailed = TRUE;\n\n                // Useful for debug\n                for (i=0; i < nChannels; i++) {\n                    Values[i] = (cmsFloat32Number) (i+j);\n                }\n\n                b.FmtFloat(&info, Values, Buffer, 1);\n                f.FmtFloat(&info, Values, Buffer, 1);\n                return;\n            }\n        }\n    }\n}",
          "fn_code_pos": [
            [
              4123,
              0
            ],
            [
              4184,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckSingleFormatterFloat",
            "parameters": {
              "Type": "cmsUInt32Number",
              "Text": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckFormattersFloat(void)\n{\n    FormatterFailed = FALSE;\n\n    C( TYPE_XYZ_FLT  );\n    C( TYPE_Lab_FLT  );\n    C( TYPE_GRAY_FLT );\n    C( TYPE_RGB_FLT  );\n    C( TYPE_BGR_FLT  );\n    C( TYPE_CMYK_FLT );\n\n    C( TYPE_LabA_FLT );\n    C( TYPE_RGBA_FLT );\n\n    C( TYPE_ARGB_FLT );\n    C( TYPE_BGRA_FLT );\n    C( TYPE_ABGR_FLT );\n\n    C( TYPE_XYZ_DBL  );\n    C( TYPE_Lab_DBL  );\n    C( TYPE_GRAY_DBL );\n    C( TYPE_RGB_DBL  );\n    C( TYPE_BGR_DBL  );\n    C( TYPE_CMYK_DBL );\n    C( TYPE_XYZ_FLT );\n\n#ifndef CMS_NO_HALF_SUPPORT \n   C( TYPE_GRAY_HALF_FLT );\n   C( TYPE_RGB_HALF_FLT  );\n   C( TYPE_CMYK_HALF_FLT );\n   C( TYPE_RGBA_HALF_FLT );\n\n   C( TYPE_RGBA_HALF_FLT );\n   C( TYPE_ARGB_HALF_FLT );\n   C( TYPE_BGR_HALF_FLT  );\n   C( TYPE_BGRA_HALF_FLT );\n   C( TYPE_ABGR_HALF_FLT );\n#endif\n\n\n\n\n   return FormatterFailed == 0 ? 1 : 0;\n}",
          "fn_code_pos": [
            [
              4188,
              0
            ],
            [
              4232,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckFormattersFloat",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckFormattersHalf(void)\n{\n    int i, j;\n\n\n    for (i=0; i < 0xffff; i++) {\n\n        cmsFloat32Number f = _cmsHalf2Float((cmsUInt16Number) i);\n\n        if (!my_isfinite(f))  {\n\n            j = _cmsFloat2Half(f);\n\n            if (i != j) {\n                Fail(\"%d != %d in Half float support!\\n\", i, j);\n                return 0;\n            }\n        }\n    }\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              4239,
              0
            ],
            [
              4261,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckFormattersHalf",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckOneRGB(cmsHTRANSFORM xform, cmsUInt16Number R, cmsUInt16Number G, cmsUInt16Number B, cmsUInt16Number Ro, cmsUInt16Number Go, cmsUInt16Number Bo)\n{\n    cmsUInt16Number RGB[3];\n    cmsUInt16Number Out[3];\n\n    RGB[0] = R;\n    RGB[1] = G;\n    RGB[2] = B;\n\n    cmsDoTransform(xform, RGB, Out, 1);\n\n    return IsGoodWord(\"R\", Ro , Out[0]) &&\n           IsGoodWord(\"G\", Go , Out[1]) &&\n           IsGoodWord(\"B\", Bo , Out[2]);\n}",
          "fn_code_pos": [
            [
              4265,
              0
            ],
            [
              4280,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckOneRGB",
            "parameters": {
              "xform": "cmsHTRANSFORM",
              "R": "cmsUInt16Number",
              "G": "cmsUInt16Number",
              "B": "cmsUInt16Number",
              "Ro": "cmsUInt16Number",
              "Go": "cmsUInt16Number",
              "Bo": "cmsUInt16Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckOneRGB_double(cmsHTRANSFORM xform, cmsFloat64Number R, cmsFloat64Number G, cmsFloat64Number B, cmsFloat64Number Ro, cmsFloat64Number Go, cmsFloat64Number Bo)\n{\n    cmsFloat64Number RGB[3];\n    cmsFloat64Number Out[3];\n\n    RGB[0] = R;\n    RGB[1] = G;\n    RGB[2] = B;\n\n    cmsDoTransform(xform, RGB, Out, 1);\n\n    return IsGoodVal(\"R\", Ro , Out[0], 0.01) &&\n           IsGoodVal(\"G\", Go , Out[1], 0.01) &&\n           IsGoodVal(\"B\", Bo , Out[2], 0.01);\n}",
          "fn_code_pos": [
            [
              4283,
              0
            ],
            [
              4298,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckOneRGB_double",
            "parameters": {
              "xform": "cmsHTRANSFORM",
              "R": "cmsFloat64Number",
              "G": "cmsFloat64Number",
              "B": "cmsFloat64Number",
              "Ro": "cmsFloat64Number",
              "Go": "cmsFloat64Number",
              "Bo": "cmsFloat64Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckChangeBufferFormat(void)\n{\n    cmsHPROFILE hsRGB = cmsCreate_sRGBProfile();\n    cmsHTRANSFORM xform;\n\n\n    xform = cmsCreateTransform(hsRGB, TYPE_RGB_16, hsRGB, TYPE_RGB_16, INTENT_PERCEPTUAL, 0);\n    cmsCloseProfile(hsRGB);\n    if (xform == NULL) return 0;\n\n\n    if (!CheckOneRGB(xform, 0, 0, 0, 0, 0, 0)) return 0;\n    if (!CheckOneRGB(xform, 120, 0, 0, 120, 0, 0)) return 0;\n    if (!CheckOneRGB(xform, 0, 222, 255, 0, 222, 255)) return 0;\n\n\n    if (!cmsChangeBuffersFormat(xform, TYPE_BGR_16, TYPE_RGB_16)) return 0;\n\n    if (!CheckOneRGB(xform, 0, 0, 123, 123, 0, 0)) return 0;\n    if (!CheckOneRGB(xform, 154, 234, 0, 0, 234, 154)) return 0;\n\n    if (!cmsChangeBuffersFormat(xform, TYPE_RGB_DBL, TYPE_RGB_DBL)) return 0;\n\n    if (!CheckOneRGB_double(xform, 0.20, 0, 0, 0.20, 0, 0)) return 0;\n    if (!CheckOneRGB_double(xform, 0, 0.9, 1, 0, 0.9, 1)) return 0;\n\n    cmsDeleteTransform(xform);\n\nreturn 1;\n}",
          "fn_code_pos": [
            [
              4301,
              0
            ],
            [
              4331,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckChangeBufferFormat",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckXYZ(cmsInt32Number Pass, cmsHPROFILE hProfile, cmsTagSignature tag)\n{\n    cmsCIEXYZ XYZ, *Pt;\n\n\n    switch (Pass) {\n\n        case 1:\n\n            XYZ.X = 1.0; XYZ.Y = 1.1; XYZ.Z = 1.2;\n            return cmsWriteTag(hProfile, tag, &XYZ);\n\n        case 2:\n            Pt = (cmsCIEXYZ *) cmsReadTag(hProfile, tag); \n            if (Pt == NULL) return 0;\n            return IsGoodFixed15_16(\"X\", 1.0, Pt ->X) &&\n                   IsGoodFixed15_16(\"Y\", 1.1, Pt->Y) &&\n                   IsGoodFixed15_16(\"Z\", 1.2, Pt -> Z);\n\n        default:\n            return 0;\n    }\n}",
          "fn_code_pos": [
            [
              4336,
              0
            ],
            [
              4359,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckXYZ",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE",
              "tag": "cmsTagSignature"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckGamma(cmsInt32Number Pass, cmsHPROFILE hProfile, cmsTagSignature tag)\n{\n    cmsToneCurve *g, *Pt;\n    cmsInt32Number rc;\n\n    switch (Pass) {\n\n        case 1:\n\n            g = cmsBuildGamma(DbgThread(), 1.0);\n            rc = cmsWriteTag(hProfile, tag, g);\n            cmsFreeToneCurve(g);\n            return rc;\n\n        case 2:\n            Pt = (cmsToneCurve *) cmsReadTag(hProfile, tag); \n            if (Pt == NULL) return 0;\n            return cmsIsToneCurveLinear(Pt);\n\n        default:\n            return 0;\n    }\n}",
          "fn_code_pos": [
            [
              4362,
              0
            ],
            [
              4385,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGamma",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE",
              "tag": "cmsTagSignature"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckTextSingle(cmsInt32Number Pass, cmsHPROFILE hProfile, cmsTagSignature tag)\n{\n    cmsMLU *m, *Pt;\n    cmsInt32Number rc;\n    char Buffer[256];\n\n\n    switch (Pass) {\n\n    case 1:\n        m = cmsMLUalloc(DbgThread(), 0);\n        cmsMLUsetASCII(m, cmsNoLanguage, cmsNoCountry, \"Test test\");    \n        rc = cmsWriteTag(hProfile, tag, m);\n        cmsMLUfree(m);\n        return rc;\n\n    case 2:\n        Pt = (cmsMLU *) cmsReadTag(hProfile, tag); \n        if (Pt == NULL) return 0;\n        cmsMLUgetASCII(Pt, cmsNoLanguage, cmsNoCountry, Buffer, 256);\n        if (strcmp(Buffer, \"Test test\") != 0) return FALSE;\n        return TRUE;\n\n    default:\n        return 0;\n    }\n}",
          "fn_code_pos": [
            [
              4387,
              0
            ],
            [
              4414,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckTextSingle",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE",
              "tag": "cmsTagSignature"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckText(cmsInt32Number Pass, cmsHPROFILE hProfile, cmsTagSignature tag)\n{\n    cmsMLU *m, *Pt;\n    cmsInt32Number rc;\n    char Buffer[256];\n\n\n    switch (Pass) {\n\n        case 1:\n            m = cmsMLUalloc(DbgThread(), 0);\n            cmsMLUsetASCII(m, cmsNoLanguage, cmsNoCountry, \"Test test\");\n            cmsMLUsetASCII(m, \"en\",  \"US\",  \"1 1 1 1\");\n            cmsMLUsetASCII(m, \"es\",  \"ES\",  \"2 2 2 2\");\n            cmsMLUsetASCII(m, \"ct\",  \"ES\",  \"3 3 3 3\");\n            cmsMLUsetASCII(m, \"en\",  \"GB\",  \"444444444\");\n            rc = cmsWriteTag(hProfile, tag, m);\n            cmsMLUfree(m);\n            return rc;\n\n        case 2:\n            Pt = (cmsMLU *) cmsReadTag(hProfile, tag); \n            if (Pt == NULL) return 0;\n            cmsMLUgetASCII(Pt, cmsNoLanguage, cmsNoCountry, Buffer, 256);\n            if (strcmp(Buffer, \"Test test\") != 0) return FALSE;\n            cmsMLUgetASCII(Pt, \"en\", \"US\", Buffer, 256);\n            if (strcmp(Buffer, \"1 1 1 1\") != 0) return FALSE;\n            cmsMLUgetASCII(Pt, \"es\", \"ES\", Buffer, 256);\n            if (strcmp(Buffer, \"2 2 2 2\") != 0) return FALSE;\n            cmsMLUgetASCII(Pt, \"ct\", \"ES\", Buffer, 256);\n            if (strcmp(Buffer, \"3 3 3 3\") != 0) return FALSE;\n            cmsMLUgetASCII(Pt, \"en\", \"GB\",  Buffer, 256);\n            if (strcmp(Buffer, \"444444444\") != 0) return FALSE;\n            return TRUE;\n\n        default:\n            return 0;\n    }\n}",
          "fn_code_pos": [
            [
              4417,
              0
            ],
            [
              4456,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckText",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE",
              "tag": "cmsTagSignature"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckData(cmsInt32Number Pass,  cmsHPROFILE hProfile, cmsTagSignature tag)\n{\n    cmsICCData *Pt;\n    cmsICCData d = { 1, 0, { '?' }};\n    cmsInt32Number rc;\n\n\n    switch (Pass) {\n\n        case 1:\n            rc = cmsWriteTag(hProfile, tag, &d);\n            return rc;\n\n        case 2:\n            Pt = (cmsICCData *) cmsReadTag(hProfile, tag); \n            if (Pt == NULL) return 0;\n            return (Pt ->data[0] == '?') && (Pt ->flag == 0) && (Pt ->len == 1);\n\n        default:\n            return 0;\n    }\n}",
          "fn_code_pos": [
            [
              4458,
              0
            ],
            [
              4480,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckData",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE",
              "tag": "cmsTagSignature"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckSignature(cmsInt32Number Pass,  cmsHPROFILE hProfile, cmsTagSignature tag)\n{\n    cmsTagSignature *Pt, Holder;\n\n    switch (Pass) {\n\n        case 1:\n            Holder = (cmsTagSignature) cmsSigPerceptualReferenceMediumGamut; \n            return cmsWriteTag(hProfile, tag, &Holder);\n\n        case 2:\n            Pt = (cmsTagSignature *) cmsReadTag(hProfile, tag); \n            if (Pt == NULL) return 0;\n            return *Pt == cmsSigPerceptualReferenceMediumGamut;\n\n        default:\n            return 0;\n    }\n}",
          "fn_code_pos": [
            [
              4483,
              0
            ],
            [
              4502,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckSignature",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE",
              "tag": "cmsTagSignature"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckDateTime(cmsInt32Number Pass,  cmsHPROFILE hProfile, cmsTagSignature tag)\n{\n    struct tm *Pt, Holder;\n\n    switch (Pass) {\n\n        case 1:\n\n            Holder.tm_hour = 1;\n            Holder.tm_min = 2;\n            Holder.tm_sec = 3;\n            Holder.tm_mday = 4;\n            Holder.tm_mon = 5;\n            Holder.tm_year = 2009 - 1900;\n            return cmsWriteTag(hProfile, tag, &Holder);\n\n        case 2:\n            Pt = (struct tm *) cmsReadTag(hProfile, tag); \n            if (Pt == NULL) return 0;\n\n            return (Pt ->tm_hour == 1 &&\n                Pt ->tm_min == 2 &&\n                Pt ->tm_sec == 3 &&\n                Pt ->tm_mday == 4 &&\n                Pt ->tm_mon == 5 &&\n                Pt ->tm_year == 2009 - 1900);\n\n        default:\n            return 0;\n    }\n\n}",
          "fn_code_pos": [
            [
              4505,
              0
            ],
            [
              4537,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckDateTime",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE",
              "tag": "cmsTagSignature"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckNamedColor(cmsInt32Number Pass,  cmsHPROFILE hProfile, cmsTagSignature tag, cmsInt32Number max_check, cmsBool  colorant_check)\n{\n    cmsNAMEDCOLORLIST* nc;\n    cmsInt32Number i, j, rc;\n    char Name[255];\n    cmsUInt16Number PCS[3];\n    cmsUInt16Number Colorant[cmsMAXCHANNELS];\n    char CheckName[255];\n    cmsUInt16Number CheckPCS[3];\n    cmsUInt16Number CheckColorant[cmsMAXCHANNELS];\n\n    switch (Pass) {\n\n    case 1:\n\n        nc = cmsAllocNamedColorList(DbgThread(), 0, 4, \"prefix\", \"suffix\");\n        if (nc == NULL) return 0;\n\n        for (i=0; i < max_check; i++) {\n\n            PCS[0] = PCS[1] = PCS[2] = (cmsUInt16Number) i;\n            Colorant[0] = Colorant[1] = Colorant[2] = Colorant[3] = (cmsUInt16Number) (max_check - i);\n\n            sprintf(Name, \"#%d\", i);\n            if (!cmsAppendNamedColor(nc, Name, PCS, Colorant)) { Fail(\"Couldn't append named color\"); return 0; }\n        }\n\n        rc = cmsWriteTag(hProfile, tag, nc);\n        cmsFreeNamedColorList(nc);\n        return rc;\n\n    case 2:\n\n        nc = (cmsNAMEDCOLORLIST *) cmsReadTag(hProfile, tag); \n        if (nc == NULL) return 0;\n\n        for (i=0; i < max_check; i++) {\n\n            CheckPCS[0] = CheckPCS[1] = CheckPCS[2] = (cmsUInt16Number) i;\n            CheckColorant[0] = CheckColorant[1] = CheckColorant[2] = CheckColorant[3] = (cmsUInt16Number) (max_check - i);\n\n            sprintf(CheckName, \"#%d\", i);\n            if (!cmsNamedColorInfo(nc, i, Name, NULL, NULL, PCS, Colorant)) { Fail(\"Invalid string\"); return 0; }\n\n\n            for (j=0; j < 3; j++) {\n                if (CheckPCS[j] != PCS[j]) {  Fail(\"Invalid PCS\"); return 0; }\n            }\n\n            // This is only used on named color list\n            if (colorant_check) {\n\n            for (j=0; j < 4; j++) {\n                if (CheckColorant[j] != Colorant[j]) { Fail(\"Invalid Colorant\"); return 0; };\n            }\n            }\n\n            if (strcmp(Name, CheckName) != 0) { Fail(\"Invalid Name\");  return 0; };\n        }\n        return 1;\n\n\n    default: return 0;\n    }\n}",
          "fn_code_pos": [
            [
              4540,
              0
            ],
            [
              4605,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckNamedColor",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE",
              "tag": "cmsTagSignature",
              "max_check": "cmsInt32Number",
              "colorant_check": "cmsBool"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckLUT(cmsInt32Number Pass,  cmsHPROFILE hProfile, cmsTagSignature tag)\n{\n    cmsPipeline* Lut, *Pt;\n    cmsInt32Number rc;\n\n\n    switch (Pass) {\n\n        case 1:\n\n            Lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n            if (Lut == NULL) return 0;\n\n            // Create an identity LUT\n            cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(DbgThread(), 3));\n            cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocIdentityCLut(DbgThread(), 3));\n            cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocIdentityCurves(DbgThread(), 3));\n\n            rc =  cmsWriteTag(hProfile, tag, Lut);\n            cmsPipelineFree(Lut);\n            return rc;\n\n        case 2:\n            Pt = (cmsPipeline *) cmsReadTag(hProfile, tag); \n            if (Pt == NULL) return 0;\n\n            // Transform values, check for identity\n            return Check16LUT(Pt);\n\n        default:\n            return 0;\n    }\n}",
          "fn_code_pos": [
            [
              4608,
              0
            ],
            [
              4641,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckLUT",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE",
              "tag": "cmsTagSignature"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckCHAD(cmsInt32Number Pass,  cmsHPROFILE hProfile, cmsTagSignature tag)\n{\n    cmsFloat64Number *Pt;\n    cmsFloat64Number CHAD[] = { 0, .1, .2, .3, .4, .5, .6, .7, .8 };\n    cmsInt32Number i;\n\n    switch (Pass) {\n\n        case 1:\n            return cmsWriteTag(hProfile, tag, CHAD);\n\n\n        case 2:\n            Pt = (cmsFloat64Number *) cmsReadTag(hProfile, tag); \n            if (Pt == NULL) return 0;\n\n            for (i=0; i < 9; i++) {\n                if (!IsGoodFixed15_16(\"CHAD\", Pt[i], CHAD[i])) return 0;\n            }\n\n            return 1;\n\n        default:\n            return 0;\n    }\n}",
          "fn_code_pos": [
            [
              4643,
              0
            ],
            [
              4669,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckCHAD",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE",
              "tag": "cmsTagSignature"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckChromaticity(cmsInt32Number Pass,  cmsHPROFILE hProfile, cmsTagSignature tag)\n{\n    cmsCIExyYTRIPLE *Pt, c = { {0, .1, 1 }, { .3, .4, 1 }, { .6, .7, 1 }};\n\n    switch (Pass) {\n\n        case 1:\n            return cmsWriteTag(hProfile, tag, &c);\n\n\n        case 2:\n            Pt = (cmsCIExyYTRIPLE *) cmsReadTag(hProfile, tag); \n            if (Pt == NULL) return 0;\n\n            if (!IsGoodFixed15_16(\"xyY\", Pt ->Red.x, c.Red.x)) return 0;\n            if (!IsGoodFixed15_16(\"xyY\", Pt ->Red.y, c.Red.y)) return 0;\n            if (!IsGoodFixed15_16(\"xyY\", Pt ->Green.x, c.Green.x)) return 0;\n            if (!IsGoodFixed15_16(\"xyY\", Pt ->Green.y, c.Green.y)) return 0;\n            if (!IsGoodFixed15_16(\"xyY\", Pt ->Blue.x, c.Blue.x)) return 0;\n            if (!IsGoodFixed15_16(\"xyY\", Pt ->Blue.y, c.Blue.y)) return 0;\n            return 1;\n\n        default:\n            return 0;\n    }\n}",
          "fn_code_pos": [
            [
              4671,
              0
            ],
            [
              4697,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckChromaticity",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE",
              "tag": "cmsTagSignature"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckColorantOrder(cmsInt32Number Pass,  cmsHPROFILE hProfile, cmsTagSignature tag)\n{\n    cmsUInt8Number *Pt, c[cmsMAXCHANNELS];\n    cmsInt32Number i;\n\n    switch (Pass) {\n\n        case 1:\n            for (i=0; i < cmsMAXCHANNELS; i++) c[i] = (cmsUInt8Number) (cmsMAXCHANNELS - i - 1);\n            return cmsWriteTag(hProfile, tag, c);\n\n\n        case 2:\n            Pt = (cmsUInt8Number *) cmsReadTag(hProfile, tag); \n            if (Pt == NULL) return 0;\n\n            for (i=0; i < cmsMAXCHANNELS; i++) {\n                if (Pt[i] != ( cmsMAXCHANNELS - i - 1 )) return 0;\n            }\n            return 1;\n\n        default:\n            return 0;\n    }\n}",
          "fn_code_pos": [
            [
              4700,
              0
            ],
            [
              4725,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckColorantOrder",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE",
              "tag": "cmsTagSignature"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckMeasurement(cmsInt32Number Pass,  cmsHPROFILE hProfile, cmsTagSignature tag)\n{\n    cmsICCMeasurementConditions *Pt, m;\n\n    switch (Pass) {\n\n        case 1:\n            m.Backing.X = 0.1;\n            m.Backing.Y = 0.2;\n            m.Backing.Z = 0.3;\n            m.Flare = 1.0;\n            m.Geometry = 1;\n            m.IlluminantType = cmsILLUMINANT_TYPE_D50;\n            m.Observer = 1;\n            return cmsWriteTag(hProfile, tag, &m);\n\n\n        case 2:\n            Pt = (cmsICCMeasurementConditions *) cmsReadTag(hProfile, tag); \n            if (Pt == NULL) return 0;\n\n            if (!IsGoodFixed15_16(\"Backing\", Pt ->Backing.X, 0.1)) return 0;\n            if (!IsGoodFixed15_16(\"Backing\", Pt ->Backing.Y, 0.2)) return 0;\n            if (!IsGoodFixed15_16(\"Backing\", Pt ->Backing.Z, 0.3)) return 0;\n            if (!IsGoodFixed15_16(\"Flare\",   Pt ->Flare, 1.0)) return 0;\n\n            if (Pt ->Geometry != 1) return 0;\n            if (Pt ->IlluminantType != cmsILLUMINANT_TYPE_D50) return 0;\n            if (Pt ->Observer != 1) return 0;\n            return 1;\n\n        default:\n            return 0;\n    }\n}",
          "fn_code_pos": [
            [
              4727,
              0
            ],
            [
              4762,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMeasurement",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE",
              "tag": "cmsTagSignature"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckUcrBg(cmsInt32Number Pass,  cmsHPROFILE hProfile, cmsTagSignature tag)\n{\n    cmsUcrBg *Pt, m;\n    cmsInt32Number rc;\n    char Buffer[256];\n\n    switch (Pass) {\n\n        case 1:\n            m.Ucr = cmsBuildGamma(DbgThread(), 2.4);\n            m.Bg  = cmsBuildGamma(DbgThread(), -2.2);\n            m.Desc = cmsMLUalloc(DbgThread(), 1);\n            cmsMLUsetASCII(m.Desc,  cmsNoLanguage, cmsNoCountry, \"test UCR/BG\");\n            rc = cmsWriteTag(hProfile, tag, &m);\n            cmsMLUfree(m.Desc);\n            cmsFreeToneCurve(m.Bg);\n            cmsFreeToneCurve(m.Ucr);\n            return rc;\n\n\n        case 2:\n            Pt = (cmsUcrBg *) cmsReadTag(hProfile, tag); \n            if (Pt == NULL) return 0;\n\n            cmsMLUgetASCII(Pt ->Desc, cmsNoLanguage, cmsNoCountry, Buffer, 256);\n            if (strcmp(Buffer, \"test UCR/BG\") != 0) return 0;\n            return 1;\n\n        default:\n            return 0;\n    }\n}",
          "fn_code_pos": [
            [
              4765,
              0
            ],
            [
              4797,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckUcrBg",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE",
              "tag": "cmsTagSignature"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckCRDinfo(cmsInt32Number Pass,  cmsHPROFILE hProfile, cmsTagSignature tag)\n{\n    cmsMLU *mlu;\n    char Buffer[256];\n    cmsInt32Number rc;\n\n    switch (Pass) {\n\n        case 1:\n            mlu = cmsMLUalloc(DbgThread(), 5);\n\n            cmsMLUsetWide(mlu,  \"PS\", \"nm\", L\"test postscript\");\n            cmsMLUsetWide(mlu,  \"PS\", \"#0\", L\"perceptual\");\n            cmsMLUsetWide(mlu,  \"PS\", \"#1\", L\"relative_colorimetric\");\n            cmsMLUsetWide(mlu,  \"PS\", \"#2\", L\"saturation\");\n            cmsMLUsetWide(mlu,  \"PS\", \"#3\", L\"absolute_colorimetric\");\n            rc = cmsWriteTag(hProfile, tag, mlu);\n            cmsMLUfree(mlu);\n            return rc;\n\n\n        case 2:\n            mlu = (cmsMLU*) cmsReadTag(hProfile, tag);\n            if (mlu == NULL) return 0;\n\n\n\n             cmsMLUgetASCII(mlu, \"PS\", \"nm\", Buffer, 256);\n             if (strcmp(Buffer, \"test postscript\") != 0) return 0;\n\n\n             cmsMLUgetASCII(mlu, \"PS\", \"#0\", Buffer, 256);\n             if (strcmp(Buffer, \"perceptual\") != 0) return 0;\n\n\n             cmsMLUgetASCII(mlu, \"PS\", \"#1\", Buffer, 256);\n             if (strcmp(Buffer, \"relative_colorimetric\") != 0) return 0;\n\n\n             cmsMLUgetASCII(mlu, \"PS\", \"#2\", Buffer, 256);\n             if (strcmp(Buffer, \"saturation\") != 0) return 0;\n\n\n             cmsMLUgetASCII(mlu, \"PS\", \"#3\", Buffer, 256);\n             if (strcmp(Buffer, \"absolute_colorimetric\") != 0) return 0;\n             return 1;\n\n        default:\n            return 0;\n    }\n}",
          "fn_code_pos": [
            [
              4800,
              0
            ],
            [
              4851,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckCRDinfo",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE",
              "tag": "cmsTagSignature"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsToneCurve *CreateSegmentedCurve(void)\n{\n    cmsCurveSegment Seg[3];\n    cmsFloat32Number Sampled[2] = { 0, 1};\n\n    Seg[0].Type = 6;\n    Seg[0].Params[0] = 1;\n    Seg[0].Params[1] = 0;\n    Seg[0].Params[2] = 0;\n    Seg[0].Params[3] = 0;\n    Seg[0].x0 = -1E22F;\n    Seg[0].x1 = 0;\n\n    Seg[1].Type = 0;\n    Seg[1].nGridPoints = 2;\n    Seg[1].SampledPoints = Sampled;\n    Seg[1].x0 = 0;\n    Seg[1].x1 = 1;\n\n    Seg[2].Type = 6;\n    Seg[2].Params[0] = 1;\n    Seg[2].Params[1] = 0;\n    Seg[2].Params[2] = 0;\n    Seg[2].Params[3] = 0;\n    Seg[2].x0 = 1;\n    Seg[2].x1 = 1E22F;\n\n    return cmsBuildSegmentedToneCurve(DbgThread(), 3, Seg);\n}",
          "fn_code_pos": [
            [
              4854,
              0
            ],
            [
              4883,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CreateSegmentedCurve",
            "parameters": {},
            "return_type": "cmsToneCurve"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckMPE(cmsInt32Number Pass,  cmsHPROFILE hProfile, cmsTagSignature tag)\n{\n    cmsPipeline* Lut, *Pt;\n    cmsToneCurve* G[3];\n    cmsInt32Number rc;\n\n    switch (Pass) {\n\n        case 1:\n\n            Lut = cmsPipelineAlloc(DbgThread(), 3, 3);\n\n            cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocLabV2ToV4(DbgThread()));\n            cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV4ToV2(DbgThread()));\n            AddIdentityCLUTfloat(Lut);\n\n            G[0] = G[1] = G[2] = CreateSegmentedCurve();\n            cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(DbgThread(), 3, G));\n            cmsFreeToneCurve(G[0]);\n\n            rc = cmsWriteTag(hProfile, tag, Lut);\n            cmsPipelineFree(Lut);\n            return rc;\n\n        case 2:\n            Pt = (cmsPipeline *) cmsReadTag(hProfile, tag); \n            if (Pt == NULL) return 0;\n            return CheckFloatLUT(Pt);\n\n        default:\n            return 0;\n    }\n}",
          "fn_code_pos": [
            [
              4886,
              0
            ],
            [
              4919,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMPE",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE",
              "tag": "cmsTagSignature"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckScreening(cmsInt32Number Pass,  cmsHPROFILE hProfile, cmsTagSignature tag)\n{\n    cmsScreening *Pt, sc;\n    cmsInt32Number rc;\n\n    switch (Pass) {\n\n        case 1:\n\n            sc.Flag = 0;\n            sc.nChannels = 1;\n            sc.Channels[0].Frequency = 2.0;\n            sc.Channels[0].ScreenAngle = 3.0;\n            sc.Channels[0].SpotShape = cmsSPOT_ELLIPSE;\n\n            rc = cmsWriteTag(hProfile, tag, &sc);\n            return rc;\n\n\n        case 2:\n            Pt = (cmsScreening *) cmsReadTag(hProfile, tag); \n            if (Pt == NULL) return 0;\n\n            if (Pt ->nChannels != 1) return 0;\n            if (Pt ->Flag      != 0) return 0;\n            if (!IsGoodFixed15_16(\"Freq\", Pt ->Channels[0].Frequency, 2.0)) return 0;\n            if (!IsGoodFixed15_16(\"Angle\", Pt ->Channels[0].ScreenAngle, 3.0)) return 0;\n            if (Pt ->Channels[0].SpotShape != cmsSPOT_ELLIPSE) return 0;\n            return 1;\n\n        default:\n            return 0;\n    }\n}",
          "fn_code_pos": [
            [
              4922,
              0
            ],
            [
              4956,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckScreening",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE",
              "tag": "cmsTagSignature"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsBool CheckOneStr(cmsMLU* mlu, cmsInt32Number n)\n{\n    char Buffer[256], Buffer2[256];\n\n\n    cmsMLUgetASCII(mlu, \"en\", \"US\", Buffer, 255);\n    sprintf(Buffer2, \"Hello, world %d\", n);\n    if (strcmp(Buffer, Buffer2) != 0) return FALSE;\n\n\n    cmsMLUgetASCII(mlu, \"es\", \"ES\", Buffer, 255);\n    sprintf(Buffer2, \"Hola, mundo %d\", n);\n    if (strcmp(Buffer, Buffer2) != 0) return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              4959,
              0
            ],
            [
              4975,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckOneStr",
            "parameters": {
              "mlu": "cmsMLU",
              "n": "cmsInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nvoid SetOneStr(cmsMLU** mlu, const wchar_t* s1, const wchar_t* s2)\n{\n    *mlu = cmsMLUalloc(DbgThread(), 0);\n    cmsMLUsetWide(*mlu, \"en\", \"US\", s1);\n    cmsMLUsetWide(*mlu, \"es\", \"ES\", s2);\n}",
          "fn_code_pos": [
            [
              4978,
              0
            ],
            [
              4984,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetOneStr",
            "parameters": {
              "mlu": "cmsMLU",
              "s1": "wchar_t",
              "s2": "wchar_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckProfileSequenceTag(cmsInt32Number Pass,  cmsHPROFILE hProfile)\n{\n    cmsSEQ* s;\n    cmsInt32Number i;\n\n    switch (Pass) {\n\n    case 1:\n\n        s = cmsAllocProfileSequenceDescription(DbgThread(), 3);\n        if (s == NULL) return 0;\n\n        SetOneStr(&s -> seq[0].Manufacturer, L\"Hello, world 0\", L\"Hola, mundo 0\");\n        SetOneStr(&s -> seq[0].Model, L\"Hello, world 0\", L\"Hola, mundo 0\");\n        SetOneStr(&s -> seq[1].Manufacturer, L\"Hello, world 1\", L\"Hola, mundo 1\");\n        SetOneStr(&s -> seq[1].Model, L\"Hello, world 1\", L\"Hola, mundo 1\");\n        SetOneStr(&s -> seq[2].Manufacturer, L\"Hello, world 2\", L\"Hola, mundo 2\");\n        SetOneStr(&s -> seq[2].Model, L\"Hello, world 2\", L\"Hola, mundo 2\");\n\n\n#ifdef CMS_DONT_USE_INT64\n        s ->seq[0].attributes[0] = cmsTransparency|cmsMatte;\n        s ->seq[0].attributes[1] = 0;\n#else\n        s ->seq[0].attributes = cmsTransparency|cmsMatte;\n#endif\n\n#ifdef CMS_DONT_USE_INT64\n        s ->seq[1].attributes[0] = cmsReflective|cmsMatte;\n        s ->seq[1].attributes[1] = 0;\n#else\n        s ->seq[1].attributes = cmsReflective|cmsMatte;\n#endif\n\n#ifdef CMS_DONT_USE_INT64\n        s ->seq[2].attributes[0] = cmsTransparency|cmsGlossy;\n        s ->seq[2].attributes[1] = 0;\n#else\n        s ->seq[2].attributes = cmsTransparency|cmsGlossy;\n#endif\n\n        if (!cmsWriteTag(hProfile, cmsSigProfileSequenceDescTag, s)) return 0;\n        cmsFreeProfileSequenceDescription(s);\n        return 1;\n\n    case 2:\n\n        s = (cmsSEQ *) cmsReadTag(hProfile, cmsSigProfileSequenceDescTag); \n        if (s == NULL) return 0;\n\n        if (s ->n != 3) return 0;\n\n#ifdef CMS_DONT_USE_INT64\n        if (s ->seq[0].attributes[0] != (cmsTransparency|cmsMatte)) return 0;\n        if (s ->seq[0].attributes[1] != 0) return 0;\n#else\n        if (s ->seq[0].attributes != (cmsTransparency|cmsMatte)) return 0;\n#endif\n\n#ifdef CMS_DONT_USE_INT64\n        if (s ->seq[1].attributes[0] != (cmsReflective|cmsMatte)) return 0;\n        if (s ->seq[1].attributes[1] != 0) return 0;\n#else\n        if (s ->seq[1].attributes != (cmsReflective|cmsMatte)) return 0;\n#endif\n\n#ifdef CMS_DONT_USE_INT64\n        if (s ->seq[2].attributes[0] != (cmsTransparency|cmsGlossy)) return 0;\n        if (s ->seq[2].attributes[1] != 0) return 0;\n#else\n        if (s ->seq[2].attributes != (cmsTransparency|cmsGlossy)) return 0;\n#endif\n\n        // Check MLU\n        for (i=0; i < 3; i++) {\n\n            if (!CheckOneStr(s -> seq[i].Manufacturer, i)) return 0;\n            if (!CheckOneStr(s -> seq[i].Model, i)) return 0;\n        }\n        return 1;\n\n    default:\n        return 0;\n    }\n}",
          "fn_code_pos": [
            [
              4987,
              0
            ],
            [
              5072,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckProfileSequenceTag",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckProfileSequenceIDTag(cmsInt32Number Pass,  cmsHPROFILE hProfile)\n{\n    cmsSEQ* s;\n    cmsInt32Number i;\n\n    switch (Pass) {\n\n    case 1:\n\n        s = cmsAllocProfileSequenceDescription(DbgThread(), 3);\n        if (s == NULL) return 0;\n\n        memcpy(s ->seq[0].ProfileID.ID8, \"0123456789ABCDEF\", 16);\n        memcpy(s ->seq[1].ProfileID.ID8, \"1111111111111111\", 16);\n        memcpy(s ->seq[2].ProfileID.ID8, \"2222222222222222\", 16);\n\n\n        SetOneStr(&s -> seq[0].Description, L\"Hello, world 0\", L\"Hola, mundo 0\");\n        SetOneStr(&s -> seq[1].Description, L\"Hello, world 1\", L\"Hola, mundo 1\");\n        SetOneStr(&s -> seq[2].Description, L\"Hello, world 2\", L\"Hola, mundo 2\");\n\n        if (!cmsWriteTag(hProfile, cmsSigProfileSequenceIdTag, s)) return 0;\n        cmsFreeProfileSequenceDescription(s);\n        return 1;\n\n    case 2:\n\n        s = (cmsSEQ *) cmsReadTag(hProfile, cmsSigProfileSequenceIdTag); \n        if (s == NULL) return 0;\n\n        if (s ->n != 3) return 0;\n\n        if (memcmp(s ->seq[0].ProfileID.ID8, \"0123456789ABCDEF\", 16) != 0) return 0;\n        if (memcmp(s ->seq[1].ProfileID.ID8, \"1111111111111111\", 16) != 0) return 0;\n        if (memcmp(s ->seq[2].ProfileID.ID8, \"2222222222222222\", 16) != 0) return 0;\n\n        for (i=0; i < 3; i++) {\n\n            if (!CheckOneStr(s -> seq[i].Description, i)) return 0;\n        }\n\n        return 1;\n\n    default:\n        return 0;\n    }\n}",
          "fn_code_pos": [
            [
              5075,
              0
            ],
            [
              5122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckProfileSequenceIDTag",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckICCViewingConditions(cmsInt32Number Pass,  cmsHPROFILE hProfile)\n{\n    cmsICCViewingConditions* v;\n    cmsICCViewingConditions  s;\n\n    switch (Pass) {\n\n        case 1:\n            s.IlluminantType = 1;\n            s.IlluminantXYZ.X = 0.1;\n            s.IlluminantXYZ.Y = 0.2;\n            s.IlluminantXYZ.Z = 0.3;\n            s.SurroundXYZ.X = 0.4;\n            s.SurroundXYZ.Y = 0.5;\n            s.SurroundXYZ.Z = 0.6;\n\n            if (!cmsWriteTag(hProfile, cmsSigViewingConditionsTag, &s)) return 0;\n            return 1;\n\n        case 2:\n            v = (cmsICCViewingConditions *) cmsReadTag(hProfile, cmsSigViewingConditionsTag); \n            if (v == NULL) return 0;\n\n            if (v ->IlluminantType != 1) return 0;\n            if (!IsGoodVal(\"IlluminantXYZ.X\", v ->IlluminantXYZ.X, 0.1, 0.001)) return 0;\n            if (!IsGoodVal(\"IlluminantXYZ.Y\", v ->IlluminantXYZ.Y, 0.2, 0.001)) return 0;\n            if (!IsGoodVal(\"IlluminantXYZ.Z\", v ->IlluminantXYZ.Z, 0.3, 0.001)) return 0;\n\n            if (!IsGoodVal(\"SurroundXYZ.X\", v ->SurroundXYZ.X, 0.4, 0.001)) return 0;\n            if (!IsGoodVal(\"SurroundXYZ.Y\", v ->SurroundXYZ.Y, 0.5, 0.001)) return 0;\n            if (!IsGoodVal(\"SurroundXYZ.Z\", v ->SurroundXYZ.Z, 0.6, 0.001)) return 0;\n\n            return 1;\n\n        default:\n            return 0;\n    }\n\n}",
          "fn_code_pos": [
            [
              5125,
              0
            ],
            [
              5164,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckICCViewingConditions",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckVCGT(cmsInt32Number Pass,  cmsHPROFILE hProfile)\n{\n    cmsToneCurve* Curves[3];\n    cmsToneCurve** PtrCurve;\n\n     switch (Pass) {\n\n        case 1:\n            Curves[0] = cmsBuildGamma(DbgThread(), 1.1);\n            Curves[1] = cmsBuildGamma(DbgThread(), 2.2);\n            Curves[2] = cmsBuildGamma(DbgThread(), 3.4);\n\n            if (!cmsWriteTag(hProfile, cmsSigVcgtTag, Curves)) return 0;\n\n            cmsFreeToneCurveTriple(Curves);\n            return 1;\n\n\n        case 2:\n\n             PtrCurve = (cmsToneCurve **) cmsReadTag(hProfile, cmsSigVcgtTag); \n             if (PtrCurve == NULL) return 0;\n             if (!IsGoodVal(\"VCGT R\", cmsEstimateGamma(PtrCurve[0], 0.01), 1.1, 0.001)) return 0;\n             if (!IsGoodVal(\"VCGT G\", cmsEstimateGamma(PtrCurve[1], 0.01), 2.2, 0.001)) return 0;\n             if (!IsGoodVal(\"VCGT B\", cmsEstimateGamma(PtrCurve[2], 0.01), 3.4, 0.001)) return 0;\n             return 1;\n\n        default:;\n    }\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              5167,
              0
            ],
            [
              5199,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckVCGT",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "cmsInt32Number CheckDictionary16(cmsInt32Number Pass,  cmsHPROFILE hProfile)\n{\n      cmsHANDLE hDict;\n      const cmsDICTentry* e;\n      switch (Pass) {\n\n        case 1:\n            hDict = cmsDictAlloc(DbgThread());\n            cmsDictAddEntry(hDict, L\"Name0\",  NULL, NULL, NULL);\n            cmsDictAddEntry(hDict, L\"Name1\",  L\"\", NULL, NULL);\n            cmsDictAddEntry(hDict, L\"Name\",  L\"String\", NULL, NULL);\n            cmsDictAddEntry(hDict, L\"Name2\", L\"12\",    NULL, NULL);\n            if (!cmsWriteTag(hProfile, cmsSigMetaTag, hDict)) return 0;\n            cmsDictFree(hDict);\n            return 1;\n\n\n        case 2:\n\n             hDict = cmsReadTag(hProfile, cmsSigMetaTag);\n             if (hDict == NULL) return 0;\n             e = cmsDictGetEntryList(hDict);\n             if (memcmp(e ->Name, L\"Name2\", sizeof(wchar_t) * 5) != 0) return 0;\n             if (memcmp(e ->Value, L\"12\",  sizeof(wchar_t) * 2) != 0) return 0;\n             e = cmsDictNextEntry(e);\n             if (memcmp(e ->Name, L\"Name\", sizeof(wchar_t) * 4) != 0) return 0;\n             if (memcmp(e ->Value, L\"String\",  sizeof(wchar_t) * 5) != 0) return 0;\n             e = cmsDictNextEntry(e);\n             if (memcmp(e ->Name, L\"Name1\", sizeof(wchar_t) *5) != 0) return 0;\n             if (e ->Value == NULL) return 0;\n             if (*e->Value != 0) return 0;\n             e = cmsDictNextEntry(e);\n             if (memcmp(e ->Name, L\"Name0\", sizeof(wchar_t) * 5) != 0) return 0;\n             if (e ->Value != NULL) return 0;\n             return 1;\n\n\n        default:;\n    }\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              5203,
              0
            ],
            [
              5244,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckDictionary16",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "cmsInt32Number CheckDictionary24(cmsInt32Number Pass,  cmsHPROFILE hProfile)\n{\n    cmsHANDLE hDict;\n    const cmsDICTentry* e;\n    cmsMLU* DisplayName;\n    char Buffer[256];\n    cmsInt32Number rc = 1;\n\n    switch (Pass) {\n\n    case 1:\n        hDict = cmsDictAlloc(DbgThread());\n\n        DisplayName = cmsMLUalloc(DbgThread(), 0);\n\n        cmsMLUsetWide(DisplayName, \"en\", \"US\", L\"Hello, world\");\n        cmsMLUsetWide(DisplayName, \"es\", \"ES\", L\"Hola, mundo\");\n        cmsMLUsetWide(DisplayName, \"fr\", \"FR\", L\"Bonjour, le monde\");\n        cmsMLUsetWide(DisplayName, \"ca\", \"CA\", L\"Hola, mon\");\n\n        cmsDictAddEntry(hDict, L\"Name\",  L\"String\", DisplayName, NULL);\n        cmsMLUfree(DisplayName);\n\n        cmsDictAddEntry(hDict, L\"Name2\", L\"12\",    NULL, NULL);\n        if (!cmsWriteTag(hProfile, cmsSigMetaTag, hDict)) return 0;\n        cmsDictFree(hDict);\n\n        return 1;\n\n\n    case 2:\n\n        hDict = cmsReadTag(hProfile, cmsSigMetaTag);\n        if (hDict == NULL) return 0;\n\n        e = cmsDictGetEntryList(hDict);\n        if (memcmp(e ->Name, L\"Name2\", sizeof(wchar_t) * 5) != 0) return 0;\n        if (memcmp(e ->Value, L\"12\",  sizeof(wchar_t) * 2) != 0) return 0;\n        e = cmsDictNextEntry(e);\n        if (memcmp(e ->Name, L\"Name\", sizeof(wchar_t) * 4) != 0) return 0;\n        if (memcmp(e ->Value, L\"String\",  sizeof(wchar_t) * 5) != 0) return 0;\n\n        cmsMLUgetASCII(e->DisplayName, \"en\", \"US\", Buffer, 256);\n        if (strcmp(Buffer, \"Hello, world\") != 0) rc = 0;\n\n\n        cmsMLUgetASCII(e->DisplayName, \"es\", \"ES\", Buffer, 256);\n        if (strcmp(Buffer, \"Hola, mundo\") != 0) rc = 0;\n\n\n        cmsMLUgetASCII(e->DisplayName, \"fr\", \"FR\", Buffer, 256);\n        if (strcmp(Buffer, \"Bonjour, le monde\") != 0) rc = 0;\n\n\n        cmsMLUgetASCII(e->DisplayName, \"ca\", \"CA\", Buffer, 256);\n        if (strcmp(Buffer, \"Hola, mon\") != 0) rc = 0;\n\n        if (rc == 0)\n            Fail(\"Unexpected string '%s'\", Buffer);\n        return 1;\n\n    default:;\n    }\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              5246,
              0
            ],
            [
              5311,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckDictionary24",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckRAWtags(cmsInt32Number Pass,  cmsHPROFILE hProfile)\n{\n    char Buffer[7];\n\n    switch (Pass) {\n\n        case 1:\n            return cmsWriteRawTag(hProfile, (cmsTagSignature) 0x31323334, \"data123\", 7); \n\n        case 2:\n            if (!cmsReadRawTag(hProfile, (cmsTagSignature) 0x31323334, Buffer, 7)) return 0; \n\n            if (memcmp(Buffer, \"data123\", 7) != 0) return 0;\n            return 1;\n\n        default:\n            return 0;\n    }\n}",
          "fn_code_pos": [
            [
              5313,
              0
            ],
            [
              5332,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckRAWtags",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check_cicp(cmsInt32Number Pass, cmsHPROFILE hProfile)\n{\n    cmsVideoSignalType* v;\n    cmsVideoSignalType  s;\n\n    switch (Pass) {\n\n    case 1:\n        s.ColourPrimaries = 1;\n        s.TransferCharacteristics = 13;\n        s.MatrixCoefficients = 0;\n        s.VideoFullRangeFlag = 1;\n        \n        if (!cmsWriteTag(hProfile, cmsSigcicpTag, &s)) return 0;\n        return 1;\n\n    case 2:\n        v = (cmsVideoSignalType*)cmsReadTag(hProfile, cmsSigcicpTag);\n        if (v == NULL) return 0;\n\n        if (v->ColourPrimaries != 1) return 0;\n        if (v->TransferCharacteristics != 13) return 0;\n        if (v->MatrixCoefficients != 0) return 0;\n        if (v->VideoFullRangeFlag != 1) return 0;\n        return 1;\n\n    default:\n        return 0;\n    }\n\n}",
          "fn_code_pos": [
            [
              5336,
              0
            ],
            [
              5367,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check_cicp",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid SetMHC2Matrix(cmsFloat64Number XYZ2XYZmatrix[3][4])\n{\n    XYZ2XYZmatrix[0][0] = 0.5; XYZ2XYZmatrix[0][1] = 0.1; XYZ2XYZmatrix[0][2] = 0.1; XYZ2XYZmatrix[0][3] = 0.0;\n    XYZ2XYZmatrix[1][0] = 0.0; XYZ2XYZmatrix[1][1] = 1.0; XYZ2XYZmatrix[1][2] = 0.0; XYZ2XYZmatrix[1][3] = 0.0;\n    XYZ2XYZmatrix[2][0] = 0.3; XYZ2XYZmatrix[2][1] = 0.2; XYZ2XYZmatrix[2][2] = 0.4; XYZ2XYZmatrix[2][3] = 0.0;\n}",
          "fn_code_pos": [
            [
              5370,
              0
            ],
            [
              5376,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetMHC2Matrix",
            "parameters": {
              "XYZ2XYZmatrix": "cmsFloat64Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsBool CloseEnough(cmsFloat64Number a, cmsFloat64Number b)\n{\n    return fabs(b - a) < (1.0 / 65535.0);\n}",
          "fn_code_pos": [
            [
              5378,
              0
            ],
            [
              5382,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CloseEnough",
            "parameters": {
              "a": "cmsFloat64Number",
              "b": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "cmsBool IsOriginalMHC2Matrix(cmsFloat64Number XYZ2XYZmatrix[3][4])\n{\n    cmsFloat64Number m[3][4];\n    int i, j;\n\n    SetMHC2Matrix(m);\n\n    for (i = 0; i < 3; i++)\n        for (j = 0; j < 4; j++)\n            if (!CloseEnough(XYZ2XYZmatrix[i][j], m[i][j])) return FALSE;\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              5384,
              0
            ],
            [
              5396,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsOriginalMHC2Matrix",
            "parameters": {
              "XYZ2XYZmatrix": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check_MHC2(cmsInt32Number Pass, cmsHPROFILE hProfile)\n{\n    cmsMHC2Type* v;\n    cmsMHC2Type  s;\n    double curve[] = { 0, 0.5, 1.0 };\n\n    switch (Pass) {\n\n    case 1:\n        SetMHC2Matrix(s.XYZ2XYZmatrix);\n        s.CurveEntries = 3;\n        s.GreenCurve = curve;\n        s.RedCurve = curve;\n        s.BlueCurve = curve;\n        s.MinLuminance = 0.1;\n        s.PeakLuminance = 100.0;\n        \n        if (!cmsWriteTag(hProfile, cmsSigMHC2Tag, &s)) return 0;\n        return 1;\n\n    case 2:\n        v = (cmsMHC2Type*)cmsReadTag(hProfile, cmsSigMHC2Tag);\n        if (v == NULL) return 0;\n\n        if (!IsOriginalMHC2Matrix(v->XYZ2XYZmatrix)) return 0;\n        if (v->CurveEntries != 3) return 0;\n        return 1;\n\n    default:\n        return 0;\n    }\n\n}",
          "fn_code_pos": [
            [
              5399,
              0
            ],
            [
              5432,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check_MHC2",
            "parameters": {
              "Pass": "cmsInt32Number",
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckProfileCreation(void)\n{\n    cmsHPROFILE h;\n    cmsInt32Number Pass;\n\n    h = cmsCreateProfilePlaceholder(DbgThread());\n    if (h == NULL) return 0;\n\n    cmsSetProfileVersion(h, 4.3);\n    if (cmsGetTagCount(h) != 0) { Fail(\"Empty profile with nonzero number of tags\"); goto Error; }\n    if (cmsIsTag(h, cmsSigAToB0Tag)) { Fail(\"Found a tag in an empty profile\"); goto Error; }\n\n    cmsSetColorSpace(h, cmsSigRgbData);\n    if (cmsGetColorSpace(h) !=  cmsSigRgbData) { Fail(\"Unable to set colorspace\"); goto Error; }\n\n    cmsSetPCS(h, cmsSigLabData);\n    if (cmsGetPCS(h) !=  cmsSigLabData) { Fail(\"Unable to set colorspace\"); goto Error; }\n\n    cmsSetDeviceClass(h, cmsSigDisplayClass);\n    if (cmsGetDeviceClass(h) != cmsSigDisplayClass) { Fail(\"Unable to set deviceclass\"); goto Error; }\n\n    cmsSetHeaderRenderingIntent(h, INTENT_SATURATION);\n    if (cmsGetHeaderRenderingIntent(h) != INTENT_SATURATION) { Fail(\"Unable to set rendering intent\"); goto Error; }\n\n    for (Pass = 1; Pass <= 2; Pass++) {\n\n        SubTest(\"Tags holding XYZ\");\n\n        if (!CheckXYZ(Pass, h, cmsSigBlueColorantTag)) goto Error;\n        if (!CheckXYZ(Pass, h, cmsSigGreenColorantTag)) goto Error;\n        if (!CheckXYZ(Pass, h, cmsSigRedColorantTag)) goto Error;\n        if (!CheckXYZ(Pass, h, cmsSigMediaBlackPointTag)) goto Error;\n        if (!CheckXYZ(Pass, h, cmsSigMediaWhitePointTag)) goto Error;\n        if (!CheckXYZ(Pass, h, cmsSigLuminanceTag)) goto Error;\n\n        SubTest(\"Tags holding curves\");\n\n        if (!CheckGamma(Pass, h, cmsSigBlueTRCTag)) goto Error;\n        if (!CheckGamma(Pass, h, cmsSigGrayTRCTag)) goto Error;\n        if (!CheckGamma(Pass, h, cmsSigGreenTRCTag)) goto Error;\n        if (!CheckGamma(Pass, h, cmsSigRedTRCTag)) goto Error;\n\n        SubTest(\"Tags holding text\");\n\n        if (!CheckTextSingle(Pass, h, cmsSigCharTargetTag)) goto Error;\n        if (!CheckTextSingle(Pass, h, cmsSigScreeningDescTag)) goto Error;\n\n        if (!CheckText(Pass, h, cmsSigCopyrightTag)) goto Error;\n        if (!CheckText(Pass, h, cmsSigProfileDescriptionTag)) goto Error;\n        if (!CheckText(Pass, h, cmsSigDeviceMfgDescTag)) goto Error;\n        if (!CheckText(Pass, h, cmsSigDeviceModelDescTag)) goto Error;\n        if (!CheckText(Pass, h, cmsSigViewingCondDescTag)) goto Error;\n\n     \n\n        SubTest(\"Tags holding cmsICCData\");\n\n        if (!CheckData(Pass, h, cmsSigPs2CRD0Tag)) goto Error;\n        if (!CheckData(Pass, h, cmsSigPs2CRD1Tag)) goto Error;\n        if (!CheckData(Pass, h, cmsSigPs2CRD2Tag)) goto Error;\n        if (!CheckData(Pass, h, cmsSigPs2CRD3Tag)) goto Error;\n        if (!CheckData(Pass, h, cmsSigPs2CSATag)) goto Error;\n        if (!CheckData(Pass, h, cmsSigPs2RenderingIntentTag)) goto Error;\n\n        SubTest(\"Tags holding signatures\");\n\n        if (!CheckSignature(Pass, h, cmsSigColorimetricIntentImageStateTag)) goto Error;\n        if (!CheckSignature(Pass, h, cmsSigPerceptualRenderingIntentGamutTag)) goto Error;\n        if (!CheckSignature(Pass, h, cmsSigSaturationRenderingIntentGamutTag)) goto Error;\n        if (!CheckSignature(Pass, h, cmsSigTechnologyTag)) goto Error;\n\n        SubTest(\"Tags holding date_time\");\n\n        if (!CheckDateTime(Pass, h, cmsSigCalibrationDateTimeTag)) goto Error;\n        if (!CheckDateTime(Pass, h, cmsSigDateTimeTag)) goto Error;\n\n        SubTest(\"Tags holding named color lists\");\n\n        if (!CheckNamedColor(Pass, h, cmsSigColorantTableTag, 15, FALSE)) goto Error;\n        if (!CheckNamedColor(Pass, h, cmsSigColorantTableOutTag, 15, FALSE)) goto Error;\n        if (!CheckNamedColor(Pass, h, cmsSigNamedColor2Tag, 4096, TRUE)) goto Error;\n\n        SubTest(\"Tags holding LUTs\");\n\n        if (!CheckLUT(Pass, h, cmsSigAToB0Tag)) goto Error;\n        if (!CheckLUT(Pass, h, cmsSigAToB1Tag)) goto Error;\n        if (!CheckLUT(Pass, h, cmsSigAToB2Tag)) goto Error;\n        if (!CheckLUT(Pass, h, cmsSigBToA0Tag)) goto Error;\n        if (!CheckLUT(Pass, h, cmsSigBToA1Tag)) goto Error;\n        if (!CheckLUT(Pass, h, cmsSigBToA2Tag)) goto Error;\n        if (!CheckLUT(Pass, h, cmsSigPreview0Tag)) goto Error;\n        if (!CheckLUT(Pass, h, cmsSigPreview1Tag)) goto Error;\n        if (!CheckLUT(Pass, h, cmsSigPreview2Tag)) goto Error;\n        if (!CheckLUT(Pass, h, cmsSigGamutTag)) goto Error;\n\n        SubTest(\"Tags holding CHAD\");\n        if (!CheckCHAD(Pass, h, cmsSigChromaticAdaptationTag)) goto Error;\n\n        SubTest(\"Tags holding Chromaticity\");\n        if (!CheckChromaticity(Pass, h, cmsSigChromaticityTag)) goto Error;\n\n        SubTest(\"Tags holding colorant order\");\n        if (!CheckColorantOrder(Pass, h, cmsSigColorantOrderTag)) goto Error;\n\n        SubTest(\"Tags holding measurement\");\n        if (!CheckMeasurement(Pass, h, cmsSigMeasurementTag)) goto Error;\n\n        SubTest(\"Tags holding CRD info\");\n        if (!CheckCRDinfo(Pass, h, cmsSigCrdInfoTag)) goto Error;\n\n        SubTest(\"Tags holding UCR/BG\");\n        if (!CheckUcrBg(Pass, h, cmsSigUcrBgTag)) goto Error;\n\n        SubTest(\"Tags holding MPE\");\n        if (!CheckMPE(Pass, h, cmsSigDToB0Tag)) goto Error;\n        if (!CheckMPE(Pass, h, cmsSigDToB1Tag)) goto Error;\n        if (!CheckMPE(Pass, h, cmsSigDToB2Tag)) goto Error;\n        if (!CheckMPE(Pass, h, cmsSigDToB3Tag)) goto Error;\n        if (!CheckMPE(Pass, h, cmsSigBToD0Tag)) goto Error;\n        if (!CheckMPE(Pass, h, cmsSigBToD1Tag)) goto Error;\n        if (!CheckMPE(Pass, h, cmsSigBToD2Tag)) goto Error;\n        if (!CheckMPE(Pass, h, cmsSigBToD3Tag)) goto Error;\n\n        SubTest(\"Tags using screening\");\n        if (!CheckScreening(Pass, h, cmsSigScreeningTag)) goto Error;\n\n        SubTest(\"Tags holding profile sequence description\");\n        if (!CheckProfileSequenceTag(Pass, h)) goto Error;\n        if (!CheckProfileSequenceIDTag(Pass, h)) goto Error;\n\n        SubTest(\"Tags holding ICC viewing conditions\");\n        if (!CheckICCViewingConditions(Pass, h)) goto Error;\n\n        SubTest(\"VCGT tags\");\n        if (!CheckVCGT(Pass, h)) goto Error;\n\n        SubTest(\"RAW tags\");\n        if (!CheckRAWtags(Pass, h)) goto Error;\n\n        SubTest(\"Dictionary meta tags\");\n        // if (!CheckDictionary16(Pass, h)) goto Error;\n        if (!CheckDictionary24(Pass, h)) goto Error;\n\n        SubTest(\"cicp Video Signal Type\");\n        if (!Check_cicp(Pass, h)) goto Error;\n\n        SubTest(\"Microsoft MHC2 tag\");\n        if (!Check_MHC2(Pass, h)) goto Error;\n\n\n        if (Pass == 1) {\n            cmsSaveProfileToFile(h, \"alltags.icc\");\n            cmsCloseProfile(h);\n            h = cmsOpenProfileFromFileTHR(DbgThread(), \"alltags.icc\", \"r\");\n        }\n\n    }\n\n    /*\n    Not implemented (by design):\n\n    cmsSigDataTag                           = 0x64617461,  // 'data'  -- Unused\n    cmsSigDeviceSettingsTag                 = 0x64657673,  // 'devs'  -- Unused\n    cmsSigNamedColorTag                     = 0x6E636f6C,  // 'ncol'  -- Don't use this one, deprecated by ICC\n    cmsSigOutputResponseTag                 = 0x72657370,  // 'resp'  -- Possible patent on this\n    */\n\n    cmsCloseProfile(h);\n    remove(\"alltags.icc\");\n    return 1;\n\nError:\n    cmsCloseProfile(h);\n    remove(\"alltags.icc\");\n    return 0;\n}",
          "fn_code_pos": [
            [
              5436,
              0
            ],
            [
              5612,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckProfileCreation",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckVersionHeaderWriting(void)\n{\n    cmsHPROFILE h;\n    int index;\n    float test_versions[] = {\n      2.3f,\n      4.08f,\n      4.09f,\n      4.3f\n    };\n\n    for (index = 0; index < sizeof(test_versions)/sizeof(test_versions[0]); index++) {\n\n      h = cmsCreateProfilePlaceholder(DbgThread());\n      if (h == NULL) return 0;\n\n      cmsSetProfileVersion(h, test_versions[index]);\n\n      cmsSaveProfileToFile(h, \"versions.icc\");\n      cmsCloseProfile(h);\n\n      h = cmsOpenProfileFromFileTHR(DbgThread(), \"versions.icc\", \"r\");\n\n      // Only the first 3 digits are significant\n      if (fabs(cmsGetProfileVersion(h) - test_versions[index]) > 0.005) {\n        Fail(\"Version failed to round-trip: wrote %.2f, read %.2f\",\n             test_versions[index], cmsGetProfileVersion(h));\n        return 0;\n      }\n\n      cmsCloseProfile(h);\n      remove(\"versions.icc\");\n    }\n    return 1;\n}",
          "fn_code_pos": [
            [
              5616,
              0
            ],
            [
              5651,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckVersionHeaderWriting",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckMultilocalizedProfile(void)\n{\n    cmsHPROFILE hProfile;\n    cmsMLU *Pt;\n    char Buffer[256];\n\n    hProfile = cmsOpenProfileFromFile(\"crayons.icc\", \"r\");\n\n    Pt = (cmsMLU *) cmsReadTag(hProfile, cmsSigProfileDescriptionTag); \n    cmsMLUgetASCII(Pt, \"en\", \"GB\", Buffer, 256);\n    if (strcmp(Buffer, \"Crayon Colours\") != 0) return FALSE;\n    cmsMLUgetASCII(Pt, \"en\", \"US\", Buffer, 256);\n    if (strcmp(Buffer, \"Crayon Colors\") != 0) return FALSE;\n\n    cmsCloseProfile(hProfile);\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              5655,
              0
            ],
            [
              5673,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMultilocalizedProfile",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid ErrorReportingFunction(cmsContext ContextID, cmsUInt32Number ErrorCode, const char *Text)\n{\n    TrappedError = TRUE;\n    SimultaneousErrors++;\n    strncpy(ReasonToFailBuffer, Text, TEXT_ERROR_BUFFER_SIZE-1);\n\n    cmsUNUSED_PARAMETER(ContextID);\n    cmsUNUSED_PARAMETER(ErrorCode);\n}",
          "fn_code_pos": [
            [
              5679,
              0
            ],
            [
              5688,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ErrorReportingFunction",
            "parameters": {
              "ContextID": "cmsContext",
              "ErrorCode": "cmsUInt32Number",
              "Text": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckBadProfiles(void)\n{\n    cmsHPROFILE h;\n\n    h = cmsOpenProfileFromFileTHR(DbgThread(), \"IDoNotExist.icc\", \"r\");\n    if (h != NULL) {\n        cmsCloseProfile(h);\n        return 0;\n    }\n\n    h = cmsOpenProfileFromFileTHR(DbgThread(), \"IAmIllFormed*.icc\", \"r\");\n    if (h != NULL) {\n        cmsCloseProfile(h);\n        return 0;\n    }\n\n    // No profile name given\n    h = cmsOpenProfileFromFileTHR(DbgThread(), \"\", \"r\");\n    if (h != NULL) {\n        cmsCloseProfile(h);\n        return 0;\n    }\n\n    h = cmsOpenProfileFromFileTHR(DbgThread(), \"..\", \"r\");\n    if (h != NULL) {\n        cmsCloseProfile(h);\n        return 0;\n    }\n\n    h = cmsOpenProfileFromFileTHR(DbgThread(), \"IHaveBadAccessMode.icc\", \"@\");\n    if (h != NULL) {\n        cmsCloseProfile(h);\n        return 0;\n    }\n\n    h = cmsOpenProfileFromFileTHR(DbgThread(), \"bad.icc\", \"r\");\n    if (h != NULL) {\n        cmsCloseProfile(h);\n        return 0;\n    }\n\n     h = cmsOpenProfileFromFileTHR(DbgThread(), \"toosmall.icc\", \"r\");\n    if (h != NULL) {\n        cmsCloseProfile(h);\n        return 0;\n    }\n\n    h = cmsOpenProfileFromMemTHR(DbgThread(), NULL, 3);\n    if (h != NULL) {\n        cmsCloseProfile(h);\n        return 0;\n    }\n\n    h = cmsOpenProfileFromMemTHR(DbgThread(), \"123\", 3);\n    if (h != NULL) {\n        cmsCloseProfile(h);\n        return 0;\n    }\n\n    if (SimultaneousErrors != 9) return 0;\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              5691,
              0
            ],
            [
              5754,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckBadProfiles",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckErrReportingOnBadProfiles(void)\n{\n    cmsInt32Number rc;\n\n    cmsSetLogErrorHandler(ErrorReportingFunction);\n    rc = CheckBadProfiles();\n    cmsSetLogErrorHandler(FatalErrorQuit);\n\n    // Reset the error state\n    TrappedError = FALSE;\n    return rc;\n}",
          "fn_code_pos": [
            [
              5757,
              0
            ],
            [
              5769,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckErrReportingOnBadProfiles",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckBadTransforms(void)\n{\n    cmsHPROFILE h1 = cmsCreate_sRGBProfile();\n    cmsHTRANSFORM x1;\n\n    x1 = cmsCreateTransform(NULL, 0, NULL, 0, 0, 0);\n    if (x1 != NULL) {\n        cmsDeleteTransform(x1);\n        return 0;\n    }\n\n\n\n    x1 = cmsCreateTransform(h1, TYPE_RGB_8, h1, TYPE_RGB_8, 12345, 0);\n    if (x1 != NULL) {\n        cmsDeleteTransform(x1);\n        return 0;\n    }\n\n    x1 = cmsCreateTransform(h1, TYPE_CMYK_8, h1, TYPE_RGB_8, 0, 0);\n    if (x1 != NULL) {\n        cmsDeleteTransform(x1);\n        return 0;\n    }\n\n    x1 = cmsCreateTransform(h1, TYPE_RGB_8, h1, TYPE_CMYK_8, 1, 0);\n    if (x1 != NULL) {\n        cmsDeleteTransform(x1);\n        return 0;\n    }\n\n    // sRGB does its output as XYZ!\n    x1 = cmsCreateTransform(h1, TYPE_RGB_8, NULL, TYPE_Lab_8, 1, 0);\n    if (x1 != NULL) {\n        cmsDeleteTransform(x1);\n        return 0;\n    }\n\n    cmsCloseProfile(h1);\n\n\n    {\n\n    cmsHPROFILE hp1 = cmsOpenProfileFromFile(\"test1.icc\", \"r\");\n    cmsHPROFILE hp2 = cmsCreate_sRGBProfile();\n\n    x1 = cmsCreateTransform(hp1, TYPE_BGR_8, hp2, TYPE_BGR_8, INTENT_PERCEPTUAL, 0);\n\n    cmsCloseProfile(hp1); cmsCloseProfile(hp2);\n    if (x1 != NULL) {\n        cmsDeleteTransform(x1);\n        return 0;\n    }\n    }\n\n    return 1;\n\n}",
          "fn_code_pos": [
            [
              5772,
              0
            ],
            [
              5830,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckBadTransforms",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckErrReportingOnBadTransforms(void)\n{\n    cmsInt32Number rc;\n\n    cmsSetLogErrorHandler(ErrorReportingFunction);\n    rc = CheckBadTransforms();\n    cmsSetLogErrorHandler(FatalErrorQuit);\n\n    // Reset the error state\n    TrappedError = FALSE;\n    return rc;\n}",
          "fn_code_pos": [
            [
              5832,
              0
            ],
            [
              5844,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckErrReportingOnBadTransforms",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check8linearXFORM(cmsHTRANSFORM xform, cmsInt32Number nChan)\n{\n    cmsInt32Number n2, i, j;\n    cmsUInt8Number Inw[cmsMAXCHANNELS], Outw[cmsMAXCHANNELS];\n\n    n2=0;\n\n    for (j=0; j < 0xFF; j++) {\n\n        memset(Inw, j, sizeof(Inw));\n        cmsDoTransform(xform, Inw, Outw, 1);\n\n        for (i=0; i < nChan; i++) {\n\n           cmsInt32Number dif = abs(Outw[i] - j);\n           if (dif > n2) n2 = dif;\n\n        }\n    }\n\n   // We allow 2 contone of difference on 8 bits\n    if (n2 > 2) {\n\n        Fail(\"Differences too big (%x)\", n2);\n        return 0;\n    }\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              5852,
              0
            ],
            [
              5881,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check8linearXFORM",
            "parameters": {
              "xform": "cmsHTRANSFORM",
              "nChan": "cmsInt32Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Compare8bitXFORM(cmsHTRANSFORM xform1, cmsHTRANSFORM xform2, cmsInt32Number nChan)\n{\n    cmsInt32Number n2, i, j;\n    cmsUInt8Number Inw[cmsMAXCHANNELS], Outw1[cmsMAXCHANNELS], Outw2[cmsMAXCHANNELS];;\n\n    n2=0;\n\n    for (j=0; j < 0xFF; j++) {\n\n        memset(Inw, j, sizeof(Inw));\n        cmsDoTransform(xform1, Inw, Outw1, 1);\n        cmsDoTransform(xform2, Inw, Outw2, 1);\n\n        for (i=0; i < nChan; i++) {\n\n           cmsInt32Number dif = abs(Outw2[i] - Outw1[i]);\n           if (dif > n2) n2 = dif;\n\n        }\n    }\n\n   // We allow 2 contone of difference on 8 bits\n    if (n2 > 2) {\n\n        Fail(\"Differences too big (%x)\", n2);\n        return 0;\n    }\n\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              5883,
              0
            ],
            [
              5914,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Compare8bitXFORM",
            "parameters": {
              "xform1": "cmsHTRANSFORM",
              "xform2": "cmsHTRANSFORM",
              "nChan": "cmsInt32Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Check16linearXFORM(cmsHTRANSFORM xform, cmsInt32Number nChan)\n{\n    cmsInt32Number n2, i, j;\n    cmsUInt16Number Inw[cmsMAXCHANNELS], Outw[cmsMAXCHANNELS];\n\n    n2=0;\n    for (j=0; j < 0xFFFF; j++) {\n\n        for (i=0; i < nChan; i++) Inw[i] = (cmsUInt16Number) j;\n\n        cmsDoTransform(xform, Inw, Outw, 1);\n\n        for (i=0; i < nChan; i++) {\n\n           cmsInt32Number dif = abs(Outw[i] - j);\n           if (dif > n2) n2 = dif;\n\n        }\n\n\n   // We allow 2 contone of difference on 16 bits\n    if (n2 > 0x200) {\n\n        Fail(\"Differences too big (%x)\", n2);\n        return 0;\n    }\n    }\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              5918,
              0
            ],
            [
              5948,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check16linearXFORM",
            "parameters": {
              "xform": "cmsHTRANSFORM",
              "nChan": "cmsInt32Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Compare16bitXFORM(cmsHTRANSFORM xform1, cmsHTRANSFORM xform2, cmsInt32Number nChan)\n{\n    cmsInt32Number n2, i, j;\n    cmsUInt16Number Inw[cmsMAXCHANNELS], Outw1[cmsMAXCHANNELS], Outw2[cmsMAXCHANNELS];;\n\n    n2=0;\n\n    for (j=0; j < 0xFFFF; j++) {\n\n        for (i=0; i < nChan; i++) Inw[i] = (cmsUInt16Number) j;\n\n        cmsDoTransform(xform1, Inw, Outw1, 1);\n        cmsDoTransform(xform2, Inw, Outw2, 1);\n\n        for (i=0; i < nChan; i++) {\n\n           cmsInt32Number dif = abs(Outw2[i] - Outw1[i]);\n           if (dif > n2) n2 = dif;\n\n        }\n    }\n\n   // We allow 2 contone of difference on 16 bits\n    if (n2 > 0x200) {\n\n        Fail(\"Differences too big (%x)\", n2);\n        return 0;\n    }\n\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              5950,
              0
            ],
            [
              5982,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Compare16bitXFORM",
            "parameters": {
              "xform1": "cmsHTRANSFORM",
              "xform2": "cmsHTRANSFORM",
              "nChan": "cmsInt32Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckFloatlinearXFORM(cmsHTRANSFORM xform, cmsInt32Number nChan)\n{\n    cmsInt32Number i, j;\n    cmsFloat32Number In[cmsMAXCHANNELS], Out[cmsMAXCHANNELS];\n\n    for (j=0; j < 0xFFFF; j++) {\n\n        for (i=0; i < nChan; i++) In[i] = (cmsFloat32Number) (j / 65535.0);;\n\n        cmsDoTransform(xform, In, Out, 1);\n\n        for (i=0; i < nChan; i++) {\n\n           // We allow no difference in floating point\n            if (!IsGoodFixed15_16(\"linear xform cmsFloat32Number\", Out[i], (cmsFloat32Number) (j / 65535.0)))\n                return 0;\n        }\n    }\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              5986,
              0
            ],
            [
              6007,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckFloatlinearXFORM",
            "parameters": {
              "xform": "cmsHTRANSFORM",
              "nChan": "cmsInt32Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CompareFloatXFORM(cmsHTRANSFORM xform1, cmsHTRANSFORM xform2, cmsInt32Number nChan)\n{\n    cmsInt32Number i, j;\n    cmsFloat32Number In[cmsMAXCHANNELS], Out1[cmsMAXCHANNELS], Out2[cmsMAXCHANNELS];\n\n    for (j=0; j < 0xFFFF; j++) {\n\n        for (i=0; i < nChan; i++) In[i] = (cmsFloat32Number) (j / 65535.0);;\n\n        cmsDoTransform(xform1, In, Out1, 1);\n        cmsDoTransform(xform2, In, Out2, 1);\n\n        for (i=0; i < nChan; i++) {\n\n           // We allow no difference in floating point\n            if (!IsGoodFixed15_16(\"linear xform cmsFloat32Number\", Out1[i], Out2[i]))\n                return 0;\n        }\n\n    }\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              6011,
              0
            ],
            [
              6034,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CompareFloatXFORM",
            "parameters": {
              "xform1": "cmsHTRANSFORM",
              "xform2": "cmsHTRANSFORM",
              "nChan": "cmsInt32Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckCurvesOnlyTransforms(void)\n{\n\n    cmsHTRANSFORM xform1, xform2;\n    cmsHPROFILE h1, h2, h3;\n    cmsToneCurve* c1, *c2, *c3;\n    cmsInt32Number rc = 1;\n\n\n    c1 = cmsBuildGamma(DbgThread(), 2.2);\n    c2 = cmsBuildGamma(DbgThread(), 1/2.2);\n    c3 = cmsBuildGamma(DbgThread(), 4.84);\n\n    h1 = cmsCreateLinearizationDeviceLinkTHR(DbgThread(), cmsSigGrayData, &c1);\n    h2 = cmsCreateLinearizationDeviceLinkTHR(DbgThread(), cmsSigGrayData, &c2);\n    h3 = cmsCreateLinearizationDeviceLinkTHR(DbgThread(), cmsSigGrayData, &c3);\n\n    SubTest(\"Gray float optimizeable transform\");\n    xform1 = cmsCreateTransform(h1, TYPE_GRAY_FLT, h2, TYPE_GRAY_FLT, INTENT_PERCEPTUAL, 0);\n    rc &= CheckFloatlinearXFORM(xform1, 1);\n    cmsDeleteTransform(xform1);\n    if (rc == 0) goto Error;\n\n    SubTest(\"Gray 8 optimizeable transform\");\n    xform1 = cmsCreateTransform(h1, TYPE_GRAY_8, h2, TYPE_GRAY_8, INTENT_PERCEPTUAL, 0);\n    rc &= Check8linearXFORM(xform1, 1);\n    cmsDeleteTransform(xform1);\n    if (rc == 0) goto Error;\n\n    SubTest(\"Gray 16 optimizeable transform\");\n    xform1 = cmsCreateTransform(h1, TYPE_GRAY_16, h2, TYPE_GRAY_16, INTENT_PERCEPTUAL, 0);\n    rc &= Check16linearXFORM(xform1, 1);\n    cmsDeleteTransform(xform1);\n    if (rc == 0) goto Error;\n\n    SubTest(\"Gray float non-optimizeable transform\");\n    xform1 = cmsCreateTransform(h1, TYPE_GRAY_FLT, h1, TYPE_GRAY_FLT, INTENT_PERCEPTUAL, 0);\n    xform2 = cmsCreateTransform(h3, TYPE_GRAY_FLT, NULL, TYPE_GRAY_FLT, INTENT_PERCEPTUAL, 0);\n\n    rc &= CompareFloatXFORM(xform1, xform2, 1);\n    cmsDeleteTransform(xform1);\n    cmsDeleteTransform(xform2);\n    if (rc == 0) goto Error;\n\n    SubTest(\"Gray 8 non-optimizeable transform\");\n    xform1 = cmsCreateTransform(h1, TYPE_GRAY_8, h1, TYPE_GRAY_8, INTENT_PERCEPTUAL, 0);\n    xform2 = cmsCreateTransform(h3, TYPE_GRAY_8, NULL, TYPE_GRAY_8, INTENT_PERCEPTUAL, 0);\n\n    rc &= Compare8bitXFORM(xform1, xform2, 1);\n    cmsDeleteTransform(xform1);\n    cmsDeleteTransform(xform2);\n    if (rc == 0) goto Error;\n\n\n    SubTest(\"Gray 16 non-optimizeable transform\");\n    xform1 = cmsCreateTransform(h1, TYPE_GRAY_16, h1, TYPE_GRAY_16, INTENT_PERCEPTUAL, 0);\n    xform2 = cmsCreateTransform(h3, TYPE_GRAY_16, NULL, TYPE_GRAY_16, INTENT_PERCEPTUAL, 0);\n\n    rc &= Compare16bitXFORM(xform1, xform2, 1);\n    cmsDeleteTransform(xform1);\n    cmsDeleteTransform(xform2);\n    if (rc == 0) goto Error;\n\nError:\n\n    cmsCloseProfile(h1); cmsCloseProfile(h2); cmsCloseProfile(h3);\n    cmsFreeToneCurve(c1); cmsFreeToneCurve(c2); cmsFreeToneCurve(c3);\n\n    return rc;\n}",
          "fn_code_pos": [
            [
              6039,
              0
            ],
            [
              6109,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckCurvesOnlyTransforms",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckOneLab(cmsHTRANSFORM xform, cmsFloat64Number L, cmsFloat64Number a, cmsFloat64Number b)\n{\n    cmsCIELab In, Out;\n    cmsFloat64Number dE;\n\n    In.L = L; In.a = a; In.b = b;\n    cmsDoTransform(xform, &In, &Out, 1);\n\n    dE = cmsDeltaE(&In, &Out);\n\n    if (dE > MaxDE) MaxDE = dE;\n\n    if (MaxDE >  0.003) {\n        Fail(\"dE=%f Lab1=(%f, %f, %f)\\n\\tLab2=(%f %f %f)\", MaxDE, In.L, In.a, In.b, Out.L, Out.a, Out.b);\n        cmsDoTransform(xform, &In, &Out, 1);\n        return 0;\n    }\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              6117,
              0
            ],
            [
              6137,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckOneLab",
            "parameters": {
              "xform": "cmsHTRANSFORM",
              "L": "cmsFloat64Number",
              "a": "cmsFloat64Number",
              "b": "cmsFloat64Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckSeveralLab(cmsHTRANSFORM xform)\n{\n    cmsInt32Number L, a, b;\n\n    MaxDE = 0;\n    for (L=0; L < 65536; L += 1311) {\n\n        for (a = 0; a < 65536; a += 1232) {\n\n            for (b = 0; b < 65536; b += 1111) {\n\n                if (!CheckOneLab(xform, (L * 100.0) / 65535.0,\n                                        (a  / 257.0) - 128, (b / 257.0) - 128))\n                    return 0;\n            }\n\n        }\n\n    }\n    return 1;\n}",
          "fn_code_pos": [
            [
              6140,
              0
            ],
            [
              6161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckSeveralLab",
            "parameters": {
              "xform": "cmsHTRANSFORM"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number OneTrivialLab(cmsHPROFILE hLab1, cmsHPROFILE hLab2, const char* txt)\n{\n    cmsHTRANSFORM xform;\n    cmsInt32Number rc;\n\n    SubTest(txt);\n    xform = cmsCreateTransformTHR(DbgThread(), hLab1, TYPE_Lab_DBL, hLab2, TYPE_Lab_DBL, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(hLab1); cmsCloseProfile(hLab2);\n\n    rc = CheckSeveralLab(xform);\n    cmsDeleteTransform(xform);\n    return rc;\n}",
          "fn_code_pos": [
            [
              6164,
              0
            ],
            [
              6177,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OneTrivialLab",
            "parameters": {
              "hLab1": "cmsHPROFILE",
              "hLab2": "cmsHPROFILE",
              "txt": "char"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckFloatLabTransforms(void)\n{\n    return OneTrivialLab(cmsCreateLab4ProfileTHR(DbgThread(), NULL), cmsCreateLab4ProfileTHR(DbgThread(), NULL),  \"Lab4/Lab4\") &&\n           OneTrivialLab(cmsCreateLab2ProfileTHR(DbgThread(), NULL), cmsCreateLab2ProfileTHR(DbgThread(), NULL),  \"Lab2/Lab2\") &&\n           OneTrivialLab(cmsCreateLab4ProfileTHR(DbgThread(), NULL), cmsCreateLab2ProfileTHR(DbgThread(), NULL),  \"Lab4/Lab2\") &&\n           OneTrivialLab(cmsCreateLab2ProfileTHR(DbgThread(), NULL), cmsCreateLab4ProfileTHR(DbgThread(), NULL),  \"Lab2/Lab4\");\n}",
          "fn_code_pos": [
            [
              6180,
              0
            ],
            [
              6187,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckFloatLabTransforms",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckEncodedLabTransforms(void)\n{\n    cmsHTRANSFORM xform;\n    cmsUInt16Number In[3];\n    cmsUInt16Number wLab[3];\n    cmsCIELab Lab;\n    cmsCIELab White = { 100, 0, 0 };\n    cmsCIELab Color = { 7.11070, -76, 26 };\n    cmsHPROFILE hLab1 = cmsCreateLab4ProfileTHR(DbgThread(), NULL);\n    cmsHPROFILE hLab2 = cmsCreateLab4ProfileTHR(DbgThread(), NULL);\n\n\n    xform = cmsCreateTransformTHR(DbgThread(), hLab1, TYPE_Lab_16, hLab2, TYPE_Lab_DBL, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(hLab1); cmsCloseProfile(hLab2);\n\n    In[0] = 0xFFFF;\n    In[1] = 0x8080;\n    In[2] = 0x8080;\n\n    cmsDoTransform(xform, In, &Lab, 1);\n\n    if (cmsDeltaE(&Lab, &White) > 0.0001) return 0;\n    \n\n    In[0] = 0x1234;\n    In[1] = 0x3434;\n    In[2] = 0x9A9A;\n\n    cmsDoTransform(xform, In, &Lab, 1);\n    cmsFloat2LabEncoded(wLab, &Lab);\n    if (memcmp(In, wLab, sizeof(wLab)) != 0) return 0;\n    if (cmsDeltaE(&Lab, &Color) > 0.0001) return 0;\n\n\n    cmsDeleteTransform(xform);\n\n    hLab1 = cmsCreateLab2ProfileTHR(DbgThread(), NULL);\n    hLab2 = cmsCreateLab4ProfileTHR(DbgThread(), NULL);\n\n    xform = cmsCreateTransformTHR(DbgThread(), hLab1, TYPE_LabV2_16, hLab2, TYPE_Lab_DBL, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(hLab1); cmsCloseProfile(hLab2);\n\n    In[0] = 0xFF00;\n    In[1] = 0x8000;\n    In[2] = 0x8000;\n\n    cmsDoTransform(xform, In, &Lab, 1);\n\n    if (cmsDeltaE(&Lab, &White) > 0.0001) return 0;\n\n    cmsDeleteTransform(xform);\n\n    hLab2 = cmsCreateLab2ProfileTHR(DbgThread(), NULL);\n    hLab1 = cmsCreateLab4ProfileTHR(DbgThread(), NULL);\n\n    xform = cmsCreateTransformTHR(DbgThread(), hLab1, TYPE_Lab_DBL, hLab2, TYPE_LabV2_16, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(hLab1); cmsCloseProfile(hLab2);\n\n    Lab.L = 100;\n    Lab.a = 0;\n    Lab.b = 0;\n\n    cmsDoTransform(xform, &Lab, In, 1);\n    if (In[0] != 0xFF00 ||\n        In[1] != 0x8000 ||\n        In[2] != 0x8000) return 0;\n\n    cmsDeleteTransform(xform);\n\n    hLab1 = cmsCreateLab4ProfileTHR(DbgThread(), NULL);\n    hLab2 = cmsCreateLab4ProfileTHR(DbgThread(), NULL);\n\n    xform = cmsCreateTransformTHR(DbgThread(), hLab1, TYPE_Lab_DBL, hLab2, TYPE_Lab_16, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(hLab1); cmsCloseProfile(hLab2);\n\n    Lab.L = 100;\n    Lab.a = 0;\n    Lab.b = 0;\n\n    cmsDoTransform(xform, &Lab, In, 1);\n\n    if (In[0] != 0xFFFF ||\n        In[1] != 0x8080 ||\n        In[2] != 0x8080) return 0;\n\n    cmsDeleteTransform(xform);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              6190,
              0
            ],
            [
              6279,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckEncodedLabTransforms",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckStoredIdentities(void)\n{\n    cmsHPROFILE hLab, hLink, h4, h2;\n    cmsHTRANSFORM xform;\n    cmsInt32Number rc = 1;\n\n    hLab  = cmsCreateLab4ProfileTHR(DbgThread(), NULL);\n    xform = cmsCreateTransformTHR(DbgThread(), hLab, TYPE_Lab_8, hLab, TYPE_Lab_8, 0, 0);\n\n    hLink = cmsTransform2DeviceLink(xform, 3.4, 0);\n    cmsSaveProfileToFile(hLink, \"abstractv2.icc\");\n    cmsCloseProfile(hLink);\n\n    hLink = cmsTransform2DeviceLink(xform, 4.3, 0);\n    cmsSaveProfileToFile(hLink, \"abstractv4.icc\");\n    cmsCloseProfile(hLink);\n\n    cmsDeleteTransform(xform);\n    cmsCloseProfile(hLab);\n\n    h4 = cmsOpenProfileFromFileTHR(DbgThread(), \"abstractv4.icc\", \"r\");\n\n    xform = cmsCreateTransformTHR(DbgThread(), h4, TYPE_Lab_DBL, h4, TYPE_Lab_DBL, INTENT_RELATIVE_COLORIMETRIC, 0);\n\n    SubTest(\"V4\");\n    rc &= CheckSeveralLab(xform);\n\n    cmsDeleteTransform(xform);\n    cmsCloseProfile(h4);\n    if (!rc) goto Error;\n\n\n    SubTest(\"V2\");\n    h2 = cmsOpenProfileFromFileTHR(DbgThread(), \"abstractv2.icc\", \"r\");\n\n    xform = cmsCreateTransformTHR(DbgThread(), h2, TYPE_Lab_DBL, h2, TYPE_Lab_DBL, INTENT_RELATIVE_COLORIMETRIC, 0);\n    rc &= CheckSeveralLab(xform);\n    cmsDeleteTransform(xform);\n    cmsCloseProfile(h2);\n    if (!rc) goto Error;\n\n\n    SubTest(\"V2 -> V4\");\n    h2 = cmsOpenProfileFromFileTHR(DbgThread(), \"abstractv2.icc\", \"r\");\n    h4 = cmsOpenProfileFromFileTHR(DbgThread(), \"abstractv4.icc\", \"r\");\n\n    xform = cmsCreateTransformTHR(DbgThread(), h4, TYPE_Lab_DBL, h2, TYPE_Lab_DBL, INTENT_RELATIVE_COLORIMETRIC, 0);\n    rc &= CheckSeveralLab(xform);\n    cmsDeleteTransform(xform);\n    cmsCloseProfile(h2);\n    cmsCloseProfile(h4);\n\n    SubTest(\"V4 -> V2\");\n    h2 = cmsOpenProfileFromFileTHR(DbgThread(), \"abstractv2.icc\", \"r\");\n    h4 = cmsOpenProfileFromFileTHR(DbgThread(), \"abstractv4.icc\", \"r\");\n\n    xform = cmsCreateTransformTHR(DbgThread(), h2, TYPE_Lab_DBL, h4, TYPE_Lab_DBL, INTENT_RELATIVE_COLORIMETRIC, 0);\n    rc &= CheckSeveralLab(xform);\n    cmsDeleteTransform(xform);\n    cmsCloseProfile(h2);\n    cmsCloseProfile(h4);\n\nError:\n    remove(\"abstractv2.icc\");\n    remove(\"abstractv4.icc\");\n    return rc;\n\n}",
          "fn_code_pos": [
            [
              6281,
              0
            ],
            [
              6349,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckStoredIdentities",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckMatrixShaperXFORMFloat(void)\n{\n    cmsHPROFILE hAbove, hSRGB;\n    cmsHTRANSFORM xform;\n    cmsInt32Number rc1, rc2;\n\n    hAbove = Create_AboveRGB();\n    xform = cmsCreateTransformTHR(DbgThread(), hAbove, TYPE_RGB_FLT, hAbove, TYPE_RGB_FLT,  INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(hAbove);\n    rc1 = CheckFloatlinearXFORM(xform, 3);\n    cmsDeleteTransform(xform);\n\n    hSRGB = cmsCreate_sRGBProfileTHR(DbgThread());\n    xform = cmsCreateTransformTHR(DbgThread(), hSRGB, TYPE_RGB_FLT, hSRGB, TYPE_RGB_FLT,  INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(hSRGB);\n    rc2 = CheckFloatlinearXFORM(xform, 3);\n    cmsDeleteTransform(xform);\n\n\n    return rc1 && rc2;\n}",
          "fn_code_pos": [
            [
              6354,
              0
            ],
            [
              6375,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMatrixShaperXFORMFloat",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckMatrixShaperXFORM16(void)\n{\n    cmsHPROFILE hAbove, hSRGB;\n    cmsHTRANSFORM xform;\n    cmsInt32Number rc1, rc2;\n\n    hAbove = Create_AboveRGB();\n    xform = cmsCreateTransformTHR(DbgThread(), hAbove, TYPE_RGB_16, hAbove, TYPE_RGB_16,  INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(hAbove);\n\n    rc1 = Check16linearXFORM(xform, 3);\n    cmsDeleteTransform(xform);\n\n    hSRGB = cmsCreate_sRGBProfileTHR(DbgThread());\n    xform = cmsCreateTransformTHR(DbgThread(), hSRGB, TYPE_RGB_16, hSRGB, TYPE_RGB_16,  INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(hSRGB);\n    rc2 = Check16linearXFORM(xform, 3);\n    cmsDeleteTransform(xform);\n\n    return rc1 && rc2;\n\n}",
          "fn_code_pos": [
            [
              6378,
              0
            ],
            [
              6400,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMatrixShaperXFORM16",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckMatrixShaperXFORM8(void)\n{\n    cmsHPROFILE hAbove, hSRGB;\n    cmsHTRANSFORM xform;\n    cmsInt32Number rc1, rc2;\n\n    hAbove = Create_AboveRGB();\n    xform = cmsCreateTransformTHR(DbgThread(), hAbove, TYPE_RGB_8, hAbove, TYPE_RGB_8,  INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(hAbove);\n    rc1 = Check8linearXFORM(xform, 3);\n    cmsDeleteTransform(xform);\n\n    hSRGB = cmsCreate_sRGBProfileTHR(DbgThread());\n    xform = cmsCreateTransformTHR(DbgThread(), hSRGB, TYPE_RGB_8, hSRGB, TYPE_RGB_8,  INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(hSRGB);\n    rc2 = Check8linearXFORM(xform, 3);\n    cmsDeleteTransform(xform);\n\n\n    return rc1 && rc2;\n}",
          "fn_code_pos": [
            [
              6404,
              0
            ],
            [
              6425,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMatrixShaperXFORM8",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckOneRGB_f(cmsHTRANSFORM xform, cmsInt32Number R, cmsInt32Number G, cmsInt32Number B, cmsFloat64Number X, cmsFloat64Number Y, cmsFloat64Number Z, cmsFloat64Number err)\n{\n    cmsFloat32Number RGB[3];\n    cmsFloat64Number Out[3];\n\n    RGB[0] = (cmsFloat32Number) (R / 255.0);\n    RGB[1] = (cmsFloat32Number) (G / 255.0);\n    RGB[2] = (cmsFloat32Number) (B / 255.0);\n\n    cmsDoTransform(xform, RGB, Out, 1);\n\n    return IsGoodVal(\"X\", X , Out[0], err) &&\n           IsGoodVal(\"Y\", Y , Out[1], err) &&\n           IsGoodVal(\"Z\", Z , Out[2], err);\n}",
          "fn_code_pos": [
            [
              6439,
              0
            ],
            [
              6454,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckOneRGB_f",
            "parameters": {
              "xform": "cmsHTRANSFORM",
              "R": "cmsInt32Number",
              "G": "cmsInt32Number",
              "B": "cmsInt32Number",
              "X": "cmsFloat64Number",
              "Y": "cmsFloat64Number",
              "Z": "cmsFloat64Number",
              "err": "cmsFloat64Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number Chack_sRGB_Float(void)\n{\n    cmsHPROFILE hsRGB, hXYZ, hLab;\n    cmsHTRANSFORM xform1, xform2;\n    cmsInt32Number rc;\n\n\n    hsRGB = cmsCreate_sRGBProfileTHR(DbgThread());\n    hXYZ  = cmsCreateXYZProfileTHR(DbgThread());\n    hLab  = cmsCreateLab4ProfileTHR(DbgThread(), NULL);\n\n    xform1 =  cmsCreateTransformTHR(DbgThread(), hsRGB, TYPE_RGB_FLT, hXYZ, TYPE_XYZ_DBL,\n                                INTENT_RELATIVE_COLORIMETRIC, 0);\n\n    xform2 =  cmsCreateTransformTHR(DbgThread(), hsRGB, TYPE_RGB_FLT, hLab, TYPE_Lab_DBL,\n                                INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(hsRGB);\n    cmsCloseProfile(hXYZ);\n    cmsCloseProfile(hLab);\n\n    MaxErr = 0;\n\n    // Xform 1 goes from 8 bits to XYZ,\n    rc  = CheckOneRGB_f(xform1, 1, 1, 1,        0.0002927, 0.0003035,  0.000250,  0.0001);\n    rc  &= CheckOneRGB_f(xform1, 127, 127, 127, 0.2046329, 0.212230,   0.175069,  0.0001);\n    rc  &= CheckOneRGB_f(xform1, 12, 13, 15,    0.0038364, 0.0039928,  0.003853,  0.0001);\n    rc  &= CheckOneRGB_f(xform1, 128, 0, 0,     0.0941240, 0.0480256,  0.003005,  0.0001);\n    rc  &= CheckOneRGB_f(xform1, 190, 25, 210,  0.3204592, 0.1605926,  0.468213,  0.0001);\n\n    // Xform 2 goes from 8 bits to Lab, we allow 0.01 error max\n    rc  &= CheckOneRGB_f(xform2, 1, 1, 1,       0.2741748, 0, 0,                   0.01);\n    rc  &= CheckOneRGB_f(xform2, 127, 127, 127, 53.192776, 0, 0,                   0.01);\n    rc  &= CheckOneRGB_f(xform2, 190, 25, 210,  47.052136, 74.565610, -56.883274,  0.01);\n    rc  &= CheckOneRGB_f(xform2, 128, 0, 0,     26.164701, 48.478171, 39.4384713,  0.01);\n\n    cmsDeleteTransform(xform1);\n    cmsDeleteTransform(xform2);\n    return rc;\n}",
          "fn_code_pos": [
            [
              6456,
              0
            ],
            [
              6495,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Chack_sRGB_Float",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsBool GetProfileRGBPrimaries(cmsHPROFILE hProfile,\n                                cmsCIEXYZTRIPLE *result,\n                                cmsUInt32Number intent)\n{\n    cmsHPROFILE hXYZ;\n    cmsHTRANSFORM hTransform;\n    cmsFloat64Number rgb[3][3] = {{1., 0., 0.},\n    {0., 1., 0.},\n    {0., 0., 1.}};\n\n    hXYZ = cmsCreateXYZProfile();\n    if (hXYZ == NULL) return FALSE;\n\n    hTransform = cmsCreateTransform(hProfile, TYPE_RGB_DBL, hXYZ, TYPE_XYZ_DBL,\n        intent, cmsFLAGS_NOCACHE | cmsFLAGS_NOOPTIMIZE);\n    cmsCloseProfile(hXYZ);\n    if (hTransform == NULL) return FALSE;\n\n    cmsDoTransform(hTransform, rgb, result, 3);\n    cmsDeleteTransform(hTransform);\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              6500,
              0
            ],
            [
              6522,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetProfileRGBPrimaries",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "result": "cmsCIEXYZTRIPLE",
              "intent": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "static\nint CheckRGBPrimaries(void)\n{\n    cmsHPROFILE hsRGB;\n    cmsCIEXYZTRIPLE tripXYZ;\n    cmsCIExyYTRIPLE tripxyY;\n    cmsBool result;\n\n    cmsSetAdaptationState(0);\n    hsRGB = cmsCreate_sRGBProfileTHR(DbgThread());\n    if (!hsRGB) return 0;\n\n    result = GetProfileRGBPrimaries(hsRGB, &tripXYZ,\n        INTENT_ABSOLUTE_COLORIMETRIC);\n\n    cmsCloseProfile(hsRGB);\n    if (!result) return 0;\n\n    cmsXYZ2xyY(&tripxyY.Red, &tripXYZ.Red);\n    cmsXYZ2xyY(&tripxyY.Green, &tripXYZ.Green);\n    cmsXYZ2xyY(&tripxyY.Blue, &tripXYZ.Blue);\n\n    /* values were taken from\n    http://en.wikipedia.org/wiki/RGB_color_spaces#Specifications */\n\n    if (!IsGoodFixed15_16(\"xRed\", tripxyY.Red.x, 0.64) ||\n        !IsGoodFixed15_16(\"yRed\", tripxyY.Red.y, 0.33) ||\n        !IsGoodFixed15_16(\"xGreen\", tripxyY.Green.x, 0.30) ||\n        !IsGoodFixed15_16(\"yGreen\", tripxyY.Green.y, 0.60) ||\n        !IsGoodFixed15_16(\"xBlue\", tripxyY.Blue.x, 0.15) ||\n        !IsGoodFixed15_16(\"yBlue\", tripxyY.Blue.y, 0.06)) {\n            Fail(\"One or more primaries are wrong.\");\n            return FALSE;\n    }\n\n    return TRUE;\n}",
          "fn_code_pos": [
            [
              6525,
              0
            ],
            [
              6561,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckRGBPrimaries",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckCMYK(cmsInt32Number Intent, const char *Profile1, const char* Profile2)\n{\n    cmsHPROFILE hSWOP  = cmsOpenProfileFromFileTHR(DbgThread(), Profile1, \"r\");\n    cmsHPROFILE hFOGRA = cmsOpenProfileFromFileTHR(DbgThread(), Profile2, \"r\");\n    cmsHTRANSFORM xform, swop_lab, fogra_lab;\n    cmsFloat32Number CMYK1[4], CMYK2[4];\n    cmsCIELab Lab1, Lab2;\n    cmsHPROFILE hLab;\n    cmsFloat64Number DeltaL, Max;\n    cmsInt32Number i;\n\n    hLab = cmsCreateLab4ProfileTHR(DbgThread(), NULL);\n\n    xform = cmsCreateTransformTHR(DbgThread(), hSWOP, TYPE_CMYK_FLT, hFOGRA, TYPE_CMYK_FLT, Intent, 0);\n\n    swop_lab = cmsCreateTransformTHR(DbgThread(), hSWOP,   TYPE_CMYK_FLT, hLab, TYPE_Lab_DBL, Intent, 0);\n    fogra_lab = cmsCreateTransformTHR(DbgThread(), hFOGRA, TYPE_CMYK_FLT, hLab, TYPE_Lab_DBL, Intent, 0);\n\n    Max = 0;\n    for (i=0; i <= 100; i++) {\n\n        CMYK1[0] = 10;\n        CMYK1[1] = 20;\n        CMYK1[2] = 30;\n        CMYK1[3] = (cmsFloat32Number) i;\n\n        cmsDoTransform(swop_lab, CMYK1, &Lab1, 1);\n        cmsDoTransform(xform, CMYK1, CMYK2, 1);\n        cmsDoTransform(fogra_lab, CMYK2, &Lab2, 1);\n\n        DeltaL = fabs(Lab1.L - Lab2.L);\n\n        if (DeltaL > Max) Max = DeltaL;\n    }\n\n\n    cmsDeleteTransform(xform);\n\n\n    xform = cmsCreateTransformTHR(DbgThread(),  hFOGRA, TYPE_CMYK_FLT, hSWOP, TYPE_CMYK_FLT, Intent, 0);\n\n    for (i=0; i <= 100; i++) {\n        CMYK1[0] = 10;\n        CMYK1[1] = 20;\n        CMYK1[2] = 30;\n        CMYK1[3] = (cmsFloat32Number) i;\n\n        cmsDoTransform(fogra_lab, CMYK1, &Lab1, 1);\n        cmsDoTransform(xform, CMYK1, CMYK2, 1);\n        cmsDoTransform(swop_lab, CMYK2, &Lab2, 1);\n\n        DeltaL = fabs(Lab1.L - Lab2.L);\n\n        if (DeltaL > Max) Max = DeltaL;\n    }\n\n\n    cmsCloseProfile(hSWOP);\n    cmsCloseProfile(hFOGRA);\n    cmsCloseProfile(hLab);\n\n    cmsDeleteTransform(xform);\n    cmsDeleteTransform(swop_lab);\n    cmsDeleteTransform(fogra_lab);\n\n    return Max < 3.0;\n}",
          "fn_code_pos": [
            [
              6568,
              0
            ],
            [
              6635,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckCMYK",
            "parameters": {
              "Intent": "cmsInt32Number",
              "Profile1": "char",
              "Profile2": "char"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckCMYKRoundtrip(void)\n{\n    return CheckCMYK(INTENT_RELATIVE_COLORIMETRIC, \"test1.icc\", \"test1.icc\");\n}",
          "fn_code_pos": [
            [
              6637,
              0
            ],
            [
              6641,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckCMYKRoundtrip",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckCMYKPerceptual(void)\n{\n    return CheckCMYK(INTENT_PERCEPTUAL, \"test1.icc\", \"test2.icc\");\n}",
          "fn_code_pos": [
            [
              6644,
              0
            ],
            [
              6648,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckCMYKPerceptual",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckCMYKRelCol(void)\n{\n    return CheckCMYK(INTENT_RELATIVE_COLORIMETRIC, \"test1.icc\", \"test2.icc\");\n}",
          "fn_code_pos": [
            [
              6652,
              0
            ],
            [
              6656,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckCMYKRelCol",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckKOnlyBlackPreserving(void)\n{\n    cmsHPROFILE hSWOP  = cmsOpenProfileFromFileTHR(DbgThread(), \"test1.icc\", \"r\");\n    cmsHPROFILE hFOGRA = cmsOpenProfileFromFileTHR(DbgThread(), \"test2.icc\", \"r\");\n    cmsHTRANSFORM xform, swop_lab, fogra_lab;\n    cmsFloat32Number CMYK1[4], CMYK2[4];\n    cmsCIELab Lab1, Lab2;\n    cmsHPROFILE hLab;\n    cmsFloat64Number DeltaL, Max;\n    cmsInt32Number i;\n\n    hLab = cmsCreateLab4ProfileTHR(DbgThread(), NULL);\n\n    xform = cmsCreateTransformTHR(DbgThread(), hSWOP, TYPE_CMYK_FLT, hFOGRA, TYPE_CMYK_FLT, INTENT_PRESERVE_K_ONLY_PERCEPTUAL, 0);\n\n    swop_lab = cmsCreateTransformTHR(DbgThread(), hSWOP,   TYPE_CMYK_FLT, hLab, TYPE_Lab_DBL, INTENT_PERCEPTUAL, 0);\n    fogra_lab = cmsCreateTransformTHR(DbgThread(), hFOGRA, TYPE_CMYK_FLT, hLab, TYPE_Lab_DBL, INTENT_PERCEPTUAL, 0);\n\n    Max = 0;\n\n    for (i=0; i <= 100; i++) {\n        CMYK1[0] = 0;\n        CMYK1[1] = 0;\n        CMYK1[2] = 0;\n        CMYK1[3] = (cmsFloat32Number) i;\n\n        // SWOP CMYK to Lab1\n        cmsDoTransform(swop_lab, CMYK1, &Lab1, 1);\n\n        // SWOP To FOGRA using black preservation\n        cmsDoTransform(xform, CMYK1, CMYK2, 1);\n\n        // Obtained FOGRA CMYK to Lab2\n        cmsDoTransform(fogra_lab, CMYK2, &Lab2, 1);\n\n        // We care only on L*\n        DeltaL = fabs(Lab1.L - Lab2.L);\n\n        if (DeltaL > Max) Max = DeltaL;\n    }\n\n\n    cmsDeleteTransform(xform);\n\n    // dL should be below 3.0\n\n\n    // Same, but FOGRA to SWOP\n    xform = cmsCreateTransformTHR(DbgThread(), hFOGRA, TYPE_CMYK_FLT, hSWOP, TYPE_CMYK_FLT, INTENT_PRESERVE_K_ONLY_PERCEPTUAL, 0);\n\n    for (i=0; i <= 100; i++) {\n        CMYK1[0] = 0;\n        CMYK1[1] = 0;\n        CMYK1[2] = 0;\n        CMYK1[3] = (cmsFloat32Number) i;\n\n        cmsDoTransform(fogra_lab, CMYK1, &Lab1, 1);\n        cmsDoTransform(xform, CMYK1, CMYK2, 1);\n        cmsDoTransform(swop_lab, CMYK2, &Lab2, 1);\n\n        DeltaL = fabs(Lab1.L - Lab2.L);\n\n        if (DeltaL > Max) Max = DeltaL;\n    }\n\n\n    cmsCloseProfile(hSWOP);\n    cmsCloseProfile(hFOGRA);\n    cmsCloseProfile(hLab);\n\n    cmsDeleteTransform(xform);\n    cmsDeleteTransform(swop_lab);\n    cmsDeleteTransform(fogra_lab);\n\n    return Max < 3.0;\n}",
          "fn_code_pos": [
            [
              6660,
              0
            ],
            [
              6736,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckKOnlyBlackPreserving",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckKPlaneBlackPreserving(void)\n{\n    cmsHPROFILE hSWOP  = cmsOpenProfileFromFileTHR(DbgThread(), \"test1.icc\", \"r\");\n    cmsHPROFILE hFOGRA = cmsOpenProfileFromFileTHR(DbgThread(), \"test2.icc\", \"r\");\n    cmsHTRANSFORM xform, swop_lab, fogra_lab;\n    cmsFloat32Number CMYK1[4], CMYK2[4];\n    cmsCIELab Lab1, Lab2;\n    cmsHPROFILE hLab;\n    cmsFloat64Number DeltaE, Max;\n    cmsInt32Number i;\n\n    hLab = cmsCreateLab4ProfileTHR(DbgThread(), NULL);\n\n    xform = cmsCreateTransformTHR(DbgThread(), hSWOP, TYPE_CMYK_FLT, hFOGRA, TYPE_CMYK_FLT, INTENT_PERCEPTUAL, 0);\n\n    swop_lab = cmsCreateTransformTHR(DbgThread(), hSWOP,  TYPE_CMYK_FLT, hLab, TYPE_Lab_DBL, INTENT_PERCEPTUAL, 0);\n    fogra_lab = cmsCreateTransformTHR(DbgThread(), hFOGRA, TYPE_CMYK_FLT, hLab, TYPE_Lab_DBL, INTENT_PERCEPTUAL, 0);\n\n    Max = 0;\n\n    for (i=0; i <= 100; i++) {\n        CMYK1[0] = 0;\n        CMYK1[1] = 0;\n        CMYK1[2] = 0;\n        CMYK1[3] = (cmsFloat32Number) i;\n\n        cmsDoTransform(swop_lab, CMYK1, &Lab1, 1);\n        cmsDoTransform(xform, CMYK1, CMYK2, 1);\n        cmsDoTransform(fogra_lab, CMYK2, &Lab2, 1);\n\n        DeltaE = cmsDeltaE(&Lab1, &Lab2);\n\n        if (DeltaE > Max) Max = DeltaE;\n    }\n\n\n    cmsDeleteTransform(xform);\n\n    xform = cmsCreateTransformTHR(DbgThread(),  hFOGRA, TYPE_CMYK_FLT, hSWOP, TYPE_CMYK_FLT, INTENT_PRESERVE_K_PLANE_PERCEPTUAL, 0);\n\n    for (i=0; i <= 100; i++) {\n        CMYK1[0] = 30;\n        CMYK1[1] = 20;\n        CMYK1[2] = 10;\n        CMYK1[3] = (cmsFloat32Number) i;\n\n        cmsDoTransform(fogra_lab, CMYK1, &Lab1, 1);\n        cmsDoTransform(xform, CMYK1, CMYK2, 1);\n        cmsDoTransform(swop_lab, CMYK2, &Lab2, 1);\n\n        DeltaE = cmsDeltaE(&Lab1, &Lab2);\n\n        if (DeltaE > Max) Max = DeltaE;\n    }\n\n    cmsDeleteTransform(xform);\n\n\n\n    cmsCloseProfile(hSWOP);\n    cmsCloseProfile(hFOGRA);\n    cmsCloseProfile(hLab);\n\n\n    cmsDeleteTransform(swop_lab);\n    cmsDeleteTransform(fogra_lab);\n\n    return Max < 30.0;\n}",
          "fn_code_pos": [
            [
              6738,
              0
            ],
            [
              6807,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckKPlaneBlackPreserving",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckProofingXFORMFloat(void)\n{\n    cmsHPROFILE hAbove;\n    cmsHTRANSFORM xform;\n    cmsInt32Number rc;\n\n    hAbove = Create_AboveRGB();\n    xform =  cmsCreateProofingTransformTHR(DbgThread(), hAbove, TYPE_RGB_FLT, hAbove, TYPE_RGB_FLT, hAbove,\n                                INTENT_RELATIVE_COLORIMETRIC, INTENT_RELATIVE_COLORIMETRIC, cmsFLAGS_SOFTPROOFING);\n    cmsCloseProfile(hAbove);\n    rc = CheckFloatlinearXFORM(xform, 3);\n    cmsDeleteTransform(xform);\n    return rc;\n}",
          "fn_code_pos": [
            [
              6813,
              0
            ],
            [
              6827,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckProofingXFORMFloat",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckProofingXFORM16(void)\n{\n    cmsHPROFILE hAbove;\n    cmsHTRANSFORM xform;\n    cmsInt32Number rc;\n\n    hAbove = Create_AboveRGB();\n    xform =  cmsCreateProofingTransformTHR(DbgThread(), hAbove, TYPE_RGB_16, hAbove, TYPE_RGB_16, hAbove,\n                                INTENT_RELATIVE_COLORIMETRIC, INTENT_RELATIVE_COLORIMETRIC, cmsFLAGS_SOFTPROOFING|cmsFLAGS_NOCACHE);\n    cmsCloseProfile(hAbove);\n    rc = Check16linearXFORM(xform, 3);\n    cmsDeleteTransform(xform);\n    return rc;\n}",
          "fn_code_pos": [
            [
              6829,
              0
            ],
            [
              6843,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckProofingXFORM16",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckGamutCheck(void)\n{\n        cmsHPROFILE hSRGB, hAbove;\n        cmsHTRANSFORM xform;\n        cmsInt32Number rc;\n        cmsUInt16Number Alarm[16] = { 0xDEAD, 0xBABE, 0xFACE };\n\n        // Set alarm codes to fancy values so we could check the out of gamut condition\n        cmsSetAlarmCodes(Alarm);\n\n        // Create the profiles\n        hSRGB  = cmsCreate_sRGBProfileTHR(DbgThread());\n        hAbove = Create_AboveRGB();\n\n        if (hSRGB == NULL || hAbove == NULL) return 0;  // Failed\n\n        SubTest(\"Gamut check on floating point\");\n\n        // Create a gamut checker in the same space. No value should be out of gamut\n        xform = cmsCreateProofingTransformTHR(DbgThread(), hAbove, TYPE_RGB_FLT, hAbove, TYPE_RGB_FLT, hAbove,\n                                INTENT_RELATIVE_COLORIMETRIC, INTENT_RELATIVE_COLORIMETRIC, cmsFLAGS_GAMUTCHECK);\n\n\n        if (!CheckFloatlinearXFORM(xform, 3)) {\n            cmsCloseProfile(hSRGB);\n            cmsCloseProfile(hAbove);\n            cmsDeleteTransform(xform);\n            Fail(\"Gamut check on same profile failed\");\n            return 0;\n        }\n\n        cmsDeleteTransform(xform);\n\n        SubTest(\"Gamut check on 16 bits\");\n\n        xform = cmsCreateProofingTransformTHR(DbgThread(), hAbove, TYPE_RGB_16, hAbove, TYPE_RGB_16, hSRGB,\n                                INTENT_RELATIVE_COLORIMETRIC, INTENT_RELATIVE_COLORIMETRIC, cmsFLAGS_GAMUTCHECK);\n\n        cmsCloseProfile(hSRGB);\n        cmsCloseProfile(hAbove);\n\n        rc = Check16linearXFORM(xform, 3);\n\n        cmsDeleteTransform(xform);\n\n        return rc;\n}",
          "fn_code_pos": [
            [
              6846,
              0
            ],
            [
              6893,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGamutCheck",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckBlackPoint(void)\n{\n    cmsHPROFILE hProfile;\n    cmsCIEXYZ Black;\n    cmsCIELab Lab;\n\n    hProfile  = cmsOpenProfileFromFileTHR(DbgThread(), \"test5.icc\", \"r\");\n    cmsDetectDestinationBlackPoint(&Black, hProfile, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(hProfile);\n\n\n    hProfile = cmsOpenProfileFromFileTHR(DbgThread(), \"test1.icc\", \"r\");\n    cmsDetectDestinationBlackPoint(&Black, hProfile, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsXYZ2Lab(NULL, &Lab, &Black);\n    cmsCloseProfile(hProfile);\n\n    hProfile = cmsOpenProfileFromFileTHR(DbgThread(), \"lcms2cmyk.icc\", \"r\");\n    cmsDetectDestinationBlackPoint(&Black, hProfile, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsXYZ2Lab(NULL, &Lab, &Black);\n    cmsCloseProfile(hProfile);\n\n    hProfile = cmsOpenProfileFromFileTHR(DbgThread(), \"test2.icc\", \"r\");\n    cmsDetectDestinationBlackPoint(&Black, hProfile, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsXYZ2Lab(NULL, &Lab, &Black);\n    cmsCloseProfile(hProfile);\n\n    hProfile = cmsOpenProfileFromFileTHR(DbgThread(), \"test1.icc\", \"r\");\n    cmsDetectDestinationBlackPoint(&Black, hProfile, INTENT_PERCEPTUAL, 0);\n    cmsXYZ2Lab(NULL, &Lab, &Black);\n    cmsCloseProfile(hProfile);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              6899,
              0
            ],
            [
              6932,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckBlackPoint",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckOneTAC(cmsFloat64Number InkLimit)\n{\n    cmsHPROFILE h;\n    cmsFloat64Number d;\n\n    h =CreateFakeCMYK(InkLimit, TRUE);\n    cmsSaveProfileToFile(h, \"lcmstac.icc\");\n    cmsCloseProfile(h);\n\n    h = cmsOpenProfileFromFile(\"lcmstac.icc\", \"r\");\n    d = cmsDetectTAC(h);\n    cmsCloseProfile(h);\n\n    remove(\"lcmstac.icc\");\n\n    if (fabs(d - InkLimit) > 5) return 0;\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              6935,
              0
            ],
            [
              6954,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckOneTAC",
            "parameters": {
              "InkLimit": "cmsFloat64Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckTAC(void)\n{\n    if (!CheckOneTAC(180)) return 0;\n    if (!CheckOneTAC(220)) return 0;\n    if (!CheckOneTAC(286)) return 0;\n    if (!CheckOneTAC(310)) return 0;\n    if (!CheckOneTAC(330)) return 0;\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              6957,
              0
            ],
            [
              6967,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckTAC",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckCGATS(void)\n{\n    cmsHANDLE  it8;\n    cmsInt32Number i;\n\n    SubTest(\"IT8 creation\");\n    it8 = cmsIT8Alloc(DbgThread());\n    if (it8 == NULL) return 0;\n\n    cmsIT8SetSheetType(it8, \"LCMS/TESTING\");\n    cmsIT8SetPropertyStr(it8, \"ORIGINATOR\",   \"1 2 3 4\");\n    cmsIT8SetPropertyUncooked(it8, \"DESCRIPTOR\",   \"1234\");\n    cmsIT8SetPropertyStr(it8, \"MANUFACTURER\", \"3\");\n    cmsIT8SetPropertyDbl(it8, \"CREATED\",      4);\n    cmsIT8SetPropertyDbl(it8, \"SERIAL\",       5);\n    cmsIT8SetPropertyHex(it8, \"MATERIAL\",     0x123);\n\n    cmsIT8SetPropertyDbl(it8, \"NUMBER_OF_SETS\", NPOINTS_IT8);\n    cmsIT8SetPropertyDbl(it8, \"NUMBER_OF_FIELDS\", 4);\n\n    cmsIT8SetDataFormat(it8, 0, \"SAMPLE_ID\");\n    cmsIT8SetDataFormat(it8, 1, \"RGB_R\");\n    cmsIT8SetDataFormat(it8, 2, \"RGB_G\");\n    cmsIT8SetDataFormat(it8, 3, \"RGB_B\");\n\n    SubTest(\"Table creation\");\n    for (i=0; i < NPOINTS_IT8; i++) {\n\n          char Patch[20];\n\n          sprintf(Patch, \"P%d\", i);\n\n          cmsIT8SetDataRowCol(it8, i, 0, Patch);\n          cmsIT8SetDataRowColDbl(it8, i, 1, i);\n          cmsIT8SetDataRowColDbl(it8, i, 2, i);\n          cmsIT8SetDataRowColDbl(it8, i, 3, i);\n    }\n\n    SubTest(\"Save to file\");\n    cmsIT8SaveToFile(it8, \"TEST.IT8\");\n    cmsIT8Free(it8);\n\n    SubTest(\"Load from file\");\n    it8 = cmsIT8LoadFromFile(DbgThread(), \"TEST.IT8\");\n    if (it8 == NULL) return 0;\n\n    SubTest(\"Save again file\");\n    cmsIT8SaveToFile(it8, \"TEST.IT8\");\n    cmsIT8Free(it8);\n\n\n    SubTest(\"Load from file (II)\");\n    it8 = cmsIT8LoadFromFile(DbgThread(), \"TEST.IT8\");\n    if (it8 == NULL) return 0;\n\n\n     SubTest(\"Change prop value\");\n    if (cmsIT8GetPropertyDbl(it8, \"DESCRIPTOR\") != 1234) {\n\n        return 0;\n    }\n\n\n    cmsIT8SetPropertyDbl(it8, \"DESCRIPTOR\", 5678);\n    if (cmsIT8GetPropertyDbl(it8, \"DESCRIPTOR\") != 5678) {\n\n        return 0;\n    }\n\n     SubTest(\"Positive numbers\");\n    if (cmsIT8GetDataDbl(it8, \"P3\", \"RGB_G\") != 3) {\n\n        return 0;\n    }\n\n\n     SubTest(\"Positive exponent numbers\");\n     cmsIT8SetPropertyDbl(it8, \"DBL_PROP\", 123E+12);\n     if ((cmsIT8GetPropertyDbl(it8, \"DBL_PROP\") - 123E+12) > 1 ) {\n\n        return 0;\n    }\n\n    SubTest(\"Negative exponent numbers\");\n    cmsIT8SetPropertyDbl(it8, \"DBL_PROP_NEG\", 123E-45);\n     if ((cmsIT8GetPropertyDbl(it8, \"DBL_PROP_NEG\") - 123E-45) > 1E-45 ) {\n\n        return 0;\n    }\n\n\n    SubTest(\"Negative numbers\");\n    cmsIT8SetPropertyDbl(it8, \"DBL_NEG_VAL\", -123);\n    if ((cmsIT8GetPropertyDbl(it8, \"DBL_NEG_VAL\")) != -123 ) {\n\n        return 0;\n    }\n\n    cmsIT8Free(it8);\n\n    remove(\"TEST.IT8\");\n    return 1;\n\n}",
          "fn_code_pos": [
            [
              6974,
              0
            ],
            [
              7078,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckCGATS",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckCGATS2(void)\n{\n    cmsHANDLE handle;\n    const cmsUInt8Number junk[] = { 0x0, 0xd, 0xd, 0xa, 0x20, 0xd, 0x20, 0x20, 0x20, 0x3a, 0x31, 0x3d, 0x3d, 0x3d, 0x3d };\n\n    handle = cmsIT8LoadFromMem(0, (const void*)junk, sizeof(junk));\n    if (handle)\n        cmsIT8Free(handle);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              7081,
              0
            ],
            [
              7092,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckCGATS2",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckCGATS_Overflow(void)\n{\n    cmsHANDLE handle;\n    const cmsUInt8Number junk[] = { \"@\\nA 1.e2147483648\\n\" };\n\n    handle = cmsIT8LoadFromMem(0, (const void*)junk, sizeof(junk));\n    if (handle)\n        cmsIT8Free(handle);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              7095,
              0
            ],
            [
              7106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckCGATS_Overflow",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nvoid GenerateCSA(const char* cInProf, const char* FileName)\n{\n    cmsHPROFILE hProfile;\n    cmsUInt32Number n;\n    char* Buffer;\n    cmsContext BuffThread = DbgThread();\n    FILE* o;\n\n\n    if (cInProf == NULL)\n        hProfile = cmsCreateLab4Profile(NULL);\n    else\n        hProfile = cmsOpenProfileFromFile(cInProf, \"r\");\n\n    n = cmsGetPostScriptCSA(DbgThread(), hProfile, 0, 0, NULL, 0);\n    if (n == 0) return;\n\n    Buffer = (char*) _cmsMalloc(BuffThread, n + 1);\n    cmsGetPostScriptCSA(DbgThread(), hProfile, 0, 0, Buffer, n);\n    Buffer[n] = 0;\n\n    if (FileName != NULL) {\n        o = fopen(FileName, \"wb\");\n        fwrite(Buffer, n, 1, o);\n        fclose(o);\n    }\n\n    _cmsFree(BuffThread, Buffer);\n    cmsCloseProfile(hProfile);\n    if (FileName != NULL)\n        remove(FileName);\n}",
          "fn_code_pos": [
            [
              7110,
              0
            ],
            [
              7142,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GenerateCSA",
            "parameters": {
              "cInProf": "char",
              "FileName": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid GenerateCRD(const char* cOutProf, const char* FileName)\n{\n    cmsHPROFILE hProfile;\n    cmsUInt32Number n;\n    char* Buffer;\n    cmsUInt32Number dwFlags = 0;\n    cmsContext BuffThread = DbgThread();\n\n\n    if (cOutProf == NULL)\n        hProfile = cmsCreateLab4Profile(NULL);\n    else\n        hProfile = cmsOpenProfileFromFile(cOutProf, \"r\");\n\n    n = cmsGetPostScriptCRD(DbgThread(), hProfile, 0, dwFlags, NULL, 0);\n    if (n == 0) return;\n\n    Buffer = (char*) _cmsMalloc(BuffThread, n + 1);\n    cmsGetPostScriptCRD(DbgThread(), hProfile, 0, dwFlags, Buffer, n);\n    Buffer[n] = 0;\n\n    if (FileName != NULL) {\n        FILE* o = fopen(FileName, \"wb\");\n        fwrite(Buffer, n, 1, o);\n        fclose(o);\n    }\n\n    _cmsFree(BuffThread, Buffer);\n    cmsCloseProfile(hProfile);\n    if (FileName != NULL)\n        remove(FileName);\n}",
          "fn_code_pos": [
            [
              7145,
              0
            ],
            [
              7177,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GenerateCRD",
            "parameters": {
              "cOutProf": "char",
              "FileName": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckPostScript(void)\n{\n    GenerateCSA(\"test5.icc\", \"sRGB_CSA.ps\");\n    GenerateCSA(\"aRGBlcms2.icc\", \"aRGB_CSA.ps\");\n    GenerateCSA(\"test4.icc\", \"sRGBV4_CSA.ps\");\n    GenerateCSA(\"test1.icc\", \"SWOP_CSA.ps\");\n    GenerateCSA(NULL, \"Lab_CSA.ps\");\n    GenerateCSA(\"graylcms2.icc\", \"gray_CSA.ps\");\n\n    GenerateCRD(\"test5.icc\", \"sRGB_CRD.ps\");\n    GenerateCRD(\"aRGBlcms2.icc\", \"aRGB_CRD.ps\");\n    GenerateCRD(NULL, \"Lab_CRD.ps\");\n    GenerateCRD(\"test1.icc\", \"SWOP_CRD.ps\");\n    GenerateCRD(\"test4.icc\", \"sRGBV4_CRD.ps\");\n    GenerateCRD(\"graylcms2.icc\", \"gray_CRD.ps\");\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              7179,
              0
            ],
            [
              7197,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckPostScript",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckGray(cmsHTRANSFORM xform, cmsUInt8Number g, double L)\n{\n    cmsCIELab Lab;\n\n    cmsDoTransform(xform, &g, &Lab, 1);\n\n    if (!IsGoodVal(\"a axis on gray\", 0, Lab.a, 0.001)) return 0;\n    if (!IsGoodVal(\"b axis on gray\", 0, Lab.b, 0.001)) return 0;\n\n    return IsGoodVal(\"Gray value\", L, Lab.L, 0.01);\n}",
          "fn_code_pos": [
            [
              7200,
              0
            ],
            [
              7211,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGray",
            "parameters": {
              "xform": "cmsHTRANSFORM",
              "g": "cmsUInt8Number",
              "L": "double"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckInputGray(void)\n{\n    cmsHPROFILE hGray = Create_Gray22();\n    cmsHPROFILE hLab  = cmsCreateLab4Profile(NULL);\n    cmsHTRANSFORM xform;\n\n    if (hGray == NULL || hLab == NULL) return 0;\n\n    xform = cmsCreateTransform(hGray, TYPE_GRAY_8, hLab, TYPE_Lab_DBL, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(hGray); cmsCloseProfile(hLab);\n\n    if (!CheckGray(xform, 0, 0)) return 0;\n    if (!CheckGray(xform, 125, 52.768)) return 0;\n    if (!CheckGray(xform, 200, 81.069)) return 0;\n    if (!CheckGray(xform, 255, 100.0)) return 0;\n\n    cmsDeleteTransform(xform);\n    return 1;\n}",
          "fn_code_pos": [
            [
              7213,
              0
            ],
            [
              7232,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckInputGray",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckLabInputGray(void)\n{\n    cmsHPROFILE hGray = Create_GrayLab();\n    cmsHPROFILE hLab  = cmsCreateLab4Profile(NULL);\n    cmsHTRANSFORM xform;\n\n    if (hGray == NULL || hLab == NULL) return 0;\n\n    xform = cmsCreateTransform(hGray, TYPE_GRAY_8, hLab, TYPE_Lab_DBL, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(hGray); cmsCloseProfile(hLab);\n\n    if (!CheckGray(xform, 0, 0)) return 0;\n    if (!CheckGray(xform, 125, 49.019)) return 0;\n    if (!CheckGray(xform, 200, 78.431)) return 0;\n    if (!CheckGray(xform, 255, 100.0)) return 0;\n\n    cmsDeleteTransform(xform);\n    return 1;\n}",
          "fn_code_pos": [
            [
              7234,
              0
            ],
            [
              7253,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckLabInputGray",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckOutGray(cmsHTRANSFORM xform, double L, cmsUInt8Number g)\n{\n    cmsCIELab Lab;\n    cmsUInt8Number g_out;\n\n    Lab.L = L;\n    Lab.a = 0;\n    Lab.b = 0;\n\n    cmsDoTransform(xform, &Lab, &g_out, 1);\n\n    return IsGoodVal(\"Gray value\", g, (double) g_out, 1);\n}",
          "fn_code_pos": [
            [
              7256,
              0
            ],
            [
              7269,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckOutGray",
            "parameters": {
              "xform": "cmsHTRANSFORM",
              "L": "double",
              "g": "cmsUInt8Number"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckOutputGray(void)\n{\n    cmsHPROFILE hGray = Create_Gray22();\n    cmsHPROFILE hLab  = cmsCreateLab4Profile(NULL);\n    cmsHTRANSFORM xform;\n\n    if (hGray == NULL || hLab == NULL) return 0;\n\n    xform = cmsCreateTransform( hLab, TYPE_Lab_DBL, hGray, TYPE_GRAY_8, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(hGray); cmsCloseProfile(hLab);\n\n    if (!CheckOutGray(xform, 0, 0)) return 0;\n    if (!CheckOutGray(xform, 100, 255)) return 0;\n\n    if (!CheckOutGray(xform, 20, 52)) return 0;\n    if (!CheckOutGray(xform, 50, 118)) return 0;\n\n\n    cmsDeleteTransform(xform);\n    return 1;\n}",
          "fn_code_pos": [
            [
              7271,
              0
            ],
            [
              7292,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckOutputGray",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckLabOutputGray(void)\n{\n    cmsHPROFILE hGray = Create_GrayLab();\n    cmsHPROFILE hLab  = cmsCreateLab4Profile(NULL);\n    cmsHTRANSFORM xform;\n    cmsInt32Number i;\n\n    if (hGray == NULL || hLab == NULL) return 0;\n\n    xform = cmsCreateTransform( hLab, TYPE_Lab_DBL, hGray, TYPE_GRAY_8, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(hGray); cmsCloseProfile(hLab);\n\n    if (!CheckOutGray(xform, 0, 0)) return 0;\n    if (!CheckOutGray(xform, 100, 255)) return 0;\n\n    for (i=0; i < 100; i++) {\n\n        cmsUInt8Number g;\n\n        g = (cmsUInt8Number) floor(i * 255.0 / 100.0 + 0.5);\n\n        if (!CheckOutGray(xform, i, g)) return 0;\n    }\n\n\n    cmsDeleteTransform(xform);\n    return 1;\n}",
          "fn_code_pos": [
            [
              7295,
              0
            ],
            [
              7323,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckLabOutputGray",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckV4gamma(void)\n{\n    cmsHPROFILE h;\n    cmsUInt16Number Lin[] = {0, 0xffff};\n    cmsToneCurve*g = cmsBuildTabulatedToneCurve16(DbgThread(), 2, Lin);\n\n    h = cmsOpenProfileFromFileTHR(DbgThread(), \"v4gamma.icc\", \"w\");\n    if (h == NULL) return 0;\n\n\n    cmsSetProfileVersion(h, 4.3);\n\n    if (!cmsWriteTag(h, cmsSigGrayTRCTag, g)) return 0;\n    cmsCloseProfile(h);\n\n    cmsFreeToneCurve(g);\n    remove(\"v4gamma.icc\");\n    return 1;\n}",
          "fn_code_pos": [
            [
              7326,
              0
            ],
            [
              7345,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckV4gamma",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckGBD(void)\n{\n    cmsCIELab Lab;\n    cmsHANDLE  h;\n    cmsInt32Number L, a, b;\n    cmsUInt32Number r1, g1, b1;\n    cmsHPROFILE hLab, hsRGB;\n    cmsHTRANSFORM xform;\n\n    h = cmsGBDAlloc(DbgThread());\n    if (h == NULL) return 0;\n\n    // Fill all Lab gamut as valid\n    SubTest(\"Filling RAW gamut\");\n\n    for (L=0; L <= 100; L += 10)\n        for (a = -128; a <= 128; a += 5)\n            for (b = -128; b <= 128; b += 5) {\n\n                Lab.L = L;\n                Lab.a = a;\n                Lab.b = b;\n                if (!cmsGDBAddPoint(h, &Lab)) return 0;\n            }\n\n    // Complete boundaries\n    SubTest(\"computing Lab gamut\");\n    if (!cmsGDBCompute(h, 0)) return 0;\n\n\n    // All points should be inside gamut\n    SubTest(\"checking Lab gamut\");\n    for (L=10; L <= 90; L += 25)\n        for (a = -120; a <= 120; a += 25)\n            for (b = -120; b <= 120; b += 25) {\n\n                Lab.L = L;\n                Lab.a = a;\n                Lab.b = b;\n                if (!cmsGDBCheckPoint(h, &Lab)) {\n                    return 0;\n                }\n            }\n    cmsGBDFree(h);\n\n\n    // Now for sRGB\n    SubTest(\"checking sRGB gamut\");\n    h = cmsGBDAlloc(DbgThread());\n    hsRGB = cmsCreate_sRGBProfile();\n    hLab  = cmsCreateLab4Profile(NULL);\n\n    xform = cmsCreateTransform(hsRGB, TYPE_RGB_8, hLab, TYPE_Lab_DBL, INTENT_RELATIVE_COLORIMETRIC, cmsFLAGS_NOCACHE);\n    cmsCloseProfile(hsRGB); cmsCloseProfile(hLab);\n\n\n    for (r1=0; r1 < 256; r1 += 5) {\n        for (g1=0; g1 < 256; g1 += 5)\n            for (b1=0; b1 < 256; b1 += 5) {\n\n\n                cmsUInt8Number rgb[3];\n\n                rgb[0] = (cmsUInt8Number) r1;\n                rgb[1] = (cmsUInt8Number) g1;\n                rgb[2] = (cmsUInt8Number) b1;\n\n                cmsDoTransform(xform, rgb, &Lab, 1);\n\n                // if (fabs(Lab.b) < 20 && Lab.a > 0) continue;\n\n                if (!cmsGDBAddPoint(h, &Lab)) {\n                    cmsGBDFree(h);\n                    return 0;\n                }\n\n\n            }\n    }\n\n\n    if (!cmsGDBCompute(h, 0)) return 0;\n    // cmsGBDdumpVRML(h, \"c:\\\\colormaps\\\\lab.wrl\");\n\n    for (r1=10; r1 < 200; r1 += 10) {\n        for (g1=10; g1 < 200; g1 += 10)\n            for (b1=10; b1 < 200; b1 += 10) {\n\n\n                cmsUInt8Number rgb[3];\n\n                rgb[0] = (cmsUInt8Number) r1;\n                rgb[1] = (cmsUInt8Number) g1;\n                rgb[2] = (cmsUInt8Number) b1;\n\n                cmsDoTransform(xform, rgb, &Lab, 1);\n                if (!cmsGDBCheckPoint(h, &Lab)) {\n\n                    cmsDeleteTransform(xform);\n                    cmsGBDFree(h);\n                    return 0;\n                }\n            }\n    }\n\n\n    cmsDeleteTransform(xform);\n    cmsGBDFree(h);\n\n    SubTest(\"checking LCh chroma ring\");\n    h = cmsGBDAlloc(DbgThread());\n\n\n    for (r1=0; r1 < 360; r1++) {\n\n        cmsCIELCh LCh;\n\n        LCh.L = 70;\n        LCh.C = 60;\n        LCh.h = r1;\n\n        cmsLCh2Lab(&Lab, &LCh);\n        if (!cmsGDBAddPoint(h, &Lab)) {\n                    cmsGBDFree(h);\n                    return 0;\n                }\n    }\n\n\n    if (!cmsGDBCompute(h, 0)) return 0;\n\n    cmsGBDFree(h);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              7350,
              0
            ],
            [
              7485,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGBD",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nint CheckMD5(void)\n{    \n    cmsHPROFILE pProfile = cmsOpenProfileFromFile(\"sRGBlcms2.icc\", \"r\");\n    cmsProfileID ProfileID1, ProfileID2, ProfileID3, ProfileID4;\n \n    if (cmsMD5computeID(pProfile)) cmsGetHeaderProfileID(pProfile, ProfileID1.ID8);\n    if (cmsMD5computeID(pProfile)) cmsGetHeaderProfileID(pProfile, ProfileID2.ID8);\n\n    cmsCloseProfile(pProfile);\n\n    pProfile = cmsOpenProfileFromFile(\"sRGBlcms2.icc\", \"r\");\n    \n    if (cmsMD5computeID(pProfile)) cmsGetHeaderProfileID(pProfile,ProfileID3.ID8);\n    if (cmsMD5computeID(pProfile)) cmsGetHeaderProfileID(pProfile,ProfileID4.ID8);\n\n    cmsCloseProfile(pProfile);\n\n    return ((memcmp(ProfileID1.ID8, ProfileID3.ID8, sizeof(ProfileID1)) == 0) &&\n            (memcmp(ProfileID2.ID8, ProfileID4.ID8, sizeof(ProfileID2)) == 0));\n}",
          "fn_code_pos": [
            [
              7488,
              0
            ],
            [
              7508,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMD5",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint CheckLinking(void)\n{\n    cmsHPROFILE h;\n    cmsPipeline * pipeline;\n    cmsStage *stageBegin, *stageEnd;\n\n    // Create a CLUT based profile\n     h = cmsCreateInkLimitingDeviceLinkTHR(DbgThread(), cmsSigCmykData, 150);\n\n     // link a second tag\n     cmsLinkTag(h, cmsSigAToB1Tag, cmsSigAToB0Tag);\n\n     // Save the linked devicelink\n    if (!cmsSaveProfileToFile(h, \"lcms2link.icc\")) return 0;\n    cmsCloseProfile(h);\n\n    // Now open the profile and read the pipeline\n    h = cmsOpenProfileFromFile(\"lcms2link.icc\", \"r\");\n    if (h == NULL) return 0;\n\n    pipeline = (cmsPipeline*) cmsReadTag(h, cmsSigAToB1Tag);\n    if (pipeline == NULL)\n    {\n        return 0;\n    }\n\n    pipeline = cmsPipelineDup(pipeline);\n\n    // extract stage from pipe line\n    cmsPipelineUnlinkStage(pipeline, cmsAT_BEGIN, &stageBegin);\n    cmsPipelineUnlinkStage(pipeline, cmsAT_END,   &stageEnd);\n    cmsPipelineInsertStage(pipeline, cmsAT_END,    stageEnd);\n    cmsPipelineInsertStage(pipeline, cmsAT_BEGIN,  stageBegin);\n    \n    if (cmsTagLinkedTo(h, cmsSigAToB1Tag) != cmsSigAToB0Tag) return 0;\n\n    cmsWriteTag(h, cmsSigAToB0Tag, pipeline);\n    cmsPipelineFree(pipeline);\n\n    if (!cmsSaveProfileToFile(h, \"lcms2link2.icc\")) return 0;\n    cmsCloseProfile(h);\n\n\n    return 1;\n\n}",
          "fn_code_pos": [
            [
              7512,
              0
            ],
            [
              7558,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckLinking",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static \ncmsHPROFILE IdentityMatrixProfile( cmsColorSpaceSignature dataSpace)\n{\n    cmsContext ctx = 0;\n    cmsVEC3 zero = {{0,0,0}};\n    cmsMAT3 identity;\n    cmsPipeline* forward;\n    cmsPipeline* reverse;\n    cmsHPROFILE identityProfile = cmsCreateProfilePlaceholder( ctx);\n    \n\n    cmsSetProfileVersion(identityProfile, 4.3);\n    \n    cmsSetDeviceClass( identityProfile,     cmsSigColorSpaceClass);\n    cmsSetColorSpace(identityProfile,       dataSpace);\n    cmsSetPCS(identityProfile,              cmsSigXYZData);\n    \n    cmsSetHeaderRenderingIntent(identityProfile,  INTENT_RELATIVE_COLORIMETRIC);\n    \n    cmsWriteTag(identityProfile, cmsSigMediaWhitePointTag, cmsD50_XYZ());\n    \n   \n    \n    _cmsMAT3identity( &identity);\n    \n    // build forward transform.... (RGB to PCS)\n    forward = cmsPipelineAlloc( 0, 3, 3);\n    cmsPipelineInsertStage( forward, cmsAT_END, cmsStageAllocMatrix( ctx, 3, 3, (cmsFloat64Number*)&identity, (cmsFloat64Number*)&zero));\n    cmsWriteTag( identityProfile, cmsSigDToB1Tag, forward);\n    \n    cmsPipelineFree( forward);\n    \n    reverse = cmsPipelineAlloc( 0, 3, 3);\n    cmsPipelineInsertStage( reverse, cmsAT_END, cmsStageAllocMatrix( ctx, 3, 3, (cmsFloat64Number*)&identity, (cmsFloat64Number*)&zero));\n    cmsWriteTag( identityProfile, cmsSigBToD1Tag, reverse);\n    \n    cmsPipelineFree( reverse);\n    \n    return identityProfile;\n}",
          "fn_code_pos": [
            [
              7564,
              0
            ],
            [
              7603,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IdentityMatrixProfile",
            "parameters": {
              "dataSpace": "cmsColorSpaceSignature"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckFloatXYZ(void)\n{\n    cmsHPROFILE input;\n    cmsHPROFILE xyzProfile = cmsCreateXYZProfile();\n    cmsHTRANSFORM xform;\n    cmsFloat32Number in[4];   \n    cmsFloat32Number out[4];\n    \n    in[0] = 1.0;\n    in[1] = 1.0;\n    in[2] = 1.0;\n    in[3] = 0.5;\n    \n    // RGB to XYZ\n    input = IdentityMatrixProfile( cmsSigRgbData);\n    \n    xform = cmsCreateTransform( input, TYPE_RGB_FLT, xyzProfile, TYPE_XYZ_FLT, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(input);\n    \n    cmsDoTransform( xform, in, out, 1);\n    cmsDeleteTransform( xform);\n    \n    if (!IsGoodVal(\"Float RGB->XYZ\", in[0], out[0], FLOAT_PRECISSION) ||\n        !IsGoodVal(\"Float RGB->XYZ\", in[1], out[1], FLOAT_PRECISSION) ||\n        !IsGoodVal(\"Float RGB->XYZ\", in[2], out[2], FLOAT_PRECISSION))\n           return 0;\n    \n    \n    // XYZ to XYZ\n    input = IdentityMatrixProfile( cmsSigXYZData);\n    \n    xform = cmsCreateTransform( input, TYPE_XYZ_FLT, xyzProfile, TYPE_XYZ_FLT, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(input);\n\n    cmsDoTransform( xform, in, out, 1);\n    \n    \n    cmsDeleteTransform( xform);\n    \n     if (!IsGoodVal(\"Float XYZ->XYZ\", in[0], out[0], FLOAT_PRECISSION) ||\n         !IsGoodVal(\"Float XYZ->XYZ\", in[1], out[1], FLOAT_PRECISSION) ||\n         !IsGoodVal(\"Float XYZ->XYZ\", in[2], out[2], FLOAT_PRECISSION))\n           return 0;\n   \n    \n    input = IdentityMatrixProfile( cmsSigXYZData);\n\n#   define TYPE_XYZA_FLT          (FLOAT_SH(1)|COLORSPACE_SH(PT_XYZ)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(4))\n    \n    xform = cmsCreateTransform( input, TYPE_XYZA_FLT, xyzProfile, TYPE_XYZA_FLT, INTENT_RELATIVE_COLORIMETRIC, cmsFLAGS_COPY_ALPHA);\n    cmsCloseProfile(input);\n\n    cmsDoTransform( xform, in, out, 1);\n    \n    \n    cmsDeleteTransform( xform);\n    \n     if (!IsGoodVal(\"Float XYZA->XYZA\", in[0], out[0], FLOAT_PRECISSION) ||\n         !IsGoodVal(\"Float XYZA->XYZA\", in[1], out[1], FLOAT_PRECISSION) ||\n         !IsGoodVal(\"Float XYZA->XYZA\", in[2], out[2], FLOAT_PRECISSION) ||\n         !IsGoodVal(\"Float XYZA->XYZA\", in[3], out[3], FLOAT_PRECISSION))\n           return 0;\n   \n    \n    // XYZ to RGB\n    input = IdentityMatrixProfile( cmsSigRgbData);\n    \n    xform = cmsCreateTransform( xyzProfile, TYPE_XYZ_FLT, input, TYPE_RGB_FLT, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(input);\n    \n    cmsDoTransform( xform, in, out, 1);\n   \n    cmsDeleteTransform( xform);\n\n       if (!IsGoodVal(\"Float XYZ->RGB\", in[0], out[0], FLOAT_PRECISSION) ||\n           !IsGoodVal(\"Float XYZ->RGB\", in[1], out[1], FLOAT_PRECISSION) ||\n           !IsGoodVal(\"Float XYZ->RGB\", in[2], out[2], FLOAT_PRECISSION))\n           return 0;\n        \n\n    // Now the optimizer should remove a stage\n\n    // XYZ to RGB\n    input = IdentityMatrixProfile( cmsSigRgbData);\n    \n    xform = cmsCreateTransform( input, TYPE_RGB_FLT, input, TYPE_RGB_FLT, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsCloseProfile(input);\n    \n    cmsDoTransform( xform, in, out, 1);\n   \n    cmsDeleteTransform( xform);\n\n       if (!IsGoodVal(\"Float RGB->RGB\", in[0], out[0], FLOAT_PRECISSION) ||\n           !IsGoodVal(\"Float RGB->RGB\", in[1], out[1], FLOAT_PRECISSION) ||\n           !IsGoodVal(\"Float RGB->RGB\", in[2], out[2], FLOAT_PRECISSION))\n           return 0;\n    \n    cmsCloseProfile(xyzProfile);\n\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              7605,
              0
            ],
            [
              7707,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckFloatXYZ",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number ChecksRGB2LabFLT(void)\n{\n    cmsHPROFILE hSRGB = cmsCreate_sRGBProfile();\n    cmsHPROFILE hLab  = cmsCreateLab4Profile(NULL);\n\n    cmsHTRANSFORM xform1 = cmsCreateTransform(hSRGB, TYPE_RGBA_FLT, hLab, TYPE_LabA_FLT, 0, cmsFLAGS_NOCACHE|cmsFLAGS_NOOPTIMIZE);\n    cmsHTRANSFORM xform2 = cmsCreateTransform(hLab, TYPE_LabA_FLT, hSRGB, TYPE_RGBA_FLT, 0, cmsFLAGS_NOCACHE|cmsFLAGS_NOOPTIMIZE);\n\n    cmsFloat32Number RGBA1[4], RGBA2[4], LabA[4];\n    int i;\n\n\n    for (i = 0; i <= 100; i++)\n    {\n        RGBA1[0] = i / 100.0F;\n        RGBA1[1] = i / 100.0F;\n        RGBA1[2] = i / 100.0F;\n        RGBA1[3] = 0;\n\n        cmsDoTransform(xform1, RGBA1, LabA,  1);\n        cmsDoTransform(xform2, LabA, RGBA2, 1);\n\n        if (!IsGoodVal(\"Float RGB->RGB\", RGBA1[0], RGBA2[0], FLOAT_PRECISSION) ||\n            !IsGoodVal(\"Float RGB->RGB\", RGBA1[1], RGBA2[1], FLOAT_PRECISSION) ||\n            !IsGoodVal(\"Float RGB->RGB\", RGBA1[2], RGBA2[2], FLOAT_PRECISSION))\n            return 0;\n    }\n\n\n    cmsDeleteTransform(xform1);\n    cmsDeleteTransform(xform2);\n    cmsCloseProfile(hSRGB);\n    cmsCloseProfile(hLab);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              7726,
              0
            ],
            [
              7762,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ChecksRGB2LabFLT",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ndouble Rec709(double L)\n{\n    if (L <0.018) return 4.5*L;\n    else\n    {\n          double a = 1.099* pow(L, 0.45);\n          \n          a = a - 0.099;\n          return a;\n    }\n}",
          "fn_code_pos": [
            [
              7767,
              0
            ],
            [
              7778,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Rec709",
            "parameters": {
              "L": "double"
            },
            "return_type": "double"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckParametricRec709(void)\n{\n    cmsFloat64Number params[7];\n    cmsToneCurve* t;\n    int i;\n\n    params[0] = 0.45; /* y */\n    params[1] = pow(1.099, 1.0 / 0.45); /* a */\n    params[2] = 0.0; /* b */\n    params[3] = 4.5; /* c */\n    params[4] = 0.018; /* d */\n    params[5] = -0.099; /* e */\n    params[6] = 0.0; /* f */\n        \n    t = cmsBuildParametricToneCurve (NULL, 5, params);\n\n\n    for (i=0; i < 256; i++)\n    {\n        cmsFloat32Number n = (cmsFloat32Number) i / 255.0F;\n        cmsUInt16Number f1 = (cmsUInt16Number) floor(255.0 * cmsEvalToneCurveFloat(t, n) + 0.5);\n        cmsUInt16Number f2 = (cmsUInt16Number) floor(255.0*Rec709((double) i / 255.0) + 0.5);\n\n        if (f1 != f2) \n        {\n            cmsFreeToneCurve(t);\n            return 0;\n        }\n    }\n\n    cmsFreeToneCurve(t);\n    return 1;\n}",
          "fn_code_pos": [
            [
              7781,
              0
            ],
            [
              7814,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckParametricRec709",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static cmsFloat32Number StraightLine( cmsFloat32Number x) \n{\n    return (cmsFloat32Number) (0.1 + 0.9 * x);\n}",
          "fn_code_pos": [
            [
              7821,
              0
            ],
            [
              7824,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "StraightLine",
            "parameters": {
              "x": "cmsFloat32Number"
            },
            "return_type": "cmsFloat32Number"
          }
        },
        {
          "fn_code": "static cmsInt32Number TestCurve( const char* label, cmsToneCurve* curve, Function fn) \n{\n    cmsInt32Number ok = 1;\n    int i;\n    for (i = 0; i < kNumPoints*3; i++) {\n        \n        cmsFloat32Number x = (cmsFloat32Number)i / (kNumPoints*3 - 1);\n        cmsFloat32Number expectedY = fn(x);\n        cmsFloat32Number out = cmsEvalToneCurveFloat( curve, x);\n        \n        if (!IsGoodVal(label, expectedY, out, FLOAT_PRECISSION)) {\n            ok = 0;\n        }\n    }\n    return ok;\n}",
          "fn_code_pos": [
            [
              7826,
              0
            ],
            [
              7841,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestCurve",
            "parameters": {
              "label": "char",
              "curve": "cmsToneCurve",
              "fn": "Function"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckFloatSamples(void)\n{\n    cmsFloat32Number y[kNumPoints];\n    int i;\n    cmsToneCurve *curve;\n    cmsInt32Number ok;\n\n    for (i = 0; i < kNumPoints; i++) {\n        cmsFloat32Number x = (cmsFloat32Number)i / (kNumPoints-1);\n        \n        y[i] = StraightLine(x);\n    }\n    \n    curve = cmsBuildTabulatedToneCurveFloat(NULL, kNumPoints, y);\n    ok = TestCurve( \"Float Samples\", curve, StraightLine);\n    cmsFreeToneCurve(curve);\n    \n    return ok;\n}",
          "fn_code_pos": [
            [
              7843,
              0
            ],
            [
              7862,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckFloatSamples",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckFloatSegments(void)\n{\n    cmsInt32Number ok = 1;\n    int i;\n    cmsToneCurve *curve;\n    \n    cmsFloat32Number y[ kNumPoints];\n    \n    // build a segmented curve with a sampled section...\n    cmsCurveSegment Seg[3];\n    \n    // Initialize segmented curve part up to 0.1\n    Seg[0].x0 = -1e22f;      // -infinity\n    Seg[0].x1 = 0.1f;\n    Seg[0].Type = 6;             // Y = (a * X + b) ^ Gamma + c\n    Seg[0].Params[0] = 1.0f;     // gamma\n    Seg[0].Params[1] = 0.9f;     // a\n    Seg[0].Params[2] = 0.0f;        // b\n    Seg[0].Params[3] = 0.1f;     // c\n    Seg[0].Params[4] = 0.0f;\n    \n    // From zero to 1\n    Seg[1].x0 = 0.1f;\n    Seg[1].x1 = 0.9f;\n    Seg[1].Type = 0;\n    \n    Seg[1].nGridPoints = kNumPoints;\n    Seg[1].SampledPoints = y;\n    \n    for (i = 0; i < kNumPoints; i++) {\n        cmsFloat32Number x = (cmsFloat32Number) (0.1 + ((cmsFloat32Number)i / (kNumPoints-1)) * (0.9 - 0.1));\n        y[i] = StraightLine(x);\n    }\n    \n    // from 1 to +infinity\n    Seg[2].x0 = 0.9f;\n    Seg[2].x1 = 1e22f;   // +infinity\n    Seg[2].Type = 6;\n    \n    Seg[2].Params[0] = 1.0f;\n    Seg[2].Params[1] = 0.9f;\n    Seg[2].Params[2] = 0.0f;\n    Seg[2].Params[3] = 0.1f;\n    Seg[2].Params[4] = 0.0f;\n    \n    curve = cmsBuildSegmentedToneCurve(0, 3, Seg);\n    \n    ok = TestCurve( \"Float Segmented Curve\", curve, StraightLine);\n\n    cmsFreeToneCurve( curve);\n\n    return ok;\n}",
          "fn_code_pos": [
            [
              7864,
              0
            ],
            [
              7917,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckFloatSegments",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckReadRAW(void)\n{\n    cmsInt32Number tag_size, tag_size1;\n    char buffer[37009];\n    cmsHPROFILE hProfile;\n\n\n    SubTest(\"RAW read on on-disk\");\n    hProfile = cmsOpenProfileFromFile(\"test1.icc\", \"r\");\n\n    if (hProfile == NULL)\n        return 0;\n    tag_size1 = cmsReadRawTag(hProfile, cmsSigGamutTag, NULL, 0);\n    tag_size = cmsReadRawTag(hProfile, cmsSigGamutTag, buffer, 37009);\n\n\n    cmsCloseProfile(hProfile);\n\n    if (tag_size != 37009)\n        return 0;\n\n    if (tag_size1 != 37009)\n        return 0;\n\n    SubTest(\"RAW read on in-memory created profiles\");\n    hProfile = cmsCreate_sRGBProfile();\n    tag_size1 = cmsReadRawTag(hProfile, cmsSigGreenColorantTag, NULL, 0);\n    tag_size = cmsReadRawTag(hProfile, cmsSigGreenColorantTag, buffer, 20);\n\n    cmsCloseProfile(hProfile);\n\n    if (tag_size != 20)\n        return 0;\n    if (tag_size1 != 20)\n        return 0;\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              7920,
              0
            ],
            [
              7958,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckReadRAW",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckMeta(void)\n{\n    char *data;\n    cmsHANDLE dict;\n    cmsHPROFILE p;\n    cmsUInt32Number clen;\n    FILE *fp;\n    int rc;\n    \n    /* open file */\n    p = cmsOpenProfileFromFile(\"ibm-t61.icc\", \"r\");\n    if (p == NULL) return 0;\n\n    /* read dictionary, but don't do anything with the value */\n    //COMMENT OUT THE NEXT TWO LINES AND IT WORKS FINE!!!\n    dict = cmsReadTag(p, cmsSigMetaTag);\n    if (dict == NULL) return 0;\n\n    /* serialize profile to memory */\n    rc = cmsSaveProfileToMem(p, NULL, &clen);\n    if (!rc) return 0;\n\n    data = (char*) chknull(malloc(clen));\n    rc = cmsSaveProfileToMem(p, data, &clen);\n    if (!rc) return 0;\n\n    /* write the memory blob to a file */\n    //NOTE: The crash does not happen if cmsSaveProfileToFile() is used */\n    fp = fopen(\"new.icc\", \"wb\");\n    fwrite(data, 1, clen, fp);\n    fclose(fp);\n    free(data);\n\n    cmsCloseProfile(p);\n\n    /* open newly created file and read metadata */\n    p = cmsOpenProfileFromFile(\"new.icc\", \"r\");\n    //ERROR: Bad dictionary Name/Value\n    //ERROR: Corrupted tag 'meta'\n    //test: test.c:59: main: Assertion `dict' failed.\n    dict = cmsReadTag(p, cmsSigMetaTag);\n   if (dict == NULL) return 0;\n\n   cmsCloseProfile(p);\n    return 1;\n}",
          "fn_code_pos": [
            [
              7961,
              0
            ],
            [
              8007,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMeta",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckFloatNULLxform(void)\n{\n    int i;\n    cmsFloat32Number in[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n    cmsFloat32Number out[10];\n\n    cmsHTRANSFORM xform = cmsCreateTransform(NULL, TYPE_GRAY_FLT, NULL, TYPE_GRAY_FLT, INTENT_PERCEPTUAL, cmsFLAGS_NULLTRANSFORM);\n\n    if (xform == NULL) {\n        Fail(\"Unable to create float null transform\");\n        return 0;\n    }\n\n    cmsDoTransform(xform, in, out, 10);\n\n    cmsDeleteTransform(xform);\n    for (i=0; i < 10; i++) {\n    \n        if (!IsGoodVal(\"float nullxform\", in[i], out[i], 0.001)) {\n        \n            return 0;\n        }\n    }\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              8011,
              0
            ],
            [
              8037,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckFloatNULLxform",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckRemoveTag(void)\n{\n    cmsHPROFILE p;\n    cmsMLU *mlu;\n    int ret;\n\n    p = cmsCreate_sRGBProfileTHR(NULL);\n\n    /* set value */\n    mlu = cmsMLUalloc (NULL, 1);\n    ret = cmsMLUsetASCII (mlu, \"en\", \"US\", \"bar\");\n    if (!ret) return 0;\n\n    ret = cmsWriteTag (p, cmsSigDeviceMfgDescTag, mlu);\n    if (!ret) return 0;\n     \n    cmsMLUfree (mlu);\n\n    /* remove the tag  */\n    ret = cmsWriteTag (p, cmsSigDeviceMfgDescTag, NULL);\n    if (!ret) return 0;\n\n    /* THIS EXPLODES */\n    cmsCloseProfile(p);\n    return 1;\n}",
          "fn_code_pos": [
            [
              8039,
              0
            ],
            [
              8065,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckRemoveTag",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckMatrixSimplify(void)\n{\n     \n       cmsHPROFILE pIn;\n       cmsHPROFILE pOut;\n       cmsHTRANSFORM t;\n       unsigned char buf[3] = { 127, 32, 64 };\n\n       \n       pIn = cmsCreate_sRGBProfile();\n       pOut = cmsOpenProfileFromFile(\"ibm-t61.icc\", \"r\");\n       if (pIn == NULL || pOut == NULL)\n              return 0;\n\n       t = cmsCreateTransform(pIn, TYPE_RGB_8, pOut, TYPE_RGB_8, INTENT_PERCEPTUAL, 0);\n       cmsDoTransformStride(t, buf, buf, 1, 1);\n       cmsDeleteTransform(t);\n       cmsCloseProfile(pIn);\n       cmsCloseProfile(pOut);\n      \n\n       return buf[0] == 144 && buf[1] == 0 && buf[2] == 69;\n}",
          "fn_code_pos": [
            [
              8068,
              0
            ],
            [
              8091,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMatrixSimplify",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\ncmsInt32Number CheckTransformLineStride(void)\n{\n\n       cmsHPROFILE pIn;\n       cmsHPROFILE pOut;\n       cmsHTRANSFORM t;\n\n       // Our buffer is formed by 4 RGB8 lines, each line is 2 pixels wide plus a padding of one byte\n\n       cmsUInt8Number buf1[]= { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0,\n                                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0, \n                                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0, \n                                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0, };\n\n       // Our buffer2 is formed by 4 RGBA lines, each line is 2 pixels wide plus a padding of one byte\n\n       cmsUInt8Number buf2[] = { 0xff, 0xff, 0xff, 1, 0xff, 0xff, 0xff, 1, 0,\n                                 0xff, 0xff, 0xff, 1, 0xff, 0xff, 0xff, 1, 0,\n                                 0xff, 0xff, 0xff, 1, 0xff, 0xff, 0xff, 1, 0,\n                                 0xff, 0xff, 0xff, 1, 0xff, 0xff, 0xff, 1, 0};\n\n       // Our buffer3 is formed by 4 RGBA16 lines, each line is 2 pixels wide plus a padding of two bytes\n\n       cmsUInt16Number buf3[] = { 0xffff, 0xffff, 0xffff, 0x0101, 0xffff, 0xffff, 0xffff, 0x0101, 0,\n                                  0xffff, 0xffff, 0xffff, 0x0101, 0xffff, 0xffff, 0xffff, 0x0101, 0,\n                                  0xffff, 0xffff, 0xffff, 0x0101, 0xffff, 0xffff, 0xffff, 0x0101, 0,\n                                  0xffff, 0xffff, 0xffff, 0x0101, 0xffff, 0xffff, 0xffff, 0x0101, 0 };\n\n       cmsUInt8Number out[1024];\n\n\n       memset(out, 0, sizeof(out));\n       pIn = cmsCreate_sRGBProfile();\n       pOut = cmsOpenProfileFromFile(\"ibm-t61.icc\", \"r\");\n       if (pIn == NULL || pOut == NULL)\n              return 0;\n\n       t = cmsCreateTransform(pIn, TYPE_RGB_8, pOut, TYPE_RGB_8, INTENT_PERCEPTUAL, cmsFLAGS_COPY_ALPHA);\n       \n       cmsDoTransformLineStride(t, buf1, out, 2, 4, 7, 7, 0, 0);\n       cmsDeleteTransform(t);\n\n       if (memcmp(out, buf1, sizeof(buf1)) != 0) {\n              Fail(\"Failed transform line stride on RGB8\");\n              cmsCloseProfile(pIn);\n              cmsCloseProfile(pOut);\n              return 0;\n       }\n\n       memset(out, 0, sizeof(out));\n\n       t = cmsCreateTransform(pIn, TYPE_RGBA_8, pOut, TYPE_RGBA_8, INTENT_PERCEPTUAL, cmsFLAGS_COPY_ALPHA);\n       \n       cmsDoTransformLineStride(t, buf2, out, 2, 4, 9, 9, 0, 0);\n\n       cmsDeleteTransform(t);\n\n\n       if (memcmp(out, buf2, sizeof(buf2)) != 0) {\n              cmsCloseProfile(pIn);\n              cmsCloseProfile(pOut);\n              Fail(\"Failed transform line stride on RGBA8\");\n              return 0;\n       }\n\n       memset(out, 0, sizeof(out));\n\n       t = cmsCreateTransform(pIn, TYPE_RGBA_16, pOut, TYPE_RGBA_16, INTENT_PERCEPTUAL, cmsFLAGS_COPY_ALPHA);\n\n       cmsDoTransformLineStride(t, buf3, out, 2, 4, 18, 18, 0, 0);\n\n       cmsDeleteTransform(t);\n\n       if (memcmp(out, buf3, sizeof(buf3)) != 0) {\n              cmsCloseProfile(pIn);\n              cmsCloseProfile(pOut);\n              Fail(\"Failed transform line stride on RGBA16\");\n              return 0;\n       }\n\n\n       memset(out, 0, sizeof(out));\n\n\n       // From 8 to 16\n       t = cmsCreateTransform(pIn, TYPE_RGBA_8, pOut, TYPE_RGBA_16, INTENT_PERCEPTUAL, cmsFLAGS_COPY_ALPHA);\n\n       cmsDoTransformLineStride(t, buf2, out, 2, 4, 9, 18, 0, 0);\n\n       cmsDeleteTransform(t);\n\n       if (memcmp(out, buf3, sizeof(buf3)) != 0) {\n              cmsCloseProfile(pIn);\n              cmsCloseProfile(pOut);\n              Fail(\"Failed transform line stride on RGBA16\");\n              return 0;\n       }\n\n\n\n       cmsCloseProfile(pIn);\n       cmsCloseProfile(pOut);\n\n       return 1;\n}",
          "fn_code_pos": [
            [
              8095,
              0
            ],
            [
              8200,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckTransformLineStride",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "static\nint CheckPlanar8opt(void)\n{\n    cmsHPROFILE aboveRGB = Create_AboveRGB();\n    cmsHPROFILE sRGB = cmsCreate_sRGBProfile();\n\n    cmsHTRANSFORM transform = cmsCreateTransform(sRGB, TYPE_RGB_8_PLANAR,\n        aboveRGB, TYPE_RGB_8_PLANAR,\n        INTENT_PERCEPTUAL, 0);\n\n    cmsDeleteTransform(transform);\n    cmsCloseProfile(aboveRGB);\n    cmsCloseProfile(sRGB);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              8203,
              0
            ],
            [
              8218,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckPlanar8opt",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint CheckPlanarFloat2int(void)\n{    \n    cmsHPROFILE sRGB = cmsCreate_sRGBProfile();\n\n    cmsHTRANSFORM transform = cmsCreateTransform(sRGB, TYPE_RGB_FLT_PLANAR,\n        sRGB, TYPE_RGB_16_PLANAR,INTENT_PERCEPTUAL, 0);\n\n    const cmsFloat32Number input[] = { 0.0f, 0.4f, 0.8f,  0.1f, 0.5f, 0.9f,  0.2f, 0.6f, 1.0f,   0.3f, 0.7f, 1.0f };\n    cmsUInt16Number output[3*4] = { 0 };\n\n    cmsDoTransform(transform, input, output, 4);\n\n    cmsDeleteTransform(transform);    \n    cmsCloseProfile(sRGB);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              8225,
              0
            ],
            [
              8242,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckPlanarFloat2int",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint CheckSE(void)\n{\n    cmsHPROFILE input_profile = Create_AboveRGB();\n    cmsHPROFILE output_profile = cmsCreate_sRGBProfile();\n\n    cmsHTRANSFORM tr = cmsCreateTransform(input_profile, TYPE_RGBA_8, output_profile, TYPE_RGBA_16_SE, INTENT_RELATIVE_COLORIMETRIC, cmsFLAGS_COPY_ALPHA);\n   \n    cmsUInt8Number rgba[4] = { 40, 41, 41, 0xfa };\n    cmsUInt16Number out[4];\n\n    cmsDoTransform(tr, rgba, out, 1);\n    cmsCloseProfile(input_profile);\n    cmsCloseProfile(output_profile);\n    cmsDeleteTransform(tr);\n\n    if (out[0] != 0xf622 || out[1] != 0x7f24 || out[2] != 0x7f24)\n        return 0;\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              8251,
              0
            ],
            [
              8271,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckSE",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint CheckForgedMPE(void) \n{\n    cmsUInt32Number i;\n    cmsHPROFILE srcProfile;\n    cmsHPROFILE dstProfile;\n    cmsColorSpaceSignature srcCS;\n    cmsUInt32Number nSrcComponents;\n    cmsUInt32Number srcFormat;\n    cmsUInt32Number intent = 0;\n    cmsUInt32Number flags = 0;\n    cmsHTRANSFORM hTransform;\n    cmsUInt8Number output[4];\n\n    srcProfile = cmsOpenProfileFromFile(\"bad_mpe.icc\", \"r\");\n    if (!srcProfile)\n        return 0;\n\n    dstProfile = cmsCreate_sRGBProfile();\n    if (!dstProfile) {\n        cmsCloseProfile(srcProfile);\n        return 0;\n    }\n\n    srcCS = cmsGetColorSpace(srcProfile);\n    nSrcComponents = cmsChannelsOfColorSpace(srcCS);\n    \n    if (srcCS == cmsSigLabData) {\n        srcFormat =\n            COLORSPACE_SH(PT_Lab) | CHANNELS_SH(nSrcComponents) | BYTES_SH(0);\n    }\n    else {\n        srcFormat =\n            COLORSPACE_SH(PT_ANY) | CHANNELS_SH(nSrcComponents) | BYTES_SH(1);\n    }\n\n    cmsSetLogErrorHandler(ErrorReportingFunction);\n\n    hTransform = cmsCreateTransform(srcProfile, srcFormat, dstProfile,\n        TYPE_BGR_8, intent, flags);\n    cmsCloseProfile(srcProfile);\n    cmsCloseProfile(dstProfile);\n\n    cmsSetLogErrorHandler(FatalErrorQuit);    \n\n    // Should report error\n    if (!TrappedError) return 0;\n\n    TrappedError = FALSE;\n\n    // Transform should NOT be created\n    if (!hTransform) return 1;\n    \n    // Never should reach here\n    if (T_BYTES(srcFormat) == 0) {  // 0 means double\n        double input[128];\n        for (i = 0; i < nSrcComponents; i++)\n            input[i] = 0.5f;\n        cmsDoTransform(hTransform, input, output, 1);\n    }\n    else {\n        cmsUInt8Number input[128];\n        for (i = 0; i < nSrcComponents; i++)\n            input[i] = 128;\n        cmsDoTransform(hTransform, input, output, 1);\n    }\n    cmsDeleteTransform(hTransform);\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              8276,
              0
            ],
            [
              8345,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckForgedMPE",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint CheckProofingIntersection(void)\n{\n    cmsHPROFILE profile_null, hnd1, hnd2;\n    cmsHTRANSFORM transform;\n\n    hnd1 = cmsCreate_sRGBProfile();\n    hnd2 = Create_AboveRGB();\n\n    profile_null = cmsCreateNULLProfileTHR(DbgThread());\n    transform = cmsCreateProofingTransformTHR(DbgThread(),\n        hnd1,\n        TYPE_RGB_FLT,\n        profile_null,\n        TYPE_GRAY_FLT,\n        hnd2,\n        INTENT_ABSOLUTE_COLORIMETRIC,\n        INTENT_ABSOLUTE_COLORIMETRIC,\n        cmsFLAGS_GAMUTCHECK |\n        cmsFLAGS_SOFTPROOFING);\n\n    cmsCloseProfile(hnd1);\n    cmsCloseProfile(hnd2);\n    cmsCloseProfile(profile_null);\n\n    // Failed?\n    if (transform == NULL) return 0;\n\n    cmsDeleteTransform(transform);\n    return 1;\n}",
          "fn_code_pos": [
            [
              8353,
              0
            ],
            [
              8383,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckProofingIntersection",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint CheckEmptyMLUC(void)\n{\n    cmsContext context = cmsCreateContext(NULL, NULL);    \n    cmsCIExyY white = { 0.31271, 0.32902, 1.0 };\n    cmsCIExyYTRIPLE primaries =\n    {\n    .Red = { 0.640, 0.330, 1.0 },\n    .Green = { 0.300, 0.600, 1.0 },\n    .Blue = { 0.150, 0.060, 1.0 }\n    };\n\n    cmsFloat64Number parameters[10] = { 2.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };\n    cmsToneCurve* toneCurve = cmsBuildParametricToneCurve(context, 1, parameters);\n    cmsToneCurve* toneCurves[3] = { toneCurve, toneCurve, toneCurve };\n\n    cmsHPROFILE profile = cmsCreateRGBProfileTHR(context, &white, &primaries, toneCurves);\n    \n    cmsSetLogErrorHandlerTHR(context, FatalErrorQuit);\n\n    cmsFreeToneCurve(toneCurve);\n\n    // Set an empty copyright tag. This should log an error.\n    cmsMLU* mlu = cmsMLUalloc(context, 1);\n    \n    cmsMLUsetASCII(mlu, \"en\", \"AU\", \"\");\n    cmsMLUsetWide(mlu,  \"en\", \"EN\", L\"\");\n    cmsWriteTag(profile, cmsSigCopyrightTag, mlu);\n    cmsMLUfree(mlu);\n\n    // This will cause a crash after setting an empty copyright tag.\n    cmsMD5computeID(profile);\n\n    // Cleanup\n    cmsCloseProfile(profile);\n    DebugMemDontCheckThis(context);\n    cmsDeleteContext(context);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              8389,
              0
            ],
            [
              8428,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckEmptyMLUC",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\ndouble distance(const cmsUInt16Number* a, const cmsUInt16Number* b)\n{\n    double d1 = a[0] - b[0];\n    double d2 = a[1] - b[1];\n    double d3 = a[2] - b[2];\n\n    return sqrt(d1 * d1 + d2 * d2 + d3 * d3);\n}",
          "fn_code_pos": [
            [
              8430,
              0
            ],
            [
              8438,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "distance",
            "parameters": {
              "a": "cmsUInt16Number",
              "b": "cmsUInt16Number"
            },
            "return_type": "double"
          }
        },
        {
          "fn_code": "static\nint Check_sRGB_Rountrips(void)\n{\n    cmsUInt16Number rgb[3], seed[3];\n    cmsCIELab Lab;\n    int i, r, g, b;\n    double err, maxErr;\n    cmsHPROFILE hsRGB = cmsCreate_sRGBProfile();\n    cmsHPROFILE hLab = cmsCreateLab4Profile(NULL);\n\n    cmsHTRANSFORM hBack = cmsCreateTransform(hLab, TYPE_Lab_DBL, hsRGB, TYPE_RGB_16, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsHTRANSFORM hForth = cmsCreateTransform(hsRGB, TYPE_RGB_16, hLab, TYPE_Lab_DBL, INTENT_RELATIVE_COLORIMETRIC, 0);\n\n    cmsCloseProfile(hLab);\n    cmsCloseProfile(hsRGB);\n\n    maxErr = 0.0;\n    for (r = 0; r <= 255; r += 16)\n        for (g = 0; g <= 255; g += 16)\n            for (b = 0; b <= 255; b += 16)\n            {\n                seed[0] = rgb[0] = (cmsUInt16Number) ((r << 8) | r);\n                seed[1] = rgb[1] = (cmsUInt16Number) ((g << 8) | g);\n                seed[2] = rgb[2] = (cmsUInt16Number) ((b << 8) | b);\n\n                for (i = 0; i < 50; i++)\n                {\n                    cmsDoTransform(hForth, rgb, &Lab, 1);\n                    cmsDoTransform(hBack, &Lab, rgb, 1);\n                }\n\n                err = distance(seed, rgb);\n\n                if (err > maxErr)\n                    maxErr = err;\n            }\n\n\n    cmsDeleteTransform(hBack);\n    cmsDeleteTransform(hForth);\n\n    if (maxErr > 20.0)\n    {\n        printf(\"Maximum sRGB roundtrip error %f!\\n\", maxErr);\n        return 0;\n    }\n    \n    return 1;\n}",
          "fn_code_pos": [
            [
              8444,
              0
            ],
            [
              8492,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check_sRGB_Rountrips",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint Check_OkLab(void)\n{\n    cmsHPROFILE hOkLab = cmsCreate_OkLabProfile(NULL);\n    cmsHPROFILE hXYZ = cmsCreateXYZProfile();\n    cmsCIEXYZ xyz, xyz2;\n    cmsCIELab okLab;\n\n#define TYPE_OKLAB_DBL          (FLOAT_SH(1)|COLORSPACE_SH(PT_MCH3)|CHANNELS_SH(3)|BYTES_SH(0))\n\n    cmsHTRANSFORM xform  = cmsCreateTransform(hXYZ, TYPE_XYZ_DBL,  hOkLab, TYPE_OKLAB_DBL, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsHTRANSFORM xform2 = cmsCreateTransform(hOkLab, TYPE_OKLAB_DBL, hXYZ, TYPE_XYZ_DBL,  INTENT_RELATIVE_COLORIMETRIC, 0);\n\n    /**\n    * D50 should be converted to white by PCS definition\n    */\n    xyz.X = 0.9642; xyz.Y = 1.0000; xyz.Z = 0.8249;\n    cmsDoTransform(xform, &xyz, &okLab, 1);\n    cmsDoTransform(xform2, &okLab, &xyz2, 1);\n\n\n    xyz.X = 1.0; xyz.Y = 0.0; xyz.Z = 0.0;\n    cmsDoTransform(xform, &xyz, &okLab, 1);\n    cmsDoTransform(xform2, &okLab, &xyz2, 1);\n\n\n    xyz.X = 0.0; xyz.Y = 1.0; xyz.Z = 0.0;\n    cmsDoTransform(xform, &xyz, &okLab, 1);\n    cmsDoTransform(xform2, &okLab, &xyz2, 1);\n\n    xyz.X = 0.0; xyz.Y = 0.0; xyz.Z = 1.0;\n    cmsDoTransform(xform, &xyz, &okLab, 1);\n    cmsDoTransform(xform2, &okLab, &xyz2, 1);\n\n    xyz.X = 0.143046; xyz.Y = 0.060610; xyz.Z = 0.713913;\n    cmsDoTransform(xform, &xyz, &okLab, 1);\n    cmsDoTransform(xform2, &okLab, &xyz2, 1);\n    \n    cmsDeleteTransform(xform);\n    cmsDeleteTransform(xform2);\n    cmsCloseProfile(hOkLab);\n    cmsCloseProfile(hXYZ);\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              8497,
              0
            ],
            [
              8541,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check_OkLab",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint Check_OkLab2(void)\n{\n#define TYPE_LABA_F32 (FLOAT_SH(1)|COLORSPACE_SH(PT_MCH3)|EXTRA_SH(1)|CHANNELS_SH(3)|BYTES_SH(4))\n\n    cmsUInt16Number rgb[3];\n    cmsFloat32Number lab[4];\n\n    cmsHPROFILE labProfile = cmsCreate_OkLabProfile(NULL);\n    cmsHPROFILE rgbProfile = cmsCreate_sRGBProfile();\n\n    cmsHTRANSFORM hBack = cmsCreateTransform(labProfile, TYPE_LABA_F32, rgbProfile, TYPE_RGB_16, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsHTRANSFORM hForth = cmsCreateTransform(rgbProfile, TYPE_RGB_16, labProfile, TYPE_LABA_F32, INTENT_RELATIVE_COLORIMETRIC, 0);\n\n    cmsCloseProfile(labProfile);\n    cmsCloseProfile(rgbProfile);\n\n    rgb[0] = 0;\n    rgb[1] = 0;\n    rgb[2] = 65535;\n\n    cmsDoTransform(hForth, rgb, &lab, 1);\n    cmsDoTransform(hBack, lab, &rgb, 1);\n\n    cmsDeleteTransform(hBack);\n    cmsDeleteTransform(hForth);\n\n    if (rgb[0] != 0 || rgb[1] != 0 || rgb[2] != 65535) return 0;\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              8544,
              0
            ],
            [
              8574,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Check_OkLab2",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\ncmsHPROFILE createRgbGamma(cmsFloat64Number g)\n{\n    cmsCIExyY       D65 = { 0.3127, 0.3290, 1.0 };\n    cmsCIExyYTRIPLE Rec709Primaries = {\n                                {0.6400, 0.3300, 1.0},\n                                {0.3000, 0.6000, 1.0},\n                                {0.1500, 0.0600, 1.0}\n    };\n    cmsToneCurve* Gamma[3];\n    cmsHPROFILE  hRGB;\n    \n    Gamma[0] = Gamma[1] = Gamma[2] = cmsBuildGamma(0, g);\n    if (Gamma[0] == NULL) return NULL;\n\n    hRGB = cmsCreateRGBProfile(&D65, &Rec709Primaries, Gamma);\n    cmsFreeToneCurve(Gamma[0]);    \n    return hRGB;\n}",
          "fn_code_pos": [
            [
              8577,
              0
            ],
            [
              8595,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "createRgbGamma",
            "parameters": {
              "g": "cmsFloat64Number"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "static\nint CheckGammaSpaceDetection(void)\n{\n    cmsFloat64Number i;\n\n    for (i = 0.5; i < 3; i += 0.1)\n    {                \n        cmsHPROFILE hProfile = createRgbGamma(i);\n\n        cmsFloat64Number gamma = cmsDetectRGBProfileGamma(hProfile, 0.01);\n\n        cmsCloseProfile(hProfile);\n\n        if (fabs(gamma - i) > 0.1)\n        {\n            Fail(\"Failed profile gamma detection of %f (got %f)\", i, gamma);\n            return 0;\n        }\n    }\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              8598,
              0
            ],
            [
              8619,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckGammaSpaceDetection",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint CheckInducedCorruption(void)\n{\n    cmsHTRANSFORM xform0;\n    char garbage[] = \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\";\n    cmsHPROFILE hsrgb = cmsCreate_sRGBProfile();\n    cmsHPROFILE hLab = cmsCreateLab4Profile(NULL);\n\n    cmsSetLogErrorHandler(NULL);\n    cmsWriteRawTag(hsrgb, cmsSigBlueColorantTag, &garbage, sizeof(garbage));\n\n    xform0 = cmsCreateTransform(hsrgb, TYPE_RGB_16, hLab, TYPE_Lab_16, INTENT_RELATIVE_COLORIMETRIC, 0);\n\n    if (xform0) cmsDeleteTransform(xform0);\n\n    cmsCloseProfile(hsrgb);\n    cmsCloseProfile(hLab);\n\n    ResetFatalError();\n    return 1;\n}",
          "fn_code_pos": [
            [
              8622,
              0
            ],
            [
              8642,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckInducedCorruption",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nvoid uint16toFloat(cmsUInt16Number* src, cmsFloat32Number* dst)\n{\n    for (int i = 0; i < 3; i++) {\n        dst[i] = src[i] / 65535.f;\n    }\n}",
          "fn_code_pos": [
            [
              8648,
              0
            ],
            [
              8654,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "uint16toFloat",
            "parameters": {
              "src": "cmsUInt16Number",
              "dst": "cmsFloat32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nint CheckLinearSpacesOptimization(void)\n{\n    cmsHPROFILE lcms_sRGB = cmsCreate_sRGBProfile();\n    cmsHPROFILE elle_sRGB = cmsOpenProfileFromFile(\"sRGB-elle-V4-srgbtrc.icc\", \"r\");\n    cmsHPROFILE elle_linear = cmsOpenProfileFromFile(\"sRGB-elle-V4-g10.icc\", \"r\");\n    cmsHTRANSFORM transform1 = cmsCreateTransform(elle_sRGB, TYPE_RGB_16, elle_linear, TYPE_RGB_16, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsHTRANSFORM transform2 = cmsCreateTransform(elle_linear, TYPE_RGB_16, lcms_sRGB, TYPE_RGB_16, INTENT_RELATIVE_COLORIMETRIC, 0);\n    cmsHTRANSFORM transform2a = cmsCreateTransform(elle_linear, TYPE_RGB_FLT, lcms_sRGB, TYPE_RGB_16, INTENT_RELATIVE_COLORIMETRIC, 0);\n\n    cmsUInt16Number sourceCol[3] = { 43 * 257, 27 * 257, 6 * 257 };\n    cmsUInt16Number linearCol[3] = { 0 };\n    float linearColF[3] = { 0 };\n    cmsUInt16Number finalCol[3] = { 0 };\n    int difR, difG, difB;\n    int difR2, difG2, difB2;\n\n    cmsDoTransform(transform1, sourceCol, linearCol, 1);\n    cmsDoTransform(transform2, linearCol, finalCol, 1);\n\n    cmsCloseProfile(lcms_sRGB); cmsCloseProfile(elle_sRGB); cmsCloseProfile(elle_linear);\n\n\n    difR = (int)sourceCol[0] - finalCol[0];\n    difG = (int)sourceCol[1] - finalCol[1];\n    difB = (int)sourceCol[2] - finalCol[2];\n\n\n    uint16toFloat(linearCol, linearColF);\n    cmsDoTransform(transform2a, linearColF, finalCol, 1);\n\n    difR2 = (int)sourceCol[0] - finalCol[0];\n    difG2 = (int)sourceCol[1] - finalCol[1];\n    difB2 = (int)sourceCol[2] - finalCol[2];\n\n    cmsDeleteTransform(transform1);\n    cmsDeleteTransform(transform2);\n    cmsDeleteTransform(transform2a);\n\n    if (abs(difR2 - difR) > 5 || abs(difG2 - difG) > 5 || abs(difB2 - difB) > 5)\n    {\n        Fail(\"Linear detection failed\");\n        return 0;\n    }\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              8656,
              0
            ],
            [
              8702,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckLinearSpacesOptimization",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint CheckBadCGATS(void)\n{\n    const char* bad_it8 =\n        \" \\\"\\\"\\n\"\n        \"NUMBER_OF_FIELDS 4\\n\"\n        \"BEGIN_DATA_FORMAT\\n\"\n        \"I R G G\\n\"\n        \"END_DATA_FORMAT\\n\"\n        \"NUMBER_OF_FIELDS 9\\n\"\n        \"NUMBER_OF_SETS 2\\n\"\n        \"BEGIN_DATA\\n\"\n        \"d\\n\"\n        \"0 0Bd\\n\"\n        \"0Ba\t$ $ t .\";\n\n    cmsHANDLE hIT8;\n    \n    cmsSetLogErrorHandler(NULL);\n\n    hIT8 = cmsIT8LoadFromMem(0, bad_it8, (cmsUInt32Number) strlen(bad_it8));\n    \n    ResetFatalError();\n\n    if (hIT8 != NULL)\n    {\n        Fail(\"Wrong IT8 accepted as ok\");\n        cmsIT8Free(hIT8);\n    }\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              8707,
              0
            ],
            [
              8738,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckBadCGATS",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint CheckIntToFloatTransform(void)\n{\n    cmsHPROFILE hAbove = Create_AboveRGB();\n    cmsHPROFILE hsRGB = cmsCreate_sRGBProfile();\n\n    cmsHTRANSFORM xform = cmsCreateTransform(hAbove, TYPE_RGB_8, hsRGB, TYPE_RGB_DBL, INTENT_PERCEPTUAL, 0);\n\n    cmsUInt8Number rgb8[3] = { 12, 253, 21 };\n    cmsFloat64Number rgbDBL[3] = { 0 };\n\n    cmsCloseProfile(hAbove); cmsCloseProfile(hsRGB);\n\n    cmsDoTransform(xform, rgb8, rgbDBL, 1);\n\n    \n    cmsDeleteTransform(xform);\n\n    if (rgbDBL[0] < 0 && rgbDBL[2] < 0) return 1;\n\n    Fail(\"Unbounded transforms with integer input failed\");\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              8740,
              0
            ],
            [
              8763,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckIntToFloatTransform",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint CheckSaveLinearizationDevicelink(void)\n{\n    const cmsFloat32Number table[] = { 0, 0.5f, 1.0f };\n\n    cmsToneCurve* tone = cmsBuildTabulatedToneCurveFloat(NULL, 3, table);\n\n    cmsToneCurve* rgb_curves[3] = { tone, tone, tone };\n\n    cmsHPROFILE hDeviceLink = cmsCreateLinearizationDeviceLink(cmsSigRgbData, rgb_curves);\n\n    cmsBool result;\n    cmsHTRANSFORM xform;\n    int i;\n    \n    cmsFreeToneCurve(tone);\n\n    result = cmsSaveProfileToFile(hDeviceLink, \"lin_rgb.icc\");\n\n    cmsCloseProfile(hDeviceLink);\n\n    if (!result)\n    {\n        remove(\"lin_rgb.icc\");\n        Fail(\"Couldn't save linearization devicelink\");        \n    }\n\n\n    hDeviceLink = cmsOpenProfileFromFile(\"lin_rgb.icc\", \"r\");\n\n    if (hDeviceLink == NULL)\n    {\n        remove(\"lin_rgb.icc\");\n        Fail(\"Couldn't open devicelink\");\n    }\n\n    xform = cmsCreateTransform(hDeviceLink, TYPE_RGB_8, NULL, TYPE_RGB_8, INTENT_PERCEPTUAL, 0);\n    cmsCloseProfile(hDeviceLink);\n\n    for (i = 0; i < 256; i++)\n    {\n        cmsUInt8Number rgb_in[3] = { i, i, i };\n        cmsUInt8Number rgb_out[3];\n\n        cmsDoTransform(xform, rgb_in, rgb_out, 1);\n\n        if (rgb_in[0] != rgb_out[0] ||\n            rgb_in[1] != rgb_out[1] ||\n            rgb_in[2] != rgb_out[2])\n        {\n            remove(\"lin_rgb.icc\");\n            Fail(\"Saved devicelink was not working\");\n        }\n    }\n\n\n    cmsDeleteTransform(xform);\n    remove(\"lin_rgb.icc\");\n\n    return 1;\n\n\n\n}",
          "fn_code_pos": [
            [
              8765,
              0
            ],
            [
              8828,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckSaveLinearizationDevicelink",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nvoid TitlePerformance(const char* Txt)\n{\n    printf(\"%-45s: \", Txt); fflush(stdout);\n}",
          "fn_code_pos": [
            [
              8844,
              0
            ],
            [
              8848,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TitlePerformance",
            "parameters": {
              "Txt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid PrintPerformance(cmsUInt32Number Bytes, cmsUInt32Number SizeOfPixel, cmsFloat64Number diff)\n{\n    cmsFloat64Number seconds  = (cmsFloat64Number) diff / CLOCKS_PER_SEC;\n    cmsFloat64Number mpix_sec = Bytes / (1024.0*1024.0*seconds*SizeOfPixel);\n\n    printf(\"%#4.3g MPixel/sec.\\n\", mpix_sec);\t\n    fflush(stdout);\n}",
          "fn_code_pos": [
            [
              8850,
              0
            ],
            [
              8858,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintPerformance",
            "parameters": {
              "Bytes": "cmsUInt32Number",
              "SizeOfPixel": "cmsUInt32Number",
              "diff": "cmsFloat64Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid SpeedTest32bits(const char * Title, cmsHPROFILE hlcmsProfileIn, cmsHPROFILE hlcmsProfileOut, cmsInt32Number Intent)\n{\n    cmsInt32Number r, g, b, j;\n    clock_t atime;\n    cmsFloat64Number diff;\n    cmsHTRANSFORM hlcmsxform;\n    Scanline_rgba32 *In;\n    cmsUInt32Number Mb;\n    cmsUInt32Number Interval = 4; // Power of 2 number to increment r,g,b values by in the loops to keep the test duration practically short\n    cmsUInt32Number NumPixels;\n\n    if (hlcmsProfileIn == NULL || hlcmsProfileOut == NULL)\n        Die(\"Unable to open profiles\");\n\n    hlcmsxform  = cmsCreateTransformTHR(DbgThread(), hlcmsProfileIn, TYPE_RGBA_FLT,\n        hlcmsProfileOut, TYPE_RGBA_FLT, Intent, cmsFLAGS_NOCACHE);\n    cmsCloseProfile(hlcmsProfileIn);\n    cmsCloseProfile(hlcmsProfileOut);\n\n    NumPixels = 256 / Interval * 256 / Interval * 256 / Interval;\n    Mb = NumPixels * sizeof(Scanline_rgba32);\n\n    In = (Scanline_rgba32 *) chknull(malloc(Mb));\n\n    j = 0;\n    for (r=0; r < 256; r += Interval)\n        for (g=0; g < 256; g += Interval)\n            for (b=0; b < 256; b += Interval) {\n\n                In[j].r = r / 256.0f;\n                In[j].g = g / 256.0f;\n                In[j].b = b / 256.0f;\n                In[j].a = (In[j].r + In[j].g + In[j].b) / 3; \n\n                j++;\n            }\n\n\n    TitlePerformance(Title);\n\n    atime = clock();\n\n    cmsDoTransform(hlcmsxform, In, In, NumPixels);\n\n    diff = clock() - atime;\n    free(In);\n\n    PrintPerformance(Mb, sizeof(Scanline_rgba32), diff);\n    cmsDeleteTransform(hlcmsxform);\n\n}",
          "fn_code_pos": [
            [
              8861,
              0
            ],
            [
              8912,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SpeedTest32bits",
            "parameters": {
              "Title": "char",
              "hlcmsProfileIn": "cmsHPROFILE",
              "hlcmsProfileOut": "cmsHPROFILE",
              "Intent": "cmsInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid SpeedTest16bits(const char * Title, cmsHPROFILE hlcmsProfileIn, cmsHPROFILE hlcmsProfileOut, cmsInt32Number Intent)\n{\n    cmsInt32Number r, g, b, j;\n    clock_t atime;\n    cmsFloat64Number diff;\n    cmsHTRANSFORM hlcmsxform;\n    Scanline_rgb16 *In;\n    cmsUInt32Number Mb;\n\n    if (hlcmsProfileIn == NULL || hlcmsProfileOut == NULL)\n        Die(\"Unable to open profiles\");\n\n    hlcmsxform  = cmsCreateTransformTHR(DbgThread(), hlcmsProfileIn, TYPE_RGB_16,\n        hlcmsProfileOut, TYPE_RGB_16, Intent, cmsFLAGS_NOCACHE);\n    cmsCloseProfile(hlcmsProfileIn);\n    cmsCloseProfile(hlcmsProfileOut);\n\n    Mb = 256*256*256 * sizeof(Scanline_rgb16);\n\n    In = (Scanline_rgb16*) chknull(malloc(Mb));\n\n    j = 0;\n    for (r=0; r < 256; r++)\n        for (g=0; g < 256; g++)\n            for (b=0; b < 256; b++) {\n\n                In[j].r = (cmsUInt16Number) ((r << 8) | r);\n                In[j].g = (cmsUInt16Number) ((g << 8) | g);\n                In[j].b = (cmsUInt16Number) ((b << 8) | b);\n\n                j++;\n            }\n\n\n    TitlePerformance(Title);\n\n    atime = clock();\n\n    cmsDoTransform(hlcmsxform, In, In, 256*256*256);\n\n    diff = clock() - atime;\n    free(In);\n\n    PrintPerformance(Mb, sizeof(Scanline_rgb16), diff);\n    cmsDeleteTransform(hlcmsxform);\n\n}",
          "fn_code_pos": [
            [
              8915,
              0
            ],
            [
              8962,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SpeedTest16bits",
            "parameters": {
              "Title": "char",
              "hlcmsProfileIn": "cmsHPROFILE",
              "hlcmsProfileOut": "cmsHPROFILE",
              "Intent": "cmsInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid SpeedTest32bitsCMYK(const char * Title, cmsHPROFILE hlcmsProfileIn, cmsHPROFILE hlcmsProfileOut)\n{\n    cmsInt32Number r, g, b, j;\n    clock_t atime;\n    cmsFloat64Number diff;\n    cmsHTRANSFORM hlcmsxform;\n    Scanline_rgba32 *In;\n    cmsUInt32Number Mb;\n    cmsUInt32Number Interval = 4; // Power of 2 number to increment r,g,b values by in the loops to keep the test duration practically short\n    cmsUInt32Number NumPixels;\n\n    if (hlcmsProfileIn == NULL || hlcmsProfileOut == NULL)\n        Die(\"Unable to open profiles\");\n\n    hlcmsxform  = cmsCreateTransformTHR(DbgThread(), hlcmsProfileIn, TYPE_CMYK_FLT,\n        hlcmsProfileOut, TYPE_CMYK_FLT, INTENT_PERCEPTUAL, cmsFLAGS_NOCACHE);\n    cmsCloseProfile(hlcmsProfileIn);\n    cmsCloseProfile(hlcmsProfileOut);\n\n    NumPixels = 256 / Interval * 256 / Interval * 256 / Interval;\n    Mb = NumPixels * sizeof(Scanline_rgba32);\n\n    In = (Scanline_rgba32 *) chknull(malloc(Mb));\n\n    j = 0;\n    for (r=0; r < 256; r += Interval)\n        for (g=0; g < 256; g += Interval)\n            for (b=0; b < 256; b += Interval) {\n\n                In[j].r = r / 256.0f;\n                In[j].g = g / 256.0f;\n                In[j].b = b / 256.0f;\n                In[j].a = (In[j].r + In[j].g + In[j].b) / 3; \n\n                j++;\n            }\n\n\n    TitlePerformance(Title);\n\n    atime = clock();\n\n    cmsDoTransform(hlcmsxform, In, In, NumPixels);\n\n    diff = clock() - atime;\n\n    free(In);\n\n    PrintPerformance(Mb, sizeof(Scanline_rgba32), diff);\n\n    cmsDeleteTransform(hlcmsxform);\n\n}",
          "fn_code_pos": [
            [
              8965,
              0
            ],
            [
              9018,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SpeedTest32bitsCMYK",
            "parameters": {
              "Title": "char",
              "hlcmsProfileIn": "cmsHPROFILE",
              "hlcmsProfileOut": "cmsHPROFILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid SpeedTest16bitsCMYK(const char * Title, cmsHPROFILE hlcmsProfileIn, cmsHPROFILE hlcmsProfileOut)\n{\n    cmsInt32Number r, g, b, j;\n    clock_t atime;\n    cmsFloat64Number diff;\n    cmsHTRANSFORM hlcmsxform;\n    Scanline_rgba16 *In;\n    cmsUInt32Number Mb;\n\n    if (hlcmsProfileIn == NULL || hlcmsProfileOut == NULL)\n        Die(\"Unable to open profiles\");\n\n    hlcmsxform  = cmsCreateTransformTHR(DbgThread(), hlcmsProfileIn, TYPE_CMYK_16,\n        hlcmsProfileOut, TYPE_CMYK_16, INTENT_PERCEPTUAL,  cmsFLAGS_NOCACHE);\n    cmsCloseProfile(hlcmsProfileIn);\n    cmsCloseProfile(hlcmsProfileOut);\n\n    Mb = 256*256*256*sizeof(Scanline_rgba16);\n\n    In = (Scanline_rgba16*) chknull(malloc(Mb));\n\n    j = 0;\n    for (r=0; r < 256; r++)\n        for (g=0; g < 256; g++)\n            for (b=0; b < 256; b++) {\n\n                In[j].r = (cmsUInt16Number) ((r << 8) | r);\n                In[j].g = (cmsUInt16Number) ((g << 8) | g);\n                In[j].b = (cmsUInt16Number) ((b << 8) | b);\n                In[j].a = 0;\n\n                j++;\n            }\n\n\n    TitlePerformance(Title);\n\n    atime = clock();\n\n    cmsDoTransform(hlcmsxform, In, In, 256*256*256);\n\n    diff = clock() - atime;\n\n    free(In);\n\n    PrintPerformance(Mb, sizeof(Scanline_rgba16), diff);\n\n    cmsDeleteTransform(hlcmsxform);\n\n}",
          "fn_code_pos": [
            [
              9021,
              0
            ],
            [
              9071,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SpeedTest16bitsCMYK",
            "parameters": {
              "Title": "char",
              "hlcmsProfileIn": "cmsHPROFILE",
              "hlcmsProfileOut": "cmsHPROFILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid SpeedTest8bits(const char * Title, cmsHPROFILE hlcmsProfileIn, cmsHPROFILE hlcmsProfileOut, cmsInt32Number Intent)\n{\n    cmsInt32Number r, g, b, j;\n    clock_t atime;\n    cmsFloat64Number diff;\n    cmsHTRANSFORM hlcmsxform;\n    Scanline_rgb8 *In;\n    cmsUInt32Number Mb;\n\n    if (hlcmsProfileIn == NULL || hlcmsProfileOut == NULL)\n        Die(\"Unable to open profiles\");\n\n    hlcmsxform  = cmsCreateTransformTHR(DbgThread(), hlcmsProfileIn, TYPE_RGB_8,\n                            hlcmsProfileOut, TYPE_RGB_8, Intent, cmsFLAGS_NOCACHE);\n    cmsCloseProfile(hlcmsProfileIn);\n    cmsCloseProfile(hlcmsProfileOut);\n\n    Mb = 256*256*256*sizeof(Scanline_rgb8);\n\n    In = (Scanline_rgb8*) chknull(malloc(Mb));\n\n    j = 0;\n    for (r=0; r < 256; r++)\n        for (g=0; g < 256; g++)\n            for (b=0; b < 256; b++) {\n\n        In[j].r = (cmsUInt8Number) r;\n        In[j].g = (cmsUInt8Number) g;\n        In[j].b = (cmsUInt8Number) b;\n\n        j++;\n    }\n\n    TitlePerformance(Title);\n\n    atime = clock();\n\n    cmsDoTransform(hlcmsxform, In, In, 256*256*256);\n\n    diff = clock() - atime;\n\n    free(In);\n\n    PrintPerformance(Mb, sizeof(Scanline_rgb8), diff);\n\n    cmsDeleteTransform(hlcmsxform);\n\n}",
          "fn_code_pos": [
            [
              9074,
              0
            ],
            [
              9122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SpeedTest8bits",
            "parameters": {
              "Title": "char",
              "hlcmsProfileIn": "cmsHPROFILE",
              "hlcmsProfileOut": "cmsHPROFILE",
              "Intent": "cmsInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid SpeedTest8bitsCMYK(const char * Title, cmsHPROFILE hlcmsProfileIn, cmsHPROFILE hlcmsProfileOut)\n{\n    cmsInt32Number r, g, b, j;\n    clock_t atime;\n    cmsFloat64Number diff;\n    cmsHTRANSFORM hlcmsxform;\n    Scanline_rgba8 *In;\n    cmsUInt32Number Mb;\n\n    if (hlcmsProfileIn == NULL || hlcmsProfileOut == NULL)\n        Die(\"Unable to open profiles\");\n\n    hlcmsxform  = cmsCreateTransformTHR(DbgThread(), hlcmsProfileIn, TYPE_CMYK_8,\n                        hlcmsProfileOut, TYPE_CMYK_8, INTENT_PERCEPTUAL, cmsFLAGS_NOCACHE);\n    cmsCloseProfile(hlcmsProfileIn);\n    cmsCloseProfile(hlcmsProfileOut);\n\n    Mb = 256*256*256*sizeof(Scanline_rgba8);\n\n    In = (Scanline_rgba8*) chknull(malloc(Mb));\n\n    j = 0;\n    for (r=0; r < 256; r++)\n        for (g=0; g < 256; g++)\n            for (b=0; b < 256; b++) {\n\n        In[j].r = (cmsUInt8Number) r;\n        In[j].g = (cmsUInt8Number) g;\n        In[j].b = (cmsUInt8Number) b;\n        In[j].a = (cmsUInt8Number) 0;\n\n        j++;\n    }\n\n    TitlePerformance(Title);\n\n    atime = clock();\n\n    cmsDoTransform(hlcmsxform, In, In, 256*256*256);\n\n    diff = clock() - atime;\n\n    free(In);\n\n    PrintPerformance(Mb, sizeof(Scanline_rgba8), diff);\n\n\n    cmsDeleteTransform(hlcmsxform);\n\n}",
          "fn_code_pos": [
            [
              9125,
              0
            ],
            [
              9175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SpeedTest8bitsCMYK",
            "parameters": {
              "Title": "char",
              "hlcmsProfileIn": "cmsHPROFILE",
              "hlcmsProfileOut": "cmsHPROFILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid SpeedTest32bitsGray(const char * Title, cmsHPROFILE hlcmsProfileIn, cmsHPROFILE hlcmsProfileOut, cmsInt32Number Intent)\n{\n    cmsInt32Number r, g, b, j;\n    clock_t atime;\n    cmsFloat64Number diff;\n    cmsHTRANSFORM hlcmsxform;\n    cmsFloat32Number *In;\n    cmsUInt32Number Mb;\n    cmsUInt32Number Interval = 4; // Power of 2 number to increment r,g,b values by in the loops to keep the test duration practically short\n    cmsUInt32Number NumPixels;\n\n    if (hlcmsProfileIn == NULL || hlcmsProfileOut == NULL)\n        Die(\"Unable to open profiles\");\n\n    hlcmsxform  = cmsCreateTransformTHR(DbgThread(), hlcmsProfileIn,\n        TYPE_GRAY_FLT, hlcmsProfileOut, TYPE_GRAY_FLT, Intent, cmsFLAGS_NOCACHE);\n    cmsCloseProfile(hlcmsProfileIn);\n    cmsCloseProfile(hlcmsProfileOut);\n\n    NumPixels = 256 / Interval * 256 / Interval * 256 / Interval;\n    Mb = NumPixels * sizeof(cmsFloat32Number);\n\n    In = (cmsFloat32Number*) chknull(malloc(Mb));\n\n    j = 0;\n    for (r = 0; r < 256; r += Interval)\n        for (g = 0; g < 256; g += Interval)\n            for (b = 0; b < 256; b += Interval) {\n\n                In[j] = ((r + g + b) / 768.0f);\n\n                j++;\n            }\n\n    TitlePerformance(Title);\n\n    atime = clock();\n\n    cmsDoTransform(hlcmsxform, In, In, NumPixels);\n\n    diff = clock() - atime;\n    free(In);\n\n    PrintPerformance(Mb, sizeof(cmsFloat32Number), diff);\n    cmsDeleteTransform(hlcmsxform);\n}",
          "fn_code_pos": [
            [
              9178,
              0
            ],
            [
              9224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SpeedTest32bitsGray",
            "parameters": {
              "Title": "char",
              "hlcmsProfileIn": "cmsHPROFILE",
              "hlcmsProfileOut": "cmsHPROFILE",
              "Intent": "cmsInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid SpeedTest16bitsGray(const char * Title, cmsHPROFILE hlcmsProfileIn, cmsHPROFILE hlcmsProfileOut, cmsInt32Number Intent)\n{\n    cmsInt32Number r, g, b, j;\n    clock_t atime;\n    cmsFloat64Number diff;\n    cmsHTRANSFORM hlcmsxform;\n    cmsUInt16Number *In;\n    cmsUInt32Number Mb;\n\n    if (hlcmsProfileIn == NULL || hlcmsProfileOut == NULL)\n        Die(\"Unable to open profiles\");\n\n    hlcmsxform  = cmsCreateTransformTHR(DbgThread(), hlcmsProfileIn,\n        TYPE_GRAY_16, hlcmsProfileOut, TYPE_GRAY_16, Intent, cmsFLAGS_NOCACHE);\n    cmsCloseProfile(hlcmsProfileIn);\n    cmsCloseProfile(hlcmsProfileOut);\n    Mb = 256*256*256 * sizeof(cmsUInt16Number);\n\n    In = (cmsUInt16Number *) chknull(malloc(Mb));\n\n    j = 0;\n    for (r=0; r < 256; r++)\n        for (g=0; g < 256; g++)\n            for (b=0; b < 256; b++) {\n\n                In[j] = (cmsUInt16Number) ((r + g + b) / 3);\n\n                j++;\n            }\n\n    TitlePerformance(Title);\n\n    atime = clock();\n\n    cmsDoTransform(hlcmsxform, In, In, 256*256*256);\n\n    diff = clock() - atime;\n    free(In);\n\n    PrintPerformance(Mb, sizeof(cmsUInt16Number), diff);\n    cmsDeleteTransform(hlcmsxform);\n}",
          "fn_code_pos": [
            [
              9227,
              0
            ],
            [
              9269,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SpeedTest16bitsGray",
            "parameters": {
              "Title": "char",
              "hlcmsProfileIn": "cmsHPROFILE",
              "hlcmsProfileOut": "cmsHPROFILE",
              "Intent": "cmsInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid SpeedTest8bitsGray(const char * Title, cmsHPROFILE hlcmsProfileIn, cmsHPROFILE hlcmsProfileOut, cmsInt32Number Intent)\n{\n    cmsInt32Number r, g, b, j;\n    clock_t atime;\n    cmsFloat64Number diff;\n    cmsHTRANSFORM hlcmsxform;\n    cmsUInt8Number *In;\n    cmsUInt32Number Mb;\n\n\n    if (hlcmsProfileIn == NULL || hlcmsProfileOut == NULL)\n        Die(\"Unable to open profiles\");\n\n    hlcmsxform  = cmsCreateTransformTHR(DbgThread(), hlcmsProfileIn,\n        TYPE_GRAY_8, hlcmsProfileOut, TYPE_GRAY_8, Intent, cmsFLAGS_NOCACHE);\n    cmsCloseProfile(hlcmsProfileIn);\n    cmsCloseProfile(hlcmsProfileOut);\n    Mb = 256*256*256;\n\n    In = (cmsUInt8Number*) chknull(malloc(Mb));\n\n    j = 0;\n    for (r=0; r < 256; r++)\n        for (g=0; g < 256; g++)\n            for (b=0; b < 256; b++) {\n\n                In[j] = (cmsUInt8Number) r;\n\n                j++;\n            }\n\n    TitlePerformance(Title);\n\n    atime = clock();\n\n    cmsDoTransform(hlcmsxform, In, In, 256*256*256);\n\n    diff = clock() - atime;\n    free(In);\n\n    PrintPerformance(Mb, sizeof(cmsUInt8Number), diff);\n    cmsDeleteTransform(hlcmsxform);\n}",
          "fn_code_pos": [
            [
              9272,
              0
            ],
            [
              9315,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SpeedTest8bitsGray",
            "parameters": {
              "Title": "char",
              "hlcmsProfileIn": "cmsHPROFILE",
              "hlcmsProfileOut": "cmsHPROFILE",
              "Intent": "cmsInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\ncmsHPROFILE CreateCurves(void)\n{\n    cmsToneCurve* Gamma = cmsBuildGamma(DbgThread(), 1.1);\n    cmsToneCurve* Transfer[3];\n    cmsHPROFILE h;\n\n    Transfer[0] = Transfer[1] = Transfer[2] = Gamma;\n    h = cmsCreateLinearizationDeviceLink(cmsSigRgbData, Transfer);\n\n    cmsFreeToneCurve(Gamma);\n\n    return h;\n}",
          "fn_code_pos": [
            [
              9318,
              0
            ],
            [
              9331,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CreateCurves",
            "parameters": {},
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "static\nvoid SpeedTest(void)\n{\n    printf(\"\\n\\nP E R F O R M A N C E   T E S T S\\n\");\n    printf(    \"=================================\\n\\n\");\n    fflush(stdout);\n\n    SpeedTest8bits(\"8 bits on CLUT profiles\",\n        cmsOpenProfileFromFile(\"test5.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"test3.icc\", \"r\"),\n        INTENT_PERCEPTUAL);\n\n    SpeedTest16bits(\"16 bits on CLUT profiles\",\n        cmsOpenProfileFromFile(\"test5.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"test3.icc\", \"r\"), INTENT_PERCEPTUAL);\n\n    SpeedTest32bits(\"32 bits on CLUT profiles\",\n        cmsOpenProfileFromFile(\"test5.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"test3.icc\", \"r\"), INTENT_PERCEPTUAL);\n\n    printf(\"\\n\");\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    SpeedTest8bits(\"8 bits on Matrix-Shaper profiles\",\n        cmsOpenProfileFromFile(\"test5.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"aRGBlcms2.icc\", \"r\"),\n        INTENT_PERCEPTUAL);\n\n    SpeedTest16bits(\"16 bits on Matrix-Shaper profiles\",\n       cmsOpenProfileFromFile(\"test5.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"aRGBlcms2.icc\", \"r\"),\n        INTENT_PERCEPTUAL);\n\n    SpeedTest32bits(\"32 bits on Matrix-Shaper profiles\",\n       cmsOpenProfileFromFile(\"test5.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"aRGBlcms2.icc\", \"r\"),\n        INTENT_PERCEPTUAL);\n\n    printf(\"\\n\");\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    SpeedTest8bits(\"8 bits on SAME Matrix-Shaper profiles\",\n        cmsOpenProfileFromFile(\"test5.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"test5.icc\", \"r\"),\n        INTENT_PERCEPTUAL);\n\n    SpeedTest16bits(\"16 bits on SAME Matrix-Shaper profiles\",\n        cmsOpenProfileFromFile(\"aRGBlcms2.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"aRGBlcms2.icc\", \"r\"),\n        INTENT_PERCEPTUAL);\n\n    SpeedTest32bits(\"32 bits on SAME Matrix-Shaper profiles\",\n        cmsOpenProfileFromFile(\"aRGBlcms2.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"aRGBlcms2.icc\", \"r\"),\n        INTENT_PERCEPTUAL);\n\n    printf(\"\\n\");\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    SpeedTest8bits(\"8 bits on Matrix-Shaper profiles (AbsCol)\",\n       cmsOpenProfileFromFile(\"test5.icc\", \"r\"),\n       cmsOpenProfileFromFile(\"aRGBlcms2.icc\", \"r\"),\n        INTENT_ABSOLUTE_COLORIMETRIC);\n\n    SpeedTest16bits(\"16 bits on Matrix-Shaper profiles (AbsCol)\",\n       cmsOpenProfileFromFile(\"test5.icc\", \"r\"),\n       cmsOpenProfileFromFile(\"aRGBlcms2.icc\", \"r\"),\n        INTENT_ABSOLUTE_COLORIMETRIC);\n\n    SpeedTest32bits(\"32 bits on Matrix-Shaper profiles (AbsCol)\",\n       cmsOpenProfileFromFile(\"test5.icc\", \"r\"),\n       cmsOpenProfileFromFile(\"aRGBlcms2.icc\", \"r\"),\n        INTENT_ABSOLUTE_COLORIMETRIC);\n\n    printf(\"\\n\");\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    SpeedTest8bits(\"8 bits on curves\",\n        CreateCurves(),\n        CreateCurves(),\n        INTENT_PERCEPTUAL);\n\n    SpeedTest16bits(\"16 bits on curves\",\n        CreateCurves(),\n        CreateCurves(),\n        INTENT_PERCEPTUAL);\n\n    SpeedTest32bits(\"32 bits on curves\",\n        CreateCurves(),\n        CreateCurves(),\n        INTENT_PERCEPTUAL);\n\n    printf(\"\\n\");\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    SpeedTest8bitsCMYK(\"8 bits on CMYK profiles\",\n        cmsOpenProfileFromFile(\"test1.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"test2.icc\", \"r\"));\n\n    SpeedTest16bitsCMYK(\"16 bits on CMYK profiles\",\n        cmsOpenProfileFromFile(\"test1.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"test2.icc\", \"r\"));\n\n    SpeedTest32bitsCMYK(\"32 bits on CMYK profiles\",\n        cmsOpenProfileFromFile(\"test1.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"test2.icc\", \"r\"));\n\n    printf(\"\\n\");\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    SpeedTest8bitsGray(\"8 bits on gray-to gray\",\n        cmsOpenProfileFromFile(\"gray3lcms2.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"graylcms2.icc\", \"r\"), INTENT_RELATIVE_COLORIMETRIC);\n\n    SpeedTest16bitsGray(\"16 bits on gray-to gray\",\n        cmsOpenProfileFromFile(\"gray3lcms2.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"graylcms2.icc\", \"r\"), INTENT_RELATIVE_COLORIMETRIC);\n\n    SpeedTest32bitsGray(\"32 bits on gray-to gray\",\n        cmsOpenProfileFromFile(\"gray3lcms2.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"graylcms2.icc\", \"r\"), INTENT_RELATIVE_COLORIMETRIC);\n\n    printf(\"\\n\");\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    SpeedTest8bitsGray(\"8 bits on gray-to-lab gray\",\n        cmsOpenProfileFromFile(\"graylcms2.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"glablcms2.icc\", \"r\"), INTENT_RELATIVE_COLORIMETRIC);\n\n    SpeedTest16bitsGray(\"16 bits on gray-to-lab gray\",\n        cmsOpenProfileFromFile(\"graylcms2.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"glablcms2.icc\", \"r\"), INTENT_RELATIVE_COLORIMETRIC);\n\n    SpeedTest32bitsGray(\"32 bits on gray-to-lab gray\",\n        cmsOpenProfileFromFile(\"graylcms2.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"glablcms2.icc\", \"r\"), INTENT_RELATIVE_COLORIMETRIC);\n\n    printf(\"\\n\");\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    SpeedTest8bitsGray(\"8 bits on SAME gray-to-gray\",\n        cmsOpenProfileFromFile(\"graylcms2.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"graylcms2.icc\", \"r\"), INTENT_PERCEPTUAL);\n\n    SpeedTest16bitsGray(\"16 bits on SAME gray-to-gray\",\n        cmsOpenProfileFromFile(\"graylcms2.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"graylcms2.icc\", \"r\"), INTENT_PERCEPTUAL);\n\n    SpeedTest32bitsGray(\"32 bits on SAME gray-to-gray\",\n        cmsOpenProfileFromFile(\"graylcms2.icc\", \"r\"),\n        cmsOpenProfileFromFile(\"graylcms2.icc\", \"r\"), INTENT_PERCEPTUAL);\n\n    printf(\"\\n\");\n}",
          "fn_code_pos": [
            [
              9334,
              0
            ],
            [
              9495,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SpeedTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid PrintSupportedIntents(void)\n{\n    cmsUInt32Number n, i;\n    cmsUInt32Number Codes[200];\n    char* Descriptions[200];\n\n    n = cmsGetSupportedIntents(200, Codes, Descriptions);\n\n    printf(\"Supported intents:\\n\");\n    for (i=0; i < n; i++) {\n        printf(\"\\t%u - %s\\n\", Codes[i], Descriptions[i]);\n    }\n    printf(\"\\n\");\n}",
          "fn_code_pos": [
            [
              9502,
              0
            ],
            [
              9516,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintSupportedIntents",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(int argc, char* argv[])\n{\n    cmsInt32Number Exhaustive = 0;\n    cmsInt32Number DoSpeedTests = 1;\n    cmsInt32Number DoCheckTests = 1;\n    cmsInt32Number DoPluginTests = 1;\n\n#ifdef CMS_IS_WINDOWS_\n    cmsInt32Number DoZooTests = 0;\n#endif\n\n#ifdef _MSC_VER\n    _CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );\n#endif\n\n    // First of all, check for the right header\n    if (cmsGetEncodedCMMversion() != LCMS_VERSION) {\n        Die(\"Oops, you are mixing header and shared lib!\\nHeader version reports to be '%d' and shared lib '%d'\\n\", LCMS_VERSION, cmsGetEncodedCMMversion());\n    }\n\n    printf(\"LittleCMS %2.2f test bed %s %s\\n\\n\", cmsGetEncodedCMMversion() / 1000.0, __DATE__, __TIME__);\n\n    if ((argc == 2) && strcmp(argv[1], \"--exhaustive\") == 0) {\n\n        Exhaustive = 1;\n        printf(\"Running exhaustive tests (will take a while...)\\n\\n\");\n    }\n    else\n        if ((argc == 3) && strcmp(argv[1], \"--chdir\") == 0) {\n            CHDIR(argv[2]);\n        }\n\n    printf(\"Installing debug memory plug-in ... \");\n    cmsPlugin(&DebugMemHandler);\n    printf(\"done.\\n\");\n\n    printf(\"Installing error logger ... \");\n    cmsSetLogErrorHandler(FatalErrorQuit);\n    printf(\"done.\\n\");\n       \n    PrintSupportedIntents();\n\n    Check(\"Base types\", CheckBaseTypes);\n    Check(\"endianness\", CheckEndianness);\n    Check(\"quick floor\", CheckQuickFloor);\n    Check(\"quick floor word\", CheckQuickFloorWord);\n    Check(\"Fixed point 15.16 representation\", CheckFixedPoint15_16);\n    Check(\"Fixed point 8.8 representation\", CheckFixedPoint8_8);\n    Check(\"D50 roundtrip\", CheckD50Roundtrip);\n\n    // Create utility profiles\n    if (DoCheckTests || DoSpeedTests)\n        Check(\"Creation of test profiles\", CreateTestProfiles);\n\n    if (DoCheckTests) {\n   \n    // Forward 1D interpolation\n    Check(\"1D interpolation in 2pt tables\", Check1DLERP2);\n    Check(\"1D interpolation in 3pt tables\", Check1DLERP3);\n    Check(\"1D interpolation in 4pt tables\", Check1DLERP4);\n    Check(\"1D interpolation in 6pt tables\", Check1DLERP6);\n    Check(\"1D interpolation in 18pt tables\", Check1DLERP18);\n    Check(\"1D interpolation in descending 2pt tables\", Check1DLERP2Down);\n    Check(\"1D interpolation in descending 3pt tables\", Check1DLERP3Down);\n    Check(\"1D interpolation in descending 6pt tables\", Check1DLERP6Down);\n    Check(\"1D interpolation in descending 18pt tables\", Check1DLERP18Down);\n\n    if (Exhaustive) {\n\n        Check(\"1D interpolation in n tables\", ExhaustiveCheck1DLERP);\n        Check(\"1D interpolation in descending tables\", ExhaustiveCheck1DLERPDown);\n    }\n\n    // Forward 3D interpolation\n    Check(\"3D interpolation Tetrahedral (float) \", Check3DinterpolationFloatTetrahedral);\n    Check(\"3D interpolation Trilinear (float) \", Check3DinterpolationFloatTrilinear);\n    Check(\"3D interpolation Tetrahedral (16) \", Check3DinterpolationTetrahedral16);\n    Check(\"3D interpolation Trilinear (16) \", Check3DinterpolationTrilinear16);\n\n    if (Exhaustive) {\n\n        Check(\"Exhaustive 3D interpolation Tetrahedral (float) \", ExaustiveCheck3DinterpolationFloatTetrahedral);\n        Check(\"Exhaustive 3D interpolation Trilinear  (float) \", ExaustiveCheck3DinterpolationFloatTrilinear);\n        Check(\"Exhaustive 3D interpolation Tetrahedral (16) \", ExhaustiveCheck3DinterpolationTetrahedral16);\n        Check(\"Exhaustive 3D interpolation Trilinear (16) \", ExhaustiveCheck3DinterpolationTrilinear16);\n    }\n\n    Check(\"Reverse interpolation 3 -> 3\", CheckReverseInterpolation3x3);\n    Check(\"Reverse interpolation 4 -> 3\", CheckReverseInterpolation4x3);\n\n\n    // High dimensionality interpolation\n\n    Check(\"3D interpolation\", Check3Dinterp);\n    Check(\"3D interpolation with granularity\", Check3DinterpGranular);\n    Check(\"4D interpolation\", Check4Dinterp);\n    Check(\"4D interpolation with granularity\", Check4DinterpGranular);\n    Check(\"5D interpolation with granularity\", Check5DinterpGranular);\n    Check(\"6D interpolation with granularity\", Check6DinterpGranular);\n    Check(\"7D interpolation with granularity\", Check7DinterpGranular);\n    Check(\"8D interpolation with granularity\", Check8DinterpGranular);\n\n    // Encoding of colorspaces\n    Check(\"Lab to LCh and back (float only) \", CheckLab2LCh);\n    Check(\"Lab to XYZ and back (float only) \", CheckLab2XYZ);\n    Check(\"Lab to xyY and back (float only) \", CheckLab2xyY);\n    Check(\"Lab V2 encoding\", CheckLabV2encoding);\n    Check(\"Lab V4 encoding\", CheckLabV4encoding);\n\n    // BlackBody\n    Check(\"Blackbody radiator\", CheckTemp2CHRM);\n\n    // Tone curves\n    Check(\"Linear gamma curves (16 bits)\", CheckGammaCreation16);\n    Check(\"Linear gamma curves (float)\", CheckGammaCreationFlt);\n\n    Check(\"Curve 1.8 (float)\", CheckGamma18);\n    Check(\"Curve 2.2 (float)\", CheckGamma22);\n    Check(\"Curve 3.0 (float)\", CheckGamma30);\n\n    Check(\"Curve 1.8 (table)\", CheckGamma18Table);\n    Check(\"Curve 2.2 (table)\", CheckGamma22Table);\n    Check(\"Curve 3.0 (table)\", CheckGamma30Table);\n\n    Check(\"Curve 1.8 (word table)\", CheckGamma18TableWord);\n    Check(\"Curve 2.2 (word table)\", CheckGamma22TableWord);\n    Check(\"Curve 3.0 (word table)\", CheckGamma30TableWord);\n\n    Check(\"Parametric curves\", CheckParametricToneCurves);\n\n    Check(\"Join curves\", CheckJointCurves);\n    Check(\"Join curves descending\", CheckJointCurvesDescending);\n    Check(\"Join curves degenerated\", CheckReverseDegenerated);\n    Check(\"Join curves sRGB (Float)\", CheckJointFloatCurves_sRGB);\n    Check(\"Join curves sRGB (16 bits)\", CheckJoint16Curves_sRGB);\n    Check(\"Join curves sigmoidal\", CheckJointCurvesSShaped);\n\n    // LUT basics\n    Check(\"LUT creation & dup\", CheckLUTcreation);\n    Check(\"1 Stage LUT \", Check1StageLUT);\n    Check(\"2 Stage LUT \", Check2StageLUT);\n    Check(\"2 Stage LUT (16 bits)\", Check2Stage16LUT);\n    Check(\"3 Stage LUT \", Check3StageLUT);\n    Check(\"3 Stage LUT (16 bits)\", Check3Stage16LUT);\n    Check(\"4 Stage LUT \", Check4StageLUT);\n    Check(\"4 Stage LUT (16 bits)\", Check4Stage16LUT);\n    Check(\"5 Stage LUT \", Check5StageLUT);\n    Check(\"5 Stage LUT (16 bits) \", Check5Stage16LUT);\n    Check(\"6 Stage LUT \", Check6StageLUT);\n    Check(\"6 Stage LUT (16 bits) \", Check6Stage16LUT);\n\n    // LUT operation\n    Check(\"Lab to Lab LUT (float only) \", CheckLab2LabLUT);\n    Check(\"XYZ to XYZ LUT (float only) \", CheckXYZ2XYZLUT);\n    Check(\"Lab to Lab MAT LUT (float only) \", CheckLab2LabMatLUT);\n    Check(\"Named Color LUT\", CheckNamedColorLUT);\n    Check(\"Usual formatters\", CheckFormatters16);\n    Check(\"Floating point formatters\", CheckFormattersFloat);\n\n#ifndef CMS_NO_HALF_SUPPORT \n    Check(\"HALF formatters\", CheckFormattersHalf);\n#endif\n    // ChangeBuffersFormat\n    Check(\"ChangeBuffersFormat\", CheckChangeBufferFormat);\n\n    // MLU\n    Check(\"Multilocalized Unicode\", CheckMLU);\n    Check(\"Multilocalized Unicode (II)\", CheckMLU_UTF8);\n\n    // Named color\n    Check(\"Named color lists\", CheckNamedColorList);\n    Check(\"Create named color profile\", CreateNamedColorProfile);\n\n\n    // Profile I/O (this one is huge!)\n    Check(\"Profile creation\", CheckProfileCreation);\n    Check(\"Header version\", CheckVersionHeaderWriting);\n    Check(\"Multilocalized profile\", CheckMultilocalizedProfile);\n\n    // Error reporting\n    Check(\"Error reporting on bad profiles\", CheckErrReportingOnBadProfiles);\n    Check(\"Error reporting on bad transforms\", CheckErrReportingOnBadTransforms);\n\n    // Transforms\n    Check(\"Curves only transforms\", CheckCurvesOnlyTransforms);\n    Check(\"Float Lab->Lab transforms\", CheckFloatLabTransforms);\n    Check(\"Encoded Lab->Lab transforms\", CheckEncodedLabTransforms);\n    Check(\"Stored identities\", CheckStoredIdentities);\n\n    Check(\"Matrix-shaper transform (float)\",   CheckMatrixShaperXFORMFloat);\n    Check(\"Matrix-shaper transform (16 bits)\", CheckMatrixShaperXFORM16);\n    Check(\"Matrix-shaper transform (8 bits)\",  CheckMatrixShaperXFORM8);\n\n    Check(\"Primaries of sRGB\", CheckRGBPrimaries);\n\n    // Known values\n    Check(\"Known values across matrix-shaper\", Chack_sRGB_Float);\n    Check(\"Gray input profile\", CheckInputGray);\n    Check(\"Gray Lab input profile\", CheckLabInputGray);\n    Check(\"Gray output profile\", CheckOutputGray);\n    Check(\"Gray Lab output profile\", CheckLabOutputGray);\n\n    Check(\"Matrix-shaper proofing transform (float)\",   CheckProofingXFORMFloat);\n    Check(\"Matrix-shaper proofing transform (16 bits)\",  CheckProofingXFORM16);\n\n    Check(\"Gamut check\", CheckGamutCheck);\n\n    Check(\"CMYK roundtrip on perceptual transform\",   CheckCMYKRoundtrip);\n\n    Check(\"CMYK perceptual transform\",   CheckCMYKPerceptual);\n    // Check(\"CMYK rel.col. transform\",   CheckCMYKRelCol);\n\n    Check(\"Black ink only preservation\", CheckKOnlyBlackPreserving);\n    Check(\"Black plane preservation\", CheckKPlaneBlackPreserving);\n\n\n    Check(\"Deciding curve types\", CheckV4gamma);\n\n    Check(\"Black point detection\", CheckBlackPoint);\n    Check(\"TAC detection\", CheckTAC);\n\n    Check(\"CGATS parser\", CheckCGATS);\n    Check(\"CGATS parser on junk\", CheckCGATS2);\n    Check(\"CGATS parser on overflow\", CheckCGATS_Overflow);\n    Check(\"PostScript generator\", CheckPostScript);\n    Check(\"Segment maxima GBD\", CheckGBD);\n    Check(\"MD5 digest\", CheckMD5);\n    Check(\"Linking\", CheckLinking);\n    Check(\"floating point tags on XYZ\", CheckFloatXYZ);\n    Check(\"RGB->Lab->RGB with alpha on FLT\", ChecksRGB2LabFLT);\n    Check(\"Parametric curve on Rec709\", CheckParametricRec709);\n    Check(\"Floating Point sampled curve with non-zero start\", CheckFloatSamples);\n    Check(\"Floating Point segmented curve with short sampled segment\", CheckFloatSegments);\n    Check(\"Read RAW tags\", CheckReadRAW);\n    Check(\"Check MetaTag\", CheckMeta);\n    Check(\"Null transform on floats\", CheckFloatNULLxform);\n    Check(\"Set free a tag\", CheckRemoveTag);\n    Check(\"Matrix simplification\", CheckMatrixSimplify);\n    Check(\"Planar 8 optimization\", CheckPlanar8opt);\n    Check(\"Planar float to int16\", CheckPlanarFloat2int);\n    Check(\"Swap endian feature\", CheckSE);\n    Check(\"Transform line stride RGB\", CheckTransformLineStride);\n    Check(\"Forged MPE profile\", CheckForgedMPE);\n    Check(\"Proofing intersection\", CheckProofingIntersection);\n    Check(\"Empty MLUC\", CheckEmptyMLUC);\n    Check(\"sRGB round-trips\", Check_sRGB_Rountrips);\n    Check(\"OkLab color space\", Check_OkLab);\n    Check(\"OkLab color space (2)\", Check_OkLab2);\n    Check(\"Gamma space detection\", CheckGammaSpaceDetection);\n    Check(\"Unbounded mode w/ integer output\", CheckIntToFloatTransform);\n    Check(\"Corrupted built-in by using cmsWriteRawTag\", CheckInducedCorruption);\n    Check(\"Bad CGATS file\", CheckBadCGATS);\n    Check(\"Saving linearization devicelink\", CheckSaveLinearizationDevicelink);\n    }\n\n    if (DoPluginTests)\n    {\n\n        Check(\"Context memory handling\", CheckAllocContext);\n        Check(\"Simple context functionality\", CheckSimpleContext);\n        Check(\"Alarm codes context\", CheckAlarmColorsContext);\n        Check(\"Adaptation state context\", CheckAdaptationStateContext);\n        Check(\"1D interpolation plugin\", CheckInterp1DPlugin); \n        Check(\"3D interpolation plugin\", CheckInterp3DPlugin); \n        Check(\"Parametric curve plugin\", CheckParametricCurvePlugin);        \n        Check(\"Formatters plugin\",       CheckFormattersPlugin);        \n        Check(\"Tag type plugin\",         CheckTagTypePlugin);\n        Check(\"MPE type plugin\",         CheckMPEPlugin);       \n        Check(\"Optimization plugin\",     CheckOptimizationPlugin); \n        Check(\"Rendering intent plugin\", CheckIntentPlugin);\n        Check(\"Full transform plugin\",   CheckTransformPlugin);\n        Check(\"Mutex plugin\",            CheckMutexPlugin);\n       \n    }\n\n\n    if (DoSpeedTests)\n        SpeedTest();\n\n\n#ifdef CMS_IS_WINDOWS_\n    if (DoZooTests) \n         CheckProfileZOO();\n#endif\n\n    DebugMemPrintTotals();\n\n    cmsUnregisterPlugins();\n\n    // Cleanup\n    if (DoCheckTests || DoSpeedTests)\n        RemoveTestProfiles();\n\n   return TotalFail;\n}",
          "fn_code_pos": [
            [
              9521,
              0
            ],
            [
              9815,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*TestFn)(void)",
          "fn_dec_pos": [
            [
              29,
              23
            ],
            [
              29,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "(* dblfnptr)(cmsFloat32Number x, const cmsFloat64Number Params[])",
          "fn_dec_pos": [
            [
              32,
              25
            ],
            [
              32,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "x": "cmsFloat32Number",
              "Params": "cmsFloat64Number"
            },
            "return_type": "cmsFloat32Number"
          }
        },
        {
          "fn_code": "chknull(void* mem)",
          "fn_dec_pos": [
            [
              59,
              6
            ],
            [
              59,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "chknull",
            "parameters": {
              "mem": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DebugMalloc(cmsContext ContextID, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              110,
              6
            ],
            [
              110,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DebugMalloc",
            "parameters": {
              "ContextID": "cmsContext",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DebugRealloc(cmsContext ContextID, void* Ptr, cmsUInt32Number NewSize)",
          "fn_dec_pos": [
            [
              160,
              7
            ],
            [
              160,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DebugRealloc",
            "parameters": {
              "ContextID": "cmsContext",
              "Ptr": "void",
              "NewSize": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "MemStr(cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              196,
              12
            ],
            [
              196,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MemStr",
            "parameters": {
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PluginMemHandler(void)",
          "fn_dec_pos": [
            [
              228,
              6
            ],
            [
              228,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PluginMemHandler",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "GammaTableLinear(cmsInt32Number nEntries, cmsBool Dir)",
          "fn_dec_pos": [
            [
              2626,
              14
            ],
            [
              2626,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GammaTableLinear",
            "parameters": {
              "nEntries": "cmsInt32Number",
              "Dir": "cmsBool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Build_sRGBGamma(void)",
          "fn_dec_pos": [
            [
              2729,
              14
            ],
            [
              2729,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Build_sRGBGamma",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CombineGammaFloat(cmsToneCurve* g1, cmsToneCurve* g2)",
          "fn_dec_pos": [
            [
              2746,
              14
            ],
            [
              2746,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CombineGammaFloat",
            "parameters": {
              "g1": "cmsToneCurve",
              "g2": "cmsToneCurve"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CombineGamma16(cmsToneCurve* g1, cmsToneCurve* g2)",
          "fn_dec_pos": [
            [
              2765,
              14
            ],
            [
              2765,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CombineGamma16",
            "parameters": {
              "g1": "cmsToneCurve",
              "g2": "cmsToneCurve"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CreateSegmentedCurve(void)",
          "fn_dec_pos": [
            [
              4855,
              14
            ],
            [
              4855,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CreateSegmentedCurve",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "(*Function)(cmsFloat32Number x)",
          "fn_dec_pos": [
            [
              7819,
              24
            ],
            [
              7819,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "x": "cmsFloat32Number"
            },
            "return_type": "cmsFloat32Number"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n    cmsUInt32Number KeepSize;\n    cmsContext      WhoAllocated;\n    cmsUInt32Number DontCheck;\n\n    union {\n        cmsUInt64Number HiSparc;\n\n        // '_cmsMemoryBlock' block is prepended by the\n        // allocator for any requested size. Thus, union holds\n        // \"widest\" type to guarantee proper '_cmsMemoryBlock'\n        // alignment for any requested size.\n\n    } alignment;\n\n\n} _cmsMemoryBlock;",
          {
            "KeepSize": "cmsUInt32Number",
            "WhoAllocated": "cmsContext",
            "DontCheck": "cmsUInt32Number",
            "alignment": "union {\n        cmsUInt64Number HiSparc;\n\n        // '_cmsMemoryBlock' block is prepended by the\n        // allocator for any requested size. Thus, union holds\n        // \"widest\" type to guarantee proper '_cmsMemoryBlock'\n        // alignment for any requested size.\n\n    }",
            "HiSparc": "cmsUInt64Number"
          },
          "_cmsMemoryBlock",
          [
            76,
            0
          ],
          [
            92,
            18
          ]
        ],
        [
          "typedef struct {\n\n    cmsHTRANSFORM hLab2sRGB;\n    cmsHTRANSFORM sRGB2Lab;\n    cmsHTRANSFORM hIlimit;\n\n} FakeCMYKParams;",
          {
            "hLab2sRGB": "cmsHTRANSFORM",
            "sRGB2Lab": "cmsHTRANSFORM",
            "hIlimit": "cmsHTRANSFORM"
          },
          "FakeCMYKParams",
          [
            453,
            0
          ],
          [
            459,
            17
          ]
        ],
        [
          "typedef struct {cmsUInt8Number r, g, b, a;}    Scanline_rgba8;",
          {
            "r": "cmsUInt8Number"
          },
          "Scanline_rgba8",
          [
            8836,
            0
          ],
          [
            8836,
            62
          ]
        ],
        [
          "typedef struct {cmsUInt16Number r, g, b, a;}   Scanline_rgba16;",
          {
            "r": "cmsUInt16Number"
          },
          "Scanline_rgba16",
          [
            8837,
            0
          ],
          [
            8837,
            63
          ]
        ],
        [
          "typedef struct {cmsFloat32Number r, g, b, a;}  Scanline_rgba32;",
          {
            "r": "cmsFloat32Number"
          },
          "Scanline_rgba32",
          [
            8838,
            0
          ],
          [
            8838,
            63
          ]
        ],
        [
          "typedef struct {cmsUInt8Number r, g, b;}       Scanline_rgb8;",
          {
            "r": "cmsUInt8Number"
          },
          "Scanline_rgb8",
          [
            8839,
            0
          ],
          [
            8839,
            61
          ]
        ],
        [
          "typedef struct {cmsUInt16Number r, g, b;}      Scanline_rgb16;",
          {
            "r": "cmsUInt16Number"
          },
          "Scanline_rgb16",
          [
            8840,
            0
          ],
          [
            8840,
            62
          ]
        ],
        [
          "typedef struct {cmsFloat32Number r, g, b;}     Scanline_rgb32;",
          {
            "r": "cmsFloat32Number"
          },
          "Scanline_rgb32",
          [
            8841,
            0
          ],
          [
            8841,
            62
          ]
        ],
        [
          "typedef struct {\n    cmsUInt32Number KeepSize;\n    cmsContext      WhoAllocated;\n    cmsUInt32Number DontCheck;\n\n    union {\n        cmsUInt64Number HiSparc;\n\n        // '_cmsMemoryBlock' block is prepended by the\n        // allocator for any requested size. Thus, union holds\n        // \"widest\" type to guarantee proper '_cmsMemoryBlock'\n        // alignment for any requested size.\n\n    } alignment;\n\n\n} _cmsMemoryBlock;",
          {
            "KeepSize": "cmsUInt32Number",
            "WhoAllocated": "cmsContext",
            "DontCheck": "cmsUInt32Number",
            "alignment": "union {\n        cmsUInt64Number HiSparc;\n\n        // '_cmsMemoryBlock' block is prepended by the\n        // allocator for any requested size. Thus, union holds\n        // \"widest\" type to guarantee proper '_cmsMemoryBlock'\n        // alignment for any requested size.\n\n    }",
            "HiSparc": "cmsUInt64Number"
          },
          "_cmsMemoryBlock",
          [
            76,
            0
          ],
          [
            92,
            18
          ]
        ],
        [
          "typedef struct {\n\n    cmsHTRANSFORM hLab2sRGB;\n    cmsHTRANSFORM sRGB2Lab;\n    cmsHTRANSFORM hIlimit;\n\n} FakeCMYKParams;",
          {
            "hLab2sRGB": "cmsHTRANSFORM",
            "sRGB2Lab": "cmsHTRANSFORM",
            "hIlimit": "cmsHTRANSFORM"
          },
          "FakeCMYKParams",
          [
            453,
            0
          ],
          [
            459,
            17
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            4508,
            4
          ],
          [
            4508,
            13
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            4523,
            18
          ],
          [
            4523,
            27
          ]
        ],
        [
          "typedef struct {cmsUInt8Number r, g, b, a;}    Scanline_rgba8;",
          {
            "r": "cmsUInt8Number"
          },
          "Scanline_rgba8",
          [
            8836,
            0
          ],
          [
            8836,
            62
          ]
        ],
        [
          "typedef struct {cmsUInt16Number r, g, b, a;}   Scanline_rgba16;",
          {
            "r": "cmsUInt16Number"
          },
          "Scanline_rgba16",
          [
            8837,
            0
          ],
          [
            8837,
            63
          ]
        ],
        [
          "typedef struct {cmsFloat32Number r, g, b, a;}  Scanline_rgba32;",
          {
            "r": "cmsFloat32Number"
          },
          "Scanline_rgba32",
          [
            8838,
            0
          ],
          [
            8838,
            63
          ]
        ],
        [
          "typedef struct {cmsUInt8Number r, g, b;}       Scanline_rgb8;",
          {
            "r": "cmsUInt8Number"
          },
          "Scanline_rgb8",
          [
            8839,
            0
          ],
          [
            8839,
            61
          ]
        ],
        [
          "typedef struct {cmsUInt16Number r, g, b;}      Scanline_rgb16;",
          {
            "r": "cmsUInt16Number"
          },
          "Scanline_rgb16",
          [
            8840,
            0
          ],
          [
            8840,
            62
          ]
        ],
        [
          "typedef struct {cmsFloat32Number r, g, b;}     Scanline_rgb32;",
          {
            "r": "cmsFloat32Number"
          },
          "Scanline_rgb32",
          [
            8841,
            0
          ],
          [
            8841,
            62
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"testcms2.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    }
  },
  "head": {
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/threaded/include/lcms2_threaded.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "cmsThreadedExtensions(cmsInt32Number max_threads, cmsUInt32Number flags)",
          "fn_dec_pos": [
            [
              49,
              23
            ],
            [
              49,
              95
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsThreadedExtensions",
            "parameters": {
              "max_threads": "cmsInt32Number",
              "flags": "cmsUInt32Number"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"lcms2_plugin.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/threaded/src/threaded_internal.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "_cmsThrCountSlices(struct _cmstransform_struct* CMMcargo, cmsInt32Number MaxWorkers, \n\t\t\t\t\t\t\t\t   cmsUInt32Number PixelsPerLine, cmsUInt32Number LineCount, \n\t\t\t\t\t\t\t\t   cmsStride* Stride)",
          "fn_dec_pos": [
            [
              57,
              16
            ],
            [
              59,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsThrCountSlices",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "MaxWorkers": "cmsInt32Number",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "_cmsThrSplitWork(const _cmsWorkSlice* master, cmsInt32Number nslices, _cmsWorkSlice slices[])",
          "fn_dec_pos": [
            [
              62,
              13
            ],
            [
              62,
              106
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsThrSplitWork",
            "parameters": {
              "master": "_cmsWorkSlice",
              "nslices": "cmsInt32Number",
              "slices": "_cmsWorkSlice"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsThrCreateWorker(cmsContext ContextID, _cmsTransform2Fn worker, _cmsWorkSlice* param)",
          "fn_dec_pos": [
            [
              65,
              16
            ],
            [
              65,
              104
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsThrCreateWorker",
            "parameters": {
              "ContextID": "cmsContext",
              "worker": "_cmsTransform2Fn",
              "param": "_cmsWorkSlice"
            },
            "return_type": "cmsHANDLE"
          }
        },
        {
          "fn_code": "_cmsThrJoinWorker(cmsContext ContextID, cmsHANDLE hWorker)",
          "fn_dec_pos": [
            [
              66,
              16
            ],
            [
              66,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsThrJoinWorker",
            "parameters": {
              "ContextID": "cmsContext",
              "hWorker": "cmsHANDLE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsThrIdealThreadCount(void)",
          "fn_dec_pos": [
            [
              67,
              16
            ],
            [
              67,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsThrIdealThreadCount",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "_cmsThrScheduler(struct _cmstransform_struct* CMMcargo,\n\t\t\t\t       const void* InputBuffer,\n\t\t\t\t       void* OutputBuffer,\n\t\t\t\t       cmsUInt32Number PixelsPerLine,\n\t\t\t\t       cmsUInt32Number LineCount,\n\t\t\t\t       const cmsStride* Stride)",
          "fn_dec_pos": [
            [
              70,
              6
            ],
            [
              75,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsThrScheduler",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "InputBuffer": "void",
              "OutputBuffer": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\n\tstruct _cmstransform_struct* CMMcargo;\n\n\tconst void* InputBuffer;\n\tvoid* OutputBuffer;\n\n\tcmsUInt32Number  PixelsPerLine;\n\tcmsUInt32Number  LineCount;\n\tconst cmsStride* Stride;\n\n} _cmsWorkSlice;",
          {
            "* CMMcargo": "struct _cmstransform_struct",
            "void": "const",
            "* OutputBuffer": "void",
            "PixelsPerLine": "cmsUInt32Number",
            "LineCount": "cmsUInt32Number",
            "cmsStride": "const"
          },
          "_cmsWorkSlice",
          [
            43,
            0
          ],
          [
            54,
            16
          ]
        ],
        [
          "typedef struct {\n\n\tstruct _cmstransform_struct* CMMcargo;\n\n\tconst void* InputBuffer;\n\tvoid* OutputBuffer;\n\n\tcmsUInt32Number  PixelsPerLine;\n\tcmsUInt32Number  LineCount;\n\tconst cmsStride* Stride;\n\n} _cmsWorkSlice;",
          {
            "* CMMcargo": "struct _cmstransform_struct",
            "void": "const",
            "* OutputBuffer": "void",
            "PixelsPerLine": "cmsUInt32Number",
            "LineCount": "cmsUInt32Number",
            "cmsStride": "const"
          },
          "_cmsWorkSlice",
          [
            43,
            0
          ],
          [
            54,
            16
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            45,
            1
          ],
          [
            45,
            28
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            57,
            35
          ],
          [
            57,
            62
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            70,
            23
          ],
          [
            70,
            50
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_threaded.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/fast_float/include/lcms2_fast_float.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "cmsFastFloatExtensions(void)",
          "fn_dec_pos": [
            [
              51,
              23
            ],
            [
              51,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFastFloatExtensions",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"lcms2_plugin.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/plugins/fast_float/src/fast_float_internal.h": {
      "fn_def_list": [
        {
          "fn_code": "cmsINLINE cmsS15Fixed16Number _cmsToFixedDomain(int a)                   { return a + ((a + 0x7fff) / 0xffff); }",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              76,
              112
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsS15Fixed16Number _cmsToFixedDomain",
            "parameters": {
              "a": "int"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int                 _cmsFromFixedDomain(cmsS15Fixed16Number a) { return a - ((a + 0x7fff) >> 16); }",
          "fn_code_pos": [
            [
              77,
              0
            ],
            [
              77,
              109
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsFromFixedDomain",
            "parameters": {
              "a": "cmsS15Fixed16Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE cmsFloat32Number fclamp(cmsFloat32Number v)\n{\n    return ((v < 1.0e-9f) || isnan(v)) ? 0.0f : (v > 1.0f ? 1.0f : v);\n}",
          "fn_code_pos": [
            [
              90,
              0
            ],
            [
              93,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFloat32Number fclamp",
            "parameters": {
              "v": "cmsFloat32Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsQuickFloor(cmsFloat64Number val)\n{\n#ifdef CMS_DONT_USE_FAST_FLOOR\n       return (int)floor(val);\n#else\n#define _lcms_double2fixmagic  (68719476736.0 * 1.5)  \n\n       union {\n              cmsFloat64Number val;\n              int halves[2];\n       } temp;\n\n       temp.val = val + _lcms_double2fixmagic;\n\n#ifdef CMS_USE_BIG_ENDIAN\n       return temp.halves[1] >> 16;\n#else\n       return temp.halves[0] >> 16;\n#endif\n#endif\n}",
          "fn_code_pos": [
            [
              96,
              0
            ],
            [
              116,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsQuickFloor",
            "parameters": {
              "val": "cmsFloat64Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE cmsUInt16Number _cmsSaturateWord(cmsFloat64Number d)\n{\n       d += 0.5;\n\n       if (d <= 0) return 0;\n       if (d >= 65535.0) return 0xffff;\n\n       return (cmsUInt16Number)floor(d);\n}",
          "fn_code_pos": [
            [
              119,
              0
            ],
            [
              127,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsUInt16Number _cmsSaturateWord",
            "parameters": {
              "d": "cmsFloat64Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE cmsFloat32Number flerp(const cmsFloat32Number LutTable[], cmsFloat32Number v)\n{\n       cmsFloat32Number y1, y0;\n       cmsFloat32Number rest;\n       int cell0, cell1;\n      \n       if (isnan(v))\n           return LutTable[0];\n\n       if (v < 1.0e-9f) {\n              return v;\n       }\n       else\n              if (v >= 1.0) {\n                    return v;\n              }\n\n       v *= (MAX_NODES_IN_CURVE - 1);\n\n       cell0 = _cmsQuickFloor(v);\n       cell1 = (int)ceilf(v);\n\n       // Rest is 16 LSB bits\n       rest = v - cell0;\n\n       y0 = LutTable[cell0];\n       y1 = LutTable[cell1];\n\n       return y0 + (y1 - y0) * rest;\n}",
          "fn_code_pos": [
            [
              130,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFloat32Number flerp",
            "parameters": {
              "LutTable": "cmsFloat32Number",
              "v": "cmsFloat32Number"
            },
            "return_type": "cmsINLINE"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "_cmsReasonableGridpointsByColorspace(cmsColorSpaceSignature Colorspace, cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              164,
              34
            ],
            [
              164,
              130
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReasonableGridpointsByColorspace",
            "parameters": {
              "Colorspace": "cmsColorSpaceSignature",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsComputeComponentIncrements(cmsUInt32Number Format,\n                                                            cmsUInt32Number BytesPerPlane,\n                                                            cmsUInt32Number* nChannels,\n                                                            cmsUInt32Number* nAlpha,\n                                                            cmsUInt32Number ComponentStartingOrder[],\n                                                            cmsUInt32Number ComponentPointerIncrements[])",
          "fn_dec_pos": [
            [
              169,
              29
            ],
            [
              174,
              105
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsComputeComponentIncrements",
            "parameters": {
              "Format": "cmsUInt32Number",
              "BytesPerPlane": "cmsUInt32Number",
              "nChannels": "cmsUInt32Number",
              "nAlpha": "cmsUInt32Number",
              "ComponentStartingOrder": "cmsUInt32Number",
              "ComponentPointerIncrements": "cmsUInt32Number"
            },
            "return_type": "CMSCHECKPOINT"
          }
        },
        {
          "fn_code": "Formatter_15Bit_Factory(cmsUInt32Number Type,\n                                                             cmsFormatterDirection Dir,\n                                                             cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              177,
              37
            ],
            [
              179,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Formatter_15Bit_Factory",
            "parameters": {
              "Type": "cmsUInt32Number",
              "Dir": "cmsFormatterDirection",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSCHECKPOINT"
          }
        },
        {
          "fn_code": "Optimize8MatrixShaper(_cmsTransform2Fn* TransformFn,\n                              void** UserData,\n                              _cmsFreeUserDataFn* FreeUserData,\n                              cmsPipeline** Lut,\n                              cmsUInt32Number* InputFormat,\n                              cmsUInt32Number* OutputFormat,\n                              cmsUInt32Number* dwFlags)",
          "fn_dec_pos": [
            [
              184,
              8
            ],
            [
              190,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Optimize8MatrixShaper",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeUserData": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "Optimize8MatrixShaperSSE(_cmsTransform2Fn* TransformFn,\n                              void** UserData,\n                              _cmsFreeUserDataFn* FreeUserData,\n                              cmsPipeline** Lut,\n                              cmsUInt32Number* InputFormat,\n                              cmsUInt32Number* OutputFormat,\n                              cmsUInt32Number* dwFlags)",
          "fn_dec_pos": [
            [
              193,
              8
            ],
            [
              199,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Optimize8MatrixShaperSSE",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeUserData": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "OptimizeMatrixShaper15(_cmsTransform2Fn* TransformFn,\n                               void** UserData,\n                               _cmsFreeUserDataFn* FreeUserData,\n                               cmsPipeline** Lut,\n                               cmsUInt32Number* InputFormat,\n                               cmsUInt32Number* OutputFormat,\n                               cmsUInt32Number* dwFlags)",
          "fn_dec_pos": [
            [
              201,
              8
            ],
            [
              207,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OptimizeMatrixShaper15",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeUserData": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "Optimize8ByJoiningCurves(_cmsTransform2Fn* TransformFn,\n                                 void** UserData,\n                                 _cmsFreeUserDataFn* FreeUserData,\n                                 cmsPipeline** Lut,\n                                 cmsUInt32Number* InputFormat,\n                                 cmsUInt32Number* OutputFormat,\n                                 cmsUInt32Number* dwFlags)",
          "fn_dec_pos": [
            [
              210,
              8
            ],
            [
              216,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Optimize8ByJoiningCurves",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeUserData": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "OptimizeFloatByJoiningCurves(_cmsTransform2Fn* TransformFn,                                  \n                                   void** UserData,\n                                   _cmsFreeUserDataFn* FreeUserData,\n                                   cmsPipeline** Lut, \n                                   cmsUInt32Number* InputFormat, \n                                   cmsUInt32Number* OutputFormat, \n                                   cmsUInt32Number* dwFlags)",
          "fn_dec_pos": [
            [
              218,
              8
            ],
            [
              224,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OptimizeFloatByJoiningCurves",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeUserData": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "OptimizeFloatMatrixShaper(_cmsTransform2Fn* TransformFn,                                  \n                                   void** UserData,\n                                   _cmsFreeUserDataFn* FreeUserData,\n                                   cmsPipeline** Lut, \n                                   cmsUInt32Number* InputFormat, \n                                   cmsUInt32Number* OutputFormat, \n                                   cmsUInt32Number* dwFlags)",
          "fn_dec_pos": [
            [
              226,
              8
            ],
            [
              232,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OptimizeFloatMatrixShaper",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeUserData": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "Optimize8BitRGBTransform(_cmsTransform2Fn* TransformFn,\n                                   void** UserData,\n                                   _cmsFreeUserDataFn* FreeDataFn,\n                                   cmsPipeline** Lut,\n                                   cmsUInt32Number* InputFormat,\n                                   cmsUInt32Number* OutputFormat,\n                                   cmsUInt32Number* dwFlags)",
          "fn_dec_pos": [
            [
              234,
              8
            ],
            [
              240,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Optimize8BitRGBTransform",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeDataFn": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "Optimize16BitRGBTransform(_cmsTransform2Fn* TransformFn,\n                                   void** UserData,\n                                   _cmsFreeUserDataFn* FreeDataFn,\n                                   cmsPipeline** Lut,\n                                   cmsUInt32Number* InputFormat,\n                                   cmsUInt32Number* OutputFormat,\n                                   cmsUInt32Number* dwFlags)",
          "fn_dec_pos": [
            [
              242,
              8
            ],
            [
              248,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Optimize16BitRGBTransform",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeDataFn": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "OptimizeCLUTRGBTransform(_cmsTransform2Fn* TransformFn,\n                                  void** UserData,\n                                  _cmsFreeUserDataFn* FreeDataFn,\n                                  cmsPipeline** Lut, \n                                  cmsUInt32Number* InputFormat, \n                                  cmsUInt32Number* OutputFormat, \n                                  cmsUInt32Number* dwFlags)",
          "fn_dec_pos": [
            [
              250,
              8
            ],
            [
              256,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OptimizeCLUTRGBTransform",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeDataFn": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "OptimizeCLUTCMYKTransform(_cmsTransform2Fn* TransformFn,\n\t\t\t\t\t              void** UserData,\n\t\t\t\t\t              _cmsFreeUserDataFn* FreeDataFn,\n\t\t\t\t\t              cmsPipeline** Lut,\n\t\t\t\t\t              cmsUInt32Number* InputFormat,\n\t\t\t\t\t              cmsUInt32Number* OutputFormat,\n\t\t\t\t\t              cmsUInt32Number* dwFlags)",
          "fn_dec_pos": [
            [
              258,
              8
            ],
            [
              264,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OptimizeCLUTCMYKTransform",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeDataFn": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "OptimizeCLUTLabTransform(_cmsTransform2Fn* TransformFn,\n                                 void** UserData,\n                                 _cmsFreeUserDataFn* FreeDataFn,\n                                 cmsPipeline** Lut, \n                                 cmsUInt32Number* InputFormat, \n                                 cmsUInt32Number* OutputFormat, \n                                 cmsUInt32Number* dwFlags)",
          "fn_dec_pos": [
            [
              267,
              8
            ],
            [
              273,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OptimizeCLUTLabTransform",
            "parameters": {
              "TransformFn": "_cmsTransform2Fn",
              "UserData": "void",
              "FreeDataFn": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\n       cmsUInt32Number InputFormat, OutputFormat; // Keep formats for further reference\n\n} _xform_head;",
          {
            "InputFormat": "cmsUInt32Number"
          },
          "_xform_head",
          [
            80,
            0
          ],
          [
            84,
            14
          ]
        ],
        [
          "typedef struct {\n\n       cmsUInt32Number InputFormat, OutputFormat; // Keep formats for further reference\n\n} _xform_head;",
          {
            "InputFormat": "cmsUInt32Number"
          },
          "_xform_head",
          [
            80,
            0
          ],
          [
            84,
            14
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2_fast_float.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdint.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <float.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/include/lcms2_plugin.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "_cmsVEC3init(cmsVEC3* r, cmsFloat64Number x, cmsFloat64Number y, cmsFloat64Number z)",
          "fn_dec_pos": [
            [
              81,
              36
            ],
            [
              81,
              120
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsVEC3init",
            "parameters": {
              "r": "cmsVEC3",
              "x": "cmsFloat64Number",
              "y": "cmsFloat64Number",
              "z": "cmsFloat64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsVEC3minus(cmsVEC3* r, const cmsVEC3* a, const cmsVEC3* b)",
          "fn_dec_pos": [
            [
              82,
              36
            ],
            [
              82,
              97
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsVEC3minus",
            "parameters": {
              "r": "cmsVEC3",
              "a": "cmsVEC3",
              "b": "cmsVEC3"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsVEC3cross(cmsVEC3* r, const cmsVEC3* u, const cmsVEC3* v)",
          "fn_dec_pos": [
            [
              83,
              36
            ],
            [
              83,
              97
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsVEC3cross",
            "parameters": {
              "r": "cmsVEC3",
              "u": "cmsVEC3",
              "v": "cmsVEC3"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsVEC3dot(const cmsVEC3* u, const cmsVEC3* v)",
          "fn_dec_pos": [
            [
              84,
              36
            ],
            [
              84,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsVEC3dot",
            "parameters": {
              "u": "cmsVEC3",
              "v": "cmsVEC3"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsVEC3length(const cmsVEC3* a)",
          "fn_dec_pos": [
            [
              85,
              36
            ],
            [
              85,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsVEC3length",
            "parameters": {
              "a": "cmsVEC3"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsVEC3distance(const cmsVEC3* a, const cmsVEC3* b)",
          "fn_dec_pos": [
            [
              86,
              36
            ],
            [
              86,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsVEC3distance",
            "parameters": {
              "a": "cmsVEC3",
              "b": "cmsVEC3"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsMAT3identity(cmsMAT3* a)",
          "fn_dec_pos": [
            [
              88,
              36
            ],
            [
              88,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMAT3identity",
            "parameters": {
              "a": "cmsMAT3"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsMAT3isIdentity(const cmsMAT3* a)",
          "fn_dec_pos": [
            [
              89,
              36
            ],
            [
              89,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMAT3isIdentity",
            "parameters": {
              "a": "cmsMAT3"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsMAT3per(cmsMAT3* r, const cmsMAT3* a, const cmsMAT3* b)",
          "fn_dec_pos": [
            [
              90,
              36
            ],
            [
              90,
              95
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMAT3per",
            "parameters": {
              "r": "cmsMAT3",
              "a": "cmsMAT3",
              "b": "cmsMAT3"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsMAT3inverse(const cmsMAT3* a, cmsMAT3* b)",
          "fn_dec_pos": [
            [
              91,
              36
            ],
            [
              91,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMAT3inverse",
            "parameters": {
              "a": "cmsMAT3",
              "b": "cmsMAT3"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsMAT3solve(cmsVEC3* x, cmsMAT3* a, cmsVEC3* b)",
          "fn_dec_pos": [
            [
              92,
              36
            ],
            [
              92,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMAT3solve",
            "parameters": {
              "x": "cmsVEC3",
              "a": "cmsMAT3",
              "b": "cmsVEC3"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsMAT3eval(cmsVEC3* r, const cmsMAT3* a, const cmsVEC3* v)",
          "fn_dec_pos": [
            [
              93,
              36
            ],
            [
              93,
              96
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMAT3eval",
            "parameters": {
              "r": "cmsVEC3",
              "a": "cmsMAT3",
              "v": "cmsVEC3"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsMD5alloc(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              98,
              36
            ],
            [
              98,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMD5alloc",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsMD5add(cmsHANDLE Handle, const cmsUInt8Number* buf, cmsUInt32Number len)",
          "fn_dec_pos": [
            [
              99,
              36
            ],
            [
              99,
              111
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMD5add",
            "parameters": {
              "Handle": "cmsHANDLE",
              "buf": "cmsUInt8Number",
              "len": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsMD5finish(cmsProfileID* ProfileID, cmsHANDLE Handle)",
          "fn_dec_pos": [
            [
              100,
              36
            ],
            [
              100,
              91
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMD5finish",
            "parameters": {
              "ProfileID": "cmsProfileID",
              "Handle": "cmsHANDLE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSignalError(cmsContext ContextID, cmsUInt32Number ErrorCode, const char *ErrorText, ...)",
          "fn_dec_pos": [
            [
              104,
              37
            ],
            [
              104,
              128
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSignalError",
            "parameters": {
              "ContextID": "cmsContext",
              "ErrorCode": "cmsUInt32Number",
              "ErrorText": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsMalloc(cmsContext ContextID, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              108,
              36
            ],
            [
              108,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMalloc",
            "parameters": {
              "ContextID": "cmsContext",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsMallocZero(cmsContext ContextID, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              109,
              36
            ],
            [
              109,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsMallocZero",
            "parameters": {
              "ContextID": "cmsContext",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsCalloc(cmsContext ContextID, cmsUInt32Number num, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              110,
              36
            ],
            [
              110,
              111
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsCalloc",
            "parameters": {
              "ContextID": "cmsContext",
              "num": "cmsUInt32Number",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsRealloc(cmsContext ContextID, void* Ptr, cmsUInt32Number NewSize)",
          "fn_dec_pos": [
            [
              111,
              36
            ],
            [
              111,
              105
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRealloc",
            "parameters": {
              "ContextID": "cmsContext",
              "Ptr": "void",
              "NewSize": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsFree(cmsContext ContextID, void* Ptr)",
          "fn_dec_pos": [
            [
              112,
              36
            ],
            [
              112,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsFree",
            "parameters": {
              "ContextID": "cmsContext",
              "Ptr": "void"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsDupMem(cmsContext ContextID, const void* Org, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              113,
              36
            ],
            [
              113,
              107
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsDupMem",
            "parameters": {
              "ContextID": "cmsContext",
              "Org": "void",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(* Read)(struct _cms_io_handler* iohandler, void *Buffer,\n                                                                  cmsUInt32Number size,\n                                                                  cmsUInt32Number count)",
          "fn_dec_pos": [
            [
              126,
              22
            ],
            [
              128,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "iohandler": "struct _cms_io_handler",
              "Buffer": "void",
              "size": "cmsUInt32Number",
              "count": "cmsUInt32Number"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "(* Seek)(struct _cms_io_handler* iohandler, cmsUInt32Number offset)",
          "fn_dec_pos": [
            [
              129,
              22
            ],
            [
              129,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "iohandler": "struct _cms_io_handler",
              "offset": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "(* Close)(struct _cms_io_handler* iohandler)",
          "fn_dec_pos": [
            [
              130,
              22
            ],
            [
              130,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "iohandler": "struct _cms_io_handler"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "(* Tell)(struct _cms_io_handler* iohandler)",
          "fn_dec_pos": [
            [
              131,
              22
            ],
            [
              131,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "iohandler": "struct _cms_io_handler"
            },
            "return_type": "cmsUInt32Number"
          }
        },
        {
          "fn_code": "(* Write)(struct _cms_io_handler* iohandler, cmsUInt32Number size,\n                                                                   const void* Buffer)",
          "fn_dec_pos": [
            [
              132,
              22
            ],
            [
              133,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "iohandler": "struct _cms_io_handler",
              "size": "cmsUInt32Number",
              "Buffer": "void"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsAdjustEndianess16(cmsUInt16Number Word)",
          "fn_dec_pos": [
            [
              137,
              36
            ],
            [
              137,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAdjustEndianess16",
            "parameters": {
              "Word": "cmsUInt16Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsAdjustEndianess32(cmsUInt32Number Value)",
          "fn_dec_pos": [
            [
              138,
              36
            ],
            [
              138,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAdjustEndianess32",
            "parameters": {
              "Value": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsAdjustEndianess64(cmsUInt64Number* Result, cmsUInt64Number* QWord)",
          "fn_dec_pos": [
            [
              139,
              36
            ],
            [
              139,
              106
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAdjustEndianess64",
            "parameters": {
              "Result": "cmsUInt64Number",
              "QWord": "cmsUInt64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsReadUInt8Number(cmsIOHANDLER* io,  cmsUInt8Number* n)",
          "fn_dec_pos": [
            [
              142,
              36
            ],
            [
              142,
              93
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadUInt8Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt8Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsReadUInt16Number(cmsIOHANDLER* io, cmsUInt16Number* n)",
          "fn_dec_pos": [
            [
              143,
              36
            ],
            [
              143,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadUInt16Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt16Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsReadUInt32Number(cmsIOHANDLER* io, cmsUInt32Number* n)",
          "fn_dec_pos": [
            [
              144,
              36
            ],
            [
              144,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadUInt32Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsReadFloat32Number(cmsIOHANDLER* io, cmsFloat32Number* n)",
          "fn_dec_pos": [
            [
              145,
              36
            ],
            [
              145,
              96
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadFloat32Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsFloat32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsReadUInt64Number(cmsIOHANDLER* io, cmsUInt64Number* n)",
          "fn_dec_pos": [
            [
              146,
              36
            ],
            [
              146,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadUInt64Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsRead15Fixed16Number(cmsIOHANDLER* io, cmsFloat64Number* n)",
          "fn_dec_pos": [
            [
              147,
              36
            ],
            [
              147,
              98
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRead15Fixed16Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsFloat64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsReadXYZNumber(cmsIOHANDLER* io, cmsCIEXYZ* XYZ)",
          "fn_dec_pos": [
            [
              148,
              36
            ],
            [
              148,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadXYZNumber",
            "parameters": {
              "io": "cmsIOHANDLER",
              "XYZ": "cmsCIEXYZ"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsReadUInt16Array(cmsIOHANDLER* io, cmsUInt32Number n, cmsUInt16Number* Array)",
          "fn_dec_pos": [
            [
              149,
              36
            ],
            [
              149,
              116
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadUInt16Array",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt32Number",
              "Array": "cmsUInt16Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsWriteUInt8Number(cmsIOHANDLER* io, cmsUInt8Number n)",
          "fn_dec_pos": [
            [
              151,
              36
            ],
            [
              151,
              92
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteUInt8Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt8Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsWriteUInt16Number(cmsIOHANDLER* io, cmsUInt16Number n)",
          "fn_dec_pos": [
            [
              152,
              36
            ],
            [
              152,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteUInt16Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt16Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsWriteUInt32Number(cmsIOHANDLER* io, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              153,
              36
            ],
            [
              153,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteUInt32Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsWriteFloat32Number(cmsIOHANDLER* io, cmsFloat32Number n)",
          "fn_dec_pos": [
            [
              154,
              36
            ],
            [
              154,
              96
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteFloat32Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsFloat32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsWriteUInt64Number(cmsIOHANDLER* io, cmsUInt64Number* n)",
          "fn_dec_pos": [
            [
              155,
              36
            ],
            [
              155,
              95
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteUInt64Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsWrite15Fixed16Number(cmsIOHANDLER* io, cmsFloat64Number n)",
          "fn_dec_pos": [
            [
              156,
              36
            ],
            [
              156,
              98
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWrite15Fixed16Number",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsFloat64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsWriteXYZNumber(cmsIOHANDLER* io, const cmsCIEXYZ* XYZ)",
          "fn_dec_pos": [
            [
              157,
              36
            ],
            [
              157,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteXYZNumber",
            "parameters": {
              "io": "cmsIOHANDLER",
              "XYZ": "cmsCIEXYZ"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsWriteUInt16Array(cmsIOHANDLER* io, cmsUInt32Number n, const cmsUInt16Number* Array)",
          "fn_dec_pos": [
            [
              158,
              36
            ],
            [
              158,
              123
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteUInt16Array",
            "parameters": {
              "io": "cmsIOHANDLER",
              "n": "cmsUInt32Number",
              "Array": "cmsUInt16Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsReadTypeBase(cmsIOHANDLER* io)",
          "fn_dec_pos": [
            [
              168,
              38
            ],
            [
              168,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadTypeBase",
            "parameters": {
              "io": "cmsIOHANDLER"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsWriteTypeBase(cmsIOHANDLER* io, cmsTagTypeSignature sig)",
          "fn_dec_pos": [
            [
              169,
              38
            ],
            [
              169,
              98
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteTypeBase",
            "parameters": {
              "io": "cmsIOHANDLER",
              "sig": "cmsTagTypeSignature"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsReadAlignment(cmsIOHANDLER* io)",
          "fn_dec_pos": [
            [
              172,
              37
            ],
            [
              172,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadAlignment",
            "parameters": {
              "io": "cmsIOHANDLER"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsWriteAlignment(cmsIOHANDLER* io)",
          "fn_dec_pos": [
            [
              173,
              37
            ],
            [
              173,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteAlignment",
            "parameters": {
              "io": "cmsIOHANDLER"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsIOPrintf(cmsIOHANDLER* io, const char* frm, ...)",
          "fn_dec_pos": [
            [
              176,
              37
            ],
            [
              176,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsIOPrintf",
            "parameters": {
              "io": "cmsIOHANDLER",
              "frm": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cms8Fixed8toDouble(cmsUInt16Number fixed8)",
          "fn_dec_pos": [
            [
              179,
              37
            ],
            [
              179,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cms8Fixed8toDouble",
            "parameters": {
              "fixed8": "cmsUInt16Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsDoubleTo8Fixed8(cmsFloat64Number val)",
          "fn_dec_pos": [
            [
              180,
              37
            ],
            [
              180,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsDoubleTo8Fixed8",
            "parameters": {
              "val": "cmsFloat64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cms15Fixed16toDouble(cmsS15Fixed16Number fix32)",
          "fn_dec_pos": [
            [
              182,
              37
            ],
            [
              182,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cms15Fixed16toDouble",
            "parameters": {
              "fix32": "cmsS15Fixed16Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsDoubleTo15Fixed16(cmsFloat64Number v)",
          "fn_dec_pos": [
            [
              183,
              37
            ],
            [
              183,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsDoubleTo15Fixed16",
            "parameters": {
              "v": "cmsFloat64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsEncodeDateTimeNumber(cmsDateTimeNumber *Dest, const struct tm *Source)",
          "fn_dec_pos": [
            [
              186,
              37
            ],
            [
              186,
              111
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsEncodeDateTimeNumber",
            "parameters": {
              "Dest": "cmsDateTimeNumber",
              "Source": "struct tm"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsDecodeDateTimeNumber(const cmsDateTimeNumber *Source, struct tm *Dest)",
          "fn_dec_pos": [
            [
              187,
              37
            ],
            [
              187,
              111
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsDecodeDateTimeNumber",
            "parameters": {
              "Source": "cmsDateTimeNumber",
              "Dest": "struct tm"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "(* _cmsFreeUserDataFn)(cmsContext ContextID, void* Data)",
          "fn_dec_pos": [
            [
              192,
              17
            ],
            [
              192,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "Data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(* _cmsDupUserDataFn)(cmsContext ContextID, const void* Data)",
          "fn_dec_pos": [
            [
              193,
              17
            ],
            [
              193,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "Data": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(* _cmsMallocFnPtrType)(cmsContext ContextID, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              229,
              14
            ],
            [
              229,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(* _cmsFreeFnPtrType)(cmsContext ContextID, void *Ptr)",
          "fn_dec_pos": [
            [
              230,
              14
            ],
            [
              230,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(* _cmsReallocFnPtrType)(cmsContext ContextID, void* Ptr, cmsUInt32Number NewSize)",
          "fn_dec_pos": [
            [
              231,
              14
            ],
            [
              231,
              96
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "Ptr": "void",
              "NewSize": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(* _cmsMalloZerocFnPtrType)(cmsContext ContextID, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              233,
              14
            ],
            [
              233,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(* _cmsCallocFnPtrType)(cmsContext ContextID, cmsUInt32Number num, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              234,
              14
            ],
            [
              234,
              102
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "num": "cmsUInt32Number",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(* _cmsDupFnPtrType)(cmsContext ContextID, const void* Org, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              235,
              14
            ],
            [
              235,
              95
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "Org": "void",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(* _cmsInterpFn16)(CMSREGISTER const cmsUInt16Number Input[],\n                                CMSREGISTER cmsUInt16Number Output[],\n                                CMSREGISTER const struct _cms_interp_struc* p)",
          "fn_dec_pos": [
            [
              264,
              13
            ],
            [
              266,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "Input": "CMSREGISTER",
              "Output": "CMSREGISTER",
              "struct": "CMSREGISTER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(* _cmsInterpFnFloat)(cmsFloat32Number const Input[],\n                                   cmsFloat32Number Output[],\n                                   const struct _cms_interp_struc* p)",
          "fn_dec_pos": [
            [
              271,
              13
            ],
            [
              273,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "Input": "cmsFloat32Number",
              "Output": "cmsFloat32Number",
              "p": "struct _cms_interp_struc"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(* cmsInterpFnFactory)(cmsUInt32Number nInputChannels, cmsUInt32Number nOutputChannels, cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              312,
              26
            ],
            [
              312,
              138
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "nInputChannels": "cmsUInt32Number",
              "nOutputChannels": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsInterpFunction"
          }
        },
        {
          "fn_code": "(* cmsParametricCurveEvaluator)(cmsInt32Number Type, const cmsFloat64Number Params[10], cmsFloat64Number R)",
          "fn_dec_pos": [
            [
              328,
              26
            ],
            [
              328,
              133
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "Type": "cmsInt32Number",
              "Params": "cmsFloat64Number",
              "R": "cmsFloat64Number"
            },
            "return_type": "cmsFloat64Number"
          }
        },
        {
          "fn_code": "(* cmsFormatter16)(CMSREGISTER struct _cmstransform_struct* CMMcargo,\n                                           CMSREGISTER cmsUInt16Number Values[],\n                                           CMSREGISTER cmsUInt8Number* Buffer,\n                                           CMSREGISTER cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              349,
              24
            ],
            [
              352,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "struct": "CMSREGISTER",
              "Values": "CMSREGISTER",
              "cmsUInt32Number": "CMSREGISTER"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(* cmsFormatterFloat)(struct _cmstransform_struct* CMMcargo,\n                                              cmsFloat32Number Values[],\n                                              cmsUInt8Number*  Buffer,\n                                              cmsUInt32Number  Stride)",
          "fn_dec_pos": [
            [
              354,
              24
            ],
            [
              357,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "Values": "cmsFloat32Number",
              "Buffer": "cmsUInt8Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(* cmsFormatterFactory)(cmsUInt32Number Type,           // Specific type, i.e. TYPE_RGB_8\n                                             cmsFormatterDirection Dir,\n                                             cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              371,
              21
            ],
            [
              373,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "Type": "cmsUInt32Number",
              "Dir": "cmsFormatterDirection",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsFormatter"
          }
        },
        {
          "fn_code": "(* ReadPtr)(struct _cms_typehandler_struct* self,\n                             cmsIOHANDLER*      io,\n                             cmsUInt32Number*   nItems,\n                             cmsUInt32Number    SizeOfTag)",
          "fn_dec_pos": [
            [
              391,
              17
            ],
            [
              394,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "nItems": "cmsUInt32Number",
              "SizeOfTag": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(* WritePtr)(struct _cms_typehandler_struct* self,\n                              cmsIOHANDLER*     io,\n                              void*             Ptr,\n                              cmsUInt32Number   nItems)",
          "fn_dec_pos": [
            [
              397,
              17
            ],
            [
              400,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "io": "cmsIOHANDLER",
              "Ptr": "void",
              "nItems": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "(* DupPtr)(struct _cms_typehandler_struct* self,\n                           const void *Ptr,\n                           cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              403,
              16
            ],
            [
              405,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(* FreePtr)(struct _cms_typehandler_struct* self,\n                            void *Ptr)",
          "fn_dec_pos": [
            [
              408,
              16
            ],
            [
              409,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "self": "struct _cms_typehandler_struct",
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(* DecideType)(cmsFloat64Number ICCVersion, const void *Data)",
          "fn_dec_pos": [
            [
              438,
              24
            ],
            [
              438,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ICCVersion": "cmsFloat64Number",
              "Data": "void"
            },
            "return_type": "cmsTagTypeSignature"
          }
        },
        {
          "fn_code": "(* cmsIntentFn)( cmsContext       ContextID,\n                                      cmsUInt32Number  nProfiles,\n                                      cmsUInt32Number  Intents[],\n                                      cmsHPROFILE      hProfiles[],\n                                      cmsBool          BPC[],\n                                      cmsFloat64Number AdaptationStates[],\n                                      cmsUInt32Number  dwFlags)",
          "fn_dec_pos": [
            [
              458,
              21
            ],
            [
              464,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "Intents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsDefaultICCintents(cmsContext       ContextID,\n                                                     cmsUInt32Number  nProfiles,\n                                                     cmsUInt32Number  Intents[],\n                                                     cmsHPROFILE      hProfiles[],\n                                                     cmsBool          BPC[],\n                                                     cmsFloat64Number AdaptationStates[],\n                                                     cmsUInt32Number  dwFlags)",
          "fn_dec_pos": [
            [
              478,
              31
            ],
            [
              484,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "Intents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(* _cmsStageEvalFn)     (const cmsFloat32Number In[], cmsFloat32Number Out[], const cmsStage* mpe)",
          "fn_dec_pos": [
            [
              491,
              13
            ],
            [
              491,
              111
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "In": "cmsFloat32Number",
              "Out": "cmsFloat32Number",
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(* _cmsStageDupElemFn)  (cmsStage* mpe)",
          "fn_dec_pos": [
            [
              492,
              13
            ],
            [
              492,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(* _cmsStageFreeElemFn) (cmsStage* mpe)",
          "fn_dec_pos": [
            [
              493,
              13
            ],
            [
              493,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsStageAllocPlaceholder(cmsContext ContextID,\n                                cmsStageSignature     Type,\n                                cmsUInt32Number       InputChannels,\n                                cmsUInt32Number       OutputChannels,\n                                _cmsStageEvalFn       EvalPtr,            // Points to fn that evaluates the element (always in floating point)\n                                _cmsStageDupElemFn    DupElemPtr,         // Points to a fn that duplicates the stage\n                                _cmsStageFreeElemFn   FreePtr,            // Points to a fn that sets the element free\n                                void*                 Data)",
          "fn_dec_pos": [
            [
              497,
              27
            ],
            [
              504,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageAllocPlaceholder",
            "parameters": {
              "ContextID": "cmsContext",
              "Type": "cmsStageSignature",
              "InputChannels": "cmsUInt32Number",
              "OutputChannels": "cmsUInt32Number",
              "EvalPtr": "_cmsStageEvalFn",
              "DupElemPtr": "_cmsStageDupElemFn",
              "FreePtr": "_cmsStageFreeElemFn",
              "Data": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(* _cmsOPToptimizeFn)(cmsPipeline** Lut,\n                                       cmsUInt32Number  Intent,\n                                       cmsUInt32Number* InputFormat,\n                                       cmsUInt32Number* OutputFormat,\n                                       cmsUInt32Number* dwFlags)",
          "fn_dec_pos": [
            [
              550,
              17
            ],
            [
              554,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "Lut": "cmsPipeline",
              "Intent": "cmsUInt32Number",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "(* _cmsPipelineEval16Fn)(CMSREGISTER const cmsUInt16Number In[],\n                                     CMSREGISTER cmsUInt16Number Out[],\n                                     const void* Data)",
          "fn_dec_pos": [
            [
              557,
              13
            ],
            [
              559,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "Data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(* _cmsPipelineEvalFloatFn)(const cmsFloat32Number In[],\n                                         cmsFloat32Number Out[],\n                                         const void* Data)",
          "fn_dec_pos": [
            [
              562,
              13
            ],
            [
              564,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "In": "cmsFloat32Number",
              "Out": "cmsFloat32Number",
              "Data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsPipelineSetOptimizationParameters(cmsPipeline* Lut,\n                                               _cmsPipelineEval16Fn Eval16,\n                                               void* PrivateData,\n                                               _cmsFreeUserDataFn FreePrivateDataFn,\n                                               _cmsDupUserDataFn DupPrivateDataFn)",
          "fn_dec_pos": [
            [
              570,
              22
            ],
            [
              574,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsPipelineSetOptimizationParameters",
            "parameters": {
              "Lut": "cmsPipeline",
              "Eval16": "_cmsPipelineEval16Fn",
              "PrivateData": "void",
              "FreePrivateDataFn": "_cmsFreeUserDataFn",
              "DupPrivateDataFn": "_cmsDupUserDataFn"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "(* _cmsTransformFn)(struct _cmstransform_struct *CMMcargo,   // Legacy function, handles just ONE scanline.\n                                     const void* InputBuffer,\n                                     void* OutputBuffer,\n                                     cmsUInt32Number Size,\n                                     cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              595,
              17
            ],
            [
              599,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "InputBuffer": "void",
              "OutputBuffer": "void",
              "Size": "cmsUInt32Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*_cmsTransform2Fn)(struct _cmstransform_struct *CMMcargo,\n                                     const void* InputBuffer,\n                                     void* OutputBuffer,\n                                     cmsUInt32Number PixelsPerLine,\n                                     cmsUInt32Number LineCount,      \n                                     const cmsStride* Stride)",
          "fn_dec_pos": [
            [
              602,
              17
            ],
            [
              607,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "InputBuffer": "void",
              "OutputBuffer": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(* _cmsTransformFactory)(_cmsTransformFn* xform,\n                                         void** UserData,\n                                         _cmsFreeUserDataFn* FreePrivateDataFn,\n                                         cmsPipeline** Lut,\n                                         cmsUInt32Number* InputFormat,\n                                         cmsUInt32Number* OutputFormat,\n                                         cmsUInt32Number* dwFlags)",
          "fn_dec_pos": [
            [
              609,
              17
            ],
            [
              615,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "xform": "_cmsTransformFn",
              "UserData": "void",
              "FreePrivateDataFn": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "(* _cmsTransform2Factory)(_cmsTransform2Fn* xform,\n                                         void** UserData,\n                                         _cmsFreeUserDataFn* FreePrivateDataFn,\n                                         cmsPipeline** Lut,\n                                         cmsUInt32Number* InputFormat,\n                                         cmsUInt32Number* OutputFormat,\n                                         cmsUInt32Number* dwFlags)",
          "fn_dec_pos": [
            [
              617,
              17
            ],
            [
              623,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "xform": "_cmsTransform2Fn",
              "UserData": "void",
              "FreePrivateDataFn": "_cmsFreeUserDataFn",
              "Lut": "cmsPipeline",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsSetTransformUserData(struct _cmstransform_struct *CMMcargo, void* ptr, _cmsFreeUserDataFn FreePrivateDataFn)",
          "fn_dec_pos": [
            [
              627,
              24
            ],
            [
              627,
              136
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsSetTransformUserData",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "ptr": "void",
              "FreePrivateDataFn": "_cmsFreeUserDataFn"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsGetTransformUserData(struct _cmstransform_struct *CMMcargo)",
          "fn_dec_pos": [
            [
              628,
              24
            ],
            [
              628,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTransformUserData",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsGetTransformFormatters16   (struct _cmstransform_struct *CMMcargo, cmsFormatter16* FromInput, cmsFormatter16* ToOutput)",
          "fn_dec_pos": [
            [
              632,
              24
            ],
            [
              632,
              147
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTransformFormatters16",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "FromInput": "cmsFormatter16",
              "ToOutput": "cmsFormatter16"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsGetTransformFormattersFloat(struct _cmstransform_struct *CMMcargo, cmsFormatterFloat* FromInput, cmsFormatterFloat* ToOutput)",
          "fn_dec_pos": [
            [
              633,
              24
            ],
            [
              633,
              153
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTransformFormattersFloat",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct",
              "FromInput": "cmsFormatterFloat",
              "ToOutput": "cmsFormatterFloat"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsGetTransformFlags(struct _cmstransform_struct* CMMcargo)",
          "fn_dec_pos": [
            [
              636,
              33
            ],
            [
              636,
              93
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTransformFlags",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "(* _cmsCreateMutexFnPtrType)(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              652,
              17
            ],
            [
              652,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(* _cmsDestroyMutexFnPtrType)(cmsContext ContextID, void* mtx)",
          "fn_dec_pos": [
            [
              653,
              17
            ],
            [
              653,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "mtx": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(* _cmsLockMutexFnPtrType)(cmsContext ContextID, void* mtx)",
          "fn_dec_pos": [
            [
              654,
              17
            ],
            [
              654,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "mtx": "void"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "(* _cmsUnlockMutexFnPtrType)(cmsContext ContextID, void* mtx)",
          "fn_dec_pos": [
            [
              655,
              17
            ],
            [
              655,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "mtx": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsCreateMutex(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              667,
              25
            ],
            [
              667,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsCreateMutex",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsDestroyMutex(cmsContext ContextID, void* mtx)",
          "fn_dec_pos": [
            [
              668,
              25
            ],
            [
              668,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsDestroyMutex",
            "parameters": {
              "ContextID": "cmsContext",
              "mtx": "void"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsLockMutex(cmsContext ContextID, void* mtx)",
          "fn_dec_pos": [
            [
              669,
              25
            ],
            [
              669,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsLockMutex",
            "parameters": {
              "ContextID": "cmsContext",
              "mtx": "void"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsUnlockMutex(cmsContext ContextID, void* mtx)",
          "fn_dec_pos": [
            [
              670,
              25
            ],
            [
              670,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsUnlockMutex",
            "parameters": {
              "ContextID": "cmsContext",
              "mtx": "void"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsGetTransformWorker(struct _cmstransform_struct* CMMcargo)",
          "fn_dec_pos": [
            [
              675,
              34
            ],
            [
              675,
              95
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTransformWorker",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsGetTransformMaxWorkers(struct _cmstransform_struct* CMMcargo)",
          "fn_dec_pos": [
            [
              676,
              34
            ],
            [
              676,
              99
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTransformMaxWorkers",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsGetTransformWorkerFlags(struct _cmstransform_struct* CMMcargo)",
          "fn_dec_pos": [
            [
              677,
              34
            ],
            [
              677,
              100
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTransformWorkerFlags",
            "parameters": {
              "CMMcargo": "struct _cmstransform_struct"
            },
            "return_type": "CMSAPI"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n    cmsFloat64Number n[3];\n\n    } cmsVEC3;",
          {
            "n[3]": "cmsFloat64Number"
          },
          "cmsVEC3",
          [
            70,
            0
          ],
          [
            73,
            14
          ]
        ],
        [
          "typedef struct {\n    cmsVEC3 v[3];\n\n    } cmsMAT3;",
          {
            "v[3]": "cmsVEC3"
          },
          "cmsMAT3",
          [
            76,
            0
          ],
          [
            79,
            14
          ]
        ],
        [
          "struct _cms_io_handler {\n\n    void* stream;   // Associated stream, which is implemented differently depending on media.\n\n    cmsContext        ContextID;\n    cmsUInt32Number   UsedSpace;\n    cmsUInt32Number   ReportedSize;\n    char              PhysicalFile[cmsMAX_PATH];\n\n    cmsUInt32Number   (* Read)(struct _cms_io_handler* iohandler, void *Buffer,\n                                                                  cmsUInt32Number size,\n                                                                  cmsUInt32Number count);\n    cmsBool           (* Seek)(struct _cms_io_handler* iohandler, cmsUInt32Number offset);\n    cmsBool           (* Close)(struct _cms_io_handler* iohandler);\n    cmsUInt32Number   (* Tell)(struct _cms_io_handler* iohandler);\n    cmsBool           (* Write)(struct _cms_io_handler* iohandler, cmsUInt32Number size,\n                                                                   const void* Buffer);\n}",
          {
            "* stream": "void",
            "ContextID": "cmsContext",
            "UsedSpace": "cmsUInt32Number",
            "ReportedSize": "cmsUInt32Number",
            "PhysicalFile[cmsMAX_PATH]": "char",
            "(* Read)(struct _cms_io_handler* iohandler, void *Buffer,\n                                                                  cmsUInt32Number size,\n                                                                  cmsUInt32Number count)": "cmsUInt32Number",
            "(* Seek)(struct _cms_io_handler* iohandler, cmsUInt32Number offset)": "cmsBool",
            "(* Close)(struct _cms_io_handler* iohandler)": "cmsBool",
            "(* Tell)(struct _cms_io_handler* iohandler)": "cmsUInt32Number",
            "(* Write)(struct _cms_io_handler* iohandler, cmsUInt32Number size,\n                                                                   const void* Buffer)": "cmsBool"
          },
          "_cms_io_handler",
          [
            117,
            0
          ],
          [
            134,
            1
          ]
        ],
        [
          "typedef struct {\n    cmsTagTypeSignature  sig;\n    cmsInt8Number        reserved[4];\n\n} _cmsTagBase;",
          {
            "sig": "cmsTagTypeSignature",
            "reserved[4]": "cmsInt8Number"
          },
          "_cmsTagBase",
          [
            161,
            0
          ],
          [
            165,
            14
          ]
        ],
        [
          "typedef struct _cmsPluginBaseStruct {\n\n        cmsUInt32Number                Magic;               // 'acpp' signature\n        cmsUInt32Number                ExpectedVersion;     // Expected version of LittleCMS\n        cmsUInt32Number                Type;                // Type of plug-in\n        struct _cmsPluginBaseStruct*   Next;                // For multiple plugin definition. NULL for end of list.\n\n} cmsPluginBase;",
          {
            "Magic": "cmsUInt32Number",
            "ExpectedVersion": "cmsUInt32Number",
            "Type": "cmsUInt32Number",
            "*   Next": "struct _cmsPluginBaseStruct"
          },
          "cmsPluginBase",
          [
            213,
            0
          ],
          [
            220,
            16
          ]
        ],
        [
          "typedef struct {\n\n        cmsPluginBase base;\n\n        // Required\n        _cmsMallocFnPtrType  MallocPtr;\n        _cmsFreeFnPtrType    FreePtr;\n        _cmsReallocFnPtrType ReallocPtr;\n\n        // Optional\n       _cmsMalloZerocFnPtrType MallocZeroPtr;\n       _cmsCallocFnPtrType     CallocPtr;\n       _cmsDupFnPtrType        DupPtr;\n\n} cmsPluginMemHandler;",
          {
            "base": "cmsPluginBase",
            "MallocPtr": "_cmsMallocFnPtrType",
            "FreePtr": "_cmsFreeFnPtrType",
            "ReallocPtr": "_cmsReallocFnPtrType",
            "MallocZeroPtr": "_cmsMalloZerocFnPtrType",
            "CallocPtr": "_cmsCallocFnPtrType",
            "DupPtr": "_cmsDupFnPtrType"
          },
          "cmsPluginMemHandler",
          [
            237,
            0
          ],
          [
            251,
            22
          ]
        ],
        [
          "typedef struct _cms_interp_struc {  // Used on all interpolations. Supplied by lcms2 when calling the interpolation function\n\n    cmsContext ContextID;     // The calling thread\n\n    cmsUInt32Number dwFlags;  // Keep original flags\n    cmsUInt32Number nInputs;  // != 1 only in 3D interpolation\n    cmsUInt32Number nOutputs; // != 1 only in 3D interpolation\n\n    cmsUInt32Number nSamples[MAX_INPUT_DIMENSIONS];  // Valid on all kinds of tables\n    cmsUInt32Number Domain[MAX_INPUT_DIMENSIONS];    // Domain = nSamples - 1\n\n    cmsUInt32Number opta[MAX_INPUT_DIMENSIONS];     // Optimization for 3D CLUT. This is the number of nodes premultiplied for each\n                                                    // dimension. For example, in 7 nodes, 7, 7^2 , 7^3, 7^4, etc. On non-regular\n                                                    // Samplings may vary according of the number of nodes for each dimension.\n\n    const void *Table;                // Points to the actual interpolation table\n    cmsInterpFunction Interpolation;  // Points to the function to do the interpolation\n\n } cmsInterpParams;",
          {
            "ContextID": "cmsContext",
            "dwFlags": "cmsUInt32Number",
            "nInputs": "cmsUInt32Number",
            "nOutputs": "cmsUInt32Number",
            "nSamples[MAX_INPUT_DIMENSIONS]": "cmsUInt32Number",
            "Domain[MAX_INPUT_DIMENSIONS]": "cmsUInt32Number",
            "opta[MAX_INPUT_DIMENSIONS]": "cmsUInt32Number",
            "void": "const",
            "Interpolation": "cmsInterpFunction"
          },
          "cmsInterpParams",
          [
            291,
            0
          ],
          [
            309,
            19
          ]
        ],
        [
          "typedef struct {\n    cmsPluginBase base;\n\n    // Points to a user-supplied function which implements the factory\n    cmsInterpFnFactory InterpolatorsFactory;\n\n} cmsPluginInterpolation;",
          {
            "base": "cmsPluginBase",
            "InterpolatorsFactory": "cmsInterpFnFactory"
          },
          "cmsPluginInterpolation",
          [
            315,
            0
          ],
          [
            321,
            25
          ]
        ],
        [
          "typedef struct {\n    cmsPluginBase base;\n\n    cmsUInt32Number nFunctions;                                     // Number of supported functions\n    cmsUInt32Number FunctionTypes[MAX_TYPES_IN_LCMS_PLUGIN];        // The identification types\n    cmsUInt32Number ParameterCount[MAX_TYPES_IN_LCMS_PLUGIN];       // Number of parameters for each function\n\n    cmsParametricCurveEvaluator    Evaluator;                       // The evaluator\n\n} cmsPluginParametricCurves;",
          {
            "base": "cmsPluginBase",
            "nFunctions": "cmsUInt32Number",
            "FunctionTypes[MAX_TYPES_IN_LCMS_PLUGIN]": "cmsUInt32Number",
            "ParameterCount[MAX_TYPES_IN_LCMS_PLUGIN]": "cmsUInt32Number",
            "Evaluator": "cmsParametricCurveEvaluator"
          },
          "cmsPluginParametricCurves",
          [
            331,
            0
          ],
          [
            340,
            28
          ]
        ],
        [
          "typedef struct {\n    cmsPluginBase          base;\n    cmsFormatterFactory    FormattersFactory;\n\n} cmsPluginFormatters;",
          {
            "base": "cmsPluginBase",
            "FormattersFactory": "cmsFormatterFactory"
          },
          "cmsPluginFormatters",
          [
            376,
            0
          ],
          [
            380,
            22
          ]
        ],
        [
          "typedef struct _cms_typehandler_struct {\n\n        cmsTagTypeSignature Signature;     // The signature of the type\n\n        // Allocates and reads items\n        void *   (* ReadPtr)(struct _cms_typehandler_struct* self,\n                             cmsIOHANDLER*      io,\n                             cmsUInt32Number*   nItems,\n                             cmsUInt32Number    SizeOfTag);\n\n        // Writes n Items\n        cmsBool  (* WritePtr)(struct _cms_typehandler_struct* self,\n                              cmsIOHANDLER*     io,\n                              void*             Ptr,\n                              cmsUInt32Number   nItems);\n\n        // Duplicate an item or array of items\n        void*   (* DupPtr)(struct _cms_typehandler_struct* self,\n                           const void *Ptr,\n                           cmsUInt32Number n);\n\n        // Free all resources\n        void    (* FreePtr)(struct _cms_typehandler_struct* self,\n                            void *Ptr);\n\n        // Additional parameters used by the calling thread\n        cmsContext       ContextID;\n        cmsUInt32Number  ICCVersion;\n\n} cmsTagTypeHandler;",
          {
            "Signature": "cmsTagTypeSignature",
            "*   (* ReadPtr)(struct _cms_typehandler_struct* self,\n                             cmsIOHANDLER*      io,\n                             cmsUInt32Number*   nItems,\n                             cmsUInt32Number    SizeOfTag)": "void",
            "(* WritePtr)(struct _cms_typehandler_struct* self,\n                              cmsIOHANDLER*     io,\n                              void*             Ptr,\n                              cmsUInt32Number   nItems)": "cmsBool",
            "*   (* DupPtr)(struct _cms_typehandler_struct* self,\n                           const void *Ptr,\n                           cmsUInt32Number n)": "void",
            "(* FreePtr)(struct _cms_typehandler_struct* self,\n                            void *Ptr)": "void",
            "ContextID": "cmsContext",
            "ICCVersion": "cmsUInt32Number"
          },
          "cmsTagTypeHandler",
          [
            386,
            0
          ],
          [
            415,
            20
          ]
        ],
        [
          "typedef struct {\n        cmsPluginBase      base;\n        cmsTagTypeHandler  Handler;\n\n} cmsPluginTagType;",
          {
            "base": "cmsPluginBase",
            "Handler": "cmsTagTypeHandler"
          },
          "cmsPluginTagType",
          [
            418,
            0
          ],
          [
            422,
            19
          ]
        ],
        [
          "typedef struct {\n\n    cmsUInt32Number     ElemCount;          // If this tag needs an array, how many elements should keep\n\n    // For reading.\n    cmsUInt32Number     nSupportedTypes;    // In how many types this tag can come (MAX_TYPES_IN_LCMS_PLUGIN maximum)\n    cmsTagTypeSignature SupportedTypes[MAX_TYPES_IN_LCMS_PLUGIN];\n\n    // For writing\n    cmsTagTypeSignature (* DecideType)(cmsFloat64Number ICCVersion, const void *Data);\n\n} cmsTagDescriptor;",
          {
            "ElemCount": "cmsUInt32Number",
            "nSupportedTypes": "cmsUInt32Number",
            "SupportedTypes[MAX_TYPES_IN_LCMS_PLUGIN]": "cmsTagTypeSignature",
            "(* DecideType)(cmsFloat64Number ICCVersion, const void *Data)": "cmsTagTypeSignature"
          },
          "cmsTagDescriptor",
          [
            429,
            0
          ],
          [
            440,
            19
          ]
        ],
        [
          "typedef struct {\n    cmsPluginBase    base;\n\n    cmsTagSignature  Signature;\n    cmsTagDescriptor Descriptor;\n\n} cmsPluginTag;",
          {
            "base": "cmsPluginBase",
            "Signature": "cmsTagSignature",
            "Descriptor": "cmsTagDescriptor"
          },
          "cmsPluginTag",
          [
            443,
            0
          ],
          [
            449,
            15
          ]
        ],
        [
          "typedef struct {\n    cmsPluginBase     base;\n    cmsUInt32Number   Intent;\n    cmsIntentFn       Link;\n    char              Description[256];\n\n} cmsPluginRenderingIntent;",
          {
            "base": "cmsPluginBase",
            "Intent": "cmsUInt32Number",
            "Link": "cmsIntentFn",
            "Description[256]": "char"
          },
          "cmsPluginRenderingIntent",
          [
            468,
            0
          ],
          [
            474,
            27
          ]
        ],
        [
          "typedef struct {\n      cmsPluginBase     base;\n      cmsTagTypeHandler Handler;\n\n}  cmsPluginMultiProcessElement;",
          {
            "base": "cmsPluginBase",
            "Handler": "cmsTagTypeHandler"
          },
          "cmsPluginMultiProcessElement",
          [
            505,
            0
          ],
          [
            509,
            32
          ]
        ],
        [
          "typedef struct {\n    cmsUInt32Number nCurves;\n    cmsToneCurve**  TheCurves;\n\n} _cmsStageToneCurvesData;",
          {
            "nCurves": "cmsUInt32Number",
            "**  TheCurves": "cmsToneCurve"
          },
          "_cmsStageToneCurvesData",
          [
            515,
            0
          ],
          [
            519,
            26
          ]
        ],
        [
          "typedef struct {\n    cmsFloat64Number*  Double;          // floating point for the matrix\n    cmsFloat64Number*  Offset;          // The offset\n\n} _cmsStageMatrixData;",
          {
            "*  Double": "cmsFloat64Number",
            "*  Offset": "cmsFloat64Number"
          },
          "_cmsStageMatrixData",
          [
            522,
            0
          ],
          [
            526,
            22
          ]
        ],
        [
          "typedef struct {\n\n    union {                       // Can have only one of both representations at same time\n        cmsUInt16Number*  T;      // Points to the table 16 bits table\n        cmsFloat32Number* TFloat; // Points to the cmsFloat32Number table\n\n    } Tab;\n\n    cmsInterpParams* Params;\n    cmsUInt32Number  nEntries;\n    cmsBool          HasFloatValues;\n\n} _cmsStageCLutData;",
          {
            "Tab": "union {                       // Can have only one of both representations at same time\n        cmsUInt16Number*  T;      // Points to the table 16 bits table\n        cmsFloat32Number* TFloat; // Points to the cmsFloat32Number table\n\n    }",
            "*  T": "cmsUInt16Number",
            "* TFloat": "cmsFloat32Number",
            "* Params": "cmsInterpParams",
            "nEntries": "cmsUInt32Number",
            "HasFloatValues": "cmsBool"
          },
          "_cmsStageCLutData",
          [
            529,
            0
          ],
          [
            541,
            20
          ]
        ],
        [
          "typedef struct {\n      cmsPluginBase     base;\n\n      // Optimize entry point\n      _cmsOPToptimizeFn  OptimizePtr;\n\n}  cmsPluginOptimization;",
          {
            "base": "cmsPluginBase",
            "OptimizePtr": "_cmsOPToptimizeFn"
          },
          "cmsPluginOptimization",
          [
            576,
            0
          ],
          [
            582,
            25
          ]
        ],
        [
          "typedef struct {\n       cmsUInt32Number BytesPerLineIn;\n       cmsUInt32Number BytesPerLineOut;\n       cmsUInt32Number BytesPerPlaneIn;\n       cmsUInt32Number BytesPerPlaneOut;\n\n} cmsStride;",
          {
            "BytesPerLineIn": "cmsUInt32Number",
            "BytesPerLineOut": "cmsUInt32Number",
            "BytesPerPlaneIn": "cmsUInt32Number",
            "BytesPerPlaneOut": "cmsUInt32Number"
          },
          "cmsStride",
          [
            587,
            0
          ],
          [
            593,
            12
          ]
        ],
        [
          "typedef struct {\n      cmsPluginBase     base;\n\n      // Transform entry point\n      union {\n             _cmsTransformFactory        legacy_xform;\n             _cmsTransform2Factory       xform;\n      } factories;\n\n}  cmsPluginTransform;",
          {
            "base": "cmsPluginBase",
            "factories": "union {\n             _cmsTransformFactory        legacy_xform;\n             _cmsTransform2Factory       xform;\n      }",
            "legacy_xform": "_cmsTransformFactory",
            "xform": "_cmsTransform2Factory"
          },
          "cmsPluginTransform",
          [
            638,
            0
          ],
          [
            647,
            22
          ]
        ],
        [
          "typedef struct {\n      cmsPluginBase     base;\n\n     _cmsCreateMutexFnPtrType  CreateMutexPtr;\n     _cmsDestroyMutexFnPtrType DestroyMutexPtr;\n     _cmsLockMutexFnPtrType    LockMutexPtr;\n     _cmsUnlockMutexFnPtrType  UnlockMutexPtr;\n\n}  cmsPluginMutex;",
          {
            "base": "cmsPluginBase",
            "CreateMutexPtr": "_cmsCreateMutexFnPtrType",
            "DestroyMutexPtr": "_cmsDestroyMutexFnPtrType",
            "LockMutexPtr": "_cmsLockMutexFnPtrType",
            "UnlockMutexPtr": "_cmsUnlockMutexFnPtrType"
          },
          "cmsPluginMutex",
          [
            657,
            0
          ],
          [
            665,
            18
          ]
        ],
        [
          "typedef struct {\n    cmsPluginBase       base;\n\n    cmsInt32Number      MaxWorkers;       // Number of starts to do as maximum\n    cmsUInt32Number     WorkerFlags;      // Reserved\n    _cmsTransform2Fn    SchedulerFn;      // callback to setup functions     \n\n}  cmsPluginParalellization;",
          {
            "base": "cmsPluginBase",
            "MaxWorkers": "cmsInt32Number",
            "WorkerFlags": "cmsUInt32Number",
            "SchedulerFn": "_cmsTransform2Fn"
          },
          "cmsPluginParalellization",
          [
            682,
            0
          ],
          [
            689,
            28
          ]
        ],
        [
          "typedef struct {\n    cmsFloat64Number n[3];\n\n    } cmsVEC3;",
          {
            "n[3]": "cmsFloat64Number"
          },
          "cmsVEC3",
          [
            70,
            0
          ],
          [
            73,
            14
          ]
        ],
        [
          "typedef struct {\n    cmsVEC3 v[3];\n\n    } cmsMAT3;",
          {
            "v[3]": "cmsVEC3"
          },
          "cmsMAT3",
          [
            76,
            0
          ],
          [
            79,
            14
          ]
        ],
        [
          "struct _cms_io_handler {\n\n    void* stream;   // Associated stream, which is implemented differently depending on media.\n\n    cmsContext        ContextID;\n    cmsUInt32Number   UsedSpace;\n    cmsUInt32Number   ReportedSize;\n    char              PhysicalFile[cmsMAX_PATH];\n\n    cmsUInt32Number   (* Read)(struct _cms_io_handler* iohandler, void *Buffer,\n                                                                  cmsUInt32Number size,\n                                                                  cmsUInt32Number count);\n    cmsBool           (* Seek)(struct _cms_io_handler* iohandler, cmsUInt32Number offset);\n    cmsBool           (* Close)(struct _cms_io_handler* iohandler);\n    cmsUInt32Number   (* Tell)(struct _cms_io_handler* iohandler);\n    cmsBool           (* Write)(struct _cms_io_handler* iohandler, cmsUInt32Number size,\n                                                                   const void* Buffer);\n}",
          {
            "* stream": "void",
            "ContextID": "cmsContext",
            "UsedSpace": "cmsUInt32Number",
            "ReportedSize": "cmsUInt32Number",
            "PhysicalFile[cmsMAX_PATH]": "char",
            "(* Read)(struct _cms_io_handler* iohandler, void *Buffer,\n                                                                  cmsUInt32Number size,\n                                                                  cmsUInt32Number count)": "cmsUInt32Number",
            "(* Seek)(struct _cms_io_handler* iohandler, cmsUInt32Number offset)": "cmsBool",
            "(* Close)(struct _cms_io_handler* iohandler)": "cmsBool",
            "(* Tell)(struct _cms_io_handler* iohandler)": "cmsUInt32Number",
            "(* Write)(struct _cms_io_handler* iohandler, cmsUInt32Number size,\n                                                                   const void* Buffer)": "cmsBool"
          },
          "_cms_io_handler",
          [
            117,
            0
          ],
          [
            134,
            1
          ]
        ],
        [
          "struct _cms_io_handler",
          {},
          "",
          [
            126,
            31
          ],
          [
            126,
            53
          ]
        ],
        [
          "struct _cms_io_handler",
          {},
          "",
          [
            129,
            31
          ],
          [
            129,
            53
          ]
        ],
        [
          "struct _cms_io_handler",
          {},
          "",
          [
            130,
            32
          ],
          [
            130,
            54
          ]
        ],
        [
          "struct _cms_io_handler",
          {},
          "",
          [
            131,
            31
          ],
          [
            131,
            53
          ]
        ],
        [
          "struct _cms_io_handler",
          {},
          "",
          [
            132,
            32
          ],
          [
            132,
            54
          ]
        ],
        [
          "typedef struct {\n    cmsTagTypeSignature  sig;\n    cmsInt8Number        reserved[4];\n\n} _cmsTagBase;",
          {
            "sig": "cmsTagTypeSignature",
            "reserved[4]": "cmsInt8Number"
          },
          "_cmsTagBase",
          [
            161,
            0
          ],
          [
            165,
            14
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            186,
            93
          ],
          [
            186,
            102
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            187,
            95
          ],
          [
            187,
            104
          ]
        ],
        [
          "typedef struct _cmsPluginBaseStruct {\n\n        cmsUInt32Number                Magic;               // 'acpp' signature\n        cmsUInt32Number                ExpectedVersion;     // Expected version of LittleCMS\n        cmsUInt32Number                Type;                // Type of plug-in\n        struct _cmsPluginBaseStruct*   Next;                // For multiple plugin definition. NULL for end of list.\n\n} cmsPluginBase;",
          {
            "Magic": "cmsUInt32Number",
            "ExpectedVersion": "cmsUInt32Number",
            "Type": "cmsUInt32Number",
            "*   Next": "struct _cmsPluginBaseStruct"
          },
          "cmsPluginBase",
          [
            213,
            0
          ],
          [
            220,
            16
          ]
        ],
        [
          "struct _cmsPluginBaseStruct",
          {},
          "",
          [
            218,
            8
          ],
          [
            218,
            35
          ]
        ],
        [
          "typedef struct {\n\n        cmsPluginBase base;\n\n        // Required\n        _cmsMallocFnPtrType  MallocPtr;\n        _cmsFreeFnPtrType    FreePtr;\n        _cmsReallocFnPtrType ReallocPtr;\n\n        // Optional\n       _cmsMalloZerocFnPtrType MallocZeroPtr;\n       _cmsCallocFnPtrType     CallocPtr;\n       _cmsDupFnPtrType        DupPtr;\n\n} cmsPluginMemHandler;",
          {
            "base": "cmsPluginBase",
            "MallocPtr": "_cmsMallocFnPtrType",
            "FreePtr": "_cmsFreeFnPtrType",
            "ReallocPtr": "_cmsReallocFnPtrType",
            "MallocZeroPtr": "_cmsMalloZerocFnPtrType",
            "CallocPtr": "_cmsCallocFnPtrType",
            "DupPtr": "_cmsDupFnPtrType"
          },
          "cmsPluginMemHandler",
          [
            237,
            0
          ],
          [
            251,
            22
          ]
        ],
        [
          "struct _cms_interp_struc",
          {},
          "",
          [
            257,
            0
          ],
          [
            257,
            24
          ]
        ],
        [
          "struct _cms_interp_struc",
          {},
          "",
          [
            273,
            41
          ],
          [
            273,
            65
          ]
        ],
        [
          "typedef struct _cms_interp_struc {  // Used on all interpolations. Supplied by lcms2 when calling the interpolation function\n\n    cmsContext ContextID;     // The calling thread\n\n    cmsUInt32Number dwFlags;  // Keep original flags\n    cmsUInt32Number nInputs;  // != 1 only in 3D interpolation\n    cmsUInt32Number nOutputs; // != 1 only in 3D interpolation\n\n    cmsUInt32Number nSamples[MAX_INPUT_DIMENSIONS];  // Valid on all kinds of tables\n    cmsUInt32Number Domain[MAX_INPUT_DIMENSIONS];    // Domain = nSamples - 1\n\n    cmsUInt32Number opta[MAX_INPUT_DIMENSIONS];     // Optimization for 3D CLUT. This is the number of nodes premultiplied for each\n                                                    // dimension. For example, in 7 nodes, 7, 7^2 , 7^3, 7^4, etc. On non-regular\n                                                    // Samplings may vary according of the number of nodes for each dimension.\n\n    const void *Table;                // Points to the actual interpolation table\n    cmsInterpFunction Interpolation;  // Points to the function to do the interpolation\n\n } cmsInterpParams;",
          {
            "ContextID": "cmsContext",
            "dwFlags": "cmsUInt32Number",
            "nInputs": "cmsUInt32Number",
            "nOutputs": "cmsUInt32Number",
            "nSamples[MAX_INPUT_DIMENSIONS]": "cmsUInt32Number",
            "Domain[MAX_INPUT_DIMENSIONS]": "cmsUInt32Number",
            "opta[MAX_INPUT_DIMENSIONS]": "cmsUInt32Number",
            "void": "const",
            "Interpolation": "cmsInterpFunction"
          },
          "cmsInterpParams",
          [
            291,
            0
          ],
          [
            309,
            19
          ]
        ],
        [
          "typedef struct {\n    cmsPluginBase base;\n\n    // Points to a user-supplied function which implements the factory\n    cmsInterpFnFactory InterpolatorsFactory;\n\n} cmsPluginInterpolation;",
          {
            "base": "cmsPluginBase",
            "InterpolatorsFactory": "cmsInterpFnFactory"
          },
          "cmsPluginInterpolation",
          [
            315,
            0
          ],
          [
            321,
            25
          ]
        ],
        [
          "typedef struct {\n    cmsPluginBase base;\n\n    cmsUInt32Number nFunctions;                                     // Number of supported functions\n    cmsUInt32Number FunctionTypes[MAX_TYPES_IN_LCMS_PLUGIN];        // The identification types\n    cmsUInt32Number ParameterCount[MAX_TYPES_IN_LCMS_PLUGIN];       // Number of parameters for each function\n\n    cmsParametricCurveEvaluator    Evaluator;                       // The evaluator\n\n} cmsPluginParametricCurves;",
          {
            "base": "cmsPluginBase",
            "nFunctions": "cmsUInt32Number",
            "FunctionTypes[MAX_TYPES_IN_LCMS_PLUGIN]": "cmsUInt32Number",
            "ParameterCount[MAX_TYPES_IN_LCMS_PLUGIN]": "cmsUInt32Number",
            "Evaluator": "cmsParametricCurveEvaluator"
          },
          "cmsPluginParametricCurves",
          [
            331,
            0
          ],
          [
            340,
            28
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            347,
            0
          ],
          [
            347,
            27
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            354,
            46
          ],
          [
            354,
            73
          ]
        ],
        [
          "typedef struct {\n    cmsPluginBase          base;\n    cmsFormatterFactory    FormattersFactory;\n\n} cmsPluginFormatters;",
          {
            "base": "cmsPluginBase",
            "FormattersFactory": "cmsFormatterFactory"
          },
          "cmsPluginFormatters",
          [
            376,
            0
          ],
          [
            380,
            22
          ]
        ],
        [
          "typedef struct _cms_typehandler_struct {\n\n        cmsTagTypeSignature Signature;     // The signature of the type\n\n        // Allocates and reads items\n        void *   (* ReadPtr)(struct _cms_typehandler_struct* self,\n                             cmsIOHANDLER*      io,\n                             cmsUInt32Number*   nItems,\n                             cmsUInt32Number    SizeOfTag);\n\n        // Writes n Items\n        cmsBool  (* WritePtr)(struct _cms_typehandler_struct* self,\n                              cmsIOHANDLER*     io,\n                              void*             Ptr,\n                              cmsUInt32Number   nItems);\n\n        // Duplicate an item or array of items\n        void*   (* DupPtr)(struct _cms_typehandler_struct* self,\n                           const void *Ptr,\n                           cmsUInt32Number n);\n\n        // Free all resources\n        void    (* FreePtr)(struct _cms_typehandler_struct* self,\n                            void *Ptr);\n\n        // Additional parameters used by the calling thread\n        cmsContext       ContextID;\n        cmsUInt32Number  ICCVersion;\n\n} cmsTagTypeHandler;",
          {
            "Signature": "cmsTagTypeSignature",
            "*   (* ReadPtr)(struct _cms_typehandler_struct* self,\n                             cmsIOHANDLER*      io,\n                             cmsUInt32Number*   nItems,\n                             cmsUInt32Number    SizeOfTag)": "void",
            "(* WritePtr)(struct _cms_typehandler_struct* self,\n                              cmsIOHANDLER*     io,\n                              void*             Ptr,\n                              cmsUInt32Number   nItems)": "cmsBool",
            "*   (* DupPtr)(struct _cms_typehandler_struct* self,\n                           const void *Ptr,\n                           cmsUInt32Number n)": "void",
            "(* FreePtr)(struct _cms_typehandler_struct* self,\n                            void *Ptr)": "void",
            "ContextID": "cmsContext",
            "ICCVersion": "cmsUInt32Number"
          },
          "cmsTagTypeHandler",
          [
            386,
            0
          ],
          [
            415,
            20
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            391,
            29
          ],
          [
            391,
            59
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            397,
            30
          ],
          [
            397,
            60
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            403,
            27
          ],
          [
            403,
            57
          ]
        ],
        [
          "struct _cms_typehandler_struct",
          {},
          "",
          [
            408,
            28
          ],
          [
            408,
            58
          ]
        ],
        [
          "typedef struct {\n        cmsPluginBase      base;\n        cmsTagTypeHandler  Handler;\n\n} cmsPluginTagType;",
          {
            "base": "cmsPluginBase",
            "Handler": "cmsTagTypeHandler"
          },
          "cmsPluginTagType",
          [
            418,
            0
          ],
          [
            422,
            19
          ]
        ],
        [
          "typedef struct {\n\n    cmsUInt32Number     ElemCount;          // If this tag needs an array, how many elements should keep\n\n    // For reading.\n    cmsUInt32Number     nSupportedTypes;    // In how many types this tag can come (MAX_TYPES_IN_LCMS_PLUGIN maximum)\n    cmsTagTypeSignature SupportedTypes[MAX_TYPES_IN_LCMS_PLUGIN];\n\n    // For writing\n    cmsTagTypeSignature (* DecideType)(cmsFloat64Number ICCVersion, const void *Data);\n\n} cmsTagDescriptor;",
          {
            "ElemCount": "cmsUInt32Number",
            "nSupportedTypes": "cmsUInt32Number",
            "SupportedTypes[MAX_TYPES_IN_LCMS_PLUGIN]": "cmsTagTypeSignature",
            "(* DecideType)(cmsFloat64Number ICCVersion, const void *Data)": "cmsTagTypeSignature"
          },
          "cmsTagDescriptor",
          [
            429,
            0
          ],
          [
            440,
            19
          ]
        ],
        [
          "typedef struct {\n    cmsPluginBase    base;\n\n    cmsTagSignature  Signature;\n    cmsTagDescriptor Descriptor;\n\n} cmsPluginTag;",
          {
            "base": "cmsPluginBase",
            "Signature": "cmsTagSignature",
            "Descriptor": "cmsTagDescriptor"
          },
          "cmsPluginTag",
          [
            443,
            0
          ],
          [
            449,
            15
          ]
        ],
        [
          "typedef struct {\n    cmsPluginBase     base;\n    cmsUInt32Number   Intent;\n    cmsIntentFn       Link;\n    char              Description[256];\n\n} cmsPluginRenderingIntent;",
          {
            "base": "cmsPluginBase",
            "Intent": "cmsUInt32Number",
            "Link": "cmsIntentFn",
            "Description[256]": "char"
          },
          "cmsPluginRenderingIntent",
          [
            468,
            0
          ],
          [
            474,
            27
          ]
        ],
        [
          "typedef struct {\n      cmsPluginBase     base;\n      cmsTagTypeHandler Handler;\n\n}  cmsPluginMultiProcessElement;",
          {
            "base": "cmsPluginBase",
            "Handler": "cmsTagTypeHandler"
          },
          "cmsPluginMultiProcessElement",
          [
            505,
            0
          ],
          [
            509,
            32
          ]
        ],
        [
          "typedef struct {\n    cmsUInt32Number nCurves;\n    cmsToneCurve**  TheCurves;\n\n} _cmsStageToneCurvesData;",
          {
            "nCurves": "cmsUInt32Number",
            "**  TheCurves": "cmsToneCurve"
          },
          "_cmsStageToneCurvesData",
          [
            515,
            0
          ],
          [
            519,
            26
          ]
        ],
        [
          "typedef struct {\n    cmsFloat64Number*  Double;          // floating point for the matrix\n    cmsFloat64Number*  Offset;          // The offset\n\n} _cmsStageMatrixData;",
          {
            "*  Double": "cmsFloat64Number",
            "*  Offset": "cmsFloat64Number"
          },
          "_cmsStageMatrixData",
          [
            522,
            0
          ],
          [
            526,
            22
          ]
        ],
        [
          "typedef struct {\n\n    union {                       // Can have only one of both representations at same time\n        cmsUInt16Number*  T;      // Points to the table 16 bits table\n        cmsFloat32Number* TFloat; // Points to the cmsFloat32Number table\n\n    } Tab;\n\n    cmsInterpParams* Params;\n    cmsUInt32Number  nEntries;\n    cmsBool          HasFloatValues;\n\n} _cmsStageCLutData;",
          {
            "Tab": "union {                       // Can have only one of both representations at same time\n        cmsUInt16Number*  T;      // Points to the table 16 bits table\n        cmsFloat32Number* TFloat; // Points to the cmsFloat32Number table\n\n    }",
            "*  T": "cmsUInt16Number",
            "* TFloat": "cmsFloat32Number",
            "* Params": "cmsInterpParams",
            "nEntries": "cmsUInt32Number",
            "HasFloatValues": "cmsBool"
          },
          "_cmsStageCLutData",
          [
            529,
            0
          ],
          [
            541,
            20
          ]
        ],
        [
          "typedef struct {\n      cmsPluginBase     base;\n\n      // Optimize entry point\n      _cmsOPToptimizeFn  OptimizePtr;\n\n}  cmsPluginOptimization;",
          {
            "base": "cmsPluginBase",
            "OptimizePtr": "_cmsOPToptimizeFn"
          },
          "cmsPluginOptimization",
          [
            576,
            0
          ],
          [
            582,
            25
          ]
        ],
        [
          "typedef struct {\n       cmsUInt32Number BytesPerLineIn;\n       cmsUInt32Number BytesPerLineOut;\n       cmsUInt32Number BytesPerPlaneIn;\n       cmsUInt32Number BytesPerPlaneOut;\n\n} cmsStride;",
          {
            "BytesPerLineIn": "cmsUInt32Number",
            "BytesPerLineOut": "cmsUInt32Number",
            "BytesPerPlaneIn": "cmsUInt32Number",
            "BytesPerPlaneOut": "cmsUInt32Number"
          },
          "cmsStride",
          [
            587,
            0
          ],
          [
            593,
            12
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            595,
            37
          ],
          [
            595,
            64
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            602,
            37
          ],
          [
            602,
            64
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            627,
            49
          ],
          [
            627,
            76
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            628,
            49
          ],
          [
            628,
            76
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            632,
            56
          ],
          [
            632,
            83
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            633,
            56
          ],
          [
            633,
            83
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            636,
            55
          ],
          [
            636,
            82
          ]
        ],
        [
          "typedef struct {\n      cmsPluginBase     base;\n\n      // Transform entry point\n      union {\n             _cmsTransformFactory        legacy_xform;\n             _cmsTransform2Factory       xform;\n      } factories;\n\n}  cmsPluginTransform;",
          {
            "base": "cmsPluginBase",
            "factories": "union {\n             _cmsTransformFactory        legacy_xform;\n             _cmsTransform2Factory       xform;\n      }",
            "legacy_xform": "_cmsTransformFactory",
            "xform": "_cmsTransform2Factory"
          },
          "cmsPluginTransform",
          [
            638,
            0
          ],
          [
            647,
            22
          ]
        ],
        [
          "typedef struct {\n      cmsPluginBase     base;\n\n     _cmsCreateMutexFnPtrType  CreateMutexPtr;\n     _cmsDestroyMutexFnPtrType DestroyMutexPtr;\n     _cmsLockMutexFnPtrType    LockMutexPtr;\n     _cmsUnlockMutexFnPtrType  UnlockMutexPtr;\n\n}  cmsPluginMutex;",
          {
            "base": "cmsPluginBase",
            "CreateMutexPtr": "_cmsCreateMutexFnPtrType",
            "DestroyMutexPtr": "_cmsDestroyMutexFnPtrType",
            "LockMutexPtr": "_cmsLockMutexFnPtrType",
            "UnlockMutexPtr": "_cmsUnlockMutexFnPtrType"
          },
          "cmsPluginMutex",
          [
            657,
            0
          ],
          [
            665,
            18
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            675,
            57
          ],
          [
            675,
            84
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            676,
            61
          ],
          [
            676,
            88
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            677,
            62
          ],
          [
            677,
            89
          ]
        ],
        [
          "typedef struct {\n    cmsPluginBase       base;\n\n    cmsInt32Number      MaxWorkers;       // Number of starts to do as maximum\n    cmsUInt32Number     WorkerFlags;      // Reserved\n    _cmsTransform2Fn    SchedulerFn;      // callback to setup functions     \n\n}  cmsPluginParalellization;",
          {
            "base": "cmsPluginBase",
            "MaxWorkers": "cmsInt32Number",
            "WorkerFlags": "cmsUInt32Number",
            "SchedulerFn": "_cmsTransform2Fn"
          },
          "cmsPluginParalellization",
          [
            682,
            0
          ],
          [
            689,
            28
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"lcms2.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include <memory.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum { cmsFormatterInput=0, cmsFormatterOutput=1 } cmsFormatterDirection;",
          {
            "cmsFormatterInput": "",
            "cmsFormatterOutput": ""
          },
          "cmsFormatterDirection",
          [
            369,
            0
          ],
          [
            369,
            81
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/include/lcms2.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "cmsGetEncodedCMMversion(void)",
          "fn_dec_pos": [
            [
              1072,
              35
            ],
            [
              1072,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetEncodedCMMversion",
            "parameters": {},
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsstrcasecmp(const char* s1, const char* s2)",
          "fn_dec_pos": [
            [
              1076,
              35
            ],
            [
              1076,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsstrcasecmp",
            "parameters": {
              "s1": "char",
              "s2": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsfilelength(FILE* f)",
          "fn_dec_pos": [
            [
              1077,
              35
            ],
            [
              1077,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsfilelength",
            "parameters": {
              "f": "FILE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsCreateContext(void* Plugin, void* UserData)",
          "fn_dec_pos": [
            [
              1087,
              34
            ],
            [
              1087,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateContext",
            "parameters": {
              "Plugin": "void",
              "UserData": "void"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsDeleteContext(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              1088,
              34
            ],
            [
              1088,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDeleteContext",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsDupContext(cmsContext ContextID, void* NewUserData)",
          "fn_dec_pos": [
            [
              1089,
              34
            ],
            [
              1089,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDupContext",
            "parameters": {
              "ContextID": "cmsContext",
              "NewUserData": "void"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetContextUserData(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              1090,
              34
            ],
            [
              1090,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetContextUserData",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsPlugin(void* Plugin)",
          "fn_dec_pos": [
            [
              1094,
              35
            ],
            [
              1094,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPlugin",
            "parameters": {
              "Plugin": "void"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsPluginTHR(cmsContext ContextID, void* Plugin)",
          "fn_dec_pos": [
            [
              1095,
              35
            ],
            [
              1095,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPluginTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "Plugin": "void"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsUnregisterPlugins(void)",
          "fn_dec_pos": [
            [
              1096,
              35
            ],
            [
              1096,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsUnregisterPlugins",
            "parameters": {},
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsUnregisterPluginsTHR(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              1097,
              35
            ],
            [
              1097,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsUnregisterPluginsTHR",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "(* cmsLogErrorHandlerFunction)(cmsContext ContextID, cmsUInt32Number ErrorCode, const char *Text)",
          "fn_dec_pos": [
            [
              1130,
              14
            ],
            [
              1130,
              111
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "ErrorCode": "cmsUInt32Number",
              "Text": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cmsSetLogErrorHandler(cmsLogErrorHandlerFunction Fn)",
          "fn_dec_pos": [
            [
              1133,
              35
            ],
            [
              1133,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetLogErrorHandler",
            "parameters": {
              "Fn": "cmsLogErrorHandlerFunction"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSetLogErrorHandlerTHR(cmsContext ContextID, cmsLogErrorHandlerFunction Fn)",
          "fn_dec_pos": [
            [
              1134,
              35
            ],
            [
              1134,
              112
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetLogErrorHandlerTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "Fn": "cmsLogErrorHandlerFunction"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsD50_XYZ(void)",
          "fn_dec_pos": [
            [
              1139,
              35
            ],
            [
              1139,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsD50_XYZ",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "cmsD50_xyY(void)",
          "fn_dec_pos": [
            [
              1140,
              35
            ],
            [
              1140,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsD50_xyY",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "cmsXYZ2xyY(cmsCIExyY* Dest, const cmsCIEXYZ* Source)",
          "fn_dec_pos": [
            [
              1143,
              35
            ],
            [
              1143,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsXYZ2xyY",
            "parameters": {
              "Dest": "cmsCIExyY",
              "Source": "cmsCIEXYZ"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsxyY2XYZ(cmsCIEXYZ* Dest, const cmsCIExyY* Source)",
          "fn_dec_pos": [
            [
              1144,
              35
            ],
            [
              1144,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsxyY2XYZ",
            "parameters": {
              "Dest": "cmsCIEXYZ",
              "Source": "cmsCIExyY"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsXYZ2Lab(const cmsCIEXYZ* WhitePoint, cmsCIELab* Lab, const cmsCIEXYZ* xyz)",
          "fn_dec_pos": [
            [
              1145,
              35
            ],
            [
              1145,
              112
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsXYZ2Lab",
            "parameters": {
              "WhitePoint": "cmsCIEXYZ",
              "Lab": "cmsCIELab",
              "xyz": "cmsCIEXYZ"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsLab2XYZ(const cmsCIEXYZ* WhitePoint, cmsCIEXYZ* xyz, const cmsCIELab* Lab)",
          "fn_dec_pos": [
            [
              1146,
              35
            ],
            [
              1146,
              112
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsLab2XYZ",
            "parameters": {
              "WhitePoint": "cmsCIEXYZ",
              "xyz": "cmsCIEXYZ",
              "Lab": "cmsCIELab"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsLab2LCh(cmsCIELCh*LCh, const cmsCIELab* Lab)",
          "fn_dec_pos": [
            [
              1147,
              35
            ],
            [
              1147,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsLab2LCh",
            "parameters": {
              "LCh": "cmsCIELCh",
              "Lab": "cmsCIELab"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsLCh2Lab(cmsCIELab* Lab, const cmsCIELCh* LCh)",
          "fn_dec_pos": [
            [
              1148,
              35
            ],
            [
              1148,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsLCh2Lab",
            "parameters": {
              "Lab": "cmsCIELab",
              "LCh": "cmsCIELCh"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsLabEncoded2Float(cmsCIELab* Lab, const cmsUInt16Number wLab[3])",
          "fn_dec_pos": [
            [
              1151,
              35
            ],
            [
              1151,
              101
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsLabEncoded2Float",
            "parameters": {
              "Lab": "cmsCIELab",
              "wLab": "cmsUInt16Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsLabEncoded2FloatV2(cmsCIELab* Lab, const cmsUInt16Number wLab[3])",
          "fn_dec_pos": [
            [
              1152,
              35
            ],
            [
              1152,
              103
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsLabEncoded2FloatV2",
            "parameters": {
              "Lab": "cmsCIELab",
              "wLab": "cmsUInt16Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsFloat2LabEncoded(cmsUInt16Number wLab[3], const cmsCIELab* Lab)",
          "fn_dec_pos": [
            [
              1153,
              35
            ],
            [
              1153,
              101
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFloat2LabEncoded",
            "parameters": {
              "wLab": "cmsUInt16Number",
              "Lab": "cmsCIELab"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsFloat2LabEncodedV2(cmsUInt16Number wLab[3], const cmsCIELab* Lab)",
          "fn_dec_pos": [
            [
              1154,
              35
            ],
            [
              1154,
              103
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFloat2LabEncodedV2",
            "parameters": {
              "wLab": "cmsUInt16Number",
              "Lab": "cmsCIELab"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsXYZEncoded2Float(cmsCIEXYZ* fxyz, const cmsUInt16Number XYZ[3])",
          "fn_dec_pos": [
            [
              1155,
              35
            ],
            [
              1155,
              101
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsXYZEncoded2Float",
            "parameters": {
              "fxyz": "cmsCIEXYZ",
              "XYZ": "cmsUInt16Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsFloat2XYZEncoded(cmsUInt16Number XYZ[3], const cmsCIEXYZ* fXYZ)",
          "fn_dec_pos": [
            [
              1156,
              35
            ],
            [
              1156,
              101
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFloat2XYZEncoded",
            "parameters": {
              "XYZ": "cmsUInt16Number",
              "fXYZ": "cmsCIEXYZ"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsDeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2)",
          "fn_dec_pos": [
            [
              1159,
              35
            ],
            [
              1159,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDeltaE",
            "parameters": {
              "Lab1": "cmsCIELab",
              "Lab2": "cmsCIELab"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCIE94DeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2)",
          "fn_dec_pos": [
            [
              1160,
              35
            ],
            [
              1160,
              95
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCIE94DeltaE",
            "parameters": {
              "Lab1": "cmsCIELab",
              "Lab2": "cmsCIELab"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsBFDdeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2)",
          "fn_dec_pos": [
            [
              1161,
              35
            ],
            [
              1161,
              93
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsBFDdeltaE",
            "parameters": {
              "Lab1": "cmsCIELab",
              "Lab2": "cmsCIELab"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCMCdeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2, cmsFloat64Number l, cmsFloat64Number c)",
          "fn_dec_pos": [
            [
              1162,
              35
            ],
            [
              1162,
              133
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCMCdeltaE",
            "parameters": {
              "Lab1": "cmsCIELab",
              "Lab2": "cmsCIELab",
              "l": "cmsFloat64Number",
              "c": "cmsFloat64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCIE2000DeltaE(const cmsCIELab* Lab1, const cmsCIELab* Lab2, cmsFloat64Number Kl, cmsFloat64Number Kc, cmsFloat64Number Kh)",
          "fn_dec_pos": [
            [
              1163,
              35
            ],
            [
              1163,
              160
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCIE2000DeltaE",
            "parameters": {
              "Lab1": "cmsCIELab",
              "Lab2": "cmsCIELab",
              "Kl": "cmsFloat64Number",
              "Kc": "cmsFloat64Number",
              "Kh": "cmsFloat64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsWhitePointFromTemp(cmsCIExyY* WhitePoint, cmsFloat64Number  TempK)",
          "fn_dec_pos": [
            [
              1166,
              35
            ],
            [
              1166,
              104
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsWhitePointFromTemp",
            "parameters": {
              "WhitePoint": "cmsCIExyY",
              "TempK": "cmsFloat64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsTempFromWhitePoint(cmsFloat64Number* TempK, const cmsCIExyY* WhitePoint)",
          "fn_dec_pos": [
            [
              1167,
              35
            ],
            [
              1167,
              110
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsTempFromWhitePoint",
            "parameters": {
              "TempK": "cmsFloat64Number",
              "WhitePoint": "cmsCIExyY"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsAdaptToIlluminant(cmsCIEXYZ* Result, const cmsCIEXYZ* SourceWhitePt,\n                                                                           const cmsCIEXYZ* Illuminant,\n                                                                           const cmsCIEXYZ* Value)",
          "fn_dec_pos": [
            [
              1170,
              35
            ],
            [
              1172,
              98
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsAdaptToIlluminant",
            "parameters": {
              "Result": "cmsCIEXYZ",
              "SourceWhitePt": "cmsCIEXYZ",
              "Illuminant": "cmsCIEXYZ",
              "Value": "cmsCIEXYZ"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCIECAM02Init(cmsContext ContextID, const cmsViewingConditions* pVC)",
          "fn_dec_pos": [
            [
              1197,
              35
            ],
            [
              1197,
              105
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCIECAM02Init",
            "parameters": {
              "ContextID": "cmsContext",
              "pVC": "cmsViewingConditions"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCIECAM02Done(cmsHANDLE hModel)",
          "fn_dec_pos": [
            [
              1198,
              35
            ],
            [
              1198,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCIECAM02Done",
            "parameters": {
              "hModel": "cmsHANDLE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCIECAM02Forward(cmsHANDLE hModel, const cmsCIEXYZ* pIn, cmsJCh* pOut)",
          "fn_dec_pos": [
            [
              1199,
              35
            ],
            [
              1199,
              107
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCIECAM02Forward",
            "parameters": {
              "hModel": "cmsHANDLE",
              "pIn": "cmsCIEXYZ",
              "pOut": "cmsJCh"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCIECAM02Reverse(cmsHANDLE hModel, const cmsJCh* pIn,    cmsCIEXYZ* pOut)",
          "fn_dec_pos": [
            [
              1200,
              35
            ],
            [
              1200,
              110
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCIECAM02Reverse",
            "parameters": {
              "hModel": "cmsHANDLE",
              "pIn": "cmsJCh",
              "pOut": "cmsCIEXYZ"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsBuildSegmentedToneCurve(cmsContext ContextID, cmsUInt32Number nSegments, const cmsCurveSegment Segments[])",
          "fn_dec_pos": [
            [
              1220,
              35
            ],
            [
              1220,
              144
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "nSegments": "cmsUInt32Number",
              "Segments": "cmsCurveSegment"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsBuildParametricToneCurve(cmsContext ContextID, cmsInt32Number Type, const cmsFloat64Number Params[])",
          "fn_dec_pos": [
            [
              1221,
              35
            ],
            [
              1221,
              138
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "Type": "cmsInt32Number",
              "Params": "cmsFloat64Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsBuildGamma(cmsContext ContextID, cmsFloat64Number Gamma)",
          "fn_dec_pos": [
            [
              1222,
              35
            ],
            [
              1222,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "Gamma": "cmsFloat64Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsBuildTabulatedToneCurve16(cmsContext ContextID, cmsUInt32Number nEntries, const cmsUInt16Number values[])",
          "fn_dec_pos": [
            [
              1223,
              35
            ],
            [
              1223,
              143
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "nEntries": "cmsUInt32Number",
              "values": "cmsUInt16Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsBuildTabulatedToneCurveFloat(cmsContext ContextID, cmsUInt32Number nEntries, const cmsFloat32Number values[])",
          "fn_dec_pos": [
            [
              1224,
              35
            ],
            [
              1224,
              147
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "nEntries": "cmsUInt32Number",
              "values": "cmsFloat32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsFreeToneCurve(cmsToneCurve* Curve)",
          "fn_dec_pos": [
            [
              1225,
              35
            ],
            [
              1225,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFreeToneCurve",
            "parameters": {
              "Curve": "cmsToneCurve"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsFreeToneCurveTriple(cmsToneCurve* Curve[3])",
          "fn_dec_pos": [
            [
              1226,
              35
            ],
            [
              1226,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFreeToneCurveTriple",
            "parameters": {
              "Curve": "cmsToneCurve"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsDupToneCurve(const cmsToneCurve* Src)",
          "fn_dec_pos": [
            [
              1227,
              35
            ],
            [
              1227,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "Src": "cmsToneCurve"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsReverseToneCurve(const cmsToneCurve* InGamma)",
          "fn_dec_pos": [
            [
              1228,
              35
            ],
            [
              1228,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "InGamma": "cmsToneCurve"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsReverseToneCurveEx(cmsUInt32Number nResultSamples, const cmsToneCurve* InGamma)",
          "fn_dec_pos": [
            [
              1229,
              35
            ],
            [
              1229,
              117
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "nResultSamples": "cmsUInt32Number",
              "InGamma": "cmsToneCurve"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsJoinToneCurve(cmsContext ContextID, const cmsToneCurve* X,  const cmsToneCurve* Y, cmsUInt32Number nPoints)",
          "fn_dec_pos": [
            [
              1230,
              35
            ],
            [
              1230,
              145
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "X": "cmsToneCurve",
              "Y": "cmsToneCurve",
              "nPoints": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsSmoothToneCurve(cmsToneCurve* Tab, cmsFloat64Number lambda)",
          "fn_dec_pos": [
            [
              1231,
              35
            ],
            [
              1231,
              97
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSmoothToneCurve",
            "parameters": {
              "Tab": "cmsToneCurve",
              "lambda": "cmsFloat64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsEvalToneCurveFloat(const cmsToneCurve* Curve, cmsFloat32Number v)",
          "fn_dec_pos": [
            [
              1232,
              35
            ],
            [
              1232,
              103
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsEvalToneCurveFloat",
            "parameters": {
              "Curve": "cmsToneCurve",
              "v": "cmsFloat32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsEvalToneCurve16(const cmsToneCurve* Curve, cmsUInt16Number v)",
          "fn_dec_pos": [
            [
              1233,
              35
            ],
            [
              1233,
              99
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsEvalToneCurve16",
            "parameters": {
              "Curve": "cmsToneCurve",
              "v": "cmsUInt16Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIsToneCurveMultisegment(const cmsToneCurve* InGamma)",
          "fn_dec_pos": [
            [
              1234,
              35
            ],
            [
              1234,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIsToneCurveMultisegment",
            "parameters": {
              "InGamma": "cmsToneCurve"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIsToneCurveLinear(const cmsToneCurve* Curve)",
          "fn_dec_pos": [
            [
              1235,
              35
            ],
            [
              1235,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIsToneCurveLinear",
            "parameters": {
              "Curve": "cmsToneCurve"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIsToneCurveMonotonic(const cmsToneCurve* t)",
          "fn_dec_pos": [
            [
              1236,
              35
            ],
            [
              1236,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIsToneCurveMonotonic",
            "parameters": {
              "t": "cmsToneCurve"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIsToneCurveDescending(const cmsToneCurve* t)",
          "fn_dec_pos": [
            [
              1237,
              35
            ],
            [
              1237,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIsToneCurveDescending",
            "parameters": {
              "t": "cmsToneCurve"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetToneCurveParametricType(const cmsToneCurve* t)",
          "fn_dec_pos": [
            [
              1238,
              35
            ],
            [
              1238,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetToneCurveParametricType",
            "parameters": {
              "t": "cmsToneCurve"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsEstimateGamma(const cmsToneCurve* t, cmsFloat64Number Precision)",
          "fn_dec_pos": [
            [
              1239,
              35
            ],
            [
              1239,
              102
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsEstimateGamma",
            "parameters": {
              "t": "cmsToneCurve",
              "Precision": "cmsFloat64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetToneCurveSegment(cmsInt32Number n, const cmsToneCurve* t)",
          "fn_dec_pos": [
            [
              1241,
              40
            ],
            [
              1241,
              103
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "n": "cmsInt32Number",
              "t": "cmsToneCurve"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsGetToneCurveEstimatedTableEntries(const cmsToneCurve* t)",
          "fn_dec_pos": [
            [
              1244,
              41
            ],
            [
              1244,
              100
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetToneCurveEstimatedTableEntries",
            "parameters": {
              "t": "cmsToneCurve"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetToneCurveEstimatedTable(const cmsToneCurve* t)",
          "fn_dec_pos": [
            [
              1245,
              41
            ],
            [
              1245,
              93
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "t": "cmsToneCurve"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsPipelineAlloc(cmsContext ContextID, cmsUInt32Number InputChannels, cmsUInt32Number OutputChannels)",
          "fn_dec_pos": [
            [
              1255,
              35
            ],
            [
              1255,
              136
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "InputChannels": "cmsUInt32Number",
              "OutputChannels": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsPipelineFree(cmsPipeline* lut)",
          "fn_dec_pos": [
            [
              1256,
              35
            ],
            [
              1256,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineFree",
            "parameters": {
              "lut": "cmsPipeline"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsPipelineDup(const cmsPipeline* Orig)",
          "fn_dec_pos": [
            [
              1257,
              35
            ],
            [
              1257,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "Orig": "cmsPipeline"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsGetPipelineContextID(const cmsPipeline* lut)",
          "fn_dec_pos": [
            [
              1259,
              35
            ],
            [
              1259,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetPipelineContextID",
            "parameters": {
              "lut": "cmsPipeline"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsPipelineInputChannels(const cmsPipeline* lut)",
          "fn_dec_pos": [
            [
              1260,
              35
            ],
            [
              1260,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineInputChannels",
            "parameters": {
              "lut": "cmsPipeline"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsPipelineOutputChannels(const cmsPipeline* lut)",
          "fn_dec_pos": [
            [
              1261,
              35
            ],
            [
              1261,
              84
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineOutputChannels",
            "parameters": {
              "lut": "cmsPipeline"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsPipelineStageCount(const cmsPipeline* lut)",
          "fn_dec_pos": [
            [
              1263,
              35
            ],
            [
              1263,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineStageCount",
            "parameters": {
              "lut": "cmsPipeline"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsPipelineGetPtrToFirstStage(const cmsPipeline* lut)",
          "fn_dec_pos": [
            [
              1264,
              35
            ],
            [
              1264,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineGetPtrToFirstStage",
            "parameters": {
              "lut": "cmsPipeline"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsPipelineGetPtrToLastStage(const cmsPipeline* lut)",
          "fn_dec_pos": [
            [
              1265,
              35
            ],
            [
              1265,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineGetPtrToLastStage",
            "parameters": {
              "lut": "cmsPipeline"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsPipelineEval16(const cmsUInt16Number In[], cmsUInt16Number Out[], const cmsPipeline* lut)",
          "fn_dec_pos": [
            [
              1267,
              35
            ],
            [
              1267,
              127
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineEval16",
            "parameters": {
              "In": "cmsUInt16Number",
              "Out": "cmsUInt16Number",
              "lut": "cmsPipeline"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsPipelineEvalFloat(const cmsFloat32Number In[], cmsFloat32Number Out[], const cmsPipeline* lut)",
          "fn_dec_pos": [
            [
              1268,
              35
            ],
            [
              1268,
              132
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineEvalFloat",
            "parameters": {
              "In": "cmsFloat32Number",
              "Out": "cmsFloat32Number",
              "lut": "cmsPipeline"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsPipelineEvalReverseFloat(cmsFloat32Number Target[], cmsFloat32Number Result[], cmsFloat32Number Hint[], const cmsPipeline* lut)",
          "fn_dec_pos": [
            [
              1269,
              35
            ],
            [
              1269,
              165
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineEvalReverseFloat",
            "parameters": {
              "Target": "cmsFloat32Number",
              "Result": "cmsFloat32Number",
              "Hint": "cmsFloat32Number",
              "lut": "cmsPipeline"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsPipelineCat(cmsPipeline* l1, const cmsPipeline* l2)",
          "fn_dec_pos": [
            [
              1270,
              35
            ],
            [
              1270,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineCat",
            "parameters": {
              "l1": "cmsPipeline",
              "l2": "cmsPipeline"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsPipelineSetSaveAs8bitsFlag(cmsPipeline* lut, cmsBool On)",
          "fn_dec_pos": [
            [
              1271,
              35
            ],
            [
              1271,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineSetSaveAs8bitsFlag",
            "parameters": {
              "lut": "cmsPipeline",
              "On": "cmsBool"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage* mpe)",
          "fn_dec_pos": [
            [
              1276,
              35
            ],
            [
              1276,
              107
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineInsertStage",
            "parameters": {
              "lut": "cmsPipeline",
              "loc": "cmsStageLoc",
              "mpe": "cmsStage"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsPipelineUnlinkStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage** mpe)",
          "fn_dec_pos": [
            [
              1277,
              35
            ],
            [
              1277,
              108
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineUnlinkStage",
            "parameters": {
              "lut": "cmsPipeline",
              "loc": "cmsStageLoc",
              "mpe": "cmsStage"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsPipelineCheckAndRetreiveStages(const cmsPipeline* Lut, cmsUInt32Number n, ...)",
          "fn_dec_pos": [
            [
              1284,
              35
            ],
            [
              1284,
              116
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsPipelineCheckAndRetreiveStages",
            "parameters": {
              "Lut": "cmsPipeline",
              "n": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsStageAllocIdentity(cmsContext ContextID, cmsUInt32Number nChannels)",
          "fn_dec_pos": [
            [
              1288,
              35
            ],
            [
              1288,
              105
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageAllocIdentity",
            "parameters": {
              "ContextID": "cmsContext",
              "nChannels": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsStageAllocToneCurves(cmsContext ContextID, cmsUInt32Number nChannels, cmsToneCurve* const Curves[])",
          "fn_dec_pos": [
            [
              1289,
              35
            ],
            [
              1289,
              137
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageAllocToneCurves",
            "parameters": {
              "ContextID": "cmsContext",
              "nChannels": "cmsUInt32Number",
              "Curves": "cmsToneCurve"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsStageAllocMatrix(cmsContext ContextID, cmsUInt32Number Rows, cmsUInt32Number Cols, const cmsFloat64Number* Matrix, const cmsFloat64Number* Offset)",
          "fn_dec_pos": [
            [
              1290,
              35
            ],
            [
              1290,
              184
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageAllocMatrix",
            "parameters": {
              "ContextID": "cmsContext",
              "Rows": "cmsUInt32Number",
              "Cols": "cmsUInt32Number",
              "Matrix": "cmsFloat64Number",
              "Offset": "cmsFloat64Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsStageAllocCLut16bit(cmsContext ContextID, cmsUInt32Number nGridPoints, cmsUInt32Number inputChan, cmsUInt32Number outputChan, const cmsUInt16Number* Table)",
          "fn_dec_pos": [
            [
              1292,
              35
            ],
            [
              1292,
              193
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageAllocCLut16bit",
            "parameters": {
              "ContextID": "cmsContext",
              "nGridPoints": "cmsUInt32Number",
              "inputChan": "cmsUInt32Number",
              "outputChan": "cmsUInt32Number",
              "Table": "cmsUInt16Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsStageAllocCLutFloat(cmsContext ContextID, cmsUInt32Number nGridPoints, cmsUInt32Number inputChan, cmsUInt32Number outputChan, const cmsFloat32Number* Table)",
          "fn_dec_pos": [
            [
              1293,
              35
            ],
            [
              1293,
              194
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageAllocCLutFloat",
            "parameters": {
              "ContextID": "cmsContext",
              "nGridPoints": "cmsUInt32Number",
              "inputChan": "cmsUInt32Number",
              "outputChan": "cmsUInt32Number",
              "Table": "cmsFloat32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsStageAllocCLut16bitGranular(cmsContext ContextID, const cmsUInt32Number clutPoints[], cmsUInt32Number inputChan, cmsUInt32Number outputChan, const cmsUInt16Number* Table)",
          "fn_dec_pos": [
            [
              1295,
              35
            ],
            [
              1295,
              208
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageAllocCLut16bitGranular",
            "parameters": {
              "ContextID": "cmsContext",
              "clutPoints": "cmsUInt32Number",
              "inputChan": "cmsUInt32Number",
              "outputChan": "cmsUInt32Number",
              "Table": "cmsUInt16Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsStageAllocCLutFloatGranular(cmsContext ContextID, const cmsUInt32Number clutPoints[], cmsUInt32Number inputChan, cmsUInt32Number outputChan, const cmsFloat32Number* Table)",
          "fn_dec_pos": [
            [
              1296,
              35
            ],
            [
              1296,
              209
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageAllocCLutFloatGranular",
            "parameters": {
              "ContextID": "cmsContext",
              "clutPoints": "cmsUInt32Number",
              "inputChan": "cmsUInt32Number",
              "outputChan": "cmsUInt32Number",
              "Table": "cmsFloat32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsStageDup(cmsStage* mpe)",
          "fn_dec_pos": [
            [
              1298,
              35
            ],
            [
              1298,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageDup",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsStageFree(cmsStage* mpe)",
          "fn_dec_pos": [
            [
              1299,
              35
            ],
            [
              1299,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageFree",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsStageNext(const cmsStage* mpe)",
          "fn_dec_pos": [
            [
              1300,
              35
            ],
            [
              1300,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageNext",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsStageInputChannels(const cmsStage* mpe)",
          "fn_dec_pos": [
            [
              1302,
              35
            ],
            [
              1302,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageInputChannels",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsStageOutputChannels(const cmsStage* mpe)",
          "fn_dec_pos": [
            [
              1303,
              35
            ],
            [
              1303,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageOutputChannels",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsStageType(const cmsStage* mpe)",
          "fn_dec_pos": [
            [
              1304,
              35
            ],
            [
              1304,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageType",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsStageData(const cmsStage* mpe)",
          "fn_dec_pos": [
            [
              1305,
              35
            ],
            [
              1305,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageData",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsGetStageContextID(const cmsStage* mpe)",
          "fn_dec_pos": [
            [
              1306,
              35
            ],
            [
              1306,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetStageContextID",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "(* cmsSAMPLER16)   (CMSREGISTER const cmsUInt16Number In[],\n                                           CMSREGISTER cmsUInt16Number Out[],\n                                           CMSREGISTER void * Cargo)",
          "fn_dec_pos": [
            [
              1309,
              23
            ],
            [
              1311,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "(* cmsSAMPLERFLOAT)(CMSREGISTER const cmsFloat32Number In[],\n                                           CMSREGISTER cmsFloat32Number Out[],\n                                           CMSREGISTER void * Cargo)",
          "fn_dec_pos": [
            [
              1313,
              23
            ],
            [
              1315,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "In": "CMSREGISTER",
              "Out": "CMSREGISTER",
              "void": "CMSREGISTER"
            },
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "cmsStageSampleCLut16bit(cmsStage* mpe, cmsSAMPLER16 Sampler, void* Cargo, cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              1321,
              35
            ],
            [
              1321,
              133
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageSampleCLut16bit",
            "parameters": {
              "mpe": "cmsStage",
              "Sampler": "cmsSAMPLER16",
              "Cargo": "void",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsStageSampleCLutFloat(cmsStage* mpe, cmsSAMPLERFLOAT Sampler, void* Cargo, cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              1322,
              35
            ],
            [
              1322,
              136
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsStageSampleCLutFloat",
            "parameters": {
              "mpe": "cmsStage",
              "Sampler": "cmsSAMPLERFLOAT",
              "Cargo": "void",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSliceSpace16(cmsUInt32Number nInputs, const cmsUInt32Number clutPoints[],\n                                                   cmsSAMPLER16 Sampler, void * Cargo)",
          "fn_dec_pos": [
            [
              1325,
              35
            ],
            [
              1326,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSliceSpace16",
            "parameters": {
              "nInputs": "cmsUInt32Number",
              "clutPoints": "cmsUInt32Number",
              "Sampler": "cmsSAMPLER16",
              "Cargo": "void"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSliceSpaceFloat(cmsUInt32Number nInputs, const cmsUInt32Number clutPoints[],\n                                                   cmsSAMPLERFLOAT Sampler, void * Cargo)",
          "fn_dec_pos": [
            [
              1328,
              35
            ],
            [
              1329,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSliceSpaceFloat",
            "parameters": {
              "nInputs": "cmsUInt32Number",
              "clutPoints": "cmsUInt32Number",
              "Sampler": "cmsSAMPLERFLOAT",
              "Cargo": "void"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsMLUalloc(cmsContext ContextID, cmsUInt32Number nItems)",
          "fn_dec_pos": [
            [
              1341,
              35
            ],
            [
              1341,
              92
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUalloc",
            "parameters": {
              "ContextID": "cmsContext",
              "nItems": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsMLUfree(cmsMLU* mlu)",
          "fn_dec_pos": [
            [
              1342,
              35
            ],
            [
              1342,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUfree",
            "parameters": {
              "mlu": "cmsMLU"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsMLUdup(const cmsMLU* mlu)",
          "fn_dec_pos": [
            [
              1343,
              35
            ],
            [
              1343,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUdup",
            "parameters": {
              "mlu": "cmsMLU"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsMLUsetASCII(cmsMLU* mlu,\n                                                  const char LanguageCode[3], const char CountryCode[3],\n                                                  const char* ASCIIString)",
          "fn_dec_pos": [
            [
              1345,
              35
            ],
            [
              1347,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUsetASCII",
            "parameters": {
              "mlu": "cmsMLU",
              "LanguageCode": "char",
              "CountryCode": "char",
              "ASCIIString": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsMLUsetWide(cmsMLU* mlu,\n                                                  const char LanguageCode[3], const char CountryCode[3],\n                                                  const wchar_t* WideString)",
          "fn_dec_pos": [
            [
              1348,
              35
            ],
            [
              1350,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUsetWide",
            "parameters": {
              "mlu": "cmsMLU",
              "LanguageCode": "char",
              "CountryCode": "char",
              "WideString": "wchar_t"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsMLUsetUTF8(cmsMLU* mlu,\n                                                  const char LanguageCode[3], const char CountryCode[3],\n                                                  const char* UTF8String)",
          "fn_dec_pos": [
            [
              1351,
              35
            ],
            [
              1353,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUsetUTF8",
            "parameters": {
              "mlu": "cmsMLU",
              "LanguageCode": "char",
              "CountryCode": "char",
              "UTF8String": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsMLUgetASCII(const cmsMLU* mlu,\n                                                  const char LanguageCode[3], const char CountryCode[3],\n                                                  char* Buffer,    cmsUInt32Number BufferSize)",
          "fn_dec_pos": [
            [
              1355,
              35
            ],
            [
              1357,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUgetASCII",
            "parameters": {
              "mlu": "cmsMLU",
              "LanguageCode": "char",
              "CountryCode": "char",
              "Buffer": "char",
              "BufferSize": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsMLUgetWide(const cmsMLU* mlu,\n                                                 const char LanguageCode[3], const char CountryCode[3],\n                                                 wchar_t* Buffer, cmsUInt32Number BufferSize)",
          "fn_dec_pos": [
            [
              1359,
              35
            ],
            [
              1361,
              93
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUgetWide",
            "parameters": {
              "mlu": "cmsMLU",
              "LanguageCode": "char",
              "CountryCode": "char",
              "Buffer": "wchar_t",
              "BufferSize": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsMLUgetUTF8(const cmsMLU* mlu,\n                                                 const char LanguageCode[3], const char CountryCode[3],\n                                                 char* Buffer, cmsUInt32Number BufferSize)",
          "fn_dec_pos": [
            [
              1362,
              35
            ],
            [
              1364,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUgetUTF8",
            "parameters": {
              "mlu": "cmsMLU",
              "LanguageCode": "char",
              "CountryCode": "char",
              "Buffer": "char",
              "BufferSize": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsMLUgetTranslation(const cmsMLU* mlu,\n                                                         const char LanguageCode[3], const char CountryCode[3],\n                                                         char ObtainedLanguage[3], char ObtainedCountry[3])",
          "fn_dec_pos": [
            [
              1367,
              35
            ],
            [
              1369,
              107
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUgetTranslation",
            "parameters": {
              "mlu": "cmsMLU",
              "LanguageCode": "char",
              "CountryCode": "char",
              "ObtainedLanguage": "char",
              "ObtainedCountry": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsMLUtranslationsCount(const cmsMLU* mlu)",
          "fn_dec_pos": [
            [
              1371,
              35
            ],
            [
              1371,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUtranslationsCount",
            "parameters": {
              "mlu": "cmsMLU"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsMLUtranslationsCodes(const cmsMLU* mlu,\n                                                             cmsUInt32Number idx,\n                                                             char LanguageCode[3],\n                                                             char CountryCode[3])",
          "fn_dec_pos": [
            [
              1373,
              35
            ],
            [
              1376,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMLUtranslationsCodes",
            "parameters": {
              "mlu": "cmsMLU",
              "idx": "cmsUInt32Number",
              "LanguageCode": "char",
              "CountryCode": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsAllocNamedColorList(cmsContext ContextID,\n                                                           cmsUInt32Number n,\n                                                           cmsUInt32Number ColorantCount,\n                                                           const char* Prefix, const char* Suffix)",
          "fn_dec_pos": [
            [
              1421,
              36
            ],
            [
              1424,
              98
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "n": "cmsUInt32Number",
              "ColorantCount": "cmsUInt32Number",
              "Prefix": "char",
              "Suffix": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsFreeNamedColorList(cmsNAMEDCOLORLIST* v)",
          "fn_dec_pos": [
            [
              1426,
              36
            ],
            [
              1426,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFreeNamedColorList",
            "parameters": {
              "v": "cmsNAMEDCOLORLIST"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsDupNamedColorList(const cmsNAMEDCOLORLIST* v)",
          "fn_dec_pos": [
            [
              1427,
              36
            ],
            [
              1427,
              84
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "v": "cmsNAMEDCOLORLIST"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsAppendNamedColor(cmsNAMEDCOLORLIST* v, const char* Name,\n                                                            cmsUInt16Number PCS[3],\n                                                            cmsUInt16Number Colorant[cmsMAXCHANNELS])",
          "fn_dec_pos": [
            [
              1428,
              36
            ],
            [
              1430,
              101
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsAppendNamedColor",
            "parameters": {
              "v": "cmsNAMEDCOLORLIST",
              "Name": "char",
              "PCS": "cmsUInt16Number",
              "Colorant": "cmsUInt16Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsNamedColorCount(const cmsNAMEDCOLORLIST* v)",
          "fn_dec_pos": [
            [
              1432,
              36
            ],
            [
              1432,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsNamedColorCount",
            "parameters": {
              "v": "cmsNAMEDCOLORLIST"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsNamedColorIndex(const cmsNAMEDCOLORLIST* v, const char* Name)",
          "fn_dec_pos": [
            [
              1433,
              36
            ],
            [
              1433,
              100
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsNamedColorIndex",
            "parameters": {
              "v": "cmsNAMEDCOLORLIST",
              "Name": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsNamedColorInfo(const cmsNAMEDCOLORLIST* NamedColorList, cmsUInt32Number nColor,\n                                                      char* Name,\n                                                      char* Prefix,\n                                                      char* Suffix,\n                                                      cmsUInt16Number* PCS,\n                                                      cmsUInt16Number* Colorant)",
          "fn_dec_pos": [
            [
              1435,
              36
            ],
            [
              1440,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsNamedColorInfo",
            "parameters": {
              "NamedColorList": "cmsNAMEDCOLORLIST",
              "nColor": "cmsUInt32Number",
              "Name": "char",
              "Prefix": "char",
              "Suffix": "char",
              "PCS": "cmsUInt16Number",
              "Colorant": "cmsUInt16Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetNamedColorList(cmsHTRANSFORM xform)",
          "fn_dec_pos": [
            [
              1443,
              36
            ],
            [
              1443,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "xform": "cmsHTRANSFORM"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsAllocProfileSequenceDescription(cmsContext ContextID, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              1470,
              35
            ],
            [
              1470,
              110
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsAllocProfileSequenceDescription",
            "parameters": {
              "ContextID": "cmsContext",
              "n": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsDupProfileSequenceDescription(const cmsSEQ* pseq)",
          "fn_dec_pos": [
            [
              1471,
              35
            ],
            [
              1471,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDupProfileSequenceDescription",
            "parameters": {
              "pseq": "cmsSEQ"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsFreeProfileSequenceDescription(cmsSEQ* pseq)",
          "fn_dec_pos": [
            [
              1472,
              35
            ],
            [
              1472,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFreeProfileSequenceDescription",
            "parameters": {
              "pseq": "cmsSEQ"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsDictAlloc(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              1487,
              37
            ],
            [
              1487,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDictAlloc",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsDictFree(cmsHANDLE hDict)",
          "fn_dec_pos": [
            [
              1488,
              37
            ],
            [
              1488,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDictFree",
            "parameters": {
              "hDict": "cmsHANDLE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsDictDup(cmsHANDLE hDict)",
          "fn_dec_pos": [
            [
              1489,
              37
            ],
            [
              1489,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDictDup",
            "parameters": {
              "hDict": "cmsHANDLE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsDictAddEntry(cmsHANDLE hDict, const wchar_t* Name, const wchar_t* Value, const cmsMLU *DisplayName, const cmsMLU *DisplayValue)",
          "fn_dec_pos": [
            [
              1491,
              37
            ],
            [
              1491,
              167
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDictAddEntry",
            "parameters": {
              "hDict": "cmsHANDLE",
              "Name": "wchar_t",
              "Value": "wchar_t",
              "DisplayName": "cmsMLU",
              "DisplayValue": "cmsMLU"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsDictGetEntryList(cmsHANDLE hDict)",
          "fn_dec_pos": [
            [
              1492,
              37
            ],
            [
              1492,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "hDict": "cmsHANDLE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsDictNextEntry(const cmsDICTentry* e)",
          "fn_dec_pos": [
            [
              1493,
              37
            ],
            [
              1493,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "e": "cmsDICTentry"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsCreateProfilePlaceholder(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              1496,
              35
            ],
            [
              1496,
              84
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateProfilePlaceholder",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetProfileContextID(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              1498,
              35
            ],
            [
              1498,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetProfileContextID",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetTagCount(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              1499,
              35
            ],
            [
              1499,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetTagCount",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetTagSignature(cmsHPROFILE hProfile, cmsUInt32Number n)",
          "fn_dec_pos": [
            [
              1500,
              35
            ],
            [
              1500,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetTagSignature",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "n": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIsTag(cmsHPROFILE hProfile, cmsTagSignature sig)",
          "fn_dec_pos": [
            [
              1501,
              35
            ],
            [
              1501,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIsTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsTagSignature"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsReadTag(cmsHPROFILE hProfile, cmsTagSignature sig)",
          "fn_dec_pos": [
            [
              1504,
              35
            ],
            [
              1504,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsReadTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsTagSignature"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsWriteTag(cmsHPROFILE hProfile, cmsTagSignature sig, const void* data)",
          "fn_dec_pos": [
            [
              1505,
              35
            ],
            [
              1505,
              107
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsWriteTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsTagSignature",
              "data": "void"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsLinkTag(cmsHPROFILE hProfile, cmsTagSignature sig, cmsTagSignature dest)",
          "fn_dec_pos": [
            [
              1506,
              35
            ],
            [
              1506,
              110
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsLinkTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsTagSignature",
              "dest": "cmsTagSignature"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsTagLinkedTo(cmsHPROFILE hProfile, cmsTagSignature sig)",
          "fn_dec_pos": [
            [
              1507,
              35
            ],
            [
              1507,
              92
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsTagLinkedTo",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsTagSignature"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsReadRawTag(cmsHPROFILE hProfile, cmsTagSignature sig, void* Buffer, cmsUInt32Number BufferSize)",
          "fn_dec_pos": [
            [
              1510,
              35
            ],
            [
              1510,
              133
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsReadRawTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsTagSignature",
              "Buffer": "void",
              "BufferSize": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsWriteRawTag(cmsHPROFILE hProfile, cmsTagSignature sig, const void* data, cmsUInt32Number Size)",
          "fn_dec_pos": [
            [
              1511,
              35
            ],
            [
              1511,
              132
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsWriteRawTag",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsTagSignature",
              "data": "void",
              "Size": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetHeaderFlags(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              1519,
              35
            ],
            [
              1519,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetHeaderFlags",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetHeaderAttributes(cmsHPROFILE hProfile, cmsUInt64Number* Flags)",
          "fn_dec_pos": [
            [
              1520,
              35
            ],
            [
              1520,
              103
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetHeaderAttributes",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Flags": "cmsUInt64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetHeaderProfileID(cmsHPROFILE hProfile, cmsUInt8Number* ProfileID)",
          "fn_dec_pos": [
            [
              1521,
              35
            ],
            [
              1521,
              105
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetHeaderProfileID",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "ProfileID": "cmsUInt8Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetHeaderCreationDateTime(cmsHPROFILE hProfile, struct tm *Dest)",
          "fn_dec_pos": [
            [
              1522,
              35
            ],
            [
              1522,
              102
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetHeaderCreationDateTime",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Dest": "struct tm"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetHeaderRenderingIntent(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              1523,
              35
            ],
            [
              1523,
              84
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetHeaderRenderingIntent",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSetHeaderFlags(cmsHPROFILE hProfile, cmsUInt32Number Flags)",
          "fn_dec_pos": [
            [
              1525,
              35
            ],
            [
              1525,
              97
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetHeaderFlags",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Flags": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetHeaderManufacturer(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              1526,
              35
            ],
            [
              1526,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetHeaderManufacturer",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSetHeaderManufacturer(cmsHPROFILE hProfile, cmsUInt32Number manufacturer)",
          "fn_dec_pos": [
            [
              1527,
              35
            ],
            [
              1527,
              111
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetHeaderManufacturer",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "manufacturer": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetHeaderCreator(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              1528,
              35
            ],
            [
              1528,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetHeaderCreator",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetHeaderModel(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              1529,
              35
            ],
            [
              1529,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetHeaderModel",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSetHeaderModel(cmsHPROFILE hProfile, cmsUInt32Number model)",
          "fn_dec_pos": [
            [
              1530,
              35
            ],
            [
              1530,
              97
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetHeaderModel",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "model": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSetHeaderAttributes(cmsHPROFILE hProfile, cmsUInt64Number Flags)",
          "fn_dec_pos": [
            [
              1531,
              35
            ],
            [
              1531,
              102
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetHeaderAttributes",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Flags": "cmsUInt64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSetHeaderProfileID(cmsHPROFILE hProfile, cmsUInt8Number* ProfileID)",
          "fn_dec_pos": [
            [
              1532,
              35
            ],
            [
              1532,
              105
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetHeaderProfileID",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "ProfileID": "cmsUInt8Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSetHeaderRenderingIntent(cmsHPROFILE hProfile, cmsUInt32Number RenderingIntent)",
          "fn_dec_pos": [
            [
              1533,
              35
            ],
            [
              1533,
              117
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetHeaderRenderingIntent",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "RenderingIntent": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetPCS(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              1536,
              35
            ],
            [
              1536,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetPCS",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSetPCS(cmsHPROFILE hProfile, cmsColorSpaceSignature pcs)",
          "fn_dec_pos": [
            [
              1537,
              35
            ],
            [
              1537,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetPCS",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "pcs": "cmsColorSpaceSignature"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetColorSpace(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              1539,
              35
            ],
            [
              1539,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetColorSpace",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSetColorSpace(cmsHPROFILE hProfile, cmsColorSpaceSignature sig)",
          "fn_dec_pos": [
            [
              1540,
              35
            ],
            [
              1540,
              101
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetColorSpace",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsColorSpaceSignature"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetDeviceClass(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              1542,
              35
            ],
            [
              1542,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetDeviceClass",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSetDeviceClass(cmsHPROFILE hProfile, cmsProfileClassSignature sig)",
          "fn_dec_pos": [
            [
              1543,
              35
            ],
            [
              1543,
              104
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetDeviceClass",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsProfileClassSignature"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSetProfileVersion(cmsHPROFILE hProfile, cmsFloat64Number Version)",
          "fn_dec_pos": [
            [
              1544,
              35
            ],
            [
              1544,
              103
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetProfileVersion",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Version": "cmsFloat64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetProfileVersion(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              1545,
              35
            ],
            [
              1545,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetProfileVersion",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetEncodedICCversion(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              1547,
              35
            ],
            [
              1547,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetEncodedICCversion",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSetEncodedICCversion(cmsHPROFILE hProfile, cmsUInt32Number Version)",
          "fn_dec_pos": [
            [
              1548,
              35
            ],
            [
              1548,
              105
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetEncodedICCversion",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Version": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIsIntentSupported(cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number UsedDirection)",
          "fn_dec_pos": [
            [
              1555,
              35
            ],
            [
              1555,
              132
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIsIntentSupported",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "UsedDirection": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIsMatrixShaper(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              1556,
              35
            ],
            [
              1556,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIsMatrixShaper",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIsCLUT(cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number UsedDirection)",
          "fn_dec_pos": [
            [
              1557,
              35
            ],
            [
              1557,
              121
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIsCLUT",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "UsedDirection": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsICCcolorSpace(int OurNotation)",
          "fn_dec_pos": [
            [
              1560,
              42
            ],
            [
              1560,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsICCcolorSpace",
            "parameters": {
              "OurNotation": "int"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsLCMScolorSpace(cmsColorSpaceSignature ProfileSpace)",
          "fn_dec_pos": [
            [
              1561,
              42
            ],
            [
              1561,
              97
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsLCMScolorSpace",
            "parameters": {
              "ProfileSpace": "cmsColorSpaceSignature"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsChannelsOf(cmsColorSpaceSignature ColorSpace)",
          "fn_dec_pos": [
            [
              1564,
              35
            ],
            [
              1564,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsChannelsOf",
            "parameters": {
              "ColorSpace": "cmsColorSpaceSignature"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsChannelsOfColorSpace(cmsColorSpaceSignature ColorSpace)",
          "fn_dec_pos": [
            [
              1567,
              32
            ],
            [
              1567,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsChannelsOfColorSpace",
            "parameters": {
              "ColorSpace": "cmsColorSpaceSignature"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsFormatterForColorspaceOfProfile(cmsHPROFILE hProfile, cmsUInt32Number nBytes, cmsBool lIsFloat)",
          "fn_dec_pos": [
            [
              1570,
              35
            ],
            [
              1570,
              133
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFormatterForColorspaceOfProfile",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "nBytes": "cmsUInt32Number",
              "lIsFloat": "cmsBool"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsFormatterForPCSOfProfile(cmsHPROFILE hProfile, cmsUInt32Number nBytes, cmsBool lIsFloat)",
          "fn_dec_pos": [
            [
              1571,
              35
            ],
            [
              1571,
              126
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsFormatterForPCSOfProfile",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "nBytes": "cmsUInt32Number",
              "lIsFloat": "cmsBool"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetProfileInfo(cmsHPROFILE hProfile, cmsInfoType Info,\n                                                            const char LanguageCode[3], const char CountryCode[3],\n                                                            wchar_t* Buffer, cmsUInt32Number BufferSize)",
          "fn_dec_pos": [
            [
              1582,
              35
            ],
            [
              1584,
              104
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetProfileInfo",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Info": "cmsInfoType",
              "LanguageCode": "char",
              "CountryCode": "char",
              "Buffer": "wchar_t",
              "BufferSize": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetProfileInfoASCII(cmsHPROFILE hProfile, cmsInfoType Info,\n                                                            const char LanguageCode[3], const char CountryCode[3],\n                                                            char* Buffer, cmsUInt32Number BufferSize)",
          "fn_dec_pos": [
            [
              1586,
              35
            ],
            [
              1588,
              101
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetProfileInfoASCII",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Info": "cmsInfoType",
              "LanguageCode": "char",
              "CountryCode": "char",
              "Buffer": "char",
              "BufferSize": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetProfileInfoUTF8(cmsHPROFILE hProfile, cmsInfoType Info,\n                                                            const char LanguageCode[3], const char CountryCode[3],\n                                                            char* Buffer, cmsUInt32Number BufferSize)",
          "fn_dec_pos": [
            [
              1590,
              34
            ],
            [
              1592,
              101
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetProfileInfoUTF8",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Info": "cmsInfoType",
              "LanguageCode": "char",
              "CountryCode": "char",
              "Buffer": "char",
              "BufferSize": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsOpenIOhandlerFromFile(cmsContext ContextID, const char* FileName, const char* AccessMode)",
          "fn_dec_pos": [
            [
              1598,
              35
            ],
            [
              1598,
              127
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "FileName": "char",
              "AccessMode": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsOpenIOhandlerFromStream(cmsContext ContextID, FILE* Stream)",
          "fn_dec_pos": [
            [
              1599,
              35
            ],
            [
              1599,
              97
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "Stream": "FILE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsOpenIOhandlerFromMem(cmsContext ContextID, void *Buffer, cmsUInt32Number size, const char* AccessMode)",
          "fn_dec_pos": [
            [
              1600,
              35
            ],
            [
              1600,
              140
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "Buffer": "void",
              "size": "cmsUInt32Number",
              "AccessMode": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsOpenIOhandlerFromNULL(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              1601,
              35
            ],
            [
              1601,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsGetProfileIOhandler(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              1602,
              35
            ],
            [
              1602,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsCloseIOhandler(cmsIOHANDLER* io)",
          "fn_dec_pos": [
            [
              1603,
              35
            ],
            [
              1603,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCloseIOhandler",
            "parameters": {
              "io": "cmsIOHANDLER"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsMD5computeID(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              1607,
              35
            ],
            [
              1607,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsMD5computeID",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsOpenProfileFromFile(const char *ICCProfile, const char *sAccess)",
          "fn_dec_pos": [
            [
              1611,
              34
            ],
            [
              1611,
              101
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsOpenProfileFromFile",
            "parameters": {
              "ICCProfile": "char",
              "sAccess": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsOpenProfileFromFileTHR(cmsContext ContextID, const char *ICCProfile, const char *sAccess)",
          "fn_dec_pos": [
            [
              1612,
              34
            ],
            [
              1612,
              126
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsOpenProfileFromFileTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "ICCProfile": "char",
              "sAccess": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsOpenProfileFromStream(FILE* ICCProfile, const char* sAccess)",
          "fn_dec_pos": [
            [
              1613,
              34
            ],
            [
              1613,
              97
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsOpenProfileFromStream",
            "parameters": {
              "ICCProfile": "FILE",
              "sAccess": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsOpenProfileFromStreamTHR(cmsContext ContextID, FILE* ICCProfile, const char* sAccess)",
          "fn_dec_pos": [
            [
              1614,
              34
            ],
            [
              1614,
              122
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsOpenProfileFromStreamTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "ICCProfile": "FILE",
              "sAccess": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsOpenProfileFromMem(const void * MemPtr, cmsUInt32Number dwSize)",
          "fn_dec_pos": [
            [
              1615,
              34
            ],
            [
              1615,
              100
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsOpenProfileFromMem",
            "parameters": {
              "MemPtr": "void",
              "dwSize": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsOpenProfileFromMemTHR(cmsContext ContextID, const void * MemPtr, cmsUInt32Number dwSize)",
          "fn_dec_pos": [
            [
              1616,
              34
            ],
            [
              1616,
              125
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsOpenProfileFromMemTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "MemPtr": "void",
              "dwSize": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsOpenProfileFromIOhandlerTHR(cmsContext ContextID, cmsIOHANDLER* io)",
          "fn_dec_pos": [
            [
              1617,
              34
            ],
            [
              1617,
              104
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsOpenProfileFromIOhandlerTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "io": "cmsIOHANDLER"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsOpenProfileFromIOhandler2THR(cmsContext ContextID, cmsIOHANDLER* io, cmsBool write)",
          "fn_dec_pos": [
            [
              1618,
              34
            ],
            [
              1618,
              120
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsOpenProfileFromIOhandler2THR",
            "parameters": {
              "ContextID": "cmsContext",
              "io": "cmsIOHANDLER",
              "write": "cmsBool"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCloseProfile(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              1619,
              34
            ],
            [
              1619,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCloseProfile",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSaveProfileToFile(cmsHPROFILE hProfile, const char* FileName)",
          "fn_dec_pos": [
            [
              1621,
              34
            ],
            [
              1621,
              98
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSaveProfileToFile",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "FileName": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSaveProfileToStream(cmsHPROFILE hProfile, FILE* Stream)",
          "fn_dec_pos": [
            [
              1622,
              34
            ],
            [
              1622,
              92
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSaveProfileToStream",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Stream": "FILE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSaveProfileToMem(cmsHPROFILE hProfile, void *MemPtr, cmsUInt32Number* BytesNeeded)",
          "fn_dec_pos": [
            [
              1623,
              34
            ],
            [
              1623,
              119
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSaveProfileToMem",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "MemPtr": "void",
              "BytesNeeded": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSaveProfileToIOhandler(cmsHPROFILE hProfile, cmsIOHANDLER* io)",
          "fn_dec_pos": [
            [
              1624,
              34
            ],
            [
              1624,
              99
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSaveProfileToIOhandler",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "io": "cmsIOHANDLER"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateRGBProfileTHR(cmsContext ContextID,\n                                                   const cmsCIExyY* WhitePoint,\n                                                   const cmsCIExyYTRIPLE* Primaries,\n                                                   cmsToneCurve* const TransferFunction[3])",
          "fn_dec_pos": [
            [
              1628,
              34
            ],
            [
              1631,
              91
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateRGBProfileTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "WhitePoint": "cmsCIExyY",
              "Primaries": "cmsCIExyYTRIPLE",
              "TransferFunction": "cmsToneCurve"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateRGBProfile(const cmsCIExyY* WhitePoint,\n                                                   const cmsCIExyYTRIPLE* Primaries,\n                                                   cmsToneCurve* const TransferFunction[3])",
          "fn_dec_pos": [
            [
              1633,
              34
            ],
            [
              1635,
              91
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateRGBProfile",
            "parameters": {
              "WhitePoint": "cmsCIExyY",
              "Primaries": "cmsCIExyYTRIPLE",
              "TransferFunction": "cmsToneCurve"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateGrayProfileTHR(cmsContext ContextID,\n                                                    const cmsCIExyY* WhitePoint,\n                                                    const cmsToneCurve* TransferFunction)",
          "fn_dec_pos": [
            [
              1637,
              34
            ],
            [
              1639,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateGrayProfileTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "WhitePoint": "cmsCIExyY",
              "TransferFunction": "cmsToneCurve"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateGrayProfile(const cmsCIExyY* WhitePoint,\n                                                    const cmsToneCurve* TransferFunction)",
          "fn_dec_pos": [
            [
              1641,
              34
            ],
            [
              1642,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateGrayProfile",
            "parameters": {
              "WhitePoint": "cmsCIExyY",
              "TransferFunction": "cmsToneCurve"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateLinearizationDeviceLinkTHR(cmsContext ContextID,\n                                                                cmsColorSpaceSignature ColorSpace,\n                                                                cmsToneCurve* const TransferFunctions[])",
          "fn_dec_pos": [
            [
              1644,
              34
            ],
            [
              1646,
              104
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateLinearizationDeviceLinkTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "ColorSpace": "cmsColorSpaceSignature",
              "TransferFunctions": "cmsToneCurve"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateLinearizationDeviceLink(cmsColorSpaceSignature ColorSpace,\n                                                                cmsToneCurve* const TransferFunctions[])",
          "fn_dec_pos": [
            [
              1648,
              34
            ],
            [
              1649,
              104
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateLinearizationDeviceLink",
            "parameters": {
              "ColorSpace": "cmsColorSpaceSignature",
              "TransferFunctions": "cmsToneCurve"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateInkLimitingDeviceLinkTHR(cmsContext ContextID,\n                                                              cmsColorSpaceSignature ColorSpace, cmsFloat64Number Limit)",
          "fn_dec_pos": [
            [
              1651,
              34
            ],
            [
              1652,
              120
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateInkLimitingDeviceLinkTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "ColorSpace": "cmsColorSpaceSignature",
              "Limit": "cmsFloat64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateInkLimitingDeviceLink(cmsColorSpaceSignature ColorSpace, cmsFloat64Number Limit)",
          "fn_dec_pos": [
            [
              1654,
              34
            ],
            [
              1654,
              123
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateInkLimitingDeviceLink",
            "parameters": {
              "ColorSpace": "cmsColorSpaceSignature",
              "Limit": "cmsFloat64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateDeviceLinkFromCubeFile(const char* cFileName)",
          "fn_dec_pos": [
            [
              1656,
              34
            ],
            [
              1656,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateDeviceLinkFromCubeFile",
            "parameters": {
              "cFileName": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateDeviceLinkFromCubeFileTHR(cmsContext ContextID, const char* cFileName)",
          "fn_dec_pos": [
            [
              1658,
              34
            ],
            [
              1658,
              113
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateDeviceLinkFromCubeFileTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "cFileName": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateLab2ProfileTHR(cmsContext ContextID, const cmsCIExyY* WhitePoint)",
          "fn_dec_pos": [
            [
              1660,
              34
            ],
            [
              1660,
              108
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateLab2ProfileTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "WhitePoint": "cmsCIExyY"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateLab2Profile(const cmsCIExyY* WhitePoint)",
          "fn_dec_pos": [
            [
              1661,
              34
            ],
            [
              1661,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateLab2Profile",
            "parameters": {
              "WhitePoint": "cmsCIExyY"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateLab4ProfileTHR(cmsContext ContextID, const cmsCIExyY* WhitePoint)",
          "fn_dec_pos": [
            [
              1662,
              34
            ],
            [
              1662,
              108
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateLab4ProfileTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "WhitePoint": "cmsCIExyY"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateLab4Profile(const cmsCIExyY* WhitePoint)",
          "fn_dec_pos": [
            [
              1663,
              34
            ],
            [
              1663,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateLab4Profile",
            "parameters": {
              "WhitePoint": "cmsCIExyY"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateXYZProfileTHR(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              1665,
              34
            ],
            [
              1665,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateXYZProfileTHR",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateXYZProfile(void)",
          "fn_dec_pos": [
            [
              1666,
              34
            ],
            [
              1666,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateXYZProfile",
            "parameters": {},
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreate_sRGBProfileTHR(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              1668,
              34
            ],
            [
              1668,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreate_sRGBProfileTHR",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreate_sRGBProfile(void)",
          "fn_dec_pos": [
            [
              1669,
              34
            ],
            [
              1669,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreate_sRGBProfile",
            "parameters": {},
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreate_OkLabProfile(cmsContext ctx)",
          "fn_dec_pos": [
            [
              1671,
              34
            ],
            [
              1671,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreate_OkLabProfile",
            "parameters": {
              "ctx": "cmsContext"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateBCHSWabstractProfileTHR(cmsContext ContextID,\n                                                             cmsUInt32Number nLUTPoints,\n                                                             cmsFloat64Number Bright,\n                                                             cmsFloat64Number Contrast,\n                                                             cmsFloat64Number Hue,\n                                                             cmsFloat64Number Saturation,\n                                                             cmsUInt32Number TempSrc,\n                                                             cmsUInt32Number TempDest)",
          "fn_dec_pos": [
            [
              1673,
              34
            ],
            [
              1680,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateBCHSWabstractProfileTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "nLUTPoints": "cmsUInt32Number",
              "Bright": "cmsFloat64Number",
              "Contrast": "cmsFloat64Number",
              "Hue": "cmsFloat64Number",
              "Saturation": "cmsFloat64Number",
              "TempSrc": "cmsUInt32Number",
              "TempDest": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateBCHSWabstractProfile(cmsUInt32Number nLUTPoints,\n                                                             cmsFloat64Number Bright,\n                                                             cmsFloat64Number Contrast,\n                                                             cmsFloat64Number Hue,\n                                                             cmsFloat64Number Saturation,\n                                                             cmsUInt32Number TempSrc,\n                                                             cmsUInt32Number TempDest)",
          "fn_dec_pos": [
            [
              1682,
              34
            ],
            [
              1688,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateBCHSWabstractProfile",
            "parameters": {
              "nLUTPoints": "cmsUInt32Number",
              "Bright": "cmsFloat64Number",
              "Contrast": "cmsFloat64Number",
              "Hue": "cmsFloat64Number",
              "Saturation": "cmsFloat64Number",
              "TempSrc": "cmsUInt32Number",
              "TempDest": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateNULLProfileTHR(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              1690,
              34
            ],
            [
              1690,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateNULLProfileTHR",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateNULLProfile(void)",
          "fn_dec_pos": [
            [
              1691,
              34
            ],
            [
              1691,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateNULLProfile",
            "parameters": {},
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsTransform2DeviceLink(cmsHTRANSFORM hTransform, cmsFloat64Number Version, cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              1694,
              34
            ],
            [
              1694,
              134
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsTransform2DeviceLink",
            "parameters": {
              "hTransform": "cmsHTRANSFORM",
              "Version": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetSupportedIntents(cmsUInt32Number nMax, cmsUInt32Number* Codes, char** Descriptions)",
          "fn_dec_pos": [
            [
              1713,
              34
            ],
            [
              1713,
              123
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetSupportedIntents",
            "parameters": {
              "nMax": "cmsUInt32Number",
              "Codes": "cmsUInt32Number",
              "Descriptions": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetSupportedIntentsTHR(cmsContext ContextID, cmsUInt32Number nMax, cmsUInt32Number* Codes, char** Descriptions)",
          "fn_dec_pos": [
            [
              1714,
              34
            ],
            [
              1714,
              148
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetSupportedIntentsTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "nMax": "cmsUInt32Number",
              "Codes": "cmsUInt32Number",
              "Descriptions": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateTransformTHR(cmsContext ContextID,\n                                                  cmsHPROFILE Input,\n                                                  cmsUInt32Number InputFormat,\n                                                  cmsHPROFILE Output,\n                                                  cmsUInt32Number OutputFormat,\n                                                  cmsUInt32Number Intent,\n                                                  cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              1756,
              34
            ],
            [
              1762,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateTransformTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "Input": "cmsHPROFILE",
              "InputFormat": "cmsUInt32Number",
              "Output": "cmsHPROFILE",
              "OutputFormat": "cmsUInt32Number",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateTransform(cmsHPROFILE Input,\n                                                  cmsUInt32Number InputFormat,\n                                                  cmsHPROFILE Output,\n                                                  cmsUInt32Number OutputFormat,\n                                                  cmsUInt32Number Intent,\n                                                  cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              1764,
              34
            ],
            [
              1769,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateTransform",
            "parameters": {
              "Input": "cmsHPROFILE",
              "InputFormat": "cmsUInt32Number",
              "Output": "cmsHPROFILE",
              "OutputFormat": "cmsUInt32Number",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateProofingTransformTHR(cmsContext ContextID,\n                                                  cmsHPROFILE Input,\n                                                  cmsUInt32Number InputFormat,\n                                                  cmsHPROFILE Output,\n                                                  cmsUInt32Number OutputFormat,\n                                                  cmsHPROFILE Proofing,\n                                                  cmsUInt32Number Intent,\n                                                  cmsUInt32Number ProofingIntent,\n                                                  cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              1771,
              34
            ],
            [
              1779,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateProofingTransformTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "Input": "cmsHPROFILE",
              "InputFormat": "cmsUInt32Number",
              "Output": "cmsHPROFILE",
              "OutputFormat": "cmsUInt32Number",
              "Proofing": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "ProofingIntent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateProofingTransform(cmsHPROFILE Input,\n                                                  cmsUInt32Number InputFormat,\n                                                  cmsHPROFILE Output,\n                                                  cmsUInt32Number OutputFormat,\n                                                  cmsHPROFILE Proofing,\n                                                  cmsUInt32Number Intent,\n                                                  cmsUInt32Number ProofingIntent,\n                                                  cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              1781,
              34
            ],
            [
              1788,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateProofingTransform",
            "parameters": {
              "Input": "cmsHPROFILE",
              "InputFormat": "cmsUInt32Number",
              "Output": "cmsHPROFILE",
              "OutputFormat": "cmsUInt32Number",
              "Proofing": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "ProofingIntent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateMultiprofileTransformTHR(cmsContext ContextID,\n                                                  cmsHPROFILE hProfiles[],\n                                                  cmsUInt32Number nProfiles,\n                                                  cmsUInt32Number InputFormat,\n                                                  cmsUInt32Number OutputFormat,\n                                                  cmsUInt32Number Intent,\n                                                  cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              1790,
              34
            ],
            [
              1796,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateMultiprofileTransformTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "hProfiles": "cmsHPROFILE",
              "nProfiles": "cmsUInt32Number",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateMultiprofileTransform(cmsHPROFILE hProfiles[],\n                                                  cmsUInt32Number nProfiles,\n                                                  cmsUInt32Number InputFormat,\n                                                  cmsUInt32Number OutputFormat,\n                                                  cmsUInt32Number Intent,\n                                                  cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              1799,
              34
            ],
            [
              1804,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateMultiprofileTransform",
            "parameters": {
              "hProfiles": "cmsHPROFILE",
              "nProfiles": "cmsUInt32Number",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsCreateExtendedTransform(cmsContext ContextID,\n                                                   cmsUInt32Number nProfiles, cmsHPROFILE hProfiles[],\n                                                   cmsBool  BPC[],\n                                                   cmsUInt32Number Intents[],\n                                                   cmsFloat64Number AdaptationStates[],\n                                                   cmsHPROFILE hGamutProfile,\n                                                   cmsUInt32Number nGamutPCSposition,\n                                                   cmsUInt32Number InputFormat,\n                                                   cmsUInt32Number OutputFormat,\n                                                   cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              1807,
              34
            ],
            [
              1816,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsCreateExtendedTransform",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "Intents": "cmsUInt32Number",
              "AdaptationStates": "cmsFloat64Number",
              "hGamutProfile": "cmsHPROFILE",
              "nGamutPCSposition": "cmsUInt32Number",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsDeleteTransform(cmsHTRANSFORM hTransform)",
          "fn_dec_pos": [
            [
              1818,
              34
            ],
            [
              1818,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDeleteTransform",
            "parameters": {
              "hTransform": "cmsHTRANSFORM"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsDoTransform(cmsHTRANSFORM Transform,\n                                                 const void * InputBuffer,\n                                                 void * OutputBuffer,\n                                                 cmsUInt32Number Size)",
          "fn_dec_pos": [
            [
              1820,
              34
            ],
            [
              1823,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDoTransform",
            "parameters": {
              "Transform": "cmsHTRANSFORM",
              "InputBuffer": "void",
              "OutputBuffer": "void",
              "Size": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsDoTransformStride(cmsHTRANSFORM Transform,   // Deprecated\n                                                 const void * InputBuffer,\n                                                 void * OutputBuffer,\n                                                 cmsUInt32Number Size,\n                                                 cmsUInt32Number Stride)",
          "fn_dec_pos": [
            [
              1825,
              34
            ],
            [
              1829,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDoTransformStride",
            "parameters": {
              "Transform": "cmsHTRANSFORM",
              "InputBuffer": "void",
              "OutputBuffer": "void",
              "Size": "cmsUInt32Number",
              "Stride": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsDoTransformLineStride(cmsHTRANSFORM  Transform,\n                                                 const void* InputBuffer,\n                                                 void* OutputBuffer,\n                                                 cmsUInt32Number PixelsPerLine,\n                                                 cmsUInt32Number LineCount,\n                                                 cmsUInt32Number BytesPerLineIn,\n                                                 cmsUInt32Number BytesPerLineOut,\n                                                 cmsUInt32Number BytesPerPlaneIn,\n                                                 cmsUInt32Number BytesPerPlaneOut)",
          "fn_dec_pos": [
            [
              1831,
              34
            ],
            [
              1839,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDoTransformLineStride",
            "parameters": {
              "Transform": "cmsHTRANSFORM",
              "InputBuffer": "void",
              "OutputBuffer": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "BytesPerLineIn": "cmsUInt32Number",
              "BytesPerLineOut": "cmsUInt32Number",
              "BytesPerPlaneIn": "cmsUInt32Number",
              "BytesPerPlaneOut": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSetAlarmCodes(const cmsUInt16Number NewAlarm[cmsMAXCHANNELS])",
          "fn_dec_pos": [
            [
              1842,
              34
            ],
            [
              1842,
              98
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetAlarmCodes",
            "parameters": {
              "NewAlarm": "cmsUInt16Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetAlarmCodes(cmsUInt16Number NewAlarm[cmsMAXCHANNELS])",
          "fn_dec_pos": [
            [
              1843,
              34
            ],
            [
              1843,
              92
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetAlarmCodes",
            "parameters": {
              "NewAlarm": "cmsUInt16Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSetAlarmCodesTHR(cmsContext ContextID, \n                                                          const cmsUInt16Number AlarmCodes[cmsMAXCHANNELS])",
          "fn_dec_pos": [
            [
              1846,
              34
            ],
            [
              1847,
              107
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetAlarmCodesTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "AlarmCodes": "cmsUInt16Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetAlarmCodesTHR(cmsContext ContextID, \n                                                          cmsUInt16Number AlarmCodes[cmsMAXCHANNELS])",
          "fn_dec_pos": [
            [
              1848,
              34
            ],
            [
              1849,
              101
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetAlarmCodesTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "AlarmCodes": "cmsUInt16Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSetAdaptationState(cmsFloat64Number d)",
          "fn_dec_pos": [
            [
              1854,
              34
            ],
            [
              1854,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetAdaptationState",
            "parameters": {
              "d": "cmsFloat64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsSetAdaptationStateTHR(cmsContext ContextID, cmsFloat64Number d)",
          "fn_dec_pos": [
            [
              1855,
              34
            ],
            [
              1855,
              100
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsSetAdaptationStateTHR",
            "parameters": {
              "ContextID": "cmsContext",
              "d": "cmsFloat64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetTransformContextID(cmsHTRANSFORM hTransform)",
          "fn_dec_pos": [
            [
              1860,
              34
            ],
            [
              1860,
              84
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetTransformContextID",
            "parameters": {
              "hTransform": "cmsHTRANSFORM"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetTransformInputFormat(cmsHTRANSFORM hTransform)",
          "fn_dec_pos": [
            [
              1863,
              33
            ],
            [
              1863,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetTransformInputFormat",
            "parameters": {
              "hTransform": "cmsHTRANSFORM"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetTransformOutputFormat(cmsHTRANSFORM hTransform)",
          "fn_dec_pos": [
            [
              1864,
              33
            ],
            [
              1864,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetTransformOutputFormat",
            "parameters": {
              "hTransform": "cmsHTRANSFORM"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsChangeBuffersFormat(cmsHTRANSFORM hTransform,\n                                                         cmsUInt32Number InputFormat,\n                                                         cmsUInt32Number OutputFormat)",
          "fn_dec_pos": [
            [
              1867,
              34
            ],
            [
              1869,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsChangeBuffersFormat",
            "parameters": {
              "hTransform": "cmsHTRANSFORM",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetPostScriptColorResource(cmsContext ContextID,\n                                                                cmsPSResourceType Type,\n                                                                cmsHPROFILE hProfile,\n                                                                cmsUInt32Number Intent,\n                                                                cmsUInt32Number dwFlags,\n                                                                cmsIOHANDLER* io)",
          "fn_dec_pos": [
            [
              1878,
              34
            ],
            [
              1883,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetPostScriptColorResource",
            "parameters": {
              "ContextID": "cmsContext",
              "Type": "cmsPSResourceType",
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number",
              "io": "cmsIOHANDLER"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetPostScriptCSA(cmsContext ContextID, cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number dwFlags, void* Buffer, cmsUInt32Number dwBufferLen)",
          "fn_dec_pos": [
            [
              1885,
              34
            ],
            [
              1885,
              189
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetPostScriptCSA",
            "parameters": {
              "ContextID": "cmsContext",
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number",
              "Buffer": "void",
              "dwBufferLen": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGetPostScriptCRD(cmsContext ContextID, cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number dwFlags, void* Buffer, cmsUInt32Number dwBufferLen)",
          "fn_dec_pos": [
            [
              1886,
              34
            ],
            [
              1886,
              189
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGetPostScriptCRD",
            "parameters": {
              "ContextID": "cmsContext",
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number",
              "Buffer": "void",
              "dwBufferLen": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8Alloc(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              1891,
              34
            ],
            [
              1891,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8Alloc",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8Free(cmsHANDLE hIT8)",
          "fn_dec_pos": [
            [
              1892,
              34
            ],
            [
              1892,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8Free",
            "parameters": {
              "hIT8": "cmsHANDLE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8TableCount(cmsHANDLE hIT8)",
          "fn_dec_pos": [
            [
              1895,
              34
            ],
            [
              1895,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8TableCount",
            "parameters": {
              "hIT8": "cmsHANDLE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8SetTable(cmsHANDLE hIT8, cmsUInt32Number nTable)",
          "fn_dec_pos": [
            [
              1896,
              34
            ],
            [
              1896,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetTable",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "nTable": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8LoadFromFile(cmsContext ContextID, const char* cFileName)",
          "fn_dec_pos": [
            [
              1899,
              34
            ],
            [
              1899,
              97
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8LoadFromFile",
            "parameters": {
              "ContextID": "cmsContext",
              "cFileName": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8LoadFromMem(cmsContext ContextID, const void *Ptr, cmsUInt32Number len)",
          "fn_dec_pos": [
            [
              1900,
              34
            ],
            [
              1900,
              111
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8LoadFromMem",
            "parameters": {
              "ContextID": "cmsContext",
              "Ptr": "void",
              "len": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8SaveToFile(cmsHANDLE hIT8, const char* cFileName)",
          "fn_dec_pos": [
            [
              1903,
              34
            ],
            [
              1903,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SaveToFile",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cFileName": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8SaveToMem(cmsHANDLE hIT8, void *MemPtr, cmsUInt32Number* BytesNeeded)",
          "fn_dec_pos": [
            [
              1904,
              34
            ],
            [
              1904,
              109
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SaveToMem",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "MemPtr": "void",
              "BytesNeeded": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8GetSheetType(cmsHANDLE hIT8)",
          "fn_dec_pos": [
            [
              1907,
              34
            ],
            [
              1907,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetSheetType",
            "parameters": {
              "hIT8": "cmsHANDLE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsIT8SetSheetType(cmsHANDLE hIT8, const char* Type)",
          "fn_dec_pos": [
            [
              1908,
              34
            ],
            [
              1908,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetSheetType",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "Type": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8SetComment(cmsHANDLE hIT8, const char* cComment)",
          "fn_dec_pos": [
            [
              1910,
              34
            ],
            [
              1910,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetComment",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cComment": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8SetPropertyStr(cmsHANDLE hIT8, const char* cProp, const char *Str)",
          "fn_dec_pos": [
            [
              1912,
              34
            ],
            [
              1912,
              106
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetPropertyStr",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cProp": "char",
              "Str": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8SetPropertyDbl(cmsHANDLE hIT8, const char* cProp, cmsFloat64Number Val)",
          "fn_dec_pos": [
            [
              1913,
              34
            ],
            [
              1913,
              111
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetPropertyDbl",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cProp": "char",
              "Val": "cmsFloat64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8SetPropertyHex(cmsHANDLE hIT8, const char* cProp, cmsUInt32Number Val)",
          "fn_dec_pos": [
            [
              1914,
              34
            ],
            [
              1914,
              110
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetPropertyHex",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cProp": "char",
              "Val": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8SetPropertyMulti(cmsHANDLE hIT8, const char* Key, const char* SubKey, const char *Buffer)",
          "fn_dec_pos": [
            [
              1915,
              34
            ],
            [
              1915,
              129
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetPropertyMulti",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "Key": "char",
              "SubKey": "char",
              "Buffer": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8SetPropertyUncooked(cmsHANDLE hIT8, const char* Key, const char* Buffer)",
          "fn_dec_pos": [
            [
              1916,
              34
            ],
            [
              1916,
              112
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetPropertyUncooked",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "Key": "char",
              "Buffer": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8GetProperty(cmsHANDLE hIT8, const char* cProp)",
          "fn_dec_pos": [
            [
              1919,
              34
            ],
            [
              1919,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetProperty",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cProp": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsIT8GetPropertyDbl(cmsHANDLE hIT8, const char* cProp)",
          "fn_dec_pos": [
            [
              1920,
              34
            ],
            [
              1920,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetPropertyDbl",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cProp": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8GetPropertyMulti(cmsHANDLE hIT8, const char* Key, const char *SubKey)",
          "fn_dec_pos": [
            [
              1921,
              34
            ],
            [
              1921,
              109
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetPropertyMulti",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "Key": "char",
              "SubKey": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsIT8EnumProperties(cmsHANDLE hIT8, char ***PropertyNames)",
          "fn_dec_pos": [
            [
              1922,
              34
            ],
            [
              1922,
              93
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8EnumProperties",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "PropertyNames": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8EnumPropertyMulti(cmsHANDLE hIT8, const char* cProp, const char ***SubpropertyNames)",
          "fn_dec_pos": [
            [
              1923,
              34
            ],
            [
              1923,
              124
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8EnumPropertyMulti",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cProp": "char",
              "SubpropertyNames": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8GetDataRowCol(cmsHANDLE hIT8, int row, int col)",
          "fn_dec_pos": [
            [
              1926,
              34
            ],
            [
              1926,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetDataRowCol",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "row": "int",
              "col": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsIT8GetDataRowColDbl(cmsHANDLE hIT8, int row, int col)",
          "fn_dec_pos": [
            [
              1927,
              34
            ],
            [
              1927,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetDataRowColDbl",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "row": "int",
              "col": "int"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8SetDataRowCol(cmsHANDLE hIT8, int row, int col,\n                                                const char* Val)",
          "fn_dec_pos": [
            [
              1929,
              34
            ],
            [
              1930,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetDataRowCol",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "row": "int",
              "col": "int",
              "Val": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8SetDataRowColDbl(cmsHANDLE hIT8, int row, int col,\n                                                cmsFloat64Number Val)",
          "fn_dec_pos": [
            [
              1932,
              34
            ],
            [
              1933,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetDataRowColDbl",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "row": "int",
              "col": "int",
              "Val": "cmsFloat64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8GetData(cmsHANDLE hIT8, const char* cPatch, const char* cSample)",
          "fn_dec_pos": [
            [
              1935,
              34
            ],
            [
              1935,
              104
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetData",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cPatch": "char",
              "cSample": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsIT8GetDataDbl(cmsHANDLE hIT8, const char* cPatch, const char* cSample)",
          "fn_dec_pos": [
            [
              1938,
              34
            ],
            [
              1938,
              107
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetDataDbl",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cPatch": "char",
              "cSample": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8SetData(cmsHANDLE hIT8, const char* cPatch,\n                                                const char* cSample,\n                                                const char *Val)",
          "fn_dec_pos": [
            [
              1940,
              34
            ],
            [
              1942,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetData",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cPatch": "char",
              "cSample": "char",
              "Val": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8SetDataDbl(cmsHANDLE hIT8, const char* cPatch,\n                                                const char* cSample,\n                                                cmsFloat64Number Val)",
          "fn_dec_pos": [
            [
              1944,
              34
            ],
            [
              1946,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetDataDbl",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cPatch": "char",
              "cSample": "char",
              "Val": "cmsFloat64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8FindDataFormat(cmsHANDLE hIT8, const char* cSample)",
          "fn_dec_pos": [
            [
              1948,
              34
            ],
            [
              1948,
              91
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8FindDataFormat",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cSample": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8SetDataFormat(cmsHANDLE hIT8, int n, const char *Sample)",
          "fn_dec_pos": [
            [
              1949,
              34
            ],
            [
              1949,
              96
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetDataFormat",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "n": "int",
              "Sample": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8EnumDataFormat(cmsHANDLE hIT8, char ***SampleNames)",
          "fn_dec_pos": [
            [
              1950,
              34
            ],
            [
              1950,
              91
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8EnumDataFormat",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "SampleNames": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8GetPatchName(cmsHANDLE hIT8, int nPatch, char* buffer)",
          "fn_dec_pos": [
            [
              1952,
              34
            ],
            [
              1952,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetPatchName",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "nPatch": "int",
              "buffer": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cmsIT8GetPatchByName(cmsHANDLE hIT8, const char *cPatch)",
          "fn_dec_pos": [
            [
              1953,
              34
            ],
            [
              1953,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8GetPatchByName",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cPatch": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8SetTableByLabel(cmsHANDLE hIT8, const char* cSet, const char* cField, const char* ExpectedType)",
          "fn_dec_pos": [
            [
              1956,
              34
            ],
            [
              1956,
              135
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetTableByLabel",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cSet": "char",
              "cField": "char",
              "ExpectedType": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8SetIndexColumn(cmsHANDLE hIT8, const char* cSample)",
          "fn_dec_pos": [
            [
              1958,
              34
            ],
            [
              1958,
              91
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8SetIndexColumn",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "cSample": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsIT8DefineDblFormat(cmsHANDLE hIT8, const char* Formatter)",
          "fn_dec_pos": [
            [
              1961,
              34
            ],
            [
              1961,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsIT8DefineDblFormat",
            "parameters": {
              "hIT8": "cmsHANDLE",
              "Formatter": "char"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGBDAlloc(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              1965,
              34
            ],
            [
              1965,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGBDAlloc",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGBDFree(cmsHANDLE hGBD)",
          "fn_dec_pos": [
            [
              1966,
              34
            ],
            [
              1966,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGBDFree",
            "parameters": {
              "hGBD": "cmsHANDLE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGDBAddPoint(cmsHANDLE hGBD, const cmsCIELab* Lab)",
          "fn_dec_pos": [
            [
              1967,
              34
            ],
            [
              1967,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGDBAddPoint",
            "parameters": {
              "hGBD": "cmsHANDLE",
              "Lab": "cmsCIELab"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGDBCompute(cmsHANDLE  hGDB, cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              1968,
              34
            ],
            [
              1968,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGDBCompute",
            "parameters": {
              "hGDB": "cmsHANDLE",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsGDBCheckPoint(cmsHANDLE hGBD, const cmsCIELab* Lab)",
          "fn_dec_pos": [
            [
              1969,
              34
            ],
            [
              1969,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsGDBCheckPoint",
            "parameters": {
              "hGBD": "cmsHANDLE",
              "Lab": "cmsCIELab"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsDetectBlackPoint(cmsCIEXYZ* BlackPoint, cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              1974,
              34
            ],
            [
              1974,
              147
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDetectBlackPoint",
            "parameters": {
              "BlackPoint": "cmsCIEXYZ",
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsDetectDestinationBlackPoint(cmsCIEXYZ* BlackPoint, cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              1975,
              34
            ],
            [
              1975,
              158
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDetectDestinationBlackPoint",
            "parameters": {
              "BlackPoint": "cmsCIEXYZ",
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsDetectTAC(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              1978,
              34
            ],
            [
              1978,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDetectTAC",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsDetectRGBProfileGamma(cmsHPROFILE hProfile, cmsFloat64Number threshold)",
          "fn_dec_pos": [
            [
              1981,
              34
            ],
            [
              1981,
              108
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDetectRGBProfileGamma",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "threshold": "cmsFloat64Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "cmsDesaturateLab(cmsCIELab* Lab,\n                                                   double amax, double amin,\n                                                   double bmax, double bmin)",
          "fn_dec_pos": [
            [
              1984,
              34
            ],
            [
              1986,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsDesaturateLab",
            "parameters": {
              "Lab": "cmsCIELab",
              "amax": "double",
              "amin": "double",
              "bmax": "double",
              "bmin": "double"
            },
            "return_type": "CMSAPI"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n    cmsUInt32Number len;\n    cmsUInt32Number flag;\n    cmsUInt8Number  data[1];\n\n} cmsICCData;",
          {
            "len": "cmsUInt32Number",
            "flag": "cmsUInt32Number",
            "data[1]": "cmsUInt8Number"
          },
          "cmsICCData",
          [
            584,
            0
          ],
          [
            589,
            13
          ]
        ],
        [
          "typedef struct {\n    cmsUInt16Number      year;\n    cmsUInt16Number      month;\n    cmsUInt16Number      day;\n    cmsUInt16Number      hours;\n    cmsUInt16Number      minutes;\n    cmsUInt16Number      seconds;\n\n} cmsDateTimeNumber;",
          {
            "year": "cmsUInt16Number",
            "month": "cmsUInt16Number",
            "day": "cmsUInt16Number",
            "hours": "cmsUInt16Number",
            "minutes": "cmsUInt16Number",
            "seconds": "cmsUInt16Number"
          },
          "cmsDateTimeNumber",
          [
            592,
            0
          ],
          [
            600,
            20
          ]
        ],
        [
          "typedef struct {\n    cmsS15Fixed16Number  X;\n    cmsS15Fixed16Number  Y;\n    cmsS15Fixed16Number  Z;\n\n} cmsEncodedXYZNumber;",
          {
            "X": "cmsS15Fixed16Number",
            "Y": "cmsS15Fixed16Number",
            "Z": "cmsS15Fixed16Number"
          },
          "cmsEncodedXYZNumber",
          [
            603,
            0
          ],
          [
            608,
            22
          ]
        ],
        [
          "typedef struct {\n    cmsUInt32Number              size;           // Profile size in bytes\n    cmsSignature                 cmmId;          // CMM for this profile\n    cmsUInt32Number              version;        // Format version number\n    cmsProfileClassSignature     deviceClass;    // Type of profile\n    cmsColorSpaceSignature       colorSpace;     // Color space of data\n    cmsColorSpaceSignature       pcs;            // PCS, XYZ or Lab only\n    cmsDateTimeNumber            date;           // Date profile was created\n    cmsSignature                 magic;          // Magic Number to identify an ICC profile\n    cmsPlatformSignature         platform;       // Primary Platform\n    cmsUInt32Number              flags;          // Various bit settings\n    cmsSignature                 manufacturer;   // Device manufacturer\n    cmsUInt32Number              model;          // Device model number\n    cmsUInt64Number              attributes;     // Device attributes\n    cmsUInt32Number              renderingIntent;// Rendering intent\n    cmsEncodedXYZNumber          illuminant;     // Profile illuminant\n    cmsSignature                 creator;        // Profile creator\n    cmsProfileID                 profileID;      // Profile ID using MD5\n    cmsInt8Number                reserved[28];   // Reserved for future use\n\n} cmsICCHeader;",
          {
            "size": "cmsUInt32Number",
            "cmmId": "cmsSignature",
            "version": "cmsUInt32Number",
            "deviceClass": "cmsProfileClassSignature",
            "colorSpace": "cmsColorSpaceSignature",
            "pcs": "cmsColorSpaceSignature",
            "date": "cmsDateTimeNumber",
            "magic": "cmsSignature",
            "platform": "cmsPlatformSignature",
            "flags": "cmsUInt32Number",
            "manufacturer": "cmsSignature",
            "model": "cmsUInt32Number",
            "attributes": "cmsUInt64Number",
            "renderingIntent": "cmsUInt32Number",
            "illuminant": "cmsEncodedXYZNumber",
            "creator": "cmsSignature",
            "profileID": "cmsProfileID",
            "reserved[28]": "cmsInt8Number"
          },
          "cmsICCHeader",
          [
            625,
            0
          ],
          [
            645,
            15
          ]
        ],
        [
          "typedef struct {\n    cmsTagTypeSignature  sig;\n    cmsInt8Number        reserved[4];\n\n} cmsTagBase;",
          {
            "sig": "cmsTagTypeSignature",
            "reserved[4]": "cmsInt8Number"
          },
          "cmsTagBase",
          [
            648,
            0
          ],
          [
            652,
            13
          ]
        ],
        [
          "typedef struct {\n    cmsTagSignature      sig;            // The tag signature\n    cmsUInt32Number      offset;         // Start of tag\n    cmsUInt32Number      size;           // Size in bytes\n\n} cmsTagEntry;",
          {
            "sig": "cmsTagSignature",
            "offset": "cmsUInt32Number",
            "size": "cmsUInt32Number"
          },
          "cmsTagEntry",
          [
            655,
            0
          ],
          [
            660,
            14
          ]
        ],
        [
          "typedef struct {\n        cmsFloat64Number X;\n        cmsFloat64Number Y;\n        cmsFloat64Number Z;\n\n    } cmsCIEXYZ;",
          {
            "X": "cmsFloat64Number",
            "Y": "cmsFloat64Number",
            "Z": "cmsFloat64Number"
          },
          "cmsCIEXYZ",
          [
            971,
            0
          ],
          [
            976,
            16
          ]
        ],
        [
          "typedef struct {\n        cmsFloat64Number x;\n        cmsFloat64Number y;\n        cmsFloat64Number Y;\n\n    } cmsCIExyY;",
          {
            "x": "cmsFloat64Number",
            "y": "cmsFloat64Number",
            "Y": "cmsFloat64Number"
          },
          "cmsCIExyY",
          [
            978,
            0
          ],
          [
            983,
            16
          ]
        ],
        [
          "typedef struct {\n        cmsFloat64Number L;\n        cmsFloat64Number a;\n        cmsFloat64Number b;\n\n    } cmsCIELab;",
          {
            "L": "cmsFloat64Number",
            "a": "cmsFloat64Number",
            "b": "cmsFloat64Number"
          },
          "cmsCIELab",
          [
            985,
            0
          ],
          [
            990,
            16
          ]
        ],
        [
          "typedef struct {\n        cmsFloat64Number L;\n        cmsFloat64Number C;\n        cmsFloat64Number h;\n\n    } cmsCIELCh;",
          {
            "L": "cmsFloat64Number",
            "C": "cmsFloat64Number",
            "h": "cmsFloat64Number"
          },
          "cmsCIELCh",
          [
            992,
            0
          ],
          [
            997,
            16
          ]
        ],
        [
          "typedef struct {\n        cmsFloat64Number J;\n        cmsFloat64Number C;\n        cmsFloat64Number h;\n\n    } cmsJCh;",
          {
            "J": "cmsFloat64Number",
            "C": "cmsFloat64Number",
            "h": "cmsFloat64Number"
          },
          "cmsJCh",
          [
            999,
            0
          ],
          [
            1004,
            13
          ]
        ],
        [
          "typedef struct {\n        cmsCIEXYZ  Red;\n        cmsCIEXYZ  Green;\n        cmsCIEXYZ  Blue;\n\n    } cmsCIEXYZTRIPLE;",
          {
            "Red": "cmsCIEXYZ",
            "Green": "cmsCIEXYZ",
            "Blue": "cmsCIEXYZ"
          },
          "cmsCIEXYZTRIPLE",
          [
            1006,
            0
          ],
          [
            1011,
            22
          ]
        ],
        [
          "typedef struct {\n        cmsCIExyY  Red;\n        cmsCIExyY  Green;\n        cmsCIExyY  Blue;\n\n    } cmsCIExyYTRIPLE;",
          {
            "Red": "cmsCIExyY",
            "Green": "cmsCIExyY",
            "Blue": "cmsCIExyY"
          },
          "cmsCIExyYTRIPLE",
          [
            1013,
            0
          ],
          [
            1018,
            22
          ]
        ],
        [
          "typedef struct {\n        cmsUInt32Number  Observer;    // 0 = unknown, 1=CIE 1931, 2=CIE 1964\n        cmsCIEXYZ        Backing;     // Value of backing\n        cmsUInt32Number  Geometry;    // 0=unknown, 1=45/0, 0/45 2=0d, d/0\n        cmsFloat64Number Flare;       // 0..1.0\n        cmsUInt32Number  IlluminantType;\n\n    } cmsICCMeasurementConditions;",
          {
            "Observer": "cmsUInt32Number",
            "Backing": "cmsCIEXYZ",
            "Geometry": "cmsUInt32Number",
            "Flare": "cmsFloat64Number",
            "IlluminantType": "cmsUInt32Number"
          },
          "cmsICCMeasurementConditions",
          [
            1031,
            0
          ],
          [
            1038,
            34
          ]
        ],
        [
          "typedef struct {\n        cmsCIEXYZ       IlluminantXYZ;   // Not the same struct as CAM02,\n        cmsCIEXYZ       SurroundXYZ;     // This is for storing the tag\n        cmsUInt32Number IlluminantType;  // viewing condition\n\n    } cmsICCViewingConditions;",
          {
            "IlluminantXYZ": "cmsCIEXYZ",
            "SurroundXYZ": "cmsCIEXYZ",
            "IlluminantType": "cmsUInt32Number"
          },
          "cmsICCViewingConditions",
          [
            1040,
            0
          ],
          [
            1045,
            30
          ]
        ],
        [
          "typedef struct {\n    cmsUInt8Number  ColourPrimaries;            // Recommendation ITU-T H.273\n    cmsUInt8Number  TransferCharacteristics;    //  (ISO/IEC 23091-2)\n    cmsUInt8Number  MatrixCoefficients;\n    cmsUInt8Number  VideoFullRangeFlag;\n\n} cmsVideoSignalType;",
          {
            "ColourPrimaries": "cmsUInt8Number",
            "TransferCharacteristics": "cmsUInt8Number",
            "MatrixCoefficients": "cmsUInt8Number",
            "VideoFullRangeFlag": "cmsUInt8Number"
          },
          "cmsVideoSignalType",
          [
            1047,
            0
          ],
          [
            1053,
            21
          ]
        ],
        [
          "typedef struct {\n    cmsUInt32Number   CurveEntries;\n    cmsFloat64Number* RedCurve;\n    cmsFloat64Number* GreenCurve;\n    cmsFloat64Number* BlueCurve;\n\n    cmsFloat64Number  MinLuminance;         // ST.2086 min luminance in nits\n    cmsFloat64Number  PeakLuminance;        // ST.2086 peak luminance in nits\n\n    cmsFloat64Number XYZ2XYZmatrix[3][4];\n\n} cmsMHC2Type;",
          {
            "CurveEntries": "cmsUInt32Number",
            "* RedCurve": "cmsFloat64Number",
            "* GreenCurve": "cmsFloat64Number",
            "* BlueCurve": "cmsFloat64Number",
            "MinLuminance": "cmsFloat64Number",
            "PeakLuminance": "cmsFloat64Number",
            "XYZ2XYZmatrix[3][4]": "cmsFloat64Number"
          },
          "cmsMHC2Type",
          [
            1055,
            0
          ],
          [
            1066,
            14
          ]
        ],
        [
          "typedef struct {\n    cmsCIEXYZ        whitePoint;\n    cmsFloat64Number Yb;\n    cmsFloat64Number La;\n    cmsUInt32Number  surround;\n    cmsFloat64Number D_value;\n\n    } cmsViewingConditions;",
          {
            "whitePoint": "cmsCIEXYZ",
            "Yb": "cmsFloat64Number",
            "La": "cmsFloat64Number",
            "surround": "cmsUInt32Number",
            "D_value": "cmsFloat64Number"
          },
          "cmsViewingConditions",
          [
            1188,
            0
          ],
          [
            1195,
            27
          ]
        ],
        [
          "typedef struct {\n    cmsFloat32Number   x0, x1;           // Domain; for x0 < x <= x1\n    cmsInt32Number     Type;             // Parametric type, Type == 0 means sampled segment. Negative values are reserved\n    cmsFloat64Number   Params[10];       // Parameters if Type != 0\n    cmsUInt32Number    nGridPoints;      // Number of grid points if Type == 0\n    cmsFloat32Number*  SampledPoints;    // Points to an array of floats if Type == 0\n\n} cmsCurveSegment;",
          {
            "x0": "cmsFloat32Number",
            "Type": "cmsInt32Number",
            "Params[10]": "cmsFloat64Number",
            "nGridPoints": "cmsUInt32Number",
            "*  SampledPoints": "cmsFloat32Number"
          },
          "cmsCurveSegment",
          [
            1208,
            0
          ],
          [
            1215,
            18
          ]
        ],
        [
          "typedef struct {\n        cmsToneCurve* Ucr;\n        cmsToneCurve* Bg;\n        cmsMLU*       Desc;\n\n} cmsUcrBg;",
          {
            "* Ucr": "cmsToneCurve",
            "* Bg": "cmsToneCurve",
            "*       Desc": "cmsMLU"
          },
          "cmsUcrBg",
          [
            1380,
            0
          ],
          [
            1385,
            11
          ]
        ],
        [
          "typedef struct {\n    cmsFloat64Number  Frequency;\n    cmsFloat64Number  ScreenAngle;\n    cmsUInt32Number   SpotShape;\n\n} cmsScreeningChannel;",
          {
            "Frequency": "cmsFloat64Number",
            "ScreenAngle": "cmsFloat64Number",
            "SpotShape": "cmsUInt32Number"
          },
          "cmsScreeningChannel",
          [
            1402,
            0
          ],
          [
            1407,
            22
          ]
        ],
        [
          "typedef struct {\n    cmsUInt32Number Flag;\n    cmsUInt32Number nChannels;\n    cmsScreeningChannel Channels[cmsMAXCHANNELS];\n\n} cmsScreening;",
          {
            "Flag": "cmsUInt32Number",
            "nChannels": "cmsUInt32Number",
            "Channels[cmsMAXCHANNELS]": "cmsScreeningChannel"
          },
          "cmsScreening",
          [
            1409,
            0
          ],
          [
            1414,
            15
          ]
        ],
        [
          "typedef struct {\n\n    cmsSignature           deviceMfg;\n    cmsSignature           deviceModel;\n    cmsUInt64Number        attributes;\n    cmsTechnologySignature technology;\n    cmsProfileID           ProfileID;\n    cmsMLU*                Manufacturer;\n    cmsMLU*                Model;\n    cmsMLU*                Description;\n\n} cmsPSEQDESC;",
          {
            "deviceMfg": "cmsSignature",
            "deviceModel": "cmsSignature",
            "attributes": "cmsUInt64Number",
            "technology": "cmsTechnologySignature",
            "ProfileID": "cmsProfileID",
            "*                Manufacturer": "cmsMLU",
            "*                Model": "cmsMLU",
            "*                Description": "cmsMLU"
          },
          "cmsPSEQDESC",
          [
            1449,
            0
          ],
          [
            1460,
            14
          ]
        ],
        [
          "typedef struct {\n\n    cmsUInt32Number n;\n    cmsContext      ContextID;\n    cmsPSEQDESC*    seq;\n\n} cmsSEQ;",
          {
            "n": "cmsUInt32Number",
            "ContextID": "cmsContext",
            "*    seq": "cmsPSEQDESC"
          },
          "cmsSEQ",
          [
            1462,
            0
          ],
          [
            1468,
            9
          ]
        ],
        [
          "typedef struct _cmsDICTentry_struct {\n\n    struct _cmsDICTentry_struct* Next;\n\n    cmsMLU *DisplayName;\n    cmsMLU *DisplayValue;\n    wchar_t* Name;\n    wchar_t* Value;\n\n} cmsDICTentry;",
          {
            "* Next": "struct _cmsDICTentry_struct",
            "*DisplayName": "cmsMLU",
            "*DisplayValue": "cmsMLU",
            "* Name": "wchar_t",
            "* Value": "wchar_t"
          },
          "cmsDICTentry",
          [
            1476,
            0
          ],
          [
            1485,
            15
          ]
        ],
        [
          "typedef struct {\n    cmsUInt32Number len;\n    cmsUInt32Number flag;\n    cmsUInt8Number  data[1];\n\n} cmsICCData;",
          {
            "len": "cmsUInt32Number",
            "flag": "cmsUInt32Number",
            "data[1]": "cmsUInt8Number"
          },
          "cmsICCData",
          [
            584,
            0
          ],
          [
            589,
            13
          ]
        ],
        [
          "typedef struct {\n    cmsUInt16Number      year;\n    cmsUInt16Number      month;\n    cmsUInt16Number      day;\n    cmsUInt16Number      hours;\n    cmsUInt16Number      minutes;\n    cmsUInt16Number      seconds;\n\n} cmsDateTimeNumber;",
          {
            "year": "cmsUInt16Number",
            "month": "cmsUInt16Number",
            "day": "cmsUInt16Number",
            "hours": "cmsUInt16Number",
            "minutes": "cmsUInt16Number",
            "seconds": "cmsUInt16Number"
          },
          "cmsDateTimeNumber",
          [
            592,
            0
          ],
          [
            600,
            20
          ]
        ],
        [
          "typedef struct {\n    cmsS15Fixed16Number  X;\n    cmsS15Fixed16Number  Y;\n    cmsS15Fixed16Number  Z;\n\n} cmsEncodedXYZNumber;",
          {
            "X": "cmsS15Fixed16Number",
            "Y": "cmsS15Fixed16Number",
            "Z": "cmsS15Fixed16Number"
          },
          "cmsEncodedXYZNumber",
          [
            603,
            0
          ],
          [
            608,
            22
          ]
        ],
        [
          "typedef struct {\n    cmsUInt32Number              size;           // Profile size in bytes\n    cmsSignature                 cmmId;          // CMM for this profile\n    cmsUInt32Number              version;        // Format version number\n    cmsProfileClassSignature     deviceClass;    // Type of profile\n    cmsColorSpaceSignature       colorSpace;     // Color space of data\n    cmsColorSpaceSignature       pcs;            // PCS, XYZ or Lab only\n    cmsDateTimeNumber            date;           // Date profile was created\n    cmsSignature                 magic;          // Magic Number to identify an ICC profile\n    cmsPlatformSignature         platform;       // Primary Platform\n    cmsUInt32Number              flags;          // Various bit settings\n    cmsSignature                 manufacturer;   // Device manufacturer\n    cmsUInt32Number              model;          // Device model number\n    cmsUInt64Number              attributes;     // Device attributes\n    cmsUInt32Number              renderingIntent;// Rendering intent\n    cmsEncodedXYZNumber          illuminant;     // Profile illuminant\n    cmsSignature                 creator;        // Profile creator\n    cmsProfileID                 profileID;      // Profile ID using MD5\n    cmsInt8Number                reserved[28];   // Reserved for future use\n\n} cmsICCHeader;",
          {
            "size": "cmsUInt32Number",
            "cmmId": "cmsSignature",
            "version": "cmsUInt32Number",
            "deviceClass": "cmsProfileClassSignature",
            "colorSpace": "cmsColorSpaceSignature",
            "pcs": "cmsColorSpaceSignature",
            "date": "cmsDateTimeNumber",
            "magic": "cmsSignature",
            "platform": "cmsPlatformSignature",
            "flags": "cmsUInt32Number",
            "manufacturer": "cmsSignature",
            "model": "cmsUInt32Number",
            "attributes": "cmsUInt64Number",
            "renderingIntent": "cmsUInt32Number",
            "illuminant": "cmsEncodedXYZNumber",
            "creator": "cmsSignature",
            "profileID": "cmsProfileID",
            "reserved[28]": "cmsInt8Number"
          },
          "cmsICCHeader",
          [
            625,
            0
          ],
          [
            645,
            15
          ]
        ],
        [
          "typedef struct {\n    cmsTagTypeSignature  sig;\n    cmsInt8Number        reserved[4];\n\n} cmsTagBase;",
          {
            "sig": "cmsTagTypeSignature",
            "reserved[4]": "cmsInt8Number"
          },
          "cmsTagBase",
          [
            648,
            0
          ],
          [
            652,
            13
          ]
        ],
        [
          "typedef struct {\n    cmsTagSignature      sig;            // The tag signature\n    cmsUInt32Number      offset;         // Start of tag\n    cmsUInt32Number      size;           // Size in bytes\n\n} cmsTagEntry;",
          {
            "sig": "cmsTagSignature",
            "offset": "cmsUInt32Number",
            "size": "cmsUInt32Number"
          },
          "cmsTagEntry",
          [
            655,
            0
          ],
          [
            660,
            14
          ]
        ],
        [
          "typedef struct {\n        cmsFloat64Number X;\n        cmsFloat64Number Y;\n        cmsFloat64Number Z;\n\n    } cmsCIEXYZ;",
          {
            "X": "cmsFloat64Number",
            "Y": "cmsFloat64Number",
            "Z": "cmsFloat64Number"
          },
          "cmsCIEXYZ",
          [
            971,
            0
          ],
          [
            976,
            16
          ]
        ],
        [
          "typedef struct {\n        cmsFloat64Number x;\n        cmsFloat64Number y;\n        cmsFloat64Number Y;\n\n    } cmsCIExyY;",
          {
            "x": "cmsFloat64Number",
            "y": "cmsFloat64Number",
            "Y": "cmsFloat64Number"
          },
          "cmsCIExyY",
          [
            978,
            0
          ],
          [
            983,
            16
          ]
        ],
        [
          "typedef struct {\n        cmsFloat64Number L;\n        cmsFloat64Number a;\n        cmsFloat64Number b;\n\n    } cmsCIELab;",
          {
            "L": "cmsFloat64Number",
            "a": "cmsFloat64Number",
            "b": "cmsFloat64Number"
          },
          "cmsCIELab",
          [
            985,
            0
          ],
          [
            990,
            16
          ]
        ],
        [
          "typedef struct {\n        cmsFloat64Number L;\n        cmsFloat64Number C;\n        cmsFloat64Number h;\n\n    } cmsCIELCh;",
          {
            "L": "cmsFloat64Number",
            "C": "cmsFloat64Number",
            "h": "cmsFloat64Number"
          },
          "cmsCIELCh",
          [
            992,
            0
          ],
          [
            997,
            16
          ]
        ],
        [
          "typedef struct {\n        cmsFloat64Number J;\n        cmsFloat64Number C;\n        cmsFloat64Number h;\n\n    } cmsJCh;",
          {
            "J": "cmsFloat64Number",
            "C": "cmsFloat64Number",
            "h": "cmsFloat64Number"
          },
          "cmsJCh",
          [
            999,
            0
          ],
          [
            1004,
            13
          ]
        ],
        [
          "typedef struct {\n        cmsCIEXYZ  Red;\n        cmsCIEXYZ  Green;\n        cmsCIEXYZ  Blue;\n\n    } cmsCIEXYZTRIPLE;",
          {
            "Red": "cmsCIEXYZ",
            "Green": "cmsCIEXYZ",
            "Blue": "cmsCIEXYZ"
          },
          "cmsCIEXYZTRIPLE",
          [
            1006,
            0
          ],
          [
            1011,
            22
          ]
        ],
        [
          "typedef struct {\n        cmsCIExyY  Red;\n        cmsCIExyY  Green;\n        cmsCIExyY  Blue;\n\n    } cmsCIExyYTRIPLE;",
          {
            "Red": "cmsCIExyY",
            "Green": "cmsCIExyY",
            "Blue": "cmsCIExyY"
          },
          "cmsCIExyYTRIPLE",
          [
            1013,
            0
          ],
          [
            1018,
            22
          ]
        ],
        [
          "typedef struct {\n        cmsUInt32Number  Observer;    // 0 = unknown, 1=CIE 1931, 2=CIE 1964\n        cmsCIEXYZ        Backing;     // Value of backing\n        cmsUInt32Number  Geometry;    // 0=unknown, 1=45/0, 0/45 2=0d, d/0\n        cmsFloat64Number Flare;       // 0..1.0\n        cmsUInt32Number  IlluminantType;\n\n    } cmsICCMeasurementConditions;",
          {
            "Observer": "cmsUInt32Number",
            "Backing": "cmsCIEXYZ",
            "Geometry": "cmsUInt32Number",
            "Flare": "cmsFloat64Number",
            "IlluminantType": "cmsUInt32Number"
          },
          "cmsICCMeasurementConditions",
          [
            1031,
            0
          ],
          [
            1038,
            34
          ]
        ],
        [
          "typedef struct {\n        cmsCIEXYZ       IlluminantXYZ;   // Not the same struct as CAM02,\n        cmsCIEXYZ       SurroundXYZ;     // This is for storing the tag\n        cmsUInt32Number IlluminantType;  // viewing condition\n\n    } cmsICCViewingConditions;",
          {
            "IlluminantXYZ": "cmsCIEXYZ",
            "SurroundXYZ": "cmsCIEXYZ",
            "IlluminantType": "cmsUInt32Number"
          },
          "cmsICCViewingConditions",
          [
            1040,
            0
          ],
          [
            1045,
            30
          ]
        ],
        [
          "typedef struct {\n    cmsUInt8Number  ColourPrimaries;            // Recommendation ITU-T H.273\n    cmsUInt8Number  TransferCharacteristics;    //  (ISO/IEC 23091-2)\n    cmsUInt8Number  MatrixCoefficients;\n    cmsUInt8Number  VideoFullRangeFlag;\n\n} cmsVideoSignalType;",
          {
            "ColourPrimaries": "cmsUInt8Number",
            "TransferCharacteristics": "cmsUInt8Number",
            "MatrixCoefficients": "cmsUInt8Number",
            "VideoFullRangeFlag": "cmsUInt8Number"
          },
          "cmsVideoSignalType",
          [
            1047,
            0
          ],
          [
            1053,
            21
          ]
        ],
        [
          "typedef struct {\n    cmsUInt32Number   CurveEntries;\n    cmsFloat64Number* RedCurve;\n    cmsFloat64Number* GreenCurve;\n    cmsFloat64Number* BlueCurve;\n\n    cmsFloat64Number  MinLuminance;         // ST.2086 min luminance in nits\n    cmsFloat64Number  PeakLuminance;        // ST.2086 peak luminance in nits\n\n    cmsFloat64Number XYZ2XYZmatrix[3][4];\n\n} cmsMHC2Type;",
          {
            "CurveEntries": "cmsUInt32Number",
            "* RedCurve": "cmsFloat64Number",
            "* GreenCurve": "cmsFloat64Number",
            "* BlueCurve": "cmsFloat64Number",
            "MinLuminance": "cmsFloat64Number",
            "PeakLuminance": "cmsFloat64Number",
            "XYZ2XYZmatrix[3][4]": "cmsFloat64Number"
          },
          "cmsMHC2Type",
          [
            1055,
            0
          ],
          [
            1066,
            14
          ]
        ],
        [
          "typedef struct _cmsContext_struct* cmsContext;",
          {},
          "cmsContext",
          [
            1085,
            0
          ],
          [
            1085,
            46
          ]
        ],
        [
          "typedef struct {\n    cmsCIEXYZ        whitePoint;\n    cmsFloat64Number Yb;\n    cmsFloat64Number La;\n    cmsUInt32Number  surround;\n    cmsFloat64Number D_value;\n\n    } cmsViewingConditions;",
          {
            "whitePoint": "cmsCIEXYZ",
            "Yb": "cmsFloat64Number",
            "La": "cmsFloat64Number",
            "surround": "cmsUInt32Number",
            "D_value": "cmsFloat64Number"
          },
          "cmsViewingConditions",
          [
            1188,
            0
          ],
          [
            1195,
            27
          ]
        ],
        [
          "typedef struct {\n    cmsFloat32Number   x0, x1;           // Domain; for x0 < x <= x1\n    cmsInt32Number     Type;             // Parametric type, Type == 0 means sampled segment. Negative values are reserved\n    cmsFloat64Number   Params[10];       // Parameters if Type != 0\n    cmsUInt32Number    nGridPoints;      // Number of grid points if Type == 0\n    cmsFloat32Number*  SampledPoints;    // Points to an array of floats if Type == 0\n\n} cmsCurveSegment;",
          {
            "x0": "cmsFloat32Number",
            "Type": "cmsInt32Number",
            "Params[10]": "cmsFloat64Number",
            "nGridPoints": "cmsUInt32Number",
            "*  SampledPoints": "cmsFloat32Number"
          },
          "cmsCurveSegment",
          [
            1208,
            0
          ],
          [
            1215,
            18
          ]
        ],
        [
          "typedef struct _cms_curve_struct cmsToneCurve;",
          {},
          "cmsToneCurve",
          [
            1218,
            0
          ],
          [
            1218,
            46
          ]
        ],
        [
          "typedef struct _cmsPipeline_struct cmsPipeline;",
          {},
          "cmsPipeline",
          [
            1251,
            0
          ],
          [
            1251,
            47
          ]
        ],
        [
          "typedef struct _cmsStage_struct cmsStage;",
          {},
          "cmsStage",
          [
            1252,
            0
          ],
          [
            1252,
            41
          ]
        ],
        [
          "typedef struct _cms_MLU_struct cmsMLU;",
          {},
          "cmsMLU",
          [
            1333,
            0
          ],
          [
            1333,
            38
          ]
        ],
        [
          "typedef struct {\n        cmsToneCurve* Ucr;\n        cmsToneCurve* Bg;\n        cmsMLU*       Desc;\n\n} cmsUcrBg;",
          {
            "* Ucr": "cmsToneCurve",
            "* Bg": "cmsToneCurve",
            "*       Desc": "cmsMLU"
          },
          "cmsUcrBg",
          [
            1380,
            0
          ],
          [
            1385,
            11
          ]
        ],
        [
          "typedef struct {\n    cmsFloat64Number  Frequency;\n    cmsFloat64Number  ScreenAngle;\n    cmsUInt32Number   SpotShape;\n\n} cmsScreeningChannel;",
          {
            "Frequency": "cmsFloat64Number",
            "ScreenAngle": "cmsFloat64Number",
            "SpotShape": "cmsUInt32Number"
          },
          "cmsScreeningChannel",
          [
            1402,
            0
          ],
          [
            1407,
            22
          ]
        ],
        [
          "typedef struct {\n    cmsUInt32Number Flag;\n    cmsUInt32Number nChannels;\n    cmsScreeningChannel Channels[cmsMAXCHANNELS];\n\n} cmsScreening;",
          {
            "Flag": "cmsUInt32Number",
            "nChannels": "cmsUInt32Number",
            "Channels[cmsMAXCHANNELS]": "cmsScreeningChannel"
          },
          "cmsScreening",
          [
            1409,
            0
          ],
          [
            1414,
            15
          ]
        ],
        [
          "typedef struct _cms_NAMEDCOLORLIST_struct cmsNAMEDCOLORLIST;",
          {},
          "cmsNAMEDCOLORLIST",
          [
            1419,
            0
          ],
          [
            1419,
            60
          ]
        ],
        [
          "typedef struct {\n\n    cmsSignature           deviceMfg;\n    cmsSignature           deviceModel;\n    cmsUInt64Number        attributes;\n    cmsTechnologySignature technology;\n    cmsProfileID           ProfileID;\n    cmsMLU*                Manufacturer;\n    cmsMLU*                Model;\n    cmsMLU*                Description;\n\n} cmsPSEQDESC;",
          {
            "deviceMfg": "cmsSignature",
            "deviceModel": "cmsSignature",
            "attributes": "cmsUInt64Number",
            "technology": "cmsTechnologySignature",
            "ProfileID": "cmsProfileID",
            "*                Manufacturer": "cmsMLU",
            "*                Model": "cmsMLU",
            "*                Description": "cmsMLU"
          },
          "cmsPSEQDESC",
          [
            1449,
            0
          ],
          [
            1460,
            14
          ]
        ],
        [
          "typedef struct {\n\n    cmsUInt32Number n;\n    cmsContext      ContextID;\n    cmsPSEQDESC*    seq;\n\n} cmsSEQ;",
          {
            "n": "cmsUInt32Number",
            "ContextID": "cmsContext",
            "*    seq": "cmsPSEQDESC"
          },
          "cmsSEQ",
          [
            1462,
            0
          ],
          [
            1468,
            9
          ]
        ],
        [
          "typedef struct _cmsDICTentry_struct {\n\n    struct _cmsDICTentry_struct* Next;\n\n    cmsMLU *DisplayName;\n    cmsMLU *DisplayValue;\n    wchar_t* Name;\n    wchar_t* Value;\n\n} cmsDICTentry;",
          {
            "* Next": "struct _cmsDICTentry_struct",
            "*DisplayName": "cmsMLU",
            "*DisplayValue": "cmsMLU",
            "* Name": "wchar_t",
            "* Value": "wchar_t"
          },
          "cmsDICTentry",
          [
            1476,
            0
          ],
          [
            1485,
            15
          ]
        ],
        [
          "struct _cmsDICTentry_struct",
          {},
          "",
          [
            1478,
            4
          ],
          [
            1478,
            31
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            1522,
            86
          ],
          [
            1522,
            95
          ]
        ],
        [
          "typedef struct _cms_io_handler cmsIOHANDLER;",
          {},
          "cmsIOHANDLER",
          [
            1596,
            0
          ],
          [
            1596,
            44
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            69,
            0
          ],
          [
            70,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            72,
            0
          ],
          [
            73,
            0
          ]
        ],
        [
          "#include <time.h>\n",
          [
            73,
            0
          ],
          [
            74,
            0
          ]
        ],
        [
          "#include <stddef.h>\n",
          [
            74,
            0
          ],
          [
            75,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n    cmsSigChromaticityType                  = 0x6368726D,  // 'chrm'\n    cmsSigcicpType                          = 0x63696370,  // 'cicp' \n    cmsSigColorantOrderType                 = 0x636C726F,  // 'clro'\n    cmsSigColorantTableType                 = 0x636C7274,  // 'clrt'\n    cmsSigCrdInfoType                       = 0x63726469,  // 'crdi'\n    cmsSigCurveType                         = 0x63757276,  // 'curv'\n    cmsSigDataType                          = 0x64617461,  // 'data'\n    cmsSigDictType                          = 0x64696374,  // 'dict'\n    cmsSigDateTimeType                      = 0x6474696D,  // 'dtim'\n    cmsSigDeviceSettingsType                = 0x64657673,  // 'devs'\n    cmsSigLut16Type                         = 0x6d667432,  // 'mft2'\n    cmsSigLut8Type                          = 0x6d667431,  // 'mft1'\n    cmsSigLutAtoBType                       = 0x6d414220,  // 'mAB '\n    cmsSigLutBtoAType                       = 0x6d424120,  // 'mBA '\n    cmsSigMeasurementType                   = 0x6D656173,  // 'meas'\n    cmsSigMultiLocalizedUnicodeType         = 0x6D6C7563,  // 'mluc'\n    cmsSigMultiProcessElementType           = 0x6D706574,  // 'mpet'\n    cmsSigNamedColorType                    = 0x6E636f6C,  // 'ncol' -- DEPRECATED!\n    cmsSigNamedColor2Type                   = 0x6E636C32,  // 'ncl2'\n    cmsSigParametricCurveType               = 0x70617261,  // 'para'\n    cmsSigProfileSequenceDescType           = 0x70736571,  // 'pseq'\n    cmsSigProfileSequenceIdType             = 0x70736964,  // 'psid'\n    cmsSigResponseCurveSet16Type            = 0x72637332,  // 'rcs2'\n    cmsSigS15Fixed16ArrayType               = 0x73663332,  // 'sf32'\n    cmsSigScreeningType                     = 0x7363726E,  // 'scrn'\n    cmsSigSignatureType                     = 0x73696720,  // 'sig '\n    cmsSigTextType                          = 0x74657874,  // 'text'\n    cmsSigTextDescriptionType               = 0x64657363,  // 'desc'\n    cmsSigU16Fixed16ArrayType               = 0x75663332,  // 'uf32'\n    cmsSigUcrBgType                         = 0x62666420,  // 'bfd '\n    cmsSigUInt16ArrayType                   = 0x75693136,  // 'ui16'\n    cmsSigUInt32ArrayType                   = 0x75693332,  // 'ui32'\n    cmsSigUInt64ArrayType                   = 0x75693634,  // 'ui64'\n    cmsSigUInt8ArrayType                    = 0x75693038,  // 'ui08'\n    cmsSigVcgtType                          = 0x76636774,  // 'vcgt'\n    cmsSigViewingConditionsType             = 0x76696577,  // 'view'\n    cmsSigXYZType                           = 0x58595A20,  // 'XYZ '\n    cmsSigMHC2Type                          = 0x4D484332   // 'MHC2'\n\n\n} cmsTagTypeSignature;",
          {
            "cmsSigChromaticityType": "",
            "cmsSigcicpType": "",
            "cmsSigColorantOrderType": "",
            "cmsSigColorantTableType": "",
            "cmsSigCrdInfoType": "",
            "cmsSigCurveType": "",
            "cmsSigDataType": "",
            "cmsSigDictType": "",
            "cmsSigDateTimeType": "",
            "cmsSigDeviceSettingsType": "",
            "cmsSigLut16Type": "",
            "cmsSigLut8Type": "",
            "cmsSigLutAtoBType": "",
            "cmsSigLutBtoAType": "",
            "cmsSigMeasurementType": "",
            "cmsSigMultiLocalizedUnicodeType": "",
            "cmsSigMultiProcessElementType": "",
            "cmsSigNamedColorType": "",
            "cmsSigNamedColor2Type": "",
            "cmsSigParametricCurveType": "",
            "cmsSigProfileSequenceDescType": "",
            "cmsSigProfileSequenceIdType": "",
            "cmsSigResponseCurveSet16Type": "",
            "cmsSigS15Fixed16ArrayType": "",
            "cmsSigScreeningType": "",
            "cmsSigSignatureType": "",
            "cmsSigTextType": "",
            "cmsSigTextDescriptionType": "",
            "cmsSigU16Fixed16ArrayType": "",
            "cmsSigUcrBgType": "",
            "cmsSigUInt16ArrayType": "",
            "cmsSigUInt32ArrayType": "",
            "cmsSigUInt64ArrayType": "",
            "cmsSigUInt8ArrayType": "",
            "cmsSigVcgtType": "",
            "cmsSigViewingConditionsType": "",
            "cmsSigXYZType": "",
            "cmsSigMHC2Type": ""
          },
          "cmsTagTypeSignature",
          [
            293,
            0
          ],
          [
            334,
            22
          ]
        ],
        [
          "typedef enum {\n    cmsSigAToB0Tag                          = 0x41324230,  // 'A2B0'\n    cmsSigAToB1Tag                          = 0x41324231,  // 'A2B1'\n    cmsSigAToB2Tag                          = 0x41324232,  // 'A2B2'\n    cmsSigBlueColorantTag                   = 0x6258595A,  // 'bXYZ'\n    cmsSigBlueMatrixColumnTag               = 0x6258595A,  // 'bXYZ'\n    cmsSigBlueTRCTag                        = 0x62545243,  // 'bTRC'\n    cmsSigBToA0Tag                          = 0x42324130,  // 'B2A0'\n    cmsSigBToA1Tag                          = 0x42324131,  // 'B2A1'\n    cmsSigBToA2Tag                          = 0x42324132,  // 'B2A2'\n    cmsSigCalibrationDateTimeTag            = 0x63616C74,  // 'calt'\n    cmsSigCharTargetTag                     = 0x74617267,  // 'targ'\n    cmsSigChromaticAdaptationTag            = 0x63686164,  // 'chad'\n    cmsSigChromaticityTag                   = 0x6368726D,  // 'chrm'\n    cmsSigColorantOrderTag                  = 0x636C726F,  // 'clro'\n    cmsSigColorantTableTag                  = 0x636C7274,  // 'clrt'\n    cmsSigColorantTableOutTag               = 0x636C6F74,  // 'clot'\n    cmsSigColorimetricIntentImageStateTag   = 0x63696973,  // 'ciis'\n    cmsSigCopyrightTag                      = 0x63707274,  // 'cprt'\n    cmsSigCrdInfoTag                        = 0x63726469,  // 'crdi'\n    cmsSigDataTag                           = 0x64617461,  // 'data'\n    cmsSigDateTimeTag                       = 0x6474696D,  // 'dtim'\n    cmsSigDeviceMfgDescTag                  = 0x646D6E64,  // 'dmnd'\n    cmsSigDeviceModelDescTag                = 0x646D6464,  // 'dmdd'\n    cmsSigDeviceSettingsTag                 = 0x64657673,  // 'devs'\n    cmsSigDToB0Tag                          = 0x44324230,  // 'D2B0'\n    cmsSigDToB1Tag                          = 0x44324231,  // 'D2B1'\n    cmsSigDToB2Tag                          = 0x44324232,  // 'D2B2'\n    cmsSigDToB3Tag                          = 0x44324233,  // 'D2B3'\n    cmsSigBToD0Tag                          = 0x42324430,  // 'B2D0'\n    cmsSigBToD1Tag                          = 0x42324431,  // 'B2D1'\n    cmsSigBToD2Tag                          = 0x42324432,  // 'B2D2'\n    cmsSigBToD3Tag                          = 0x42324433,  // 'B2D3'\n    cmsSigGamutTag                          = 0x67616D74,  // 'gamt'\n    cmsSigGrayTRCTag                        = 0x6b545243,  // 'kTRC'\n    cmsSigGreenColorantTag                  = 0x6758595A,  // 'gXYZ'\n    cmsSigGreenMatrixColumnTag              = 0x6758595A,  // 'gXYZ'\n    cmsSigGreenTRCTag                       = 0x67545243,  // 'gTRC'\n    cmsSigLuminanceTag                      = 0x6C756d69,  // 'lumi'\n    cmsSigMeasurementTag                    = 0x6D656173,  // 'meas'\n    cmsSigMediaBlackPointTag                = 0x626B7074,  // 'bkpt'\n    cmsSigMediaWhitePointTag                = 0x77747074,  // 'wtpt'\n    cmsSigNamedColorTag                     = 0x6E636f6C,  // 'ncol' // Deprecated by the ICC\n    cmsSigNamedColor2Tag                    = 0x6E636C32,  // 'ncl2'\n    cmsSigOutputResponseTag                 = 0x72657370,  // 'resp'\n    cmsSigPerceptualRenderingIntentGamutTag = 0x72696730,  // 'rig0'\n    cmsSigPreview0Tag                       = 0x70726530,  // 'pre0'\n    cmsSigPreview1Tag                       = 0x70726531,  // 'pre1'\n    cmsSigPreview2Tag                       = 0x70726532,  // 'pre2'\n    cmsSigProfileDescriptionTag             = 0x64657363,  // 'desc'\n    cmsSigProfileDescriptionMLTag           = 0x6473636d,  // 'dscm'\n    cmsSigProfileSequenceDescTag            = 0x70736571,  // 'pseq'\n    cmsSigProfileSequenceIdTag              = 0x70736964,  // 'psid'\n    cmsSigPs2CRD0Tag                        = 0x70736430,  // 'psd0'\n    cmsSigPs2CRD1Tag                        = 0x70736431,  // 'psd1'\n    cmsSigPs2CRD2Tag                        = 0x70736432,  // 'psd2'\n    cmsSigPs2CRD3Tag                        = 0x70736433,  // 'psd3'\n    cmsSigPs2CSATag                         = 0x70733273,  // 'ps2s'\n    cmsSigPs2RenderingIntentTag             = 0x70733269,  // 'ps2i'\n    cmsSigRedColorantTag                    = 0x7258595A,  // 'rXYZ'\n    cmsSigRedMatrixColumnTag                = 0x7258595A,  // 'rXYZ'\n    cmsSigRedTRCTag                         = 0x72545243,  // 'rTRC'\n    cmsSigSaturationRenderingIntentGamutTag = 0x72696732,  // 'rig2'\n    cmsSigScreeningDescTag                  = 0x73637264,  // 'scrd'\n    cmsSigScreeningTag                      = 0x7363726E,  // 'scrn'\n    cmsSigTechnologyTag                     = 0x74656368,  // 'tech'\n    cmsSigUcrBgTag                          = 0x62666420,  // 'bfd '\n    cmsSigViewingCondDescTag                = 0x76756564,  // 'vued'\n    cmsSigViewingConditionsTag              = 0x76696577,  // 'view'\n    cmsSigVcgtTag                           = 0x76636774,  // 'vcgt'\n    cmsSigMetaTag                           = 0x6D657461,  // 'meta'\n    cmsSigcicpTag                           = 0x63696370,  // 'cicp'\n    cmsSigArgyllArtsTag                     = 0x61727473,  // 'arts'\n    cmsSigMHC2Tag                           = 0x4D484332   // 'MHC2'\n\n} cmsTagSignature;",
          {
            "cmsSigAToB0Tag": "",
            "cmsSigAToB1Tag": "",
            "cmsSigAToB2Tag": "",
            "cmsSigBlueColorantTag": "",
            "cmsSigBlueMatrixColumnTag": "",
            "cmsSigBlueTRCTag": "",
            "cmsSigBToA0Tag": "",
            "cmsSigBToA1Tag": "",
            "cmsSigBToA2Tag": "",
            "cmsSigCalibrationDateTimeTag": "",
            "cmsSigCharTargetTag": "",
            "cmsSigChromaticAdaptationTag": "",
            "cmsSigChromaticityTag": "",
            "cmsSigColorantOrderTag": "",
            "cmsSigColorantTableTag": "",
            "cmsSigColorantTableOutTag": "",
            "cmsSigColorimetricIntentImageStateTag": "",
            "cmsSigCopyrightTag": "",
            "cmsSigCrdInfoTag": "",
            "cmsSigDataTag": "",
            "cmsSigDateTimeTag": "",
            "cmsSigDeviceMfgDescTag": "",
            "cmsSigDeviceModelDescTag": "",
            "cmsSigDeviceSettingsTag": "",
            "cmsSigDToB0Tag": "",
            "cmsSigDToB1Tag": "",
            "cmsSigDToB2Tag": "",
            "cmsSigDToB3Tag": "",
            "cmsSigBToD0Tag": "",
            "cmsSigBToD1Tag": "",
            "cmsSigBToD2Tag": "",
            "cmsSigBToD3Tag": "",
            "cmsSigGamutTag": "",
            "cmsSigGrayTRCTag": "",
            "cmsSigGreenColorantTag": "",
            "cmsSigGreenMatrixColumnTag": "",
            "cmsSigGreenTRCTag": "",
            "cmsSigLuminanceTag": "",
            "cmsSigMeasurementTag": "",
            "cmsSigMediaBlackPointTag": "",
            "cmsSigMediaWhitePointTag": "",
            "cmsSigNamedColorTag": "",
            "cmsSigNamedColor2Tag": "",
            "cmsSigOutputResponseTag": "",
            "cmsSigPerceptualRenderingIntentGamutTag": "",
            "cmsSigPreview0Tag": "",
            "cmsSigPreview1Tag": "",
            "cmsSigPreview2Tag": "",
            "cmsSigProfileDescriptionTag": "",
            "cmsSigProfileDescriptionMLTag": "",
            "cmsSigProfileSequenceDescTag": "",
            "cmsSigProfileSequenceIdTag": "",
            "cmsSigPs2CRD0Tag": "",
            "cmsSigPs2CRD1Tag": "",
            "cmsSigPs2CRD2Tag": "",
            "cmsSigPs2CRD3Tag": "",
            "cmsSigPs2CSATag": "",
            "cmsSigPs2RenderingIntentTag": "",
            "cmsSigRedColorantTag": "",
            "cmsSigRedMatrixColumnTag": "",
            "cmsSigRedTRCTag": "",
            "cmsSigSaturationRenderingIntentGamutTag": "",
            "cmsSigScreeningDescTag": "",
            "cmsSigScreeningTag": "",
            "cmsSigTechnologyTag": "",
            "cmsSigUcrBgTag": "",
            "cmsSigViewingCondDescTag": "",
            "cmsSigViewingConditionsTag": "",
            "cmsSigVcgtTag": "",
            "cmsSigMetaTag": "",
            "cmsSigcicpTag": "",
            "cmsSigArgyllArtsTag": "",
            "cmsSigMHC2Tag": ""
          },
          "cmsTagSignature",
          [
            337,
            0
          ],
          [
            412,
            18
          ]
        ],
        [
          "typedef enum {\n    cmsSigDigitalCamera                     = 0x6463616D,  // 'dcam'\n    cmsSigFilmScanner                       = 0x6673636E,  // 'fscn'\n    cmsSigReflectiveScanner                 = 0x7273636E,  // 'rscn'\n    cmsSigInkJetPrinter                     = 0x696A6574,  // 'ijet'\n    cmsSigThermalWaxPrinter                 = 0x74776178,  // 'twax'\n    cmsSigElectrophotographicPrinter        = 0x6570686F,  // 'epho'\n    cmsSigElectrostaticPrinter              = 0x65737461,  // 'esta'\n    cmsSigDyeSublimationPrinter             = 0x64737562,  // 'dsub'\n    cmsSigPhotographicPaperPrinter          = 0x7270686F,  // 'rpho'\n    cmsSigFilmWriter                        = 0x6670726E,  // 'fprn'\n    cmsSigVideoMonitor                      = 0x7669646D,  // 'vidm'\n    cmsSigVideoCamera                       = 0x76696463,  // 'vidc'\n    cmsSigProjectionTelevision              = 0x706A7476,  // 'pjtv'\n    cmsSigCRTDisplay                        = 0x43525420,  // 'CRT '\n    cmsSigPMDisplay                         = 0x504D4420,  // 'PMD '\n    cmsSigAMDisplay                         = 0x414D4420,  // 'AMD '\n    cmsSigPhotoCD                           = 0x4B504344,  // 'KPCD'\n    cmsSigPhotoImageSetter                  = 0x696D6773,  // 'imgs'\n    cmsSigGravure                           = 0x67726176,  // 'grav'\n    cmsSigOffsetLithography                 = 0x6F666673,  // 'offs'\n    cmsSigSilkscreen                        = 0x73696C6B,  // 'silk'\n    cmsSigFlexography                       = 0x666C6578,  // 'flex'\n    cmsSigMotionPictureFilmScanner          = 0x6D706673,  // 'mpfs'\n    cmsSigMotionPictureFilmRecorder         = 0x6D706672,  // 'mpfr'\n    cmsSigDigitalMotionPictureCamera        = 0x646D7063,  // 'dmpc'\n    cmsSigDigitalCinemaProjector            = 0x64636A70   // 'dcpj'\n\n} cmsTechnologySignature;",
          {
            "cmsSigDigitalCamera": "",
            "cmsSigFilmScanner": "",
            "cmsSigReflectiveScanner": "",
            "cmsSigInkJetPrinter": "",
            "cmsSigThermalWaxPrinter": "",
            "cmsSigElectrophotographicPrinter": "",
            "cmsSigElectrostaticPrinter": "",
            "cmsSigDyeSublimationPrinter": "",
            "cmsSigPhotographicPaperPrinter": "",
            "cmsSigFilmWriter": "",
            "cmsSigVideoMonitor": "",
            "cmsSigVideoCamera": "",
            "cmsSigProjectionTelevision": "",
            "cmsSigCRTDisplay": "",
            "cmsSigPMDisplay": "",
            "cmsSigAMDisplay": "",
            "cmsSigPhotoCD": "",
            "cmsSigPhotoImageSetter": "",
            "cmsSigGravure": "",
            "cmsSigOffsetLithography": "",
            "cmsSigSilkscreen": "",
            "cmsSigFlexography": "",
            "cmsSigMotionPictureFilmScanner": "",
            "cmsSigMotionPictureFilmRecorder": "",
            "cmsSigDigitalMotionPictureCamera": "",
            "cmsSigDigitalCinemaProjector": ""
          },
          "cmsTechnologySignature",
          [
            416,
            0
          ],
          [
            444,
            25
          ]
        ],
        [
          "typedef enum {\n    cmsSigXYZData                           = 0x58595A20,  // 'XYZ '\n    cmsSigLabData                           = 0x4C616220,  // 'Lab '\n    cmsSigLuvData                           = 0x4C757620,  // 'Luv '\n    cmsSigYCbCrData                         = 0x59436272,  // 'YCbr'\n    cmsSigYxyData                           = 0x59787920,  // 'Yxy '\n    cmsSigRgbData                           = 0x52474220,  // 'RGB '\n    cmsSigGrayData                          = 0x47524159,  // 'GRAY'\n    cmsSigHsvData                           = 0x48535620,  // 'HSV '\n    cmsSigHlsData                           = 0x484C5320,  // 'HLS '\n    cmsSigCmykData                          = 0x434D594B,  // 'CMYK'\n    cmsSigCmyData                           = 0x434D5920,  // 'CMY '\n    cmsSigMCH1Data                          = 0x4D434831,  // 'MCH1'\n    cmsSigMCH2Data                          = 0x4D434832,  // 'MCH2'\n    cmsSigMCH3Data                          = 0x4D434833,  // 'MCH3'\n    cmsSigMCH4Data                          = 0x4D434834,  // 'MCH4'\n    cmsSigMCH5Data                          = 0x4D434835,  // 'MCH5'\n    cmsSigMCH6Data                          = 0x4D434836,  // 'MCH6'\n    cmsSigMCH7Data                          = 0x4D434837,  // 'MCH7'\n    cmsSigMCH8Data                          = 0x4D434838,  // 'MCH8'\n    cmsSigMCH9Data                          = 0x4D434839,  // 'MCH9'\n    cmsSigMCHAData                          = 0x4D434841,  // 'MCHA'\n    cmsSigMCHBData                          = 0x4D434842,  // 'MCHB'\n    cmsSigMCHCData                          = 0x4D434843,  // 'MCHC'\n    cmsSigMCHDData                          = 0x4D434844,  // 'MCHD'\n    cmsSigMCHEData                          = 0x4D434845,  // 'MCHE'\n    cmsSigMCHFData                          = 0x4D434846,  // 'MCHF'\n    cmsSigNamedData                         = 0x6e6d636c,  // 'nmcl'\n    cmsSig1colorData                        = 0x31434C52,  // '1CLR'\n    cmsSig2colorData                        = 0x32434C52,  // '2CLR'\n    cmsSig3colorData                        = 0x33434C52,  // '3CLR'\n    cmsSig4colorData                        = 0x34434C52,  // '4CLR'\n    cmsSig5colorData                        = 0x35434C52,  // '5CLR'\n    cmsSig6colorData                        = 0x36434C52,  // '6CLR'\n    cmsSig7colorData                        = 0x37434C52,  // '7CLR'\n    cmsSig8colorData                        = 0x38434C52,  // '8CLR'\n    cmsSig9colorData                        = 0x39434C52,  // '9CLR'\n    cmsSig10colorData                       = 0x41434C52,  // 'ACLR'\n    cmsSig11colorData                       = 0x42434C52,  // 'BCLR'\n    cmsSig12colorData                       = 0x43434C52,  // 'CCLR'\n    cmsSig13colorData                       = 0x44434C52,  // 'DCLR'\n    cmsSig14colorData                       = 0x45434C52,  // 'ECLR'\n    cmsSig15colorData                       = 0x46434C52,  // 'FCLR'\n    cmsSigLuvKData                          = 0x4C75764B   // 'LuvK'\n\n} cmsColorSpaceSignature;",
          {
            "cmsSigXYZData": "",
            "cmsSigLabData": "",
            "cmsSigLuvData": "",
            "cmsSigYCbCrData": "",
            "cmsSigYxyData": "",
            "cmsSigRgbData": "",
            "cmsSigGrayData": "",
            "cmsSigHsvData": "",
            "cmsSigHlsData": "",
            "cmsSigCmykData": "",
            "cmsSigCmyData": "",
            "cmsSigMCH1Data": "",
            "cmsSigMCH2Data": "",
            "cmsSigMCH3Data": "",
            "cmsSigMCH4Data": "",
            "cmsSigMCH5Data": "",
            "cmsSigMCH6Data": "",
            "cmsSigMCH7Data": "",
            "cmsSigMCH8Data": "",
            "cmsSigMCH9Data": "",
            "cmsSigMCHAData": "",
            "cmsSigMCHBData": "",
            "cmsSigMCHCData": "",
            "cmsSigMCHDData": "",
            "cmsSigMCHEData": "",
            "cmsSigMCHFData": "",
            "cmsSigNamedData": "",
            "cmsSig1colorData": "",
            "cmsSig2colorData": "",
            "cmsSig3colorData": "",
            "cmsSig4colorData": "",
            "cmsSig5colorData": "",
            "cmsSig6colorData": "",
            "cmsSig7colorData": "",
            "cmsSig8colorData": "",
            "cmsSig9colorData": "",
            "cmsSig10colorData": "",
            "cmsSig11colorData": "",
            "cmsSig12colorData": "",
            "cmsSig13colorData": "",
            "cmsSig14colorData": "",
            "cmsSig15colorData": "",
            "cmsSigLuvKData": ""
          },
          "cmsColorSpaceSignature",
          [
            448,
            0
          ],
          [
            493,
            25
          ]
        ],
        [
          "typedef enum {\n    cmsSigInputClass                        = 0x73636E72,  // 'scnr'\n    cmsSigDisplayClass                      = 0x6D6E7472,  // 'mntr'\n    cmsSigOutputClass                       = 0x70727472,  // 'prtr'\n    cmsSigLinkClass                         = 0x6C696E6B,  // 'link'\n    cmsSigAbstractClass                     = 0x61627374,  // 'abst'\n    cmsSigColorSpaceClass                   = 0x73706163,  // 'spac'\n    cmsSigNamedColorClass                   = 0x6e6d636c   // 'nmcl'\n\n} cmsProfileClassSignature;",
          {
            "cmsSigInputClass": "",
            "cmsSigDisplayClass": "",
            "cmsSigOutputClass": "",
            "cmsSigLinkClass": "",
            "cmsSigAbstractClass": "",
            "cmsSigColorSpaceClass": "",
            "cmsSigNamedColorClass": ""
          },
          "cmsProfileClassSignature",
          [
            496,
            0
          ],
          [
            505,
            27
          ]
        ],
        [
          "typedef enum {\n    cmsSigMacintosh                         = 0x4150504C,  // 'APPL'\n    cmsSigMicrosoft                         = 0x4D534654,  // 'MSFT'\n    cmsSigSolaris                           = 0x53554E57,  // 'SUNW'\n    cmsSigSGI                               = 0x53474920,  // 'SGI '\n    cmsSigTaligent                          = 0x54474E54,  // 'TGNT'\n    cmsSigUnices                            = 0x2A6E6978   // '*nix'   // From argyll -- Not official\n\n} cmsPlatformSignature;",
          {
            "cmsSigMacintosh": "",
            "cmsSigMicrosoft": "",
            "cmsSigSolaris": "",
            "cmsSigSGI": "",
            "cmsSigTaligent": "",
            "cmsSigUnices": ""
          },
          "cmsPlatformSignature",
          [
            508,
            0
          ],
          [
            516,
            23
          ]
        ],
        [
          "typedef enum {\n    cmsSigCurveSetElemType              = 0x63767374,  //'cvst'\n    cmsSigMatrixElemType                = 0x6D617466,  //'matf'\n    cmsSigCLutElemType                  = 0x636C7574,  //'clut'\n\n    cmsSigBAcsElemType                  = 0x62414353,  // 'bACS'\n    cmsSigEAcsElemType                  = 0x65414353,  // 'eACS'\n\n    // Custom from here, not in the ICC Spec\n    cmsSigXYZ2LabElemType               = 0x6C327820,  // 'l2x '\n    cmsSigLab2XYZElemType               = 0x78326C20,  // 'x2l '\n    cmsSigNamedColorElemType            = 0x6E636C20,  // 'ncl '\n    cmsSigLabV2toV4                     = 0x32203420,  // '2 4 '\n    cmsSigLabV4toV2                     = 0x34203220,  // '4 2 '\n  \n    // Identities\n    cmsSigIdentityElemType              = 0x69646E20,  // 'idn '\n\n    // Float to floatPCS\n    cmsSigLab2FloatPCS                  = 0x64326C20,  // 'd2l '\n    cmsSigFloatPCS2Lab                  = 0x6C326420,  // 'l2d '\n    cmsSigXYZ2FloatPCS                  = 0x64327820,  // 'd2x '\n    cmsSigFloatPCS2XYZ                  = 0x78326420,  // 'x2d '  \n    cmsSigClipNegativesElemType         = 0x636c7020   // 'clp '\n\n} cmsStageSignature;",
          {
            "cmsSigCurveSetElemType": "",
            "cmsSigMatrixElemType": "",
            "cmsSigCLutElemType": "",
            "cmsSigBAcsElemType": "",
            "cmsSigEAcsElemType": "",
            "cmsSigXYZ2LabElemType": "",
            "cmsSigLab2XYZElemType": "",
            "cmsSigNamedColorElemType": "",
            "cmsSigLabV2toV4": "",
            "cmsSigLabV4toV2": "",
            "cmsSigIdentityElemType": "",
            "cmsSigLab2FloatPCS": "",
            "cmsSigFloatPCS2Lab": "",
            "cmsSigXYZ2FloatPCS": "",
            "cmsSigFloatPCS2XYZ": "",
            "cmsSigClipNegativesElemType": ""
          },
          "cmsStageSignature",
          [
            529,
            0
          ],
          [
            554,
            20
          ]
        ],
        [
          "typedef enum {\n\n    cmsSigFormulaCurveSeg               = 0x70617266, // 'parf'\n    cmsSigSampledCurveSeg               = 0x73616D66, // 'samf'\n    cmsSigSegmentedCurve                = 0x63757266  // 'curf'\n\n} cmsCurveSegSignature;",
          {
            "cmsSigFormulaCurveSeg": "",
            "cmsSigSampledCurveSeg": "",
            "cmsSigSegmentedCurve": ""
          },
          "cmsCurveSegSignature",
          [
            557,
            0
          ],
          [
            563,
            23
          ]
        ],
        [
          "typedef enum { cmsAT_BEGIN, cmsAT_END } cmsStageLoc;",
          {
            "cmsAT_BEGIN": "",
            "cmsAT_END": ""
          },
          "cmsStageLoc",
          [
            1274,
            0
          ],
          [
            1274,
            52
          ]
        ],
        [
          "typedef enum {\n             cmsInfoDescription  = 0,\n             cmsInfoManufacturer = 1,\n             cmsInfoModel        = 2,\n             cmsInfoCopyright    = 3\n} cmsInfoType;",
          {
            "cmsInfoDescription": "",
            "cmsInfoManufacturer": "",
            "cmsInfoModel": "",
            "cmsInfoCopyright": ""
          },
          "cmsInfoType",
          [
            1575,
            0
          ],
          [
            1580,
            14
          ]
        ],
        [
          "typedef enum { cmsPS_RESOURCE_CSA, cmsPS_RESOURCE_CRD } cmsPSResourceType;",
          {
            "cmsPS_RESOURCE_CSA": "",
            "cmsPS_RESOURCE_CRD": ""
          },
          "cmsPSResourceType",
          [
            1875,
            0
          ],
          [
            1875,
            74
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/Projects/VC2019/resource.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/Projects/VC2017/resource.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/Projects/VC2022/resource.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/utils/common/utils.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "InitUtils(const char* PName)",
          "fn_dec_pos": [
            [
              57,
              5
            ],
            [
              57,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "InitUtils",
            "parameters": {
              "PName": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "FatalError(const char *frm, ...)",
          "fn_dec_pos": [
            [
              63,
              5
            ],
            [
              63,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FatalError",
            "parameters": {
              "frm": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "xgetopt(int argc, char *argv[], char *optionS)",
          "fn_dec_pos": [
            [
              70,
              4
            ],
            [
              70,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "xgetopt",
            "parameters": {
              "argc": "int",
              "argv": "char",
              "optionS": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OpenStockProfile(cmsContext ContextID, const char* File)",
          "fn_dec_pos": [
            [
              74,
              12
            ],
            [
              74,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OpenStockProfile",
            "parameters": {
              "ContextID": "cmsContext",
              "File": "char"
            },
            "return_type": "cmsHPROFILE"
          }
        },
        {
          "fn_code": "PrintProfileInformation(cmsHPROFILE h)",
          "fn_dec_pos": [
            [
              78,
              5
            ],
            [
              78,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintProfileInformation",
            "parameters": {
              "h": "cmsHPROFILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "PrintRenderingIntents(void)",
          "fn_dec_pos": [
            [
              82,
              5
            ],
            [
              82,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintRenderingIntents",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PrintBuiltins(void)",
          "fn_dec_pos": [
            [
              83,
              5
            ],
            [
              83,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintBuiltins",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "SaveMemoryBlock(const cmsUInt8Number* Buffer, cmsUInt32Number dwLen, const char* Filename)",
          "fn_dec_pos": [
            [
              87,
              8
            ],
            [
              87,
              98
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SaveMemoryBlock",
            "parameters": {
              "Buffer": "cmsUInt8Number",
              "dwLen": "cmsUInt32Number",
              "Filename": "char"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "PixelTypeFromChanCount(int ColorChannels)",
          "fn_dec_pos": [
            [
              92,
              4
            ],
            [
              92,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixelTypeFromChanCount",
            "parameters": {
              "ColorChannels": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ChanCountFromPixelType(int ColorChannels)",
          "fn_dec_pos": [
            [
              97,
              4
            ],
            [
              97,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ChanCountFromPixelType",
            "parameters": {
              "ColorChannels": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"lcms2.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <wchar.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/utils/jpgicc/iccjpeg.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\t\t/* needed to define \"FILE\", \"NULL\" */\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"jpeglib.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/src/lcms2_internal.h": {
      "fn_def_list": [
        {
          "fn_code": "cmsINLINE cmsS15Fixed16Number _cmsToFixedDomain(int a)                   { return a + ((a + 0x7fff) / 0xffff); }",
          "fn_code_pos": [
            [
              150,
              0
            ],
            [
              150,
              112
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsS15Fixed16Number _cmsToFixedDomain",
            "parameters": {
              "a": "int"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int                 _cmsFromFixedDomain(cmsS15Fixed16Number a) { return a - ((a + 0x7fff) >> 16); }",
          "fn_code_pos": [
            [
              151,
              0
            ],
            [
              151,
              109
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsFromFixedDomain",
            "parameters": {
              "a": "cmsS15Fixed16Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsQuickFloor(cmsFloat64Number val)\n{\n#ifdef CMS_DONT_USE_FAST_FLOOR\n    return (int) floor(val);\n#else\n    const cmsFloat64Number _lcms_double2fixmagic = 68719476736.0 * 1.5;  // 2^36 * 1.5, (52-16=36) uses limited precision to floor\n    union {\n        cmsFloat64Number val;\n        int halves[2];\n    } temp;\n\n    temp.val = val + _lcms_double2fixmagic;\n\n#ifdef CMS_USE_BIG_ENDIAN\n    return temp.halves[1] >> 16;\n#else\n    return temp.halves[0] >> 16;\n#endif\n#endif\n}",
          "fn_code_pos": [
            [
              159,
              0
            ],
            [
              178,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsQuickFloor",
            "parameters": {
              "val": "cmsFloat64Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE cmsUInt16Number _cmsQuickFloorWord(cmsFloat64Number d)\n{\n    return (cmsUInt16Number) _cmsQuickFloor(d - 32767.0) + 32767U;\n}",
          "fn_code_pos": [
            [
              181,
              0
            ],
            [
              184,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsUInt16Number _cmsQuickFloorWord",
            "parameters": {
              "d": "cmsFloat64Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE cmsUInt16Number _cmsQuickSaturateWord(cmsFloat64Number d)\n{\n    d += 0.5;\n    if (d <= 0) return 0;\n    if (d >= 65535.0) return 0xffff;\n\n    return _cmsQuickFloorWord(d);\n}",
          "fn_code_pos": [
            [
              187,
              0
            ],
            [
              194,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmsUInt16Number _cmsQuickSaturateWord",
            "parameters": {
              "d": "cmsFloat64Number"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsLockPrimitive(_cmsMutex *m)\n{\n    EnterCriticalSection(m);\n    return 0;\n}",
          "fn_code_pos": [
            [
              284,
              0
            ],
            [
              288,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsLockPrimitive",
            "parameters": {
              "m": "_cmsMutex"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsUnlockPrimitive(_cmsMutex *m)\n{\n    LeaveCriticalSection(m);\n    return 0;\n}",
          "fn_code_pos": [
            [
              290,
              0
            ],
            [
              294,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsUnlockPrimitive",
            "parameters": {
              "m": "_cmsMutex"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsInitMutexPrimitive(_cmsMutex *m)\n{\n    InitializeCriticalSection(m);\n    return 0;\n}",
          "fn_code_pos": [
            [
              296,
              0
            ],
            [
              300,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsInitMutexPrimitive",
            "parameters": {
              "m": "_cmsMutex"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsDestroyMutexPrimitive(_cmsMutex *m)\n{\n    DeleteCriticalSection(m);\n    return 0;\n}",
          "fn_code_pos": [
            [
              302,
              0
            ],
            [
              306,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsDestroyMutexPrimitive",
            "parameters": {
              "m": "_cmsMutex"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsEnterCriticalSectionPrimitive(_cmsMutex *m)\n{\n    EnterCriticalSection(m);\n    return 0;\n}",
          "fn_code_pos": [
            [
              308,
              0
            ],
            [
              312,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsEnterCriticalSectionPrimitive",
            "parameters": {
              "m": "_cmsMutex"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsLeaveCriticalSectionPrimitive(_cmsMutex *m)\n{\n    LeaveCriticalSection(m);\n    return 0;\n}",
          "fn_code_pos": [
            [
              314,
              0
            ],
            [
              318,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsLeaveCriticalSectionPrimitive",
            "parameters": {
              "m": "_cmsMutex"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsLockPrimitive(_cmsMutex *m)\n{\n    return pthread_mutex_lock(m);\n}",
          "fn_code_pos": [
            [
              329,
              0
            ],
            [
              332,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsLockPrimitive",
            "parameters": {
              "m": "_cmsMutex"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsUnlockPrimitive(_cmsMutex *m)\n{\n    return pthread_mutex_unlock(m);\n}",
          "fn_code_pos": [
            [
              334,
              0
            ],
            [
              337,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsUnlockPrimitive",
            "parameters": {
              "m": "_cmsMutex"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsInitMutexPrimitive(_cmsMutex *m)\n{\n    return pthread_mutex_init(m, NULL);\n}",
          "fn_code_pos": [
            [
              339,
              0
            ],
            [
              342,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsInitMutexPrimitive",
            "parameters": {
              "m": "_cmsMutex"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsDestroyMutexPrimitive(_cmsMutex *m)\n{\n    return pthread_mutex_destroy(m);\n}",
          "fn_code_pos": [
            [
              344,
              0
            ],
            [
              347,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsDestroyMutexPrimitive",
            "parameters": {
              "m": "_cmsMutex"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsEnterCriticalSectionPrimitive(_cmsMutex *m)\n{\n    return pthread_mutex_lock(m);\n}",
          "fn_code_pos": [
            [
              349,
              0
            ],
            [
              352,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsEnterCriticalSectionPrimitive",
            "parameters": {
              "m": "_cmsMutex"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsLeaveCriticalSectionPrimitive(_cmsMutex *m)\n{\n    return pthread_mutex_unlock(m);\n}",
          "fn_code_pos": [
            [
              354,
              0
            ],
            [
              357,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsLeaveCriticalSectionPrimitive",
            "parameters": {
              "m": "_cmsMutex"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsLockPrimitive(_cmsMutex *m)\n{\n    cmsUNUSED_PARAMETER(m);\n    return 0;\n}",
          "fn_code_pos": [
            [
              366,
              0
            ],
            [
              370,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsLockPrimitive",
            "parameters": {
              "m": "_cmsMutex"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsUnlockPrimitive(_cmsMutex *m)\n{\n    cmsUNUSED_PARAMETER(m);\n    return 0;\n}",
          "fn_code_pos": [
            [
              372,
              0
            ],
            [
              376,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsUnlockPrimitive",
            "parameters": {
              "m": "_cmsMutex"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsInitMutexPrimitive(_cmsMutex *m)\n{\n    cmsUNUSED_PARAMETER(m);\n    return 0;\n}",
          "fn_code_pos": [
            [
              378,
              0
            ],
            [
              382,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsInitMutexPrimitive",
            "parameters": {
              "m": "_cmsMutex"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsDestroyMutexPrimitive(_cmsMutex *m)\n{\n    cmsUNUSED_PARAMETER(m);\n    return 0;\n}",
          "fn_code_pos": [
            [
              384,
              0
            ],
            [
              388,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsDestroyMutexPrimitive",
            "parameters": {
              "m": "_cmsMutex"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsEnterCriticalSectionPrimitive(_cmsMutex *m)\n{\n    cmsUNUSED_PARAMETER(m);\n    return 0;\n}",
          "fn_code_pos": [
            [
              390,
              0
            ],
            [
              394,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsEnterCriticalSectionPrimitive",
            "parameters": {
              "m": "_cmsMutex"
            },
            "return_type": "cmsINLINE"
          }
        },
        {
          "fn_code": "cmsINLINE int _cmsLeaveCriticalSectionPrimitive(_cmsMutex *m)\n{\n    cmsUNUSED_PARAMETER(m);\n    return 0;\n}",
          "fn_code_pos": [
            [
              396,
              0
            ],
            [
              400,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsLeaveCriticalSectionPrimitive",
            "parameters": {
              "m": "_cmsMutex"
            },
            "return_type": "cmsINLINE"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "_cmsPluginMalloc(cmsContext ContextID, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              406,
              6
            ],
            [
              406,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsPluginMalloc",
            "parameters": {
              "ContextID": "cmsContext",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsRegisterMemHandlerPlugin(cmsContext ContextID, cmsPluginBase* Plugin)",
          "fn_dec_pos": [
            [
              409,
              10
            ],
            [
              409,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterMemHandlerPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Plugin": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsRegisterInterpPlugin(cmsContext ContextID, cmsPluginBase* Plugin)",
          "fn_dec_pos": [
            [
              412,
              9
            ],
            [
              412,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterInterpPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Plugin": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsRegisterParametricCurvesPlugin(cmsContext ContextID, cmsPluginBase* Plugin)",
          "fn_dec_pos": [
            [
              415,
              9
            ],
            [
              415,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterParametricCurvesPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Plugin": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsRegisterFormattersPlugin(cmsContext ContextID, cmsPluginBase* Plugin)",
          "fn_dec_pos": [
            [
              418,
              9
            ],
            [
              418,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterFormattersPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Plugin": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsRegisterTagTypePlugin(cmsContext ContextID, cmsPluginBase* Plugin)",
          "fn_dec_pos": [
            [
              421,
              9
            ],
            [
              421,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterTagTypePlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Plugin": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsRegisterTagPlugin(cmsContext ContextID, cmsPluginBase* Plugin)",
          "fn_dec_pos": [
            [
              424,
              9
            ],
            [
              424,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterTagPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Plugin": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsRegisterRenderingIntentPlugin(cmsContext ContextID, cmsPluginBase* Plugin)",
          "fn_dec_pos": [
            [
              427,
              9
            ],
            [
              427,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterRenderingIntentPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Plugin": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsRegisterMultiProcessElementPlugin(cmsContext ContextID, cmsPluginBase* Plugin)",
          "fn_dec_pos": [
            [
              430,
              9
            ],
            [
              430,
              91
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterMultiProcessElementPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Plugin": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsRegisterOptimizationPlugin(cmsContext ContextID, cmsPluginBase* Plugin)",
          "fn_dec_pos": [
            [
              433,
              9
            ],
            [
              433,
              84
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterOptimizationPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Plugin": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsRegisterTransformPlugin(cmsContext ContextID, cmsPluginBase* Plugin)",
          "fn_dec_pos": [
            [
              436,
              9
            ],
            [
              436,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterTransformPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Plugin": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsRegisterMutexPlugin(cmsContext ContextID, cmsPluginBase* Plugin)",
          "fn_dec_pos": [
            [
              439,
              8
            ],
            [
              439,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterMutexPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Plugin": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsRegisterParallelizationPlugin(cmsContext ContextID, cmsPluginBase* Plugin)",
          "fn_dec_pos": [
            [
              442,
              8
            ],
            [
              442,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsRegisterParallelizationPlugin",
            "parameters": {
              "ContextID": "cmsContext",
              "Plugin": "cmsPluginBase"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsCreateSubAlloc(cmsContext ContextID, cmsUInt32Number Initial)",
          "fn_dec_pos": [
            [
              466,
              18
            ],
            [
              466,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsCreateSubAlloc",
            "parameters": {
              "ContextID": "cmsContext",
              "Initial": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsSubAllocDestroy(_cmsSubAllocator* s)",
          "fn_dec_pos": [
            [
              467,
              18
            ],
            [
              467,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsSubAllocDestroy",
            "parameters": {
              "s": "_cmsSubAllocator"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsSubAlloc(_cmsSubAllocator* s, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              468,
              18
            ],
            [
              468,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsSubAlloc",
            "parameters": {
              "s": "_cmsSubAllocator",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsSubAllocDup(_cmsSubAllocator* s, const void *ptr, cmsUInt32Number size)",
          "fn_dec_pos": [
            [
              469,
              18
            ],
            [
              469,
              93
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsSubAllocDup",
            "parameters": {
              "s": "_cmsSubAllocator",
              "ptr": "void",
              "size": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsInstallAllocFunctions(cmsPluginMemHandler* Plugin, _cmsMemPluginChunkType* ptr)",
          "fn_dec_pos": [
            [
              512,
              6
            ],
            [
              512,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsInstallAllocFunctions",
            "parameters": {
              "Plugin": "cmsPluginMemHandler",
              "ptr": "_cmsMemPluginChunkType"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsGetContext(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              528,
              27
            ],
            [
              528,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetContext",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsContextGetClientChunk(cmsContext id, _cmsMemoryClient mc)",
          "fn_dec_pos": [
            [
              531,
              10
            ],
            [
              531,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsContextGetClientChunk",
            "parameters": {
              "id": "cmsContext",
              "mc": "_cmsMemoryClient"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsAllocLogErrorChunk(struct _cmsContext_struct* ctx, \n                            const struct _cmsContext_struct* src)",
          "fn_dec_pos": [
            [
              549,
              5
            ],
            [
              550,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocLogErrorChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsAllocAlarmCodesChunk(struct _cmsContext_struct* ctx, \n                            const struct _cmsContext_struct* src)",
          "fn_dec_pos": [
            [
              563,
              5
            ],
            [
              564,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocAlarmCodesChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsAllocAdaptationStateChunk(struct _cmsContext_struct* ctx, \n                                   const struct _cmsContext_struct* src)",
          "fn_dec_pos": [
            [
              577,
              5
            ],
            [
              578,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocAdaptationStateChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsAllocMemPluginChunk(struct _cmsContext_struct* ctx, \n                             const struct _cmsContext_struct* src)",
          "fn_dec_pos": [
            [
              585,
              5
            ],
            [
              586,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocMemPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsAllocInterpPluginChunk(struct _cmsContext_struct* ctx, \n                                const struct _cmsContext_struct* src)",
          "fn_dec_pos": [
            [
              599,
              5
            ],
            [
              600,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocInterpPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsAllocCurvesPluginChunk(struct _cmsContext_struct* ctx, \n                                                      const struct _cmsContext_struct* src)",
          "fn_dec_pos": [
            [
              613,
              5
            ],
            [
              614,
              91
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocCurvesPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsAllocFormattersPluginChunk(struct _cmsContext_struct* ctx, \n                                                       const struct _cmsContext_struct* src)",
          "fn_dec_pos": [
            [
              627,
              5
            ],
            [
              628,
              92
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocFormattersPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsAllocTagTypePluginChunk(struct _cmsContext_struct* ctx, \n                                                        const struct _cmsContext_struct* src)",
          "fn_dec_pos": [
            [
              646,
              5
            ],
            [
              647,
              93
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocTagTypePluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsAllocMPETypePluginChunk(struct _cmsContext_struct* ctx, \n                                                        const struct _cmsContext_struct* src)",
          "fn_dec_pos": [
            [
              649,
              5
            ],
            [
              650,
              93
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocMPETypePluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsAllocTagPluginChunk(struct _cmsContext_struct* ctx, \n                                                      const struct _cmsContext_struct* src)",
          "fn_dec_pos": [
            [
              663,
              5
            ],
            [
              664,
              91
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocTagPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsAllocIntentsPluginChunk(struct _cmsContext_struct* ctx, \n                                                        const struct _cmsContext_struct* src)",
          "fn_dec_pos": [
            [
              678,
              5
            ],
            [
              679,
              93
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocIntentsPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsAllocOptimizationPluginChunk(struct _cmsContext_struct* ctx, \n                                         const struct _cmsContext_struct* src)",
          "fn_dec_pos": [
            [
              693,
              5
            ],
            [
              694,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocOptimizationPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsAllocTransformPluginChunk(struct _cmsContext_struct* ctx, \n                                        const struct _cmsContext_struct* src)",
          "fn_dec_pos": [
            [
              707,
              5
            ],
            [
              708,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocTransformPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsAllocMutexPluginChunk(struct _cmsContext_struct* ctx, \n                                        const struct _cmsContext_struct* src)",
          "fn_dec_pos": [
            [
              724,
              5
            ],
            [
              725,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocMutexPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsAllocParallelizationPluginChunk(struct _cmsContext_struct* ctx,\n                                         const struct _cmsContext_struct* src)",
          "fn_dec_pos": [
            [
              740,
              5
            ],
            [
              741,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAllocParallelizationPluginChunk",
            "parameters": {
              "ctx": "struct _cmsContext_struct",
              "src": "struct _cmsContext_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsReadHeader(_cmsICCPROFILE* Icc)",
          "fn_dec_pos": [
            [
              852,
              21
            ],
            [
              852,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadHeader",
            "parameters": {
              "Icc": "_cmsICCPROFILE"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsWriteHeader(_cmsICCPROFILE* Icc, cmsUInt32Number UsedSpace)",
          "fn_dec_pos": [
            [
              853,
              21
            ],
            [
              853,
              84
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteHeader",
            "parameters": {
              "Icc": "_cmsICCPROFILE",
              "UsedSpace": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsSearchTag(_cmsICCPROFILE* Icc, cmsTagSignature sig, cmsBool lFollowLinks)",
          "fn_dec_pos": [
            [
              854,
              21
            ],
            [
              854,
              98
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsSearchTag",
            "parameters": {
              "Icc": "_cmsICCPROFILE",
              "sig": "cmsTagSignature",
              "lFollowLinks": "cmsBool"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "_cmsGetTagTypeHandler(cmsContext ContextID, cmsTagTypeSignature sig)",
          "fn_dec_pos": [
            [
              857,
              21
            ],
            [
              857,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTagTypeHandler",
            "parameters": {
              "ContextID": "cmsContext",
              "sig": "cmsTagTypeSignature"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsGetTagTrueType(cmsHPROFILE hProfile, cmsTagSignature sig)",
          "fn_dec_pos": [
            [
              858,
              21
            ],
            [
              858,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTagTrueType",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "sig": "cmsTagSignature"
            },
            "return_type": "cmsTagTypeSignature"
          }
        },
        {
          "fn_code": "_cmsGetTagDescriptor(cmsContext ContextID, cmsTagSignature sig)",
          "fn_dec_pos": [
            [
              859,
              21
            ],
            [
              859,
              84
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTagDescriptor",
            "parameters": {
              "ContextID": "cmsContext",
              "sig": "cmsTagSignature"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsTagSignature2String(char String[5], cmsTagSignature sig)",
          "fn_dec_pos": [
            [
              863,
              21
            ],
            [
              863,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsTagSignature2String",
            "parameters": {
              "String": "char",
              "sig": "cmsTagSignature"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsComputeInterpParams(cmsContext ContextID, cmsUInt32Number nSamples, cmsUInt32Number InputChan, cmsUInt32Number OutputChan, const void* Table, cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              867,
              41
            ],
            [
              867,
              211
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ContextID": "cmsContext",
              "nSamples": "cmsUInt32Number",
              "InputChan": "cmsUInt32Number",
              "OutputChan": "cmsUInt32Number",
              "Table": "void",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsComputeInterpParamsEx(cmsContext ContextID, const cmsUInt32Number nSamples[], cmsUInt32Number InputChan, cmsUInt32Number OutputChan, const void* Table, cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              868,
              41
            ],
            [
              868,
              221
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsComputeInterpParamsEx",
            "parameters": {
              "ContextID": "cmsContext",
              "nSamples": "cmsUInt32Number",
              "InputChan": "cmsUInt32Number",
              "OutputChan": "cmsUInt32Number",
              "Table": "void",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsFreeInterpParams(cmsInterpParams* p)",
          "fn_dec_pos": [
            [
              869,
              41
            ],
            [
              869,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsFreeInterpParams",
            "parameters": {
              "p": "cmsInterpParams"
            },
            "return_type": "CMSCHECKPOINT"
          }
        },
        {
          "fn_code": "_cmsSetInterpolationRoutine(cmsContext ContextID, cmsInterpParams* p)",
          "fn_dec_pos": [
            [
              870,
              41
            ],
            [
              870,
              110
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsSetInterpolationRoutine",
            "parameters": {
              "ContextID": "cmsContext",
              "p": "cmsInterpParams"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsStageAllocLab2XYZ(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              920,
              35
            ],
            [
              920,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageAllocLab2XYZ",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageAllocXYZ2Lab(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              921,
              35
            ],
            [
              921,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageAllocXYZ2Lab",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageAllocLabPrelin(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              922,
              35
            ],
            [
              922,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageAllocLabPrelin",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageAllocLabV2ToV4(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              923,
              35
            ],
            [
              923,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageAllocLabV2ToV4",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageAllocLabV2ToV4curves(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              924,
              35
            ],
            [
              924,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageAllocLabV2ToV4curves",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageAllocLabV4ToV2(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              925,
              35
            ],
            [
              925,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageAllocLabV4ToV2",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageAllocNamedColor(cmsNAMEDCOLORLIST* NamedColorList, cmsBool UsePCS)",
          "fn_dec_pos": [
            [
              926,
              35
            ],
            [
              926,
              110
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageAllocNamedColor",
            "parameters": {
              "NamedColorList": "cmsNAMEDCOLORLIST",
              "UsePCS": "cmsBool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageAllocIdentityCurves(cmsContext ContextID, cmsUInt32Number nChannels)",
          "fn_dec_pos": [
            [
              927,
              35
            ],
            [
              927,
              112
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageAllocIdentityCurves",
            "parameters": {
              "ContextID": "cmsContext",
              "nChannels": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageAllocIdentityCLut(cmsContext ContextID, cmsUInt32Number nChan)",
          "fn_dec_pos": [
            [
              928,
              35
            ],
            [
              928,
              106
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageAllocIdentityCLut",
            "parameters": {
              "ContextID": "cmsContext",
              "nChan": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageNormalizeFromLabFloat(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              929,
              35
            ],
            [
              929,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageNormalizeFromLabFloat",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageNormalizeFromXyzFloat(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              930,
              35
            ],
            [
              930,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageNormalizeFromXyzFloat",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageNormalizeToLabFloat(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              931,
              35
            ],
            [
              931,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageNormalizeToLabFloat",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageNormalizeToXyzFloat(cmsContext ContextID)",
          "fn_dec_pos": [
            [
              932,
              35
            ],
            [
              932,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageNormalizeToXyzFloat",
            "parameters": {
              "ContextID": "cmsContext"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageClipNegatives(cmsContext ContextID, cmsUInt32Number nChannels)",
          "fn_dec_pos": [
            [
              933,
              35
            ],
            [
              933,
              106
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageClipNegatives",
            "parameters": {
              "ContextID": "cmsContext",
              "nChannels": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsStageGetPtrToCurveSet(const cmsStage* mpe)",
          "fn_dec_pos": [
            [
              937,
              16
            ],
            [
              937,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsStageGetPtrToCurveSet",
            "parameters": {
              "mpe": "cmsStage"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsReadInputLUT(cmsHPROFILE hProfile, cmsUInt32Number Intent)",
          "fn_dec_pos": [
            [
              962,
              37
            ],
            [
              962,
              99
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsReadOutputLUT(cmsHPROFILE hProfile, cmsUInt32Number Intent)",
          "fn_dec_pos": [
            [
              963,
              37
            ],
            [
              963,
              100
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsReadDevicelinkLUT(cmsHPROFILE hProfile, cmsUInt32Number Intent)",
          "fn_dec_pos": [
            [
              964,
              37
            ],
            [
              964,
              104
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "Intent": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsReadMediaWhitePoint(cmsCIEXYZ* Dest, cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              967,
              18
            ],
            [
              967,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadMediaWhitePoint",
            "parameters": {
              "Dest": "cmsCIEXYZ",
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsReadCHAD(cmsMAT3* Dest, cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              968,
              18
            ],
            [
              968,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadCHAD",
            "parameters": {
              "Dest": "cmsMAT3",
              "hProfile": "cmsHPROFILE"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsLinkProfiles(cmsContext         ContextID,\n                              cmsUInt32Number    nProfiles,\n                              cmsUInt32Number    TheIntents[],\n                              cmsHPROFILE        hProfiles[],\n                              cmsBool            BPC[],\n                              cmsFloat64Number   AdaptationStates[],\n                              cmsUInt32Number    dwFlags)",
          "fn_dec_pos": [
            [
              975,
              13
            ],
            [
              981,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsLinkProfiles",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "TheIntents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsReadProfileSequence(cmsHPROFILE hProfile)",
          "fn_dec_pos": [
            [
              985,
              8
            ],
            [
              985,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReadProfileSequence",
            "parameters": {
              "hProfile": "cmsHPROFILE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsWriteProfileSequence(cmsHPROFILE hProfile, const cmsSEQ* seq)",
          "fn_dec_pos": [
            [
              986,
              8
            ],
            [
              986,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsWriteProfileSequence",
            "parameters": {
              "hProfile": "cmsHPROFILE",
              "seq": "cmsSEQ"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsCompileProfileSequence(cmsContext ContextID, cmsUInt32Number nProfiles, cmsHPROFILE hProfiles[])",
          "fn_dec_pos": [
            [
              987,
              8
            ],
            [
              987,
              108
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsCompileProfileSequence",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsQuantizeVal(cmsFloat64Number i, cmsUInt32Number MaxSamples)",
          "fn_dec_pos": [
            [
              992,
              41
            ],
            [
              992,
              104
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsQuantizeVal",
            "parameters": {
              "i": "cmsFloat64Number",
              "MaxSamples": "cmsUInt32Number"
            },
            "return_type": "CMSCHECKPOINT"
          }
        },
        {
          "fn_code": "_cmsReasonableGridpointsByColorspace(cmsColorSpaceSignature Colorspace, cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              994,
              34
            ],
            [
              994,
              130
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsReasonableGridpointsByColorspace",
            "parameters": {
              "Colorspace": "cmsColorSpaceSignature",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsEndPointsBySpace(cmsColorSpaceSignature Space,\n                                      cmsUInt16Number **White,\n                                      cmsUInt16Number **Black,\n                                      cmsUInt32Number *nOutputs)",
          "fn_dec_pos": [
            [
              996,
              17
            ],
            [
              999,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsEndPointsBySpace",
            "parameters": {
              "Space": "cmsColorSpaceSignature",
              "White": "cmsUInt16Number",
              "Black": "cmsUInt16Number",
              "nOutputs": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsOptimizePipeline(cmsContext ContextID,\n                                      cmsPipeline**    Lut,\n                                      cmsUInt32Number  Intent,\n                                      cmsUInt32Number* InputFormat,\n                                      cmsUInt32Number* OutputFormat,\n                                      cmsUInt32Number* dwFlags )",
          "fn_dec_pos": [
            [
              1001,
              25
            ],
            [
              1006,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsOptimizePipeline",
            "parameters": {
              "ContextID": "cmsContext",
              "Lut": "cmsPipeline",
              "Intent": "cmsUInt32Number",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSAPI"
          }
        },
        {
          "fn_code": "_cmsCreateGamutCheckPipeline(cmsContext ContextID,\n                                              cmsHPROFILE hProfiles[],\n                                              cmsBool  BPC[],\n                                              cmsUInt32Number Intents[],\n                                              cmsFloat64Number AdaptationStates[],\n                                              cmsUInt32Number nGamutPCSposition,\n                                              cmsHPROFILE hGamut)",
          "fn_dec_pos": [
            [
              1011,
              17
            ],
            [
              1017,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsCreateGamutCheckPipeline",
            "parameters": {
              "ContextID": "cmsContext",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "Intents": "cmsUInt32Number",
              "AdaptationStates": "cmsFloat64Number",
              "nGamutPCSposition": "cmsUInt32Number",
              "hGamut": "cmsHPROFILE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsFormatterIsFloat(cmsUInt32Number Type)",
          "fn_dec_pos": [
            [
              1024,
              16
            ],
            [
              1024,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsFormatterIsFloat",
            "parameters": {
              "Type": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsFormatterIs8bit(cmsUInt32Number Type)",
          "fn_dec_pos": [
            [
              1025,
              16
            ],
            [
              1025,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsFormatterIs8bit",
            "parameters": {
              "Type": "cmsUInt32Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsGetFormatter(cmsContext ContextID,\n                                                      cmsUInt32Number Type,          // Specific type, i.e. TYPE_RGB_8\n                                                      cmsFormatterDirection Dir,\n                                                      cmsUInt32Number dwFlags)",
          "fn_dec_pos": [
            [
              1027,
              37
            ],
            [
              1030,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetFormatter",
            "parameters": {
              "ContextID": "cmsContext",
              "Type": "cmsUInt32Number",
              "Dir": "cmsFormatterDirection",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "CMSCHECKPOINT"
          }
        },
        {
          "fn_code": "_cmsHalf2Float(cmsUInt16Number h)",
          "fn_dec_pos": [
            [
              1036,
              41
            ],
            [
              1036,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsHalf2Float",
            "parameters": {
              "h": "cmsUInt16Number"
            },
            "return_type": "CMSCHECKPOINT"
          }
        },
        {
          "fn_code": "_cmsFloat2Half(cmsFloat32Number flt)",
          "fn_dec_pos": [
            [
              1037,
              41
            ],
            [
              1037,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsFloat2Half",
            "parameters": {
              "flt": "cmsFloat32Number"
            },
            "return_type": "CMSCHECKPOINT"
          }
        },
        {
          "fn_code": "_cmsHandleExtraChannels(_cmsTRANSFORM* p, const void* in,\n                             void* out, \n                             cmsUInt32Number PixelsPerLine,\n                             cmsUInt32Number LineCount,\n                             const cmsStride* Stride)",
          "fn_dec_pos": [
            [
              1119,
              5
            ],
            [
              1123,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsHandleExtraChannels",
            "parameters": {
              "p": "_cmsTRANSFORM",
              "in": "void",
              "out": "void",
              "PixelsPerLine": "cmsUInt32Number",
              "LineCount": "cmsUInt32Number",
              "Stride": "cmsStride"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_cmsChain2Lab(cmsContext             ContextID,\n                            cmsUInt32Number        nProfiles,\n                            cmsUInt32Number        InputFormat,\n                            cmsUInt32Number        OutputFormat,\n                            const cmsUInt32Number  Intents[],\n                            const cmsHPROFILE      hProfiles[],\n                            const cmsBool          BPC[],\n                            const cmsFloat64Number AdaptationStates[],\n                            cmsUInt32Number        dwFlags)",
          "fn_dec_pos": [
            [
              1127,
              14
            ],
            [
              1135,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsChain2Lab",
            "parameters": {
              "ContextID": "cmsContext",
              "nProfiles": "cmsUInt32Number",
              "InputFormat": "cmsUInt32Number",
              "OutputFormat": "cmsUInt32Number",
              "Intents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": "cmsHTRANSFORM"
          }
        },
        {
          "fn_code": "_cmsBuildKToneCurve(cmsContext       ContextID,\n                            cmsUInt32Number        nPoints,\n                            cmsUInt32Number        nProfiles,\n                            const cmsUInt32Number  Intents[],\n                            const cmsHPROFILE      hProfiles[],\n                            const cmsBool          BPC[],\n                            const cmsFloat64Number AdaptationStates[],\n                            cmsUInt32Number        dwFlags)",
          "fn_dec_pos": [
            [
              1138,
              14
            ],
            [
              1145,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsBuildKToneCurve",
            "parameters": {
              "ContextID": "cmsContext",
              "nPoints": "cmsUInt32Number",
              "nProfiles": "cmsUInt32Number",
              "Intents": "cmsUInt32Number",
              "hProfiles": "cmsHPROFILE",
              "BPC": "cmsBool",
              "AdaptationStates": "cmsFloat64Number",
              "dwFlags": "cmsUInt32Number"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_cmsAdaptationMatrix(cmsMAT3* r, const cmsMAT3* ConeMatrix, const cmsCIEXYZ* FromIll, const cmsCIEXYZ* ToIll)",
          "fn_dec_pos": [
            [
              1147,
              10
            ],
            [
              1147,
              119
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsAdaptationMatrix",
            "parameters": {
              "r": "cmsMAT3",
              "ConeMatrix": "cmsMAT3",
              "FromIll": "cmsCIEXYZ",
              "ToIll": "cmsCIEXYZ"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsBuildRGB2XYZtransferMatrix(cmsMAT3* r, const cmsCIExyY* WhitePoint, const cmsCIExyYTRIPLE* Primaries)",
          "fn_dec_pos": [
            [
              1149,
              10
            ],
            [
              1149,
              115
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsBuildRGB2XYZtransferMatrix",
            "parameters": {
              "r": "cmsMAT3",
              "WhitePoint": "cmsCIExyY",
              "Primaries": "cmsCIExyYTRIPLE"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "_cmsGetTime(struct tm* ptr_time)",
          "fn_dec_pos": [
            [
              1153,
              8
            ],
            [
              1153,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_cmsGetTime",
            "parameters": {
              "ptr_time": "struct tm"
            },
            "return_type": "cmsBool"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct _cmsSubAllocator_chunk_st {\n\n    cmsUInt8Number* Block;\n    cmsUInt32Number BlockSize;\n    cmsUInt32Number Used;\n\n    struct _cmsSubAllocator_chunk_st* next;\n\n} _cmsSubAllocator_chunk;",
          {
            "* Block": "cmsUInt8Number",
            "BlockSize": "cmsUInt32Number",
            "Used": "cmsUInt32Number",
            "* next": "struct _cmsSubAllocator_chunk_st"
          },
          "_cmsSubAllocator_chunk",
          [
            447,
            0
          ],
          [
            455,
            25
          ]
        ],
        [
          "typedef struct {\n\n    cmsContext ContextID;\n    _cmsSubAllocator_chunk* h;\n\n} _cmsSubAllocator;",
          {
            "ContextID": "cmsContext",
            "* h": "_cmsSubAllocator_chunk"
          },
          "_cmsSubAllocator",
          [
            458,
            0
          ],
          [
            463,
            19
          ]
        ],
        [
          "typedef struct {\n\n    _cmsMallocFnPtrType     MallocPtr;    \n    _cmsMalloZerocFnPtrType MallocZeroPtr;\n    _cmsFreeFnPtrType       FreePtr;\n    _cmsReallocFnPtrType    ReallocPtr;\n    _cmsCallocFnPtrType     CallocPtr;\n    _cmsDupFnPtrType        DupPtr;\n\n} _cmsMemPluginChunkType;",
          {
            "MallocPtr": "_cmsMallocFnPtrType",
            "MallocZeroPtr": "_cmsMalloZerocFnPtrType",
            "FreePtr": "_cmsFreeFnPtrType",
            "ReallocPtr": "_cmsReallocFnPtrType",
            "CallocPtr": "_cmsCallocFnPtrType",
            "DupPtr": "_cmsDupFnPtrType"
          },
          "_cmsMemPluginChunkType",
          [
            500,
            0
          ],
          [
            509,
            25
          ]
        ],
        [
          "struct _cmsContext_struct {\n    \n    struct _cmsContext_struct* Next;  // Points to next context in the new style\n    _cmsSubAllocator* MemPool;        // The memory pool that stores context data\n    \n    void* chunks[MemoryClientMax];    // array of pointers to client chunks. Memory itself is held in the suballocator.\n                                      // If NULL, then it reverts to global Context0\n\n    _cmsMemPluginChunkType DefaultMemoryManager;  // The allocators used for creating the context itself. Cannot be overridden\n}",
          {
            "* Next": "struct _cmsContext_struct",
            "* MemPool": "_cmsSubAllocator",
            "* chunks[MemoryClientMax]": "void",
            "DefaultMemoryManager": "_cmsMemPluginChunkType"
          },
          "_cmsContext_struct",
          [
            515,
            0
          ],
          [
            524,
            1
          ]
        ],
        [
          "typedef struct {\n\n    cmsLogErrorHandlerFunction LogErrorHandler;  // Set to NULL for Context0 fallback\n\n} _cmsLogErrorChunkType;",
          {
            "LogErrorHandler": "cmsLogErrorHandlerFunction"
          },
          "_cmsLogErrorChunkType",
          [
            539,
            0
          ],
          [
            543,
            24
          ]
        ],
        [
          "typedef struct {\n   \n    cmsUInt16Number AlarmCodes[cmsMAXCHANNELS];\n\n} _cmsAlarmCodesChunkType;",
          {
            "AlarmCodes[cmsMAXCHANNELS]": "cmsUInt16Number"
          },
          "_cmsAlarmCodesChunkType",
          [
            553,
            0
          ],
          [
            557,
            26
          ]
        ],
        [
          "typedef struct {\n    \n    cmsFloat64Number  AdaptationState;\n\n} _cmsAdaptationStateChunkType;",
          {
            "AdaptationState": "cmsFloat64Number"
          },
          "_cmsAdaptationStateChunkType",
          [
            567,
            0
          ],
          [
            571,
            31
          ]
        ],
        [
          "typedef struct {\n\n    cmsInterpFnFactory Interpolators;\n\n} _cmsInterpPluginChunkType;",
          {
            "Interpolators": "cmsInterpFnFactory"
          },
          "_cmsInterpPluginChunkType",
          [
            589,
            0
          ],
          [
            593,
            28
          ]
        ],
        [
          "typedef struct {\n\n    struct _cmsParametricCurvesCollection_st* ParametricCurves;\n\n} _cmsCurvesPluginChunkType;",
          {
            "* ParametricCurves": "struct _cmsParametricCurvesCollection_st"
          },
          "_cmsCurvesPluginChunkType",
          [
            603,
            0
          ],
          [
            607,
            28
          ]
        ],
        [
          "typedef struct {\n\n    struct _cms_formatters_factory_list* FactoryList;\n\n} _cmsFormattersPluginChunkType;",
          {
            "* FactoryList": "struct _cms_formatters_factory_list"
          },
          "_cmsFormattersPluginChunkType",
          [
            617,
            0
          ],
          [
            621,
            32
          ]
        ],
        [
          "typedef struct {\n\n    struct _cmsTagTypeLinkedList_st* TagTypes;\n\n} _cmsTagTypePluginChunkType;",
          {
            "* TagTypes": "struct _cmsTagTypeLinkedList_st"
          },
          "_cmsTagTypePluginChunkType",
          [
            631,
            0
          ],
          [
            635,
            29
          ]
        ],
        [
          "typedef struct {\n   \n    struct _cmsTagLinkedList_st* Tag;\n\n} _cmsTagPluginChunkType;",
          {
            "* Tag": "struct _cmsTagLinkedList_st"
          },
          "_cmsTagPluginChunkType",
          [
            652,
            0
          ],
          [
            656,
            25
          ]
        ],
        [
          "typedef struct {\n\n    struct _cms_intents_list* Intents;\n\n} _cmsIntentsPluginChunkType;",
          {
            "* Intents": "struct _cms_intents_list"
          },
          "_cmsIntentsPluginChunkType",
          [
            667,
            0
          ],
          [
            671,
            29
          ]
        ],
        [
          "typedef struct {\n\n    struct _cmsOptimizationCollection_st* OptimizationCollection;\n\n} _cmsOptimizationPluginChunkType;",
          {
            "* OptimizationCollection": "struct _cmsOptimizationCollection_st"
          },
          "_cmsOptimizationPluginChunkType",
          [
            682,
            0
          ],
          [
            686,
            34
          ]
        ],
        [
          "typedef struct {\n\n    struct _cmsTransformCollection_st* TransformCollection;\n\n} _cmsTransformPluginChunkType;",
          {
            "* TransformCollection": "struct _cmsTransformCollection_st"
          },
          "_cmsTransformPluginChunkType",
          [
            697,
            0
          ],
          [
            701,
            31
          ]
        ],
        [
          "typedef struct {\n\n    _cmsCreateMutexFnPtrType  CreateMutexPtr;\n    _cmsDestroyMutexFnPtrType DestroyMutexPtr;\n    _cmsLockMutexFnPtrType    LockMutexPtr;\n    _cmsUnlockMutexFnPtrType  UnlockMutexPtr;\n\n} _cmsMutexPluginChunkType;",
          {
            "CreateMutexPtr": "_cmsCreateMutexFnPtrType",
            "DestroyMutexPtr": "_cmsDestroyMutexFnPtrType",
            "LockMutexPtr": "_cmsLockMutexFnPtrType",
            "UnlockMutexPtr": "_cmsUnlockMutexFnPtrType"
          },
          "_cmsMutexPluginChunkType",
          [
            711,
            0
          ],
          [
            718,
            27
          ]
        ],
        [
          "typedef struct {\n\n    cmsInt32Number      MaxWorkers;       // Number of workers to do as maximum\n    cmsInt32Number      WorkerFlags;      // reserved\n    _cmsTransform2Fn    SchedulerFn;      // callback to setup functions \n    \n} _cmsParallelizationPluginChunkType;",
          {
            "MaxWorkers": "cmsInt32Number",
            "WorkerFlags": "cmsInt32Number",
            "SchedulerFn": "_cmsTransform2Fn"
          },
          "_cmsParallelizationPluginChunkType",
          [
            728,
            0
          ],
          [
            734,
            37
          ]
        ],
        [
          "typedef struct {\n\n    cmsUInt16Number Language;\n    cmsUInt16Number Country;\n\n    cmsUInt32Number StrW;       // Offset to current unicode string\n    cmsUInt32Number Len;        // Length in bytes\n\n} _cmsMLUentry;",
          {
            "Language": "cmsUInt16Number",
            "Country": "cmsUInt16Number",
            "StrW": "cmsUInt32Number",
            "Len": "cmsUInt32Number"
          },
          "_cmsMLUentry",
          [
            747,
            0
          ],
          [
            755,
            15
          ]
        ],
        [
          "struct _cms_MLU_struct {\n\n    cmsContext ContextID;\n\n    // The directory\n    cmsUInt32Number  AllocatedEntries;\n    cmsUInt32Number  UsedEntries;\n    _cmsMLUentry* Entries;     // Array of pointers to strings allocated in MemPool\n\n    // The Pool\n    cmsUInt32Number PoolSize;  // The maximum allocated size\n    cmsUInt32Number PoolUsed;  // The used size\n    void*  MemPool;            // Pointer to begin of memory pool\n}",
          {
            "ContextID": "cmsContext",
            "AllocatedEntries": "cmsUInt32Number",
            "UsedEntries": "cmsUInt32Number",
            "* Entries": "_cmsMLUentry",
            "PoolSize": "cmsUInt32Number",
            "PoolUsed": "cmsUInt32Number",
            "*  MemPool": "void"
          },
          "_cms_MLU_struct",
          [
            757,
            0
          ],
          [
            770,
            1
          ]
        ],
        [
          "typedef struct {\n\n    char Name[cmsMAX_PATH];\n    cmsUInt16Number PCS[3];\n    cmsUInt16Number DeviceColorant[cmsMAXCHANNELS];\n\n} _cmsNAMEDCOLOR;",
          {
            "Name[cmsMAX_PATH]": "char",
            "PCS[3]": "cmsUInt16Number",
            "DeviceColorant[cmsMAXCHANNELS]": "cmsUInt16Number"
          },
          "_cmsNAMEDCOLOR",
          [
            773,
            0
          ],
          [
            779,
            17
          ]
        ],
        [
          "struct _cms_NAMEDCOLORLIST_struct {\n\n    cmsUInt32Number nColors;\n    cmsUInt32Number Allocated;\n    cmsUInt32Number ColorantCount;\n\n    char Prefix[33];      // Prefix and suffix are defined to be 32 characters at most\n    char Suffix[33];\n\n    _cmsNAMEDCOLOR* List;\n\n    cmsContext ContextID;\n}",
          {
            "nColors": "cmsUInt32Number",
            "Allocated": "cmsUInt32Number",
            "ColorantCount": "cmsUInt32Number",
            "Prefix[33]": "char",
            "Suffix[33]": "char",
            "* List": "_cmsNAMEDCOLOR",
            "ContextID": "cmsContext"
          },
          "_cms_NAMEDCOLORLIST_struct",
          [
            781,
            0
          ],
          [
            793,
            1
          ]
        ],
        [
          "typedef struct _cms_iccprofile_struct {\n\n    // I/O handler\n    cmsIOHANDLER*            IOhandler;\n\n    // The thread ID\n    cmsContext               ContextID;\n\n    // Creation time\n    struct tm                Created;\n\n    // Color management module identification\n    cmsUInt32Number          CMM;\n\n    // Only most important items found in ICC profiles\n    cmsUInt32Number          Version;\n    cmsProfileClassSignature DeviceClass;\n    cmsColorSpaceSignature   ColorSpace;\n    cmsColorSpaceSignature   PCS;\n    cmsUInt32Number          RenderingIntent;\n\n    cmsPlatformSignature     platform;\n    cmsUInt32Number          flags;\n    cmsUInt32Number          manufacturer, model;\n    cmsUInt64Number          attributes;\n    cmsUInt32Number          creator;\n\n    cmsProfileID             ProfileID;\n\n    // Dictionary\n    cmsUInt32Number          TagCount;\n    cmsTagSignature          TagNames[MAX_TABLE_TAG];\n    cmsTagSignature          TagLinked[MAX_TABLE_TAG];           // The tag to which is linked (0=none)\n    cmsUInt32Number          TagSizes[MAX_TABLE_TAG];            // Size on disk\n    cmsUInt32Number          TagOffsets[MAX_TABLE_TAG];\n    cmsBool                  TagSaveAsRaw[MAX_TABLE_TAG];        // True to write uncooked\n    void *                   TagPtrs[MAX_TABLE_TAG];\n    cmsTagTypeHandler*       TagTypeHandlers[MAX_TABLE_TAG];     // Same structure may be serialized on different types\n                                                                 // depending on profile version, so we keep track of the\n                                                                 // type handler for each tag in the list.\n    // Special\n    cmsBool                  IsWrite;\n\n    // Keep a mutex for cmsReadTag -- Note that this only works if the user includes a mutex plugin\n    void *                   UsrMutex;\n\n} _cmsICCPROFILE;",
          {
            "*            IOhandler": "cmsIOHANDLER",
            "ContextID": "cmsContext",
            "Created": "struct tm",
            "CMM": "cmsUInt32Number",
            "Version": "cmsUInt32Number",
            "DeviceClass": "cmsProfileClassSignature",
            "ColorSpace": "cmsColorSpaceSignature",
            "PCS": "cmsColorSpaceSignature",
            "RenderingIntent": "cmsUInt32Number",
            "platform": "cmsPlatformSignature",
            "flags": "cmsUInt32Number",
            "manufacturer": "cmsUInt32Number",
            "attributes": "cmsUInt64Number",
            "creator": "cmsUInt32Number",
            "ProfileID": "cmsProfileID",
            "TagCount": "cmsUInt32Number",
            "TagNames[MAX_TABLE_TAG]": "cmsTagSignature",
            "TagLinked[MAX_TABLE_TAG]": "cmsTagSignature",
            "TagSizes[MAX_TABLE_TAG]": "cmsUInt32Number",
            "TagOffsets[MAX_TABLE_TAG]": "cmsUInt32Number",
            "TagSaveAsRaw[MAX_TABLE_TAG]": "cmsBool",
            "*                   TagPtrs[MAX_TABLE_TAG]": "void",
            "*       TagTypeHandlers[MAX_TABLE_TAG]": "cmsTagTypeHandler",
            "IsWrite": "cmsBool",
            "*                   UsrMutex": "void"
          },
          "_cmsICCPROFILE",
          [
            803,
            0
          ],
          [
            849,
            17
          ]
        ],
        [
          "struct _cms_curve_struct {\n\n    cmsInterpParams*  InterpParams;  // Private optimizations for interpolation\n\n    cmsUInt32Number   nSegments;     // Number of segments in the curve. Zero for a 16-bit based tables\n    cmsCurveSegment*  Segments;      // The segments\n    cmsInterpParams** SegInterp;     // Array of private optimizations for interpolation in table-based segments\n\n    cmsParametricCurveEvaluator* Evals;  // Evaluators (one per segment)\n\n    // 16 bit Table-based representation follows\n    cmsUInt32Number    nEntries;      // Number of table elements\n    cmsUInt16Number*   Table16;       // The table itself.\n}",
          {
            "*  InterpParams": "cmsInterpParams",
            "nSegments": "cmsUInt32Number",
            "*  Segments": "cmsCurveSegment",
            "** SegInterp": "cmsInterpParams",
            "* Evals": "cmsParametricCurveEvaluator",
            "nEntries": "cmsUInt32Number",
            "*   Table16": "cmsUInt16Number"
          },
          "_cms_curve_struct",
          [
            878,
            0
          ],
          [
            891,
            1
          ]
        ],
        [
          "struct _cmsStage_struct {\n\n    cmsContext          ContextID;\n\n    cmsStageSignature   Type;           // Identifies the stage\n    cmsStageSignature   Implements;     // Identifies the *function* of the stage (for optimizations)\n\n    cmsUInt32Number     InputChannels;  // Input channels -- for optimization purposes\n    cmsUInt32Number     OutputChannels; // Output channels -- for optimization purposes\n\n    _cmsStageEvalFn     EvalPtr;        // Points to fn that evaluates the stage (always in floating point)\n    _cmsStageDupElemFn  DupElemPtr;     // Points to a fn that duplicates the *data* of the stage\n    _cmsStageFreeElemFn FreePtr;        // Points to a fn that sets the *data* of the stage free\n\n    // A generic pointer to whatever memory needed by the stage\n    void*               Data;\n\n    // Maintains linked list (used internally)\n    struct _cmsStage_struct* Next;\n}",
          {
            "ContextID": "cmsContext",
            "Type": "cmsStageSignature",
            "Implements": "cmsStageSignature",
            "InputChannels": "cmsUInt32Number",
            "OutputChannels": "cmsUInt32Number",
            "EvalPtr": "_cmsStageEvalFn",
            "DupElemPtr": "_cmsStageDupElemFn",
            "FreePtr": "_cmsStageFreeElemFn",
            "*               Data": "void",
            "* Next": "struct _cmsStage_struct"
          },
          "_cmsStage_struct",
          [
            897,
            0
          ],
          [
            916,
            1
          ]
        ],
        [
          "struct _cmsPipeline_struct {\n\n    cmsStage* Elements;                                // Points to elements chain\n    cmsUInt32Number InputChannels, OutputChannels;\n\n    // Data & evaluators\n    void *Data;\n\n   _cmsPipelineEval16Fn    Eval16Fn;\n   _cmsPipelineEvalFloatFn EvalFloatFn;\n   _cmsFreeUserDataFn      FreeDataFn;\n   _cmsDupUserDataFn       DupDataFn;\n\n    cmsContext ContextID;            // Environment\n\n    cmsBool  SaveAs8Bits;            // Implementation-specific: save as 8 bits if possible\n}",
          {
            "* Elements": "cmsStage",
            "InputChannels": "cmsUInt32Number",
            "*Data": "void",
            "Eval16Fn": "_cmsPipelineEval16Fn",
            "EvalFloatFn": "_cmsPipelineEvalFloatFn",
            "FreeDataFn": "_cmsFreeUserDataFn",
            "DupDataFn": "_cmsDupUserDataFn",
            "ContextID": "cmsContext",
            "SaveAs8Bits": "cmsBool"
          },
          "_cmsPipeline_struct",
          [
            939,
            0
          ],
          [
            955,
            1
          ]
        ],
        [
          "typedef struct {\n\n    // 1-pixel cache (16 bits only)\n    cmsUInt16Number CacheIn[cmsMAXCHANNELS];\n    cmsUInt16Number CacheOut[cmsMAXCHANNELS];\n\n} _cmsCACHE;",
          {
            "CacheIn[cmsMAXCHANNELS]": "cmsUInt16Number",
            "CacheOut[cmsMAXCHANNELS]": "cmsUInt16Number"
          },
          "_cmsCACHE",
          [
            1045,
            0
          ],
          [
            1051,
            12
          ]
        ],
        [
          "typedef struct _cmstransform_struct {\n\n    cmsUInt32Number InputFormat, OutputFormat; // Keep formats for further reference\n\n    // Points to transform code\n    _cmsTransform2Fn xform;\n\n    // Formatters, cannot be embedded into LUT because cache\n    cmsFormatter16 FromInput;\n    cmsFormatter16 ToOutput;\n\n    cmsFormatterFloat FromInputFloat;\n    cmsFormatterFloat ToOutputFloat;\n\n    // 1-pixel cache seed for zero as input (16 bits, read only)\n    _cmsCACHE Cache;\n\n    // A Pipeline holding the full (optimized) transform\n    cmsPipeline* Lut;\n\n    // A Pipeline holding the gamut check. It goes from the input space to bilevel\n    cmsPipeline* GamutCheck;\n\n    // Colorant tables\n    cmsNAMEDCOLORLIST* InputColorant;       // Input Colorant table\n    cmsNAMEDCOLORLIST* OutputColorant;      // Colorant table (for n chans > CMYK)\n\n    // Informational only\n    cmsColorSpaceSignature EntryColorSpace;\n    cmsColorSpaceSignature ExitColorSpace;\n\n    // White points (informative only)\n    cmsCIEXYZ EntryWhitePoint;\n    cmsCIEXYZ ExitWhitePoint;\n\n    // Profiles used to create the transform\n    cmsSEQ* Sequence;\n\n    cmsUInt32Number  dwOriginalFlags;\n    cmsFloat64Number AdaptationState;\n\n    // The intent of this transform. That is usually the last intent in the profilechain, but may differ\n    cmsUInt32Number RenderingIntent;\n\n    // An id that uniquely identifies the running context. May be null.\n    cmsContext ContextID;\n\n    // A user-defined pointer that can be used to store data for transform plug-ins\n    void* UserData;\n    _cmsFreeUserDataFn FreeUserData;\n\n    // A way to provide backwards compatibility with full xform plugins\n    _cmsTransformFn OldXform;\n\n    // A one-worker transform entry for parallelization \n    _cmsTransform2Fn Worker;\n    cmsInt32Number   MaxWorkers;\n    cmsUInt32Number  WorkerFlags;\n\n} _cmsTRANSFORM;",
          {
            "InputFormat": "cmsUInt32Number",
            "xform": "_cmsTransform2Fn",
            "FromInput": "cmsFormatter16",
            "ToOutput": "cmsFormatter16",
            "FromInputFloat": "cmsFormatterFloat",
            "ToOutputFloat": "cmsFormatterFloat",
            "Cache": "_cmsCACHE",
            "* Lut": "cmsPipeline",
            "* GamutCheck": "cmsPipeline",
            "* InputColorant": "cmsNAMEDCOLORLIST",
            "* OutputColorant": "cmsNAMEDCOLORLIST",
            "EntryColorSpace": "cmsColorSpaceSignature",
            "ExitColorSpace": "cmsColorSpaceSignature",
            "EntryWhitePoint": "cmsCIEXYZ",
            "ExitWhitePoint": "cmsCIEXYZ",
            "* Sequence": "cmsSEQ",
            "dwOriginalFlags": "cmsUInt32Number",
            "AdaptationState": "cmsFloat64Number",
            "RenderingIntent": "cmsUInt32Number",
            "ContextID": "cmsContext",
            "* UserData": "void",
            "FreeUserData": "_cmsFreeUserDataFn",
            "OldXform": "_cmsTransformFn",
            "Worker": "_cmsTransform2Fn",
            "MaxWorkers": "cmsInt32Number",
            "WorkerFlags": "cmsUInt32Number"
          },
          "_cmsTRANSFORM",
          [
            1056,
            0
          ],
          [
            1115,
            16
          ]
        ],
        [
          "typedef struct _cmsSubAllocator_chunk_st {\n\n    cmsUInt8Number* Block;\n    cmsUInt32Number BlockSize;\n    cmsUInt32Number Used;\n\n    struct _cmsSubAllocator_chunk_st* next;\n\n} _cmsSubAllocator_chunk;",
          {
            "* Block": "cmsUInt8Number",
            "BlockSize": "cmsUInt32Number",
            "Used": "cmsUInt32Number",
            "* next": "struct _cmsSubAllocator_chunk_st"
          },
          "_cmsSubAllocator_chunk",
          [
            447,
            0
          ],
          [
            455,
            25
          ]
        ],
        [
          "struct _cmsSubAllocator_chunk_st",
          {},
          "",
          [
            453,
            4
          ],
          [
            453,
            36
          ]
        ],
        [
          "typedef struct {\n\n    cmsContext ContextID;\n    _cmsSubAllocator_chunk* h;\n\n} _cmsSubAllocator;",
          {
            "ContextID": "cmsContext",
            "* h": "_cmsSubAllocator_chunk"
          },
          "_cmsSubAllocator",
          [
            458,
            0
          ],
          [
            463,
            19
          ]
        ],
        [
          "typedef struct {\n\n    _cmsMallocFnPtrType     MallocPtr;    \n    _cmsMalloZerocFnPtrType MallocZeroPtr;\n    _cmsFreeFnPtrType       FreePtr;\n    _cmsReallocFnPtrType    ReallocPtr;\n    _cmsCallocFnPtrType     CallocPtr;\n    _cmsDupFnPtrType        DupPtr;\n\n} _cmsMemPluginChunkType;",
          {
            "MallocPtr": "_cmsMallocFnPtrType",
            "MallocZeroPtr": "_cmsMalloZerocFnPtrType",
            "FreePtr": "_cmsFreeFnPtrType",
            "ReallocPtr": "_cmsReallocFnPtrType",
            "CallocPtr": "_cmsCallocFnPtrType",
            "DupPtr": "_cmsDupFnPtrType"
          },
          "_cmsMemPluginChunkType",
          [
            500,
            0
          ],
          [
            509,
            25
          ]
        ],
        [
          "struct _cmsContext_struct {\n    \n    struct _cmsContext_struct* Next;  // Points to next context in the new style\n    _cmsSubAllocator* MemPool;        // The memory pool that stores context data\n    \n    void* chunks[MemoryClientMax];    // array of pointers to client chunks. Memory itself is held in the suballocator.\n                                      // If NULL, then it reverts to global Context0\n\n    _cmsMemPluginChunkType DefaultMemoryManager;  // The allocators used for creating the context itself. Cannot be overridden\n}",
          {
            "* Next": "struct _cmsContext_struct",
            "* MemPool": "_cmsSubAllocator",
            "* chunks[MemoryClientMax]": "void",
            "DefaultMemoryManager": "_cmsMemPluginChunkType"
          },
          "_cmsContext_struct",
          [
            515,
            0
          ],
          [
            524,
            1
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            517,
            4
          ],
          [
            517,
            29
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            528,
            0
          ],
          [
            528,
            25
          ]
        ],
        [
          "typedef struct {\n\n    cmsLogErrorHandlerFunction LogErrorHandler;  // Set to NULL for Context0 fallback\n\n} _cmsLogErrorChunkType;",
          {
            "LogErrorHandler": "cmsLogErrorHandlerFunction"
          },
          "_cmsLogErrorChunkType",
          [
            539,
            0
          ],
          [
            543,
            24
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            549,
            28
          ],
          [
            549,
            53
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            550,
            34
          ],
          [
            550,
            59
          ]
        ],
        [
          "typedef struct {\n   \n    cmsUInt16Number AlarmCodes[cmsMAXCHANNELS];\n\n} _cmsAlarmCodesChunkType;",
          {
            "AlarmCodes[cmsMAXCHANNELS]": "cmsUInt16Number"
          },
          "_cmsAlarmCodesChunkType",
          [
            553,
            0
          ],
          [
            557,
            26
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            563,
            30
          ],
          [
            563,
            55
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            564,
            34
          ],
          [
            564,
            59
          ]
        ],
        [
          "typedef struct {\n    \n    cmsFloat64Number  AdaptationState;\n\n} _cmsAdaptationStateChunkType;",
          {
            "AdaptationState": "cmsFloat64Number"
          },
          "_cmsAdaptationStateChunkType",
          [
            567,
            0
          ],
          [
            571,
            31
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            577,
            35
          ],
          [
            577,
            60
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            578,
            41
          ],
          [
            578,
            66
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            585,
            29
          ],
          [
            585,
            54
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            586,
            35
          ],
          [
            586,
            60
          ]
        ],
        [
          "typedef struct {\n\n    cmsInterpFnFactory Interpolators;\n\n} _cmsInterpPluginChunkType;",
          {
            "Interpolators": "cmsInterpFnFactory"
          },
          "_cmsInterpPluginChunkType",
          [
            589,
            0
          ],
          [
            593,
            28
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            599,
            32
          ],
          [
            599,
            57
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            600,
            38
          ],
          [
            600,
            63
          ]
        ],
        [
          "typedef struct {\n\n    struct _cmsParametricCurvesCollection_st* ParametricCurves;\n\n} _cmsCurvesPluginChunkType;",
          {
            "* ParametricCurves": "struct _cmsParametricCurvesCollection_st"
          },
          "_cmsCurvesPluginChunkType",
          [
            603,
            0
          ],
          [
            607,
            28
          ]
        ],
        [
          "struct _cmsParametricCurvesCollection_st",
          {},
          "",
          [
            605,
            4
          ],
          [
            605,
            44
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            613,
            32
          ],
          [
            613,
            57
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            614,
            60
          ],
          [
            614,
            85
          ]
        ],
        [
          "typedef struct {\n\n    struct _cms_formatters_factory_list* FactoryList;\n\n} _cmsFormattersPluginChunkType;",
          {
            "* FactoryList": "struct _cms_formatters_factory_list"
          },
          "_cmsFormattersPluginChunkType",
          [
            617,
            0
          ],
          [
            621,
            32
          ]
        ],
        [
          "struct _cms_formatters_factory_list",
          {},
          "",
          [
            619,
            4
          ],
          [
            619,
            39
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            627,
            36
          ],
          [
            627,
            61
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            628,
            61
          ],
          [
            628,
            86
          ]
        ],
        [
          "typedef struct {\n\n    struct _cmsTagTypeLinkedList_st* TagTypes;\n\n} _cmsTagTypePluginChunkType;",
          {
            "* TagTypes": "struct _cmsTagTypeLinkedList_st"
          },
          "_cmsTagTypePluginChunkType",
          [
            631,
            0
          ],
          [
            635,
            29
          ]
        ],
        [
          "struct _cmsTagTypeLinkedList_st",
          {},
          "",
          [
            633,
            4
          ],
          [
            633,
            35
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            646,
            33
          ],
          [
            646,
            58
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            647,
            62
          ],
          [
            647,
            87
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            649,
            33
          ],
          [
            649,
            58
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            650,
            62
          ],
          [
            650,
            87
          ]
        ],
        [
          "typedef struct {\n   \n    struct _cmsTagLinkedList_st* Tag;\n\n} _cmsTagPluginChunkType;",
          {
            "* Tag": "struct _cmsTagLinkedList_st"
          },
          "_cmsTagPluginChunkType",
          [
            652,
            0
          ],
          [
            656,
            25
          ]
        ],
        [
          "struct _cmsTagLinkedList_st",
          {},
          "",
          [
            654,
            4
          ],
          [
            654,
            31
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            663,
            29
          ],
          [
            663,
            54
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            664,
            60
          ],
          [
            664,
            85
          ]
        ],
        [
          "typedef struct {\n\n    struct _cms_intents_list* Intents;\n\n} _cmsIntentsPluginChunkType;",
          {
            "* Intents": "struct _cms_intents_list"
          },
          "_cmsIntentsPluginChunkType",
          [
            667,
            0
          ],
          [
            671,
            29
          ]
        ],
        [
          "struct _cms_intents_list",
          {},
          "",
          [
            669,
            4
          ],
          [
            669,
            28
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            678,
            33
          ],
          [
            678,
            58
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            679,
            62
          ],
          [
            679,
            87
          ]
        ],
        [
          "typedef struct {\n\n    struct _cmsOptimizationCollection_st* OptimizationCollection;\n\n} _cmsOptimizationPluginChunkType;",
          {
            "* OptimizationCollection": "struct _cmsOptimizationCollection_st"
          },
          "_cmsOptimizationPluginChunkType",
          [
            682,
            0
          ],
          [
            686,
            34
          ]
        ],
        [
          "struct _cmsOptimizationCollection_st",
          {},
          "",
          [
            684,
            4
          ],
          [
            684,
            40
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            693,
            38
          ],
          [
            693,
            63
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            694,
            47
          ],
          [
            694,
            72
          ]
        ],
        [
          "typedef struct {\n\n    struct _cmsTransformCollection_st* TransformCollection;\n\n} _cmsTransformPluginChunkType;",
          {
            "* TransformCollection": "struct _cmsTransformCollection_st"
          },
          "_cmsTransformPluginChunkType",
          [
            697,
            0
          ],
          [
            701,
            31
          ]
        ],
        [
          "struct _cmsTransformCollection_st",
          {},
          "",
          [
            699,
            4
          ],
          [
            699,
            37
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            707,
            35
          ],
          [
            707,
            60
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            708,
            46
          ],
          [
            708,
            71
          ]
        ],
        [
          "typedef struct {\n\n    _cmsCreateMutexFnPtrType  CreateMutexPtr;\n    _cmsDestroyMutexFnPtrType DestroyMutexPtr;\n    _cmsLockMutexFnPtrType    LockMutexPtr;\n    _cmsUnlockMutexFnPtrType  UnlockMutexPtr;\n\n} _cmsMutexPluginChunkType;",
          {
            "CreateMutexPtr": "_cmsCreateMutexFnPtrType",
            "DestroyMutexPtr": "_cmsDestroyMutexFnPtrType",
            "LockMutexPtr": "_cmsLockMutexFnPtrType",
            "UnlockMutexPtr": "_cmsUnlockMutexFnPtrType"
          },
          "_cmsMutexPluginChunkType",
          [
            711,
            0
          ],
          [
            718,
            27
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            724,
            31
          ],
          [
            724,
            56
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            725,
            46
          ],
          [
            725,
            71
          ]
        ],
        [
          "typedef struct {\n\n    cmsInt32Number      MaxWorkers;       // Number of workers to do as maximum\n    cmsInt32Number      WorkerFlags;      // reserved\n    _cmsTransform2Fn    SchedulerFn;      // callback to setup functions \n    \n} _cmsParallelizationPluginChunkType;",
          {
            "MaxWorkers": "cmsInt32Number",
            "WorkerFlags": "cmsInt32Number",
            "SchedulerFn": "_cmsTransform2Fn"
          },
          "_cmsParallelizationPluginChunkType",
          [
            728,
            0
          ],
          [
            734,
            37
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            740,
            41
          ],
          [
            740,
            66
          ]
        ],
        [
          "struct _cmsContext_struct",
          {},
          "",
          [
            741,
            47
          ],
          [
            741,
            72
          ]
        ],
        [
          "typedef struct {\n\n    cmsUInt16Number Language;\n    cmsUInt16Number Country;\n\n    cmsUInt32Number StrW;       // Offset to current unicode string\n    cmsUInt32Number Len;        // Length in bytes\n\n} _cmsMLUentry;",
          {
            "Language": "cmsUInt16Number",
            "Country": "cmsUInt16Number",
            "StrW": "cmsUInt32Number",
            "Len": "cmsUInt32Number"
          },
          "_cmsMLUentry",
          [
            747,
            0
          ],
          [
            755,
            15
          ]
        ],
        [
          "struct _cms_MLU_struct {\n\n    cmsContext ContextID;\n\n    // The directory\n    cmsUInt32Number  AllocatedEntries;\n    cmsUInt32Number  UsedEntries;\n    _cmsMLUentry* Entries;     // Array of pointers to strings allocated in MemPool\n\n    // The Pool\n    cmsUInt32Number PoolSize;  // The maximum allocated size\n    cmsUInt32Number PoolUsed;  // The used size\n    void*  MemPool;            // Pointer to begin of memory pool\n}",
          {
            "ContextID": "cmsContext",
            "AllocatedEntries": "cmsUInt32Number",
            "UsedEntries": "cmsUInt32Number",
            "* Entries": "_cmsMLUentry",
            "PoolSize": "cmsUInt32Number",
            "PoolUsed": "cmsUInt32Number",
            "*  MemPool": "void"
          },
          "_cms_MLU_struct",
          [
            757,
            0
          ],
          [
            770,
            1
          ]
        ],
        [
          "typedef struct {\n\n    char Name[cmsMAX_PATH];\n    cmsUInt16Number PCS[3];\n    cmsUInt16Number DeviceColorant[cmsMAXCHANNELS];\n\n} _cmsNAMEDCOLOR;",
          {
            "Name[cmsMAX_PATH]": "char",
            "PCS[3]": "cmsUInt16Number",
            "DeviceColorant[cmsMAXCHANNELS]": "cmsUInt16Number"
          },
          "_cmsNAMEDCOLOR",
          [
            773,
            0
          ],
          [
            779,
            17
          ]
        ],
        [
          "struct _cms_NAMEDCOLORLIST_struct {\n\n    cmsUInt32Number nColors;\n    cmsUInt32Number Allocated;\n    cmsUInt32Number ColorantCount;\n\n    char Prefix[33];      // Prefix and suffix are defined to be 32 characters at most\n    char Suffix[33];\n\n    _cmsNAMEDCOLOR* List;\n\n    cmsContext ContextID;\n}",
          {
            "nColors": "cmsUInt32Number",
            "Allocated": "cmsUInt32Number",
            "ColorantCount": "cmsUInt32Number",
            "Prefix[33]": "char",
            "Suffix[33]": "char",
            "* List": "_cmsNAMEDCOLOR",
            "ContextID": "cmsContext"
          },
          "_cms_NAMEDCOLORLIST_struct",
          [
            781,
            0
          ],
          [
            793,
            1
          ]
        ],
        [
          "typedef struct _cms_iccprofile_struct {\n\n    // I/O handler\n    cmsIOHANDLER*            IOhandler;\n\n    // The thread ID\n    cmsContext               ContextID;\n\n    // Creation time\n    struct tm                Created;\n\n    // Color management module identification\n    cmsUInt32Number          CMM;\n\n    // Only most important items found in ICC profiles\n    cmsUInt32Number          Version;\n    cmsProfileClassSignature DeviceClass;\n    cmsColorSpaceSignature   ColorSpace;\n    cmsColorSpaceSignature   PCS;\n    cmsUInt32Number          RenderingIntent;\n\n    cmsPlatformSignature     platform;\n    cmsUInt32Number          flags;\n    cmsUInt32Number          manufacturer, model;\n    cmsUInt64Number          attributes;\n    cmsUInt32Number          creator;\n\n    cmsProfileID             ProfileID;\n\n    // Dictionary\n    cmsUInt32Number          TagCount;\n    cmsTagSignature          TagNames[MAX_TABLE_TAG];\n    cmsTagSignature          TagLinked[MAX_TABLE_TAG];           // The tag to which is linked (0=none)\n    cmsUInt32Number          TagSizes[MAX_TABLE_TAG];            // Size on disk\n    cmsUInt32Number          TagOffsets[MAX_TABLE_TAG];\n    cmsBool                  TagSaveAsRaw[MAX_TABLE_TAG];        // True to write uncooked\n    void *                   TagPtrs[MAX_TABLE_TAG];\n    cmsTagTypeHandler*       TagTypeHandlers[MAX_TABLE_TAG];     // Same structure may be serialized on different types\n                                                                 // depending on profile version, so we keep track of the\n                                                                 // type handler for each tag in the list.\n    // Special\n    cmsBool                  IsWrite;\n\n    // Keep a mutex for cmsReadTag -- Note that this only works if the user includes a mutex plugin\n    void *                   UsrMutex;\n\n} _cmsICCPROFILE;",
          {
            "*            IOhandler": "cmsIOHANDLER",
            "ContextID": "cmsContext",
            "Created": "struct tm",
            "CMM": "cmsUInt32Number",
            "Version": "cmsUInt32Number",
            "DeviceClass": "cmsProfileClassSignature",
            "ColorSpace": "cmsColorSpaceSignature",
            "PCS": "cmsColorSpaceSignature",
            "RenderingIntent": "cmsUInt32Number",
            "platform": "cmsPlatformSignature",
            "flags": "cmsUInt32Number",
            "manufacturer": "cmsUInt32Number",
            "attributes": "cmsUInt64Number",
            "creator": "cmsUInt32Number",
            "ProfileID": "cmsProfileID",
            "TagCount": "cmsUInt32Number",
            "TagNames[MAX_TABLE_TAG]": "cmsTagSignature",
            "TagLinked[MAX_TABLE_TAG]": "cmsTagSignature",
            "TagSizes[MAX_TABLE_TAG]": "cmsUInt32Number",
            "TagOffsets[MAX_TABLE_TAG]": "cmsUInt32Number",
            "TagSaveAsRaw[MAX_TABLE_TAG]": "cmsBool",
            "*                   TagPtrs[MAX_TABLE_TAG]": "void",
            "*       TagTypeHandlers[MAX_TABLE_TAG]": "cmsTagTypeHandler",
            "IsWrite": "cmsBool",
            "*                   UsrMutex": "void"
          },
          "_cmsICCPROFILE",
          [
            803,
            0
          ],
          [
            849,
            17
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            812,
            4
          ],
          [
            812,
            13
          ]
        ],
        [
          "struct _cms_curve_struct {\n\n    cmsInterpParams*  InterpParams;  // Private optimizations for interpolation\n\n    cmsUInt32Number   nSegments;     // Number of segments in the curve. Zero for a 16-bit based tables\n    cmsCurveSegment*  Segments;      // The segments\n    cmsInterpParams** SegInterp;     // Array of private optimizations for interpolation in table-based segments\n\n    cmsParametricCurveEvaluator* Evals;  // Evaluators (one per segment)\n\n    // 16 bit Table-based representation follows\n    cmsUInt32Number    nEntries;      // Number of table elements\n    cmsUInt16Number*   Table16;       // The table itself.\n}",
          {
            "*  InterpParams": "cmsInterpParams",
            "nSegments": "cmsUInt32Number",
            "*  Segments": "cmsCurveSegment",
            "** SegInterp": "cmsInterpParams",
            "* Evals": "cmsParametricCurveEvaluator",
            "nEntries": "cmsUInt32Number",
            "*   Table16": "cmsUInt16Number"
          },
          "_cms_curve_struct",
          [
            878,
            0
          ],
          [
            891,
            1
          ]
        ],
        [
          "struct _cmsStage_struct {\n\n    cmsContext          ContextID;\n\n    cmsStageSignature   Type;           // Identifies the stage\n    cmsStageSignature   Implements;     // Identifies the *function* of the stage (for optimizations)\n\n    cmsUInt32Number     InputChannels;  // Input channels -- for optimization purposes\n    cmsUInt32Number     OutputChannels; // Output channels -- for optimization purposes\n\n    _cmsStageEvalFn     EvalPtr;        // Points to fn that evaluates the stage (always in floating point)\n    _cmsStageDupElemFn  DupElemPtr;     // Points to a fn that duplicates the *data* of the stage\n    _cmsStageFreeElemFn FreePtr;        // Points to a fn that sets the *data* of the stage free\n\n    // A generic pointer to whatever memory needed by the stage\n    void*               Data;\n\n    // Maintains linked list (used internally)\n    struct _cmsStage_struct* Next;\n}",
          {
            "ContextID": "cmsContext",
            "Type": "cmsStageSignature",
            "Implements": "cmsStageSignature",
            "InputChannels": "cmsUInt32Number",
            "OutputChannels": "cmsUInt32Number",
            "EvalPtr": "_cmsStageEvalFn",
            "DupElemPtr": "_cmsStageDupElemFn",
            "FreePtr": "_cmsStageFreeElemFn",
            "*               Data": "void",
            "* Next": "struct _cmsStage_struct"
          },
          "_cmsStage_struct",
          [
            897,
            0
          ],
          [
            916,
            1
          ]
        ],
        [
          "struct _cmsStage_struct",
          {},
          "",
          [
            915,
            4
          ],
          [
            915,
            27
          ]
        ],
        [
          "struct _cmsPipeline_struct {\n\n    cmsStage* Elements;                                // Points to elements chain\n    cmsUInt32Number InputChannels, OutputChannels;\n\n    // Data & evaluators\n    void *Data;\n\n   _cmsPipelineEval16Fn    Eval16Fn;\n   _cmsPipelineEvalFloatFn EvalFloatFn;\n   _cmsFreeUserDataFn      FreeDataFn;\n   _cmsDupUserDataFn       DupDataFn;\n\n    cmsContext ContextID;            // Environment\n\n    cmsBool  SaveAs8Bits;            // Implementation-specific: save as 8 bits if possible\n}",
          {
            "* Elements": "cmsStage",
            "InputChannels": "cmsUInt32Number",
            "*Data": "void",
            "Eval16Fn": "_cmsPipelineEval16Fn",
            "EvalFloatFn": "_cmsPipelineEvalFloatFn",
            "FreeDataFn": "_cmsFreeUserDataFn",
            "DupDataFn": "_cmsDupUserDataFn",
            "ContextID": "cmsContext",
            "SaveAs8Bits": "cmsBool"
          },
          "_cmsPipeline_struct",
          [
            939,
            0
          ],
          [
            955,
            1
          ]
        ],
        [
          "struct _cmstransform_struct",
          {},
          "",
          [
            1043,
            0
          ],
          [
            1043,
            27
          ]
        ],
        [
          "typedef struct {\n\n    // 1-pixel cache (16 bits only)\n    cmsUInt16Number CacheIn[cmsMAXCHANNELS];\n    cmsUInt16Number CacheOut[cmsMAXCHANNELS];\n\n} _cmsCACHE;",
          {
            "CacheIn[cmsMAXCHANNELS]": "cmsUInt16Number",
            "CacheOut[cmsMAXCHANNELS]": "cmsUInt16Number"
          },
          "_cmsCACHE",
          [
            1045,
            0
          ],
          [
            1051,
            12
          ]
        ],
        [
          "typedef struct _cmstransform_struct {\n\n    cmsUInt32Number InputFormat, OutputFormat; // Keep formats for further reference\n\n    // Points to transform code\n    _cmsTransform2Fn xform;\n\n    // Formatters, cannot be embedded into LUT because cache\n    cmsFormatter16 FromInput;\n    cmsFormatter16 ToOutput;\n\n    cmsFormatterFloat FromInputFloat;\n    cmsFormatterFloat ToOutputFloat;\n\n    // 1-pixel cache seed for zero as input (16 bits, read only)\n    _cmsCACHE Cache;\n\n    // A Pipeline holding the full (optimized) transform\n    cmsPipeline* Lut;\n\n    // A Pipeline holding the gamut check. It goes from the input space to bilevel\n    cmsPipeline* GamutCheck;\n\n    // Colorant tables\n    cmsNAMEDCOLORLIST* InputColorant;       // Input Colorant table\n    cmsNAMEDCOLORLIST* OutputColorant;      // Colorant table (for n chans > CMYK)\n\n    // Informational only\n    cmsColorSpaceSignature EntryColorSpace;\n    cmsColorSpaceSignature ExitColorSpace;\n\n    // White points (informative only)\n    cmsCIEXYZ EntryWhitePoint;\n    cmsCIEXYZ ExitWhitePoint;\n\n    // Profiles used to create the transform\n    cmsSEQ* Sequence;\n\n    cmsUInt32Number  dwOriginalFlags;\n    cmsFloat64Number AdaptationState;\n\n    // The intent of this transform. That is usually the last intent in the profilechain, but may differ\n    cmsUInt32Number RenderingIntent;\n\n    // An id that uniquely identifies the running context. May be null.\n    cmsContext ContextID;\n\n    // A user-defined pointer that can be used to store data for transform plug-ins\n    void* UserData;\n    _cmsFreeUserDataFn FreeUserData;\n\n    // A way to provide backwards compatibility with full xform plugins\n    _cmsTransformFn OldXform;\n\n    // A one-worker transform entry for parallelization \n    _cmsTransform2Fn Worker;\n    cmsInt32Number   MaxWorkers;\n    cmsUInt32Number  WorkerFlags;\n\n} _cmsTRANSFORM;",
          {
            "InputFormat": "cmsUInt32Number",
            "xform": "_cmsTransform2Fn",
            "FromInput": "cmsFormatter16",
            "ToOutput": "cmsFormatter16",
            "FromInputFloat": "cmsFormatterFloat",
            "ToOutputFloat": "cmsFormatterFloat",
            "Cache": "_cmsCACHE",
            "* Lut": "cmsPipeline",
            "* GamutCheck": "cmsPipeline",
            "* InputColorant": "cmsNAMEDCOLORLIST",
            "* OutputColorant": "cmsNAMEDCOLORLIST",
            "EntryColorSpace": "cmsColorSpaceSignature",
            "ExitColorSpace": "cmsColorSpaceSignature",
            "EntryWhitePoint": "cmsCIEXYZ",
            "ExitWhitePoint": "cmsCIEXYZ",
            "* Sequence": "cmsSEQ",
            "dwOriginalFlags": "cmsUInt32Number",
            "AdaptationState": "cmsFloat64Number",
            "RenderingIntent": "cmsUInt32Number",
            "ContextID": "cmsContext",
            "* UserData": "void",
            "FreeUserData": "_cmsFreeUserDataFn",
            "OldXform": "_cmsTransformFn",
            "Worker": "_cmsTransform2Fn",
            "MaxWorkers": "cmsInt32Number",
            "WorkerFlags": "cmsUInt32Number"
          },
          "_cmsTRANSFORM",
          [
            1056,
            0
          ],
          [
            1115,
            16
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            1153,
            20
          ],
          [
            1153,
            29
          ]
        ]
      ],
      "include_list": [
        [
          "#   include \"lcms2_plugin.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <float.h>\n",
          [
            109,
            8
          ],
          [
            110,
            0
          ]
        ],
        [
          "#include <windows.h>\n",
          [
            207,
            0
          ],
          [
            208,
            0
          ]
        ],
        [
          "#include <pthread.h>\n",
          [
            323,
            0
          ],
          [
            324,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n\n    UserPtr,            // User-defined pointer\n    Logger,\n    AlarmCodesContext,\n    AdaptationStateContext, \n    MemPlugin,\n    InterpPlugin,\n    CurvesPlugin,\n    FormattersPlugin,\n    TagTypePlugin,\n    TagPlugin,\n    IntentPlugin,\n    MPEPlugin,\n    OptimizationPlugin,\n    TransformPlugin,\n    MutexPlugin,\n    ParallelizationPlugin,\n\n    // Last in list\n    MemoryClientMax\n\n} _cmsMemoryClient;",
          {
            "UserPtr": "",
            "Logger": "",
            "AlarmCodesContext": "",
            "AdaptationStateContext": "",
            "MemPlugin": "",
            "InterpPlugin": "",
            "CurvesPlugin": "",
            "FormattersPlugin": "",
            "TagTypePlugin": "",
            "TagPlugin": "",
            "IntentPlugin": "",
            "MPEPlugin": "",
            "OptimizationPlugin": "",
            "TransformPlugin": "",
            "MutexPlugin": "",
            "ParallelizationPlugin": "",
            "MemoryClientMax": ""
          },
          "_cmsMemoryClient",
          [
            474,
            0
          ],
          [
            496,
            19
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/lcms/testbed/testcms2.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "DebugMemDontCheckThis(void *Ptr)",
          "fn_dec_pos": [
            [
              48,
              5
            ],
            [
              48,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DebugMemDontCheckThis",
            "parameters": {
              "Ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "IsGoodVal(const char *title, cmsFloat64Number in, cmsFloat64Number out, cmsFloat64Number max)",
          "fn_dec_pos": [
            [
              51,
              8
            ],
            [
              51,
              101
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsGoodVal",
            "parameters": {
              "title": "char",
              "in": "cmsFloat64Number",
              "out": "cmsFloat64Number",
              "max": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "IsGoodFixed15_16(const char *title, cmsFloat64Number in, cmsFloat64Number out)",
          "fn_dec_pos": [
            [
              52,
              8
            ],
            [
              52,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsGoodFixed15_16",
            "parameters": {
              "title": "char",
              "in": "cmsFloat64Number",
              "out": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "IsGoodFixed8_8(const char *title, cmsFloat64Number in, cmsFloat64Number out)",
          "fn_dec_pos": [
            [
              53,
              8
            ],
            [
              53,
              84
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsGoodFixed8_8",
            "parameters": {
              "title": "char",
              "in": "cmsFloat64Number",
              "out": "cmsFloat64Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "IsGoodWord(const char *title, cmsUInt16Number in, cmsUInt16Number out)",
          "fn_dec_pos": [
            [
              54,
              8
            ],
            [
              54,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsGoodWord",
            "parameters": {
              "title": "char",
              "in": "cmsUInt16Number",
              "out": "cmsUInt16Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "IsGoodWordPrec(const char *title, cmsUInt16Number in, cmsUInt16Number out, cmsUInt16Number maxErr)",
          "fn_dec_pos": [
            [
              55,
              8
            ],
            [
              55,
              106
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsGoodWordPrec",
            "parameters": {
              "title": "char",
              "in": "cmsUInt16Number",
              "out": "cmsUInt16Number",
              "maxErr": "cmsUInt16Number"
            },
            "return_type": "cmsBool"
          }
        },
        {
          "fn_code": "PluginMemHandler(void)",
          "fn_dec_pos": [
            [
              57,
              6
            ],
            [
              57,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PluginMemHandler",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "WatchDogContext(void* usr)",
          "fn_dec_pos": [
            [
              58,
              11
            ],
            [
              58,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WatchDogContext",
            "parameters": {
              "usr": "void"
            },
            "return_type": "cmsContext"
          }
        },
        {
          "fn_code": "ResetFatalError(void)",
          "fn_dec_pos": [
            [
              60,
              5
            ],
            [
              60,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ResetFatalError",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "Die(const char* Reason, ...)",
          "fn_dec_pos": [
            [
              61,
              5
            ],
            [
              61,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Die",
            "parameters": {
              "Reason": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "Dot(void)",
          "fn_dec_pos": [
            [
              62,
              5
            ],
            [
              62,
              14
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Dot",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "Fail(const char* frm, ...)",
          "fn_dec_pos": [
            [
              63,
              5
            ],
            [
              63,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fail",
            "parameters": {
              "frm": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "SubTest(const char* frm, ...)",
          "fn_dec_pos": [
            [
              64,
              5
            ],
            [
              64,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SubTest",
            "parameters": {
              "frm": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TestMemoryLeaks(cmsBool ok)",
          "fn_dec_pos": [
            [
              65,
              5
            ],
            [
              65,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestMemoryLeaks",
            "parameters": {
              "ok": "cmsBool"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "Say(const char* str)",
          "fn_dec_pos": [
            [
              66,
              5
            ],
            [
              66,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Say",
            "parameters": {
              "str": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "CheckSimpleContext(void)",
          "fn_dec_pos": [
            [
              69,
              15
            ],
            [
              69,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckSimpleContext",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "CheckAllocContext(void)",
          "fn_dec_pos": [
            [
              70,
              15
            ],
            [
              70,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckAllocContext",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "CheckAlarmColorsContext(void)",
          "fn_dec_pos": [
            [
              71,
              15
            ],
            [
              71,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckAlarmColorsContext",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "CheckAdaptationStateContext(void)",
          "fn_dec_pos": [
            [
              72,
              15
            ],
            [
              72,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckAdaptationStateContext",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "CheckInterp1DPlugin(void)",
          "fn_dec_pos": [
            [
              73,
              15
            ],
            [
              73,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckInterp1DPlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "CheckInterp3DPlugin(void)",
          "fn_dec_pos": [
            [
              74,
              15
            ],
            [
              74,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckInterp3DPlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "CheckParametricCurvePlugin(void)",
          "fn_dec_pos": [
            [
              75,
              15
            ],
            [
              75,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckParametricCurvePlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "CheckFormattersPlugin(void)",
          "fn_dec_pos": [
            [
              76,
              15
            ],
            [
              76,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckFormattersPlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "CheckTagTypePlugin(void)",
          "fn_dec_pos": [
            [
              77,
              15
            ],
            [
              77,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckTagTypePlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "CheckMPEPlugin(void)",
          "fn_dec_pos": [
            [
              78,
              15
            ],
            [
              78,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMPEPlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "CheckOptimizationPlugin(void)",
          "fn_dec_pos": [
            [
              79,
              15
            ],
            [
              79,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckOptimizationPlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "CheckIntentPlugin(void)",
          "fn_dec_pos": [
            [
              80,
              15
            ],
            [
              80,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckIntentPlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "CheckTransformPlugin(void)",
          "fn_dec_pos": [
            [
              81,
              15
            ],
            [
              81,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckTransformPlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "CheckMutexPlugin(void)",
          "fn_dec_pos": [
            [
              82,
              15
            ],
            [
              82,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMutexPlugin",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "CheckMethodPackDoublesFromFloat(void)",
          "fn_dec_pos": [
            [
              83,
              15
            ],
            [
              83,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMethodPackDoublesFromFloat",
            "parameters": {},
            "return_type": "cmsInt32Number"
          }
        },
        {
          "fn_code": "CheckProfileZOO(void)",
          "fn_dec_pos": [
            [
              87,
              5
            ],
            [
              87,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckProfileZOO",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"lcms2_internal.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#    include \"crtdbg.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#    include <io.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#    include <direct.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#    include <unistd.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    }
  }
}