{
  "src": {
    "../docker_shared/source_code/c-ares/src/lib/ares_event_kqueue.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares_evsys_kqueue_destroy(ares_event_thread_t *e)\n{\n  ares_evsys_kqueue_t *kq = NULL;\n\n  if (e == NULL) {\n    return;\n  }\n\n  kq = e->ev_sys_data;\n  if (kq == NULL) {\n    return;\n  }\n\n  if (kq->kqueue_fd != -1) {\n    close(kq->kqueue_fd);\n  }\n\n  ares_free(kq->changelist);\n  ares_free(kq);\n  e->ev_sys_data = NULL;\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              72,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_kqueue_destroy",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_kqueue_init(ares_event_thread_t *e)\n{\n  ares_evsys_kqueue_t *kq = NULL;\n\n  kq = ares_malloc_zero(sizeof(*kq));\n  if (kq == NULL) {\n    return ARES_FALSE;\n  }\n\n  e->ev_sys_data = kq;\n\n  kq->kqueue_fd = kqueue();\n  if (kq->kqueue_fd == -1) {\n    ares_evsys_kqueue_destroy(e);\n    return ARES_FALSE;\n  }\n\n#  ifdef FD_CLOEXEC\n  fcntl(kq->kqueue_fd, F_SETFD, FD_CLOEXEC);\n#  endif\n\n  kq->nchanges_alloc = 8;\n  kq->changelist =\n    ares_malloc_zero(sizeof(*kq->changelist) * kq->nchanges_alloc);\n  if (kq->changelist == NULL) {\n    ares_evsys_kqueue_destroy(e);\n    return ARES_FALSE;\n  }\n\n  e->ev_signal = ares_pipeevent_create(e);\n  if (e->ev_signal == NULL) {\n    ares_evsys_kqueue_destroy(e);\n    return ARES_FALSE;\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              74,
              0
            ],
            [
              110,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_kqueue_init",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_kqueue_enqueue(ares_evsys_kqueue_t *kq, int fd,\n                                      int16_t filter, uint16_t flags)\n{\n  size_t idx;\n\n  if (kq == NULL) {\n    return;\n  }\n\n  idx = kq->nchanges;\n\n  kq->nchanges++;\n\n  if (kq->nchanges > kq->nchanges_alloc) {\n    kq->nchanges_alloc <<= 1;\n    kq->changelist = ares_realloc_zero(kq->changelist, kq->nchanges_alloc >> 1,\n                                       kq->nchanges_alloc);\n  }\n\n  EV_SET(&kq->changelist[idx], fd, filter, flags, 0, 0, 0);\n}",
          "fn_code_pos": [
            [
              112,
              0
            ],
            [
              132,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_kqueue_enqueue",
            "parameters": {
              "kq": "ares_evsys_kqueue_t",
              "fd": "int",
              "filter": "int16_t",
              "flags": "uint16_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_evsys_kqueue_event_process(ares_event_t      *event,\n                                            ares_event_flags_t old_flags,\n                                            ares_event_flags_t new_flags)\n{\n  ares_event_thread_t *e = event->e;\n  ares_evsys_kqueue_t *kq;\n\n  if (e == NULL) {\n    return;\n  }\n\n  kq = e->ev_sys_data;\n  if (kq == NULL) {\n    return;\n  }\n\n  if (new_flags & ARES_EVENT_FLAG_READ && !(old_flags & ARES_EVENT_FLAG_READ)) {\n    ares_evsys_kqueue_enqueue(kq, event->fd, EVFILT_READ, EV_ADD | EV_ENABLE);\n  }\n\n  if (!(new_flags & ARES_EVENT_FLAG_READ) && old_flags & ARES_EVENT_FLAG_READ) {\n    ares_evsys_kqueue_enqueue(kq, event->fd, EVFILT_READ, EV_DELETE);\n  }\n\n  if (new_flags & ARES_EVENT_FLAG_WRITE &&\n      !(old_flags & ARES_EVENT_FLAG_WRITE)) {\n    ares_evsys_kqueue_enqueue(kq, event->fd, EVFILT_WRITE, EV_ADD | EV_ENABLE);\n  }\n\n  if (!(new_flags & ARES_EVENT_FLAG_WRITE) &&\n      old_flags & ARES_EVENT_FLAG_WRITE) {\n    ares_evsys_kqueue_enqueue(kq, event->fd, EVFILT_WRITE, EV_DELETE);\n  }\n}",
          "fn_code_pos": [
            [
              134,
              0
            ],
            [
              167,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_kqueue_event_process",
            "parameters": {
              "event": "ares_event_t",
              "old_flags": "ares_event_flags_t",
              "new_flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_kqueue_event_add(ares_event_t *event)\n{\n  ares_evsys_kqueue_event_process(event, 0, event->flags);\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              169,
              0
            ],
            [
              173,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_kqueue_event_add",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_kqueue_event_del(ares_event_t *event)\n{\n  ares_evsys_kqueue_event_process(event, event->flags, 0);\n}",
          "fn_code_pos": [
            [
              175,
              0
            ],
            [
              178,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_kqueue_event_del",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_evsys_kqueue_event_mod(ares_event_t      *event,\n                                        ares_event_flags_t new_flags)\n{\n  ares_evsys_kqueue_event_process(event, event->flags, new_flags);\n}",
          "fn_code_pos": [
            [
              180,
              0
            ],
            [
              184,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_kqueue_event_mod",
            "parameters": {
              "event": "ares_event_t",
              "new_flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static size_t ares_evsys_kqueue_wait(ares_event_thread_t *e,\n                                     unsigned long        timeout_ms)\n{\n  struct kevent        events[8];\n  size_t               nevents = sizeof(events) / sizeof(*events);\n  ares_evsys_kqueue_t *kq      = e->ev_sys_data;\n  int                  rv;\n  size_t               i;\n  struct timespec      ts;\n  struct timespec     *timeout = NULL;\n  size_t               cnt     = 0;\n\n  if (timeout_ms != 0) {\n    ts.tv_sec  = timeout_ms / 1000;\n    ts.tv_nsec = (timeout_ms % 1000) * 1000 * 1000;\n    timeout    = &ts;\n  }\n\n  memset(events, 0, sizeof(events));\n\n  rv = kevent(kq->kqueue_fd, kq->changelist, (int)kq->nchanges, events,\n              (int)nevents, timeout);\n  if (rv < 0) {\n    return 0;\n  }\n\n  /* Changelist was consumed */\n  kq->nchanges = 0;\n  nevents      = (size_t)rv;\n\n  for (i = 0; i < nevents; i++) {\n    ares_event_t      *ev;\n    ares_event_flags_t flags = 0;\n\n    ev = ares__htable_asvp_get_direct(e->ev_handles,\n                                      (ares_socket_t)events[i].ident);\n    if (ev == NULL || ev->cb == NULL) {\n      continue;\n    }\n\n    cnt++;\n\n    if (events[i].filter == EVFILT_READ ||\n        events[i].flags & (EV_EOF | EV_ERROR)) {\n      flags |= ARES_EVENT_FLAG_READ;\n    } else {\n      flags |= ARES_EVENT_FLAG_WRITE;\n    }\n\n    ev->cb(e, ev->fd, ev->data, flags);\n  }\n\n  return cnt;\n}",
          "fn_code_pos": [
            [
              186,
              0
            ],
            [
              239,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_kqueue_wait",
            "parameters": {
              "e": "ares_event_thread_t",
              "timeout_ms": "unsigned long"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  int            kqueue_fd;\n  struct kevent *changelist;\n  size_t         nchanges;\n  size_t         nchanges_alloc;\n} ares_evsys_kqueue_t;",
          {
            "kqueue_fd": "int",
            "*changelist": "struct kevent",
            "nchanges": "size_t",
            "nchanges_alloc": "size_t"
          },
          "ares_evsys_kqueue_t",
          [
            45,
            0
          ],
          [
            50,
            22
          ]
        ],
        [
          "typedef struct {\n  int            kqueue_fd;\n  struct kevent *changelist;\n  size_t         nchanges;\n  size_t         nchanges_alloc;\n} ares_evsys_kqueue_t;",
          {
            "kqueue_fd": "int",
            "*changelist": "struct kevent",
            "nchanges": "size_t",
            "nchanges_alloc": "size_t"
          },
          "ares_evsys_kqueue_t",
          [
            45,
            0
          ],
          [
            50,
            22
          ]
        ],
        [
          "struct kevent",
          {},
          "",
          [
            47,
            2
          ],
          [
            47,
            15
          ]
        ],
        [
          "struct kevent",
          {},
          "",
          [
            189,
            2
          ],
          [
            189,
            15
          ]
        ],
        [
          "struct timespec",
          {},
          "",
          [
            194,
            2
          ],
          [
            194,
            17
          ]
        ],
        [
          "struct timespec",
          {},
          "",
          [
            195,
            2
          ],
          [
            195,
            17
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_event.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <sys/types.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#  include <sys/event.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <sys/time.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#  include <fcntl.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__buf.c": {
      "fn_def_list": [
        {
          "fn_code": "ares__buf_t *ares__buf_create(void)\n{\n  ares__buf_t *buf = ares_malloc_zero(sizeof(*buf));\n  if (buf == NULL) {\n    return NULL;\n  }\n\n  buf->tag_offset = SIZE_MAX;\n  return buf;\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              56,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_create",
            "parameters": {},
            "return_type": "ares__buf_t"
          }
        },
        {
          "fn_code": "ares__buf_t *ares__buf_create_const(const unsigned char *data, size_t data_len)\n{\n  ares__buf_t *buf;\n\n  if (data == NULL || data_len == 0) {\n    return NULL;\n  }\n\n  buf = ares__buf_create();\n  if (buf == NULL) {\n    return NULL;\n  }\n\n  buf->data     = data;\n  buf->data_len = data_len;\n\n  return buf;\n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              75,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_create_const",
            "parameters": {
              "data": "unsigned char",
              "data_len": "size_t"
            },
            "return_type": "ares__buf_t"
          }
        },
        {
          "fn_code": "void ares__buf_destroy(ares__buf_t *buf)\n{\n  if (buf == NULL) {\n    return;\n  }\n  ares_free(buf->alloc_buf);\n  ares_free(buf);\n}",
          "fn_code_pos": [
            [
              77,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_destroy",
            "parameters": {
              "buf": "ares__buf_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares__buf_is_const(const ares__buf_t *buf)\n{\n  if (buf == NULL) {\n    return ARES_FALSE;\n  }\n\n  if (buf->data != NULL && buf->alloc_buf == NULL) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_is_const",
            "parameters": {
              "buf": "ares__buf_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "void ares__buf_reclaim(ares__buf_t *buf)\n{\n  size_t prefix_size;\n  size_t data_size;\n\n  if (buf == NULL) {\n    return;\n  }\n\n  if (ares__buf_is_const(buf)) {\n    return;\n  }\n\n  /* Silence coverity.  All lengths are zero so would bail out later but\n   * coverity doesn't know this */\n  if (buf->alloc_buf == NULL) {\n    return;\n  }\n\n  if (buf->tag_offset != SIZE_MAX && buf->tag_offset < buf->offset) {\n    prefix_size = buf->tag_offset;\n  } else {\n    prefix_size = buf->offset;\n  }\n\n  if (prefix_size == 0) {\n    return;\n  }\n\n  data_size = buf->data_len - prefix_size;\n\n  memmove(buf->alloc_buf, buf->alloc_buf + prefix_size, data_size);\n  buf->data      = buf->alloc_buf;\n  buf->data_len  = data_size;\n  buf->offset   -= prefix_size;\n  if (buf->tag_offset != SIZE_MAX) {\n    buf->tag_offset -= prefix_size;\n  }\n\n  return;\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              139,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_reclaim",
            "parameters": {
              "buf": "ares__buf_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t ares__buf_ensure_space(ares__buf_t *buf,\n                                            size_t       needed_size)\n{\n  size_t         remaining_size;\n  size_t         alloc_size;\n  unsigned char *ptr;\n\n  if (buf == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (ares__buf_is_const(buf)) {\n    return ARES_EFORMERR;\n  }\n\n  /* When calling ares__buf_finish_str() we end up adding a null terminator,\n   * so we want to ensure the size is always sufficient for this as we don't\n   * want an ARES_ENOMEM at that point */\n  needed_size++;\n\n  /* No need to do an expensive move operation, we have enough to just append */\n  remaining_size = buf->alloc_buf_len - buf->data_len;\n  if (remaining_size >= needed_size) {\n    return ARES_SUCCESS;\n  }\n\n  /* See if just moving consumed data frees up enough space */\n  ares__buf_reclaim(buf);\n\n  remaining_size = buf->alloc_buf_len - buf->data_len;\n  if (remaining_size >= needed_size) {\n    return ARES_SUCCESS;\n  }\n\n  alloc_size = buf->alloc_buf_len;\n\n  /* Not yet started */\n  if (alloc_size == 0) {\n    alloc_size = 16; /* Always shifts 1, so ends up being 32 minimum */\n  }\n\n  /* Increase allocation by powers of 2 */\n  do {\n    alloc_size     <<= 1;\n    remaining_size   = alloc_size - buf->data_len;\n  } while (remaining_size < needed_size);\n\n  ptr = ares_realloc(buf->alloc_buf, alloc_size);\n  if (ptr == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  buf->alloc_buf     = ptr;\n  buf->alloc_buf_len = alloc_size;\n  buf->data          = ptr;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              141,
              0
            ],
            [
              198,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_ensure_space",
            "parameters": {
              "buf": "ares__buf_t",
              "needed_size": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_set_length(ares__buf_t *buf, size_t len)\n{\n  if (buf == NULL || ares__buf_is_const(buf)) {\n    return ARES_EFORMERR;\n  }\n\n  if (len >= buf->alloc_buf_len - buf->offset) {\n    return ARES_EFORMERR;\n  }\n\n  buf->data_len = len;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              200,
              0
            ],
            [
              212,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_set_length",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_append(ares__buf_t *buf, const unsigned char *data,\n                               size_t data_len)\n{\n  ares_status_t status;\n\n  if (data == NULL || data_len == 0) {\n    return ARES_EFORMERR;\n  }\n\n  status = ares__buf_ensure_space(buf, data_len);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  memcpy(buf->alloc_buf + buf->data_len, data, data_len);\n  buf->data_len += data_len;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              214,
              0
            ],
            [
              231,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_append",
            "parameters": {
              "buf": "ares__buf_t",
              "data": "unsigned char",
              "data_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_append_byte(ares__buf_t *buf, unsigned char byte)\n{\n  return ares__buf_append(buf, &byte, 1);\n}",
          "fn_code_pos": [
            [
              233,
              0
            ],
            [
              236,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_append_byte",
            "parameters": {
              "buf": "ares__buf_t",
              "byte": "unsigned char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_append_be16(ares__buf_t *buf, unsigned short u16)\n{\n  ares_status_t status;\n\n  status = ares__buf_append_byte(buf, (unsigned char)((u16 >> 8) & 0xff));\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares__buf_append_byte(buf, (unsigned char)(u16 & 0xff));\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              238,
              0
            ],
            [
              253,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_append_be16",
            "parameters": {
              "buf": "ares__buf_t",
              "u16": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_append_be32(ares__buf_t *buf, unsigned int u32)\n{\n  ares_status_t status;\n\n  status = ares__buf_append_byte(buf, ((unsigned char)(u32 >> 24) & 0xff));\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares__buf_append_byte(buf, ((unsigned char)(u32 >> 16) & 0xff));\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares__buf_append_byte(buf, ((unsigned char)(u32 >> 8) & 0xff));\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares__buf_append_byte(buf, ((unsigned char)u32 & 0xff));\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              255,
              0
            ],
            [
              280,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_append_be32",
            "parameters": {
              "buf": "ares__buf_t",
              "u32": "unsigned int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "unsigned char *ares__buf_append_start(ares__buf_t *buf, size_t *len)\n{\n  ares_status_t status;\n\n  if (len == NULL || *len == 0) {\n    return NULL;\n  }\n\n  status = ares__buf_ensure_space(buf, *len);\n  if (status != ARES_SUCCESS) {\n    return NULL;\n  }\n\n  /* -1 for possible null terminator for ares__buf_finish_str() */\n  *len = buf->alloc_buf_len - buf->data_len - 1;\n  return buf->alloc_buf + buf->data_len;\n}",
          "fn_code_pos": [
            [
              282,
              0
            ],
            [
              298,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_append_start",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void ares__buf_append_finish(ares__buf_t *buf, size_t len)\n{\n  if (buf == NULL) {\n    return;\n  }\n\n  buf->data_len += len;\n}",
          "fn_code_pos": [
            [
              300,
              0
            ],
            [
              307,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_append_finish",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "unsigned char *ares__buf_finish_bin(ares__buf_t *buf, size_t *len)\n{\n  unsigned char *ptr = NULL;\n  if (buf == NULL || len == NULL || ares__buf_is_const(buf)) {\n    return NULL;\n  }\n\n  ares__buf_reclaim(buf);\n\n  /* We don't want to return NULL except on failure, may be zero-length */\n  if (buf->alloc_buf == NULL &&\n      ares__buf_ensure_space(buf, 1) != ARES_SUCCESS) {\n    return NULL;\n  }\n  ptr  = buf->alloc_buf;\n  *len = buf->data_len;\n  ares_free(buf);\n  return ptr;\n}",
          "fn_code_pos": [
            [
              309,
              0
            ],
            [
              327,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_finish_bin",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "char *ares__buf_finish_str(ares__buf_t *buf, size_t *len)\n{\n  char  *ptr;\n  size_t mylen;\n\n  ptr = (char *)ares__buf_finish_bin(buf, &mylen);\n  if (ptr == NULL) {\n    return NULL;\n  }\n\n  if (len != NULL) {\n    *len = mylen;\n  }\n\n  /* NOTE: ensured via ares__buf_ensure_space() that there is always at least\n   *       1 extra byte available for this specific use-case */\n  ptr[mylen] = 0;\n\n  return ptr;\n}",
          "fn_code_pos": [
            [
              329,
              0
            ],
            [
              348,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_finish_str",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "void ares__buf_tag(ares__buf_t *buf)\n{\n  if (buf == NULL) {\n    return;\n  }\n\n  buf->tag_offset = buf->offset;\n}",
          "fn_code_pos": [
            [
              350,
              0
            ],
            [
              357,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_tag",
            "parameters": {
              "buf": "ares__buf_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_tag_rollback(ares__buf_t *buf)\n{\n  if (buf == NULL || buf->tag_offset == SIZE_MAX) {\n    return ARES_EFORMERR;\n  }\n\n  buf->offset     = buf->tag_offset;\n  buf->tag_offset = SIZE_MAX;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              359,
              0
            ],
            [
              368,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_tag_rollback",
            "parameters": {
              "buf": "ares__buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_tag_clear(ares__buf_t *buf)\n{\n  if (buf == NULL || buf->tag_offset == SIZE_MAX) {\n    return ARES_EFORMERR;\n  }\n\n  buf->tag_offset = SIZE_MAX;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              370,
              0
            ],
            [
              378,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_tag_clear",
            "parameters": {
              "buf": "ares__buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "const unsigned char *ares__buf_tag_fetch(const ares__buf_t *buf, size_t *len)\n{\n  if (buf == NULL || buf->tag_offset == SIZE_MAX || len == NULL) {\n    return NULL;\n  }\n\n  *len = buf->offset - buf->tag_offset;\n  return buf->data + buf->tag_offset;\n}",
          "fn_code_pos": [
            [
              380,
              0
            ],
            [
              388,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_tag_fetch",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "size_t ares__buf_tag_length(const ares__buf_t *buf)\n{\n  if (buf == NULL || buf->tag_offset == SIZE_MAX) {\n    return 0;\n  }\n  return buf->offset - buf->tag_offset;\n}",
          "fn_code_pos": [
            [
              390,
              0
            ],
            [
              396,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_tag_length",
            "parameters": {
              "buf": "ares__buf_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_tag_fetch_bytes(const ares__buf_t *buf,\n                                        unsigned char *bytes, size_t *len)\n{\n  size_t               ptr_len = 0;\n  const unsigned char *ptr     = ares__buf_tag_fetch(buf, &ptr_len);\n\n  if (ptr == NULL || bytes == NULL || len == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (*len < ptr_len) {\n    return ARES_EFORMERR;\n  }\n\n  *len = ptr_len;\n\n  if (ptr_len > 0) {\n    memcpy(bytes, ptr, ptr_len);\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              398,
              0
            ],
            [
              418,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_tag_fetch_bytes",
            "parameters": {
              "buf": "ares__buf_t",
              "bytes": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_tag_fetch_string(const ares__buf_t *buf, char *str,\n                                         size_t len)\n{\n  size_t        out_len;\n  ares_status_t status;\n  size_t        i;\n\n  if (str == NULL || len == 0) {\n    return ARES_EFORMERR;\n  }\n\n  /* Space for NULL terminator */\n  out_len = len - 1;\n\n  status = ares__buf_tag_fetch_bytes(buf, (unsigned char *)str, &out_len);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* NULL terminate */\n  str[out_len] = 0;\n\n  /* Validate string is printable */\n  for (i = 0; i < out_len; i++) {\n    if (!ares__isprint(str[i])) {\n      return ARES_EBADSTR;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              420,
              0
            ],
            [
              450,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_tag_fetch_string",
            "parameters": {
              "buf": "ares__buf_t",
              "str": "char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static const unsigned char *ares__buf_fetch(const ares__buf_t *buf, size_t *len)\n{\n  if (len != NULL) {\n    *len = 0;\n  }\n\n  if (buf == NULL || len == NULL || buf->data == NULL) {\n    return NULL;\n  }\n\n  *len = buf->data_len - buf->offset;\n  if (*len == 0) {\n    return NULL;\n  }\n\n  return buf->data + buf->offset;\n}",
          "fn_code_pos": [
            [
              452,
              0
            ],
            [
              468,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_fetch",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_consume(ares__buf_t *buf, size_t len)\n{\n  size_t remaining_len = ares__buf_len(buf);\n\n  if (remaining_len < len) {\n    return ARES_EBADRESP;\n  }\n\n  buf->offset += len;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              470,
              0
            ],
            [
              480,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_consume",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_fetch_be16(ares__buf_t *buf, unsigned short *u16)\n{\n  size_t               remaining_len;\n  const unsigned char *ptr = ares__buf_fetch(buf, &remaining_len);\n  unsigned int         u32;\n\n  if (buf == NULL || u16 == NULL || remaining_len < sizeof(*u16)) {\n    return ARES_EBADRESP;\n  }\n\n  /* Do math in an unsigned int in order to prevent warnings due to automatic\n   * conversion by the compiler from short to int during shifts */\n  u32  = ((unsigned int)(ptr[0]) << 8 | (unsigned int)ptr[1]);\n  *u16 = (unsigned short)(u32 & 0xFFFF);\n\n  return ares__buf_consume(buf, sizeof(*u16));\n}",
          "fn_code_pos": [
            [
              482,
              0
            ],
            [
              498,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_fetch_be16",
            "parameters": {
              "buf": "ares__buf_t",
              "u16": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_fetch_be32(ares__buf_t *buf, unsigned int *u32)\n{\n  size_t               remaining_len;\n  const unsigned char *ptr = ares__buf_fetch(buf, &remaining_len);\n\n  if (buf == NULL || u32 == NULL || remaining_len < sizeof(*u32)) {\n    return ARES_EBADRESP;\n  }\n\n  *u32 = ((unsigned int)(ptr[0]) << 24 | (unsigned int)(ptr[1]) << 16 |\n          (unsigned int)(ptr[2]) << 8 | (unsigned int)(ptr[3]));\n\n  return ares__buf_consume(buf, sizeof(*u32));\n}",
          "fn_code_pos": [
            [
              500,
              0
            ],
            [
              513,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_fetch_be32",
            "parameters": {
              "buf": "ares__buf_t",
              "u32": "unsigned int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_fetch_bytes(ares__buf_t *buf, unsigned char *bytes,\n                                    size_t len)\n{\n  size_t               remaining_len;\n  const unsigned char *ptr = ares__buf_fetch(buf, &remaining_len);\n\n  if (buf == NULL || bytes == NULL || len == 0 || remaining_len < len) {\n    return ARES_EBADRESP;\n  }\n\n  memcpy(bytes, ptr, len);\n  return ares__buf_consume(buf, len);\n}",
          "fn_code_pos": [
            [
              515,
              0
            ],
            [
              527,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_fetch_bytes",
            "parameters": {
              "buf": "ares__buf_t",
              "bytes": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_fetch_bytes_dup(ares__buf_t *buf, size_t len,\n                                        ares_bool_t     null_term,\n                                        unsigned char **bytes)\n{\n  size_t               remaining_len;\n  const unsigned char *ptr = ares__buf_fetch(buf, &remaining_len);\n\n  if (buf == NULL || bytes == NULL || len == 0 || remaining_len < len) {\n    return ARES_EBADRESP;\n  }\n\n  *bytes = ares_malloc(null_term ? len + 1 : len);\n  if (*bytes == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  memcpy(*bytes, ptr, len);\n  if (null_term) {\n    (*bytes)[len] = 0;\n  }\n  return ares__buf_consume(buf, len);\n}",
          "fn_code_pos": [
            [
              529,
              0
            ],
            [
              550,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_fetch_bytes_dup",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t",
              "null_term": "ares_bool_t",
              "bytes": "unsigned char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_fetch_str_dup(ares__buf_t *buf, size_t len, char **str)\n{\n  size_t               remaining_len;\n  const unsigned char *ptr = ares__buf_fetch(buf, &remaining_len);\n\n  if (buf == NULL || str == NULL || len == 0 || remaining_len < len) {\n    return ARES_EBADRESP;\n  }\n\n  *str = ares_malloc(len + 1);\n  if (*str == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  memcpy(*str, ptr, len);\n  (*str)[len] = 0;\n\n  return ares__buf_consume(buf, len);\n}",
          "fn_code_pos": [
            [
              552,
              0
            ],
            [
              570,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_fetch_str_dup",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t",
              "str": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_fetch_bytes_into_buf(ares__buf_t *buf,\n                                             ares__buf_t *dest, size_t len)\n{\n  size_t               remaining_len;\n  const unsigned char *ptr = ares__buf_fetch(buf, &remaining_len);\n  ares_status_t        status;\n\n  if (buf == NULL || dest == NULL || len == 0 || remaining_len < len) {\n    return ARES_EBADRESP;\n  }\n\n  status = ares__buf_append(dest, ptr, len);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return ares__buf_consume(buf, len);\n}",
          "fn_code_pos": [
            [
              572,
              0
            ],
            [
              589,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_fetch_bytes_into_buf",
            "parameters": {
              "buf": "ares__buf_t",
              "dest": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares__is_whitespace(unsigned char c,\n                                       ares_bool_t   include_linefeed)\n{\n  switch (c) {\n    case '\\r':\n    case '\\t':\n    case ' ':\n    case '\\v':\n    case '\\f':\n      return ARES_TRUE;\n    case '\\n':\n      return include_linefeed;\n    default:\n      break;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              591,
              0
            ],
            [
              607,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__is_whitespace",
            "parameters": {
              "c": "unsigned char",
              "include_linefeed": "ares_bool_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "size_t ares__buf_consume_whitespace(ares__buf_t *buf,\n                                    ares_bool_t  include_linefeed)\n{\n  size_t               remaining_len = 0;\n  const unsigned char *ptr           = ares__buf_fetch(buf, &remaining_len);\n  size_t               i;\n\n  if (ptr == NULL) {\n    return 0;\n  }\n\n  for (i = 0; i < remaining_len; i++) {\n    if (!ares__is_whitespace(ptr[i], include_linefeed)) {\n      break;\n    }\n  }\n\n  if (i > 0) {\n    ares__buf_consume(buf, i);\n  }\n  return i;\n}",
          "fn_code_pos": [
            [
              609,
              0
            ],
            [
              630,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_consume_whitespace",
            "parameters": {
              "buf": "ares__buf_t",
              "include_linefeed": "ares_bool_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "size_t ares__buf_consume_nonwhitespace(ares__buf_t *buf)\n{\n  size_t               remaining_len = 0;\n  const unsigned char *ptr           = ares__buf_fetch(buf, &remaining_len);\n  size_t               i;\n\n  if (ptr == NULL) {\n    return 0;\n  }\n\n  for (i = 0; i < remaining_len; i++) {\n    if (ares__is_whitespace(ptr[i], ARES_TRUE)) {\n      break;\n    }\n  }\n\n  if (i > 0) {\n    ares__buf_consume(buf, i);\n  }\n  return i;\n}",
          "fn_code_pos": [
            [
              632,
              0
            ],
            [
              652,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_consume_nonwhitespace",
            "parameters": {
              "buf": "ares__buf_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "size_t ares__buf_consume_line(ares__buf_t *buf, ares_bool_t include_linefeed)\n{\n  size_t               remaining_len = 0;\n  const unsigned char *ptr           = ares__buf_fetch(buf, &remaining_len);\n  size_t               i;\n\n  if (ptr == NULL) {\n    return 0;\n  }\n\n  for (i = 0; i < remaining_len; i++) {\n    if (ptr[i] == '\\n') {\n      goto done;\n    }\n  }\n\ndone:\n  if (include_linefeed && i < remaining_len && ptr[i] == '\\n') {\n    i++;\n  }\n\n  if (i > 0) {\n    ares__buf_consume(buf, i);\n  }\n  return i;\n}",
          "fn_code_pos": [
            [
              654,
              0
            ],
            [
              679,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_consume_line",
            "parameters": {
              "buf": "ares__buf_t",
              "include_linefeed": "ares_bool_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "size_t ares__buf_consume_until_charset(ares__buf_t         *buf,\n                                       const unsigned char *charset, size_t len,\n                                       ares_bool_t require_charset)\n{\n  size_t               remaining_len = 0;\n  const unsigned char *ptr           = ares__buf_fetch(buf, &remaining_len);\n  size_t               i;\n  ares_bool_t          found = ARES_FALSE;\n\n  if (ptr == NULL || charset == NULL || len == 0) {\n    return 0;\n  }\n\n  for (i = 0; i < remaining_len; i++) {\n    size_t j;\n    for (j = 0; j < len; j++) {\n      if (ptr[i] == charset[j]) {\n        found = ARES_TRUE;\n        goto done;\n      }\n    }\n  }\n\ndone:\n  if (require_charset && !found) {\n    return 0;\n  }\n\n  if (i > 0) {\n    ares__buf_consume(buf, i);\n  }\n  return i;\n}",
          "fn_code_pos": [
            [
              681,
              0
            ],
            [
              713,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_consume_until_charset",
            "parameters": {
              "buf": "ares__buf_t",
              "charset": "unsigned char",
              "len": "size_t",
              "require_charset": "ares_bool_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "size_t ares__buf_consume_charset(ares__buf_t *buf, const unsigned char *charset,\n                                 size_t len)\n{\n  size_t               remaining_len = 0;\n  const unsigned char *ptr           = ares__buf_fetch(buf, &remaining_len);\n  size_t               i;\n\n  if (ptr == NULL || charset == NULL || len == 0) {\n    return 0;\n  }\n\n  for (i = 0; i < remaining_len; i++) {\n    size_t j;\n    for (j = 0; j < len; j++) {\n      if (ptr[i] == charset[j]) {\n        break;\n      }\n    }\n    /* Not found */\n    if (j == len) {\n      break;\n    }\n  }\n\n  if (i > 0) {\n    ares__buf_consume(buf, i);\n  }\n  return i;\n}",
          "fn_code_pos": [
            [
              715,
              0
            ],
            [
              743,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_consume_charset",
            "parameters": {
              "buf": "ares__buf_t",
              "charset": "unsigned char",
              "len": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static void ares__buf_destroy_cb(void *arg)\n{\n  ares__buf_destroy(arg);\n}",
          "fn_code_pos": [
            [
              745,
              0
            ],
            [
              748,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_destroy_cb",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares__buf_split_isduplicate(ares__llist_t       *list,\n                                               const unsigned char *val,\n                                               size_t               len,\n                                               ares__buf_split_t    flags)\n{\n  ares__llist_node_t *node;\n\n  for (node = ares__llist_node_first(list); node != NULL;\n       node = ares__llist_node_next(node)) {\n    const ares__buf_t   *buf  = ares__llist_node_val(node);\n    size_t               plen = 0;\n    const unsigned char *ptr  = ares__buf_peek(buf, &plen);\n\n    /* Can't be duplicate if lengths mismatch */\n    if (plen != len) {\n      continue;\n    }\n\n    if (flags & ARES_BUF_SPLIT_CASE_INSENSITIVE) {\n      if (ares__memeq_ci(ptr, val, len)) {\n        return ARES_TRUE;\n      }\n    } else {\n      if (memcmp(ptr, val, len) == 0) {\n        return ARES_TRUE;\n      }\n    }\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              750,
              0
            ],
            [
              779,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_split_isduplicate",
            "parameters": {
              "list": "ares__llist_t",
              "val": "unsigned char",
              "len": "size_t",
              "flags": "ares__buf_split_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_split(ares__buf_t *buf, const unsigned char *delims,\n                              size_t delims_len, ares__buf_split_t flags,\n                              size_t max_sections, ares__llist_t **list)\n{\n  ares_status_t status = ARES_SUCCESS;\n  ares_bool_t   first  = ARES_TRUE;\n\n  if (buf == NULL || delims == NULL || delims_len == 0 || list == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *list = ares__llist_create(ares__buf_destroy_cb);\n  if (*list == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  while (ares__buf_len(buf)) {\n    size_t               len = 0;\n    const unsigned char *ptr;\n\n    if (first) {\n      /* No delimiter yet, just tag the start */\n      ares__buf_tag(buf);\n    } else {\n      if (flags & ARES_BUF_SPLIT_DONT_CONSUME_DELIMS) {\n        /* tag then eat delimiter so its first byte in buffer */\n        ares__buf_tag(buf);\n        ares__buf_consume(buf, 1);\n      } else {\n        /* throw away delimiter */\n        ares__buf_consume(buf, 1);\n        ares__buf_tag(buf);\n      }\n    }\n\n    if (max_sections && ares__llist_len(*list) >= max_sections - 1) {\n      ares__buf_consume(buf, ares__buf_len(buf));\n    } else {\n      ares__buf_consume_until_charset(buf, delims, delims_len, ARES_FALSE);\n    }\n\n    ptr = ares__buf_tag_fetch(buf, &len);\n\n    /* Shouldn't be possible */\n    if (ptr == NULL) {\n      status = ARES_EFORMERR;\n      goto done;\n    }\n\n    if (flags & ARES_BUF_SPLIT_LTRIM) {\n      size_t i;\n      for (i = 0; i < len; i++) {\n        if (!ares__is_whitespace(ptr[i], ARES_TRUE)) {\n          break;\n        }\n      }\n      ptr += i;\n      len -= i;\n    }\n\n    if (flags & ARES_BUF_SPLIT_RTRIM) {\n      while (len && ares__is_whitespace(ptr[len - 1], ARES_TRUE)) {\n        len--;\n      }\n    }\n\n    if (len != 0 || flags & ARES_BUF_SPLIT_ALLOW_BLANK) {\n      ares__buf_t *data;\n\n      if (!(flags & ARES_BUF_SPLIT_NO_DUPLICATES) ||\n          !ares__buf_split_isduplicate(*list, ptr, len, flags)) {\n        /* Since we don't allow const buffers of 0 length, and user wants\n         * 0-length buffers, swap what we do here */\n        if (len) {\n          data = ares__buf_create_const(ptr, len);\n        } else {\n          data = ares__buf_create();\n        }\n\n        if (data == NULL) {\n          status = ARES_ENOMEM;\n          goto done;\n        }\n\n        if (ares__llist_insert_last(*list, data) == NULL) {\n          ares__buf_destroy(data);\n          status = ARES_ENOMEM;\n          goto done;\n        }\n      }\n    }\n\n    first = ARES_FALSE;\n  }\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares__llist_destroy(*list);\n    *list = NULL;\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              781,
              0
            ],
            [
              884,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_split",
            "parameters": {
              "buf": "ares__buf_t",
              "delims": "unsigned char",
              "delims_len": "size_t",
              "flags": "ares__buf_split_t",
              "max_sections": "size_t",
              "list": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares__buf_begins_with(const ares__buf_t   *buf,\n                                  const unsigned char *data, size_t data_len)\n{\n  size_t               remaining_len = 0;\n  const unsigned char *ptr           = ares__buf_fetch(buf, &remaining_len);\n\n  if (ptr == NULL || data == NULL || data_len == 0) {\n    return ARES_FALSE;\n  }\n\n  if (data_len > remaining_len) {\n    return ARES_FALSE;\n  }\n\n  if (memcmp(ptr, data, data_len) != 0) {\n    return ARES_FALSE;\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              886,
              0
            ],
            [
              905,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_begins_with",
            "parameters": {
              "buf": "ares__buf_t",
              "data": "unsigned char",
              "data_len": "size_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "size_t ares__buf_len(const ares__buf_t *buf)\n{\n  if (buf == NULL) {\n    return 0;\n  }\n\n  return buf->data_len - buf->offset;\n}",
          "fn_code_pos": [
            [
              907,
              0
            ],
            [
              914,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_len",
            "parameters": {
              "buf": "ares__buf_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "const unsigned char *ares__buf_peek(const ares__buf_t *buf, size_t *len)\n{\n  return ares__buf_fetch(buf, len);\n}",
          "fn_code_pos": [
            [
              916,
              0
            ],
            [
              919,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_peek",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "size_t ares__buf_get_position(const ares__buf_t *buf)\n{\n  if (buf == NULL) {\n    return 0;\n  }\n  return buf->offset;\n}",
          "fn_code_pos": [
            [
              921,
              0
            ],
            [
              927,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_get_position",
            "parameters": {
              "buf": "ares__buf_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_set_position(ares__buf_t *buf, size_t idx)\n{\n  if (buf == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (idx > buf->data_len) {\n    return ARES_EFORMERR;\n  }\n\n  buf->offset = idx;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              929,
              0
            ],
            [
              941,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_set_position",
            "parameters": {
              "buf": "ares__buf_t",
              "idx": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_parse_dns_binstr(ares__buf_t *buf, size_t remaining_len,\n                                         unsigned char **bin, size_t *bin_len,\n                                         ares_bool_t allow_multiple)\n{\n  unsigned char len;\n  ares_status_t status;\n  ares__buf_t  *binbuf   = NULL;\n  size_t        orig_len = ares__buf_len(buf);\n\n  if (buf == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (remaining_len == 0) {\n    return ARES_EBADRESP;\n  }\n\n  binbuf = ares__buf_create();\n  if (binbuf == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  while (orig_len - ares__buf_len(buf) < remaining_len) {\n    status = ares__buf_fetch_bytes(buf, &len, 1);\n    if (status != ARES_SUCCESS) {\n      break;\n    }\n\n    if (len) {\n      /* XXX: Maybe we should scan to make sure it is printable? */\n      if (bin != NULL) {\n        status = ares__buf_fetch_bytes_into_buf(buf, binbuf, len);\n      } else {\n        status = ares__buf_consume(buf, len);\n      }\n      if (status != ARES_SUCCESS) {\n        break;\n      }\n    }\n\n    if (!allow_multiple) {\n      break;\n    }\n  }\n\n\n  if (status != ARES_SUCCESS) {\n    ares__buf_destroy(binbuf);\n  } else {\n    if (bin != NULL) {\n      size_t mylen = 0;\n      /* NOTE: we use ares__buf_finish_str() here as we guarantee NULL\n       *       Termination even though we are technically returning binary data.\n       */\n      *bin     = (unsigned char *)ares__buf_finish_str(binbuf, &mylen);\n      *bin_len = mylen;\n    }\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              943,
              0
            ],
            [
              1003,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_parse_dns_binstr",
            "parameters": {
              "buf": "ares__buf_t",
              "remaining_len": "size_t",
              "bin": "unsigned char",
              "bin_len": "size_t",
              "allow_multiple": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_parse_dns_str(ares__buf_t *buf, size_t remaining_len,\n                                      char **str, ares_bool_t allow_multiple)\n{\n  size_t len;\n  return ares__buf_parse_dns_binstr(buf, remaining_len, (unsigned char **)str,\n                                    &len, allow_multiple);\n}",
          "fn_code_pos": [
            [
              1005,
              0
            ],
            [
              1011,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_parse_dns_str",
            "parameters": {
              "buf": "ares__buf_t",
              "remaining_len": "size_t",
              "str": "char",
              "allow_multiple": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_append_num_dec(ares__buf_t *buf, size_t num, size_t len)\n{\n  size_t i;\n  size_t mod;\n\n  if (len == 0) {\n    len = ares__count_digits(num);\n  }\n\n  mod = ares__pow(10, len);\n\n  for (i = len; i > 0; i--) {\n    size_t        digit = (num % mod);\n    ares_status_t status;\n\n    mod /= 10;\n\n    /* Silence coverity.  Shouldn't be possible since we calculate it above */\n    if (mod == 0) {\n      return ARES_EFORMERR;\n    }\n\n    digit  /= mod;\n    status  = ares__buf_append_byte(buf, '0' + (unsigned char)(digit & 0xFF));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1013,
              0
            ],
            [
              1042,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_append_num_dec",
            "parameters": {
              "buf": "ares__buf_t",
              "num": "size_t",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_append_num_hex(ares__buf_t *buf, size_t num, size_t len)\n{\n  size_t                     i;\n  static const unsigned char hexbytes[] = \"0123456789ABCDEF\";\n\n  if (len == 0) {\n    len = ares__count_hexdigits(num);\n  }\n\n  for (i = len; i > 0; i--) {\n    ares_status_t status;\n    status = ares__buf_append_byte(buf, hexbytes[(num >> ((i - 1) * 4)) & 0xF]);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1044,
              0
            ],
            [
              1061,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_append_num_hex",
            "parameters": {
              "buf": "ares__buf_t",
              "num": "size_t",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_append_str(ares__buf_t *buf, const char *str)\n{\n  return ares__buf_append(buf, (const unsigned char *)str, ares_strlen(str));\n}",
          "fn_code_pos": [
            [
              1063,
              0
            ],
            [
              1066,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_append_str",
            "parameters": {
              "buf": "ares__buf_t",
              "str": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__buf_hexdump_line(ares__buf_t *buf, size_t idx,\n                                            const unsigned char *data,\n                                            size_t               len)\n{\n  size_t        i;\n  ares_status_t status;\n\n  /* Address */\n  status = ares__buf_append_num_hex(buf, idx, 6);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* | */\n  status = ares__buf_append_str(buf, \" | \");\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  for (i = 0; i < 16; i++) {\n    if (i >= len) {\n      status = ares__buf_append_str(buf, \"  \");\n    } else {\n      status = ares__buf_append_num_hex(buf, data[i], 2);\n    }\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    status = ares__buf_append_byte(buf, ' ');\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  /* | */\n  status = ares__buf_append_str(buf, \" | \");\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  for (i = 0; i < 16; i++) {\n    if (i >= len) {\n      break;\n    }\n    status = ares__buf_append_byte(buf, ares__isprint(data[i]) ? data[i] : '.');\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return ares__buf_append_byte(buf, '\\n');\n}",
          "fn_code_pos": [
            [
              1068,
              0
            ],
            [
              1120,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_hexdump_line",
            "parameters": {
              "buf": "ares__buf_t",
              "idx": "size_t",
              "data": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_hexdump(ares__buf_t *buf, const unsigned char *data,\n                                size_t len)\n{\n  size_t i;\n\n  /* Each line is 16 bytes */\n  for (i = 0; i < len; i += 16) {\n    ares_status_t status;\n    status = ares__buf_hexdump_line(buf, i, data + i, len - i);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1122,
              0
            ],
            [
              1137,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_hexdump",
            "parameters": {
              "buf": "ares__buf_t",
              "data": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__buf_load_file(const char *filename, ares__buf_t *buf)\n{\n  FILE          *fp        = NULL;\n  unsigned char *ptr       = NULL;\n  size_t         len       = 0;\n  size_t         ptr_len   = 0;\n  long           ftell_len = 0;\n  ares_status_t  status;\n\n  if (filename == NULL || buf == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  fp = fopen(filename, \"rb\");\n  if (fp == NULL) {\n    int error = ERRNO;\n    switch (error) {\n      case ENOENT:\n      case ESRCH:\n        status = ARES_ENOTFOUND;\n        goto done;\n      default:\n        DEBUGF(fprintf(stderr, \"fopen() failed with error: %d %s\\n\", error,\n                       strerror(error)));\n        DEBUGF(fprintf(stderr, \"Error opening file: %s\\n\", filename));\n        status = ARES_EFILE;\n        goto done;\n    }\n  }\n\n  /* Get length portably, fstat() is POSIX, not C */\n  if (fseek(fp, 0, SEEK_END) != 0) {\n    status = ARES_EFILE;\n    goto done;\n  }\n\n  ftell_len = ftell(fp);\n  if (ftell_len < 0) {\n    status = ARES_EFILE;\n    goto done;\n  }\n  len = (size_t)ftell_len;\n\n  if (fseek(fp, 0, SEEK_SET) != 0) {\n    status = ARES_EFILE;\n    goto done;\n  }\n\n  if (len == 0) {\n    status = ARES_SUCCESS;\n    goto done;\n  }\n\n  /* Read entire data into buffer */\n  ptr_len = len;\n  ptr     = ares__buf_append_start(buf, &ptr_len);\n  if (ptr == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  ptr_len = fread(ptr, 1, len, fp);\n  if (ptr_len != len) {\n    status = ARES_EFILE;\n    goto done;\n  }\n\n  ares__buf_append_finish(buf, len);\n  status = ARES_SUCCESS;\n\ndone:\n  if (fp != NULL) {\n    fclose(fp);\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              1139,
              0
            ],
            [
              1214,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_load_file",
            "parameters": {
              "filename": "char",
              "buf": "ares__buf_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares__buf_create(void)",
          "fn_dec_pos": [
            [
              47,
              13
            ],
            [
              47,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares__buf_create_const(const unsigned char *data, size_t data_len)",
          "fn_dec_pos": [
            [
              58,
              13
            ],
            [
              58,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_create_const",
            "parameters": {
              "data": "unsigned char",
              "data_len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__buf_append_start(ares__buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              282,
              15
            ],
            [
              282,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_append_start",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__buf_finish_bin(ares__buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              309,
              15
            ],
            [
              309,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_finish_bin",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__buf_finish_str(ares__buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              329,
              6
            ],
            [
              329,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_finish_str",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__buf_tag_fetch(const ares__buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              380,
              21
            ],
            [
              380,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_tag_fetch",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__buf_fetch(const ares__buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              452,
              28
            ],
            [
              452,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_fetch",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__buf_peek(const ares__buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              916,
              21
            ],
            [
              916,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_peek",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares__buf {\n  const unsigned char *data;          /*!< pointer to start of data buffer */\n  size_t               data_len;      /*!< total size of data in buffer */\n\n  unsigned char       *alloc_buf;     /*!< Pointer to allocated data buffer,\n                                       *   not used for const buffers */\n  size_t               alloc_buf_len; /*!< Size of allocated data buffer */\n\n  size_t               offset;        /*!< Current working offset in buffer */\n  size_t               tag_offset;    /*!< Tagged offset in buffer. Uses\n                                       *   SIZE_MAX if not set. */\n}",
          {
            "unsigned char": "const",
            "data_len": "size_t",
            "*alloc_buf": "unsigned char",
            "alloc_buf_len": "size_t",
            "offset": "size_t",
            "tag_offset": "size_t"
          },
          "ares__buf",
          [
            34,
            0
          ],
          [
            45,
            1
          ]
        ],
        [
          "struct ares__buf {\n  const unsigned char *data;          /*!< pointer to start of data buffer */\n  size_t               data_len;      /*!< total size of data in buffer */\n\n  unsigned char       *alloc_buf;     /*!< Pointer to allocated data buffer,\n                                       *   not used for const buffers */\n  size_t               alloc_buf_len; /*!< Size of allocated data buffer */\n\n  size_t               offset;        /*!< Current working offset in buffer */\n  size_t               tag_offset;    /*!< Tagged offset in buffer. Uses\n                                       *   SIZE_MAX if not set. */\n}",
          {
            "unsigned char": "const",
            "data_len": "size_t",
            "*alloc_buf": "unsigned char",
            "alloc_buf_len": "size_t",
            "offset": "size_t",
            "tag_offset": "size_t"
          },
          "ares__buf",
          [
            34,
            0
          ],
          [
            45,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares__buf.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#  include <stdint.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__addrinfo2hostent.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_status_t ares__addrinfo2hostent(const struct ares_addrinfo *ai, int family,\n                                     struct hostent **host)\n{\n  struct ares_addrinfo_node  *next;\n  struct ares_addrinfo_cname *next_cname;\n  char                      **aliases  = NULL;\n  char                       *addrs    = NULL;\n  size_t                      naliases = 0;\n  size_t                      naddrs   = 0;\n  size_t                      alias    = 0;\n  size_t                      i;\n\n  if (ai == NULL || host == NULL) {\n    return ARES_EBADQUERY;\n  }\n\n  /* Use the first node of the response as the family, since hostent can only\n   * represent one family.  We assume getaddrinfo() returned a sorted list if\n   * the user requested AF_UNSPEC. */\n  if (family == AF_UNSPEC && ai->nodes) {\n    family = ai->nodes->ai_family;\n  }\n\n  if (family != AF_INET && family != AF_INET6) {\n    return ARES_EBADQUERY;\n  }\n\n  *host = ares_malloc(sizeof(**host));\n  if (!(*host)) {\n    goto enomem;\n  }\n  memset(*host, 0, sizeof(**host));\n\n  next = ai->nodes;\n  while (next) {\n    if (next->ai_family == family) {\n      ++naddrs;\n    }\n    next = next->ai_next;\n  }\n\n  next_cname = ai->cnames;\n  while (next_cname) {\n    if (next_cname->alias) {\n      ++naliases;\n    }\n    next_cname = next_cname->next;\n  }\n\n  aliases = ares_malloc((naliases + 1) * sizeof(char *));\n  if (!aliases) {\n    goto enomem;\n  }\n  (*host)->h_aliases = aliases;\n  memset(aliases, 0, (naliases + 1) * sizeof(char *));\n\n  if (naliases) {\n    for (next_cname = ai->cnames; next_cname != NULL;\n         next_cname = next_cname->next) {\n      if (next_cname->alias == NULL) {\n        continue;\n      }\n      aliases[alias] = ares_strdup(next_cname->alias);\n      if (!aliases[alias]) {\n        goto enomem;\n      }\n      alias++;\n    }\n  }\n\n\n  (*host)->h_addr_list = ares_malloc((naddrs + 1) * sizeof(char *));\n  if (!(*host)->h_addr_list) {\n    goto enomem;\n  }\n\n  memset((*host)->h_addr_list, 0, (naddrs + 1) * sizeof(char *));\n\n  if (ai->cnames) {\n    (*host)->h_name = ares_strdup(ai->cnames->name);\n    if ((*host)->h_name == NULL && ai->cnames->name) {\n      goto enomem;\n    }\n  } else {\n    (*host)->h_name = ares_strdup(ai->name);\n    if ((*host)->h_name == NULL && ai->name) {\n      goto enomem;\n    }\n  }\n\n  (*host)->h_addrtype = (HOSTENT_ADDRTYPE_TYPE)family;\n\n  if (family == AF_INET) {\n    (*host)->h_length = sizeof(struct in_addr);\n  }\n\n  if (family == AF_INET6) {\n    (*host)->h_length = sizeof(struct ares_in6_addr);\n  }\n\n  if (naddrs) {\n    addrs = ares_malloc(naddrs * (size_t)(*host)->h_length);\n    if (!addrs) {\n      goto enomem;\n    }\n\n    i = 0;\n    for (next = ai->nodes; next != NULL; next = next->ai_next) {\n      if (next->ai_family != family) {\n        continue;\n      }\n      (*host)->h_addr_list[i] = addrs + (i * (size_t)(*host)->h_length);\n      if (family == AF_INET6) {\n        memcpy(\n          (*host)->h_addr_list[i],\n          &(CARES_INADDR_CAST(struct sockaddr_in6 *, next->ai_addr)->sin6_addr),\n          (size_t)(*host)->h_length);\n      }\n      if (family == AF_INET) {\n        memcpy(\n          (*host)->h_addr_list[i],\n          &(CARES_INADDR_CAST(struct sockaddr_in *, next->ai_addr)->sin_addr),\n          (size_t)(*host)->h_length);\n      }\n      ++i;\n    }\n\n    if (i == 0) {\n      ares_free(addrs);\n    }\n  }\n\n  if (naddrs == 0 && naliases == 0) {\n    ares_free_hostent(*host);\n    *host = NULL;\n    return ARES_ENODATA;\n  }\n\n  return ARES_SUCCESS;\n\nenomem:\n  ares_free_hostent(*host);\n  *host = NULL;\n  return ARES_ENOMEM;\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              200,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__addrinfo2hostent",
            "parameters": {
              "ai": "struct ares_addrinfo",
              "family": "int",
              "host": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__addrinfo2addrttl(const struct ares_addrinfo *ai, int family,\n                                     size_t                req_naddrttls,\n                                     struct ares_addrttl  *addrttls,\n                                     struct ares_addr6ttl *addr6ttls,\n                                     size_t               *naddrttls)\n{\n  struct ares_addrinfo_node  *next;\n  struct ares_addrinfo_cname *next_cname;\n  int                         cname_ttl = INT_MAX;\n\n  if (family != AF_INET && family != AF_INET6) {\n    return ARES_EBADQUERY;\n  }\n\n  if (ai == NULL || naddrttls == NULL) {\n    return ARES_EBADQUERY;\n  }\n\n  if (family == AF_INET && addrttls == NULL) {\n    return ARES_EBADQUERY;\n  }\n\n  if (family == AF_INET6 && addr6ttls == NULL) {\n    return ARES_EBADQUERY;\n  }\n\n  if (req_naddrttls == 0) {\n    return ARES_EBADQUERY;\n  }\n\n  *naddrttls = 0;\n\n  next_cname = ai->cnames;\n  while (next_cname) {\n    if (next_cname->ttl < cname_ttl) {\n      cname_ttl = next_cname->ttl;\n    }\n    next_cname = next_cname->next;\n  }\n\n  for (next = ai->nodes; next != NULL; next = next->ai_next) {\n    if (next->ai_family != family) {\n      continue;\n    }\n\n    if (*naddrttls >= req_naddrttls) {\n      break;\n    }\n\n    if (family == AF_INET6) {\n      if (next->ai_ttl > cname_ttl) {\n        addr6ttls[*naddrttls].ttl = cname_ttl;\n      } else {\n        addr6ttls[*naddrttls].ttl = next->ai_ttl;\n      }\n\n      memcpy(\n        &addr6ttls[*naddrttls].ip6addr,\n        &(CARES_INADDR_CAST(struct sockaddr_in6 *, next->ai_addr)->sin6_addr),\n        sizeof(struct ares_in6_addr));\n    } else {\n      if (next->ai_ttl > cname_ttl) {\n        addrttls[*naddrttls].ttl = cname_ttl;\n      } else {\n        addrttls[*naddrttls].ttl = next->ai_ttl;\n      }\n      memcpy(\n        &addrttls[*naddrttls].ipaddr,\n        &(CARES_INADDR_CAST(struct sockaddr_in *, next->ai_addr)->sin_addr),\n        sizeof(struct in_addr));\n    }\n    (*naddrttls)++;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              202,
              0
            ],
            [
              277,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__addrinfo2addrttl",
            "parameters": {
              "ai": "struct ares_addrinfo",
              "family": "int",
              "req_naddrttls": "size_t",
              "addrttls": "struct ares_addrttl",
              "addr6ttls": "struct ares_addr6ttl",
              "naddrttls": "size_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            56,
            43
          ],
          [
            56,
            63
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            57,
            37
          ],
          [
            57,
            51
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            59,
            2
          ],
          [
            59,
            27
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            60,
            2
          ],
          [
            60,
            28
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            149,
            31
          ],
          [
            149,
            45
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            153,
            31
          ],
          [
            153,
            51
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            171,
            30
          ],
          [
            171,
            49
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            177,
            30
          ],
          [
            177,
            48
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            202,
            43
          ],
          [
            202,
            63
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            204,
            37
          ],
          [
            204,
            56
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            205,
            37
          ],
          [
            205,
            57
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            208,
            2
          ],
          [
            208,
            27
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            209,
            2
          ],
          [
            209,
            28
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            260,
            28
          ],
          [
            260,
            47
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            261,
            15
          ],
          [
            261,
            35
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            270,
            28
          ],
          [
            270,
            46
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            271,
            15
          ],
          [
            271,
            29
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#  include <limits.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include \"ares_dns.h\"\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_event_epoll.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares_evsys_epoll_destroy(ares_event_thread_t *e)\n{\n  ares_evsys_epoll_t *ep = NULL;\n\n  if (e == NULL) {\n    return;\n  }\n\n  ep = e->ev_sys_data;\n  if (ep == NULL) {\n    return;\n  }\n\n  if (ep->epoll_fd != -1) {\n    close(ep->epoll_fd);\n  }\n\n  ares_free(ep);\n  e->ev_sys_data = NULL;\n}",
          "fn_code_pos": [
            [
              43,
              0
            ],
            [
              62,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_epoll_destroy",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_epoll_init(ares_event_thread_t *e)\n{\n  ares_evsys_epoll_t *ep = NULL;\n\n  ep = ares_malloc_zero(sizeof(*ep));\n  if (ep == NULL) {\n    return ARES_FALSE;\n  }\n\n  e->ev_sys_data = ep;\n\n  ep->epoll_fd = epoll_create1(0);\n  if (ep->epoll_fd == -1) {\n    ares_evsys_epoll_destroy(e);\n    return ARES_FALSE;\n  }\n\n#  ifdef FD_CLOEXEC\n  fcntl(ep->epoll_fd, F_SETFD, FD_CLOEXEC);\n#  endif\n\n  e->ev_signal = ares_pipeevent_create(e);\n  if (e->ev_signal == NULL) {\n    ares_evsys_epoll_destroy(e);\n    return ARES_FALSE;\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              92,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_epoll_init",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_epoll_event_add(ares_event_t *event)\n{\n  const ares_event_thread_t *e  = event->e;\n  const ares_evsys_epoll_t  *ep = e->ev_sys_data;\n  struct epoll_event         epev;\n\n  memset(&epev, 0, sizeof(epev));\n  epev.data.fd = event->fd;\n  epev.events  = EPOLLRDHUP | EPOLLERR | EPOLLHUP;\n  if (event->flags & ARES_EVENT_FLAG_READ) {\n    epev.events |= EPOLLIN;\n  }\n  if (event->flags & ARES_EVENT_FLAG_WRITE) {\n    epev.events |= EPOLLOUT;\n  }\n  if (epoll_ctl(ep->epoll_fd, EPOLL_CTL_ADD, event->fd, &epev) != 0) {\n    return ARES_FALSE;\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              94,
              0
            ],
            [
              113,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_epoll_event_add",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_epoll_event_del(ares_event_t *event)\n{\n  const ares_event_thread_t *e  = event->e;\n  const ares_evsys_epoll_t  *ep = e->ev_sys_data;\n  struct epoll_event         epev;\n\n  memset(&epev, 0, sizeof(epev));\n  epev.data.fd = event->fd;\n  epoll_ctl(ep->epoll_fd, EPOLL_CTL_DEL, event->fd, &epev);\n}",
          "fn_code_pos": [
            [
              115,
              0
            ],
            [
              124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_epoll_event_del",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_evsys_epoll_event_mod(ares_event_t      *event,\n                                       ares_event_flags_t new_flags)\n{\n  const ares_event_thread_t *e  = event->e;\n  const ares_evsys_epoll_t  *ep = e->ev_sys_data;\n  struct epoll_event         epev;\n\n  memset(&epev, 0, sizeof(epev));\n  epev.data.fd = event->fd;\n  epev.events  = EPOLLRDHUP | EPOLLERR | EPOLLHUP;\n  if (new_flags & ARES_EVENT_FLAG_READ) {\n    epev.events |= EPOLLIN;\n  }\n  if (new_flags & ARES_EVENT_FLAG_WRITE) {\n    epev.events |= EPOLLOUT;\n  }\n  epoll_ctl(ep->epoll_fd, EPOLL_CTL_MOD, event->fd, &epev);\n}",
          "fn_code_pos": [
            [
              126,
              0
            ],
            [
              143,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_epoll_event_mod",
            "parameters": {
              "event": "ares_event_t",
              "new_flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static size_t ares_evsys_epoll_wait(ares_event_thread_t *e,\n                                    unsigned long        timeout_ms)\n{\n  struct epoll_event        events[8];\n  size_t                    nevents = sizeof(events) / sizeof(*events);\n  const ares_evsys_epoll_t *ep      = e->ev_sys_data;\n  int                       rv;\n  size_t                    i;\n  size_t                    cnt = 0;\n\n  memset(events, 0, sizeof(events));\n\n  rv = epoll_wait(ep->epoll_fd, events, (int)nevents,\n                  (timeout_ms == 0) ? -1 : (int)timeout_ms);\n  if (rv < 0) {\n    return 0;\n  }\n\n  nevents = (size_t)rv;\n\n  for (i = 0; i < nevents; i++) {\n    ares_event_t      *ev;\n    ares_event_flags_t flags = 0;\n\n    ev = ares__htable_asvp_get_direct(e->ev_handles,\n                                      (ares_socket_t)events[i].data.fd);\n    if (ev == NULL || ev->cb == NULL) {\n      continue;\n    }\n\n    cnt++;\n\n    if (events[i].events & (EPOLLIN | EPOLLRDHUP | EPOLLHUP | EPOLLERR)) {\n      flags |= ARES_EVENT_FLAG_READ;\n    }\n    if (events[i].events & EPOLLOUT) {\n      flags |= ARES_EVENT_FLAG_WRITE;\n    }\n\n    ev->cb(e, ev->fd, ev->data, flags);\n  }\n\n  return cnt;\n}",
          "fn_code_pos": [
            [
              145,
              0
            ],
            [
              188,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_epoll_wait",
            "parameters": {
              "e": "ares_event_thread_t",
              "timeout_ms": "unsigned long"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  int epoll_fd;\n} ares_evsys_epoll_t;",
          {
            "epoll_fd": "int"
          },
          "ares_evsys_epoll_t",
          [
            39,
            0
          ],
          [
            41,
            21
          ]
        ],
        [
          "typedef struct {\n  int epoll_fd;\n} ares_evsys_epoll_t;",
          {
            "epoll_fd": "int"
          },
          "ares_evsys_epoll_t",
          [
            39,
            0
          ],
          [
            41,
            21
          ]
        ],
        [
          "struct epoll_event",
          {},
          "",
          [
            98,
            2
          ],
          [
            98,
            20
          ]
        ],
        [
          "struct epoll_event",
          {},
          "",
          [
            119,
            2
          ],
          [
            119,
            20
          ]
        ],
        [
          "struct epoll_event",
          {},
          "",
          [
            131,
            2
          ],
          [
            131,
            20
          ]
        ],
        [
          "struct epoll_event",
          {},
          "",
          [
            148,
            2
          ],
          [
            148,
            20
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_event.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <sys/epoll.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#  include <fcntl.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/inet_net_pton.c": {
      "fn_def_list": [
        {
          "fn_code": "static int ares_inet_net_pton_ipv4(const char *src, unsigned char *dst,\n                                   size_t size)\n{\n  static const char    xdigits[] = \"0123456789abcdef\";\n  static const char    digits[]  = \"0123456789\";\n  int                  n;\n  int                  ch;\n  int                  tmp = 0;\n  int                  dirty;\n  int                  bits;\n  const unsigned char *odst = dst;\n\n  ch = *src++;\n  if (ch == '0' && (src[0] == 'x' || src[0] == 'X') && ISASCII(src[1]) &&\n      ISXDIGIT(src[1])) {\n    /* Hexadecimal: Eat nybble string. */\n    if (!size) {\n      goto emsgsize;\n    }\n    dirty = 0;\n    src++; /* skip x or X. */\n    while ((ch = *src++) != '\\0' && ISASCII(ch) && ISXDIGIT(ch)) {\n      if (ISUPPER(ch)) {\n        ch = tolower(ch);\n      }\n      n = (int)(strchr(xdigits, ch) - xdigits);\n      if (dirty == 0) {\n        tmp = n;\n      } else {\n        tmp = (tmp << 4) | n;\n      }\n      if (++dirty == 2) {\n        if (!size--) {\n          goto emsgsize;\n        }\n        *dst++ = (unsigned char)tmp;\n        dirty  = 0;\n      }\n    }\n    if (dirty) { /* Odd trailing nybble? */\n      if (!size--) {\n        goto emsgsize;\n      }\n      *dst++ = (unsigned char)(tmp << 4);\n    }\n  } else if (ISASCII(ch) && ISDIGIT(ch)) {\n    /* Decimal: eat dotted digit string. */\n    for (;;) {\n      tmp = 0;\n      do {\n        n    = (int)(strchr(digits, ch) - digits);\n        tmp *= 10;\n        tmp += n;\n        if (tmp > 255) {\n          goto enoent;\n        }\n      } while ((ch = *src++) != '\\0' && ISASCII(ch) && ISDIGIT(ch));\n      if (!size--) {\n        goto emsgsize;\n      }\n      *dst++ = (unsigned char)tmp;\n      if (ch == '\\0' || ch == '/') {\n        break;\n      }\n      if (ch != '.') {\n        goto enoent;\n      }\n      ch = *src++;\n      if (!ISASCII(ch) || !ISDIGIT(ch)) {\n        goto enoent;\n      }\n    }\n  } else {\n    goto enoent;\n  }\n\n  bits = -1;\n  if (ch == '/' && ISASCII(src[0]) && ISDIGIT(src[0]) && dst > odst) {\n    /* CIDR width specifier.  Nothing can follow it. */\n    ch   = *src++; /* Skip over the /. */\n    bits = 0;\n    do {\n      n     = (int)(strchr(digits, ch) - digits);\n      bits *= 10;\n      bits += n;\n      if (bits > 32) {\n        goto enoent;\n      }\n    } while ((ch = *src++) != '\\0' && ISASCII(ch) && ISDIGIT(ch));\n    if (ch != '\\0') {\n      goto enoent;\n    }\n  }\n\n  /* Firey death and destruction unless we prefetched EOS. */\n  if (ch != '\\0') {\n    goto enoent;\n  }\n\n  /* If nothing was written to the destination, we found no address. */\n  if (dst == odst) {\n    goto enoent; /* LCOV_EXCL_LINE: all valid paths above increment dst */\n  }\n  /* If no CIDR spec was given, infer width from net class. */\n  if (bits == -1) {\n    if (*odst >= 240) {        /* Class E */\n      bits = 32;\n    } else if (*odst >= 224) { /* Class D */\n      bits = 8;\n    } else if (*odst >= 192) { /* Class C */\n      bits = 24;\n    } else if (*odst >= 128) { /* Class B */\n      bits = 16;\n    } else {                   /* Class A */\n      bits = 8;\n    }\n    /* If imputed mask is narrower than specified octets, widen. */\n    if (bits < ((dst - odst) * 8)) {\n      bits = (int)(dst - odst) * 8;\n    }\n    /*\n     * If there are no additional bits specified for a class D\n     * address adjust bits to 4.\n     */\n    if (bits == 8 && *odst == 224) {\n      bits = 4;\n    }\n  }\n  /* Extend network to cover the actual mask. */\n  while (bits > ((dst - odst) * 8)) {\n    if (!size--) {\n      goto emsgsize;\n    }\n    *dst++ = '\\0';\n  }\n  return bits;\n\nenoent:\n  SET_ERRNO(ENOENT);\n  return -1;\n\nemsgsize:\n  SET_ERRNO(EMSGSIZE);\n  return -1;\n}",
          "fn_code_pos": [
            [
              61,
              0
            ],
            [
              205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_net_pton_ipv4",
            "parameters": {
              "src": "char",
              "dst": "unsigned char",
              "size": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int getbits(const char *src, size_t *bitsp)\n{\n  static const char digits[] = \"0123456789\";\n  size_t            n;\n  size_t            val;\n  char              ch;\n\n  val = 0;\n  n   = 0;\n  while ((ch = *src++) != '\\0') {\n    const char *pch;\n\n    pch = strchr(digits, ch);\n    if (pch != NULL) {\n      if (n++ != 0 && val == 0) { /* no leading zeros */\n        return 0;\n      }\n      val *= 10;\n      val += (size_t)(pch - digits);\n      if (val > 128) { /* range */\n        return 0;\n      }\n      continue;\n    }\n    return 0;\n  }\n  if (n == 0) {\n    return 0;\n  }\n  *bitsp = val;\n  return 1;\n}",
          "fn_code_pos": [
            [
              207,
              0
            ],
            [
              238,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getbits",
            "parameters": {
              "src": "char",
              "bitsp": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int ares_inet_pton6(const char *src, unsigned char *dst)\n{\n  static const char xdigits_l[] = \"0123456789abcdef\";\n  static const char xdigits_u[] = \"0123456789ABCDEF\";\n  unsigned char     tmp[NS_IN6ADDRSZ];\n  unsigned char    *tp;\n  unsigned char    *endp;\n  unsigned char    *colonp;\n  const char       *xdigits;\n  const char       *curtok;\n  int               ch;\n  int               saw_xdigit;\n  int               count_xdigit;\n  unsigned int      val;\n\n  memset((tp = tmp), '\\0', NS_IN6ADDRSZ);\n  endp   = tp + NS_IN6ADDRSZ;\n  colonp = NULL;\n  /* Leading :: requires some special handling. */\n  if (*src == ':') {\n    if (*++src != ':') {\n      goto enoent;\n    }\n  }\n  curtok     = src;\n  saw_xdigit = count_xdigit = 0;\n  val                       = 0;\n  while ((ch = *src++) != '\\0') {\n    const char *pch;\n\n    if ((pch = strchr((xdigits = xdigits_l), ch)) == NULL) {\n      pch = strchr((xdigits = xdigits_u), ch);\n    }\n    if (pch != NULL) {\n      if (count_xdigit >= 4) {\n        goto enoent;\n      }\n      val <<= 4;\n      val  |= (unsigned int)(pch - xdigits);\n      if (val > 0xffff) {\n        goto enoent;\n      }\n      saw_xdigit = 1;\n      count_xdigit++;\n      continue;\n    }\n    if (ch == ':') {\n      curtok = src;\n      if (!saw_xdigit) {\n        if (colonp) {\n          goto enoent;\n        }\n        colonp = tp;\n        continue;\n      } else if (*src == '\\0') {\n        goto enoent;\n      }\n      if (tp + NS_INT16SZ > endp) {\n        goto enoent;\n      }\n      *tp++        = (unsigned char)(val >> 8) & 0xff;\n      *tp++        = (unsigned char)val & 0xff;\n      saw_xdigit   = 0;\n      count_xdigit = 0;\n      val          = 0;\n      continue;\n    }\n    if (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&\n        ares_inet_net_pton_ipv4(curtok, tp, NS_INADDRSZ) > 0) {\n      tp         += NS_INADDRSZ;\n      saw_xdigit  = 0;\n      break; /* '\\0' was seen by inet_pton4(). */\n    }\n    goto enoent;\n  }\n  if (saw_xdigit) {\n    if (tp + NS_INT16SZ > endp) {\n      goto enoent;\n    }\n    *tp++ = (unsigned char)(val >> 8) & 0xff;\n    *tp++ = (unsigned char)val & 0xff;\n  }\n  if (colonp != NULL) {\n    /*\n     * Since some memmove()'s erroneously fail to handle\n     * overlapping regions, we'll do the shift by hand.\n     */\n    const int n = (int)(tp - colonp);\n    int       i;\n\n    if (tp == endp) {\n      goto enoent;\n    }\n    for (i = 1; i <= n; i++) {\n      endp[-i]      = colonp[n - i];\n      colonp[n - i] = 0;\n    }\n    tp = endp;\n  }\n  if (tp != endp) {\n    goto enoent;\n  }\n\n  memcpy(dst, tmp, NS_IN6ADDRSZ);\n  return 1;\n\nenoent:\n  SET_ERRNO(ENOENT);\n  return -1;\n}",
          "fn_code_pos": [
            [
              240,
              0
            ],
            [
              349,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_pton6",
            "parameters": {
              "src": "char",
              "dst": "unsigned char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int ares_inet_net_pton_ipv6(const char *src, unsigned char *dst,\n                                   size_t size)\n{\n  struct ares_in6_addr in6;\n  int                  ret;\n  size_t               bits;\n  size_t               bytes;\n  char                 buf[INET6_ADDRSTRLEN + sizeof(\"/128\")];\n  char                *sep;\n\n  if (ares_strlen(src) >= sizeof buf) {\n    SET_ERRNO(EMSGSIZE);\n    return -1;\n  }\n  ares_strcpy(buf, src, sizeof buf);\n\n  sep = strchr(buf, '/');\n  if (sep != NULL) {\n    *sep++ = '\\0';\n  }\n\n  ret = ares_inet_pton6(buf, (unsigned char *)&in6);\n  if (ret != 1) {\n    return -1;\n  }\n\n  if (sep == NULL) {\n    bits = 128;\n  } else {\n    if (!getbits(sep, &bits)) {\n      SET_ERRNO(ENOENT);\n      return -1;\n    }\n  }\n\n  bytes = (bits + 7) / 8;\n  if (bytes > size) {\n    SET_ERRNO(EMSGSIZE);\n    return -1;\n  }\n  memcpy(dst, &in6, bytes);\n  return (int)bits;\n}",
          "fn_code_pos": [
            [
              351,
              0
            ],
            [
              393,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_net_pton_ipv6",
            "parameters": {
              "src": "char",
              "dst": "unsigned char",
              "size": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_inet_net_pton(int af, const char *src, void *dst, size_t size)\n{\n  switch (af) {\n    case AF_INET:\n      return ares_inet_net_pton_ipv4(src, dst, size);\n    case AF_INET6:\n      return ares_inet_net_pton_ipv6(src, dst, size);\n    default:\n      SET_ERRNO(EAFNOSUPPORT);\n      return -1;\n  }\n}",
          "fn_code_pos": [
            [
              413,
              0
            ],
            [
              424,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_net_pton",
            "parameters": {
              "af": "int",
              "src": "char",
              "dst": "void",
              "size": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_inet_pton(int af, const char *src, void *dst)\n{\n  int    result;\n  size_t size;\n\n  if (af == AF_INET) {\n    size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    size = sizeof(struct ares_in6_addr);\n  } else {\n    SET_ERRNO(EAFNOSUPPORT);\n    return -1;\n  }\n  result = ares_inet_net_pton(af, src, dst, size);\n  if (result == -1 && ERRNO == ENOENT) {\n    return 0;\n  }\n  return (result > -1) ? 1 : -1;\n}",
          "fn_code_pos": [
            [
              426,
              0
            ],
            [
              444,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_pton",
            "parameters": {
              "af": "int",
              "src": "char",
              "dst": "void"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            37,
            6
          ],
          [
            37,
            26
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            354,
            2
          ],
          [
            354,
            22
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            432,
            18
          ],
          [
            432,
            32
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            434,
            18
          ],
          [
            434,
            38
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include \"ares_ipv6.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_search.c": {
      "fn_def_list": [
        {
          "fn_code": "static void squery_free(struct search_query *squery)\n{\n  if (squery == NULL) {\n    return;\n  }\n  ares__strsplit_free(squery->names, squery->names_cnt);\n  ares_dns_record_destroy(squery->dnsrec);\n  ares_free(squery);\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              64,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "squery_free",
            "parameters": {
              "squery": "struct search_query"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void end_squery(struct search_query *squery, ares_status_t status,\n                       const ares_dns_record_t *dnsrec)\n{\n  squery->callback(squery->arg, status, squery->timeouts, dnsrec);\n  squery_free(squery);\n}",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              74,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "end_squery",
            "parameters": {
              "squery": "struct search_query",
              "status": "ares_status_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t ares_search_next(ares_channel_t      *channel,\n                                      struct search_query *squery,\n                                      ares_bool_t         *skip_cleanup)\n{\n  ares_status_t status;\n\n  *skip_cleanup = ARES_FALSE;\n\n  /* Misuse check */\n  if (squery->next_name_idx >= squery->names_cnt) {\n    return ARES_EFORMERR;\n  }\n\n  status = ares_dns_record_query_set_name(\n    squery->dnsrec, 0, squery->names[squery->next_name_idx++]);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status =\n    ares_send_dnsrec(channel, squery->dnsrec, search_callback, squery, NULL);\n\n  if (status != ARES_EFORMERR) {\n    *skip_cleanup = ARES_TRUE;\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              79,
              0
            ],
            [
              106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_search_next",
            "parameters": {
              "channel": "ares_channel_t",
              "squery": "struct search_query",
              "skip_cleanup": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static void search_callback(void *arg, ares_status_t status, size_t timeouts,\n                            const ares_dns_record_t *dnsrec)\n{\n  struct search_query *squery  = (struct search_query *)arg;\n  ares_channel_t      *channel = squery->channel;\n  ares_dns_rcode_t     rcode;\n  size_t               ancount;\n  ares_status_t        mystatus;\n  ares_bool_t          skip_cleanup = ARES_FALSE;\n\n  squery->timeouts += timeouts;\n\n  if (status != ARES_SUCCESS) {\n    end_squery(squery, status, dnsrec);\n    return;\n  }\n\n  rcode    = ares_dns_record_get_rcode(dnsrec);\n  ancount  = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER);\n  mystatus = ares_dns_query_reply_tostatus(rcode, ancount);\n\n  if (mystatus != ARES_ENODATA && mystatus != ARES_ESERVFAIL &&\n      mystatus != ARES_ENOTFOUND) {\n    end_squery(squery, mystatus, dnsrec);\n    return;\n  }\n\n  /* If we ever get ARES_ENODATA along the way, record that; if the search\n   * should run to the very end and we got at least one ARES_ENODATA,\n   * then callers like ares_gethostbyname() may want to try a T_A search\n   * even if the last domain we queried for T_AAAA resource records\n   * returned ARES_ENOTFOUND.\n   */\n  if (mystatus == ARES_ENODATA) {\n    squery->ever_got_nodata = ARES_TRUE;\n  }\n\n  if (squery->next_name_idx < squery->names_cnt) {\n    mystatus = ares_search_next(channel, squery, &skip_cleanup);\n    if (mystatus != ARES_SUCCESS && !skip_cleanup) {\n      end_squery(squery, mystatus, NULL);\n    }\n    return;\n  }\n\n\n  /* We have no more domains to search, return an appropriate response. */\n  if (mystatus == ARES_ENOTFOUND && squery->ever_got_nodata) {\n    end_squery(squery, ARES_ENODATA, NULL);\n    return;\n  }\n\n  end_squery(squery, mystatus, NULL);\n}",
          "fn_code_pos": [
            [
              108,
              0
            ],
            [
              161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "search_callback",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares__search_eligible(const ares_channel_t *channel,\n                                         const char           *name)\n{\n  size_t len = ares_strlen(name);\n\n  /* Name ends in '.', cannot search */\n  if (len && name[len - 1] == '.') {\n    return ARES_FALSE;\n  }\n\n  if (channel->flags & ARES_FLAG_NOSEARCH) {\n    return ARES_FALSE;\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              165,
              0
            ],
            [
              180,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__search_eligible",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__search_name_list(const ares_channel_t *channel,\n                                     const char *name, char ***names,\n                                     size_t *names_len)\n{\n  ares_status_t status;\n  char        **list     = NULL;\n  size_t        list_len = 0;\n  char         *alias    = NULL;\n  size_t        ndots    = 0;\n  size_t        idx      = 0;\n  const char   *p;\n  size_t        i;\n\n  /* Perform HOSTALIASES resolution */\n  status = ares__lookup_hostaliases(channel, name, &alias);\n  if (status == ARES_SUCCESS) {\n    /* If hostalias succeeds, there is no searching, it is used as-is */\n    list_len = 1;\n    list     = ares_malloc_zero(sizeof(*list) * list_len);\n    if (list == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    list[0] = alias;\n    alias   = NULL;\n    goto done;\n  } else if (status != ARES_ENOTFOUND) {\n    goto done;\n  }\n\n  /* See if searching is eligible at all, if not, look up as-is only */\n  if (!ares__search_eligible(channel, name)) {\n    list_len = 1;\n    list     = ares_malloc_zero(sizeof(*list) * list_len);\n    if (list == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    list[0] = ares_strdup(name);\n    if (list[0] == NULL) {\n      status = ARES_ENOMEM;\n    } else {\n      status = ARES_SUCCESS;\n    }\n    goto done;\n  }\n\n  /* Count the number of dots in name */\n  ndots = 0;\n  for (p = name; *p != 0; p++) {\n    if (*p == '.') {\n      ndots++;\n    }\n  }\n\n  /* Allocate an entry for each search domain, plus one for as-is */\n  list_len = channel->ndomains + 1;\n  list     = ares_malloc_zero(sizeof(*list) * list_len);\n  if (list == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  /* Set status here, its possible there are no search domains at all, so\n   * status may be ARES_ENOTFOUND from ares__lookup_hostaliases(). */\n  status = ARES_SUCCESS;\n\n  /* Try as-is first */\n  if (ndots >= channel->ndots) {\n    list[idx] = ares_strdup(name);\n    if (list[idx] == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    idx++;\n  }\n\n  /* Append each search suffix to the name */\n  for (i = 0; i < channel->ndomains; i++) {\n    status = ares__cat_domain(name, channel->domains[i], &list[idx]);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n    idx++;\n  }\n\n  /* Try as-is last */\n  if (ndots < channel->ndots) {\n    list[idx] = ares_strdup(name);\n    if (list[idx] == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    idx++;\n  }\n\n\ndone:\n  if (status == ARES_SUCCESS) {\n    *names     = list;\n    *names_len = list_len;\n  } else {\n    ares__strsplit_free(list, list_len);\n  }\n\n  ares_free(alias);\n  return status;\n}",
          "fn_code_pos": [
            [
              182,
              0
            ],
            [
              289,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__search_name_list",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "names": "char",
              "names_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_search_int(ares_channel_t          *channel,\n                                     const ares_dns_record_t *dnsrec,\n                                     ares_callback_dnsrec callback, void *arg)\n{\n  struct search_query *squery = NULL;\n  const char          *name;\n  ares_status_t        status       = ARES_SUCCESS;\n  ares_bool_t          skip_cleanup = ARES_FALSE;\n\n  /* Extract the name for the search. Note that searches are only supported for\n   * DNS records containing a single query.\n   */\n  if (ares_dns_record_query_cnt(dnsrec) != 1) {\n    status = ARES_EBADQUERY;\n    goto fail;\n  }\n\n  status = ares_dns_record_query_get(dnsrec, 0, &name, NULL, NULL);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  /* Per RFC 7686, reject queries for \".onion\" domain names with NXDOMAIN. */\n  if (ares__is_onion_domain(name)) {\n    status = ARES_ENOTFOUND;\n    goto fail;\n  }\n\n  /* Allocate a search_query structure to hold the state necessary for\n   * doing multiple lookups.\n   */\n  squery = ares_malloc_zero(sizeof(*squery));\n  if (squery == NULL) {\n    status = ARES_ENOMEM;\n    goto fail;\n  }\n\n  squery->channel = channel;\n\n  /* Duplicate DNS record since, name will need to be rewritten */\n  squery->dnsrec = ares_dns_record_duplicate(dnsrec);\n  if (squery->dnsrec == NULL) {\n    status = ARES_ENOMEM;\n    goto fail;\n  }\n\n  squery->callback        = callback;\n  squery->arg             = arg;\n  squery->timeouts        = 0;\n  squery->ever_got_nodata = ARES_FALSE;\n\n  status =\n    ares__search_name_list(channel, name, &squery->names, &squery->names_cnt);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  status = ares_search_next(channel, squery, &skip_cleanup);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  return status;\n\nfail:\n  if (!skip_cleanup) {\n    squery_free(squery);\n    callback(arg, status, 0, NULL);\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              291,
              0
            ],
            [
              361,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_search_int",
            "parameters": {
              "channel": "ares_channel_t",
              "dnsrec": "ares_dns_record_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void *ares__dnsrec_convert_arg(ares_callback callback, void *arg)\n{\n  dnsrec_convert_arg_t *carg = ares_malloc_zero(sizeof(*carg));\n  if (carg == NULL) {\n    return NULL;\n  }\n  carg->callback = callback;\n  carg->arg      = arg;\n  return carg;\n}",
          "fn_code_pos": [
            [
              371,
              0
            ],
            [
              380,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__dnsrec_convert_arg",
            "parameters": {
              "callback": "ares_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__dnsrec_convert_cb(void *arg, ares_status_t status, size_t timeouts,\n                             const ares_dns_record_t *dnsrec)\n{\n  dnsrec_convert_arg_t *carg = arg;\n  unsigned char        *abuf = NULL;\n  size_t                alen = 0;\n\n  if (dnsrec != NULL) {\n    ares_status_t mystatus = ares_dns_write(dnsrec, &abuf, &alen);\n    if (mystatus != ARES_SUCCESS) {\n      status = mystatus;\n    }\n  }\n\n  carg->callback(carg->arg, (int)status, (int)timeouts, abuf, (int)alen);\n\n  ares_free(abuf);\n  ares_free(carg);\n}",
          "fn_code_pos": [
            [
              386,
              0
            ],
            [
              404,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__dnsrec_convert_cb",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_search(ares_channel_t *channel, const char *name, int dnsclass,\n                 int type, ares_callback callback, void *arg)\n{\n  ares_status_t      status;\n  ares_dns_record_t *dnsrec = NULL;\n  size_t             max_udp_size;\n  ares_dns_flags_t   rd_flag;\n  void              *carg = NULL;\n  if (channel == NULL || name == NULL) {\n    return;\n  }\n\n  /* For now, ares_search_int() uses the ares_callback prototype. We need to\n   * wrap the callback passed to this function in ares__dnsrec_convert_cb, to\n   * convert from ares_callback_dnsrec to ares_callback. Allocate the convert\n   * arg structure here.\n   */\n  carg = ares__dnsrec_convert_arg(callback, arg);\n  if (carg == NULL) {\n    callback(arg, ARES_ENOMEM, 0, NULL, 0);\n    return;\n  }\n\n  rd_flag      = !(channel->flags & ARES_FLAG_NORECURSE) ? ARES_FLAG_RD : 0;\n  max_udp_size = (channel->flags & ARES_FLAG_EDNS) ? channel->ednspsz : 0;\n  status       = ares_dns_record_create_query(\n    &dnsrec, name, (ares_dns_class_t)dnsclass, (ares_dns_rec_type_t)type, 0,\n    rd_flag, max_udp_size);\n  if (status != ARES_SUCCESS) {\n    callback(arg, (int)status, 0, NULL, 0);\n    ares_free(carg);\n    return;\n  }\n\n  ares__channel_lock(channel);\n  ares_search_int(channel, dnsrec, ares__dnsrec_convert_cb, carg);\n  ares__channel_unlock(channel);\n\n  ares_dns_record_destroy(dnsrec);\n}",
          "fn_code_pos": [
            [
              409,
              0
            ],
            [
              448,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_search",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "dnsclass": "int",
              "type": "int",
              "callback": "ares_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_search_dnsrec(ares_channel_t          *channel,\n                                 const ares_dns_record_t *dnsrec,\n                                 ares_callback_dnsrec callback, void *arg)\n{\n  ares_status_t status;\n\n  if (channel == NULL || dnsrec == NULL || callback == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  ares__channel_lock(channel);\n  status = ares_search_int(channel, dnsrec, callback, arg);\n  ares__channel_unlock(channel);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              451,
              0
            ],
            [
              466,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_search_dnsrec",
            "parameters": {
              "channel": "ares_channel_t",
              "dnsrec": "ares_dns_record_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__cat_domain(const char *name, const char *domain, char **s)\n{\n  size_t nlen = ares_strlen(name);\n  size_t dlen = ares_strlen(domain);\n\n  *s = ares_malloc(nlen + 1 + dlen + 1);\n  if (!*s) {\n    return ARES_ENOMEM;\n  }\n  memcpy(*s, name, nlen);\n  (*s)[nlen] = '.';\n  if (strcmp(domain, \".\") == 0) {\n    /* Avoid appending the root domain to the separator, which would set *s to\n       an ill-formed value (ending in two consecutive dots). */\n    dlen = 0;\n  }\n  memcpy(*s + nlen + 1, domain, dlen);\n  (*s)[nlen + 1 + dlen] = 0;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              469,
              0
            ],
            [
              488,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__cat_domain",
            "parameters": {
              "name": "char",
              "domain": "char",
              "s": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__lookup_hostaliases(const ares_channel_t *channel,\n                                       const char *name, char **alias)\n{\n  ares_status_t       status      = ARES_SUCCESS;\n  const char         *hostaliases = NULL;\n  ares__buf_t        *buf         = NULL;\n  ares__llist_t      *lines       = NULL;\n  ares__llist_node_t *node;\n\n  if (channel == NULL || name == NULL || alias == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *alias = NULL;\n\n  /* Configuration says to not perform alias lookup */\n  if (channel->flags & ARES_FLAG_NOALIASES) {\n    return ARES_ENOTFOUND;\n  }\n\n  /* If a domain has a '.', its not allowed to perform an alias lookup */\n  if (strchr(name, '.') != NULL) {\n    return ARES_ENOTFOUND;\n  }\n\n  hostaliases = getenv(\"HOSTALIASES\");\n  if (hostaliases == NULL) {\n    status = ARES_ENOTFOUND;\n    goto done;\n  }\n\n  buf = ares__buf_create();\n  if (buf == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  status = ares__buf_load_file(hostaliases, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* The HOSTALIASES file is structured as one alias per line.  The first\n   * field in the line is the simple hostname with no periods, followed by\n   * whitespace, then the full domain name, e.g.:\n   *\n   * c-ares  www.c-ares.org\n   * curl    www.curl.se\n   */\n\n  status = ares__buf_split(buf, (const unsigned char *)\"\\n\", 1,\n                           ARES_BUF_SPLIT_TRIM, 0, &lines);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  for (node = ares__llist_node_first(lines); node != NULL;\n       node = ares__llist_node_next(node)) {\n    ares__buf_t *line         = ares__llist_node_val(node);\n    char         hostname[64] = \"\";\n    char         fqdn[256]    = \"\";\n\n    /* Pull off hostname */\n    ares__buf_tag(line);\n    ares__buf_consume_nonwhitespace(line);\n    if (ares__buf_tag_fetch_string(line, hostname, sizeof(hostname)) !=\n        ARES_SUCCESS) {\n      continue;\n    }\n\n    /* Match hostname */\n    if (strcasecmp(hostname, name) != 0) {\n      continue;\n    }\n\n    /* consume whitespace */\n    ares__buf_consume_whitespace(line, ARES_TRUE);\n\n    /* pull off fqdn */\n    ares__buf_tag(line);\n    ares__buf_consume_nonwhitespace(line);\n    if (ares__buf_tag_fetch_string(line, fqdn, sizeof(fqdn)) != ARES_SUCCESS ||\n        ares_strlen(fqdn) == 0) {\n      continue;\n    }\n\n    /* Validate characterset */\n    if (!ares__is_hostname(fqdn)) {\n      continue;\n    }\n\n    *alias = ares_strdup(fqdn);\n    if (*alias == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n\n    /* Good! */\n    status = ARES_SUCCESS;\n    goto done;\n  }\n\n  status = ARES_ENOTFOUND;\n\ndone:\n  ares__buf_destroy(buf);\n  ares__llist_destroy(lines);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              490,
              0
            ],
            [
              599,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__lookup_hostaliases",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "alias": "char"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "search_callback(void *arg, ares_status_t status, size_t timeouts,\n                            const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              76,
              12
            ],
            [
              77,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "search_callback",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__dnsrec_convert_arg(ares_callback callback, void *arg)",
          "fn_dec_pos": [
            [
              371,
              6
            ],
            [
              371,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__dnsrec_convert_arg",
            "parameters": {
              "callback": "ares_callback",
              "arg": "void"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct search_query {\n  /* Arguments passed to ares_search_dnsrec() */\n  ares_channel_t      *channel;\n  ares_callback_dnsrec callback;\n  void                *arg;\n\n  /* Duplicate of DNS record passed to ares_search_dnsrec() */\n  ares_dns_record_t   *dnsrec;\n\n  /* Search order for names */\n  char               **names;\n  size_t               names_cnt;\n\n  /* State tracking progress through the search query */\n  size_t               next_name_idx; /* next name index being attempted */\n  size_t      timeouts;        /* number of timeouts we saw for this request */\n  ares_bool_t ever_got_nodata; /* did we ever get ARES_ENODATA along the way? */\n}",
          {
            "*channel": "ares_channel_t",
            "callback": "ares_callback_dnsrec",
            "*arg": "void",
            "*dnsrec": "ares_dns_record_t",
            "**names": "char",
            "names_cnt": "size_t",
            "next_name_idx": "size_t",
            "timeouts": "size_t",
            "ever_got_nodata": "ares_bool_t"
          },
          "search_query",
          [
            37,
            0
          ],
          [
            54,
            1
          ]
        ],
        [
          "typedef struct {\n  ares_callback callback;\n  void         *arg;\n} dnsrec_convert_arg_t;",
          {
            "callback": "ares_callback",
            "*arg": "void"
          },
          "dnsrec_convert_arg_t",
          [
            364,
            0
          ],
          [
            367,
            23
          ]
        ],
        [
          "struct search_query {\n  /* Arguments passed to ares_search_dnsrec() */\n  ares_channel_t      *channel;\n  ares_callback_dnsrec callback;\n  void                *arg;\n\n  /* Duplicate of DNS record passed to ares_search_dnsrec() */\n  ares_dns_record_t   *dnsrec;\n\n  /* Search order for names */\n  char               **names;\n  size_t               names_cnt;\n\n  /* State tracking progress through the search query */\n  size_t               next_name_idx; /* next name index being attempted */\n  size_t      timeouts;        /* number of timeouts we saw for this request */\n  ares_bool_t ever_got_nodata; /* did we ever get ARES_ENODATA along the way? */\n}",
          {
            "*channel": "ares_channel_t",
            "callback": "ares_callback_dnsrec",
            "*arg": "void",
            "*dnsrec": "ares_dns_record_t",
            "**names": "char",
            "names_cnt": "size_t",
            "next_name_idx": "size_t",
            "timeouts": "size_t",
            "ever_got_nodata": "ares_bool_t"
          },
          "search_query",
          [
            37,
            0
          ],
          [
            54,
            1
          ]
        ],
        [
          "struct search_query",
          {},
          "",
          [
            56,
            24
          ],
          [
            56,
            43
          ]
        ],
        [
          "struct search_query",
          {},
          "",
          [
            69,
            23
          ],
          [
            69,
            42
          ]
        ],
        [
          "struct search_query",
          {},
          "",
          [
            80,
            38
          ],
          [
            80,
            57
          ]
        ],
        [
          "struct search_query",
          {},
          "",
          [
            111,
            2
          ],
          [
            111,
            21
          ]
        ],
        [
          "struct search_query",
          {},
          "",
          [
            111,
            34
          ],
          [
            111,
            53
          ]
        ],
        [
          "struct search_query",
          {},
          "",
          [
            295,
            2
          ],
          [
            295,
            21
          ]
        ],
        [
          "typedef struct {\n  ares_callback callback;\n  void         *arg;\n} dnsrec_convert_arg_t;",
          {
            "callback": "ares_callback",
            "*arg": "void"
          },
          "dnsrec_convert_arg_t",
          [
            364,
            0
          ],
          [
            367,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include \"ares_dns.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_parse_a_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_parse_a_reply(const unsigned char *abuf, int alen,\n                       struct hostent **host, struct ares_addrttl *addrttls,\n                       int *naddrttls)\n{\n  struct ares_addrinfo ai;\n  char                *question_hostname = NULL;\n  ares_status_t        status;\n  size_t               req_naddrttls = 0;\n  ares_dns_record_t   *dnsrec        = NULL;\n\n  if (alen < 0) {\n    return ARES_EBADRESP;\n  }\n\n  if (naddrttls) {\n    req_naddrttls = (size_t)*naddrttls;\n    *naddrttls    = 0;\n  }\n\n  memset(&ai, 0, sizeof(ai));\n\n  status = ares_dns_parse(abuf, (size_t)alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  status = ares__parse_into_addrinfo(dnsrec, 0, 0, &ai);\n  if (status != ARES_SUCCESS && status != ARES_ENODATA) {\n    goto fail;\n  }\n\n  if (host != NULL) {\n    status = ares__addrinfo2hostent(&ai, AF_INET, host);\n    if (status != ARES_SUCCESS && status != ARES_ENODATA) {\n      goto fail;\n    }\n  }\n\n  if (addrttls != NULL && req_naddrttls) {\n    size_t temp_naddrttls = 0;\n    ares__addrinfo2addrttl(&ai, AF_INET, req_naddrttls, addrttls, NULL,\n                           &temp_naddrttls);\n    *naddrttls = (int)temp_naddrttls;\n  }\n\n\nfail:\n  ares__freeaddrinfo_cnames(ai.cnames);\n  ares__freeaddrinfo_nodes(ai.nodes);\n  ares_free(ai.name);\n  ares_free(question_hostname);\n  ares_dns_record_destroy(dnsrec);\n\n  if (status == ARES_EBADNAME) {\n    status = ARES_EBADRESP;\n  }\n\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              53,
              0
            ],
            [
              111,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_a_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "host": "struct hostent",
              "addrttls": "struct ares_addrttl",
              "naddrttls": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            54,
            23
          ],
          [
            54,
            37
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            54,
            46
          ],
          [
            54,
            65
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            57,
            2
          ],
          [
            57,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#  include <limits.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include \"ares_dns.h\"\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_gethostbyaddr.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares_gethostbyaddr_int(ares_channel_t *channel, const void *addr,\n                                   int addrlen, int family,\n                                   ares_host_callback callback, void *arg)\n{\n  struct addr_query *aquery;\n\n  if (family != AF_INET && family != AF_INET6) {\n    callback(arg, ARES_ENOTIMP, 0, NULL);\n    return;\n  }\n\n  if ((family == AF_INET && addrlen != sizeof(aquery->addr.addr.addr4)) ||\n      (family == AF_INET6 && addrlen != sizeof(aquery->addr.addr.addr6))) {\n    callback(arg, ARES_ENOTIMP, 0, NULL);\n    return;\n  }\n\n  aquery = ares_malloc(sizeof(struct addr_query));\n  if (!aquery) {\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    return;\n  }\n  aquery->lookups = ares_strdup(channel->lookups);\n  if (aquery->lookups == NULL) {\n    ares_free(aquery);\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    return;\n  }\n  aquery->channel = channel;\n  if (family == AF_INET) {\n    memcpy(&aquery->addr.addr.addr4, addr, sizeof(aquery->addr.addr.addr4));\n  } else {\n    memcpy(&aquery->addr.addr.addr6, addr, sizeof(aquery->addr.addr.addr6));\n  }\n  aquery->addr.family       = family;\n  aquery->callback          = callback;\n  aquery->arg               = arg;\n  aquery->remaining_lookups = aquery->lookups;\n  aquery->timeouts          = 0;\n\n  next_lookup(aquery);\n}",
          "fn_code_pos": [
            [
              70,
              0
            ],
            [
              111,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_gethostbyaddr_int",
            "parameters": {
              "channel": "ares_channel_t",
              "addr": "void",
              "addrlen": "int",
              "family": "int",
              "callback": "ares_host_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_gethostbyaddr(ares_channel_t *channel, const void *addr, int addrlen,\n                        int family, ares_host_callback callback, void *arg)\n{\n  if (channel == NULL) {\n    return;\n  }\n  ares__channel_lock(channel);\n  ares_gethostbyaddr_int(channel, addr, addrlen, family, callback, arg);\n  ares__channel_unlock(channel);\n}",
          "fn_code_pos": [
            [
              113,
              0
            ],
            [
              122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_gethostbyaddr",
            "parameters": {
              "channel": "ares_channel_t",
              "addr": "void",
              "addrlen": "int",
              "family": "int",
              "callback": "ares_host_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void next_lookup(struct addr_query *aquery)\n{\n  const char     *p;\n  ares_status_t   status;\n  struct hostent *host;\n  char           *name;\n\n  for (p = aquery->remaining_lookups; *p; p++) {\n    switch (*p) {\n      case 'b':\n        name = ares_dns_addr_to_ptr(&aquery->addr);\n        if (name == NULL) {\n          end_aquery(aquery, ARES_ENOMEM, NULL);\n          return;\n        }\n        aquery->remaining_lookups = p + 1;\n        ares_query_dnsrec(aquery->channel, name, ARES_CLASS_IN,\n                          ARES_REC_TYPE_PTR, addr_callback, aquery, NULL);\n        ares_free(name);\n        return;\n      case 'f':\n        status = file_lookup(aquery->channel, &aquery->addr, &host);\n\n        /* this status check below previously checked for !ARES_ENOTFOUND,\n           but we should not assume that this single error code is the one\n           that can occur, as that is in fact no longer the case */\n        if (status == ARES_SUCCESS) {\n          end_aquery(aquery, status, host);\n          return;\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  end_aquery(aquery, ARES_ENOTFOUND, NULL);\n}",
          "fn_code_pos": [
            [
              124,
              0
            ],
            [
              160,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "next_lookup",
            "parameters": {
              "aquery": "struct addr_query"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void addr_callback(void *arg, ares_status_t status, size_t timeouts,\n                          const ares_dns_record_t *dnsrec)\n{\n  struct addr_query *aquery = (struct addr_query *)arg;\n  struct hostent    *host;\n  size_t             addrlen;\n\n  aquery->timeouts += timeouts;\n  if (status == ARES_SUCCESS) {\n    if (aquery->addr.family == AF_INET) {\n      addrlen = sizeof(aquery->addr.addr.addr4);\n      status  = ares_parse_ptr_reply_dnsrec(dnsrec, &aquery->addr.addr.addr4,\n                                            (int)addrlen, AF_INET, &host);\n    } else {\n      addrlen = sizeof(aquery->addr.addr.addr6);\n      status  = ares_parse_ptr_reply_dnsrec(dnsrec, &aquery->addr.addr.addr6,\n                                            (int)addrlen, AF_INET6, &host);\n    }\n    end_aquery(aquery, status, host);\n  } else if (status == ARES_EDESTRUCTION || status == ARES_ECANCELLED) {\n    end_aquery(aquery, status, NULL);\n  } else {\n    next_lookup(aquery);\n  }\n}",
          "fn_code_pos": [
            [
              162,
              0
            ],
            [
              186,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "addr_callback",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void end_aquery(struct addr_query *aquery, ares_status_t status,\n                       struct hostent *host)\n{\n  aquery->callback(aquery->arg, (int)status, (int)aquery->timeouts, host);\n  if (host) {\n    ares_free_hostent(host);\n  }\n  ares_free(aquery->lookups);\n  ares_free(aquery);\n}",
          "fn_code_pos": [
            [
              188,
              0
            ],
            [
              197,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "end_aquery",
            "parameters": {
              "aquery": "struct addr_query",
              "status": "ares_status_t",
              "host": "struct hostent"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t file_lookup(ares_channel_t         *channel,\n                                 const struct ares_addr *addr,\n                                 struct hostent        **host)\n{\n  char                      ipaddr[INET6_ADDRSTRLEN];\n  const void               *ptr = NULL;\n  const ares_hosts_entry_t *entry;\n  ares_status_t             status;\n\n  if (addr->family == AF_INET) {\n    ptr = &addr->addr.addr4;\n  } else if (addr->family == AF_INET6) {\n    ptr = &addr->addr.addr6;\n  }\n\n  if (ptr == NULL) {\n    return ARES_ENOTFOUND;\n  }\n\n  if (!ares_inet_ntop(addr->family, ptr, ipaddr, sizeof(ipaddr))) {\n    return ARES_ENOTFOUND;\n  }\n\n  status = ares__hosts_search_ipaddr(channel, ARES_FALSE, ipaddr, &entry);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares__hosts_entry_to_hostent(entry, addr->family, host);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              199,
              0
            ],
            [
              233,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_lookup",
            "parameters": {
              "channel": "ares_channel_t",
              "addr": "struct ares_addr",
              "host": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "next_lookup(struct addr_query *aquery)",
          "fn_dec_pos": [
            [
              61,
              12
            ],
            [
              61,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "next_lookup",
            "parameters": {
              "aquery": "struct addr_query"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "addr_callback(void *arg, ares_status_t status, size_t timeouts,\n                          const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              62,
              12
            ],
            [
              63,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "addr_callback",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "end_aquery(struct addr_query *aquery, ares_status_t status,\n                       struct hostent *host)",
          "fn_dec_pos": [
            [
              64,
              12
            ],
            [
              65,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "end_aquery",
            "parameters": {
              "aquery": "struct addr_query",
              "status": "ares_status_t",
              "host": "struct hostent"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "file_lookup(ares_channel_t         *channel,\n                                 const struct ares_addr *addr,\n                                 struct hostent        **host)",
          "fn_dec_pos": [
            [
              66,
              21
            ],
            [
              68,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_lookup",
            "parameters": {
              "channel": "ares_channel_t",
              "addr": "struct ares_addr",
              "host": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct addr_query {\n  /* Arguments passed to ares_gethostbyaddr() */\n  ares_channel_t    *channel;\n  struct ares_addr   addr;\n  ares_host_callback callback;\n  void              *arg;\n  char       *lookups; /* duplicate memory from channel for ares_reinit() */\n  const char *remaining_lookups;\n  size_t      timeouts;\n}",
          {
            "*channel": "ares_channel_t",
            "addr": "struct ares_addr",
            "callback": "ares_host_callback",
            "*arg": "void",
            "*lookups": "char",
            "char": "const",
            "timeouts": "size_t"
          },
          "addr_query",
          [
            50,
            0
          ],
          [
            59,
            1
          ]
        ],
        [
          "struct addr_query {\n  /* Arguments passed to ares_gethostbyaddr() */\n  ares_channel_t    *channel;\n  struct ares_addr   addr;\n  ares_host_callback callback;\n  void              *arg;\n  char       *lookups; /* duplicate memory from channel for ares_reinit() */\n  const char *remaining_lookups;\n  size_t      timeouts;\n}",
          {
            "*channel": "ares_channel_t",
            "addr": "struct ares_addr",
            "callback": "ares_host_callback",
            "*arg": "void",
            "*lookups": "char",
            "char": "const",
            "timeouts": "size_t"
          },
          "addr_query",
          [
            50,
            0
          ],
          [
            59,
            1
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            53,
            2
          ],
          [
            53,
            18
          ]
        ],
        [
          "struct addr_query",
          {},
          "",
          [
            61,
            24
          ],
          [
            61,
            41
          ]
        ],
        [
          "struct addr_query",
          {},
          "",
          [
            64,
            23
          ],
          [
            64,
            40
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            65,
            23
          ],
          [
            65,
            37
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            67,
            39
          ],
          [
            67,
            55
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            68,
            33
          ],
          [
            68,
            47
          ]
        ],
        [
          "struct addr_query",
          {},
          "",
          [
            74,
            2
          ],
          [
            74,
            19
          ]
        ],
        [
          "struct addr_query",
          {},
          "",
          [
            87,
            30
          ],
          [
            87,
            47
          ]
        ],
        [
          "struct addr_query",
          {},
          "",
          [
            124,
            24
          ],
          [
            124,
            41
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            128,
            2
          ],
          [
            128,
            16
          ]
        ],
        [
          "struct addr_query",
          {},
          "",
          [
            165,
            2
          ],
          [
            165,
            19
          ]
        ],
        [
          "struct addr_query",
          {},
          "",
          [
            165,
            31
          ],
          [
            165,
            48
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            166,
            2
          ],
          [
            166,
            16
          ]
        ],
        [
          "struct addr_query",
          {},
          "",
          [
            188,
            23
          ],
          [
            188,
            40
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            189,
            23
          ],
          [
            189,
            37
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            200,
            39
          ],
          [
            200,
            55
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            201,
            33
          ],
          [
            201,
            47
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include \"ares_platform.h\"\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_parse_caa_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_parse_caa_reply(const unsigned char *abuf, int alen_int,\n                         struct ares_caa_reply **caa_out)\n{\n  ares_status_t          status;\n  size_t                 alen;\n  struct ares_caa_reply *caa_head = NULL;\n  struct ares_caa_reply *caa_last = NULL;\n  struct ares_caa_reply *caa_curr;\n  ares_dns_record_t     *dnsrec = NULL;\n  size_t                 i;\n\n  *caa_out = NULL;\n\n  if (alen_int < 0) {\n    return ARES_EBADRESP;\n  }\n\n  alen = (size_t)alen_int;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {\n    const unsigned char *ptr;\n    size_t               ptr_len;\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP;\n      goto done;\n    }\n\n    /* XXX: Why do we allow Chaos class? */\n    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN &&\n        ares_dns_rr_get_class(rr) != ARES_CLASS_CHAOS) {\n      continue;\n    }\n\n    /* Only looking for CAA records */\n    if (ares_dns_rr_get_type(rr) != ARES_REC_TYPE_CAA) {\n      continue;\n    }\n\n    /* Allocate storage for this CAA answer appending it to the list */\n    caa_curr = ares_malloc_data(ARES_DATATYPE_CAA_REPLY);\n    if (caa_curr == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n\n    /* Link in the record */\n    if (caa_last) {\n      caa_last->next = caa_curr;\n    } else {\n      caa_head = caa_curr;\n    }\n    caa_last = caa_curr;\n\n    caa_curr->critical = ares_dns_rr_get_u8(rr, ARES_RR_CAA_CRITICAL);\n    caa_curr->property =\n      (unsigned char *)ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_CAA_TAG));\n    if (caa_curr->property == NULL) {\n      status = ARES_ENOMEM;\n      break;\n    }\n    /* RFC6844 says this can only be ascii, so not sure why we're recording a\n     * length */\n    caa_curr->plength = ares_strlen((const char *)caa_curr->property);\n\n    ptr = ares_dns_rr_get_bin(rr, ARES_RR_CAA_VALUE, &ptr_len);\n    if (ptr == NULL) {\n      status = ARES_EBADRESP;\n      goto done;\n    }\n\n    /* Wants NULL termination for some reason */\n    caa_curr->value = ares_malloc(ptr_len + 1);\n    if (caa_curr->value == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    memcpy(caa_curr->value, ptr, ptr_len);\n    caa_curr->value[ptr_len] = 0;\n    caa_curr->length         = ptr_len;\n  }\n\ndone:\n  /* clean up on error */\n  if (status != ARES_SUCCESS) {\n    if (caa_head) {\n      ares_free_data(caa_head);\n    }\n  } else {\n    /* everything looks fine, return the data */\n    *caa_out = caa_head;\n  }\n  ares_dns_record_destroy(dnsrec);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_caa_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen_int": "int",
              "caa_out": "struct ares_caa_reply"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            32,
            25
          ],
          [
            32,
            46
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            36,
            2
          ],
          [
            36,
            23
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            37,
            2
          ],
          [
            37,
            23
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            38,
            2
          ],
          [
            38,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_parse_mx_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_parse_mx_reply(const unsigned char *abuf, int alen_int,\n                        struct ares_mx_reply **mx_out)\n{\n  ares_status_t         status;\n  size_t                alen;\n  struct ares_mx_reply *mx_head = NULL;\n  struct ares_mx_reply *mx_last = NULL;\n  struct ares_mx_reply *mx_curr;\n  ares_dns_record_t    *dnsrec = NULL;\n  size_t                i;\n\n  *mx_out = NULL;\n\n  if (alen_int < 0) {\n    return ARES_EBADRESP;\n  }\n\n  alen = (size_t)alen_int;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP;\n      goto done;\n    }\n\n    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN ||\n        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_MX) {\n      continue;\n    }\n\n    /* Allocate storage for this MX answer appending it to the list */\n    mx_curr = ares_malloc_data(ARES_DATATYPE_MX_REPLY);\n    if (mx_curr == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n\n    /* Link in the record */\n    if (mx_last) {\n      mx_last->next = mx_curr;\n    } else {\n      mx_head = mx_curr;\n    }\n    mx_last = mx_curr;\n\n    mx_curr->priority = ares_dns_rr_get_u16(rr, ARES_RR_MX_PREFERENCE);\n    mx_curr->host = ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_MX_EXCHANGE));\n\n    if (mx_curr->host == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n  }\n\ndone:\n  /* clean up on error */\n  if (status != ARES_SUCCESS) {\n    if (mx_head) {\n      ares_free_data(mx_head);\n    }\n  } else {\n    /* everything looks fine, return the data */\n    *mx_out = mx_head;\n  }\n  ares_dns_record_destroy(dnsrec);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              111,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_mx_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen_int": "int",
              "mx_out": "struct ares_mx_reply"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            32,
            24
          ],
          [
            32,
            44
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            36,
            2
          ],
          [
            36,
            22
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            37,
            2
          ],
          [
            37,
            22
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            38,
            2
          ],
          [
            38,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__addrinfo_localhost.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_status_t ares_append_ai_node(int aftype, unsigned short port,\n                                  unsigned int ttl, const void *adata,\n                                  struct ares_addrinfo_node **nodes)\n{\n  struct ares_addrinfo_node *node;\n\n  node = ares__append_addrinfo_node(nodes);\n  if (!node) {\n    return ARES_ENOMEM;\n  }\n\n  memset(node, 0, sizeof(*node));\n\n  if (aftype == AF_INET) {\n    struct sockaddr_in *sin = ares_malloc(sizeof(*sin));\n    if (!sin) {\n      return ARES_ENOMEM;\n    }\n\n    memset(sin, 0, sizeof(*sin));\n    memcpy(&sin->sin_addr.s_addr, adata, sizeof(sin->sin_addr.s_addr));\n    sin->sin_family = AF_INET;\n    sin->sin_port   = htons(port);\n\n    node->ai_addr    = (struct sockaddr *)sin;\n    node->ai_family  = AF_INET;\n    node->ai_addrlen = sizeof(*sin);\n    node->ai_addr    = (struct sockaddr *)sin;\n    node->ai_ttl     = (int)ttl;\n  }\n\n  if (aftype == AF_INET6) {\n    struct sockaddr_in6 *sin6 = ares_malloc(sizeof(*sin6));\n    if (!sin6) {\n      return ARES_ENOMEM;\n    }\n\n    memset(sin6, 0, sizeof(*sin6));\n    memcpy(&sin6->sin6_addr.s6_addr, adata, sizeof(sin6->sin6_addr.s6_addr));\n    sin6->sin6_family = AF_INET6;\n    sin6->sin6_port   = htons(port);\n\n    node->ai_addr    = (struct sockaddr *)sin6;\n    node->ai_family  = AF_INET6;\n    node->ai_addrlen = sizeof(*sin6);\n    node->ai_addr    = (struct sockaddr *)sin6;\n    node->ai_ttl     = (int)ttl;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_append_ai_node",
            "parameters": {
              "aftype": "int",
              "port": "unsigned short",
              "ttl": "unsigned int",
              "adata": "void",
              "nodes": "struct ares_addrinfo_node"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t\n  ares__default_loopback_addrs(int aftype, unsigned short port,\n                               struct ares_addrinfo_node **nodes)\n{\n  ares_status_t status = ARES_SUCCESS;\n\n  if (aftype == AF_UNSPEC || aftype == AF_INET6) {\n    struct ares_in6_addr addr6;\n    ares_inet_pton(AF_INET6, \"::1\", &addr6);\n    status = ares_append_ai_node(AF_INET6, port, 0, &addr6, nodes);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  if (aftype == AF_UNSPEC || aftype == AF_INET) {\n    struct in_addr addr4;\n    ares_inet_pton(AF_INET, \"127.0.0.1\", &addr4);\n    status = ares_append_ai_node(AF_INET, port, 0, &addr4, nodes);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              108,
              0
            ],
            [
              133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__default_loopback_addrs",
            "parameters": {
              "aftype": "int",
              "port": "unsigned short",
              "nodes": "struct ares_addrinfo_node"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t\n  ares__system_loopback_addrs(int aftype, unsigned short port,\n                              struct ares_addrinfo_node **nodes)\n{\n#if defined(_WIN32) && defined(_WIN32_WINNT) && _WIN32_WINNT >= 0x0600 && \\\n  !defined(__WATCOMC__)\n  PMIB_UNICASTIPADDRESS_TABLE table;\n  unsigned int                i;\n  ares_status_t               status;\n\n  *nodes = NULL;\n\n  if (GetUnicastIpAddressTable((ADDRESS_FAMILY)aftype, &table) != NO_ERROR) {\n    return ARES_ENOTFOUND;\n  }\n\n  for (i = 0; i < table->NumEntries; i++) {\n    if (table->Table[i].InterfaceLuid.Info.IfType !=\n        IF_TYPE_SOFTWARE_LOOPBACK) {\n      continue;\n    }\n\n    if (table->Table[i].Address.si_family == AF_INET) {\n      status =\n        ares_append_ai_node(table->Table[i].Address.si_family, port, 0,\n                            &table->Table[i].Address.Ipv4.sin_addr, nodes);\n    } else if (table->Table[i].Address.si_family == AF_INET6) {\n      status =\n        ares_append_ai_node(table->Table[i].Address.si_family, port, 0,\n                            &table->Table[i].Address.Ipv6.sin6_addr, nodes);\n    } else {\n      /* Ignore any others */\n      continue;\n    }\n\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n\n  if (*nodes == NULL) {\n    status = ARES_ENOTFOUND;\n  }\n\nfail:\n  FreeMibTable(table);\n\n  if (status != ARES_SUCCESS) {\n    ares__freeaddrinfo_nodes(*nodes);\n    *nodes = NULL;\n  }\n\n  return status;\n\n#else\n  (void)aftype;\n  (void)port;\n  (void)nodes;\n  /* Not supported on any other OS at this time */\n  return ARES_ENOTFOUND;\n#endif\n}",
          "fn_code_pos": [
            [
              135,
              0
            ],
            [
              196,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__system_loopback_addrs",
            "parameters": {
              "aftype": "int",
              "port": "unsigned short",
              "nodes": "struct ares_addrinfo_node"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__addrinfo_localhost(const char *name, unsigned short port,\n                                       const struct ares_addrinfo_hints *hints,\n                                       struct ares_addrinfo             *ai)\n{\n  struct ares_addrinfo_node *nodes = NULL;\n  ares_status_t              status;\n\n  /* Validate family */\n  switch (hints->ai_family) {\n    case AF_INET:\n    case AF_INET6:\n    case AF_UNSPEC:\n      break;\n    default:\n      return ARES_EBADFAMILY;\n  }\n\n  ai->name = ares_strdup(name);\n  if (!ai->name) {\n    goto enomem;\n  }\n\n  status = ares__system_loopback_addrs(hints->ai_family, port, &nodes);\n\n  if (status == ARES_ENOTFOUND) {\n    status = ares__default_loopback_addrs(hints->ai_family, port, &nodes);\n  }\n\n  ares__addrinfo_cat_nodes(&ai->nodes, nodes);\n\n  return status;\n\nenomem:\n  ares__freeaddrinfo_nodes(nodes);\n  ares_free(ai->name);\n  ai->name = NULL;\n  return ARES_ENOMEM;\n}",
          "fn_code_pos": [
            [
              198,
              0
            ],
            [
              235,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__addrinfo_localhost",
            "parameters": {
              "name": "char",
              "port": "unsigned short",
              "hints": "struct ares_addrinfo_hints",
              "ai": "struct ares_addrinfo"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            58,
            34
          ],
          [
            58,
            59
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            60,
            2
          ],
          [
            60,
            27
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            70,
            4
          ],
          [
            70,
            22
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            80,
            24
          ],
          [
            80,
            39
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            83,
            24
          ],
          [
            83,
            39
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            88,
            4
          ],
          [
            88,
            23
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            98,
            24
          ],
          [
            98,
            39
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            101,
            24
          ],
          [
            101,
            39
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            110,
            31
          ],
          [
            110,
            56
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            115,
            4
          ],
          [
            115,
            24
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            124,
            4
          ],
          [
            124,
            18
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            137,
            30
          ],
          [
            137,
            55
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            199,
            45
          ],
          [
            199,
            71
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            200,
            39
          ],
          [
            200,
            59
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            202,
            2
          ],
          [
            202,
            27
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#  include <ws2ipdef.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#    include <iphlpapi.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#    include <netioapi.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_parse_ns_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_parse_ns_reply(const unsigned char *abuf, int alen_int,\n                        struct hostent **host)\n{\n  ares_status_t      status;\n  size_t             alen;\n  size_t             nscount  = 0;\n  struct hostent    *hostent  = NULL;\n  const char        *hostname = NULL;\n  ares_dns_record_t *dnsrec   = NULL;\n  size_t             i;\n  size_t             ancount;\n\n  *host = NULL;\n\n  if (alen_int < 0) {\n    return ARES_EBADRESP;\n  }\n\n  alen = (size_t)alen_int;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  ancount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER);\n  if (ancount == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  /* Response structure */\n  hostent = ares_malloc(sizeof(*hostent));\n  if (hostent == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  memset(hostent, 0, sizeof(*hostent));\n\n  hostent->h_addr_list = ares_malloc(sizeof(*hostent->h_addr_list));\n  if (hostent->h_addr_list == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n  hostent->h_addr_list[0] = NULL;\n  hostent->h_addrtype     = AF_INET;\n  hostent->h_length       = sizeof(struct in_addr);\n\n  /* Fill in hostname */\n  status = ares_dns_record_query_get(dnsrec, 0, &hostname, NULL, NULL);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n  hostent->h_name = ares_strdup(hostname);\n  if (hostent->h_name == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  /* Preallocate the maximum number + 1 */\n  hostent->h_aliases = ares_malloc((ancount + 1) * sizeof(*hostent->h_aliases));\n  if (hostent->h_aliases == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n  memset(hostent->h_aliases, 0, (ancount + 1) * sizeof(*hostent->h_aliases));\n\n  for (i = 0; i < ancount; i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP;\n      goto done;\n    }\n\n    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN ||\n        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_NS) {\n      continue;\n    }\n\n    hostname = ares_dns_rr_get_str(rr, ARES_RR_NS_NSDNAME);\n    if (hostname == NULL) {\n      status = ARES_EBADRESP;\n      goto done;\n    }\n\n    hostent->h_aliases[nscount] = ares_strdup(hostname);\n    if (hostent->h_aliases[nscount] == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    nscount++;\n  }\n\n  if (nscount == 0) {\n    status = ARES_ENODATA;\n  } else {\n    status = ARES_SUCCESS;\n  }\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_free_hostent(hostent);\n    /* Compatibility */\n    if (status == ARES_EBADNAME) {\n      status = ARES_EBADRESP;\n    }\n  } else {\n    *host = hostent;\n  }\n  ares_dns_record_destroy(dnsrec);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              156,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_ns_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen_int": "int",
              "host": "struct hostent"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            42,
            24
          ],
          [
            42,
            38
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            47,
            2
          ],
          [
            47,
            16
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            88,
            35
          ],
          [
            88,
            49
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_platform.c": {
      "fn_def_list": [
        {
          "fn_code": "win_platform ares__getplatform(void)\n{\n  OSVERSIONINFOEX OsvEx;\n\n  memset(&OsvEx, 0, sizeof(OsvEx));\n  OsvEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);\n#  ifdef _MSC_VER\n#    pragma warning(push)\n#    pragma warning(disable : 4996) /* warning C4996: 'GetVersionExW': was \\\n                                       declared deprecated */\n#  endif\n  if (!GetVersionEx((void *)&OsvEx)) {\n    memset(&OsvEx, 0, sizeof(OsvEx));\n    OsvEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n    if (!GetVersionEx((void *)&OsvEx)) {\n      return WIN_UNKNOWN;\n    }\n  }\n#  ifdef _MSC_VER\n#    pragma warning(pop)\n#  endif\n\n  switch (OsvEx.dwPlatformId) {\n    case V_PLATFORM_WIN32s:\n      return WIN_3X;\n\n    case V_PLATFORM_WIN32_WINDOWS:\n      return WIN_9X;\n\n    case V_PLATFORM_WIN32_NT:\n      return WIN_NT;\n\n    case V_PLATFORM_WIN32_CE:\n      return WIN_CE;\n\n    default:\n      return WIN_UNKNOWN;\n  }\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              78,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__getplatform",
            "parameters": {},
            "return_type": "win_platform"
          }
        },
        {
          "fn_code": "struct servent *getservbyport(int port, const char *proto)\n{\n  unsigned short u_port;\n  const char    *protocol = NULL;\n  int            error    = 0;\n  size_t         i;\n\n  u_port = ntohs((unsigned short)port);\n\n  if (proto) {\n    switch (ares_strlen(proto)) {\n      case 3:\n        if (!strncasecmp(proto, \"tcp\", 3)) {\n          protocol = \"tcp\";\n        } else if (!strncasecmp(proto, \"udp\", 3)) {\n          protocol = \"udp\";\n        } else {\n          error = WSAEFAULT;\n        }\n        break;\n      case 4:\n        if (!strncasecmp(proto, \"sctp\", 4)) {\n          protocol = \"sctp\";\n        } else if (!strncasecmp(proto, \"dccp\", 4)) {\n          protocol = \"dccp\";\n        } else {\n          error = WSAEFAULT;\n        }\n        break;\n      default:\n        error = WSAEFAULT;\n    }\n  }\n\n  if (!error) {\n    for (i = 0; i < (sizeof(IANAports) / sizeof(IANAports[0])) - 1; i++) {\n      if (u_port == IANAports[i].s_port) {\n        if (!protocol || !strcasecmp(protocol, IANAports[i].s_proto)) {\n          return (struct servent *)&IANAports[i];\n        }\n      }\n    }\n    error = WSANO_DATA;\n  }\n\n  SET_SOCKERRNO(error);\n  return NULL;\n}",
          "fn_code_pos": [
            [
              11000,
              0
            ],
            [
              11047,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getservbyport",
            "parameters": {
              "port": "int",
              "proto": "char"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "getservbyport(int port, const char *proto)",
          "fn_dec_pos": [
            [
              11000,
              16
            ],
            [
              11000,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getservbyport",
            "parameters": {
              "port": "int",
              "proto": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pvt_servent {\n  char          *s_name;\n  char         **s_aliases;\n  unsigned short s_port;\n  char          *s_proto;\n}",
          {
            "*s_name": "char",
            "**s_aliases": "char",
            "s_port": "unsigned short",
            "*s_proto": "char"
          },
          "pvt_servent",
          [
            90,
            0
          ],
          [
            95,
            1
          ]
        ],
        [
          "struct pvt_servent {\n  char          *s_name;\n  char         **s_aliases;\n  unsigned short s_port;\n  char          *s_proto;\n}",
          {
            "*s_name": "char",
            "**s_aliases": "char",
            "s_port": "unsigned short",
            "*s_proto": "char"
          },
          "pvt_servent",
          [
            90,
            0
          ],
          [
            95,
            1
          ]
        ],
        [
          "struct pvt_servent",
          {},
          "",
          [
            101,
            7
          ],
          [
            101,
            25
          ]
        ],
        [
          "struct servent",
          {},
          "",
          [
            11000,
            0
          ],
          [
            11000,
            14
          ]
        ],
        [
          "struct servent",
          {},
          "",
          [
            11038,
            18
          ],
          [
            11038,
            32
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"ares_platform.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_expand_name.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_status_t ares__expand_name_validated(const unsigned char *encoded,\n                                          const unsigned char *abuf,\n                                          size_t alen, char **s, size_t *enclen,\n                                          ares_bool_t is_hostname)\n{\n  ares_status_t status;\n  ares__buf_t  *buf = NULL;\n  size_t        start_len;\n\n  if (encoded == NULL || abuf == NULL || alen == 0 || enclen == NULL) {\n    return ARES_EBADNAME; /* EFORMERR would be better */\n  }\n\n  if (encoded < abuf || encoded >= abuf + alen) {\n    return ARES_EBADNAME; /* EFORMERR would be better */\n  }\n\n  *enclen = 0;\n\n  /* NOTE: we allow 's' to be NULL to skip it */\n  if (s) {\n    *s = NULL;\n  }\n\n  buf = ares__buf_create_const(abuf, alen);\n\n  if (buf == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  status = ares__buf_set_position(buf, (size_t)(encoded - abuf));\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  start_len = ares__buf_len(buf);\n  status    = ares__dns_name_parse(buf, s, is_hostname);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  *enclen = start_len - ares__buf_len(buf);\n\ndone:\n  ares__buf_destroy(buf);\n  return status;\n}",
          "fn_code_pos": [
            [
              38,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__expand_name_validated",
            "parameters": {
              "encoded": "unsigned char",
              "abuf": "unsigned char",
              "alen": "size_t",
              "s": "char",
              "enclen": "size_t",
              "is_hostname": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "int ares_expand_name(const unsigned char *encoded, const unsigned char *abuf,\n                     int alen, char **s, long *enclen)\n{\n  /* Keep public API compatible */\n  size_t        enclen_temp = 0;\n  ares_status_t status;\n\n  if (alen < 0) {\n    return ARES_EBADRESP;\n  }\n\n  status  = ares__expand_name_validated(encoded, abuf, (size_t)alen, s,\n                                        &enclen_temp, ARES_FALSE);\n  *enclen = (long)enclen_temp;\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              101,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_expand_name",
            "parameters": {
              "encoded": "unsigned char",
              "abuf": "unsigned char",
              "alen": "int",
              "s": "char",
              "enclen": "long"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_status_t ares__expand_name_for_response(const unsigned char *encoded,\n                                             const unsigned char *abuf,\n                                             size_t alen, char **s,\n                                             size_t     *enclen,\n                                             ares_bool_t is_hostname)\n{\n  ares_status_t status =\n    ares__expand_name_validated(encoded, abuf, alen, s, enclen, is_hostname);\n  if (status == ARES_EBADNAME) {\n    status = ARES_EBADRESP;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              105,
              0
            ],
            [
              117,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__expand_name_for_response",
            "parameters": {
              "encoded": "unsigned char",
              "abuf": "unsigned char",
              "alen": "size_t",
              "s": "char",
              "enclen": "size_t",
              "is_hostname": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"ares_private.h\" /* for the memdebug */\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_qcache.c": {
      "fn_def_list": [
        {
          "fn_code": "static char *ares__qcache_calc_key(const ares_dns_record_t *dnsrec)\n{\n  ares__buf_t     *buf = ares__buf_create();\n  size_t           i;\n  ares_status_t    status;\n  ares_dns_flags_t flags;\n\n  if (dnsrec == NULL || buf == NULL) {\n    return NULL;\n  }\n\n  /* Format is OPCODE|FLAGS[|QTYPE1|QCLASS1|QNAME1]... */\n\n  status = ares__buf_append_str(\n    buf, ares_dns_opcode_tostr(ares_dns_record_get_opcode(dnsrec)));\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  status = ares__buf_append_byte(buf, '|');\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  flags = ares_dns_record_get_flags(dnsrec);\n  /* Only care about RD and CD */\n  if (flags & ARES_FLAG_RD) {\n    status = ares__buf_append_str(buf, \"rd\");\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n  if (flags & ARES_FLAG_CD) {\n    status = ares__buf_append_str(buf, \"cd\");\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n\n  for (i = 0; i < ares_dns_record_query_cnt(dnsrec); i++) {\n    const char         *name;\n    size_t              name_len;\n    ares_dns_rec_type_t qtype;\n    ares_dns_class_t    qclass;\n\n    status = ares_dns_record_query_get(dnsrec, i, &name, &qtype, &qclass);\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n\n    status = ares__buf_append_byte(buf, '|');\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n\n    status = ares__buf_append_str(buf, ares_dns_rec_type_tostr(qtype));\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n\n    status = ares__buf_append_byte(buf, '|');\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n\n    status = ares__buf_append_str(buf, ares_dns_class_tostr(qclass));\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n\n    status = ares__buf_append_byte(buf, '|');\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n\n    /* On queries, a '.' may be appended to the name to indicate an explicit\n     * name lookup without performing a search.  Strip this since its not part\n     * of a cached response. */\n    name_len = ares_strlen(name);\n    if (name_len && name[name_len - 1] == '.') {\n      name_len--;\n    }\n\n    status = ares__buf_append(buf, (const unsigned char *)name, name_len);\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n\n  return ares__buf_finish_str(buf, NULL);\n\nfail:\n  ares__buf_destroy(buf);\n  return NULL;\n}",
          "fn_code_pos": [
            [
              42,
              0
            ],
            [
              136,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__qcache_calc_key",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static void ares__qcache_expire(ares__qcache_t       *cache,\n                                const struct timeval *now)\n{\n  ares__slist_node_t *node;\n\n  if (cache == NULL) {\n    return;\n  }\n\n  while ((node = ares__slist_node_first(cache->expire)) != NULL) {\n    const ares__qcache_entry_t *entry = ares__slist_node_val(node);\n    if (entry->expire_ts > now->tv_sec) {\n      break;\n    }\n\n    ares__htable_strvp_remove(cache->cache, entry->key);\n    ares__slist_node_destroy(node);\n  }\n}",
          "fn_code_pos": [
            [
              138,
              0
            ],
            [
              156,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__qcache_expire",
            "parameters": {
              "cache": "ares__qcache_t",
              "now": "struct timeval"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__qcache_flush(ares__qcache_t *cache)\n{\n  struct timeval now;\n  memset(&now, 0, sizeof(now));\n  ares__qcache_expire(cache, &now);\n}",
          "fn_code_pos": [
            [
              158,
              0
            ],
            [
              163,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__qcache_flush",
            "parameters": {
              "cache": "ares__qcache_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__qcache_destroy(ares__qcache_t *cache)\n{\n  if (cache == NULL) {\n    return;\n  }\n\n  ares__htable_strvp_destroy(cache->cache);\n  ares__slist_destroy(cache->expire);\n  ares_free(cache);\n}",
          "fn_code_pos": [
            [
              165,
              0
            ],
            [
              174,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__qcache_destroy",
            "parameters": {
              "cache": "ares__qcache_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int ares__qcache_entry_sort_cb(const void *arg1, const void *arg2)\n{\n  const ares__qcache_entry_t *entry1 = arg1;\n  const ares__qcache_entry_t *entry2 = arg2;\n\n  if (entry1->expire_ts > entry2->expire_ts) {\n    return 1;\n  }\n\n  if (entry1->expire_ts < entry2->expire_ts) {\n    return -1;\n  }\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              176,
              0
            ],
            [
              190,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__qcache_entry_sort_cb",
            "parameters": {
              "arg1": "void",
              "arg2": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void ares__qcache_entry_destroy_cb(void *arg)\n{\n  ares__qcache_entry_t *entry = arg;\n  if (entry == NULL) {\n    return;\n  }\n\n  ares_free(entry->key);\n  ares_dns_record_destroy(entry->dnsrec);\n  ares_free(entry);\n}",
          "fn_code_pos": [
            [
              192,
              0
            ],
            [
              202,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__qcache_entry_destroy_cb",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares__qcache_create(ares_rand_state *rand_state,\n                                  unsigned int     max_ttl,\n                                  ares__qcache_t **cache_out)\n{\n  ares_status_t   status = ARES_SUCCESS;\n  ares__qcache_t *cache;\n\n  cache = ares_malloc_zero(sizeof(*cache));\n  if (cache == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  cache->cache = ares__htable_strvp_create(NULL);\n  if (cache->cache == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  cache->expire = ares__slist_create(rand_state, ares__qcache_entry_sort_cb,\n                                     ares__qcache_entry_destroy_cb);\n  if (cache->expire == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  cache->max_ttl = max_ttl;\n\ndone:\n  if (status != ARES_SUCCESS) {\n    *cache_out = NULL;\n    ares__qcache_destroy(cache);\n    return status;\n  }\n\n  *cache_out = cache;\n  return status;\n}",
          "fn_code_pos": [
            [
              204,
              0
            ],
            [
              241,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__qcache_create",
            "parameters": {
              "rand_state": "ares_rand_state",
              "max_ttl": "unsigned int",
              "cache_out": "ares__qcache_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static unsigned int ares__qcache_calc_minttl(ares_dns_record_t *dnsrec)\n{\n  unsigned int minttl = 0xFFFFFFFF;\n  size_t       sect;\n\n  for (sect = ARES_SECTION_ANSWER; sect <= ARES_SECTION_ADDITIONAL; sect++) {\n    size_t i;\n    for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, (ares_dns_section_t)sect);\n         i++) {\n      const ares_dns_rr_t *rr =\n        ares_dns_record_rr_get(dnsrec, (ares_dns_section_t)sect, i);\n      ares_dns_rec_type_t type = ares_dns_rr_get_type(rr);\n      unsigned int        ttl  = ares_dns_rr_get_ttl(rr);\n      if (type == ARES_REC_TYPE_OPT || type == ARES_REC_TYPE_SOA) {\n        continue;\n      }\n\n      if (ttl < minttl) {\n        minttl = ttl;\n      }\n    }\n  }\n\n  return minttl;\n}",
          "fn_code_pos": [
            [
              243,
              0
            ],
            [
              267,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__qcache_calc_minttl",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static unsigned int ares__qcache_soa_minimum(ares_dns_record_t *dnsrec)\n{\n  size_t i;\n\n  /* RFC 2308 Section 5 says its the minimum of MINIMUM and the TTL of the\n   * record. */\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_AUTHORITY); i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get(dnsrec, ARES_SECTION_AUTHORITY, i);\n    ares_dns_rec_type_t type = ares_dns_rr_get_type(rr);\n    unsigned int        ttl;\n    unsigned int        minimum;\n\n    if (type != ARES_REC_TYPE_SOA) {\n      continue;\n    }\n\n    minimum = ares_dns_rr_get_u32(rr, ARES_RR_SOA_MINIMUM);\n    ttl     = ares_dns_rr_get_ttl(rr);\n\n    if (ttl > minimum) {\n      return minimum;\n    }\n    return ttl;\n  }\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              269,
              0
            ],
            [
              296,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__qcache_soa_minimum",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static char *ares__qcache_calc_key_frombuf(const unsigned char *qbuf,\n                                           size_t               qlen)\n{\n  ares_status_t      status;\n  ares_dns_record_t *dnsrec = NULL;\n  char              *key    = NULL;\n\n  status = ares_dns_parse(qbuf, qlen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  key = ares__qcache_calc_key(dnsrec);\n\ndone:\n  ares_dns_record_destroy(dnsrec);\n  return key;\n}",
          "fn_code_pos": [
            [
              298,
              0
            ],
            [
              315,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__qcache_calc_key_frombuf",
            "parameters": {
              "qbuf": "unsigned char",
              "qlen": "size_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static ares_status_t ares__qcache_insert(ares__qcache_t      *qcache,\n                                         ares_dns_record_t   *dnsrec,\n                                         const unsigned char *qbuf, size_t qlen,\n                                         const struct timeval *now)\n{\n  ares__qcache_entry_t *entry;\n  unsigned int          ttl;\n  ares_dns_rcode_t      rcode = ares_dns_record_get_rcode(dnsrec);\n  ares_dns_flags_t      flags = ares_dns_record_get_flags(dnsrec);\n\n  if (qcache == NULL || dnsrec == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  /* Only save NOERROR or NXDOMAIN */\n  if (rcode != ARES_RCODE_NOERROR && rcode != ARES_RCODE_NXDOMAIN) {\n    return ARES_ENOTIMP;\n  }\n\n  /* Don't save truncated queries */\n  if (flags & ARES_FLAG_TC) {\n    return ARES_ENOTIMP;\n  }\n\n  /* Look at SOA for NXDOMAIN for minimum */\n  if (rcode == ARES_RCODE_NXDOMAIN) {\n    ttl = ares__qcache_soa_minimum(dnsrec);\n  } else {\n    ttl = ares__qcache_calc_minttl(dnsrec);\n  }\n\n  /* Don't cache something that is already expired */\n  if (ttl == 0) {\n    return ARES_EREFUSED;\n  }\n\n  if (ttl > qcache->max_ttl) {\n    ttl = qcache->max_ttl;\n  }\n\n  entry = ares_malloc_zero(sizeof(*entry));\n  if (entry == NULL) {\n    goto fail;\n  }\n\n  entry->dnsrec    = dnsrec;\n  entry->expire_ts = now->tv_sec + (time_t)ttl;\n  entry->insert_ts = now->tv_sec;\n\n  /* We can't guarantee the server responded with the same flags as the\n   * request had, so we have to re-parse the request in order to generate the\n   * key for caching, but we'll only do this once we know for sure we really\n   * want to cache it */\n  entry->key = ares__qcache_calc_key_frombuf(qbuf, qlen);\n  if (entry->key == NULL) {\n    goto fail;\n  }\n\n  if (!ares__htable_strvp_insert(qcache->cache, entry->key, entry)) {\n    goto fail;\n  }\n\n  if (ares__slist_insert(qcache->expire, entry) == NULL) {\n    goto fail;\n  }\n\n  return ARES_SUCCESS;\n\nfail:\n  if (entry != NULL && entry->key != NULL) {\n    ares__htable_strvp_remove(qcache->cache, entry->key);\n    ares_free(entry->key);\n    ares_free(entry);\n  }\n  return ARES_ENOMEM;\n}",
          "fn_code_pos": [
            [
              318,
              0
            ],
            [
              393,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__qcache_insert",
            "parameters": {
              "qcache": "ares__qcache_t",
              "dnsrec": "ares_dns_record_t",
              "qbuf": "unsigned char",
              "qlen": "size_t",
              "now": "struct timeval"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_qcache_fetch(ares_channel_t           *channel,\n                                const struct timeval     *now,\n                                const ares_dns_record_t  *dnsrec,\n                                const ares_dns_record_t **dnsrec_resp)\n{\n  char                 *key = NULL;\n  ares__qcache_entry_t *entry;\n  ares_status_t         status = ARES_SUCCESS;\n\n  if (channel == NULL || dnsrec == NULL || dnsrec_resp == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (channel->qcache == NULL) {\n    return ARES_ENOTFOUND;\n  }\n\n  ares__qcache_expire(channel->qcache, now);\n\n  key = ares__qcache_calc_key(dnsrec);\n  if (key == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  entry = ares__htable_strvp_get_direct(channel->qcache->cache, key);\n  if (entry == NULL) {\n    status = ARES_ENOTFOUND;\n    goto done;\n  }\n\n  ares_dns_record_write_ttl_decrement(\n    entry->dnsrec, (unsigned int)(now->tv_sec - entry->insert_ts));\n\n  *dnsrec_resp = entry->dnsrec;\n\ndone:\n  ares_free(key);\n  return status;\n}",
          "fn_code_pos": [
            [
              395,
              0
            ],
            [
              434,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_fetch",
            "parameters": {
              "channel": "ares_channel_t",
              "now": "struct timeval",
              "dnsrec": "ares_dns_record_t",
              "dnsrec_resp": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_qcache_insert(ares_channel_t       *channel,\n                                 const struct timeval *now,\n                                 const struct query   *query,\n                                 ares_dns_record_t    *dnsrec)\n{\n  return ares__qcache_insert(channel->qcache, dnsrec, query->qbuf, query->qlen,\n                             now);\n}",
          "fn_code_pos": [
            [
              436,
              0
            ],
            [
              443,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_insert",
            "parameters": {
              "channel": "ares_channel_t",
              "now": "struct timeval",
              "query": "struct query",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares__qcache_calc_key(const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              42,
              13
            ],
            [
              42,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__qcache_calc_key",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__qcache_calc_key_frombuf(const unsigned char *qbuf,\n                                           size_t               qlen)",
          "fn_dec_pos": [
            [
              298,
              13
            ],
            [
              299,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__qcache_calc_key_frombuf",
            "parameters": {
              "qbuf": "unsigned char",
              "qlen": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares__qcache {\n  ares__htable_strvp_t *cache;\n  ares__slist_t        *expire;\n  unsigned int          max_ttl;\n}",
          {
            "*cache": "ares__htable_strvp_t",
            "*expire": "ares__slist_t",
            "max_ttl": "unsigned int"
          },
          "ares__qcache",
          [
            29,
            0
          ],
          [
            33,
            1
          ]
        ],
        [
          "typedef struct {\n  char              *key;\n  ares_dns_record_t *dnsrec;\n  time_t             expire_ts;\n  time_t             insert_ts;\n} ares__qcache_entry_t;",
          {
            "*key": "char",
            "*dnsrec": "ares_dns_record_t",
            "expire_ts": "time_t",
            "insert_ts": "time_t"
          },
          "ares__qcache_entry_t",
          [
            35,
            0
          ],
          [
            40,
            23
          ]
        ],
        [
          "struct ares__qcache {\n  ares__htable_strvp_t *cache;\n  ares__slist_t        *expire;\n  unsigned int          max_ttl;\n}",
          {
            "*cache": "ares__htable_strvp_t",
            "*expire": "ares__slist_t",
            "max_ttl": "unsigned int"
          },
          "ares__qcache",
          [
            29,
            0
          ],
          [
            33,
            1
          ]
        ],
        [
          "typedef struct {\n  char              *key;\n  ares_dns_record_t *dnsrec;\n  time_t             expire_ts;\n  time_t             insert_ts;\n} ares__qcache_entry_t;",
          {
            "*key": "char",
            "*dnsrec": "ares_dns_record_t",
            "expire_ts": "time_t",
            "insert_ts": "time_t"
          },
          "ares__qcache_entry_t",
          [
            35,
            0
          ],
          [
            40,
            23
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            139,
            38
          ],
          [
            139,
            52
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            160,
            2
          ],
          [
            160,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            321,
            47
          ],
          [
            321,
            61
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            396,
            38
          ],
          [
            396,
            52
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            437,
            39
          ],
          [
            437,
            53
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            438,
            39
          ],
          [
            438,
            51
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_cancel.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_cancel(ares_channel_t *channel)\n{\n  if (channel == NULL) {\n    return;\n  }\n\n  ares__channel_lock(channel);\n\n  if (ares__llist_len(channel->all_queries) > 0) {\n    ares__llist_node_t *node = NULL;\n    ares__llist_node_t *next = NULL;\n\n    /* Swap list heads, so that only those queries which were present on entry\n     * into this function are cancelled. New queries added by callbacks of\n     * queries being cancelled will not be cancelled themselves.\n     */\n    ares__llist_t      *list_copy = channel->all_queries;\n    channel->all_queries          = ares__llist_create(NULL);\n\n    /* Out of memory, this function doesn't return a result code though so we\n     * can't report to caller */\n    if (channel->all_queries == NULL) {\n      channel->all_queries = list_copy;\n      goto done;\n    }\n\n    node = ares__llist_node_first(list_copy);\n    while (node != NULL) {\n      struct query             *query;\n      struct server_connection *conn;\n\n      /* Cache next since this node is being deleted */\n      next = ares__llist_node_next(node);\n\n      query                   = ares__llist_node_claim(node);\n      conn                    = query->conn;\n      query->node_all_queries = NULL;\n\n      /* NOTE: its possible this may enqueue new queries */\n      query->callback(query->arg, ARES_ECANCELLED, 0, NULL);\n      ares__free_query(query);\n\n      /* See if the connection should be cleaned up */\n      ares__check_cleanup_conn(channel, conn);\n\n      node = next;\n    }\n\n    ares__llist_destroy(list_copy);\n  }\n\n  ares_queue_notify_empty(channel);\n\ndone:\n  ares__channel_unlock(channel);\n}",
          "fn_code_pos": [
            [
              37,
              0
            ],
            [
              92,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_cancel",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct query",
          {},
          "",
          [
            65,
            6
          ],
          [
            65,
            18
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            66,
            6
          ],
          [
            66,
            30
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_options.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_destroy_options(struct ares_options *options)\n{\n  int i;\n\n  ares_free(options->servers);\n\n  for (i = 0; options->domains && i < options->ndomains; i++) {\n    ares_free(options->domains[i]);\n  }\n\n  ares_free(options->domains);\n  ares_free(options->sortlist);\n  ares_free(options->lookups);\n  ares_free(options->resolvconf_path);\n  ares_free(options->hosts_path);\n}",
          "fn_code_pos": [
            [
              38,
              0
            ],
            [
              53,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_destroy_options",
            "parameters": {
              "options": "struct ares_options"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static struct in_addr *ares_save_opt_servers(ares_channel_t *channel,\n                                             int            *nservers)\n{\n  ares__slist_node_t *snode;\n  struct in_addr     *out =\n    ares_malloc_zero(ares__slist_len(channel->servers) * sizeof(*out));\n\n  *nservers = 0;\n\n  if (out == NULL) {\n    return NULL;\n  }\n\n  for (snode = ares__slist_node_first(channel->servers); snode != NULL;\n       snode = ares__slist_node_next(snode)) {\n    const struct server_state *server = ares__slist_node_val(snode);\n\n    if (server->addr.family != AF_INET) {\n      continue;\n    }\n\n    memcpy(&out[*nservers], &server->addr.addr.addr4, sizeof(*out));\n    (*nservers)++;\n  }\n\n  return out;\n}",
          "fn_code_pos": [
            [
              55,
              0
            ],
            [
              81,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_save_opt_servers",
            "parameters": {
              "channel": "ares_channel_t",
              "nservers": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "int ares_save_options(ares_channel_t *channel, struct ares_options *options,\n                      int *optmask)\n{\n  size_t i;\n\n  /* NOTE: We can't zero the whole thing out, this is because the size of the\n   *       struct ares_options changes over time, so if someone compiled\n   *       with an older version, their struct size might be smaller and\n   *       we might overwrite their memory! So using the optmask is critical\n   *       here, as they could have only set options they knew about.\n   *\n   *       Unfortunately ares_destroy_options() doesn't take an optmask, so\n   *       there are a few pointers we *must* zero out otherwise we won't\n   *       know if they were allocated or not\n   */\n  options->servers         = NULL;\n  options->domains         = NULL;\n  options->sortlist        = NULL;\n  options->lookups         = NULL;\n  options->resolvconf_path = NULL;\n  options->hosts_path      = NULL;\n\n  if (!ARES_CONFIG_CHECK(channel)) {\n    return ARES_ENODATA;\n  }\n\n  if (channel->optmask & ARES_OPT_FLAGS) {\n    options->flags = (int)channel->flags;\n  }\n\n  /* We convert ARES_OPT_TIMEOUT to ARES_OPT_TIMEOUTMS in\n   * ares__init_by_options() */\n  if (channel->optmask & ARES_OPT_TIMEOUTMS) {\n    options->timeout = (int)channel->timeout;\n  }\n\n  if (channel->optmask & ARES_OPT_TRIES) {\n    options->tries = (int)channel->tries;\n  }\n\n  if (channel->optmask & ARES_OPT_NDOTS) {\n    options->ndots = (int)channel->ndots;\n  }\n\n  if (channel->optmask & ARES_OPT_MAXTIMEOUTMS) {\n    options->maxtimeout = (int)channel->maxtimeout;\n  }\n\n  if (channel->optmask & ARES_OPT_UDP_PORT) {\n    options->udp_port = channel->udp_port;\n  }\n  if (channel->optmask & ARES_OPT_TCP_PORT) {\n    options->tcp_port = channel->tcp_port;\n  }\n\n  if (channel->optmask & ARES_OPT_SOCK_STATE_CB) {\n    options->sock_state_cb      = channel->sock_state_cb;\n    options->sock_state_cb_data = channel->sock_state_cb_data;\n  }\n\n  if (channel->optmask & ARES_OPT_SERVERS) {\n    options->servers = ares_save_opt_servers(channel, &options->nservers);\n    if (options->servers == NULL) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  if (channel->optmask & ARES_OPT_DOMAINS) {\n    options->domains = NULL;\n    if (channel->ndomains) {\n      options->domains = ares_malloc(channel->ndomains * sizeof(char *));\n      if (!options->domains) {\n        return ARES_ENOMEM;\n      }\n\n      for (i = 0; i < channel->ndomains; i++) {\n        options->domains[i] = ares_strdup(channel->domains[i]);\n        if (!options->domains[i]) {\n          options->ndomains = (int)i;\n          return ARES_ENOMEM;\n        }\n      }\n    }\n    options->ndomains = (int)channel->ndomains;\n  }\n\n  if (channel->optmask & ARES_OPT_LOOKUPS) {\n    options->lookups = ares_strdup(channel->lookups);\n    if (!options->lookups && channel->lookups) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  if (channel->optmask & ARES_OPT_SORTLIST) {\n    options->sortlist = NULL;\n    if (channel->nsort) {\n      options->sortlist = ares_malloc(channel->nsort * sizeof(struct apattern));\n      if (!options->sortlist) {\n        return ARES_ENOMEM;\n      }\n      for (i = 0; i < channel->nsort; i++) {\n        options->sortlist[i] = channel->sortlist[i];\n      }\n    }\n    options->nsort = (int)channel->nsort;\n  }\n\n  if (channel->optmask & ARES_OPT_RESOLVCONF) {\n    options->resolvconf_path = ares_strdup(channel->resolvconf_path);\n    if (!options->resolvconf_path) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  if (channel->optmask & ARES_OPT_HOSTS_FILE) {\n    options->hosts_path = ares_strdup(channel->hosts_path);\n    if (!options->hosts_path) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  if (channel->optmask & ARES_OPT_SOCK_SNDBUF &&\n      channel->socket_send_buffer_size > 0) {\n    options->socket_send_buffer_size = channel->socket_send_buffer_size;\n  }\n\n  if (channel->optmask & ARES_OPT_SOCK_RCVBUF &&\n      channel->socket_receive_buffer_size > 0) {\n    options->socket_receive_buffer_size = channel->socket_receive_buffer_size;\n  }\n\n  if (channel->optmask & ARES_OPT_EDNSPSZ) {\n    options->ednspsz = (int)channel->ednspsz;\n  }\n\n  if (channel->optmask & ARES_OPT_UDP_MAX_QUERIES) {\n    options->udp_max_queries = (int)channel->udp_max_queries;\n  }\n\n  if (channel->optmask & ARES_OPT_QUERY_CACHE) {\n    options->qcache_max_ttl = channel->qcache_max_ttl;\n  }\n\n  if (channel->optmask & ARES_OPT_EVENT_THREAD) {\n    options->evsys = channel->evsys;\n  }\n\n  /* Set options for server failover behavior */\n  if (channel->optmask & ARES_OPT_SERVER_FAILOVER) {\n    options->server_failover_opts.retry_chance =\n      channel->server_retry_chance;\n    options->server_failover_opts.retry_delay =\n      channel->server_retry_delay;\n  }\n\n  *optmask = (int)channel->optmask;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              242,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_save_options",
            "parameters": {
              "channel": "ares_channel_t",
              "options": "struct ares_options",
              "optmask": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static ares_status_t ares__init_options_servers(ares_channel_t       *channel,\n                                                const struct in_addr *servers,\n                                                size_t                nservers)\n{\n  ares__llist_t *slist = NULL;\n  ares_status_t  status;\n\n  status = ares_in_addr_to_server_config_llist(servers, nservers, &slist);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares__servers_update(channel, slist, ARES_TRUE);\n\n  ares__llist_destroy(slist);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              244,
              0
            ],
            [
              261,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_options_servers",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "struct in_addr",
              "nservers": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__init_by_options(ares_channel_t            *channel,\n                                    const struct ares_options *options,\n                                    int                        optmask)\n{\n  size_t i;\n\n  if (channel == NULL) {\n    return ARES_ENODATA;\n  }\n\n  if (options == NULL) {\n    if (optmask != 0) {\n      return ARES_ENODATA;\n    }\n    return ARES_SUCCESS;\n  }\n\n  /* Easy stuff. */\n\n  /* Event Thread requires threading support and is incompatible with socket\n   * state callbacks */\n  if (optmask & ARES_OPT_EVENT_THREAD) {\n    if (!ares_threadsafety()) {\n      return ARES_ENOTIMP;\n    }\n    if (optmask & ARES_OPT_SOCK_STATE_CB) {\n      return ARES_EFORMERR;\n    }\n    channel->evsys = options->evsys;\n  }\n\n  if (optmask & ARES_OPT_FLAGS) {\n    channel->flags = (unsigned int)options->flags;\n  }\n\n  if (optmask & ARES_OPT_TIMEOUTMS) {\n    /* Apparently some integrations were passing -1 to tell c-ares to use\n     * the default instead of just omitting the optmask */\n    if (options->timeout <= 0) {\n      optmask &= ~(ARES_OPT_TIMEOUTMS);\n    } else {\n      channel->timeout = (unsigned int)options->timeout;\n    }\n  } else if (optmask & ARES_OPT_TIMEOUT) {\n    optmask &= ~(ARES_OPT_TIMEOUT);\n    /* Apparently some integrations were passing -1 to tell c-ares to use\n     * the default instead of just omitting the optmask */\n    if (options->timeout > 0) {\n      /* Convert to milliseconds */\n      optmask          |= ARES_OPT_TIMEOUTMS;\n      channel->timeout  = (unsigned int)options->timeout * 1000;\n    }\n  }\n\n  if (optmask & ARES_OPT_TRIES) {\n    if (options->tries <= 0) {\n      optmask &= ~(ARES_OPT_TRIES);\n    } else {\n      channel->tries = (size_t)options->tries;\n    }\n  }\n\n  if (optmask & ARES_OPT_NDOTS) {\n    if (options->ndots < 0) {\n      optmask &= ~(ARES_OPT_NDOTS);\n    } else {\n      channel->ndots = (size_t)options->ndots;\n    }\n  }\n\n  if (optmask & ARES_OPT_MAXTIMEOUTMS) {\n    if (options->maxtimeout <= 0) {\n      optmask &= ~(ARES_OPT_MAXTIMEOUTMS);\n    } else {\n      channel->maxtimeout = (size_t)options->maxtimeout;\n    }\n  }\n\n  if (optmask & ARES_OPT_ROTATE) {\n    channel->rotate = ARES_TRUE;\n  }\n\n  if (optmask & ARES_OPT_NOROTATE) {\n    channel->rotate = ARES_FALSE;\n  }\n\n  if (optmask & ARES_OPT_UDP_PORT) {\n    channel->udp_port = options->udp_port;\n  }\n\n  if (optmask & ARES_OPT_TCP_PORT) {\n    channel->tcp_port = options->tcp_port;\n  }\n\n  if (optmask & ARES_OPT_SOCK_STATE_CB) {\n    channel->sock_state_cb      = options->sock_state_cb;\n    channel->sock_state_cb_data = options->sock_state_cb_data;\n  }\n\n  if (optmask & ARES_OPT_SOCK_SNDBUF) {\n    if (options->socket_send_buffer_size <= 0) {\n      optmask &= ~(ARES_OPT_SOCK_SNDBUF);\n    } else {\n      channel->socket_send_buffer_size = options->socket_send_buffer_size;\n    }\n  }\n\n  if (optmask & ARES_OPT_SOCK_RCVBUF) {\n    if (options->socket_receive_buffer_size <= 0) {\n      optmask &= ~(ARES_OPT_SOCK_RCVBUF);\n    } else {\n      channel->socket_receive_buffer_size = options->socket_receive_buffer_size;\n    }\n  }\n\n  if (optmask & ARES_OPT_EDNSPSZ) {\n    if (options->ednspsz <= 0) {\n      optmask &= ~(ARES_OPT_EDNSPSZ);\n    } else {\n      channel->ednspsz = (size_t)options->ednspsz;\n    }\n  }\n\n  /* Copy the domains, if given.  Keep channel->ndomains consistent so\n   * we can clean up in case of error.\n   */\n  if (optmask & ARES_OPT_DOMAINS && options->ndomains > 0) {\n    channel->domains =\n      ares_malloc_zero((size_t)options->ndomains * sizeof(char *));\n    if (!channel->domains) {\n      return ARES_ENOMEM;\n    }\n    channel->ndomains = (size_t)options->ndomains;\n    for (i = 0; i < (size_t)options->ndomains; i++) {\n      channel->domains[i] = ares_strdup(options->domains[i]);\n      if (!channel->domains[i]) {\n        return ARES_ENOMEM;\n      }\n    }\n  }\n\n  /* Set lookups, if given. */\n  if (optmask & ARES_OPT_LOOKUPS) {\n    if (options->lookups == NULL) {\n      optmask &= ~(ARES_OPT_LOOKUPS);\n    } else {\n      channel->lookups = ares_strdup(options->lookups);\n      if (!channel->lookups) {\n        return ARES_ENOMEM;\n      }\n    }\n  }\n\n  /* copy sortlist */\n  if (optmask & ARES_OPT_SORTLIST && options->nsort > 0) {\n    channel->nsort = (size_t)options->nsort;\n    channel->sortlist =\n      ares_malloc((size_t)options->nsort * sizeof(struct apattern));\n    if (!channel->sortlist) {\n      return ARES_ENOMEM;\n    }\n    for (i = 0; i < (size_t)options->nsort; i++) {\n      channel->sortlist[i] = options->sortlist[i];\n    }\n  }\n\n  /* Set path for resolv.conf file, if given. */\n  if (optmask & ARES_OPT_RESOLVCONF) {\n    if (options->resolvconf_path == NULL) {\n      optmask &= ~(ARES_OPT_RESOLVCONF);\n    } else {\n      channel->resolvconf_path = ares_strdup(options->resolvconf_path);\n      if (channel->resolvconf_path == NULL) {\n        return ARES_ENOMEM;\n      }\n    }\n  }\n\n  /* Set path for hosts file, if given. */\n  if (optmask & ARES_OPT_HOSTS_FILE) {\n    if (options->hosts_path == NULL) {\n      optmask &= ~(ARES_OPT_HOSTS_FILE);\n    } else {\n      channel->hosts_path = ares_strdup(options->hosts_path);\n      if (channel->hosts_path == NULL) {\n        return ARES_ENOMEM;\n      }\n    }\n  }\n\n  if (optmask & ARES_OPT_UDP_MAX_QUERIES) {\n    if (options->udp_max_queries <= 0) {\n      optmask &= ~(ARES_OPT_UDP_MAX_QUERIES);\n    } else {\n      channel->udp_max_queries = (size_t)options->udp_max_queries;\n    }\n  }\n\n  if (optmask & ARES_OPT_QUERY_CACHE) {\n    /* qcache_max_ttl is unsigned unlike the others */\n    if (options->qcache_max_ttl == 0) {\n      optmask &= ~(ARES_OPT_QUERY_CACHE);\n    } else {\n      channel->qcache_max_ttl = options->qcache_max_ttl;\n    }\n  }\n\n  /* Initialize the ipv4 servers if provided */\n  if (optmask & ARES_OPT_SERVERS) {\n    if (options->nservers <= 0) {\n      optmask &= ~(ARES_OPT_SERVERS);\n    } else {\n      ares_status_t status;\n      status = ares__init_options_servers(channel, options->servers,\n                                          (size_t)options->nservers);\n      if (status != ARES_SUCCESS) {\n        return status;\n      }\n    }\n  }\n\n  /* Set fields for server failover behavior */\n  if (optmask & ARES_OPT_SERVER_FAILOVER) {\n    channel->server_retry_chance =\n      options->server_failover_opts.retry_chance;\n    channel->server_retry_delay =\n      options->server_failover_opts.retry_delay;\n  }\n\n  channel->optmask = (unsigned int)optmask;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              263,
              0
            ],
            [
              495,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_by_options",
            "parameters": {
              "channel": "ares_channel_t",
              "options": "struct ares_options",
              "optmask": "int"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_save_opt_servers(ares_channel_t *channel,\n                                             int            *nservers)",
          "fn_dec_pos": [
            [
              55,
              23
            ],
            [
              56,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_save_opt_servers",
            "parameters": {
              "channel": "ares_channel_t",
              "nservers": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_options",
          {},
          "",
          [
            38,
            26
          ],
          [
            38,
            45
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            55,
            7
          ],
          [
            55,
            21
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            59,
            2
          ],
          [
            59,
            16
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            70,
            10
          ],
          [
            70,
            29
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            84,
            47
          ],
          [
            84,
            66
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            180,
            62
          ],
          [
            180,
            77
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            245,
            54
          ],
          [
            245,
            68
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            264,
            42
          ],
          [
            264,
            61
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            420,
            50
          ],
          [
            420,
            65
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_dns_name.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares__nameoffset_free(void *arg)\n{\n  ares_nameoffset_t *off = arg;\n  if (off == NULL) {\n    return;\n  }\n  ares_free(off->name);\n  ares_free(off);\n}",
          "fn_code_pos": [
            [
              35,
              0
            ],
            [
              43,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__nameoffset_free",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t ares__nameoffset_create(ares__llist_t **list,\n                                             const char *name, size_t idx)\n{\n  ares_status_t      status;\n  ares_nameoffset_t *off = NULL;\n\n  if (list == NULL || name == NULL || ares_strlen(name) == 0 ||\n      ares_strlen(name) > 255) {\n    return ARES_EFORMERR;\n  }\n\n  if (*list == NULL) {\n    *list = ares__llist_create(ares__nameoffset_free);\n  }\n  if (*list == NULL) {\n    status = ARES_ENOMEM;\n    goto fail;\n  }\n\n  off = ares_malloc_zero(sizeof(*off));\n  if (off == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  off->name     = ares_strdup(name);\n  off->name_len = ares_strlen(off->name);\n  off->idx      = idx;\n\n  if (ares__llist_insert_last(*list, off) == NULL) {\n    status = ARES_ENOMEM;\n    goto fail;\n  }\n\n  return ARES_SUCCESS;\n\nfail:\n  ares__nameoffset_free(off);\n  return status;\n}",
          "fn_code_pos": [
            [
              45,
              0
            ],
            [
              83,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__nameoffset_create",
            "parameters": {
              "list": "ares__llist_t",
              "name": "char",
              "idx": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static const ares_nameoffset_t *ares__nameoffset_find(ares__llist_t *list,\n                                                      const char    *name)\n{\n  size_t                   name_len = ares_strlen(name);\n  ares__llist_node_t      *node;\n  const ares_nameoffset_t *longest_match = NULL;\n\n  if (list == NULL || name == NULL || name_len == 0) {\n    return NULL;\n  }\n\n  for (node = ares__llist_node_first(list); node != NULL;\n       node = ares__llist_node_next(node)) {\n    const ares_nameoffset_t *val = ares__llist_node_val(node);\n    size_t                   prefix_len;\n\n    /* Can't be a match if the stored name is longer */\n    if (val->name_len > name_len) {\n      continue;\n    }\n\n    /* Can't be the longest match if our existing longest match is longer */\n    if (longest_match != NULL && longest_match->name_len > val->name_len) {\n      continue;\n    }\n\n    prefix_len = name_len - val->name_len;\n\n    if (strcasecmp(val->name, name + prefix_len) != 0) {\n      continue;\n    }\n\n    /* We need to make sure if `val->name` is \"example.com\" that name is\n     * is separated by a label, e.g. \"myexample.com\" is not ok, however\n     * \"my.example.com\" is, so we look for the preceding \".\" */\n    if (prefix_len != 0 && name[prefix_len - 1] != '.') {\n      continue;\n    }\n\n    longest_match = val;\n  }\n\n  return longest_match;\n}",
          "fn_code_pos": [
            [
              85,
              0
            ],
            [
              128,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__nameoffset_find",
            "parameters": {
              "list": "ares__llist_t",
              "name": "char"
            },
            "return_type": "ares_nameoffset_t"
          }
        },
        {
          "fn_code": "static void ares_dns_labels_free(ares_dns_labels_t *labels)\n{\n  size_t i;\n\n  if (labels == NULL) {\n    return;\n  }\n\n  for (i = 0; i < labels->num; i++) {\n    ares__buf_destroy(labels->label[i]);\n    labels->label[i] = NULL;\n  }\n  ares_free(labels->label);\n  labels->label = NULL;\n  labels->num   = 0;\n}",
          "fn_code_pos": [
            [
              135,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_labels_free",
            "parameters": {
              "labels": "ares_dns_labels_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares__buf_t *ares_dns_labels_add(ares_dns_labels_t *labels)\n{\n  void *temp;\n\n  if (labels == NULL) {\n    return NULL;\n  }\n\n  temp = ares_realloc_zero(labels->label, sizeof(*labels->label) * labels->num,\n                           sizeof(*labels->label) * (labels->num + 1));\n  if (temp == NULL) {\n    return NULL;\n  }\n\n  labels->label = temp;\n\n  labels->label[labels->num] = ares__buf_create();\n  if (labels->label[labels->num] == NULL) {\n    return NULL;\n  }\n\n  labels->num++;\n  return labels->label[labels->num - 1];\n}",
          "fn_code_pos": [
            [
              152,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_labels_add",
            "parameters": {
              "labels": "ares_dns_labels_t"
            },
            "return_type": "ares__buf_t"
          }
        },
        {
          "fn_code": "static const ares__buf_t *\n  ares_dns_labels_get_last(const ares_dns_labels_t *labels)\n{\n  if (labels == NULL || labels->num == 0) {\n    return NULL;\n  }\n\n  return labels->label[labels->num - 1];\n}",
          "fn_code_pos": [
            [
              177,
              0
            ],
            [
              185,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_labels_get_last",
            "parameters": {
              "labels": "ares_dns_labels_t"
            },
            "return_type": "ares__buf_t"
          }
        },
        {
          "fn_code": "static void ares_dns_name_labels_del_last(ares_dns_labels_t *labels)\n{\n  if (labels == NULL || labels->num == 0) {\n    return;\n  }\n\n  ares__buf_destroy(labels->label[labels->num - 1]);\n  labels->label[labels->num - 1] = NULL;\n  labels->num--;\n}",
          "fn_code_pos": [
            [
              187,
              0
            ],
            [
              196,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_name_labels_del_last",
            "parameters": {
              "labels": "ares_dns_labels_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t ares_parse_dns_name_escape(ares__buf_t *namebuf,\n                                                ares__buf_t *label,\n                                                ares_bool_t  validate_hostname)\n{\n  ares_status_t status;\n  unsigned char c;\n\n  status = ares__buf_fetch_bytes(namebuf, &c, 1);\n  if (status != ARES_SUCCESS) {\n    return ARES_EBADNAME;\n  }\n\n  /* If next character is a digit, read 2 more digits */\n  if (isdigit(c)) {\n    size_t       i;\n    unsigned int val = 0;\n\n    val = c - '0';\n\n    for (i = 0; i < 2; i++) {\n      status = ares__buf_fetch_bytes(namebuf, &c, 1);\n      if (status != ARES_SUCCESS) {\n        return ARES_EBADNAME;\n      }\n\n      if (!isdigit(c)) {\n        return ARES_EBADNAME;\n      }\n      val *= 10;\n      val += c - '0';\n    }\n\n    /* Out of range */\n    if (val > 255) {\n      return ARES_EBADNAME;\n    }\n\n    if (validate_hostname && !ares__is_hostnamech((unsigned char)val)) {\n      return ARES_EBADNAME;\n    }\n\n    return ares__buf_append_byte(label, (unsigned char)val);\n  }\n\n  /* We can just output the character */\n  if (validate_hostname && !ares__is_hostnamech(c)) {\n    return ARES_EBADNAME;\n  }\n\n  return ares__buf_append_byte(label, c);\n}",
          "fn_code_pos": [
            [
              198,
              0
            ],
            [
              248,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_dns_name_escape",
            "parameters": {
              "namebuf": "ares__buf_t",
              "label": "ares__buf_t",
              "validate_hostname": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_split_dns_name(ares_dns_labels_t *labels,\n                                         ares_bool_t        validate_hostname,\n                                         const char        *name)\n{\n  ares_status_t status;\n  ares__buf_t  *label   = NULL;\n  ares__buf_t  *namebuf = NULL;\n  size_t        i;\n  size_t        total_len = 0;\n  unsigned char c;\n\n  if (name == NULL || labels == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  /* Put name into a buffer for parsing */\n  namebuf = ares__buf_create();\n  if (namebuf == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  if (*name != '\\0') {\n    status =\n      ares__buf_append(namebuf, (const unsigned char *)name, ares_strlen(name));\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\n  /* Start with 1 label */\n  label = ares_dns_labels_add(labels);\n  if (label == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  while (ares__buf_fetch_bytes(namebuf, &c, 1) == ARES_SUCCESS) {\n    /* New label */\n    if (c == '.') {\n      label = ares_dns_labels_add(labels);\n      if (label == NULL) {\n        status = ARES_ENOMEM;\n        goto done;\n      }\n      continue;\n    }\n\n    /* Escape */\n    if (c == '\\\\') {\n      status = ares_parse_dns_name_escape(namebuf, label, validate_hostname);\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n      continue;\n    }\n\n    /* Output direct character */\n    if (validate_hostname && !ares__is_hostnamech(c)) {\n      status = ARES_EBADNAME;\n      goto done;\n    }\n\n    status = ares__buf_append_byte(label, c);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\n  /* Remove trailing blank label */\n  if (ares__buf_len(ares_dns_labels_get_last(labels)) == 0) {\n    ares_dns_name_labels_del_last(labels);\n  }\n\n  /* If someone passed in \".\" there could have been 2 blank labels, check for\n   * that */\n  if (labels->num == 1 &&\n      ares__buf_len(ares_dns_labels_get_last(labels)) == 0) {\n    ares_dns_name_labels_del_last(labels);\n  }\n\n  /* Scan to make sure label lengths are valid */\n  for (i = 0; i < labels->num; i++) {\n    size_t len = ares__buf_len(labels->label[i]);\n    /* No 0-length labels, and no labels over 63 bytes */\n    if (len == 0 || len > 63) {\n      status = ARES_EBADNAME;\n      goto done;\n    }\n    total_len += len;\n  }\n\n  /* Can't exceed maximum (unescaped) length */\n  if (labels->num && total_len + labels->num - 1 > 255) {\n    status = ARES_EBADNAME;\n    goto done;\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  ares__buf_destroy(namebuf);\n  if (status != ARES_SUCCESS) {\n    ares_dns_labels_free(labels);\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              250,
              0
            ],
            [
              356,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_split_dns_name",
            "parameters": {
              "labels": "ares_dns_labels_t",
              "validate_hostname": "ares_bool_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__dns_name_write(ares__buf_t *buf, ares__llist_t **list,\n                                   ares_bool_t validate_hostname,\n                                   const char *name)\n{\n  const ares_nameoffset_t *off = NULL;\n  size_t                   name_len;\n  size_t                   pos = ares__buf_len(buf);\n  ares_dns_labels_t        labels;\n  char                     name_copy[512];\n  ares_status_t            status;\n\n  if (buf == NULL || name == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  memset(&labels, 0, sizeof(labels));\n\n  /* NOTE: due to possible escaping, name_copy buffer is > 256 to allow for\n   *       this */\n  name_len = ares_strcpy(name_copy, name, sizeof(name_copy));\n\n  /* Find longest match */\n  if (list != NULL) {\n    off = ares__nameoffset_find(*list, name_copy);\n    if (off != NULL && off->name_len != name_len) {\n      /* truncate */\n      name_len            -= (off->name_len + 1);\n      name_copy[name_len]  = 0;\n    }\n  }\n\n  /* Output labels */\n  if (off == NULL || off->name_len != name_len) {\n    size_t i;\n\n    status = ares_split_dns_name(&labels, validate_hostname, name_copy);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    for (i = 0; i < labels.num; i++) {\n      size_t               len = 0;\n      const unsigned char *ptr = ares__buf_peek(labels.label[i], &len);\n\n      status = ares__buf_append_byte(buf, (unsigned char)(len & 0xFF));\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n\n      status = ares__buf_append(buf, ptr, len);\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n    }\n\n    /* If we are NOT jumping to another label, output terminator */\n    if (off == NULL) {\n      status = ares__buf_append_byte(buf, 0);\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n    }\n  }\n\n  /* Output name compression offset jump */\n  if (off != NULL) {\n    unsigned short u16 =\n      (unsigned short)0xC000 | (unsigned short)(off->idx & 0x3FFF);\n    status = ares__buf_append_be16(buf, u16);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\n  /* Store pointer for future jumps as long as its not an exact match for\n   * a prior entry */\n  if (list != NULL && (off == NULL || off->name_len != name_len) &&\n      name_len > 0) {\n    status = ares__nameoffset_create(list, name /* not truncated copy! */, pos);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  ares_dns_labels_free(&labels);\n  return status;\n}",
          "fn_code_pos": [
            [
              358,
              0
            ],
            [
              447,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__dns_name_write",
            "parameters": {
              "buf": "ares__buf_t",
              "list": "ares__llist_t",
              "validate_hostname": "ares_bool_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_bool_t is_reservedch(int ch)\n{\n  switch (ch) {\n    case '\"':\n    case '.':\n    case ';':\n    case '\\\\':\n    case '(':\n    case ')':\n    case '@':\n    case '$':\n      return ARES_TRUE;\n    default:\n      break;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              450,
              0
            ],
            [
              467,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "is_reservedch",
            "parameters": {
              "ch": "int"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__fetch_dnsname_into_buf(ares__buf_t *buf,\n                                                  ares__buf_t *dest, size_t len,\n                                                  ares_bool_t is_hostname)\n{\n  size_t               remaining_len;\n  const unsigned char *ptr = ares__buf_peek(buf, &remaining_len);\n  ares_status_t        status;\n  size_t               i;\n\n  if (buf == NULL || len == 0 || remaining_len < len) {\n    return ARES_EBADRESP;\n  }\n\n  for (i = 0; i < len; i++) {\n    unsigned char c = ptr[i];\n\n    /* Hostnames have a very specific allowed character set.  Anything outside\n     * of that (non-printable and reserved included) are disallowed */\n    if (is_hostname && !ares__is_hostnamech(c)) {\n      status = ARES_EBADRESP;\n      goto fail;\n    }\n\n    /* NOTE: dest may be NULL if the user is trying to skip the name. validation\n     *       still occurs above. */\n    if (dest == NULL) {\n      continue;\n    }\n\n    /* Non-printable characters need to be output as \\DDD */\n    if (!ares__isprint(c)) {\n      unsigned char escape[4];\n\n      escape[0] = '\\\\';\n      escape[1] = '0' + (c / 100);\n      escape[2] = '0' + ((c % 100) / 10);\n      escape[3] = '0' + (c % 10);\n\n      status = ares__buf_append(dest, escape, sizeof(escape));\n      if (status != ARES_SUCCESS) {\n        goto fail;\n      }\n\n      continue;\n    }\n\n    /* Reserved characters need to be escaped, otherwise normal */\n    if (is_reservedch(c)) {\n      status = ares__buf_append_byte(dest, '\\\\');\n      if (status != ARES_SUCCESS) {\n        goto fail;\n      }\n    }\n\n    status = ares__buf_append_byte(dest, c);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return ares__buf_consume(buf, len);\n\nfail:\n  return status;\n}",
          "fn_code_pos": [
            [
              469,
              0
            ],
            [
              533,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__fetch_dnsname_into_buf",
            "parameters": {
              "buf": "ares__buf_t",
              "dest": "ares__buf_t",
              "len": "size_t",
              "is_hostname": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__dns_name_parse(ares__buf_t *buf, char **name,\n                                   ares_bool_t is_hostname)\n{\n  size_t        save_offset = 0;\n  unsigned char c;\n  ares_status_t status;\n  ares__buf_t  *namebuf     = NULL;\n  size_t        label_start = ares__buf_get_position(buf);\n\n  if (buf == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (name != NULL) {\n    namebuf = ares__buf_create();\n    if (namebuf == NULL) {\n      status = ARES_ENOMEM;\n      goto fail;\n    }\n  }\n\n  /* The compression scheme allows a domain name in a message to be\n   * represented as either:\n   *\n   * - a sequence of labels ending in a zero octet\n   * - a pointer\n   * - a sequence of labels ending with a pointer\n   */\n  while (1) {\n    /* Keep track of the minimum label starting position to prevent forward\n     * jumping */\n    if (label_start > ares__buf_get_position(buf)) {\n      label_start = ares__buf_get_position(buf);\n    }\n\n    status = ares__buf_fetch_bytes(buf, &c, 1);\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n\n    /* Pointer/Redirect */\n    if ((c & 0xc0) == 0xc0) {\n      /* The pointer takes the form of a two octet sequence:\n       *\n       *   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n       *   | 1  1|                OFFSET                   |\n       *   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n       *\n       * The first two bits are ones.  This allows a pointer to be distinguished\n       * from a label, since the label must begin with two zero bits because\n       * labels are restricted to 63 octets or less.  (The 10 and 01\n       * combinations are reserved for future use.)  The OFFSET field specifies\n       * an offset from the start of the message (i.e., the first octet of the\n       * ID field in the domain header).  A zero offset specifies the first byte\n       * of the ID field, etc.\n       */\n      size_t offset = (size_t)((c & 0x3F) << 8);\n\n      /* Fetch second byte of the redirect length */\n      status = ares__buf_fetch_bytes(buf, &c, 1);\n      if (status != ARES_SUCCESS) {\n        goto fail;\n      }\n\n      offset |= ((size_t)c);\n\n      /* According to RFC 1035 4.1.4:\n       *    In this scheme, an entire domain name or a list of labels at\n       *    the end of a domain name is replaced with a pointer to a prior\n       *    occurrence of the same name.\n       * Note the word \"prior\", meaning it must go backwards.  This was\n       * confirmed via the ISC BIND code that it also prevents forward\n       * pointers.\n       */\n      if (offset >= label_start) {\n        status = ARES_EBADNAME;\n        goto fail;\n      }\n\n      /* First time we make a jump, save the current position */\n      if (save_offset == 0) {\n        save_offset = ares__buf_get_position(buf);\n      }\n\n      status = ares__buf_set_position(buf, offset);\n      if (status != ARES_SUCCESS) {\n        status = ARES_EBADNAME;\n        goto fail;\n      }\n\n      continue;\n    } else if ((c & 0xc0) != 0) {\n      /* 10 and 01 are reserved */\n      status = ARES_EBADNAME;\n      goto fail;\n    } else if (c == 0) {\n      /* termination via zero octet*/\n      break;\n    }\n\n    /* New label */\n\n    /* Labels are separated by periods */\n    if (ares__buf_len(namebuf) != 0 && name != NULL) {\n      status = ares__buf_append_byte(namebuf, '.');\n      if (status != ARES_SUCCESS) {\n        goto fail;\n      }\n    }\n\n    status = ares__fetch_dnsname_into_buf(buf, namebuf, c, is_hostname);\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n\n  /* Restore offset read after first redirect/pointer as this is where the DNS\n   * message continues */\n  if (save_offset) {\n    ares__buf_set_position(buf, save_offset);\n  }\n\n  if (name != NULL) {\n    *name = ares__buf_finish_str(namebuf, NULL);\n    if (*name == NULL) {\n      status = ARES_ENOMEM;\n      goto fail;\n    }\n  }\n\n  return ARES_SUCCESS;\n\nfail:\n  /* We want badname response if we couldn't parse */\n  if (status == ARES_EBADRESP) {\n    status = ARES_EBADNAME;\n  }\n\n  ares__buf_destroy(namebuf);\n  return status;\n}",
          "fn_code_pos": [
            [
              535,
              0
            ],
            [
              675,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__dns_name_parse",
            "parameters": {
              "buf": "ares__buf_t",
              "name": "char",
              "is_hostname": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares__nameoffset_find(ares__llist_t *list,\n                                                      const char    *name)",
          "fn_dec_pos": [
            [
              85,
              32
            ],
            [
              86,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__nameoffset_find",
            "parameters": {
              "list": "ares__llist_t",
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_labels_add(ares_dns_labels_t *labels)",
          "fn_dec_pos": [
            [
              152,
              20
            ],
            [
              152,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_labels_add",
            "parameters": {
              "labels": "ares_dns_labels_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_labels_get_last(const ares_dns_labels_t *labels)",
          "fn_dec_pos": [
            [
              178,
              2
            ],
            [
              178,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_labels_get_last",
            "parameters": {
              "labels": "ares_dns_labels_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  char  *name;\n  size_t name_len;\n  size_t idx;\n} ares_nameoffset_t;",
          {
            "*name": "char",
            "name_len": "size_t",
            "idx": "size_t"
          },
          "ares_nameoffset_t",
          [
            29,
            0
          ],
          [
            33,
            20
          ]
        ],
        [
          "typedef struct {\n  ares__buf_t **label;\n  size_t        num;\n} ares_dns_labels_t;",
          {
            "**label": "ares__buf_t",
            "num": "size_t"
          },
          "ares_dns_labels_t",
          [
            130,
            0
          ],
          [
            133,
            20
          ]
        ],
        [
          "typedef struct {\n  char  *name;\n  size_t name_len;\n  size_t idx;\n} ares_nameoffset_t;",
          {
            "*name": "char",
            "name_len": "size_t",
            "idx": "size_t"
          },
          "ares_nameoffset_t",
          [
            29,
            0
          ],
          [
            33,
            20
          ]
        ],
        [
          "typedef struct {\n  ares__buf_t **label;\n  size_t        num;\n} ares_dns_labels_t;",
          {
            "**label": "ares__buf_t",
            "num": "size_t"
          },
          "ares_dns_labels_t",
          [
            130,
            0
          ],
          [
            133,
            20
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_sysconfig_mac.c": {
      "fn_def_list": [
        {
          "fn_code": "static void dnsinfo_destroy(dnsinfo_t *dnsinfo)\n{\n  if (dnsinfo == NULL) {\n    return;\n  }\n\n  if (dnsinfo->handle) {\n    dlclose(dnsinfo->handle);\n  }\n\n  ares_free(dnsinfo);\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              76,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dnsinfo_destroy",
            "parameters": {
              "dnsinfo": "dnsinfo_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t dnsinfo_init(dnsinfo_t **dnsinfo_out)\n{\n  dnsinfo_t    *dnsinfo = NULL;\n  ares_status_t status  = ARES_SUCCESS;\n\n  if (dnsinfo_out == NULL) {\n    status = ARES_EFORMERR;\n    goto done;\n  }\n\n  *dnsinfo_out = NULL;\n\n  dnsinfo = ares_malloc_zero(sizeof(*dnsinfo));\n\n  if (dnsinfo == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  dnsinfo->handle = dlopen(\"/usr/lib/libSystem.dylib\", RTLD_LAZY | RTLD_NOLOAD);\n  if (dnsinfo->handle == NULL) {\n    status = ARES_ESERVFAIL;\n    goto done;\n  }\n\n  dnsinfo->dns_configuration_notify_key =\n    dlsym(dnsinfo->handle, \"dns_configuration_notify_key\");\n  dnsinfo->dns_configuration_copy =\n    dlsym(dnsinfo->handle, \"dns_configuration_copy\");\n  dnsinfo->dns_configuration_free =\n    dlsym(dnsinfo->handle, \"dns_configuration_free\");\n\n  if (dnsinfo->dns_configuration_notify_key == NULL ||\n      dnsinfo->dns_configuration_copy == NULL ||\n      dnsinfo->dns_configuration_free == NULL) {\n    status = ARES_ESERVFAIL;\n    goto done;\n  }\n\n\ndone:\n  if (status == ARES_SUCCESS) {\n    *dnsinfo_out = dnsinfo;\n  } else {\n    dnsinfo_destroy(dnsinfo);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              78,
              0
            ],
            [
              126,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dnsinfo_init",
            "parameters": {
              "dnsinfo_out": "dnsinfo_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_bool_t search_is_duplicate(const ares_sysconfig_t *sysconfig,\n                                       const char             *name)\n{\n  size_t i;\n  for (i = 0; i < sysconfig->ndomains; i++) {\n    if (strcasecmp(sysconfig->domains[i], name) == 0) {\n      return ARES_TRUE;\n    }\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              128,
              0
            ],
            [
              138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "search_is_duplicate",
            "parameters": {
              "sysconfig": "ares_sysconfig_t",
              "name": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t read_resolver(const dns_resolver_t *resolver,\n                                   ares_sysconfig_t     *sysconfig)\n{\n  int            i;\n  unsigned short port   = 0;\n  ares_status_t  status = ARES_SUCCESS;\n\n  /* XXX: resolver->domain is for domain-specific servers.  When we implement\n   *      this support, we'll want to use this.  But for now, we're going to\n   *      skip any servers which set this since we can't properly route. */\n  if (resolver->domain != NULL) {\n    return ARES_SUCCESS;\n  }\n\n  /* Check to see if DNS server should be used, base this on if the server is\n   * reachable or can be reachable automatically if we send traffic that\n   * direction. */\n  if (!(resolver->reach_flags &\n        (kSCNetworkFlagsReachable |\n         kSCNetworkReachabilityFlagsConnectionOnTraffic))) {\n    return ARES_SUCCESS;\n  }\n\n  /* NOTE: it doesn't look like resolver->flags is relevant */\n\n  /* If there's no nameservers, nothing to do */\n  if (resolver->n_nameserver <= 0) {\n    return ARES_SUCCESS;\n  }\n\n  /* Default port */\n  port = resolver->port;\n\n  /* Append search list */\n  if (resolver->n_search > 0) {\n    char **new_domains =\n      ares_realloc_zero(sysconfig->domains,\n                        sizeof(*sysconfig->domains) * sysconfig->ndomains,\n                        sizeof(*sysconfig->domains) *\n                          (sysconfig->ndomains + (size_t)resolver->n_search));\n    if (new_domains == NULL) {\n      return ARES_ENOMEM;\n    }\n    sysconfig->domains = new_domains;\n\n    for (i = 0; i < resolver->n_search; i++) {\n      /* Skip duplicates */\n      if (search_is_duplicate(sysconfig, resolver->search[i])) {\n        continue;\n      }\n      sysconfig->domains[sysconfig->ndomains] =\n        ares_strdup(resolver->search[i]);\n      if (sysconfig->domains[sysconfig->ndomains] == NULL) {\n        return ARES_ENOMEM;\n      }\n      sysconfig->ndomains++;\n    }\n  }\n\n  /* NOTE: we're going to skip importing the sort addresses for now.  Its\n   *       likely not used, its not obvious how to even configure such a thing.\n   */\n#  if 0\n  for (i=0; i<resolver->n_sortaddr; i++) {\n    char val[256];\n    inet_ntop(AF_INET, &resolver->sortaddr[i]->address, val, sizeof(val));\n    printf(\"\\t\\t%s/\", val);\n    inet_ntop(AF_INET, &resolver->sortaddr[i]->mask, val, sizeof(val));\n    printf(\"%s\\n\", val);\n  }\n#  endif\n\n  if (resolver->options != NULL) {\n    status = ares__sysconfig_set_options(sysconfig, resolver->options);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  /* NOTE:\n   *   - resolver->timeout appears unused, always 0, so we ignore this\n   *   - resolver->service_identifier doesn't appear relevant to us\n   *   - resolver->cid also isn't relevant\n   *   - resolver->if_index we don't need, if_name is used instead.\n   */\n\n  /* XXX: resolver->search_order appears like it might be relevant, we might\n   * need to sort the resulting list by this metric if we find in the future we\n   * need to.  That said, due to the automatic re-sorting we do, I'm not sure it\n   * matters.  Here's an article on this search order stuff:\n   *      https://www.cnet.com/tech/computing/os-x-10-6-3-and-dns-server-priority-changes/\n   */\n\n  for (i = 0; i < resolver->n_nameserver; i++) {\n    struct ares_addr addr;\n    unsigned short   addrport;\n\n    if (resolver->nameserver[i]->sa_family == AF_INET) {\n      struct sockaddr_in *addr_in =\n        (struct sockaddr_in *)(void *)resolver->nameserver[i];\n      addr.family = AF_INET;\n      memcpy(&addr.addr.addr4, &(addr_in->sin_addr), sizeof(addr.addr.addr4));\n      addrport = ntohs(addr_in->sin_port);\n    } else if (resolver->nameserver[i]->sa_family == AF_INET6) {\n      struct sockaddr_in6 *addr_in6 =\n        (struct sockaddr_in6 *)(void *)resolver->nameserver[i];\n      addr.family = AF_INET6;\n      memcpy(&addr.addr.addr6, &(addr_in6->sin6_addr), sizeof(addr.addr.addr6));\n      addrport = ntohs(addr_in6->sin6_port);\n    } else {\n      continue;\n    }\n\n    if (addrport == 0) {\n      addrport = port;\n    }\n    status = ares__sconfig_append(&sysconfig->sconfig, &addr, addrport,\n                                  addrport, resolver->if_name);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              140,
              0
            ],
            [
              264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_resolver",
            "parameters": {
              "resolver": "dns_resolver_t",
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t read_resolvers(dns_resolver_t **resolvers, int nresolvers,\n                                    ares_sysconfig_t *sysconfig)\n{\n  ares_status_t status = ARES_SUCCESS;\n  int           i;\n\n  for (i = 0; status == ARES_SUCCESS && i < nresolvers; i++) {\n    status = read_resolver(resolvers[i], sysconfig);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              266,
              0
            ],
            [
              277,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_resolvers",
            "parameters": {
              "resolvers": "dns_resolver_t",
              "nresolvers": "int",
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__init_sysconfig_macos(ares_sysconfig_t *sysconfig)\n{\n  dnsinfo_t    *dnsinfo = NULL;\n  dns_config_t *sc_dns  = NULL;\n  ares_status_t status  = ARES_SUCCESS;\n\n  status = dnsinfo_init(&dnsinfo);\n\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  sc_dns = dnsinfo->dns_configuration_copy();\n  if (sc_dns == NULL) {\n    status = ARES_ESERVFAIL;\n    goto done;\n  }\n\n  /* There are `resolver`, `scoped_resolver`, and `service_specific_resolver`\n   * settings. The `scoped_resolver` settings appear to be already available via\n   * the `resolver` settings and likely are only relevant to link-local dns\n   * servers which we can already detect via the address itself, so we'll ignore\n   * the `scoped_resolver` section.  It isn't clear what the\n   * `service_specific_resolver` is used for, I haven't personally seen it\n   * in use so we'll ignore this until at some point where we find we need it.\n   * Likely this wasn't available via `/etc/resolv.conf` nor `libresolv` anyhow\n   * so its not worse to prior configuration methods, worst case. */\n\n  status = read_resolvers(sc_dns->resolver, sc_dns->n_resolver, sysconfig);\n\ndone:\n  if (dnsinfo) {\n    dnsinfo->dns_configuration_free(sc_dns);\n    dnsinfo_destroy(dnsinfo);\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              279,
              0
            ],
            [
              315,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_sysconfig_macos",
            "parameters": {
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*dns_configuration_notify_key)(void)",
          "fn_dec_pos": [
            [
              60,
              14
            ],
            [
              60,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "(*dns_configuration_copy)(void)",
          "fn_dec_pos": [
            [
              61,
              16
            ],
            [
              61,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "(*dns_configuration_free)(dns_config_t *config)",
          "fn_dec_pos": [
            [
              62,
              7
            ],
            [
              62,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "config": "dns_config_t"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  void *handle;\n  const char *(*dns_configuration_notify_key)(void);\n  dns_config_t *(*dns_configuration_copy)(void);\n  void (*dns_configuration_free)(dns_config_t *config);\n} dnsinfo_t;",
          {
            "*handle": "void",
            "char": "const",
            "*(*dns_configuration_copy)(void)": "dns_config_t",
            "(*dns_configuration_free)(dns_config_t *config)": "void"
          },
          "dnsinfo_t",
          [
            58,
            0
          ],
          [
            63,
            12
          ]
        ],
        [
          "typedef struct {\n  void *handle;\n  const char *(*dns_configuration_notify_key)(void);\n  dns_config_t *(*dns_configuration_copy)(void);\n  void (*dns_configuration_free)(dns_config_t *config);\n} dnsinfo_t;",
          {
            "*handle": "void",
            "char": "const",
            "*(*dns_configuration_copy)(void)": "dns_config_t",
            "(*dns_configuration_free)(dns_config_t *config)": "void"
          },
          "dnsinfo_t",
          [
            58,
            0
          ],
          [
            63,
            12
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            234,
            4
          ],
          [
            234,
            20
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            238,
            6
          ],
          [
            238,
            24
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            239,
            9
          ],
          [
            239,
            27
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            244,
            6
          ],
          [
            244,
            25
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            245,
            9
          ],
          [
            245,
            28
          ]
        ]
      ],
      "include_list": [
        [
          "#  include \"ares_setup.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#  include <stdio.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#  include <stdlib.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#  include <string.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#  include <dlfcn.h>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#  include \"thirdparty/apple/dnsinfo.h\"\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#  include <SystemConfiguration/SCNetworkConfiguration.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#  include \"ares.h\"\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#  include \"ares_private.h\"\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_rand.c": {
      "fn_def_list": [
        {
          "fn_code": "static unsigned int ares_u32_from_ptr(void *addr)\n{\n  if (sizeof(void *) == 8) {\n    return (unsigned int)((((ares_uint64_t)addr >> 32) & 0xFFFFFFFF) |\n                          ((ares_uint64_t)addr & 0xFFFFFFFF));\n  }\n  return (unsigned int)((size_t)addr & 0xFFFFFFFF);\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_u32_from_ptr",
            "parameters": {
              "addr": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void ares_rc4_generate_key(ares_rand_rc4 *rc4_state, unsigned char *key,\n                                  size_t key_len)\n{\n  size_t         i;\n  size_t         len = 0;\n  unsigned int   data;\n  struct timeval tv;\n\n  if (key_len != ARES_RC4_KEY_LEN) {\n    return;\n  }\n\n  /* Randomness is hard to come by.  Maybe the system randomizes heap and stack\n   * addresses. Maybe the current timestamp give us some randomness. Use\n   * rc4_state (heap), &i (stack), and ares__tvnow()\n   */\n  data = ares_u32_from_ptr(rc4_state);\n  memcpy(key + len, &data, sizeof(data));\n  len += sizeof(data);\n\n  data = ares_u32_from_ptr(&i);\n  memcpy(key + len, &data, sizeof(data));\n  len += sizeof(data);\n\n  tv   = ares__tvnow();\n  data = (unsigned int)((tv.tv_sec | tv.tv_usec) & 0xFFFFFFFF);\n  memcpy(key + len, &data, sizeof(data));\n  len += sizeof(data);\n\n  srand(ares_u32_from_ptr(rc4_state) | ares_u32_from_ptr(&i) |\n        (unsigned int)((tv.tv_sec | tv.tv_usec) & 0xFFFFFFFF));\n\n  for (i = len; i < key_len; i++) {\n    key[i] = (unsigned char)(rand() % 256); /* LCOV_EXCL_LINE */\n  }\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              101,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_rc4_generate_key",
            "parameters": {
              "rc4_state": "ares_rand_rc4",
              "key": "unsigned char",
              "key_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_rc4_init(ares_rand_rc4 *rc4_state)\n{\n  unsigned char key[ARES_RC4_KEY_LEN];\n  size_t        i;\n  size_t        j;\n\n  ares_rc4_generate_key(rc4_state, key, sizeof(key));\n\n  for (i = 0; i < sizeof(rc4_state->S); i++) {\n    rc4_state->S[i] = i & 0xFF;\n  }\n\n  for (i = 0, j = 0; i < 256; i++) {\n    j = (j + rc4_state->S[i] + key[i % sizeof(key)]) % 256;\n    ARES_SWAP_BYTE(&rc4_state->S[i], &rc4_state->S[j]);\n  }\n\n  rc4_state->i = 0;\n  rc4_state->j = 0;\n}",
          "fn_code_pos": [
            [
              103,
              0
            ],
            [
              122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_rc4_init",
            "parameters": {
              "rc4_state": "ares_rand_rc4"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_rc4_prng(ares_rand_rc4 *rc4_state, unsigned char *buf,\n                          size_t len)\n{\n  unsigned char *S = rc4_state->S;\n  size_t         i = rc4_state->i;\n  size_t         j = rc4_state->j;\n  size_t         cnt;\n\n  for (cnt = 0; cnt < len; cnt++) {\n    i = (i + 1) % 256;\n    j = (j + S[i]) % 256;\n\n    ARES_SWAP_BYTE(&S[i], &S[j]);\n    buf[cnt] = S[(S[i] + S[j]) % 256];\n  }\n\n  rc4_state->i = i;\n  rc4_state->j = j;\n}",
          "fn_code_pos": [
            [
              126,
              0
            ],
            [
              144,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_rc4_prng",
            "parameters": {
              "rc4_state": "ares_rand_rc4",
              "buf": "unsigned char",
              "len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares__init_rand_engine(ares_rand_state *state)\n{\n  state->cache_remaining = 0;\n\n#if defined(HAVE_ARC4RANDOM_BUF) || defined(HAVE_GETRANDOM) || defined(_WIN32)\n  if (!(state->bad_backends & ARES_RAND_OS)) {\n    state->type = ARES_RAND_OS;\n    return ARES_TRUE;\n  }\n#endif\n\n#if defined(CARES_RANDOM_FILE)\n  if (!(state->bad_backends & ARES_RAND_FILE)) {\n    state->type            = ARES_RAND_FILE;\n    state->state.rand_file = fopen(CARES_RANDOM_FILE, \"rb\");\n    if (state->state.rand_file) {\n      setvbuf(state->state.rand_file, NULL, _IONBF, 0);\n      return ARES_TRUE;\n    }\n  }\n  /* Fall-Thru on failure to RC4 */\n#endif\n\n  state->type = ARES_RAND_RC4;\n  ares_rc4_init(&state->state.rc4);\n\n  /* Currently cannot fail */\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              177,
              0
            ],
            [
              205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_rand_engine",
            "parameters": {
              "state": "ares_rand_state"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_rand_state *ares__init_rand_state(void)\n{\n  ares_rand_state *state = NULL;\n\n  state = ares_malloc_zero(sizeof(*state));\n  if (!state) {\n    return NULL;\n  }\n\n  if (!ares__init_rand_engine(state)) {\n    ares_free(state);\n    return NULL;\n  }\n\n  return state;\n}",
          "fn_code_pos": [
            [
              207,
              0
            ],
            [
              222,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_rand_state",
            "parameters": {},
            "return_type": "ares_rand_state"
          }
        },
        {
          "fn_code": "static void ares__clear_rand_state(ares_rand_state *state)\n{\n  if (!state) {\n    return;\n  }\n\n  switch (state->type) {\n    case ARES_RAND_OS:\n      break;\n    case ARES_RAND_FILE:\n      fclose(state->state.rand_file);\n      break;\n    case ARES_RAND_RC4:\n      break;\n  }\n}",
          "fn_code_pos": [
            [
              224,
              0
            ],
            [
              239,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__clear_rand_state",
            "parameters": {
              "state": "ares_rand_state"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares__reinit_rand(ares_rand_state *state)\n{\n  ares__clear_rand_state(state);\n  ares__init_rand_engine(state);\n}",
          "fn_code_pos": [
            [
              241,
              0
            ],
            [
              245,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__reinit_rand",
            "parameters": {
              "state": "ares_rand_state"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__destroy_rand_state(ares_rand_state *state)\n{\n  if (!state) {\n    return;\n  }\n\n  ares__clear_rand_state(state);\n  ares_free(state);\n}",
          "fn_code_pos": [
            [
              247,
              0
            ],
            [
              255,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__destroy_rand_state",
            "parameters": {
              "state": "ares_rand_state"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares__rand_bytes_fetch(ares_rand_state *state, unsigned char *buf,\n                                   size_t len)\n{\n  while (1) {\n    size_t bytes_read = 0;\n\n    switch (state->type) {\n      case ARES_RAND_OS:\n#ifdef _WIN32\n        RtlGenRandom(buf, (ULONG)len);\n        return;\n#elif defined(HAVE_ARC4RANDOM_BUF)\n        arc4random_buf(buf, len);\n        return;\n#elif defined(HAVE_GETRANDOM)\n        while (1) {\n          size_t  n = len - bytes_read;\n          /* getrandom() on Linux always succeeds and is never\n           * interrupted by a signal when requesting <= 256 bytes.\n           */\n          ssize_t rv = getrandom(buf + bytes_read, n > 256 ? 256 : n, 0);\n          if (rv <= 0) {\n            /* We need to fall back to another backend */\n            if (errno == ENOSYS) {\n              state->bad_backends |= ARES_RAND_OS;\n              break;\n            }\n            continue; /* Just retry. */\n          }\n\n          bytes_read += (size_t)rv;\n          if (bytes_read == len) {\n            return;\n          }\n        }\n        break;\n#else\n        /* Shouldn't be possible to be here */\n        break;\n#endif\n\n      case ARES_RAND_FILE:\n        while (1) {\n          size_t rv = fread(buf + bytes_read, 1, len - bytes_read,\n                            state->state.rand_file);\n          if (rv == 0) {\n            break; /* critical error, will reinit rand state */\n          }\n\n          bytes_read += rv;\n          if (bytes_read == len) {\n            return;\n          }\n        }\n        break;\n\n      case ARES_RAND_RC4:\n        ares_rc4_prng(&state->state.rc4, buf, len);\n        return;\n    }\n\n    /* If we didn't return before we got here, that means we had a critical rand\n     * failure and need to reinitialized */\n    ares__reinit_rand(state);\n  }\n}",
          "fn_code_pos": [
            [
              257,
              0
            ],
            [
              322,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__rand_bytes_fetch",
            "parameters": {
              "state": "ares_rand_state",
              "buf": "unsigned char",
              "len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__rand_bytes(ares_rand_state *state, unsigned char *buf, size_t len)\n{\n  /* See if we need to refill the cache to serve the request, but if len is\n   * excessive, we're not going to update our cache or serve from cache */\n  if (len > state->cache_remaining && len < sizeof(state->cache)) {\n    size_t fetch_size = sizeof(state->cache) - state->cache_remaining;\n    ares__rand_bytes_fetch(state, state->cache, fetch_size);\n    state->cache_remaining = sizeof(state->cache);\n  }\n\n  /* Serve from cache */\n  if (len <= state->cache_remaining) {\n    size_t offset = sizeof(state->cache) - state->cache_remaining;\n    memcpy(buf, state->cache + offset, len);\n    state->cache_remaining -= len;\n    return;\n  }\n\n  /* Serve direct due to excess size of request */\n  ares__rand_bytes_fetch(state, buf, len);\n}",
          "fn_code_pos": [
            [
              324,
              0
            ],
            [
              344,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__rand_bytes",
            "parameters": {
              "state": "ares_rand_state",
              "buf": "unsigned char",
              "len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "unsigned short ares__generate_new_id(ares_rand_state *state)\n{\n  unsigned short r = 0;\n\n  ares__rand_bytes(state, (unsigned char *)&r, sizeof(r));\n  return r;\n}",
          "fn_code_pos": [
            [
              346,
              0
            ],
            [
              352,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__generate_new_id",
            "parameters": {
              "state": "ares_rand_state"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "SystemFunction036(PVOID RandomBuffer, ULONG RandomBufferLength)",
          "fn_dec_pos": [
            [
              170,
              15
            ],
            [
              170,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SystemFunction036",
            "parameters": {
              "RandomBuffer": "PVOID",
              "RandomBufferLength": "ULONG"
            },
            "return_type": "BOOLEAN"
          }
        },
        {
          "fn_code": "ares__init_rand_state(void)",
          "fn_dec_pos": [
            [
              207,
              17
            ],
            [
              207,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_rand_state",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct ares_rand_rc4 {\n  unsigned char S[256];\n  size_t        i;\n  size_t        j;\n} ares_rand_rc4;",
          {
            "S[256]": "unsigned char",
            "i": "size_t",
            "j": "size_t"
          },
          "ares_rand_rc4",
          [
            50,
            0
          ],
          [
            54,
            16
          ]
        ],
        [
          "struct ares_rand_state {\n  ares_rand_backend type;\n  ares_rand_backend bad_backends;\n\n  union {\n    FILE         *rand_file;\n    ares_rand_rc4 rc4;\n  } state;\n\n  /* Since except for RC4, random data will likely result in a syscall, lets\n   * pre-pull 256 bytes at a time.  Every query will pull 2 bytes off this so\n   * that means we should only need a syscall every 128 queries. 256bytes\n   * appears to be a sweet spot that may be able to be served without\n   * interruption */\n  unsigned char cache[256];\n  size_t        cache_remaining;\n}",
          {
            "type": "ares_rand_backend",
            "bad_backends": "ares_rand_backend",
            "state": "union {\n    FILE         *rand_file;\n    ares_rand_rc4 rc4;\n  }",
            "*rand_file": "FILE",
            "rc4": "ares_rand_rc4",
            "cache[256]": "unsigned char",
            "cache_remaining": "size_t"
          },
          "ares_rand_state",
          [
            146,
            0
          ],
          [
            162,
            1
          ]
        ],
        [
          "typedef struct ares_rand_rc4 {\n  unsigned char S[256];\n  size_t        i;\n  size_t        j;\n} ares_rand_rc4;",
          {
            "S[256]": "unsigned char",
            "i": "size_t",
            "j": "size_t"
          },
          "ares_rand_rc4",
          [
            50,
            0
          ],
          [
            54,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            72,
            2
          ],
          [
            72,
            16
          ]
        ],
        [
          "struct ares_rand_state {\n  ares_rand_backend type;\n  ares_rand_backend bad_backends;\n\n  union {\n    FILE         *rand_file;\n    ares_rand_rc4 rc4;\n  } state;\n\n  /* Since except for RC4, random data will likely result in a syscall, lets\n   * pre-pull 256 bytes at a time.  Every query will pull 2 bytes off this so\n   * that means we should only need a syscall every 128 queries. 256bytes\n   * appears to be a sweet spot that may be able to be served without\n   * interruption */\n  unsigned char cache[256];\n  size_t        cache_remaining;\n}",
          {
            "type": "ares_rand_backend",
            "bad_backends": "ares_rand_backend",
            "state": "union {\n    FILE         *rand_file;\n    ares_rand_rc4 rc4;\n  }",
            "*rand_file": "FILE",
            "rc4": "ares_rand_rc4",
            "cache[256]": "unsigned char",
            "cache_remaining": "size_t"
          },
          "ares_rand_state",
          [
            146,
            0
          ],
          [
            162,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#  include <AvailabilityMacros.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <sys/random.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  ARES_RAND_OS   = 1 << 0, /* OS-provided such as RtlGenRandom or arc4random */\n  ARES_RAND_FILE = 1 << 1, /* OS file-backed random number generator */\n  ARES_RAND_RC4  = 1 << 2, /* Internal RC4 based PRNG */\n} ares_rand_backend;",
          {
            "ARES_RAND_OS": "",
            "ARES_RAND_FILE": "",
            "ARES_RAND_RC4": ""
          },
          "ares_rand_backend",
          [
            42,
            0
          ],
          [
            46,
            20
          ]
        ]
      ]
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_sysconfig.c": {
      "fn_def_list": [
        {
          "fn_code": "static ares_bool_t get_REG_SZ(HKEY hKey, const char *leafKeyName, char **outptr)\n{\n  DWORD size = 0;\n  int   res;\n\n  *outptr = NULL;\n\n  /* Find out size of string stored in registry */\n  res = RegQueryValueExA(hKey, leafKeyName, 0, NULL, NULL, &size);\n  if ((res != ERROR_SUCCESS && res != ERROR_MORE_DATA) || !size) {\n    return ARES_FALSE;\n  }\n\n  /* Allocate buffer of indicated size plus one given that string\n     might have been stored without null termination */\n  *outptr = ares_malloc(size + 1);\n  if (!*outptr) {\n    return ARES_FALSE;\n  }\n\n  /* Get the value for real */\n  res = RegQueryValueExA(hKey, leafKeyName, 0, NULL, (unsigned char *)*outptr,\n                         &size);\n  if ((res != ERROR_SUCCESS) || (size == 1)) {\n    ares_free(*outptr);\n    *outptr = NULL;\n    return ARES_FALSE;\n  }\n\n  /* Null terminate buffer always */\n  *(*outptr + size) = '\\0';\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              93,
              0
            ],
            [
              126,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_REG_SZ",
            "parameters": {
              "hKey": "HKEY",
              "leafKeyName": "char",
              "outptr": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void commanjoin(char **dst, const char * const src, const size_t len)\n{\n  char  *newbuf;\n  size_t newsize;\n\n  /* 1 for terminating 0 and 2 for , and terminating 0 */\n  newsize = len + (*dst ? (ares_strlen(*dst) + 2) : 1);\n  newbuf  = ares_realloc(*dst, newsize);\n  if (!newbuf) {\n    return;\n  }\n  if (*dst == NULL) {\n    *newbuf = '\\0';\n  }\n  *dst = newbuf;\n  if (ares_strlen(*dst) != 0) {\n    strcat(*dst, \",\");\n  }\n  strncat(*dst, src, len);\n}",
          "fn_code_pos": [
            [
              128,
              0
            ],
            [
              147,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "commanjoin",
            "parameters": {
              "dst": "char",
              "src": "char",
              "len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void commajoin(char **dst, const char *src)\n{\n  commanjoin(dst, src, ares_strlen(src));\n}",
          "fn_code_pos": [
            [
              154,
              0
            ],
            [
              157,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "commajoin",
            "parameters": {
              "dst": "char",
              "src": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int compareAddresses(const void *arg1, const void *arg2)\n{\n  const Address * const left  = arg1;\n  const Address * const right = arg2;\n  /* Lower metric the more preferred */\n  if (left->metric < right->metric) {\n    return -1;\n  }\n  if (left->metric > right->metric) {\n    return 1;\n  }\n  /* If metrics are equal, lower original index more preferred */\n  if (left->orig_idx < right->orig_idx) {\n    return -1;\n  }\n  if (left->orig_idx > right->orig_idx) {\n    return 1;\n  }\n  return 0;\n}",
          "fn_code_pos": [
            [
              179,
              0
            ],
            [
              198,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compareAddresses",
            "parameters": {
              "arg1": "void",
              "arg2": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static ULONG getBestRouteMetric(IF_LUID * const luid, /* Can't be const :( */\n                                const SOCKADDR_INET * const dest,\n                                const ULONG                 interfaceMetric)\n{\n  /* On this interface, get the best route to that destination. */\n#  if defined(__WATCOMC__)\n  /* OpenWatcom's builtin Windows SDK does not have a definition for\n   * MIB_IPFORWARD_ROW2, and also does not allow the usage of SOCKADDR_INET\n   * as a variable. Let's work around this by returning the worst possible\n   * metric, but only when using the OpenWatcom compiler.\n   * It may be worth investigating using a different version of the Windows\n   * SDK with OpenWatcom in the future, though this may be fixed in OpenWatcom\n   * 2.0.\n   */\n  return (ULONG)-1;\n#  else\n  MIB_IPFORWARD_ROW2 row;\n  SOCKADDR_INET      ignored;\n  if (GetBestRoute2(/* The interface to use.  The index is ignored since we are\n                     * passing a LUID.\n                     */\n                    luid, 0,\n                    /* No specific source address. */\n                    NULL,\n                    /* Our destination address. */\n                    dest,\n                    /* No options. */\n                    0,\n                    /* The route row. */\n                    &row,\n                    /* The best source address, which we don't need. */\n                    &ignored) != NO_ERROR\n      /* If the metric is \"unused\" (-1) or too large for us to add the two\n       * metrics, use the worst possible, thus sorting this last.\n       */\n      || row.Metric == (ULONG)-1 ||\n      row.Metric > ((ULONG)-1) - interfaceMetric) {\n    /* Return the worst possible metric. */\n    return (ULONG)-1;\n  }\n\n  /* Return the metric value from that row, plus the interface metric.\n   *\n   * See\n   * http://msdn.microsoft.com/en-us/library/windows/desktop/aa814494(v=vs.85).aspx\n   * which describes the combination as a \"sum\".\n   */\n  return row.Metric + interfaceMetric;\n#  endif /* __WATCOMC__ */\n}",
          "fn_code_pos": [
            [
              233,
              0
            ],
            [
              282,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getBestRouteMetric",
            "parameters": {
              "luid": "IF_LUID",
              "dest": "SOCKADDR_INET",
              "interfaceMetric": "ULONG"
            },
            "return_type": "ULONG"
          }
        },
        {
          "fn_code": "static ares_bool_t get_DNS_Windows(char **outptr)\n{\n  IP_ADAPTER_DNS_SERVER_ADDRESS *ipaDNSAddr;\n  IP_ADAPTER_ADDRESSES          *ipaa;\n  IP_ADAPTER_ADDRESSES          *newipaa;\n  IP_ADAPTER_ADDRESSES          *ipaaEntry;\n  ULONG                          ReqBufsz  = IPAA_INITIAL_BUF_SZ;\n  ULONG                          Bufsz     = IPAA_INITIAL_BUF_SZ;\n  ULONG                          AddrFlags = 0;\n  int                            trying    = IPAA_MAX_TRIES;\n  ULONG                          res;\n\n  /* The capacity of addresses, in elements. */\n  size_t                         addressesSize;\n  /* The number of elements in addresses. */\n  size_t                         addressesIndex = 0;\n  /* The addresses we will sort. */\n  Address                       *addresses;\n\n  union {\n    struct sockaddr     *sa;\n    struct sockaddr_in  *sa4;\n    struct sockaddr_in6 *sa6;\n  } namesrvr;\n\n  *outptr = NULL;\n\n  ipaa = ares_malloc(Bufsz);\n  if (!ipaa) {\n    return ARES_FALSE;\n  }\n\n  /* Start with enough room for a few DNS server addresses and we'll grow it\n   * as we encounter more.\n   */\n  addressesSize = 4;\n  addresses     = (Address *)ares_malloc(sizeof(Address) * addressesSize);\n  if (addresses == NULL) {\n    /* We need room for at least some addresses to function. */\n    ares_free(ipaa);\n    return ARES_FALSE;\n  }\n\n  /* Usually this call succeeds with initial buffer size */\n  res = GetAdaptersAddresses(AF_UNSPEC, AddrFlags, NULL, ipaa, &ReqBufsz);\n  if ((res != ERROR_BUFFER_OVERFLOW) && (res != ERROR_SUCCESS)) {\n    goto done;\n  }\n\n  while ((res == ERROR_BUFFER_OVERFLOW) && (--trying)) {\n    if (Bufsz < ReqBufsz) {\n      newipaa = ares_realloc(ipaa, ReqBufsz);\n      if (!newipaa) {\n        goto done;\n      }\n      Bufsz = ReqBufsz;\n      ipaa  = newipaa;\n    }\n    res = GetAdaptersAddresses(AF_UNSPEC, AddrFlags, NULL, ipaa, &ReqBufsz);\n    if (res == ERROR_SUCCESS) {\n      break;\n    }\n  }\n  if (res != ERROR_SUCCESS) {\n    goto done;\n  }\n\n  for (ipaaEntry = ipaa; ipaaEntry; ipaaEntry = ipaaEntry->Next) {\n    if (ipaaEntry->OperStatus != IfOperStatusUp) {\n      continue;\n    }\n\n    /* For each interface, find any associated DNS servers as IPv4 or IPv6\n     * addresses.  For each found address, find the best route to that DNS\n     * server address _on_ _that_ _interface_ (at this moment in time) and\n     * compute the resulting total metric, just as Windows routing will do.\n     * Then, sort all the addresses found by the metric.\n     */\n    for (ipaDNSAddr = ipaaEntry->FirstDnsServerAddress; ipaDNSAddr;\n         ipaDNSAddr = ipaDNSAddr->Next) {\n      char ipaddr[INET6_ADDRSTRLEN] = \"\";\n      namesrvr.sa                   = ipaDNSAddr->Address.lpSockaddr;\n\n      if (namesrvr.sa->sa_family == AF_INET) {\n        if ((namesrvr.sa4->sin_addr.S_un.S_addr == INADDR_ANY) ||\n            (namesrvr.sa4->sin_addr.S_un.S_addr == INADDR_NONE)) {\n          continue;\n        }\n\n        /* Allocate room for another address, if necessary, else skip. */\n        if (addressesIndex == addressesSize) {\n          const size_t    newSize = addressesSize + 4;\n          Address * const newMem =\n            (Address *)ares_realloc(addresses, sizeof(Address) * newSize);\n          if (newMem == NULL) {\n            continue;\n          }\n          addresses     = newMem;\n          addressesSize = newSize;\n        }\n\n        addresses[addressesIndex].metric = getBestRouteMetric(\n          &ipaaEntry->Luid, (SOCKADDR_INET *)((void *)(namesrvr.sa)),\n          ipaaEntry->Ipv4Metric);\n\n        /* Record insertion index to make qsort stable */\n        addresses[addressesIndex].orig_idx = addressesIndex;\n\n        if (!ares_inet_ntop(AF_INET, &namesrvr.sa4->sin_addr, ipaddr,\n                            sizeof(ipaddr))) {\n          continue;\n        }\n        snprintf(addresses[addressesIndex].text,\n                 sizeof(addresses[addressesIndex].text), \"[%s]:%u\", ipaddr,\n                 ntohs(namesrvr.sa4->sin_port));\n        ++addressesIndex;\n      } else if (namesrvr.sa->sa_family == AF_INET6) {\n        unsigned int     ll_scope = 0;\n        struct ares_addr addr;\n\n        if (memcmp(&namesrvr.sa6->sin6_addr, &ares_in6addr_any,\n                   sizeof(namesrvr.sa6->sin6_addr)) == 0) {\n          continue;\n        }\n\n        /* Allocate room for another address, if necessary, else skip. */\n        if (addressesIndex == addressesSize) {\n          const size_t    newSize = addressesSize + 4;\n          Address * const newMem =\n            (Address *)ares_realloc(addresses, sizeof(Address) * newSize);\n          if (newMem == NULL) {\n            continue;\n          }\n          addresses     = newMem;\n          addressesSize = newSize;\n        }\n\n        /* See if its link-local */\n        memset(&addr, 0, sizeof(addr));\n        addr.family = AF_INET6;\n        memcpy(&addr.addr.addr6, &namesrvr.sa6->sin6_addr, 16);\n        if (ares__addr_is_linklocal(&addr)) {\n          ll_scope = ipaaEntry->Ipv6IfIndex;\n        }\n\n        addresses[addressesIndex].metric = getBestRouteMetric(\n          &ipaaEntry->Luid, (SOCKADDR_INET *)((void *)(namesrvr.sa)),\n          ipaaEntry->Ipv6Metric);\n\n        /* Record insertion index to make qsort stable */\n        addresses[addressesIndex].orig_idx = addressesIndex;\n\n        if (!ares_inet_ntop(AF_INET6, &namesrvr.sa6->sin6_addr, ipaddr,\n                            sizeof(ipaddr))) {\n          continue;\n        }\n\n        if (ll_scope) {\n          snprintf(addresses[addressesIndex].text,\n                   sizeof(addresses[addressesIndex].text), \"[%s]:%u%%%u\",\n                   ipaddr, ntohs(namesrvr.sa6->sin6_port), ll_scope);\n        } else {\n          snprintf(addresses[addressesIndex].text,\n                   sizeof(addresses[addressesIndex].text), \"[%s]:%u\", ipaddr,\n                   ntohs(namesrvr.sa6->sin6_port));\n        }\n        ++addressesIndex;\n      } else {\n        /* Skip non-IPv4/IPv6 addresses completely. */\n        continue;\n      }\n    }\n  }\n\n  /* Sort all of the textual addresses by their metric (and original index if\n   * metrics are equal). */\n  qsort(addresses, addressesIndex, sizeof(*addresses), compareAddresses);\n\n  /* Join them all into a single string, removing duplicates. */\n  {\n    size_t i;\n    for (i = 0; i < addressesIndex; ++i) {\n      size_t j;\n      /* Look for this address text appearing previously in the results. */\n      for (j = 0; j < i; ++j) {\n        if (strcmp(addresses[j].text, addresses[i].text) == 0) {\n          break;\n        }\n      }\n      /* Iff we didn't emit this address already, emit it now. */\n      if (j == i) {\n        /* Add that to outptr (if we can). */\n        commajoin(outptr, addresses[i].text);\n      }\n    }\n  }\n\ndone:\n  ares_free(addresses);\n\n  if (ipaa) {\n    ares_free(ipaa);\n  }\n\n  if (!*outptr) {\n    return ARES_FALSE;\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              301,
              0
            ],
            [
              510,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_DNS_Windows",
            "parameters": {
              "outptr": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t get_SuffixList_Windows(char **outptr)\n{\n  HKEY  hKey;\n  HKEY  hKeyEnum;\n  char  keyName[256];\n  DWORD keyNameBuffSize;\n  DWORD keyIdx = 0;\n  char *p      = NULL;\n\n  *outptr = NULL;\n\n  if (ares__getplatform() != WIN_NT) {\n    return ARES_FALSE;\n  }\n\n  /* 1. Global DNS Suffix Search List */\n  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY, 0, KEY_READ, &hKey) ==\n      ERROR_SUCCESS) {\n    get_REG_SZ(hKey, SEARCHLIST_KEY, outptr);\n    if (get_REG_SZ(hKey, DOMAIN_KEY, &p)) {\n      commajoin(outptr, p);\n      ares_free(p);\n      p = NULL;\n    }\n    RegCloseKey(hKey);\n  }\n\n  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_NT_DNSCLIENT, 0, KEY_READ, &hKey) ==\n      ERROR_SUCCESS) {\n    if (get_REG_SZ(hKey, SEARCHLIST_KEY, &p)) {\n      commajoin(outptr, p);\n      ares_free(p);\n      p = NULL;\n    }\n    RegCloseKey(hKey);\n  }\n\n  /* 2. Connection Specific Search List composed of:\n   *  a. Primary DNS Suffix */\n  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_DNSCLIENT, 0, KEY_READ, &hKey) ==\n      ERROR_SUCCESS) {\n    if (get_REG_SZ(hKey, PRIMARYDNSSUFFIX_KEY, &p)) {\n      commajoin(outptr, p);\n      ares_free(p);\n      p = NULL;\n    }\n    RegCloseKey(hKey);\n  }\n\n  /*  b. Interface SearchList, Domain, DhcpDomain */\n  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY \"\\\\\" INTERFACES_KEY, 0,\n                    KEY_READ, &hKey) == ERROR_SUCCESS) {\n    for (;;) {\n      keyNameBuffSize = sizeof(keyName);\n      if (RegEnumKeyExA(hKey, keyIdx++, keyName, &keyNameBuffSize, 0, NULL,\n                        NULL, NULL) != ERROR_SUCCESS) {\n        break;\n      }\n      if (RegOpenKeyExA(hKey, keyName, 0, KEY_QUERY_VALUE, &hKeyEnum) !=\n          ERROR_SUCCESS) {\n        continue;\n      }\n      /* p can be comma separated (SearchList) */\n      if (get_REG_SZ(hKeyEnum, SEARCHLIST_KEY, &p)) {\n        commajoin(outptr, p);\n        ares_free(p);\n        p = NULL;\n      }\n      if (get_REG_SZ(hKeyEnum, DOMAIN_KEY, &p)) {\n        commajoin(outptr, p);\n        ares_free(p);\n        p = NULL;\n      }\n      if (get_REG_SZ(hKeyEnum, DHCPDOMAIN_KEY, &p)) {\n        commajoin(outptr, p);\n        ares_free(p);\n        p = NULL;\n      }\n      RegCloseKey(hKeyEnum);\n    }\n    RegCloseKey(hKey);\n  }\n\n  return *outptr != NULL ? ARES_TRUE : ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              525,
              0
            ],
            [
              609,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_SuffixList_Windows",
            "parameters": {
              "outptr": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__init_sysconfig_windows(ares_sysconfig_t *sysconfig)\n{\n  char         *line   = NULL;\n  ares_status_t status = ARES_SUCCESS;\n\n  if (get_DNS_Windows(&line)) {\n    status = ares__sconfig_append_fromstr(&sysconfig->sconfig, line, ARES_TRUE);\n    ares_free(line);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\n  if (get_SuffixList_Windows(&line)) {\n    sysconfig->domains = ares__strsplit(line, \", \", &sysconfig->ndomains);\n    ares_free(line);\n    if (sysconfig->domains == NULL) {\n      status = ARES_EFILE;\n    }\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\ndone:\n  return status;\n}",
          "fn_code_pos": [
            [
              611,
              0
            ],
            [
              637,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_sysconfig_windows",
            "parameters": {
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__init_sysconfig_mvs(ares_sysconfig_t *sysconfig)\n{\n  struct __res_state *res = 0;\n  size_t              count4;\n  size_t              count6;\n  int                 i;\n  __STATEEXTIPV6     *v6;\n  arse__llist_t      *sconfig = NULL;\n  ares_status_t       status;\n\n  if (0 == res) {\n    int rc = res_init();\n    while (rc == -1 && h_errno == TRY_AGAIN) {\n      rc = res_init();\n    }\n    if (rc == -1) {\n      return ARES_ENOMEM;\n    }\n    res = __res();\n  }\n\n  v6 = res->__res_extIPv6;\n  if (res->nscount > 0) {\n    count4 = (size_t)res->nscount;\n  }\n\n  if (v6 && v6->__stat_nscount > 0) {\n    count6 = (size_t)v6->__stat_nscount;\n  } else {\n    count6 = 0;\n  }\n\n  for (i = 0; i < count4; i++) {\n    struct sockaddr_in *addr_in = &(res->nsaddr_list[i]);\n    struct ares_addr    addr;\n\n    addr.addr.addr4.s_addr = addr_in->sin_addr.s_addr;\n    addr.family            = AF_INET;\n\n    status =\n      ares__sconfig_append(&sysconfig->sconfig, &addr, htons(addr_in->sin_port),\n                           htons(addr_in->sin_port), NULL);\n\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  for (i = 0; i < count6; i++) {\n    struct sockaddr_in6 *addr_in = &(v6->__stat_nsaddr_list[i]);\n    struct ares_addr     addr;\n\n    addr.family = AF_INET6;\n    memcpy(&(addr.addr.addr6), &(addr_in->sin6_addr),\n           sizeof(addr_in->sin6_addr));\n\n    status =\n      ares__sconfig_append(&sysconfig->sconfig, &addr, htons(addr_in->sin_port),\n                           htons(addr_in->sin_port), NULL);\n\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              641,
              0
            ],
            [
              707,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_sysconfig_mvs",
            "parameters": {
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__init_sysconfig_riscos(ares_sysconfig_t *sysconfig)\n{\n  char         *line;\n  ares_status_t status = ARES_SUCCESS;\n\n  /* Under RISC OS, name servers are listed in the\n     system variable Inet$Resolvers, space separated. */\n  line = getenv(\"Inet$Resolvers\");\n  if (line) {\n    char *resolvers = ares_strdup(line);\n    char *pos;\n    char *space;\n\n    if (!resolvers) {\n      return ARES_ENOMEM;\n    }\n\n    pos = resolvers;\n    do {\n      space = strchr(pos, ' ');\n      if (space) {\n        *space = '\\0';\n      }\n      status =\n        ares__sconfig_append_fromstr(&sysconfig->sconfig, pos, ARES_TRUE);\n      if (status != ARES_SUCCESS) {\n        break;\n      }\n      pos = space + 1;\n    } while (space);\n\n    ares_free(resolvers);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              711,
              0
            ],
            [
              746,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_sysconfig_riscos",
            "parameters": {
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__init_sysconfig_watt32(ares_sysconfig_t *sysconfig)\n{\n  size_t        i;\n  ares_status_t status;\n\n  sock_init();\n\n  for (i = 0; def_nameservers[i]; i++) {\n    struct ares_addr addr;\n\n    addr.family            = AF_INET;\n    addr.addr.addr4.s_addr = htonl(def_nameservers[i]);\n\n    status = ares__sconfig_append(&sysconfig->sconfig, &addr, 0, 0, NULL);\n\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              750,
              0
            ],
            [
              771,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_sysconfig_watt32",
            "parameters": {
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__init_sysconfig_android(ares_sysconfig_t *sysconfig)\n{\n  size_t        i;\n  char        **dns_servers;\n  char         *domains;\n  size_t        num_servers;\n  ares_status_t status = ARES_EFILE;\n\n  /* Use the Android connectivity manager to get a list\n   * of DNS servers. As of Android 8 (Oreo) net.dns#\n   * system properties are no longer available. Google claims this\n   * improves privacy. Apps now need the ACCESS_NETWORK_STATE\n   * permission and must use the ConnectivityManager which\n   * is Java only. */\n  dns_servers = ares_get_android_server_list(MAX_DNS_PROPERTIES, &num_servers);\n  if (dns_servers != NULL) {\n    for (i = 0; i < num_servers; i++) {\n      status = ares__sconfig_append_fromstr(&sysconfig->sconfig, dns_servers[i],\n                                            ARES_TRUE);\n      if (status != ARES_SUCCESS) {\n        return status;\n      }\n    }\n    for (i = 0; i < num_servers; i++) {\n      ares_free(dns_servers[i]);\n    }\n    ares_free(dns_servers);\n  }\n\n  domains            = ares_get_android_search_domains_list();\n  sysconfig->domains = ares__strsplit(domains, \", \", &sysconfig->ndomains);\n  ares_free(domains);\n\n#  ifdef HAVE___SYSTEM_PROPERTY_GET\n  /* Old way using the system property still in place as\n   * a fallback. Older android versions can still use this.\n   * it's possible for older apps not not have added the new\n   * permission and we want to try to avoid breaking those.\n   *\n   * We'll only run this if we don't have any dns servers\n   * because this will get the same ones (if it works). */\n  if (sysconfig->sconfig == NULL) {\n    char propname[PROP_NAME_MAX];\n    char propvalue[PROP_VALUE_MAX] = \"\";\n    for (i = 1; i <= MAX_DNS_PROPERTIES; i++) {\n      snprintf(propname, sizeof(propname), \"%s%u\", DNS_PROP_NAME_PREFIX, i);\n      if (__system_property_get(propname, propvalue) < 1) {\n        break;\n      }\n      status =\n        ares__sconfig_append_fromstr(&sysconfig->sconfig, propvalue, ARES_TRUE);\n      if (status != ARES_SUCCESS) {\n        return status;\n      }\n    }\n  }\n#  endif /* HAVE___SYSTEM_PROPERTY_GET */\n\n  return status;\n}",
          "fn_code_pos": [
            [
              775,
              0
            ],
            [
              834,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_sysconfig_android",
            "parameters": {
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__init_sysconfig_libresolv(ares_sysconfig_t *sysconfig)\n{\n  struct __res_state       res;\n  ares_status_t            status = ARES_SUCCESS;\n  union res_sockaddr_union addr[MAXNS];\n  int                      nscount;\n  size_t                   i;\n  size_t                   entries = 0;\n  ares__buf_t             *ipbuf   = NULL;\n\n  memset(&res, 0, sizeof(res));\n\n  if (res_ninit(&res) != 0 || !(res.options & RES_INIT)) {\n    return ARES_EFILE;\n  }\n\n  nscount = res_getservers(&res, addr, MAXNS);\n\n  for (i = 0; i < (size_t)nscount; ++i) {\n    char           ipaddr[INET6_ADDRSTRLEN] = \"\";\n    char          *ipstr                    = NULL;\n    unsigned short port                     = 0;\n    unsigned int   ll_scope                 = 0;\n\n    sa_family_t    family = addr[i].sin.sin_family;\n    if (family == AF_INET) {\n      ares_inet_ntop(family, &addr[i].sin.sin_addr, ipaddr, sizeof(ipaddr));\n      port = ntohs(addr[i].sin.sin_port);\n    } else if (family == AF_INET6) {\n      ares_inet_ntop(family, &addr[i].sin6.sin6_addr, ipaddr, sizeof(ipaddr));\n      port     = ntohs(addr[i].sin6.sin6_port);\n      ll_scope = addr[i].sin6.sin6_scope_id;\n    } else {\n      continue;\n    }\n\n\n    /* [ip]:port%iface */\n    ipbuf = ares__buf_create();\n    if (ipbuf == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n\n    status = ares__buf_append_str(ipbuf, \"[\");\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    status = ares__buf_append_str(ipbuf, ipaddr);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    status = ares__buf_append_str(ipbuf, \"]\");\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    if (port) {\n      status = ares__buf_append_str(ipbuf, \":\");\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n      status = ares__buf_append_num_dec(ipbuf, port, 0);\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n    }\n\n    if (ll_scope) {\n      status = ares__buf_append_str(ipbuf, \"%\");\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n      status = ares__buf_append_num_dec(ipbuf, ll_scope, 0);\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n    }\n\n    ipstr = ares__buf_finish_str(ipbuf, NULL);\n    ipbuf = NULL;\n    if (ipstr == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n\n    status =\n      ares__sconfig_append_fromstr(&sysconfig->sconfig, ipstr, ARES_TRUE);\n\n    ares_free(ipstr);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\n  while ((entries < MAXDNSRCH) && res.dnsrch[entries]) {\n    entries++;\n  }\n\n  if (entries) {\n    sysconfig->domains = ares_malloc_zero(entries * sizeof(char *));\n    if (sysconfig->domains == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    } else {\n      sysconfig->ndomains = entries;\n      for (i = 0; i < sysconfig->ndomains; i++) {\n        sysconfig->domains[i] = ares_strdup(res.dnsrch[i]);\n        if (sysconfig->domains[i] == NULL) {\n          status = ARES_ENOMEM;\n          goto done;\n        }\n      }\n    }\n  }\n\n  if (res.ndots >= 0) {\n    sysconfig->ndots = (size_t)res.ndots;\n  }\n/* Apple does not allow configuration of retry, so this is a static dummy\n * value, ignore */\n#  ifndef __APPLE__\n  if (res.retry > 0) {\n    sysconfig->tries = (size_t)res.retry;\n  }\n#  endif\n  if (res.options & RES_ROTATE) {\n    sysconfig->rotate = ARES_TRUE;\n  }\n\n  if (res.retrans > 0) {\n/* Apple does not allow configuration of retrans, so this is a dummy value\n * that is extremely high (5s) */\n#  ifndef __APPLE__\n    if (res.retrans > 0) {\n      sysconfig->timeout_ms = (unsigned int)res.retrans * 1000;\n    }\n#  endif\n  }\n\ndone:\n  ares__buf_destroy(ipbuf);\n  res_ndestroy(&res);\n  return status;\n}",
          "fn_code_pos": [
            [
              838,
              0
            ],
            [
              984,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_sysconfig_libresolv",
            "parameters": {
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static void ares_sysconfig_free(ares_sysconfig_t *sysconfig)\n{\n  ares__llist_destroy(sysconfig->sconfig);\n  ares__strsplit_free(sysconfig->domains, sysconfig->ndomains);\n  ares_free(sysconfig->sortlist);\n  ares_free(sysconfig->lookups);\n  memset(sysconfig, 0, sizeof(*sysconfig));\n}",
          "fn_code_pos": [
            [
              987,
              0
            ],
            [
              994,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sysconfig_free",
            "parameters": {
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t ares_sysconfig_apply(ares_channel_t         *channel,\n                                          const ares_sysconfig_t *sysconfig)\n{\n  ares_status_t status;\n\n  if (sysconfig->sconfig && !(channel->optmask & ARES_OPT_SERVERS)) {\n    status = ares__servers_update(channel, sysconfig->sconfig, ARES_FALSE);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  if (sysconfig->domains && !(channel->optmask & ARES_OPT_DOMAINS)) {\n    /* Make sure we duplicate first then replace so even if there is\n     * ARES_ENOMEM, the channel stays in a good state */\n    char **temp =\n      ares__strsplit_duplicate(sysconfig->domains, sysconfig->ndomains);\n    if (temp == NULL) {\n      return ARES_ENOMEM;\n    }\n\n    ares__strsplit_free(channel->domains, channel->ndomains);\n    channel->domains  = temp;\n    channel->ndomains = sysconfig->ndomains;\n  }\n\n  if (sysconfig->lookups && !(channel->optmask & ARES_OPT_LOOKUPS)) {\n    char *temp = ares_strdup(sysconfig->lookups);\n    if (temp == NULL) {\n      return ARES_ENOMEM;\n    }\n\n    ares_free(channel->lookups);\n    channel->lookups = temp;\n  }\n\n  if (sysconfig->sortlist && !(channel->optmask & ARES_OPT_SORTLIST)) {\n    struct apattern *temp =\n      ares_malloc(sizeof(*channel->sortlist) * sysconfig->nsortlist);\n    if (temp == NULL) {\n      return ARES_ENOMEM;\n    }\n    memcpy(temp, sysconfig->sortlist,\n           sizeof(*channel->sortlist) * sysconfig->nsortlist);\n\n    ares_free(channel->sortlist);\n    channel->sortlist = temp;\n    channel->nsort    = sysconfig->nsortlist;\n  }\n\n  if (sysconfig->ndots && !(channel->optmask & ARES_OPT_NDOTS)) {\n    channel->ndots = sysconfig->ndots;\n  }\n\n  if (sysconfig->tries && !(channel->optmask & ARES_OPT_TRIES)) {\n    channel->tries = sysconfig->tries;\n  }\n\n  if (sysconfig->timeout_ms && !(channel->optmask & ARES_OPT_TIMEOUTMS)) {\n    channel->timeout = sysconfig->timeout_ms;\n  }\n\n  if (!(channel->optmask & (ARES_OPT_ROTATE | ARES_OPT_NOROTATE))) {\n    channel->rotate = sysconfig->rotate;\n  }\n\n  if (sysconfig->usevc) {\n    channel->flags |= ARES_FLAG_USEVC;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              996,
              0
            ],
            [
              1067,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_sysconfig_apply",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__init_by_sysconfig(ares_channel_t *channel)\n{\n  ares_status_t    status;\n  ares_sysconfig_t sysconfig;\n\n  memset(&sysconfig, 0, sizeof(sysconfig));\n\n#ifdef _WIN32\n  status = ares__init_sysconfig_windows(&sysconfig);\n#elif defined(__MVS__)\n  status = ares__init_sysconfig_mvs(&sysconfig);\n#elif defined(__riscos__)\n  status = ares__init_sysconfig_riscos(&sysconfig);\n#elif defined(WATT32)\n  status = ares__init_sysconfig_watt32(&sysconfig);\n#elif defined(ANDROID) || defined(__ANDROID__)\n  status = ares__init_sysconfig_android(&sysconfig);\n#elif defined(__APPLE__)\n  status = ares__init_sysconfig_macos(&sysconfig);\n#elif defined(CARES_USE_LIBRESOLV)\n  status = ares__init_sysconfig_libresolv(&sysconfig);\n#else\n  status = ares__init_sysconfig_files(channel, &sysconfig);\n#endif\n\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Environment is supposed to override sysconfig */\n  status = ares__init_by_environment(&sysconfig);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_sysconfig_apply(channel, &sysconfig);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\ndone:\n  ares_sysconfig_free(&sysconfig);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              1069,
              0
            ],
            [
              1113,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_by_sysconfig",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  /* The metric we sort them by. */\n  ULONG  metric;\n\n  /* Original index of the item, used as a secondary sort parameter to make\n   * qsort() stable if the metrics are equal */\n  size_t orig_idx;\n\n  /* Room enough for the string form of any IPv4 or IPv6 address that\n   * ares_inet_ntop() will create.  Based on the existing c-ares practice.\n   */\n  char   text[INET6_ADDRSTRLEN + 8 + 64]; /* [%s]:NNNNN%iface */\n} Address;",
          {
            "metric": "ULONG",
            "orig_idx": "size_t",
            "text[INET6_ADDRSTRLEN + 8 + 64]": "char"
          },
          "Address",
          [
            162,
            0
          ],
          [
            174,
            10
          ]
        ],
        [
          "typedef struct {\n  /* The metric we sort them by. */\n  ULONG  metric;\n\n  /* Original index of the item, used as a secondary sort parameter to make\n   * qsort() stable if the metrics are equal */\n  size_t orig_idx;\n\n  /* Room enough for the string form of any IPv4 or IPv6 address that\n   * ares_inet_ntop() will create.  Based on the existing c-ares practice.\n   */\n  char   text[INET6_ADDRSTRLEN + 8 + 64]; /* [%s]:NNNNN%iface */\n} Address;",
          {
            "metric": "ULONG",
            "orig_idx": "size_t",
            "text[INET6_ADDRSTRLEN + 8 + 64]": "char"
          },
          "Address",
          [
            162,
            0
          ],
          [
            174,
            10
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            321,
            4
          ],
          [
            321,
            19
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            322,
            4
          ],
          [
            322,
            22
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            323,
            4
          ],
          [
            323,
            23
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            419,
            8
          ],
          [
            419,
            24
          ]
        ],
        [
          "struct __res_state",
          {},
          "",
          [
            643,
            2
          ],
          [
            643,
            20
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            674,
            4
          ],
          [
            674,
            22
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            675,
            4
          ],
          [
            675,
            20
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            690,
            4
          ],
          [
            690,
            23
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            691,
            4
          ],
          [
            691,
            20
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            758,
            4
          ],
          [
            758,
            20
          ]
        ],
        [
          "struct __res_state",
          {},
          "",
          [
            840,
            2
          ],
          [
            840,
            20
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            1033,
            4
          ],
          [
            1033,
            19
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <sys/param.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#  include <sys/system_properties.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#  include \"ares_android.h\"\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#  include <resolv.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#    include <iphlpapi.h>\n",
          [
            61,
            0
          ],
          [
            62,
            0
          ]
        ],
        [
          "#    include <netioapi.h>\n",
          [
            64,
            0
          ],
          [
            65,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            68,
            0
          ],
          [
            69,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            69,
            0
          ],
          [
            70,
            0
          ]
        ],
        [
          "#include \"ares_platform.h\"\n",
          [
            70,
            0
          ],
          [
            71,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            71,
            0
          ],
          [
            72,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_freeaddrinfo.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares__freeaddrinfo_cnames(struct ares_addrinfo_cname *head)\n{\n  struct ares_addrinfo_cname *current;\n  while (head) {\n    current = head;\n    head    = head->next;\n    ares_free(current->alias);\n    ares_free(current->name);\n    ares_free(current);\n  }\n}",
          "fn_code_pos": [
            [
              36,
              0
            ],
            [
              46,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__freeaddrinfo_cnames",
            "parameters": {
              "head": "struct ares_addrinfo_cname"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__freeaddrinfo_nodes(struct ares_addrinfo_node *head)\n{\n  struct ares_addrinfo_node *current;\n  while (head) {\n    current = head;\n    head    = head->ai_next;\n    ares_free(current->ai_addr);\n    ares_free(current);\n  }\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              57,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__freeaddrinfo_nodes",
            "parameters": {
              "head": "struct ares_addrinfo_node"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_freeaddrinfo(struct ares_addrinfo *ai)\n{\n  if (ai == NULL) {\n    return;\n  }\n  ares__freeaddrinfo_cnames(ai->cnames);\n  ares__freeaddrinfo_nodes(ai->nodes);\n\n  ares_free(ai->name);\n  ares_free(ai);\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              69,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_freeaddrinfo",
            "parameters": {
              "ai": "struct ares_addrinfo"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            36,
            31
          ],
          [
            36,
            57
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            38,
            2
          ],
          [
            38,
            28
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            48,
            30
          ],
          [
            48,
            55
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            50,
            2
          ],
          [
            50,
            27
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            59,
            23
          ],
          [
            59,
            43
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__threads.c": {
      "fn_def_list": [
        {
          "fn_code": "ares__thread_mutex_t *ares__thread_mutex_create(void)\n{\n  ares__thread_mutex_t *mut = ares_malloc_zero(sizeof(*mut));\n  if (mut == NULL) {\n    return NULL;\n  }\n\n  InitializeCriticalSection(&mut->mutex);\n  return mut;\n}",
          "fn_code_pos": [
            [
              36,
              0
            ],
            [
              45,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_mutex_create",
            "parameters": {},
            "return_type": "ares__thread_mutex_t"
          }
        },
        {
          "fn_code": "void ares__thread_mutex_destroy(ares__thread_mutex_t *mut)\n{\n  if (mut == NULL) {\n    return;\n  }\n  DeleteCriticalSection(&mut->mutex);\n  ares_free(mut);\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_mutex_destroy",
            "parameters": {
              "mut": "ares__thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__thread_mutex_lock(ares__thread_mutex_t *mut)\n{\n  if (mut == NULL) {\n    return;\n  }\n  EnterCriticalSection(&mut->mutex);\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              62,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_mutex_lock",
            "parameters": {
              "mut": "ares__thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__thread_mutex_unlock(ares__thread_mutex_t *mut)\n{\n  if (mut == NULL) {\n    return;\n  }\n  LeaveCriticalSection(&mut->mutex);\n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              70,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_mutex_unlock",
            "parameters": {
              "mut": "ares__thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__thread_cond_t *ares__thread_cond_create(void)\n{\n  ares__thread_cond_t *cond = ares_malloc_zero(sizeof(*cond));\n  if (cond == NULL) {\n    return NULL;\n  }\n  InitializeConditionVariable(&cond->cond);\n  return cond;\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_create",
            "parameters": {},
            "return_type": "ares__thread_cond_t"
          }
        },
        {
          "fn_code": "void ares__thread_cond_destroy(ares__thread_cond_t *cond)\n{\n  if (cond == NULL) {\n    return;\n  }\n  ares_free(cond);\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              92,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_destroy",
            "parameters": {
              "cond": "ares__thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__thread_cond_signal(ares__thread_cond_t *cond)\n{\n  if (cond == NULL) {\n    return;\n  }\n  WakeConditionVariable(&cond->cond);\n}",
          "fn_code_pos": [
            [
              94,
              0
            ],
            [
              100,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_signal",
            "parameters": {
              "cond": "ares__thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__thread_cond_broadcast(ares__thread_cond_t *cond)\n{\n  if (cond == NULL) {\n    return;\n  }\n  WakeAllConditionVariable(&cond->cond);\n}",
          "fn_code_pos": [
            [
              102,
              0
            ],
            [
              108,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_broadcast",
            "parameters": {
              "cond": "ares__thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares__thread_cond_wait(ares__thread_cond_t  *cond,\n                                     ares__thread_mutex_t *mut)\n{\n  if (cond == NULL || mut == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  SleepConditionVariableCS(&cond->cond, &mut->mutex, INFINITE);\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              110,
              0
            ],
            [
              119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_wait",
            "parameters": {
              "cond": "ares__thread_cond_t",
              "mut": "ares__thread_mutex_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__thread_cond_timedwait(ares__thread_cond_t  *cond,\n                                          ares__thread_mutex_t *mut,\n                                          unsigned long         timeout_ms)\n{\n  if (cond == NULL || mut == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (!SleepConditionVariableCS(&cond->cond, &mut->mutex, timeout_ms)) {\n    return ARES_ETIMEOUT;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              134,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_timedwait",
            "parameters": {
              "cond": "ares__thread_cond_t",
              "mut": "ares__thread_mutex_t",
              "timeout_ms": "unsigned long"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static DWORD WINAPI ares__thread_func(LPVOID lpParameter)\n{\n  ares__thread_t *thread = lpParameter;\n\n  thread->rv = thread->func(thread->arg);\n  return 0;\n}",
          "fn_code_pos": [
            [
              146,
              0
            ],
            [
              152,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_func",
            "parameters": {
              "lpParameter": "LPVOID"
            },
            "return_type": "DWORD"
          }
        },
        {
          "fn_code": "ares_status_t ares__thread_create(ares__thread_t    **thread,\n                                  ares__thread_func_t func, void *arg)\n{\n  ares__thread_t *thr = NULL;\n\n  if (func == NULL || thread == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  thr = ares_malloc_zero(sizeof(*thr));\n  if (thr == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  thr->func   = func;\n  thr->arg    = arg;\n  thr->thread = CreateThread(NULL, 0, ares__thread_func, thr, 0, &thr->id);\n  if (thr->thread == NULL) {\n    ares_free(thr);\n    return ARES_ESERVFAIL;\n  }\n\n  *thread = thr;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              154,
              0
            ],
            [
              178,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_create",
            "parameters": {
              "thread": "ares__thread_t",
              "func": "ares__thread_func_t",
              "arg": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__thread_join(ares__thread_t *thread, void **rv)\n{\n  ares_status_t status = ARES_SUCCESS;\n\n  if (thread == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (WaitForSingleObject(thread->thread, INFINITE) != WAIT_OBJECT_0) {\n    status = ARES_ENOTFOUND;\n  } else {\n    CloseHandle(thread->thread);\n  }\n\n  if (status == ARES_SUCCESS && rv != NULL) {\n    *rv = thread->rv;\n  }\n  ares_free(thread);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              180,
              0
            ],
            [
              200,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_join",
            "parameters": {
              "thread": "ares__thread_t",
              "rv": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__thread_mutex_t *ares__thread_mutex_create(void)\n{\n  pthread_mutexattr_t   attr;\n  ares__thread_mutex_t *mut = ares_malloc_zero(sizeof(*mut));\n  if (mut == NULL) {\n    return NULL;\n  }\n\n  if (pthread_mutexattr_init(&attr) != 0) {\n    ares_free(mut);\n    return NULL;\n  }\n\n  if (pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE) != 0) {\n    goto fail;\n  }\n\n  if (pthread_mutex_init(&mut->mutex, &attr) != 0) {\n    goto fail;\n  }\n\n  pthread_mutexattr_destroy(&attr);\n  return mut;\n\nfail:\n  pthread_mutexattr_destroy(&attr);\n  ares_free(mut);\n  return NULL;\n}",
          "fn_code_pos": [
            [
              219,
              0
            ],
            [
              247,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_mutex_create",
            "parameters": {},
            "return_type": "ares__thread_mutex_t"
          }
        },
        {
          "fn_code": "void ares__thread_mutex_destroy(ares__thread_mutex_t *mut)\n{\n  if (mut == NULL) {\n    return;\n  }\n  pthread_mutex_destroy(&mut->mutex);\n  ares_free(mut);\n}",
          "fn_code_pos": [
            [
              249,
              0
            ],
            [
              256,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_mutex_destroy",
            "parameters": {
              "mut": "ares__thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__thread_mutex_lock(ares__thread_mutex_t *mut)\n{\n  if (mut == NULL) {\n    return;\n  }\n  pthread_mutex_lock(&mut->mutex);\n}",
          "fn_code_pos": [
            [
              258,
              0
            ],
            [
              264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_mutex_lock",
            "parameters": {
              "mut": "ares__thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__thread_mutex_unlock(ares__thread_mutex_t *mut)\n{\n  if (mut == NULL) {\n    return;\n  }\n  pthread_mutex_unlock(&mut->mutex);\n}",
          "fn_code_pos": [
            [
              266,
              0
            ],
            [
              272,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_mutex_unlock",
            "parameters": {
              "mut": "ares__thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__thread_cond_t *ares__thread_cond_create(void)\n{\n  ares__thread_cond_t *cond = ares_malloc_zero(sizeof(*cond));\n  if (cond == NULL) {\n    return NULL;\n  }\n  pthread_cond_init(&cond->cond, NULL);\n  return cond;\n}",
          "fn_code_pos": [
            [
              278,
              0
            ],
            [
              286,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_create",
            "parameters": {},
            "return_type": "ares__thread_cond_t"
          }
        },
        {
          "fn_code": "void ares__thread_cond_destroy(ares__thread_cond_t *cond)\n{\n  if (cond == NULL) {\n    return;\n  }\n  pthread_cond_destroy(&cond->cond);\n  ares_free(cond);\n}",
          "fn_code_pos": [
            [
              288,
              0
            ],
            [
              295,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_destroy",
            "parameters": {
              "cond": "ares__thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__thread_cond_signal(ares__thread_cond_t *cond)\n{\n  if (cond == NULL) {\n    return;\n  }\n  pthread_cond_signal(&cond->cond);\n}",
          "fn_code_pos": [
            [
              297,
              0
            ],
            [
              303,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_signal",
            "parameters": {
              "cond": "ares__thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__thread_cond_broadcast(ares__thread_cond_t *cond)\n{\n  if (cond == NULL) {\n    return;\n  }\n  pthread_cond_broadcast(&cond->cond);\n}",
          "fn_code_pos": [
            [
              305,
              0
            ],
            [
              311,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_broadcast",
            "parameters": {
              "cond": "ares__thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares__thread_cond_wait(ares__thread_cond_t  *cond,\n                                     ares__thread_mutex_t *mut)\n{\n  if (cond == NULL || mut == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  pthread_cond_wait(&cond->cond, &mut->mutex);\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              313,
              0
            ],
            [
              322,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_wait",
            "parameters": {
              "cond": "ares__thread_cond_t",
              "mut": "ares__thread_mutex_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static void ares__timespec_timeout(struct timespec *ts, unsigned long add_ms)\n{\n#    if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_REALTIME)\n  clock_gettime(CLOCK_REALTIME, ts);\n#    elif defined(HAVE_GETTIMEOFDAY)\n  struct timeval tv;\n  gettimeofday(&tv, NULL);\n  ts->tv_sec  = tv.tv_sec;\n  ts->tv_nsec = tv.tv_usec * 1000;\n#    else\n#      error cannot determine current system time\n#    endif\n\n  ts->tv_sec  += (time_t)(add_ms / 1000);\n  ts->tv_nsec += (long)((add_ms % 1000) * 1000000);\n\n  /* Normalize if needed */\n  if (ts->tv_nsec >= 1000000000) {\n    ts->tv_sec  += ts->tv_nsec / 1000000000;\n    ts->tv_nsec %= 1000000000;\n  }\n}",
          "fn_code_pos": [
            [
              324,
              0
            ],
            [
              345,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__timespec_timeout",
            "parameters": {
              "ts": "struct timespec",
              "add_ms": "unsigned long"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares__thread_cond_timedwait(ares__thread_cond_t  *cond,\n                                          ares__thread_mutex_t *mut,\n                                          unsigned long         timeout_ms)\n{\n  struct timespec ts;\n\n  if (cond == NULL || mut == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  ares__timespec_timeout(&ts, timeout_ms);\n\n  if (pthread_cond_timedwait(&cond->cond, &mut->mutex, &ts) != 0) {\n    return ARES_ETIMEOUT;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              347,
              0
            ],
            [
              364,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_timedwait",
            "parameters": {
              "cond": "ares__thread_cond_t",
              "mut": "ares__thread_mutex_t",
              "timeout_ms": "unsigned long"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__thread_create(ares__thread_t    **thread,\n                                  ares__thread_func_t func, void *arg)\n{\n  ares__thread_t *thr = NULL;\n\n  if (func == NULL || thread == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  thr = ares_malloc_zero(sizeof(*thr));\n  if (thr == NULL) {\n    return ARES_ENOMEM;\n  }\n  if (pthread_create(&thr->thread, NULL, func, arg) != 0) {\n    ares_free(thr);\n    return ARES_ESERVFAIL;\n  }\n\n  *thread = thr;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              370,
              0
            ],
            [
              390,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_create",
            "parameters": {
              "thread": "ares__thread_t",
              "func": "ares__thread_func_t",
              "arg": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__thread_join(ares__thread_t *thread, void **rv)\n{\n  void         *ret    = NULL;\n  ares_status_t status = ARES_SUCCESS;\n\n  if (thread == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (pthread_join(thread->thread, &ret) != 0) {\n    status = ARES_ENOTFOUND;\n  }\n  ares_free(thread);\n\n  if (status == ARES_SUCCESS && rv != NULL) {\n    *rv = ret;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              392,
              0
            ],
            [
              410,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_join",
            "parameters": {
              "thread": "ares__thread_t",
              "rv": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_threadsafety(void)\n{\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              414,
              0
            ],
            [
              417,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_threadsafety",
            "parameters": {},
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__thread_mutex_t *ares__thread_mutex_create(void)\n{\n  return NULL;\n}",
          "fn_code_pos": [
            [
              422,
              0
            ],
            [
              425,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_mutex_create",
            "parameters": {},
            "return_type": "ares__thread_mutex_t"
          }
        },
        {
          "fn_code": "void ares__thread_mutex_destroy(ares__thread_mutex_t *mut)\n{\n  (void)mut;\n}",
          "fn_code_pos": [
            [
              427,
              0
            ],
            [
              430,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_mutex_destroy",
            "parameters": {
              "mut": "ares__thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__thread_mutex_lock(ares__thread_mutex_t *mut)\n{\n  (void)mut;\n}",
          "fn_code_pos": [
            [
              432,
              0
            ],
            [
              435,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_mutex_lock",
            "parameters": {
              "mut": "ares__thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__thread_mutex_unlock(ares__thread_mutex_t *mut)\n{\n  (void)mut;\n}",
          "fn_code_pos": [
            [
              437,
              0
            ],
            [
              440,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_mutex_unlock",
            "parameters": {
              "mut": "ares__thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__thread_cond_t *ares__thread_cond_create(void)\n{\n  return NULL;\n}",
          "fn_code_pos": [
            [
              442,
              0
            ],
            [
              445,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_create",
            "parameters": {},
            "return_type": "ares__thread_cond_t"
          }
        },
        {
          "fn_code": "void ares__thread_cond_destroy(ares__thread_cond_t *cond)\n{\n  (void)cond;\n}",
          "fn_code_pos": [
            [
              447,
              0
            ],
            [
              450,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_destroy",
            "parameters": {
              "cond": "ares__thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__thread_cond_signal(ares__thread_cond_t *cond)\n{\n  (void)cond;\n}",
          "fn_code_pos": [
            [
              452,
              0
            ],
            [
              455,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_signal",
            "parameters": {
              "cond": "ares__thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__thread_cond_broadcast(ares__thread_cond_t *cond)\n{\n  (void)cond;\n}",
          "fn_code_pos": [
            [
              457,
              0
            ],
            [
              460,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_broadcast",
            "parameters": {
              "cond": "ares__thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares__thread_cond_wait(ares__thread_cond_t  *cond,\n                                     ares__thread_mutex_t *mut)\n{\n  (void)cond;\n  (void)mut;\n  return ARES_ENOTIMP;\n}",
          "fn_code_pos": [
            [
              462,
              0
            ],
            [
              468,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_wait",
            "parameters": {
              "cond": "ares__thread_cond_t",
              "mut": "ares__thread_mutex_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__thread_cond_timedwait(ares__thread_cond_t  *cond,\n                                          ares__thread_mutex_t *mut,\n                                          unsigned long         timeout_ms)\n{\n  (void)cond;\n  (void)mut;\n  (void)timeout_ms;\n  return ARES_ENOTIMP;\n}",
          "fn_code_pos": [
            [
              470,
              0
            ],
            [
              478,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_timedwait",
            "parameters": {
              "cond": "ares__thread_cond_t",
              "mut": "ares__thread_mutex_t",
              "timeout_ms": "unsigned long"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__thread_create(ares__thread_t    **thread,\n                                  ares__thread_func_t func, void *arg)\n{\n  (void)thread;\n  (void)func;\n  (void)arg;\n  return ARES_ENOTIMP;\n}",
          "fn_code_pos": [
            [
              480,
              0
            ],
            [
              487,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_create",
            "parameters": {
              "thread": "ares__thread_t",
              "func": "ares__thread_func_t",
              "arg": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__thread_join(ares__thread_t *thread, void **rv)\n{\n  (void)thread;\n  (void)rv;\n  return ARES_ENOTIMP;\n}",
          "fn_code_pos": [
            [
              489,
              0
            ],
            [
              494,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_join",
            "parameters": {
              "thread": "ares__thread_t",
              "rv": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_threadsafety(void)\n{\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              496,
              0
            ],
            [
              499,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_threadsafety",
            "parameters": {},
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__channel_threading_init(ares_channel_t *channel)\n{\n  ares_status_t status = ARES_SUCCESS;\n\n  /* Threading is optional! */\n  if (!ares_threadsafety()) {\n    return ARES_SUCCESS;\n  }\n\n  channel->lock = ares__thread_mutex_create();\n  if (channel->lock == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  channel->cond_empty = ares__thread_cond_create();\n  if (channel->cond_empty == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares__channel_threading_destroy(channel);\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              503,
              0
            ],
            [
              529,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__channel_threading_init",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares__channel_threading_destroy(ares_channel_t *channel)\n{\n  ares__thread_mutex_destroy(channel->lock);\n  channel->lock = NULL;\n  ares__thread_cond_destroy(channel->cond_empty);\n  channel->cond_empty = NULL;\n}",
          "fn_code_pos": [
            [
              531,
              0
            ],
            [
              537,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__channel_threading_destroy",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__channel_lock(ares_channel_t *channel)\n{\n  ares__thread_mutex_lock(channel->lock);\n}",
          "fn_code_pos": [
            [
              539,
              0
            ],
            [
              542,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__channel_lock",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__channel_unlock(ares_channel_t *channel)\n{\n  ares__thread_mutex_unlock(channel->lock);\n}",
          "fn_code_pos": [
            [
              544,
              0
            ],
            [
              547,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__channel_unlock",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_queue_wait_empty(ares_channel_t *channel, int timeout_ms)\n{\n  ares_status_t  status = ARES_SUCCESS;\n  struct timeval tout;\n\n  if (!ares_threadsafety()) {\n    return ARES_ENOTIMP;\n  }\n\n  if (channel == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (timeout_ms >= 0) {\n    tout          = ares__tvnow();\n    tout.tv_sec  += timeout_ms / 1000;\n    tout.tv_usec += (timeout_ms % 1000) * 1000;\n  }\n\n  ares__thread_mutex_lock(channel->lock);\n  while (ares__llist_len(channel->all_queries)) {\n    if (timeout_ms < 0) {\n      ares__thread_cond_wait(channel->cond_empty, channel->lock);\n    } else {\n      struct timeval tv_remaining;\n      struct timeval tv_now = ares__tvnow();\n      unsigned long  tms;\n\n      ares__timeval_remaining(&tv_remaining, &tv_now, &tout);\n      tms = (unsigned long)((tv_remaining.tv_sec * 1000) +\n                            (tv_remaining.tv_usec / 1000));\n      if (tms == 0) {\n        status = ARES_ETIMEOUT;\n      } else {\n        status =\n          ares__thread_cond_timedwait(channel->cond_empty, channel->lock, tms);\n      }\n\n      /* If there was a timeout, don't loop.  Otherwise, make sure this wasn't\n       * a spurious wakeup by looping and checking the condition. */\n      if (status == ARES_ETIMEOUT) {\n        break;\n      }\n    }\n  }\n  ares__thread_mutex_unlock(channel->lock);\n  return status;\n}",
          "fn_code_pos": [
            [
              550,
              0
            ],
            [
              597,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_queue_wait_empty",
            "parameters": {
              "channel": "ares_channel_t",
              "timeout_ms": "int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares_queue_notify_empty(ares_channel_t *channel)\n{\n  if (channel == NULL) {\n    return;\n  }\n\n  /* We are guaranteed to be holding a channel lock already */\n  if (ares__llist_len(channel->all_queries)) {\n    return;\n  }\n\n  /* Notify all waiters of the conditional */\n  ares__thread_cond_broadcast(channel->cond_empty);\n}",
          "fn_code_pos": [
            [
              599,
              0
            ],
            [
              612,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_queue_notify_empty",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares__thread_mutex_create(void)",
          "fn_dec_pos": [
            [
              36,
              22
            ],
            [
              36,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_mutex_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares__thread_cond_create(void)",
          "fn_dec_pos": [
            [
              76,
              21
            ],
            [
              76,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "(*func)(void *arg)",
          "fn_dec_pos": [
            [
              140,
              8
            ],
            [
              140,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "arg": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__thread_mutex_create(void)",
          "fn_dec_pos": [
            [
              219,
              22
            ],
            [
              219,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_mutex_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares__thread_cond_create(void)",
          "fn_dec_pos": [
            [
              278,
              21
            ],
            [
              278,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares__thread_mutex_create(void)",
          "fn_dec_pos": [
            [
              422,
              22
            ],
            [
              422,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_mutex_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares__thread_cond_create(void)",
          "fn_dec_pos": [
            [
              442,
              21
            ],
            [
              442,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_create",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares__thread_mutex {\n  CRITICAL_SECTION mutex;\n}",
          {
            "mutex": "CRITICAL_SECTION"
          },
          "ares__thread_mutex",
          [
            32,
            0
          ],
          [
            34,
            1
          ]
        ],
        [
          "struct ares__thread_cond {\n  CONDITION_VARIABLE cond;\n}",
          {
            "cond": "CONDITION_VARIABLE"
          },
          "ares__thread_cond",
          [
            72,
            0
          ],
          [
            74,
            1
          ]
        ],
        [
          "struct ares__thread {\n  HANDLE thread;\n  DWORD  id;\n\n  void *(*func)(void *arg);\n  void *arg;\n  void *rv;\n}",
          {
            "thread": "HANDLE",
            "id": "DWORD",
            "*(*func)(void *arg)": "void",
            "*arg": "void",
            "*rv": "void"
          },
          "ares__thread",
          [
            136,
            0
          ],
          [
            143,
            1
          ]
        ],
        [
          "struct ares__thread_mutex {\n  pthread_mutex_t mutex;\n}",
          {
            "mutex": "pthread_mutex_t"
          },
          "ares__thread_mutex",
          [
            215,
            0
          ],
          [
            217,
            1
          ]
        ],
        [
          "struct ares__thread_cond {\n  pthread_cond_t cond;\n}",
          {
            "cond": "pthread_cond_t"
          },
          "ares__thread_cond",
          [
            274,
            0
          ],
          [
            276,
            1
          ]
        ],
        [
          "struct ares__thread {\n  pthread_t thread;\n}",
          {
            "thread": "pthread_t"
          },
          "ares__thread",
          [
            366,
            0
          ],
          [
            368,
            1
          ]
        ],
        [
          "struct ares__thread_mutex {\n  CRITICAL_SECTION mutex;\n}",
          {
            "mutex": "CRITICAL_SECTION"
          },
          "ares__thread_mutex",
          [
            32,
            0
          ],
          [
            34,
            1
          ]
        ],
        [
          "struct ares__thread_cond {\n  CONDITION_VARIABLE cond;\n}",
          {
            "cond": "CONDITION_VARIABLE"
          },
          "ares__thread_cond",
          [
            72,
            0
          ],
          [
            74,
            1
          ]
        ],
        [
          "struct ares__thread {\n  HANDLE thread;\n  DWORD  id;\n\n  void *(*func)(void *arg);\n  void *arg;\n  void *rv;\n}",
          {
            "thread": "HANDLE",
            "id": "DWORD",
            "*(*func)(void *arg)": "void",
            "*arg": "void",
            "*rv": "void"
          },
          "ares__thread",
          [
            136,
            0
          ],
          [
            143,
            1
          ]
        ],
        [
          "struct ares__thread_mutex {\n  pthread_mutex_t mutex;\n}",
          {
            "mutex": "pthread_mutex_t"
          },
          "ares__thread_mutex",
          [
            215,
            0
          ],
          [
            217,
            1
          ]
        ],
        [
          "struct ares__thread_cond {\n  pthread_cond_t cond;\n}",
          {
            "cond": "pthread_cond_t"
          },
          "ares__thread_cond",
          [
            274,
            0
          ],
          [
            276,
            1
          ]
        ],
        [
          "struct timespec",
          {},
          "",
          [
            324,
            35
          ],
          [
            324,
            50
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            329,
            2
          ],
          [
            329,
            16
          ]
        ],
        [
          "struct timespec",
          {},
          "",
          [
            351,
            2
          ],
          [
            351,
            17
          ]
        ],
        [
          "struct ares__thread {\n  pthread_t thread;\n}",
          {
            "thread": "pthread_t"
          },
          "ares__thread",
          [
            366,
            0
          ],
          [
            368,
            1
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            553,
            2
          ],
          [
            553,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            574,
            6
          ],
          [
            574,
            20
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            575,
            6
          ],
          [
            575,
            20
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#    include <pthread.h>\n",
          [
            203,
            0
          ],
          [
            204,
            0
          ]
        ],
        [
          "#      include <time.h>\n",
          [
            207,
            0
          ],
          [
            208,
            0
          ]
        ],
        [
          "#      include <sys/time.h>\n",
          [
            212,
            0
          ],
          [
            213,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_parse_naptr_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_parse_naptr_reply(const unsigned char *abuf, int alen_int,\n                           struct ares_naptr_reply **naptr_out)\n{\n  ares_status_t            status;\n  size_t                   alen;\n  struct ares_naptr_reply *naptr_head = NULL;\n  struct ares_naptr_reply *naptr_last = NULL;\n  struct ares_naptr_reply *naptr_curr;\n  ares_dns_record_t       *dnsrec = NULL;\n  size_t                   i;\n\n  *naptr_out = NULL;\n\n  if (alen_int < 0) {\n    return ARES_EBADRESP;\n  }\n\n  alen = (size_t)alen_int;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP;\n      goto done;\n    }\n\n    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN ||\n        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_NAPTR) {\n      continue;\n    }\n\n    /* Allocate storage for this NAPTR answer appending it to the list */\n    naptr_curr = ares_malloc_data(ARES_DATATYPE_NAPTR_REPLY);\n    if (naptr_curr == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n\n    /* Link in the record */\n    if (naptr_last) {\n      naptr_last->next = naptr_curr;\n    } else {\n      naptr_head = naptr_curr;\n    }\n    naptr_last = naptr_curr;\n\n    naptr_curr->order      = ares_dns_rr_get_u16(rr, ARES_RR_NAPTR_ORDER);\n    naptr_curr->preference = ares_dns_rr_get_u16(rr, ARES_RR_NAPTR_PREFERENCE);\n\n    /* XXX: Why is this unsigned char * ? */\n    naptr_curr->flags = (unsigned char *)ares_strdup(\n      ares_dns_rr_get_str(rr, ARES_RR_NAPTR_FLAGS));\n    if (naptr_curr->flags == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    /* XXX: Why is this unsigned char * ? */\n    naptr_curr->service = (unsigned char *)ares_strdup(\n      ares_dns_rr_get_str(rr, ARES_RR_NAPTR_SERVICES));\n    if (naptr_curr->service == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    /* XXX: Why is this unsigned char * ? */\n    naptr_curr->regexp = (unsigned char *)ares_strdup(\n      ares_dns_rr_get_str(rr, ARES_RR_NAPTR_REGEXP));\n    if (naptr_curr->regexp == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    naptr_curr->replacement =\n      ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_NAPTR_REPLACEMENT));\n    if (naptr_curr->replacement == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n  }\n\ndone:\n  /* clean up on error */\n  if (status != ARES_SUCCESS) {\n    if (naptr_head) {\n      ares_free_data(naptr_head);\n    }\n  } else {\n    /* everything looks fine, return the data */\n    *naptr_out = naptr_head;\n  }\n  ares_dns_record_destroy(dnsrec);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              30,
              0
            ],
            [
              133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_naptr_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen_int": "int",
              "naptr_out": "struct ares_naptr_reply"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            31,
            27
          ],
          [
            31,
            50
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            35,
            2
          ],
          [
            35,
            25
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            36,
            2
          ],
          [
            36,
            25
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            37,
            2
          ],
          [
            37,
            25
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_free_hostent.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_free_hostent(struct hostent *host)\n{\n  char **p;\n\n  if (!host) {\n    return;\n  }\n\n  ares_free(host->h_name);\n  for (p = host->h_aliases; p && *p; p++) {\n    ares_free(*p);\n  }\n  ares_free(host->h_aliases);\n  if (host->h_addr_list) {\n    ares_free(\n      host->h_addr_list[0]); /* no matter if there is one or many entries,\n                           there is only one malloc for all of them */\n    ares_free(host->h_addr_list);\n  }\n  ares_free(host);\n}",
          "fn_code_pos": [
            [
              36,
              0
            ],
            [
              56,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_free_hostent",
            "parameters": {
              "host": "struct hostent"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            36,
            23
          ],
          [
            36,
            37
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"ares_private.h\" /* for memdebug */\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_fds.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_fds(ares_channel_t *channel, fd_set *read_fds, fd_set *write_fds)\n{\n  ares_socket_t       nfds;\n  ares__slist_node_t *snode;\n  /* Are there any active queries? */\n  size_t              active_queries;\n\n  if (channel == NULL || read_fds == NULL || write_fds == NULL) {\n    return 0;\n  }\n\n  ares__channel_lock(channel);\n\n  active_queries = ares__llist_len(channel->all_queries);\n\n  nfds = 0;\n  for (snode = ares__slist_node_first(channel->servers); snode != NULL;\n       snode = ares__slist_node_next(snode)) {\n    struct server_state *server = ares__slist_node_val(snode);\n    ares__llist_node_t  *node;\n\n    for (node = ares__llist_node_first(server->connections); node != NULL;\n         node = ares__llist_node_next(node)) {\n      const struct server_connection *conn = ares__llist_node_val(node);\n\n      if (!active_queries && !conn->is_tcp) {\n        continue;\n      }\n\n      /* Silence coverity, shouldn't be possible */\n      if (conn->fd == ARES_SOCKET_BAD) {\n        continue;\n      }\n\n      /* Always wait on read */\n      FD_SET(conn->fd, read_fds);\n\n      if (conn->fd >= nfds) {\n        nfds = conn->fd + 1;\n      }\n\n      /* TCP only wait on write if we have buffered data */\n      if (conn->is_tcp && ares__buf_len(server->tcp_send)) {\n        FD_SET(conn->fd, write_fds);\n      }\n    }\n  }\n\n  ares__channel_unlock(channel);\n  return (int)nfds;\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_fds",
            "parameters": {
              "channel": "ares_channel_t",
              "read_fds": "fd_set",
              "write_fds": "fd_set"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct server_state",
          {},
          "",
          [
            50,
            4
          ],
          [
            50,
            23
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            55,
            12
          ],
          [
            55,
            36
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__hosts_file.c": {
      "fn_def_list": [
        {
          "fn_code": "const void *ares_dns_pton(const char *ipaddr, struct ares_addr *addr,\n                          size_t *out_len)\n{\n  const void *ptr     = NULL;\n  size_t      ptr_len = 0;\n\n  if (ipaddr == NULL || addr == NULL || out_len == NULL) {\n    return NULL;\n  }\n\n  *out_len = 0;\n\n  if (addr->family == AF_INET &&\n      ares_inet_pton(AF_INET, ipaddr, &addr->addr.addr4) > 0) {\n    ptr     = &addr->addr.addr4;\n    ptr_len = sizeof(addr->addr.addr4);\n  } else if (addr->family == AF_INET6 &&\n             ares_inet_pton(AF_INET6, ipaddr, &addr->addr.addr6) > 0) {\n    ptr     = &addr->addr.addr6;\n    ptr_len = sizeof(addr->addr.addr6);\n  } else if (addr->family == AF_UNSPEC) {\n    if (ares_inet_pton(AF_INET, ipaddr, &addr->addr.addr4) > 0) {\n      addr->family = AF_INET;\n      ptr          = &addr->addr.addr4;\n      ptr_len      = sizeof(addr->addr.addr4);\n    } else if (ares_inet_pton(AF_INET6, ipaddr, &addr->addr.addr6) > 0) {\n      addr->family = AF_INET6;\n      ptr          = &addr->addr.addr6;\n      ptr_len      = sizeof(addr->addr.addr6);\n    }\n  }\n\n  *out_len = ptr_len;\n  return ptr;\n}",
          "fn_code_pos": [
            [
              100,
              0
            ],
            [
              134,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_pton",
            "parameters": {
              "ipaddr": "char",
              "addr": "struct ares_addr",
              "out_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares__normalize_ipaddr(const char *ipaddr, char *out,\n                                          size_t out_len)\n{\n  struct ares_addr data;\n  const void      *addr;\n  size_t           addr_len = 0;\n\n  memset(&data, 0, sizeof(data));\n  data.family = AF_UNSPEC;\n\n  addr = ares_dns_pton(ipaddr, &data, &addr_len);\n  if (addr == NULL) {\n    return ARES_FALSE;\n  }\n\n  if (!ares_inet_ntop(data.family, addr, out, (ares_socklen_t)out_len)) {\n    return ARES_FALSE;\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              136,
              0
            ],
            [
              156,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__normalize_ipaddr",
            "parameters": {
              "ipaddr": "char",
              "out": "char",
              "out_len": "size_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares__hosts_entry_destroy(ares_hosts_entry_t *entry)\n{\n  if (entry == NULL) {\n    return;\n  }\n\n  /* Honor reference counting */\n  if (entry->refcnt != 0) {\n    entry->refcnt--;\n  }\n\n  if (entry->refcnt > 0) {\n    return;\n  }\n\n  ares__llist_destroy(entry->hosts);\n  ares__llist_destroy(entry->ips);\n  ares_free(entry);\n}",
          "fn_code_pos": [
            [
              158,
              0
            ],
            [
              176,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_entry_destroy",
            "parameters": {
              "entry": "ares_hosts_entry_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares__hosts_entry_destroy_cb(void *entry)\n{\n  ares__hosts_entry_destroy(entry);\n}",
          "fn_code_pos": [
            [
              178,
              0
            ],
            [
              181,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_entry_destroy_cb",
            "parameters": {
              "entry": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__hosts_file_destroy(ares_hosts_file_t *hf)\n{\n  if (hf == NULL) {\n    return;\n  }\n\n  ares_free(hf->filename);\n  ares__htable_strvp_destroy(hf->hosthash);\n  ares__htable_strvp_destroy(hf->iphash);\n  ares_free(hf);\n}",
          "fn_code_pos": [
            [
              183,
              0
            ],
            [
              193,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_file_destroy",
            "parameters": {
              "hf": "ares_hosts_file_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_hosts_file_t *ares__hosts_file_create(const char *filename)\n{\n  ares_hosts_file_t *hf = ares_malloc_zero(sizeof(*hf));\n  if (hf == NULL) {\n    goto fail;\n  }\n\n  hf->ts = time(NULL);\n\n  hf->filename = ares_strdup(filename);\n  if (hf->filename == NULL) {\n    goto fail;\n  }\n\n  hf->iphash = ares__htable_strvp_create(ares__hosts_entry_destroy_cb);\n  if (hf->iphash == NULL) {\n    goto fail;\n  }\n\n  hf->hosthash = ares__htable_strvp_create(NULL);\n  if (hf->hosthash == NULL) {\n    goto fail;\n  }\n\n  return hf;\n\nfail:\n  ares__hosts_file_destroy(hf);\n  return NULL;\n}",
          "fn_code_pos": [
            [
              195,
              0
            ],
            [
              224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_file_create",
            "parameters": {
              "filename": "char"
            },
            "return_type": "ares_hosts_file_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__hosts_file_merge_entry(\n  const ares_hosts_file_t *hf, ares_hosts_entry_t *existing,\n  ares_hosts_entry_t *entry, ares_hosts_file_match_t matchtype)\n{\n  ares__llist_node_t *node;\n\n  /* If we matched on IP address, we know there can only be 1, so there's no\n   * reason to do anything */\n  if (matchtype != ARES_MATCH_IPADDR) {\n    while ((node = ares__llist_node_first(entry->ips)) != NULL) {\n      const char *ipaddr = ares__llist_node_val(node);\n\n      if (ares__htable_strvp_get_direct(hf->iphash, ipaddr) != NULL) {\n        ares__llist_node_destroy(node);\n        continue;\n      }\n\n      ares__llist_node_move_parent_last(node, existing->ips);\n    }\n  }\n\n\n  while ((node = ares__llist_node_first(entry->hosts)) != NULL) {\n    const char *hostname = ares__llist_node_val(node);\n\n    if (ares__htable_strvp_get_direct(hf->hosthash, hostname) != NULL) {\n      ares__llist_node_destroy(node);\n      continue;\n    }\n\n    ares__llist_node_move_parent_last(node, existing->hosts);\n  }\n\n  ares__hosts_entry_destroy(entry);\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              232,
              0
            ],
            [
              267,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_file_merge_entry",
            "parameters": {
              "hf": "ares_hosts_file_t",
              "existing": "ares_hosts_entry_t",
              "entry": "ares_hosts_entry_t",
              "matchtype": "ares_hosts_file_match_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_hosts_file_match_t\n  ares__hosts_file_match(const ares_hosts_file_t *hf, ares_hosts_entry_t *entry,\n                         ares_hosts_entry_t **match)\n{\n  ares__llist_node_t *node;\n  *match = NULL;\n\n  for (node = ares__llist_node_first(entry->ips); node != NULL;\n       node = ares__llist_node_next(node)) {\n    const char *ipaddr = ares__llist_node_val(node);\n    *match             = ares__htable_strvp_get_direct(hf->iphash, ipaddr);\n    if (*match != NULL) {\n      return ARES_MATCH_IPADDR;\n    }\n  }\n\n  for (node = ares__llist_node_first(entry->hosts); node != NULL;\n       node = ares__llist_node_next(node)) {\n    const char *host = ares__llist_node_val(node);\n    *match           = ares__htable_strvp_get_direct(hf->hosthash, host);\n    if (*match != NULL) {\n      return ARES_MATCH_HOST;\n    }\n  }\n\n  return ARES_MATCH_NONE;\n}",
          "fn_code_pos": [
            [
              269,
              0
            ],
            [
              295,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_file_match",
            "parameters": {
              "hf": "ares_hosts_file_t",
              "entry": "ares_hosts_entry_t",
              "match": "ares_hosts_entry_t"
            },
            "return_type": "ares_hosts_file_match_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__hosts_file_add(ares_hosts_file_t  *hosts,\n                                          ares_hosts_entry_t *entry)\n{\n  ares_hosts_entry_t     *match  = NULL;\n  ares_status_t           status = ARES_SUCCESS;\n  ares__llist_node_t     *node;\n  ares_hosts_file_match_t matchtype;\n  size_t                  num_hostnames;\n\n  /* Record the number of hostnames in this entry file.  If we merge into an\n   * existing record, these will be *appended* to the entry, so we'll count\n   * backwards when adding to the hosts hashtable */\n  num_hostnames = ares__llist_len(entry->hosts);\n\n  matchtype = ares__hosts_file_match(hosts, entry, &match);\n\n  if (matchtype != ARES_MATCH_NONE) {\n    status = ares__hosts_file_merge_entry(hosts, match, entry, matchtype);\n    if (status != ARES_SUCCESS) {\n      ares__hosts_entry_destroy(entry);\n      return status;\n    }\n    /* entry was invalidated above by merging */\n    entry = match;\n  }\n\n  if (matchtype != ARES_MATCH_IPADDR) {\n    const char *ipaddr = ares__llist_last_val(entry->ips);\n\n    if (!ares__htable_strvp_get(hosts->iphash, ipaddr, NULL)) {\n      if (!ares__htable_strvp_insert(hosts->iphash, ipaddr, entry)) {\n        ares__hosts_entry_destroy(entry);\n        return ARES_ENOMEM;\n      }\n      entry->refcnt++;\n    }\n  }\n\n  /* Go backwards, on a merge, hostnames are appended.  Breakout once we've\n   * consumed all the hosts that we appended */\n  for (node = ares__llist_node_last(entry->hosts); node != NULL;\n       node = ares__llist_node_prev(node)) {\n    const char *val = ares__llist_node_val(node);\n\n    if (num_hostnames == 0) {\n      break;\n    }\n\n    num_hostnames--;\n\n    /* first hostname match wins.  If we detect a duplicate hostname for another\n     * ip it will automatically be added to the same entry */\n    if (ares__htable_strvp_get(hosts->hosthash, val, NULL)) {\n      continue;\n    }\n\n    if (!ares__htable_strvp_insert(hosts->hosthash, val, entry)) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              298,
              0
            ],
            [
              360,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_file_add",
            "parameters": {
              "hosts": "ares_hosts_file_t",
              "entry": "ares_hosts_entry_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares__hosts_entry_isdup(ares_hosts_entry_t *entry,\n                                           const char         *host)\n{\n  ares__llist_node_t *node;\n\n  for (node = ares__llist_node_first(entry->ips); node != NULL;\n       node = ares__llist_node_next(node)) {\n    const char *myhost = ares__llist_node_val(node);\n    if (strcasecmp(myhost, host) == 0) {\n      return ARES_TRUE;\n    }\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              362,
              0
            ],
            [
              376,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_entry_isdup",
            "parameters": {
              "entry": "ares_hosts_entry_t",
              "host": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__parse_hosts_hostnames(ares__buf_t        *buf,\n                                                 ares_hosts_entry_t *entry)\n{\n  entry->hosts = ares__llist_create(ares_free);\n  if (entry->hosts == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  /* Parse hostnames and aliases */\n  while (ares__buf_len(buf)) {\n    char          hostname[256];\n    char         *temp;\n    ares_status_t status;\n    unsigned char comment = '#';\n\n    ares__buf_consume_whitespace(buf, ARES_FALSE);\n\n    if (ares__buf_len(buf) == 0) {\n      break;\n    }\n\n    /* See if it is a comment, if so stop processing */\n    if (ares__buf_begins_with(buf, &comment, 1)) {\n      break;\n    }\n\n    ares__buf_tag(buf);\n\n    /* Must be at end of line */\n    if (ares__buf_consume_nonwhitespace(buf) == 0) {\n      break;\n    }\n\n    status = ares__buf_tag_fetch_string(buf, hostname, sizeof(hostname));\n    if (status != ARES_SUCCESS) {\n      /* Bad entry, just ignore as long as its not the first.  If its the first,\n       * it must be valid */\n      if (ares__llist_len(entry->hosts) == 0) {\n        return ARES_EBADSTR;\n      }\n\n      continue;\n    }\n\n    /* Validate it is a valid hostname characterset */\n    if (!ares__is_hostname(hostname)) {\n      continue;\n    }\n\n    /* Don't add a duplicate to the same entry */\n    if (ares__hosts_entry_isdup(entry, hostname)) {\n      continue;\n    }\n\n    /* Add to list */\n    temp = ares_strdup(hostname);\n    if (temp == NULL) {\n      return ARES_ENOMEM;\n    }\n\n    if (ares__llist_insert_last(entry->hosts, temp) == NULL) {\n      ares_free(temp);\n      return ARES_ENOMEM;\n    }\n  }\n\n  /* Must have at least 1 entry */\n  if (ares__llist_len(entry->hosts) == 0) {\n    return ARES_EBADSTR;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              378,
              0
            ],
            [
              450,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__parse_hosts_hostnames",
            "parameters": {
              "buf": "ares__buf_t",
              "entry": "ares_hosts_entry_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__parse_hosts_ipaddr(ares__buf_t         *buf,\n                                              ares_hosts_entry_t **entry_out)\n{\n  char                addr[INET6_ADDRSTRLEN];\n  char               *temp;\n  ares_hosts_entry_t *entry = NULL;\n  ares_status_t       status;\n\n  *entry_out = NULL;\n\n  ares__buf_tag(buf);\n  ares__buf_consume_nonwhitespace(buf);\n  status = ares__buf_tag_fetch_string(buf, addr, sizeof(addr));\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Validate and normalize the ip address format */\n  if (!ares__normalize_ipaddr(addr, addr, sizeof(addr))) {\n    return ARES_EBADSTR;\n  }\n\n  entry = ares_malloc_zero(sizeof(*entry));\n  if (entry == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  entry->ips = ares__llist_create(ares_free);\n  if (entry->ips == NULL) {\n    ares__hosts_entry_destroy(entry);\n    return ARES_ENOMEM;\n  }\n\n  temp = ares_strdup(addr);\n  if (temp == NULL) {\n    ares__hosts_entry_destroy(entry);\n    return ARES_ENOMEM;\n  }\n\n  if (ares__llist_insert_first(entry->ips, temp) == NULL) {\n    ares_free(temp);\n    ares__hosts_entry_destroy(entry);\n    return ARES_ENOMEM;\n  }\n\n  *entry_out = entry;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              452,
              0
            ],
            [
              500,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__parse_hosts_ipaddr",
            "parameters": {
              "buf": "ares__buf_t",
              "entry_out": "ares_hosts_entry_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__parse_hosts(const char         *filename,\n                                       ares_hosts_file_t **out)\n{\n  ares__buf_t        *buf    = NULL;\n  ares_status_t       status = ARES_EBADRESP;\n  ares_hosts_file_t  *hf     = NULL;\n  ares_hosts_entry_t *entry  = NULL;\n\n  *out = NULL;\n\n  buf = ares__buf_create();\n  if (buf == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  status = ares__buf_load_file(filename, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  hf = ares__hosts_file_create(filename);\n  if (hf == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  while (ares__buf_len(buf)) {\n    unsigned char comment = '#';\n\n    /* -- Start of new line here -- */\n\n    /* Consume any leading whitespace */\n    ares__buf_consume_whitespace(buf, ARES_FALSE);\n\n    if (ares__buf_len(buf) == 0) {\n      break;\n    }\n\n    /* See if it is a comment, if so, consume remaining line */\n    if (ares__buf_begins_with(buf, &comment, 1)) {\n      ares__buf_consume_line(buf, ARES_TRUE);\n      continue;\n    }\n\n    /* Pull off ip address */\n    status = ares__parse_hosts_ipaddr(buf, &entry);\n    if (status == ARES_ENOMEM) {\n      goto done;\n    }\n    if (status != ARES_SUCCESS) {\n      /* Bad line, consume and go onto next */\n      ares__buf_consume_line(buf, ARES_TRUE);\n      continue;\n    }\n\n    /* Parse of the hostnames */\n    status = ares__parse_hosts_hostnames(buf, entry);\n    if (status == ARES_ENOMEM) {\n      goto done;\n    } else if (status != ARES_SUCCESS) {\n      /* Bad line, consume and go onto next */\n      ares__hosts_entry_destroy(entry);\n      entry = NULL;\n      ares__buf_consume_line(buf, ARES_TRUE);\n      continue;\n    }\n\n    /* Append the successful entry to the hosts file */\n    status = ares__hosts_file_add(hf, entry);\n    entry  = NULL; /* is always invalidated by this function, even on error */\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    /* Go to next line */\n    ares__buf_consume_line(buf, ARES_TRUE);\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  ares__hosts_entry_destroy(entry);\n  ares__buf_destroy(buf);\n  if (status != ARES_SUCCESS) {\n    ares__hosts_file_destroy(hf);\n  } else {\n    *out = hf;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              502,
              0
            ],
            [
              592,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__parse_hosts",
            "parameters": {
              "filename": "char",
              "out": "ares_hosts_file_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares__hosts_expired(const char              *filename,\n                                       const ares_hosts_file_t *hf)\n{\n  time_t mod_ts = 0;\n\n#ifdef HAVE_STAT\n  struct stat st;\n  if (stat(filename, &st) == 0) {\n    mod_ts = st.st_mtime;\n  }\n#elif defined(_WIN32)\n  struct _stat st;\n  if (_stat(filename, &st) == 0) {\n    mod_ts = st.st_mtime;\n  }\n#else\n  (void)filename;\n#endif\n\n  if (hf == NULL) {\n    return ARES_TRUE;\n  }\n\n  /* Expire every 60s if we can't get a time */\n  if (mod_ts == 0) {\n    mod_ts = time(NULL) - 60;\n  }\n\n  /* If filenames are different, its expired */\n  if (strcasecmp(hf->filename, filename) != 0) {\n    return ARES_TRUE;\n  }\n\n  if (hf->ts <= mod_ts) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              594,
              0
            ],
            [
              632,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_expired",
            "parameters": {
              "filename": "char",
              "hf": "ares_hosts_file_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__hosts_path(const ares_channel_t *channel,\n                                      ares_bool_t use_env, char **path)\n{\n  char *path_hosts = NULL;\n\n  *path = NULL;\n\n  if (channel->hosts_path) {\n    path_hosts = ares_strdup(channel->hosts_path);\n    if (!path_hosts) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  if (use_env) {\n    if (path_hosts) {\n      ares_free(path_hosts);\n    }\n\n    path_hosts = ares_strdup(getenv(\"CARES_HOSTS\"));\n    if (!path_hosts) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  if (!path_hosts) {\n#ifdef WIN32\n    char  PATH_HOSTS[MAX_PATH] = \"\";\n    char  tmp[MAX_PATH];\n    HKEY  hkeyHosts;\n    DWORD dwLength = sizeof(tmp);\n    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY, 0, KEY_READ,\n                      &hkeyHosts) != ERROR_SUCCESS) {\n      return ARES_ENOTFOUND;\n    }\n    RegQueryValueExA(hkeyHosts, DATABASEPATH, NULL, NULL, (LPBYTE)tmp,\n                     &dwLength);\n    ExpandEnvironmentStringsA(tmp, PATH_HOSTS, MAX_PATH);\n    RegCloseKey(hkeyHosts);\n    strcat(PATH_HOSTS, WIN_PATH_HOSTS);\n#elif defined(WATT32)\n    const char *PATH_HOSTS = _w32_GetHostsFile();\n\n    if (!PATH_HOSTS) {\n      return ARES_ENOTFOUND;\n    }\n#endif\n    path_hosts = ares_strdup(PATH_HOSTS);\n    if (!path_hosts) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  *path = path_hosts;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              634,
              0
            ],
            [
              689,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_path",
            "parameters": {
              "channel": "ares_channel_t",
              "use_env": "ares_bool_t",
              "path": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__hosts_update(ares_channel_t *channel,\n                                        ares_bool_t     use_env)\n{\n  ares_status_t status;\n  char         *filename = NULL;\n\n  status = ares__hosts_path(channel, use_env, &filename);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  if (!ares__hosts_expired(filename, channel->hf)) {\n    ares_free(filename);\n    return ARES_SUCCESS;\n  }\n\n  ares__hosts_file_destroy(channel->hf);\n  channel->hf = NULL;\n\n  status = ares__parse_hosts(filename, &channel->hf);\n  ares_free(filename);\n  return status;\n}",
          "fn_code_pos": [
            [
              691,
              0
            ],
            [
              713,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_update",
            "parameters": {
              "channel": "ares_channel_t",
              "use_env": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__hosts_search_ipaddr(ares_channel_t *channel,\n                                        ares_bool_t use_env, const char *ipaddr,\n                                        const ares_hosts_entry_t **entry)\n{\n  ares_status_t status;\n  char          addr[INET6_ADDRSTRLEN];\n\n  *entry = NULL;\n\n  status = ares__hosts_update(channel, use_env);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  if (channel->hf == NULL) {\n    return ARES_ENOTFOUND;\n  }\n\n  if (!ares__normalize_ipaddr(ipaddr, addr, sizeof(addr))) {\n    return ARES_EBADNAME;\n  }\n\n  *entry = ares__htable_strvp_get_direct(channel->hf->iphash, addr);\n  if (*entry == NULL) {\n    return ARES_ENOTFOUND;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              715,
              0
            ],
            [
              743,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_search_ipaddr",
            "parameters": {
              "channel": "ares_channel_t",
              "use_env": "ares_bool_t",
              "ipaddr": "char",
              "entry": "ares_hosts_entry_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__hosts_search_host(ares_channel_t *channel,\n                                      ares_bool_t use_env, const char *host,\n                                      const ares_hosts_entry_t **entry)\n{\n  ares_status_t status;\n\n  *entry = NULL;\n\n  status = ares__hosts_update(channel, use_env);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  if (channel->hf == NULL) {\n    return ARES_ENOTFOUND;\n  }\n\n  *entry = ares__htable_strvp_get_direct(channel->hf->hosthash, host);\n  if (*entry == NULL) {\n    return ARES_ENOTFOUND;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              745,
              0
            ],
            [
              768,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_search_host",
            "parameters": {
              "channel": "ares_channel_t",
              "use_env": "ares_bool_t",
              "host": "char",
              "entry": "ares_hosts_entry_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__hosts_entry_to_hostent(const ares_hosts_entry_t *entry,\n                                           int family, struct hostent **hostent)\n{\n  ares_status_t       status;\n  size_t              naliases;\n  ares__llist_node_t *node;\n  size_t              idx;\n\n  *hostent = ares_malloc_zero(sizeof(**hostent));\n  if (*hostent == NULL) {\n    status = ARES_ENOMEM;\n    goto fail;\n  }\n\n  (*hostent)->h_addrtype = (HOSTENT_ADDRTYPE_TYPE)family;\n\n  /* Copy IP addresses that match the address family */\n  idx = 0;\n  for (node = ares__llist_node_first(entry->ips); node != NULL;\n       node = ares__llist_node_next(node)) {\n    struct ares_addr addr;\n    const void      *ptr     = NULL;\n    size_t           ptr_len = 0;\n    const char      *ipaddr  = ares__llist_node_val(node);\n    char           **temp    = NULL;\n\n    memset(&addr, 0, sizeof(addr));\n\n    addr.family = family;\n    ptr         = ares_dns_pton(ipaddr, &addr, &ptr_len);\n    if (ptr == NULL) {\n      continue;\n    }\n\n    /* If family == AF_UNSPEC, then we want to inherit this for future\n     * conversions as we can only support a single address class */\n    if (family == AF_UNSPEC) {\n      family                 = addr.family;\n      (*hostent)->h_addrtype = (HOSTENT_ADDRTYPE_TYPE)addr.family;\n    }\n\n    temp = ares_realloc_zero((*hostent)->h_addr_list,\n                             (idx + 1) * sizeof(*(*hostent)->h_addr_list),\n                             (idx + 2) * sizeof(*(*hostent)->h_addr_list));\n    if (temp == NULL) {\n      status = ARES_ENOMEM;\n      goto fail;\n    }\n\n    (*hostent)->h_addr_list = temp;\n\n    (*hostent)->h_addr_list[idx] = ares_malloc(ptr_len);\n    if ((*hostent)->h_addr_list[idx] == NULL) {\n      status = ARES_ENOMEM;\n      goto fail;\n    }\n\n    memcpy((*hostent)->h_addr_list[idx], ptr, ptr_len);\n    idx++;\n    (*hostent)->h_length = (HOSTENT_LENGTH_TYPE)ptr_len;\n  }\n\n  /* entry didn't match address class */\n  if (idx == 0) {\n    status = ARES_ENOTFOUND;\n    goto fail;\n  }\n\n  /* Copy main hostname */\n  (*hostent)->h_name = ares_strdup(ares__llist_first_val(entry->hosts));\n  if ((*hostent)->h_name == NULL) {\n    status = ARES_ENOMEM;\n    goto fail;\n  }\n\n  /* Copy aliases */\n  naliases = ares__llist_len(entry->hosts) - 1;\n\n  /* Cap at 100, some people use https://github.com/StevenBlack/hosts and we\n   * don't need 200k+ aliases */\n  if (naliases > 100) {\n    naliases = 100;\n  }\n\n  (*hostent)->h_aliases =\n    ares_malloc_zero((naliases + 1) * sizeof(*(*hostent)->h_aliases));\n  if ((*hostent)->h_aliases == NULL) {\n    status = ARES_ENOMEM;\n    goto fail;\n  }\n\n  /* Copy all entries to the alias except the first */\n  idx  = 0;\n  node = ares__llist_node_first(entry->hosts);\n  node = ares__llist_node_next(node);\n  while (node != NULL) {\n    (*hostent)->h_aliases[idx] = ares_strdup(ares__llist_node_val(node));\n    if ((*hostent)->h_aliases[idx] == NULL) {\n      status = ARES_ENOMEM;\n      goto fail;\n    }\n    idx++;\n\n    /* Break out if artificially capped */\n    if (idx == naliases) {\n      break;\n    }\n    node = ares__llist_node_next(node);\n  }\n\n  return ARES_SUCCESS;\n\nfail:\n  ares_free_hostent(*hostent);\n  *hostent = NULL;\n  return status;\n}",
          "fn_code_pos": [
            [
              770,
              0
            ],
            [
              886,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_entry_to_hostent",
            "parameters": {
              "entry": "ares_hosts_entry_t",
              "family": "int",
              "hostent": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t\n  ares__hosts_ai_append_cnames(const ares_hosts_entry_t    *entry,\n                               struct ares_addrinfo_cname **cnames_out)\n{\n  struct ares_addrinfo_cname *cname  = NULL;\n  struct ares_addrinfo_cname *cnames = NULL;\n  const char                 *primaryhost;\n  ares__llist_node_t         *node;\n  ares_status_t               status;\n  size_t                      cnt = 0;\n\n  node        = ares__llist_node_first(entry->hosts);\n  primaryhost = ares__llist_node_val(node);\n  /* Skip to next node to start with aliases */\n  node = ares__llist_node_next(node);\n\n  while (node != NULL) {\n    const char *host = ares__llist_node_val(node);\n\n    /* Cap at 100 entries. , some people use\n     * https://github.com/StevenBlack/hosts and we don't need 200k+ aliases */\n    cnt++;\n    if (cnt > 100) {\n      break;\n    }\n\n    cname = ares__append_addrinfo_cname(&cnames);\n    if (cname == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n\n    cname->alias = ares_strdup(host);\n    if (cname->alias == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n\n    cname->name = ares_strdup(primaryhost);\n    if (cname->name == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n\n    node = ares__llist_node_next(node);\n  }\n\n  /* No entries, add only primary */\n  if (cnames == NULL) {\n    cname = ares__append_addrinfo_cname(&cnames);\n    if (cname == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n\n    cname->name = ares_strdup(primaryhost);\n    if (cname->name == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n  }\n  status = ARES_SUCCESS;\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares__freeaddrinfo_cnames(cnames);\n    return status;\n  }\n\n  *cnames_out = cnames;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              888,
              0
            ],
            [
              959,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_ai_append_cnames",
            "parameters": {
              "entry": "ares_hosts_entry_t",
              "cnames_out": "struct ares_addrinfo_cname"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__hosts_entry_to_addrinfo(const ares_hosts_entry_t *entry,\n                                            const char *name, int family,\n                                            unsigned short        port,\n                                            ares_bool_t           want_cnames,\n                                            struct ares_addrinfo *ai)\n{\n  ares_status_t               status;\n  struct ares_addrinfo_cname *cnames  = NULL;\n  struct ares_addrinfo_node  *ainodes = NULL;\n  ares__llist_node_t         *node;\n\n  switch (family) {\n    case AF_INET:\n    case AF_INET6:\n    case AF_UNSPEC:\n      break;\n    default:\n      return ARES_EBADFAMILY;\n  }\n\n  ai->name = ares_strdup(name);\n  if (ai->name == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  for (node = ares__llist_node_first(entry->ips); node != NULL;\n       node = ares__llist_node_next(node)) {\n    struct ares_addr addr;\n    const void      *ptr     = NULL;\n    size_t           ptr_len = 0;\n    const char      *ipaddr  = ares__llist_node_val(node);\n\n    memset(&addr, 0, sizeof(addr));\n    addr.family = family;\n    ptr         = ares_dns_pton(ipaddr, &addr, &ptr_len);\n\n    if (ptr == NULL) {\n      continue;\n    }\n\n    status = ares_append_ai_node(addr.family, port, 0, ptr, &ainodes);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\n  if (want_cnames) {\n    status = ares__hosts_ai_append_cnames(entry, &cnames);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares__freeaddrinfo_cnames(cnames);\n    ares__freeaddrinfo_nodes(ainodes);\n    ares_free(ai->name);\n    ai->name = NULL;\n    return status;\n  }\n  ares__addrinfo_cat_cnames(&ai->cnames, cnames);\n  ares__addrinfo_cat_nodes(&ai->nodes, ainodes);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              961,
              0
            ],
            [
              1029,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_entry_to_addrinfo",
            "parameters": {
              "entry": "ares_hosts_entry_t",
              "name": "char",
              "family": "int",
              "port": "unsigned short",
              "want_cnames": "ares_bool_t",
              "ai": "struct ares_addrinfo"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_dns_pton(const char *ipaddr, struct ares_addr *addr,\n                          size_t *out_len)",
          "fn_dec_pos": [
            [
              100,
              12
            ],
            [
              101,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_pton",
            "parameters": {
              "ipaddr": "char",
              "addr": "struct ares_addr",
              "out_len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__hosts_file_create(const char *filename)",
          "fn_dec_pos": [
            [
              195,
              26
            ],
            [
              195,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_file_create",
            "parameters": {
              "filename": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_hosts_file {\n  time_t                ts;\n  /*! cache the filename so we know if the filename changes it automatically\n   *  invalidates the cache */\n  char                 *filename;\n  /*! iphash is the owner of the 'entry' object as there is only ever a single\n   *  match to the object. */\n  ares__htable_strvp_t *iphash;\n  /*! hosthash does not own the entry so won't free on destruction */\n  ares__htable_strvp_t *hosthash;\n}",
          {
            "ts": "time_t",
            "*filename": "char",
            "*iphash": "ares__htable_strvp_t",
            "*hosthash": "ares__htable_strvp_t"
          },
          "ares_hosts_file",
          [
            81,
            0
          ],
          [
            91,
            1
          ]
        ],
        [
          "struct ares_hosts_entry {\n  size_t         refcnt; /*! If the entry is stored multiple times in the\n                          *  ip address hash, we have to reference count it */\n  ares__llist_t *ips;\n  ares__llist_t *hosts;\n}",
          {
            "refcnt": "size_t",
            "*ips": "ares__llist_t",
            "*hosts": "ares__llist_t"
          },
          "ares_hosts_entry",
          [
            93,
            0
          ],
          [
            98,
            1
          ]
        ],
        [
          "struct ares_hosts_file {\n  time_t                ts;\n  /*! cache the filename so we know if the filename changes it automatically\n   *  invalidates the cache */\n  char                 *filename;\n  /*! iphash is the owner of the 'entry' object as there is only ever a single\n   *  match to the object. */\n  ares__htable_strvp_t *iphash;\n  /*! hosthash does not own the entry so won't free on destruction */\n  ares__htable_strvp_t *hosthash;\n}",
          {
            "ts": "time_t",
            "*filename": "char",
            "*iphash": "ares__htable_strvp_t",
            "*hosthash": "ares__htable_strvp_t"
          },
          "ares_hosts_file",
          [
            81,
            0
          ],
          [
            91,
            1
          ]
        ],
        [
          "struct ares_hosts_entry {\n  size_t         refcnt; /*! If the entry is stored multiple times in the\n                          *  ip address hash, we have to reference count it */\n  ares__llist_t *ips;\n  ares__llist_t *hosts;\n}",
          {
            "refcnt": "size_t",
            "*ips": "ares__llist_t",
            "*hosts": "ares__llist_t"
          },
          "ares_hosts_entry",
          [
            93,
            0
          ],
          [
            98,
            1
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            100,
            46
          ],
          [
            100,
            62
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            139,
            2
          ],
          [
            139,
            18
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            600,
            2
          ],
          [
            600,
            13
          ]
        ],
        [
          "struct _stat",
          {},
          "",
          [
            605,
            2
          ],
          [
            605,
            14
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            771,
            55
          ],
          [
            771,
            69
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            790,
            4
          ],
          [
            790,
            20
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            890,
            31
          ],
          [
            890,
            57
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            892,
            2
          ],
          [
            892,
            28
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            893,
            2
          ],
          [
            893,
            28
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            965,
            44
          ],
          [
            965,
            64
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            968,
            2
          ],
          [
            968,
            28
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            969,
            2
          ],
          [
            969,
            27
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            989,
            4
          ],
          [
            989,
            20
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <sys/types.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#  include <sys/stat.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <time.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include \"ares_platform.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  ARES_MATCH_NONE   = 0,\n  ARES_MATCH_IPADDR = 1,\n  ARES_MATCH_HOST   = 2\n} ares_hosts_file_match_t;",
          {
            "ARES_MATCH_NONE": "",
            "ARES_MATCH_IPADDR": "",
            "ARES_MATCH_HOST": ""
          },
          "ares_hosts_file_match_t",
          [
            226,
            0
          ],
          [
            230,
            26
          ]
        ]
      ]
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_android.c": {
      "fn_def_list": [
        {
          "fn_code": "static jclass    jni_get_class(JNIEnv *env, const char *path)\n{\n  jclass cls = NULL;\n\n  if (env == NULL || path == NULL || *path == '\\0') {\n    return NULL;\n  }\n\n  cls = (*env)->FindClass(env, path);\n  if ((*env)->ExceptionOccurred(env)) {\n    (*env)->ExceptionClear(env);\n    return NULL;\n  }\n  return cls;\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              66,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jni_get_class",
            "parameters": {
              "env": "JNIEnv",
              "path": "char"
            },
            "return_type": "jclass"
          }
        },
        {
          "fn_code": "static jmethodID jni_get_method_id(JNIEnv *env, jclass cls,\n                                   const char *func_name, const char *signature)\n{\n  jmethodID mid = NULL;\n\n  if (env == NULL || cls == NULL || func_name == NULL || *func_name == '\\0' ||\n      signature == NULL || *signature == '\\0') {\n    return NULL;\n  }\n\n  mid = (*env)->GetMethodID(env, cls, func_name, signature);\n  if ((*env)->ExceptionOccurred(env)) {\n    (*env)->ExceptionClear(env);\n    return NULL;\n  }\n\n  return mid;\n}",
          "fn_code_pos": [
            [
              68,
              0
            ],
            [
              85,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jni_get_method_id",
            "parameters": {
              "env": "JNIEnv",
              "cls": "jclass",
              "func_name": "char",
              "signature": "char"
            },
            "return_type": "jmethodID"
          }
        },
        {
          "fn_code": "void ares_library_init_jvm(JavaVM *jvm)\n{\n  android_jvm = jvm;\n}",
          "fn_code_pos": [
            [
              87,
              0
            ],
            [
              90,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_init_jvm",
            "parameters": {
              "jvm": "JavaVM"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int ares_library_init_android(jobject connectivity_manager)\n{\n  JNIEnv       *env          = NULL;\n  int           need_detatch = 0;\n  int           res;\n  ares_status_t ret     = ARES_ENOTINITIALIZED;\n  jclass        obj_cls = NULL;\n\n  if (android_jvm == NULL) {\n    goto cleanup;\n  }\n\n  res = (*android_jvm)->GetEnv(android_jvm, (void **)&env, JNI_VERSION_1_6);\n  if (res == JNI_EDETACHED) {\n    env          = NULL;\n    res          = (*android_jvm)->AttachCurrentThread(android_jvm, &env, NULL);\n    need_detatch = 1;\n  }\n  if (res != JNI_OK || env == NULL) {\n    goto cleanup;\n  }\n\n  android_connectivity_manager =\n    (*env)->NewGlobalRef(env, connectivity_manager);\n  if (android_connectivity_manager == NULL) {\n    goto cleanup;\n  }\n\n  /* Initialization has succeeded. Now attempt to cache the methods that will be\n   * called by ares_get_android_server_list. */\n  ret = ARES_SUCCESS;\n\n  /* ConnectivityManager in API 1. */\n  obj_cls = jni_get_class(env, \"android/net/ConnectivityManager\");\n  if (obj_cls == NULL) {\n    goto cleanup;\n  }\n\n  /* ConnectivityManager.getActiveNetwork in API 23. */\n  android_cm_active_net_mid = jni_get_method_id(\n    env, obj_cls, \"getActiveNetwork\", \"()Landroid/net/Network;\");\n  if (android_cm_active_net_mid == NULL) {\n    goto cleanup;\n  }\n\n  /* ConnectivityManager.getLinkProperties in API 21. */\n  android_cm_link_props_mid =\n    jni_get_method_id(env, obj_cls, \"getLinkProperties\",\n                      \"(Landroid/net/Network;)Landroid/net/LinkProperties;\");\n  if (android_cm_link_props_mid == NULL) {\n    goto cleanup;\n  }\n\n  /* LinkProperties in API 21. */\n  (*env)->DeleteLocalRef(env, obj_cls);\n  obj_cls = jni_get_class(env, \"android/net/LinkProperties\");\n  if (obj_cls == NULL) {\n    goto cleanup;\n  }\n\n  /* getDnsServers in API 21. */\n  android_lp_dns_servers_mid =\n    jni_get_method_id(env, obj_cls, \"getDnsServers\", \"()Ljava/util/List;\");\n  if (android_lp_dns_servers_mid == NULL) {\n    goto cleanup;\n  }\n\n  /* getDomains in API 21. */\n  android_lp_domains_mid =\n    jni_get_method_id(env, obj_cls, \"getDomains\", \"()Ljava/lang/String;\");\n  if (android_lp_domains_mid == NULL) {\n    goto cleanup;\n  }\n\n  (*env)->DeleteLocalRef(env, obj_cls);\n  obj_cls = jni_get_class(env, \"java/util/List\");\n  if (obj_cls == NULL) {\n    goto cleanup;\n  }\n\n  android_list_size_mid = jni_get_method_id(env, obj_cls, \"size\", \"()I\");\n  if (android_list_size_mid == NULL) {\n    goto cleanup;\n  }\n\n  android_list_get_mid =\n    jni_get_method_id(env, obj_cls, \"get\", \"(I)Ljava/lang/Object;\");\n  if (android_list_get_mid == NULL) {\n    goto cleanup;\n  }\n\n  (*env)->DeleteLocalRef(env, obj_cls);\n  obj_cls = jni_get_class(env, \"java/net/InetAddress\");\n  if (obj_cls == NULL) {\n    goto cleanup;\n  }\n\n  android_ia_host_addr_mid =\n    jni_get_method_id(env, obj_cls, \"getHostAddress\", \"()Ljava/lang/String;\");\n  if (android_ia_host_addr_mid == NULL) {\n    goto cleanup;\n  }\n\n  (*env)->DeleteLocalRef(env, obj_cls);\n  goto done;\n\ncleanup:\n  if (obj_cls != NULL) {\n    (*env)->DeleteLocalRef(env, obj_cls);\n  }\n\n  android_cm_active_net_mid  = NULL;\n  android_cm_link_props_mid  = NULL;\n  android_lp_dns_servers_mid = NULL;\n  android_lp_domains_mid     = NULL;\n  android_list_size_mid      = NULL;\n  android_list_get_mid       = NULL;\n  android_ia_host_addr_mid   = NULL;\n\ndone:\n  if (need_detatch) {\n    (*android_jvm)->DetachCurrentThread(android_jvm);\n  }\n\n  return ret;\n}",
          "fn_code_pos": [
            [
              92,
              0
            ],
            [
              217,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_init_android",
            "parameters": {
              "connectivity_manager": "jobject"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_library_android_initialized(void)\n{\n  if (android_jvm == NULL || android_connectivity_manager == NULL) {\n    return ARES_ENOTINITIALIZED;\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              219,
              0
            ],
            [
              225,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_android_initialized",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "void ares_library_cleanup_android(void)\n{\n  JNIEnv *env          = NULL;\n  int     need_detatch = 0;\n  int     res;\n\n  if (android_jvm == NULL || android_connectivity_manager == NULL) {\n    return;\n  }\n\n  res = (*android_jvm)->GetEnv(android_jvm, (void **)&env, JNI_VERSION_1_6);\n  if (res == JNI_EDETACHED) {\n    env          = NULL;\n    res          = (*android_jvm)->AttachCurrentThread(android_jvm, &env, NULL);\n    need_detatch = 1;\n  }\n  if (res != JNI_OK || env == NULL) {\n    return;\n  }\n\n  android_cm_active_net_mid  = NULL;\n  android_cm_link_props_mid  = NULL;\n  android_lp_dns_servers_mid = NULL;\n  android_lp_domains_mid     = NULL;\n  android_list_size_mid      = NULL;\n  android_list_get_mid       = NULL;\n  android_ia_host_addr_mid   = NULL;\n\n  (*env)->DeleteGlobalRef(env, android_connectivity_manager);\n  android_connectivity_manager = NULL;\n\n  if (need_detatch) {\n    (*android_jvm)->DetachCurrentThread(android_jvm);\n  }\n}",
          "fn_code_pos": [
            [
              227,
              0
            ],
            [
              261,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_cleanup_android",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "char **ares_get_android_server_list(size_t max_servers, size_t *num_servers)\n{\n  JNIEnv     *env             = NULL;\n  jobject     active_network  = NULL;\n  jobject     link_properties = NULL;\n  jobject     server_list     = NULL;\n  jobject     server          = NULL;\n  jstring     str             = NULL;\n  jint        nserv;\n  const char *ch_server_address;\n  int         res;\n  size_t      i;\n  char      **dns_list     = NULL;\n  int         need_detatch = 0;\n\n  if (android_jvm == NULL || android_connectivity_manager == NULL ||\n      max_servers == 0 || num_servers == NULL) {\n    return NULL;\n  }\n\n  if (android_cm_active_net_mid == NULL || android_cm_link_props_mid == NULL ||\n      android_lp_dns_servers_mid == NULL || android_list_size_mid == NULL ||\n      android_list_get_mid == NULL || android_ia_host_addr_mid == NULL) {\n    return NULL;\n  }\n\n  res = (*android_jvm)->GetEnv(android_jvm, (void **)&env, JNI_VERSION_1_6);\n  if (res == JNI_EDETACHED) {\n    env          = NULL;\n    res          = (*android_jvm)->AttachCurrentThread(android_jvm, &env, NULL);\n    need_detatch = 1;\n  }\n  if (res != JNI_OK || env == NULL) {\n    goto done;\n  }\n\n  /* JNI below is equivalent to this Java code.\n     import android.content.Context;\n     import android.net.ConnectivityManager;\n     import android.net.LinkProperties;\n     import android.net.Network;\n     import java.net.InetAddress;\n     import java.util.List;\n\n     ConnectivityManager cm = (ConnectivityManager)this.getApplicationContext()\n       .getSystemService(Context.CONNECTIVITY_SERVICE);\n     Network an = cm.getActiveNetwork();\n     LinkProperties lp = cm.getLinkProperties(an);\n     List<InetAddress> dns = lp.getDnsServers();\n     for (InetAddress ia: dns) {\n       String ha = ia.getHostAddress();\n     }\n\n     Note: The JNI ConnectivityManager object and all method IDs were previously\n           initialized in ares_library_init_android.\n   */\n\n  active_network = (*env)->CallObjectMethod(env, android_connectivity_manager,\n                                            android_cm_active_net_mid);\n  if (active_network == NULL) {\n    goto done;\n  }\n\n  link_properties =\n    (*env)->CallObjectMethod(env, android_connectivity_manager,\n                             android_cm_link_props_mid, active_network);\n  if (link_properties == NULL) {\n    goto done;\n  }\n\n  server_list =\n    (*env)->CallObjectMethod(env, link_properties, android_lp_dns_servers_mid);\n  if (server_list == NULL) {\n    goto done;\n  }\n\n  nserv = (*env)->CallIntMethod(env, server_list, android_list_size_mid);\n  if (nserv > (jint)max_servers) {\n    nserv = (jint)max_servers;\n  }\n  if (nserv <= 0) {\n    goto done;\n  }\n  *num_servers = (size_t)nserv;\n\n  dns_list = ares_malloc(sizeof(*dns_list) * (*num_servers));\n  for (i = 0; i < *num_servers; i++) {\n    size_t len = 64;\n    server =\n      (*env)->CallObjectMethod(env, server_list, android_list_get_mid, (jint)i);\n    dns_list[i]    = ares_malloc(len);\n    dns_list[i][0] = 0;\n    if (server == NULL) {\n      continue;\n    }\n    str = (*env)->CallObjectMethod(env, server, android_ia_host_addr_mid);\n    ch_server_address = (*env)->GetStringUTFChars(env, str, 0);\n    ares_strcpy(dns_list[i], ch_server_address, len);\n    (*env)->ReleaseStringUTFChars(env, str, ch_server_address);\n    (*env)->DeleteLocalRef(env, str);\n    (*env)->DeleteLocalRef(env, server);\n  }\n\ndone:\n  if ((*env)->ExceptionOccurred(env)) {\n    (*env)->ExceptionClear(env);\n  }\n\n  if (server_list != NULL) {\n    (*env)->DeleteLocalRef(env, server_list);\n  }\n  if (link_properties != NULL) {\n    (*env)->DeleteLocalRef(env, link_properties);\n  }\n  if (active_network != NULL) {\n    (*env)->DeleteLocalRef(env, active_network);\n  }\n\n  if (need_detatch) {\n    (*android_jvm)->DetachCurrentThread(android_jvm);\n  }\n  return dns_list;\n}",
          "fn_code_pos": [
            [
              263,
              0
            ],
            [
              385,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "char *ares_get_android_search_domains_list(void)\n{\n  JNIEnv     *env             = NULL;\n  jobject     active_network  = NULL;\n  jobject     link_properties = NULL;\n  jstring     domains         = NULL;\n  const char *domain;\n  int         res;\n  char       *domain_list  = NULL;\n  int         need_detatch = 0;\n\n  if (android_jvm == NULL || android_connectivity_manager == NULL) {\n    return NULL;\n  }\n\n  if (android_cm_active_net_mid == NULL || android_cm_link_props_mid == NULL ||\n      android_lp_domains_mid == NULL) {\n    return NULL;\n  }\n\n  res = (*android_jvm)->GetEnv(android_jvm, (void **)&env, JNI_VERSION_1_6);\n  if (res == JNI_EDETACHED) {\n    env          = NULL;\n    res          = (*android_jvm)->AttachCurrentThread(android_jvm, &env, NULL);\n    need_detatch = 1;\n  }\n  if (res != JNI_OK || env == NULL) {\n    goto done;\n  }\n\n  /* JNI below is equivalent to this Java code.\n     import android.content.Context;\n     import android.net.ConnectivityManager;\n     import android.net.LinkProperties;\n\n     ConnectivityManager cm = (ConnectivityManager)this.getApplicationContext()\n       .getSystemService(Context.CONNECTIVITY_SERVICE);\n     Network an = cm.getActiveNetwork();\n     LinkProperties lp = cm.getLinkProperties(an);\n   String domains = lp.getDomains();\n     for (String domain: domains.split(\",\")) {\n       String d = domain;\n     }\n\n     Note: The JNI ConnectivityManager object and all method IDs were previously\n           initialized in ares_library_init_android.\n   */\n\n  active_network = (*env)->CallObjectMethod(env, android_connectivity_manager,\n                                            android_cm_active_net_mid);\n  if (active_network == NULL) {\n    goto done;\n  }\n\n  link_properties =\n    (*env)->CallObjectMethod(env, android_connectivity_manager,\n                             android_cm_link_props_mid, active_network);\n  if (link_properties == NULL) {\n    goto done;\n  }\n\n  /* Get the domains. It is a common separated list of domains to search. */\n  domains =\n    (*env)->CallObjectMethod(env, link_properties, android_lp_domains_mid);\n  if (domains == NULL) {\n    goto done;\n  }\n\n  /* Split on , */\n  domain      = (*env)->GetStringUTFChars(env, domains, 0);\n  domain_list = ares_strdup(domain);\n  (*env)->ReleaseStringUTFChars(env, domains, domain);\n  (*env)->DeleteLocalRef(env, domains);\n\ndone:\n  if ((*env)->ExceptionOccurred(env)) {\n    (*env)->ExceptionClear(env);\n  }\n\n  if (link_properties != NULL) {\n    (*env)->DeleteLocalRef(env, link_properties);\n  }\n  if (active_network != NULL) {\n    (*env)->DeleteLocalRef(env, active_network);\n  }\n\n  if (need_detatch) {\n    (*android_jvm)->DetachCurrentThread(android_jvm);\n  }\n  return domain_list;\n}",
          "fn_code_pos": [
            [
              387,
              0
            ],
            [
              477,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_android_search_domains_list",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_get_android_server_list(size_t max_servers, size_t *num_servers)",
          "fn_dec_pos": [
            [
              263,
              7
            ],
            [
              263,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_android_server_list",
            "parameters": {
              "max_servers": "size_t",
              "num_servers": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_get_android_search_domains_list(void)",
          "fn_dec_pos": [
            [
              387,
              6
            ],
            [
              387,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_android_search_domains_list",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#  include <jni.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include \"ares_setup.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#  include \"ares.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include \"ares_android.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#  include \"ares_private.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/windows_port.c": {
      "fn_def_list": [
        {
          "fn_code": "BOOL WINAPI DllMain(HINSTANCE hnd, DWORD reason, LPVOID reserved)\n{\n  (void)hnd;\n  (void)reason;\n  (void)reserved;\n  return (TRUE);\n}",
          "fn_code_pos": [
            [
              19,
              0
            ],
            [
              25,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DllMain",
            "parameters": {
              "hnd": "HINSTANCE",
              "reason": "DWORD",
              "reserved": "LPVOID"
            },
            "return_type": "BOOL"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            8,
            0
          ],
          [
            9,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__sortaddrinfo.c": {
      "fn_def_list": [
        {
          "fn_code": "static int get_scope(const struct sockaddr *addr)\n{\n  if (addr->sa_family == AF_INET6) {\n    const struct sockaddr_in6 *addr6 =\n      CARES_INADDR_CAST(const struct sockaddr_in6 *, addr);\n    if (IN6_IS_ADDR_MULTICAST(&addr6->sin6_addr)) {\n      return ARES_IPV6_ADDR_MC_SCOPE(&addr6->sin6_addr);\n    } else if (IN6_IS_ADDR_LOOPBACK(&addr6->sin6_addr) ||\n               IN6_IS_ADDR_LINKLOCAL(&addr6->sin6_addr)) {\n      /*\n       * RFC 4291 section 2.5.3 says loopback is to be treated as having\n       * link-local scope.\n       */\n      return ARES_IPV6_ADDR_SCOPE_LINKLOCAL;\n    } else if (IN6_IS_ADDR_SITELOCAL(&addr6->sin6_addr)) {\n      return ARES_IPV6_ADDR_SCOPE_SITELOCAL;\n    } else {\n      return ARES_IPV6_ADDR_SCOPE_GLOBAL;\n    }\n  } else if (addr->sa_family == AF_INET) {\n    const struct sockaddr_in *addr4 =\n      CARES_INADDR_CAST(const struct sockaddr_in *, addr);\n    unsigned long int na = ntohl(addr4->sin_addr.s_addr);\n    if (ARES_IN_LOOPBACK(na) ||          /* 127.0.0.0/8 */\n        (na & 0xffff0000) == 0xa9fe0000) /* 169.254.0.0/16 */\n    {\n      return ARES_IPV6_ADDR_SCOPE_LINKLOCAL;\n    } else {\n      /*\n       * RFC 6724 section 3.2. Other IPv4 addresses, including private\n       * addresses and shared addresses (100.64.0.0/10), are assigned global\n       * scope.\n       */\n      return ARES_IPV6_ADDR_SCOPE_GLOBAL;\n    }\n  } else {\n    /*\n     * This should never happen.\n     * Return a scope with low priority as a last resort.\n     */\n    return ARES_IPV6_ADDR_SCOPE_NODELOCAL;\n  }\n}",
          "fn_code_pos": [
            [
              90,
              0
            ],
            [
              132,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_scope",
            "parameters": {
              "addr": "struct sockaddr"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int get_label(const struct sockaddr *addr)\n{\n  if (addr->sa_family == AF_INET) {\n    return 4;\n  } else if (addr->sa_family == AF_INET6) {\n    const struct sockaddr_in6 *addr6 =\n      CARES_INADDR_CAST(const struct sockaddr_in6 *, addr);\n    if (IN6_IS_ADDR_LOOPBACK(&addr6->sin6_addr)) {\n      return 0;\n    } else if (IN6_IS_ADDR_V4MAPPED(&addr6->sin6_addr)) {\n      return 4;\n    } else if (ARES_IN6_IS_ADDR_6TO4(&addr6->sin6_addr)) {\n      return 2;\n    } else if (ARES_IN6_IS_ADDR_TEREDO(&addr6->sin6_addr)) {\n      return 5;\n    } else if (ARES_IN6_IS_ADDR_ULA(&addr6->sin6_addr)) {\n      return 13;\n    } else if (IN6_IS_ADDR_V4COMPAT(&addr6->sin6_addr)) {\n      return 3;\n    } else if (IN6_IS_ADDR_SITELOCAL(&addr6->sin6_addr)) {\n      return 11;\n    } else if (ARES_IN6_IS_ADDR_6BONE(&addr6->sin6_addr)) {\n      return 12;\n    } else {\n      /* All other IPv6 addresses, including global unicast addresses. */\n      return 1;\n    }\n  } else {\n    /*\n     * This should never happen.\n     * Return a semi-random label as a last resort.\n     */\n    return 1;\n  }\n}",
          "fn_code_pos": [
            [
              134,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_label",
            "parameters": {
              "addr": "struct sockaddr"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int get_precedence(const struct sockaddr *addr)\n{\n  if (addr->sa_family == AF_INET) {\n    return 35;\n  } else if (addr->sa_family == AF_INET6) {\n    const struct sockaddr_in6 *addr6 =\n      CARES_INADDR_CAST(const struct sockaddr_in6 *, addr);\n    if (IN6_IS_ADDR_LOOPBACK(&addr6->sin6_addr)) {\n      return 50;\n    } else if (IN6_IS_ADDR_V4MAPPED(&addr6->sin6_addr)) {\n      return 35;\n    } else if (ARES_IN6_IS_ADDR_6TO4(&addr6->sin6_addr)) {\n      return 30;\n    } else if (ARES_IN6_IS_ADDR_TEREDO(&addr6->sin6_addr)) {\n      return 5;\n    } else if (ARES_IN6_IS_ADDR_ULA(&addr6->sin6_addr)) {\n      return 3;\n    } else if (IN6_IS_ADDR_V4COMPAT(&addr6->sin6_addr) ||\n               IN6_IS_ADDR_SITELOCAL(&addr6->sin6_addr) ||\n               ARES_IN6_IS_ADDR_6BONE(&addr6->sin6_addr)) {\n      return 1;\n    } else {\n      /* All other IPv6 addresses, including global unicast addresses. */\n      return 40;\n    }\n  } else {\n    return 1;\n  }\n}",
          "fn_code_pos": [
            [
              174,
              0
            ],
            [
              202,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_precedence",
            "parameters": {
              "addr": "struct sockaddr"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static size_t common_prefix_len(const struct in6_addr *a1,\n                                const struct in6_addr *a2)\n{\n  const unsigned char *p1 = (const unsigned char *)a1;\n  const unsigned char *p2 = (const unsigned char *)a2;\n  size_t               i;\n  for (i = 0; i < sizeof(*a1); ++i) {\n    unsigned char x;\n    size_t        j;\n    if (p1[i] == p2[i]) {\n      continue;\n    }\n    x = p1[i] ^ p2[i];\n    for (j = 0; j < CHAR_BIT; ++j) {\n      if (x & (1 << (CHAR_BIT - 1))) {\n        return i * CHAR_BIT + j;\n      }\n      x <<= 1;\n    }\n  }\n  return sizeof(*a1) * CHAR_BIT;\n}",
          "fn_code_pos": [
            [
              207,
              0
            ],
            [
              228,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "common_prefix_len",
            "parameters": {
              "a1": "struct in6_addr",
              "a2": "struct in6_addr"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static int rfc6724_compare(const void *ptr1, const void *ptr2)\n{\n  const struct addrinfo_sort_elem *a1 = (const struct addrinfo_sort_elem *)ptr1;\n  const struct addrinfo_sort_elem *a2 = (const struct addrinfo_sort_elem *)ptr2;\n  int                              scope_src1;\n  int                              scope_dst1;\n  int                              scope_match1;\n  int                              scope_src2;\n  int                              scope_dst2;\n  int                              scope_match2;\n  int                              label_src1;\n  int                              label_dst1;\n  int                              label_match1;\n  int                              label_src2;\n  int                              label_dst2;\n  int                              label_match2;\n  int                              precedence1;\n  int                              precedence2;\n  size_t                           prefixlen1;\n  size_t                           prefixlen2;\n\n  /* Rule 1: Avoid unusable destinations. */\n  if (a1->has_src_addr != a2->has_src_addr) {\n    return ((int)a2->has_src_addr) - ((int)a1->has_src_addr);\n  }\n\n  /* Rule 2: Prefer matching scope. */\n  scope_src1 = ARES_IPV6_ADDR_SCOPE_NODELOCAL;\n  if (a1->has_src_addr) {\n    scope_src1 = get_scope(&a1->src_addr.sa);\n  }\n  scope_dst1   = get_scope(a1->ai->ai_addr);\n  scope_match1 = (scope_src1 == scope_dst1);\n\n  scope_src2 = ARES_IPV6_ADDR_SCOPE_NODELOCAL;\n  if (a2->has_src_addr) {\n    scope_src2 = get_scope(&a2->src_addr.sa);\n  }\n  scope_dst2   = get_scope(a2->ai->ai_addr);\n  scope_match2 = (scope_src2 == scope_dst2);\n\n  if (scope_match1 != scope_match2) {\n    return scope_match2 - scope_match1;\n  }\n\n  /* Rule 3: Avoid deprecated addresses.  */\n\n  /* Rule 4: Prefer home addresses.  */\n\n  /* Rule 5: Prefer matching label. */\n  label_src1 = 1;\n  if (a1->has_src_addr) {\n    label_src1 = get_label(&a1->src_addr.sa);\n  }\n  label_dst1   = get_label(a1->ai->ai_addr);\n  label_match1 = (label_src1 == label_dst1);\n\n  label_src2 = 1;\n  if (a2->has_src_addr) {\n    label_src2 = get_label(&a2->src_addr.sa);\n  }\n  label_dst2   = get_label(a2->ai->ai_addr);\n  label_match2 = (label_src2 == label_dst2);\n\n  if (label_match1 != label_match2) {\n    return label_match2 - label_match1;\n  }\n\n  /* Rule 6: Prefer higher precedence. */\n  precedence1 = get_precedence(a1->ai->ai_addr);\n  precedence2 = get_precedence(a2->ai->ai_addr);\n  if (precedence1 != precedence2) {\n    return precedence2 - precedence1;\n  }\n\n  /* Rule 7: Prefer native transport.  */\n\n  /* Rule 8: Prefer smaller scope. */\n  if (scope_dst1 != scope_dst2) {\n    return scope_dst1 - scope_dst2;\n  }\n\n  /* Rule 9: Use longest matching prefix. */\n  if (a1->has_src_addr && a1->ai->ai_addr->sa_family == AF_INET6 &&\n      a2->has_src_addr && a2->ai->ai_addr->sa_family == AF_INET6) {\n    const struct sockaddr_in6 *a1_src = &a1->src_addr.sa6;\n    const struct sockaddr_in6 *a1_dst =\n      CARES_INADDR_CAST(const struct sockaddr_in6 *, a1->ai->ai_addr);\n    const struct sockaddr_in6 *a2_src = &a2->src_addr.sa6;\n    const struct sockaddr_in6 *a2_dst =\n      CARES_INADDR_CAST(const struct sockaddr_in6 *, a2->ai->ai_addr);\n    prefixlen1 = common_prefix_len(&a1_src->sin6_addr, &a1_dst->sin6_addr);\n    prefixlen2 = common_prefix_len(&a2_src->sin6_addr, &a2_dst->sin6_addr);\n    if (prefixlen1 != prefixlen2) {\n      return (int)prefixlen2 - (int)prefixlen1;\n    }\n  }\n\n  /*\n   * Rule 10: Leave the order unchanged.\n   * We need this since qsort() is not necessarily stable.\n   */\n  return ((int)a1->original_order) - ((int)a2->original_order);\n}",
          "fn_code_pos": [
            [
              234,
              0
            ],
            [
              337,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rfc6724_compare",
            "parameters": {
              "ptr1": "void",
              "ptr2": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int find_src_addr(ares_channel_t *channel, const struct sockaddr *addr,\n                         struct sockaddr *src_addr)\n{\n  ares_socket_t  sock;\n  int            ret;\n  ares_socklen_t len;\n\n  switch (addr->sa_family) {\n    case AF_INET:\n      len = sizeof(struct sockaddr_in);\n      break;\n    case AF_INET6:\n      len = sizeof(struct sockaddr_in6);\n      break;\n    default:\n      /* No known usable source address for non-INET families. */\n      return 0;\n  }\n\n  sock = ares__open_socket(channel, addr->sa_family, SOCK_DGRAM, IPPROTO_UDP);\n  if (sock == ARES_SOCKET_BAD) {\n    if (errno == EAFNOSUPPORT) {\n      return 0;\n    } else {\n      return -1;\n    }\n  }\n\n  do {\n    ret = ares__connect_socket(channel, sock, addr, len);\n  } while (ret == -1 && errno == EINTR);\n\n  if (ret == -1) {\n    ares__close_socket(channel, sock);\n    return 0;\n  }\n\n  if (getsockname(sock, src_addr, &len) != 0) {\n    ares__close_socket(channel, sock);\n    return -1;\n  }\n  ares__close_socket(channel, sock);\n  return 1;\n}",
          "fn_code_pos": [
            [
              347,
              0
            ],
            [
              390,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_src_addr",
            "parameters": {
              "channel": "ares_channel_t",
              "addr": "struct sockaddr",
              "src_addr": "struct sockaddr"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_status_t ares__sortaddrinfo(ares_channel_t            *channel,\n                                 struct ares_addrinfo_node *list_sentinel)\n{\n  struct ares_addrinfo_node *cur;\n  size_t                     nelem = 0;\n  size_t                     i;\n  int                        has_src_addr;\n  struct addrinfo_sort_elem *elems;\n\n  cur = list_sentinel->ai_next;\n  while (cur) {\n    ++nelem;\n    cur = cur->ai_next;\n  }\n\n  if (!nelem) {\n    return ARES_ENODATA;\n  }\n\n  elems = (struct addrinfo_sort_elem *)ares_malloc(\n    nelem * sizeof(struct addrinfo_sort_elem));\n  if (!elems) {\n    return ARES_ENOMEM;\n  }\n\n  /*\n   * Convert the linked list to an array that also contains the candidate\n   * source address for each destination address.\n   */\n  for (i = 0, cur = list_sentinel->ai_next; i < nelem;\n       ++i, cur   = cur->ai_next) {\n    assert(cur != NULL);\n    elems[i].ai             = cur;\n    elems[i].original_order = i;\n    has_src_addr = find_src_addr(channel, cur->ai_addr, &elems[i].src_addr.sa);\n    if (has_src_addr == -1) {\n      ares_free(elems);\n      return ARES_ENOTFOUND;\n    }\n    elems[i].has_src_addr = (has_src_addr == 1) ? ARES_TRUE : ARES_FALSE;\n  }\n\n  /* Sort the addresses, and rearrange the linked list so it matches the sorted\n   * order. */\n  qsort((void *)elems, nelem, sizeof(struct addrinfo_sort_elem),\n        rfc6724_compare);\n\n  list_sentinel->ai_next = elems[0].ai;\n  for (i = 0; i < nelem - 1; ++i) {\n    elems[i].ai->ai_next = elems[i + 1].ai;\n  }\n  elems[nelem - 1].ai->ai_next = NULL;\n\n  ares_free(elems);\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              396,
              0
            ],
            [
              451,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__sortaddrinfo",
            "parameters": {
              "channel": "ares_channel_t",
              "list_sentinel": "struct ares_addrinfo_node"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct addrinfo_sort_elem {\n  struct ares_addrinfo_node *ai;\n  ares_bool_t                has_src_addr;\n  ares_sockaddr              src_addr;\n  size_t                     original_order;\n}",
          {
            "*ai": "struct ares_addrinfo_node",
            "has_src_addr": "ares_bool_t",
            "src_addr": "ares_sockaddr",
            "original_order": "size_t"
          },
          "addrinfo_sort_elem",
          [
            56,
            0
          ],
          [
            61,
            1
          ]
        ],
        [
          "struct addrinfo_sort_elem {\n  struct ares_addrinfo_node *ai;\n  ares_bool_t                has_src_addr;\n  ares_sockaddr              src_addr;\n  size_t                     original_order;\n}",
          {
            "*ai": "struct ares_addrinfo_node",
            "has_src_addr": "ares_bool_t",
            "src_addr": "ares_sockaddr",
            "original_order": "size_t"
          },
          "addrinfo_sort_elem",
          [
            56,
            0
          ],
          [
            61,
            1
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            57,
            2
          ],
          [
            57,
            27
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            90,
            27
          ],
          [
            90,
            42
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            93,
            10
          ],
          [
            93,
            29
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            110,
            10
          ],
          [
            110,
            28
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            134,
            27
          ],
          [
            134,
            42
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            139,
            10
          ],
          [
            139,
            29
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            174,
            32
          ],
          [
            174,
            47
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            179,
            10
          ],
          [
            179,
            29
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            207,
            38
          ],
          [
            207,
            53
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            208,
            38
          ],
          [
            208,
            53
          ]
        ],
        [
          "struct addrinfo_sort_elem",
          {},
          "",
          [
            236,
            8
          ],
          [
            236,
            33
          ]
        ],
        [
          "struct addrinfo_sort_elem",
          {},
          "",
          [
            236,
            47
          ],
          [
            236,
            72
          ]
        ],
        [
          "struct addrinfo_sort_elem",
          {},
          "",
          [
            237,
            8
          ],
          [
            237,
            33
          ]
        ],
        [
          "struct addrinfo_sort_elem",
          {},
          "",
          [
            237,
            47
          ],
          [
            237,
            72
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            319,
            10
          ],
          [
            319,
            29
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            320,
            10
          ],
          [
            320,
            29
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            322,
            10
          ],
          [
            322,
            29
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            323,
            10
          ],
          [
            323,
            29
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            347,
            56
          ],
          [
            347,
            71
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            348,
            25
          ],
          [
            348,
            40
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            356,
            19
          ],
          [
            356,
            37
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            359,
            19
          ],
          [
            359,
            38
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            397,
            33
          ],
          [
            397,
            58
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            399,
            2
          ],
          [
            399,
            27
          ]
        ],
        [
          "struct addrinfo_sort_elem",
          {},
          "",
          [
            403,
            2
          ],
          [
            403,
            27
          ]
        ],
        [
          "struct addrinfo_sort_elem",
          {},
          "",
          [
            415,
            11
          ],
          [
            415,
            36
          ]
        ],
        [
          "struct addrinfo_sort_elem",
          {},
          "",
          [
            416,
            19
          ],
          [
            416,
            44
          ]
        ],
        [
          "struct addrinfo_sort_elem",
          {},
          "",
          [
            440,
            37
          ],
          [
            440,
            62
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_data.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_free_data(void *dataptr)\n{\n  while (dataptr != NULL) {\n    struct ares_data *ptr;\n    void             *next_data = NULL;\n\n#ifdef __INTEL_COMPILER\n#  pragma warning(push)\n#  pragma warning(disable : 1684)\n    /* 1684: conversion from pointer to same-sized integral type */\n#endif\n\n    ptr = (void *)((char *)dataptr - offsetof(struct ares_data, data));\n\n#ifdef __INTEL_COMPILER\n#  pragma warning(pop)\n#endif\n\n    if (ptr->mark != ARES_DATATYPE_MARK) {\n      return;\n    }\n\n    switch (ptr->type) {\n      case ARES_DATATYPE_MX_REPLY:\n        next_data = ptr->data.mx_reply.next;\n        ares_free(ptr->data.mx_reply.host);\n        break;\n\n      case ARES_DATATYPE_SRV_REPLY:\n        next_data = ptr->data.srv_reply.next;\n        ares_free(ptr->data.srv_reply.host);\n        break;\n\n      case ARES_DATATYPE_URI_REPLY:\n        next_data = ptr->data.uri_reply.next;\n        ares_free(ptr->data.uri_reply.uri);\n        break;\n\n      case ARES_DATATYPE_TXT_REPLY:\n      case ARES_DATATYPE_TXT_EXT:\n        next_data = ptr->data.txt_reply.next;\n        ares_free(ptr->data.txt_reply.txt);\n        break;\n\n      case ARES_DATATYPE_ADDR_NODE:\n        next_data = ptr->data.addr_node.next;\n        break;\n\n      case ARES_DATATYPE_ADDR_PORT_NODE:\n        next_data = ptr->data.addr_port_node.next;\n        break;\n\n      case ARES_DATATYPE_NAPTR_REPLY:\n        next_data = ptr->data.naptr_reply.next;\n        ares_free(ptr->data.naptr_reply.flags);\n        ares_free(ptr->data.naptr_reply.service);\n        ares_free(ptr->data.naptr_reply.regexp);\n        ares_free(ptr->data.naptr_reply.replacement);\n        break;\n\n      case ARES_DATATYPE_SOA_REPLY:\n        ares_free(ptr->data.soa_reply.nsname);\n        ares_free(ptr->data.soa_reply.hostmaster);\n        break;\n\n      case ARES_DATATYPE_CAA_REPLY:\n        next_data = ptr->data.caa_reply.next;\n        ares_free(ptr->data.caa_reply.property);\n        ares_free(ptr->data.caa_reply.value);\n        break;\n\n      default:\n        return;\n    }\n\n    ares_free(ptr);\n    dataptr = next_data;\n  }\n}",
          "fn_code_pos": [
            [
              49,
              0
            ],
            [
              127,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_free_data",
            "parameters": {
              "dataptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void *ares_malloc_data(ares_datatype type)\n{\n  struct ares_data *ptr;\n\n  ptr = ares_malloc_zero(sizeof(*ptr));\n  if (!ptr) {\n    return NULL;\n  }\n\n  switch (type) {\n    case ARES_DATATYPE_MX_REPLY:\n    case ARES_DATATYPE_SRV_REPLY:\n    case ARES_DATATYPE_URI_REPLY:\n    case ARES_DATATYPE_TXT_EXT:\n    case ARES_DATATYPE_TXT_REPLY:\n    case ARES_DATATYPE_CAA_REPLY:\n    case ARES_DATATYPE_ADDR_NODE:\n    case ARES_DATATYPE_ADDR_PORT_NODE:\n    case ARES_DATATYPE_NAPTR_REPLY:\n    case ARES_DATATYPE_SOA_REPLY:\n      break;\n\n    default:\n      ares_free(ptr);\n      return NULL;\n  }\n\n  ptr->mark = ARES_DATATYPE_MARK;\n  ptr->type = type;\n\n  return &ptr->data;\n}",
          "fn_code_pos": [
            [
              140,
              0
            ],
            [
              171,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_malloc_data",
            "parameters": {
              "type": "ares_datatype"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_malloc_data(ares_datatype type)",
          "fn_dec_pos": [
            [
              140,
              6
            ],
            [
              140,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_malloc_data",
            "parameters": {
              "type": "ares_datatype"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_data",
          {},
          "",
          [
            52,
            4
          ],
          [
            52,
            20
          ]
        ],
        [
          "struct ares_data",
          {},
          "",
          [
            61,
            46
          ],
          [
            61,
            62
          ]
        ],
        [
          "struct ares_data",
          {},
          "",
          [
            142,
            2
          ],
          [
            142,
            18
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <stddef.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__htable_strvp.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares__htable_strvp_destroy(ares__htable_strvp_t *htable)\n{\n  if (htable == NULL) {\n    return;\n  }\n\n  ares__htable_destroy(htable->hash);\n  ares_free(htable);\n}",
          "fn_code_pos": [
            [
              42,
              0
            ],
            [
              50,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_strvp_destroy",
            "parameters": {
              "htable": "ares__htable_strvp_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static unsigned int hash_func(const void *key, unsigned int seed)\n{\n  const char *arg = key;\n  return ares__htable_hash_FNV1a_casecmp((const unsigned char *)arg,\n                                         ares_strlen(arg), seed);\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              57,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "hash_func",
            "parameters": {
              "key": "void",
              "seed": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static const void *bucket_key(const void *bucket)\n{\n  const ares__htable_strvp_bucket_t *arg = bucket;\n  return arg->key;\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_key",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void bucket_free(void *bucket)\n{\n  ares__htable_strvp_bucket_t *arg = bucket;\n\n  if (arg->parent->free_val) {\n    arg->parent->free_val(arg->val);\n  }\n  ares_free(arg->key);\n  ares_free(arg);\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              74,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_free",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t key_eq(const void *key1, const void *key2)\n{\n  const char *k1 = key1;\n  const char *k2 = key2;\n\n  if (strcasecmp(k1, k2) == 0) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "key_eq",
            "parameters": {
              "key1": "void",
              "key2": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__htable_strvp_t *\n  ares__htable_strvp_create(ares__htable_strvp_val_free_t val_free)\n{\n  ares__htable_strvp_t *htable = ares_malloc(sizeof(*htable));\n  if (htable == NULL) {\n    goto fail;\n  }\n\n  htable->hash =\n    ares__htable_create(hash_func, bucket_key, bucket_free, key_eq);\n  if (htable->hash == NULL) {\n    goto fail;\n  }\n\n  htable->free_val = val_free;\n\n  return htable;\n\nfail:\n  if (htable) {\n    ares__htable_destroy(htable->hash);\n    ares_free(htable);\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              88,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_strvp_create",
            "parameters": {
              "val_free": "ares__htable_strvp_val_free_t"
            },
            "return_type": "ares__htable_strvp_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares__htable_strvp_insert(ares__htable_strvp_t *htable,\n                                      const char *key, void *val)\n{\n  ares__htable_strvp_bucket_t *bucket = NULL;\n\n  if (htable == NULL || key == NULL) {\n    goto fail;\n  }\n\n  bucket = ares_malloc(sizeof(*bucket));\n  if (bucket == NULL) {\n    goto fail;\n  }\n\n  bucket->parent = htable;\n  bucket->key    = ares_strdup(key);\n  if (bucket->key == NULL) {\n    goto fail;\n  }\n  bucket->val = val;\n\n  if (!ares__htable_insert(htable->hash, bucket)) {\n    goto fail;\n  }\n\n  return ARES_TRUE;\n\nfail:\n  if (bucket) {\n    ares_free(bucket->key);\n    ares_free(bucket);\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              147,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_strvp_insert",
            "parameters": {
              "htable": "ares__htable_strvp_t",
              "key": "char",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares__htable_strvp_get(const ares__htable_strvp_t *htable,\n                                   const char *key, void **val)\n{\n  ares__htable_strvp_bucket_t *bucket = NULL;\n\n  if (val) {\n    *val = NULL;\n  }\n\n  if (htable == NULL || key == NULL) {\n    return ARES_FALSE;\n  }\n\n  bucket = ares__htable_get(htable->hash, key);\n  if (bucket == NULL) {\n    return ARES_FALSE;\n  }\n\n  if (val) {\n    *val = bucket->val;\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              149,
              0
            ],
            [
              171,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_strvp_get",
            "parameters": {
              "htable": "ares__htable_strvp_t",
              "key": "char",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "void *ares__htable_strvp_get_direct(const ares__htable_strvp_t *htable,\n                                    const char                 *key)\n{\n  void *val = NULL;\n  ares__htable_strvp_get(htable, key, &val);\n  return val;\n}",
          "fn_code_pos": [
            [
              173,
              0
            ],
            [
              179,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_strvp_get_direct",
            "parameters": {
              "htable": "ares__htable_strvp_t",
              "key": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_bool_t ares__htable_strvp_remove(ares__htable_strvp_t *htable,\n                                      const char           *key)\n{\n  if (htable == NULL) {\n    return ARES_FALSE;\n  }\n\n  return ares__htable_remove(htable->hash, key);\n}",
          "fn_code_pos": [
            [
              181,
              0
            ],
            [
              189,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_strvp_remove",
            "parameters": {
              "htable": "ares__htable_strvp_t",
              "key": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "size_t ares__htable_strvp_num_keys(const ares__htable_strvp_t *htable)\n{\n  if (htable == NULL) {\n    return 0;\n  }\n  return ares__htable_num_keys(htable->hash);\n}",
          "fn_code_pos": [
            [
              191,
              0
            ],
            [
              197,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_strvp_num_keys",
            "parameters": {
              "htable": "ares__htable_strvp_t"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "bucket_key(const void *bucket)",
          "fn_dec_pos": [
            [
              59,
              19
            ],
            [
              59,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_key",
            "parameters": {
              "bucket": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_strvp_create(ares__htable_strvp_val_free_t val_free)",
          "fn_dec_pos": [
            [
              89,
              2
            ],
            [
              89,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_strvp_create",
            "parameters": {
              "val_free": "ares__htable_strvp_val_free_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_strvp_get_direct(const ares__htable_strvp_t *htable,\n                                    const char                 *key)",
          "fn_dec_pos": [
            [
              173,
              6
            ],
            [
              174,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_strvp_get_direct",
            "parameters": {
              "htable": "ares__htable_strvp_t",
              "key": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares__htable_strvp {\n  ares__htable_strvp_val_free_t free_val;\n  ares__htable_t               *hash;\n}",
          {
            "free_val": "ares__htable_strvp_val_free_t",
            "*hash": "ares__htable_t"
          },
          "ares__htable_strvp",
          [
            31,
            0
          ],
          [
            34,
            1
          ]
        ],
        [
          "typedef struct {\n  char                 *key;\n  void                 *val;\n  ares__htable_strvp_t *parent;\n} ares__htable_strvp_bucket_t;",
          {
            "*key": "char",
            "*val": "void",
            "*parent": "ares__htable_strvp_t"
          },
          "ares__htable_strvp_bucket_t",
          [
            36,
            0
          ],
          [
            40,
            30
          ]
        ],
        [
          "struct ares__htable_strvp {\n  ares__htable_strvp_val_free_t free_val;\n  ares__htable_t               *hash;\n}",
          {
            "free_val": "ares__htable_strvp_val_free_t",
            "*hash": "ares__htable_t"
          },
          "ares__htable_strvp",
          [
            31,
            0
          ],
          [
            34,
            1
          ]
        ],
        [
          "typedef struct {\n  char                 *key;\n  void                 *val;\n  ares__htable_strvp_t *parent;\n} ares__htable_strvp_bucket_t;",
          {
            "*key": "char",
            "*val": "void",
            "*parent": "ares__htable_strvp_t"
          },
          "ares__htable_strvp_bucket_t",
          [
            36,
            0
          ],
          [
            40,
            30
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares__htable.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares__htable_strvp.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_library_init.c": {
      "fn_def_list": [
        {
          "fn_code": "static void        *default_malloc(size_t size)\n{\n  if (size == 0) {\n    return NULL;\n  }\n  return malloc(size);\n}",
          "fn_code_pos": [
            [
              49,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_malloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void *default_realloc(void *p, size_t size)\n{\n  return realloc(p, size);\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              62,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_realloc",
            "parameters": {
              "p": "void",
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void default_free(void *p)\n{\n  free(p);\n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_free",
            "parameters": {
              "p": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void *ares_malloc_zero(size_t size)\n{\n  void *ptr = ares_malloc(size);\n  if (ptr != NULL) {\n    memset(ptr, 0, size);\n  }\n\n  return ptr;\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_malloc_zero",
            "parameters": {
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void *ares_realloc_zero(void *ptr, size_t orig_size, size_t new_size)\n{\n  void *p = ares_realloc(ptr, new_size);\n  if (p == NULL) {\n    return NULL;\n  }\n\n  if (new_size > orig_size) {\n    memset((unsigned char *)p + orig_size, 0, new_size - orig_size);\n  }\n\n  return p;\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              98,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_realloc_zero",
            "parameters": {
              "ptr": "void",
              "orig_size": "size_t",
              "new_size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int ares_library_init(int flags)\n{\n  if (ares_initialized) {\n    ares_initialized++;\n    return ARES_SUCCESS;\n  }\n  ares_initialized++;\n\n  /* NOTE: ARES_LIB_INIT_WIN32 flag no longer used */\n\n  ares_init_flags = flags;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              100,
              0
            ],
            [
              113,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_init",
            "parameters": {
              "flags": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_library_init_mem(int flags, void *(*amalloc)(size_t size),\n                          void (*afree)(void *ptr),\n                          void *(*arealloc)(void *ptr, size_t size))\n{\n  if (amalloc) {\n    ares_malloc = amalloc;\n  }\n  if (arealloc) {\n    ares_realloc = arealloc;\n  }\n  if (afree) {\n    ares_free = afree;\n  }\n  return ares_library_init(flags);\n}",
          "fn_code_pos": [
            [
              115,
              0
            ],
            [
              129,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_init_mem",
            "parameters": {
              "flags": "int",
              "amalloc": "void",
              "size": "size_t",
              "afree": "void",
              "ptr": "void",
              "arealloc": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void ares_library_cleanup(void)\n{\n  if (!ares_initialized) {\n    return;\n  }\n  ares_initialized--;\n  if (ares_initialized) {\n    return;\n  }\n\n  /* NOTE: ARES_LIB_INIT_WIN32 flag no longer used */\n\n#if defined(ANDROID) || defined(__ANDROID__)\n  ares_library_cleanup_android();\n#endif\n\n  ares_init_flags = ARES_LIB_INIT_NONE;\n  ares_malloc     = malloc;\n  ares_realloc    = realloc;\n  ares_free       = free;\n}",
          "fn_code_pos": [
            [
              131,
              0
            ],
            [
              151,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_cleanup",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int ares_library_initialized(void)\n{\n#ifdef USE_WINSOCK\n  if (!ares_initialized) {\n    return ARES_ENOTINITIALIZED;\n  }\n#endif\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              153,
              0
            ],
            [
              161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_initialized",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "default_malloc(size_t size)",
          "fn_dec_pos": [
            [
              49,
              20
            ],
            [
              49,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_malloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "default_realloc(void *p, size_t size)",
          "fn_dec_pos": [
            [
              59,
              13
            ],
            [
              59,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "default_realloc",
            "parameters": {
              "p": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*ares_malloc)(size_t size)",
          "fn_dec_pos": [
            [
              72,
              6
            ],
            [
              72,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*ares_realloc)(void *ptr, size_t size)",
          "fn_dec_pos": [
            [
              73,
              6
            ],
            [
              73,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*ares_free)(void *ptr)",
          "fn_dec_pos": [
            [
              74,
              5
            ],
            [
              74,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ptr": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_malloc_zero(size_t size)",
          "fn_dec_pos": [
            [
              76,
              6
            ],
            [
              76,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_malloc_zero",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_realloc_zero(void *ptr, size_t orig_size, size_t new_size)",
          "fn_dec_pos": [
            [
              86,
              6
            ],
            [
              86,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_realloc_zero",
            "parameters": {
              "ptr": "void",
              "orig_size": "size_t",
              "new_size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*amalloc)(size_t size)",
          "fn_dec_pos": [
            [
              115,
              43
            ],
            [
              115,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*afree)(void *ptr)",
          "fn_dec_pos": [
            [
              116,
              31
            ],
            [
              116,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*arealloc)(void *ptr, size_t size)",
          "fn_dec_pos": [
            [
              117,
              32
            ],
            [
              117,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include \"ares_android.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_dns_parse.c": {
      "fn_def_list": [
        {
          "fn_code": "static size_t ares_dns_rr_remaining_len(const ares__buf_t *buf, size_t orig_len,\n                                        size_t rdlength)\n{\n  size_t used_len = orig_len - ares__buf_len(buf);\n  if (used_len >= rdlength) {\n    return 0;\n  }\n  return rdlength - used_len;\n}",
          "fn_code_pos": [
            [
              33,
              0
            ],
            [
              41,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_remaining_len",
            "parameters": {
              "buf": "ares__buf_t",
              "orig_len": "size_t",
              "rdlength": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_and_set_dns_name(ares__buf_t   *buf,\n                                                     ares_bool_t    is_hostname,\n                                                     ares_dns_rr_t *rr,\n                                                     ares_dns_rr_key_t key)\n{\n  ares_status_t status;\n  char         *name = NULL;\n\n  status = ares__dns_name_parse(buf, &name, is_hostname);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_rr_set_str_own(rr, key, name);\n  if (status != ARES_SUCCESS) {\n    ares_free(name);\n    return status;\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              43,
              0
            ],
            [
              62,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_and_set_dns_name",
            "parameters": {
              "buf": "ares__buf_t",
              "is_hostname": "ares_bool_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_and_set_dns_str(\n  ares__buf_t *buf, size_t max_len, ares_bool_t allow_multiple,\n  ares_dns_rr_t *rr, ares_dns_rr_key_t key, ares_bool_t blank_allowed)\n{\n  ares_status_t status;\n  char         *str = NULL;\n\n  status = ares__buf_parse_dns_str(buf, max_len, &str, allow_multiple);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  if (!blank_allowed && ares_strlen(str) == 0) {\n    ares_free(str);\n    return ARES_EBADRESP;\n  }\n\n  status = ares_dns_rr_set_str_own(rr, key, str);\n  if (status != ARES_SUCCESS) {\n    ares_free(str);\n    return status;\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_and_set_dns_str",
            "parameters": {
              "buf": "ares__buf_t",
              "max_len": "size_t",
              "allow_multiple": "ares_bool_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "blank_allowed": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t\n  ares_dns_parse_and_set_dns_binstr(ares__buf_t *buf, size_t max_len,\n                                    ares_bool_t    allow_multiple,\n                                    ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  ares_status_t  status;\n  unsigned char *bin     = NULL;\n  size_t         bin_len = 0;\n\n  status =\n    ares__buf_parse_dns_binstr(buf, max_len, &bin, &bin_len, allow_multiple);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_rr_set_bin_own(rr, key, bin, bin_len);\n  if (status != ARES_SUCCESS) {\n    ares_free(bin);\n    return status;\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              110,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_and_set_dns_binstr",
            "parameters": {
              "buf": "ares__buf_t",
              "max_len": "size_t",
              "allow_multiple": "ares_bool_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_and_set_be32(ares__buf_t      *buf,\n                                                 ares_dns_rr_t    *rr,\n                                                 ares_dns_rr_key_t key)\n{\n  ares_status_t status;\n  unsigned int  u32;\n\n  status = ares__buf_fetch_be32(buf, &u32);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return ares_dns_rr_set_u32(rr, key, u32);\n}",
          "fn_code_pos": [
            [
              112,
              0
            ],
            [
              125,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_and_set_be32",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_and_set_be16(ares__buf_t      *buf,\n                                                 ares_dns_rr_t    *rr,\n                                                 ares_dns_rr_key_t key)\n{\n  ares_status_t  status;\n  unsigned short u16;\n\n  status = ares__buf_fetch_be16(buf, &u16);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return ares_dns_rr_set_u16(rr, key, u16);\n}",
          "fn_code_pos": [
            [
              127,
              0
            ],
            [
              140,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_and_set_be16",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_and_set_u8(ares__buf_t      *buf,\n                                               ares_dns_rr_t    *rr,\n                                               ares_dns_rr_key_t key)\n{\n  ares_status_t status;\n  unsigned char u8;\n\n  status = ares__buf_fetch_bytes(buf, &u8, 1);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return ares_dns_rr_set_u8(rr, key, u8);\n}",
          "fn_code_pos": [
            [
              142,
              0
            ],
            [
              155,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_and_set_u8",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_a(ares__buf_t *buf, ares_dns_rr_t *rr,\n                                         size_t rdlength)\n{\n  struct in_addr addr;\n  ares_status_t  status;\n\n  (void)rdlength; /* Not needed */\n\n  status = ares__buf_fetch_bytes(buf, (unsigned char *)&addr, sizeof(addr));\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return ares_dns_rr_set_addr(rr, ARES_RR_A_ADDR, &addr);\n}",
          "fn_code_pos": [
            [
              157,
              0
            ],
            [
              171,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_a",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_ns(ares__buf_t *buf, ares_dns_rr_t *rr,\n                                          size_t rdlength)\n{\n  (void)rdlength; /* Not needed */\n\n  return ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,\n                                         ARES_RR_NS_NSDNAME);\n}",
          "fn_code_pos": [
            [
              173,
              0
            ],
            [
              180,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_ns",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_cname(ares__buf_t   *buf,\n                                             ares_dns_rr_t *rr, size_t rdlength)\n{\n  (void)rdlength; /* Not needed */\n\n  return ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,\n                                         ARES_RR_CNAME_CNAME);\n}",
          "fn_code_pos": [
            [
              182,
              0
            ],
            [
              189,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_cname",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_soa(ares__buf_t *buf, ares_dns_rr_t *rr,\n                                           size_t rdlength)\n{\n  ares_status_t status;\n\n  (void)rdlength; /* Not needed */\n\n  /* MNAME */\n  status =\n    ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr, ARES_RR_SOA_MNAME);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* RNAME */\n  status =\n    ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr, ARES_RR_SOA_RNAME);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* SERIAL */\n  status = ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SOA_SERIAL);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* REFRESH */\n  status = ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SOA_REFRESH);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* RETRY */\n  status = ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SOA_RETRY);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* EXPIRE */\n  status = ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SOA_EXPIRE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* MINIMUM */\n  return ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SOA_MINIMUM);\n}",
          "fn_code_pos": [
            [
              191,
              0
            ],
            [
              238,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_soa",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_ptr(ares__buf_t *buf, ares_dns_rr_t *rr,\n                                           size_t rdlength)\n{\n  (void)rdlength; /* Not needed */\n\n  return ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,\n                                         ARES_RR_PTR_DNAME);\n}",
          "fn_code_pos": [
            [
              240,
              0
            ],
            [
              247,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_ptr",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_hinfo(ares__buf_t   *buf,\n                                             ares_dns_rr_t *rr, size_t rdlength)\n{\n  ares_status_t status;\n  size_t        orig_len = ares__buf_len(buf);\n\n  (void)rdlength; /* Not needed */\n\n  /* CPU */\n  status = ares_dns_parse_and_set_dns_str(\n    buf, ares_dns_rr_remaining_len(buf, orig_len, rdlength), ARES_FALSE, rr,\n    ARES_RR_HINFO_CPU, ARES_TRUE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* OS */\n  status = ares_dns_parse_and_set_dns_str(\n    buf, ares_dns_rr_remaining_len(buf, orig_len, rdlength), ARES_FALSE, rr,\n    ARES_RR_HINFO_OS, ARES_TRUE);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              249,
              0
            ],
            [
              271,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_hinfo",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_mx(ares__buf_t *buf, ares_dns_rr_t *rr,\n                                          size_t rdlength)\n{\n  ares_status_t status;\n\n  (void)rdlength; /* Not needed */\n\n  /* PREFERENCE */\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_MX_PREFERENCE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* EXCHANGE */\n  return ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,\n                                         ARES_RR_MX_EXCHANGE);\n}",
          "fn_code_pos": [
            [
              273,
              0
            ],
            [
              289,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_mx",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_txt(ares__buf_t *buf, ares_dns_rr_t *rr,\n                                           size_t rdlength)\n{\n  return ares_dns_parse_and_set_dns_binstr(buf, rdlength, ARES_TRUE, rr,\n                                           ARES_RR_TXT_DATA);\n}",
          "fn_code_pos": [
            [
              291,
              0
            ],
            [
              296,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_txt",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_aaaa(ares__buf_t *buf, ares_dns_rr_t *rr,\n                                            size_t rdlength)\n{\n  struct ares_in6_addr addr;\n  ares_status_t        status;\n\n  (void)rdlength; /* Not needed */\n\n  status = ares__buf_fetch_bytes(buf, (unsigned char *)&addr, sizeof(addr));\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return ares_dns_rr_set_addr6(rr, ARES_RR_AAAA_ADDR, &addr);\n}",
          "fn_code_pos": [
            [
              298,
              0
            ],
            [
              312,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_aaaa",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_srv(ares__buf_t *buf, ares_dns_rr_t *rr,\n                                           size_t rdlength)\n{\n  ares_status_t status;\n\n  (void)rdlength; /* Not needed */\n\n  /* PRIORITY */\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_SRV_PRIORITY);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* WEIGHT */\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_SRV_WEIGHT);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* PORT */\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_SRV_PORT);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* TARGET */\n  return ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,\n                                         ARES_RR_SRV_TARGET);\n}",
          "fn_code_pos": [
            [
              314,
              0
            ],
            [
              342,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_srv",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_naptr(ares__buf_t   *buf,\n                                             ares_dns_rr_t *rr, size_t rdlength)\n{\n  ares_status_t status;\n  size_t        orig_len = ares__buf_len(buf);\n\n  /* ORDER */\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_NAPTR_ORDER);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* PREFERENCE */\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_NAPTR_PREFERENCE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* FLAGS */\n  status = ares_dns_parse_and_set_dns_str(\n    buf, ares_dns_rr_remaining_len(buf, orig_len, rdlength), ARES_FALSE, rr,\n    ARES_RR_NAPTR_FLAGS, ARES_TRUE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* SERVICES */\n  status = ares_dns_parse_and_set_dns_str(\n    buf, ares_dns_rr_remaining_len(buf, orig_len, rdlength), ARES_FALSE, rr,\n    ARES_RR_NAPTR_SERVICES, ARES_TRUE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* REGEXP */\n  status = ares_dns_parse_and_set_dns_str(\n    buf, ares_dns_rr_remaining_len(buf, orig_len, rdlength), ARES_FALSE, rr,\n    ARES_RR_NAPTR_REGEXP, ARES_TRUE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* REPLACEMENT */\n  return ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,\n                                         ARES_RR_NAPTR_REPLACEMENT);\n}",
          "fn_code_pos": [
            [
              344,
              0
            ],
            [
              389,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_naptr",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_opt(ares__buf_t *buf, ares_dns_rr_t *rr,\n                                           size_t         rdlength,\n                                           unsigned short raw_class,\n                                           unsigned int   raw_ttl)\n{\n  ares_status_t  status;\n  size_t         orig_len = ares__buf_len(buf);\n  unsigned short rcode_high;\n\n  status = ares_dns_rr_set_u16(rr, ARES_RR_OPT_UDP_SIZE, raw_class);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* First 8 bits of TTL are an extended RCODE, and they go in the higher order\n   * after the original 4-bit rcode */\n  rcode_high             = (unsigned short)((raw_ttl >> 20) & 0x0FF0);\n  rr->parent->raw_rcode |= rcode_high;\n\n  status = ares_dns_rr_set_u8(rr, ARES_RR_OPT_VERSION,\n                              (unsigned char)(raw_ttl >> 16) & 0xFF);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_rr_set_u16(rr, ARES_RR_OPT_FLAGS,\n                               (unsigned short)(raw_ttl & 0xFFFF));\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Parse options */\n  while (ares_dns_rr_remaining_len(buf, orig_len, rdlength)) {\n    unsigned short opt = 0;\n    unsigned short len = 0;\n    unsigned char *val = NULL;\n\n    /* Fetch be16 option */\n    status = ares__buf_fetch_be16(buf, &opt);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Fetch be16 length */\n    status = ares__buf_fetch_be16(buf, &len);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    if (len) {\n      status = ares__buf_fetch_bytes_dup(buf, len, ARES_TRUE, &val);\n      if (status != ARES_SUCCESS) {\n        return status;\n      }\n    }\n\n    status = ares_dns_rr_set_opt_own(rr, ARES_RR_OPT_OPTIONS, opt, val, len);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              391,
              0
            ],
            [
              454,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_opt",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t",
              "raw_class": "unsigned short",
              "raw_ttl": "unsigned int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_tlsa(ares__buf_t *buf, ares_dns_rr_t *rr,\n                                            size_t rdlength)\n{\n  ares_status_t  status;\n  size_t         orig_len = ares__buf_len(buf);\n  size_t         len;\n  unsigned char *data;\n\n  status = ares_dns_parse_and_set_u8(buf, rr, ARES_RR_TLSA_CERT_USAGE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_parse_and_set_u8(buf, rr, ARES_RR_TLSA_SELECTOR);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_parse_and_set_u8(buf, rr, ARES_RR_TLSA_MATCH);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  len = ares_dns_rr_remaining_len(buf, orig_len, rdlength);\n  if (len == 0) {\n    return ARES_EBADRESP;\n  }\n\n  status = ares__buf_fetch_bytes_dup(buf, len, ARES_FALSE, &data);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_rr_set_bin_own(rr, ARES_RR_TLSA_DATA, data, len);\n  if (status != ARES_SUCCESS) {\n    ares_free(data);\n    return status;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              456,
              0
            ],
            [
              496,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_tlsa",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_svcb(ares__buf_t *buf, ares_dns_rr_t *rr,\n                                            size_t rdlength)\n{\n  ares_status_t status;\n  size_t        orig_len = ares__buf_len(buf);\n\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_SVCB_PRIORITY);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status =\n    ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr, ARES_RR_SVCB_TARGET);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Parse params */\n  while (ares_dns_rr_remaining_len(buf, orig_len, rdlength)) {\n    unsigned short opt = 0;\n    unsigned short len = 0;\n    unsigned char *val = NULL;\n\n    /* Fetch be16 option */\n    status = ares__buf_fetch_be16(buf, &opt);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Fetch be16 length */\n    status = ares__buf_fetch_be16(buf, &len);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    if (len) {\n      status = ares__buf_fetch_bytes_dup(buf, len, ARES_TRUE, &val);\n      if (status != ARES_SUCCESS) {\n        return status;\n      }\n    }\n\n    status = ares_dns_rr_set_opt_own(rr, ARES_RR_SVCB_PARAMS, opt, val, len);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              498,
              0
            ],
            [
              547,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_svcb",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_https(ares__buf_t   *buf,\n                                             ares_dns_rr_t *rr, size_t rdlength)\n{\n  ares_status_t status;\n  size_t        orig_len = ares__buf_len(buf);\n\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_HTTPS_PRIORITY);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status =\n    ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr, ARES_RR_HTTPS_TARGET);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Parse params */\n  while (ares_dns_rr_remaining_len(buf, orig_len, rdlength)) {\n    unsigned short opt = 0;\n    unsigned short len = 0;\n    unsigned char *val = NULL;\n\n    /* Fetch be16 option */\n    status = ares__buf_fetch_be16(buf, &opt);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Fetch be16 length */\n    status = ares__buf_fetch_be16(buf, &len);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    if (len) {\n      status = ares__buf_fetch_bytes_dup(buf, len, ARES_TRUE, &val);\n      if (status != ARES_SUCCESS) {\n        return status;\n      }\n    }\n\n    status = ares_dns_rr_set_opt_own(rr, ARES_RR_HTTPS_PARAMS, opt, val, len);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              549,
              0
            ],
            [
              598,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_https",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_uri(ares__buf_t *buf, ares_dns_rr_t *rr,\n                                           size_t rdlength)\n{\n  char         *name = NULL;\n  ares_status_t status;\n  size_t        orig_len = ares__buf_len(buf);\n  size_t        remaining_len;\n\n  /* PRIORITY */\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_URI_PRIORITY);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* WEIGHT */\n  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_URI_WEIGHT);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* TARGET -- not in string format, rest of buffer, required to be\n   * non-zero length */\n  remaining_len = ares_dns_rr_remaining_len(buf, orig_len, rdlength);\n  if (remaining_len == 0) {\n    status = ARES_EBADRESP;\n    return status;\n  }\n\n  /* NOTE: Not in DNS string format */\n  status = ares__buf_fetch_str_dup(buf, remaining_len, &name);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_rr_set_str_own(rr, ARES_RR_URI_TARGET, name);\n  if (status != ARES_SUCCESS) {\n    ares_free(name);\n    return status;\n  }\n  name = NULL;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              600,
              0
            ],
            [
              642,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_uri",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_caa(ares__buf_t *buf, ares_dns_rr_t *rr,\n                                           size_t rdlength)\n{\n  unsigned char *data     = NULL;\n  size_t         data_len = 0;\n  ares_status_t  status;\n  size_t         orig_len = ares__buf_len(buf);\n\n  /* CRITICAL */\n  status = ares_dns_parse_and_set_u8(buf, rr, ARES_RR_CAA_CRITICAL);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Tag */\n  status = ares_dns_parse_and_set_dns_str(\n    buf, ares_dns_rr_remaining_len(buf, orig_len, rdlength), ARES_FALSE, rr,\n    ARES_RR_CAA_TAG, ARES_FALSE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Value - binary! (remaining buffer */\n  data_len = ares_dns_rr_remaining_len(buf, orig_len, rdlength);\n  if (data_len == 0) {\n    status = ARES_EBADRESP;\n    return status;\n  }\n  status = ares__buf_fetch_bytes_dup(buf, data_len, ARES_TRUE, &data);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_rr_set_bin_own(rr, ARES_RR_CAA_VALUE, data, data_len);\n  if (status != ARES_SUCCESS) {\n    ares_free(data);\n    return status;\n  }\n  data = NULL;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              644,
              0
            ],
            [
              685,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_caa",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr_raw_rr(ares__buf_t   *buf,\n                                              ares_dns_rr_t *rr,\n                                              size_t         rdlength,\n                                              unsigned short raw_type)\n{\n  ares_status_t  status;\n  unsigned char *bytes = NULL;\n\n  if (rdlength == 0) {\n    return ARES_SUCCESS;\n  }\n\n  status = ares__buf_fetch_bytes_dup(buf, rdlength, ARES_FALSE, &bytes);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Can't fail */\n  status = ares_dns_rr_set_u16(rr, ARES_RR_RAW_RR_TYPE, raw_type);\n  if (status != ARES_SUCCESS) {\n    ares_free(bytes);\n    return status;\n  }\n\n  status = ares_dns_rr_set_bin_own(rr, ARES_RR_RAW_RR_DATA, bytes, rdlength);\n  if (status != ARES_SUCCESS) {\n    ares_free(bytes);\n    return status;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              687,
              0
            ],
            [
              718,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_raw_rr",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "rdlength": "size_t",
              "raw_type": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_header(ares__buf_t *buf, unsigned int flags,\n                                           ares_dns_record_t **dnsrec,\n                                           unsigned short     *qdcount,\n                                           unsigned short     *ancount,\n                                           unsigned short     *nscount,\n                                           unsigned short     *arcount)\n{\n  ares_status_t     status = ARES_EBADRESP;\n  unsigned short    u16;\n  unsigned short    id;\n  unsigned short    dns_flags = 0;\n  ares_dns_opcode_t opcode;\n  unsigned short    rcode;\n\n  (void)flags; /* currently unused */\n\n  if (buf == NULL || dnsrec == NULL || qdcount == NULL || ancount == NULL ||\n      nscount == NULL || arcount == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *dnsrec = NULL;\n\n  /*\n   *  RFC 1035 4.1.1. Header section format.\n   *  and Updated by RFC 2065 to add AD and CD bits.\n   *                                  1  1  1  1  1  1\n   *    0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\n   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   *  |                      ID                       |\n   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   *  |QR|   Opcode  |AA|TC|RD|RA| Z|AD|CD|   RCODE   |\n   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   *  |                    QDCOUNT                    |\n   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   *  |                    ANCOUNT                    |\n   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   *  |                    NSCOUNT                    |\n   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   *  |                    ARCOUNT                    |\n   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   */\n\n  /* ID */\n  status = ares__buf_fetch_be16(buf, &id);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  /* Flags */\n  status = ares__buf_fetch_be16(buf, &u16);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  /* QR */\n  if (u16 & 0x8000) {\n    dns_flags |= ARES_FLAG_QR;\n  }\n\n  /* OPCODE */\n  opcode = (u16 >> 11) & 0xf;\n\n  /* AA */\n  if (u16 & 0x400) {\n    dns_flags |= ARES_FLAG_AA;\n  }\n\n  /* TC */\n  if (u16 & 0x200) {\n    dns_flags |= ARES_FLAG_TC;\n  }\n\n  /* RD */\n  if (u16 & 0x100) {\n    dns_flags |= ARES_FLAG_RD;\n  }\n\n  /* RA */\n  if (u16 & 0x80) {\n    dns_flags |= ARES_FLAG_RA;\n  }\n\n  /* Z -- unused */\n\n  /* AD */\n  if (u16 & 0x20) {\n    dns_flags |= ARES_FLAG_AD;\n  }\n\n  /* CD */\n  if (u16 & 0x10) {\n    dns_flags |= ARES_FLAG_CD;\n  }\n\n  /* RCODE */\n  rcode = u16 & 0xf;\n\n  /* QDCOUNT */\n  status = ares__buf_fetch_be16(buf, qdcount);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  /* ANCOUNT */\n  status = ares__buf_fetch_be16(buf, ancount);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  /* NSCOUNT */\n  status = ares__buf_fetch_be16(buf, nscount);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  /* ARCOUNT */\n  status = ares__buf_fetch_be16(buf, arcount);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  status = ares_dns_record_create(dnsrec, id, dns_flags, opcode,\n                                  ARES_RCODE_NOERROR /* Temporary */);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  (*dnsrec)->raw_rcode = rcode;\n\n  if (*ancount > 0) {\n    status =\n      ares_dns_record_rr_prealloc(*dnsrec, ARES_SECTION_ANSWER, *ancount);\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n\n  if (*nscount > 0) {\n    status =\n      ares_dns_record_rr_prealloc(*dnsrec, ARES_SECTION_AUTHORITY, *nscount);\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n\n  if (*arcount > 0) {\n    status =\n      ares_dns_record_rr_prealloc(*dnsrec, ARES_SECTION_ADDITIONAL, *arcount);\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n\n  return ARES_SUCCESS;\n\nfail:\n  ares_dns_record_destroy(*dnsrec);\n  *dnsrec  = NULL;\n  *qdcount = 0;\n  *ancount = 0;\n  *nscount = 0;\n  *arcount = 0;\n\n  return status;\n}",
          "fn_code_pos": [
            [
              720,
              0
            ],
            [
              885,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_header",
            "parameters": {
              "buf": "ares__buf_t",
              "flags": "unsigned int",
              "dnsrec": "ares_dns_record_t",
              "qdcount": "unsigned short",
              "ancount": "unsigned short",
              "nscount": "unsigned short",
              "arcount": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t\n  ares_dns_parse_rr_data(ares__buf_t *buf, size_t rdlength, ares_dns_rr_t *rr,\n                         ares_dns_rec_type_t type, unsigned short raw_type,\n                         unsigned short raw_class, unsigned int raw_ttl)\n{\n  switch (type) {\n    case ARES_REC_TYPE_A:\n      return ares_dns_parse_rr_a(buf, rr, rdlength);\n    case ARES_REC_TYPE_NS:\n      return ares_dns_parse_rr_ns(buf, rr, rdlength);\n    case ARES_REC_TYPE_CNAME:\n      return ares_dns_parse_rr_cname(buf, rr, rdlength);\n    case ARES_REC_TYPE_SOA:\n      return ares_dns_parse_rr_soa(buf, rr, rdlength);\n    case ARES_REC_TYPE_PTR:\n      return ares_dns_parse_rr_ptr(buf, rr, rdlength);\n    case ARES_REC_TYPE_HINFO:\n      return ares_dns_parse_rr_hinfo(buf, rr, rdlength);\n    case ARES_REC_TYPE_MX:\n      return ares_dns_parse_rr_mx(buf, rr, rdlength);\n    case ARES_REC_TYPE_TXT:\n      return ares_dns_parse_rr_txt(buf, rr, rdlength);\n    case ARES_REC_TYPE_AAAA:\n      return ares_dns_parse_rr_aaaa(buf, rr, rdlength);\n    case ARES_REC_TYPE_SRV:\n      return ares_dns_parse_rr_srv(buf, rr, rdlength);\n    case ARES_REC_TYPE_NAPTR:\n      return ares_dns_parse_rr_naptr(buf, rr, rdlength);\n    case ARES_REC_TYPE_ANY:\n      return ARES_EBADRESP;\n    case ARES_REC_TYPE_OPT:\n      return ares_dns_parse_rr_opt(buf, rr, rdlength, raw_class, raw_ttl);\n    case ARES_REC_TYPE_TLSA:\n      return ares_dns_parse_rr_tlsa(buf, rr, rdlength);\n    case ARES_REC_TYPE_SVCB:\n      return ares_dns_parse_rr_svcb(buf, rr, rdlength);\n    case ARES_REC_TYPE_HTTPS:\n      return ares_dns_parse_rr_https(buf, rr, rdlength);\n    case ARES_REC_TYPE_URI:\n      return ares_dns_parse_rr_uri(buf, rr, rdlength);\n    case ARES_REC_TYPE_CAA:\n      return ares_dns_parse_rr_caa(buf, rr, rdlength);\n    case ARES_REC_TYPE_RAW_RR:\n      return ares_dns_parse_rr_raw_rr(buf, rr, rdlength, raw_type);\n  }\n  return ARES_EFORMERR;\n}",
          "fn_code_pos": [
            [
              887,
              0
            ],
            [
              933,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr_data",
            "parameters": {
              "buf": "ares__buf_t",
              "rdlength": "size_t",
              "rr": "ares_dns_rr_t",
              "type": "ares_dns_rec_type_t",
              "raw_type": "unsigned short",
              "raw_class": "unsigned short",
              "raw_ttl": "unsigned int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_qd(ares__buf_t       *buf,\n                                       ares_dns_record_t *dnsrec)\n{\n  char               *name = NULL;\n  unsigned short      u16;\n  ares_status_t       status;\n  ares_dns_rec_type_t type;\n  ares_dns_class_t    qclass;\n  /* The question section is used to carry the \"question\" in most queries,\n   * i.e., the parameters that define what is being asked.  The section\n   * contains QDCOUNT (usually 1) entries, each of the following format:\n   *                                 1  1  1  1  1  1\n   *   0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   * |                                               |\n   * /                     QNAME                     /\n   * /                                               /\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   * |                     QTYPE                     |\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   * |                     QCLASS                    |\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   */\n\n  /* Name */\n  status = ares__dns_name_parse(buf, &name, ARES_FALSE);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Type */\n  status = ares__buf_fetch_be16(buf, &u16);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n  type = u16;\n\n  /* Class */\n  status = ares__buf_fetch_be16(buf, &u16);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n  qclass = u16;\n\n  /* Add question */\n  status = ares_dns_record_query_add(dnsrec, name, type, qclass);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\ndone:\n  ares_free(name);\n  return status;\n}",
          "fn_code_pos": [
            [
              935,
              0
            ],
            [
              988,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_qd",
            "parameters": {
              "buf": "ares__buf_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_rr(ares__buf_t *buf, unsigned int flags,\n                                       ares_dns_section_t sect,\n                                       ares_dns_record_t *dnsrec)\n{\n  char               *name = NULL;\n  unsigned short      u16;\n  unsigned short      raw_type;\n  ares_status_t       status;\n  ares_dns_rec_type_t type;\n  ares_dns_class_t    qclass;\n  unsigned int        ttl;\n  size_t              rdlength;\n  ares_dns_rr_t      *rr            = NULL;\n  size_t              remaining_len = 0;\n  size_t              processed_len = 0;\n  ares_bool_t         namecomp;\n\n  /* All RRs have the same top level format shown below:\n   *                                 1  1  1  1  1  1\n   *   0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   * |                                               |\n   * /                                               /\n   * /                      NAME                     /\n   * |                                               |\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   * |                      TYPE                     |\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   * |                     CLASS                     |\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   * |                      TTL                      |\n   * |                                               |\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   * |                   RDLENGTH                    |\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|\n   * /                     RDATA                     /\n   * /                                               /\n   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   */\n\n  /* Name */\n  status = ares__dns_name_parse(buf, &name, ARES_FALSE);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Type */\n  status = ares__buf_fetch_be16(buf, &u16);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n  type     = u16;\n  raw_type = u16; /* Only used for raw rr data */\n\n  /* Class */\n  status = ares__buf_fetch_be16(buf, &u16);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n  qclass = u16;\n\n  /* TTL */\n  status = ares__buf_fetch_be32(buf, &ttl);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Length */\n  status = ares__buf_fetch_be16(buf, &u16);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n  rdlength = u16;\n\n  if (!ares_dns_rec_type_isvalid(type, ARES_FALSE)) {\n    type = ARES_REC_TYPE_RAW_RR;\n  }\n\n  namecomp = ares_dns_rec_type_allow_name_compression(type);\n  if (sect == ARES_SECTION_ANSWER &&\n      (flags &\n       (namecomp ? ARES_DNS_PARSE_AN_BASE_RAW : ARES_DNS_PARSE_AN_EXT_RAW))) {\n    type = ARES_REC_TYPE_RAW_RR;\n  }\n  if (sect == ARES_SECTION_AUTHORITY &&\n      (flags &\n       (namecomp ? ARES_DNS_PARSE_NS_BASE_RAW : ARES_DNS_PARSE_NS_EXT_RAW))) {\n    type = ARES_REC_TYPE_RAW_RR;\n  }\n  if (sect == ARES_SECTION_ADDITIONAL &&\n      (flags &\n       (namecomp ? ARES_DNS_PARSE_AR_BASE_RAW : ARES_DNS_PARSE_AR_EXT_RAW))) {\n    type = ARES_REC_TYPE_RAW_RR;\n  }\n\n  /* Pull into another buffer for safety */\n  if (rdlength > ares__buf_len(buf)) {\n    status = ARES_EBADRESP;\n    goto done;\n  }\n\n  /* Add the base rr */\n  status =\n    ares_dns_record_rr_add(&rr, dnsrec, sect, name, type,\n                           type == ARES_REC_TYPE_OPT ? ARES_CLASS_IN : qclass,\n                           type == ARES_REC_TYPE_OPT ? 0 : ttl);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Record the current remaining length in the buffer so we can tell how\n   * much was processed */\n  remaining_len = ares__buf_len(buf);\n\n  /* Fill in the data for the rr */\n  status = ares_dns_parse_rr_data(buf, rdlength, rr, type, raw_type,\n                                  (unsigned short)qclass, ttl);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Determine how many bytes were processed */\n  processed_len = remaining_len - ares__buf_len(buf);\n\n  /* If too many bytes were processed, error! */\n  if (processed_len > rdlength) {\n    status = ARES_EBADRESP;\n    goto done;\n  }\n\n  /* If too few bytes were processed, consume the unprocessed data for this\n   * record as the parser may not have wanted/needed to use it */\n  if (processed_len < rdlength) {\n    ares__buf_consume(buf, rdlength - processed_len);\n  }\n\n\ndone:\n  ares_free(name);\n  return status;\n}",
          "fn_code_pos": [
            [
              990,
              0
            ],
            [
              1130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_rr",
            "parameters": {
              "buf": "ares__buf_t",
              "flags": "unsigned int",
              "sect": "ares_dns_section_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_parse_buf(ares__buf_t *buf, unsigned int flags,\n                                        ares_dns_record_t **dnsrec)\n{\n  ares_status_t  status;\n  unsigned short qdcount;\n  unsigned short ancount;\n  unsigned short nscount;\n  unsigned short arcount;\n  unsigned short i;\n\n  if (buf == NULL || dnsrec == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  /* Maximum DNS packet size is 64k, even over TCP */\n  if (ares__buf_len(buf) > 0xFFFF) {\n    return ARES_EFORMERR;\n  }\n\n  /* All communications inside of the domain protocol are carried in a single\n   * format called a message.  The top level format of message is divided\n   * into 5 sections (some of which are empty in certain cases) shown below:\n   *\n   * +---------------------+\n   * |        Header       |\n   * +---------------------+\n   * |       Question      | the question for the name server\n   * +---------------------+\n   * |        Answer       | RRs answering the question\n   * +---------------------+\n   * |      Authority      | RRs pointing toward an authority\n   * +---------------------+\n   * |      Additional     | RRs holding additional information\n   * +---------------------+\n   */\n\n  /* Parse header */\n  status = ares_dns_parse_header(buf, flags, dnsrec, &qdcount, &ancount,\n                                 &nscount, &arcount);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  /* Must have questions */\n  if (qdcount == 0) {\n    status = ARES_EBADRESP;\n    goto fail;\n  }\n\n  /* XXX: this should be controlled by a flag in case we want to allow\n   *      multiple questions.  I think mDNS allows this */\n  if (qdcount > 1) {\n    status = ARES_EBADRESP;\n    goto fail;\n  }\n\n  /* Parse questions */\n  for (i = 0; i < qdcount; i++) {\n    status = ares_dns_parse_qd(buf, *dnsrec);\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n\n  /* Parse Answers */\n  for (i = 0; i < ancount; i++) {\n    status = ares_dns_parse_rr(buf, flags, ARES_SECTION_ANSWER, *dnsrec);\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n\n  /* Parse Authority */\n  for (i = 0; i < nscount; i++) {\n    status = ares_dns_parse_rr(buf, flags, ARES_SECTION_AUTHORITY, *dnsrec);\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n\n  /* Parse Additional */\n  for (i = 0; i < arcount; i++) {\n    status = ares_dns_parse_rr(buf, flags, ARES_SECTION_ADDITIONAL, *dnsrec);\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n\n  /* Finalize rcode now that if we have OPT it is processed */\n  if (!ares_dns_rcode_isvalid((*dnsrec)->raw_rcode)) {\n    (*dnsrec)->rcode = ARES_RCODE_SERVFAIL;\n  } else {\n    (*dnsrec)->rcode = (ares_dns_rcode_t)(*dnsrec)->raw_rcode;\n  }\n\n  return ARES_SUCCESS;\n\nfail:\n  ares_dns_record_destroy(*dnsrec);\n  *dnsrec = NULL;\n  return status;\n}",
          "fn_code_pos": [
            [
              1132,
              0
            ],
            [
              1233,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse_buf",
            "parameters": {
              "buf": "ares__buf_t",
              "flags": "unsigned int",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_parse(const unsigned char *buf, size_t buf_len,\n                             unsigned int flags, ares_dns_record_t **dnsrec)\n{\n  ares__buf_t  *parser = NULL;\n  ares_status_t status;\n\n  if (buf == NULL || buf_len == 0 || dnsrec == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  parser = ares__buf_create_const(buf, buf_len);\n  if (parser == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  status = ares_dns_parse_buf(parser, flags, dnsrec);\n  ares__buf_destroy(parser);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              1235,
              0
            ],
            [
              1254,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_parse",
            "parameters": {
              "buf": "unsigned char",
              "buf_len": "size_t",
              "flags": "unsigned int",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct in_addr",
          {},
          "",
          [
            160,
            2
          ],
          [
            160,
            16
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            301,
            2
          ],
          [
            301,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <stdint.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__slist.c": {
      "fn_def_list": [
        {
          "fn_code": "ares__slist_t *ares__slist_create(ares_rand_state         *rand_state,\n                                  ares__slist_cmp_t        cmp,\n                                  ares__slist_destructor_t destruct)\n{\n  ares__slist_t *list;\n\n  if (rand_state == NULL || cmp == NULL) {\n    return NULL;\n  }\n\n  list = ares_malloc_zero(sizeof(*list));\n\n  if (list == NULL) {\n    return NULL;\n  }\n\n  list->rand_state = rand_state;\n  list->cmp        = cmp;\n  list->destruct   = destruct;\n\n  list->levels = ARES__SLIST_START_LEVELS;\n  list->head   = ares_malloc_zero(sizeof(*list->head) * list->levels);\n  if (list->head == NULL) {\n    ares_free(list);\n    return NULL;\n  }\n\n  return list;\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_create",
            "parameters": {
              "rand_state": "ares_rand_state",
              "cmp": "ares__slist_cmp_t",
              "destruct": "ares__slist_destructor_t"
            },
            "return_type": "ares__slist_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares__slist_coin_flip(ares__slist_t *list)\n{\n  size_t total_bits = sizeof(list->rand_data) * 8;\n  size_t bit;\n\n  /* Refill random data used for coin flips.  We pull this in 8 byte chunks.\n   * ares__rand_bytes() has some built-in caching of its own so we don't need\n   * to be excessive in caching ourselves.  Prefer to require less memory per\n   * skiplist */\n  if (list->rand_bits == 0) {\n    ares__rand_bytes(list->rand_state, list->rand_data,\n                     sizeof(list->rand_data));\n    list->rand_bits = total_bits;\n  }\n\n  bit = total_bits - list->rand_bits;\n  list->rand_bits--;\n\n  return (list->rand_data[bit / 8] & (1 << (bit % 8))) ? ARES_TRUE : ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_coin_flip",
            "parameters": {
              "list": "ares__slist_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "void ares__slist_replace_destructor(ares__slist_t           *list,\n                                    ares__slist_destructor_t destruct)\n{\n  if (list == NULL) {\n    return;\n  }\n\n  list->destruct = destruct;\n}",
          "fn_code_pos": [
            [
              107,
              0
            ],
            [
              115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_replace_destructor",
            "parameters": {
              "list": "ares__slist_t",
              "destruct": "ares__slist_destructor_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static size_t ares__slist_max_level(const ares__slist_t *list)\n{\n  size_t max_level = 0;\n\n  if (list->cnt + 1 <= (1 << ARES__SLIST_START_LEVELS)) {\n    max_level = ARES__SLIST_START_LEVELS;\n  } else {\n    max_level = ares__log2(ares__round_up_pow2(list->cnt + 1));\n  }\n\n  if (list->levels > max_level) {\n    max_level = list->levels;\n  }\n\n  return max_level;\n}",
          "fn_code_pos": [
            [
              117,
              0
            ],
            [
              132,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_max_level",
            "parameters": {
              "list": "ares__slist_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static size_t ares__slist_calc_level(ares__slist_t *list)\n{\n  size_t max_level = ares__slist_max_level(list);\n  size_t level;\n\n  for (level = 1; ares__slist_coin_flip(list) && level < max_level; level++)\n    ;\n\n  return level;\n}",
          "fn_code_pos": [
            [
              134,
              0
            ],
            [
              143,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_calc_level",
            "parameters": {
              "list": "ares__slist_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static void ares__slist_node_push(ares__slist_t *list, ares__slist_node_t *node)\n{\n  size_t              i;\n  ares__slist_node_t *left = NULL;\n\n  /* Scan from highest level in the slist, even if we're not using that number\n   * of levels for this entry as this is what makes it O(log n) */\n  for (i = list->levels; i-- > 0;) {\n    /* set left if left is NULL and the current node value is greater than the\n     * head at this level */\n    if (left == NULL && list->head[i] != NULL &&\n        list->cmp(node->data, list->head[i]->data) > 0) {\n      left = list->head[i];\n    }\n\n    if (left != NULL) {\n      /* scan forward to find our insertion point */\n      while (left->next[i] != NULL &&\n             list->cmp(node->data, left->next[i]->data) > 0) {\n        left = left->next[i];\n      }\n    }\n\n    /* search only as we didn't randomly select this number of levels */\n    if (i >= node->levels) {\n      continue;\n    }\n\n    if (left == NULL) {\n      /* head insertion */\n      node->next[i] = list->head[i];\n      node->prev[i] = NULL;\n      list->head[i] = node;\n    } else {\n      /* Chain */\n      node->next[i] = left->next[i];\n      node->prev[i] = left;\n      left->next[i] = node;\n    }\n\n    if (node->next[i] != NULL) {\n      /* chain prev */\n      node->next[i]->prev[i] = node;\n    } else {\n      if (i == 0) {\n        /* update tail */\n        list->tail = node;\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              145,
              0
            ],
            [
              195,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_push",
            "parameters": {
              "list": "ares__slist_t",
              "node": "ares__slist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__slist_node_t *ares__slist_insert(ares__slist_t *list, void *val)\n{\n  ares__slist_node_t *node = NULL;\n\n  if (list == NULL || val == NULL) {\n    return NULL;\n  }\n\n  node = ares_malloc_zero(sizeof(*node));\n\n  if (node == NULL) {\n    goto fail;\n  }\n\n  node->data   = val;\n  node->parent = list;\n\n  /* Randomly determine the number of levels we want to use */\n  node->levels = ares__slist_calc_level(list);\n\n  /* Allocate array of next and prev nodes for linking each level */\n  node->next = ares_malloc_zero(sizeof(*node->next) * node->levels);\n  if (node->next == NULL) {\n    goto fail;\n  }\n\n  node->prev = ares_malloc_zero(sizeof(*node->prev) * node->levels);\n  if (node->prev == NULL) {\n    goto fail;\n  }\n\n  /* If the number of levels is greater than we currently support in the slist,\n   * increase the count */\n  if (list->levels < node->levels) {\n    void *ptr =\n      ares_realloc_zero(list->head, sizeof(*list->head) * list->levels,\n                        sizeof(*list->head) * node->levels);\n    if (ptr == NULL) {\n      goto fail;\n    }\n\n    list->head   = ptr;\n    list->levels = node->levels;\n  }\n\n  ares__slist_node_push(list, node);\n\n  list->cnt++;\n\n  return node;\n\nfail:\n  if (node) {\n    ares_free(node->prev);\n    ares_free(node->next);\n    ares_free(node);\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              197,
              0
            ],
            [
              255,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_insert",
            "parameters": {
              "list": "ares__slist_t",
              "val": "void"
            },
            "return_type": "ares__slist_node_t"
          }
        },
        {
          "fn_code": "static void ares__slist_node_pop(ares__slist_node_t *node)\n{\n  ares__slist_t *list = node->parent;\n  size_t         i;\n\n  /* relink each node at each level */\n  for (i = node->levels; i-- > 0;) {\n    if (node->next[i] == NULL) {\n      if (i == 0) {\n        list->tail = node->prev[0];\n      }\n    } else {\n      node->next[i]->prev[i] = node->prev[i];\n    }\n\n    if (node->prev[i] == NULL) {\n      list->head[i] = node->next[i];\n    } else {\n      node->prev[i]->next[i] = node->next[i];\n    }\n  }\n\n  memset(node->next, 0, sizeof(*node->next) * node->levels);\n  memset(node->prev, 0, sizeof(*node->prev) * node->levels);\n}",
          "fn_code_pos": [
            [
              257,
              0
            ],
            [
              281,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_pop",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void *ares__slist_node_claim(ares__slist_node_t *node)\n{\n  ares__slist_t *list;\n  void          *val;\n\n  if (node == NULL) {\n    return NULL;\n  }\n\n  list = node->parent;\n  val  = node->data;\n\n  ares__slist_node_pop(node);\n\n  ares_free(node->next);\n  ares_free(node->prev);\n  ares_free(node);\n\n  list->cnt--;\n\n  return val;\n}",
          "fn_code_pos": [
            [
              283,
              0
            ],
            [
              304,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_claim",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__slist_node_reinsert(ares__slist_node_t *node)\n{\n  ares__slist_t *list;\n\n  if (node == NULL) {\n    return;\n  }\n\n  list = node->parent;\n\n  ares__slist_node_pop(node);\n  ares__slist_node_push(list, node);\n}",
          "fn_code_pos": [
            [
              306,
              0
            ],
            [
              318,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_reinsert",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__slist_node_t *ares__slist_node_find(ares__slist_t *list, const void *val)\n{\n  size_t              i;\n  ares__slist_node_t *node = NULL;\n  int                 rv   = -1;\n\n  if (list == NULL || val == NULL) {\n    return NULL;\n  }\n\n  /* Scan nodes starting at the highest level. For each level scan forward\n   * until the value is between the prior and next node, or if equal quit\n   * as we found a match */\n  for (i = list->levels; i-- > 0;) {\n    if (node == NULL) {\n      node = list->head[i];\n    }\n\n    if (node == NULL) {\n      continue;\n    }\n\n    do {\n      rv = list->cmp(val, node->data);\n\n      if (rv < 0) {\n        /* back off, our value is greater than current node reference */\n        node = node->prev[i];\n      } else if (rv > 0) {\n        /* move forward and try again. if it goes past, it will loop again and\n         * go to previous entry */\n        node = node->next[i];\n      }\n\n      /* rv == 0 will terminate loop */\n\n    } while (node != NULL && rv > 0);\n\n    /* Found a match, no need to continue */\n    if (rv == 0) {\n      break;\n    }\n  }\n\n  /* no match */\n  if (rv != 0) {\n    return NULL;\n  }\n\n  /* The list may have multiple entries that match.  They're guaranteed to be\n   * in order, but we're not guaranteed to have selected the _first_ matching\n   * node.  Lets scan backwards to find the first match */\n  while (node->prev[0] != NULL && list->cmp(node->prev[0]->data, val) == 0) {\n    node = node->prev[0];\n  }\n\n  return node;\n}",
          "fn_code_pos": [
            [
              320,
              0
            ],
            [
              377,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_find",
            "parameters": {
              "list": "ares__slist_t",
              "val": "void"
            },
            "return_type": "ares__slist_node_t"
          }
        },
        {
          "fn_code": "ares__slist_node_t *ares__slist_node_first(ares__slist_t *list)\n{\n  if (list == NULL) {\n    return NULL;\n  }\n\n  return list->head[0];\n}",
          "fn_code_pos": [
            [
              379,
              0
            ],
            [
              386,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_first",
            "parameters": {
              "list": "ares__slist_t"
            },
            "return_type": "ares__slist_node_t"
          }
        },
        {
          "fn_code": "ares__slist_node_t *ares__slist_node_last(ares__slist_t *list)\n{\n  if (list == NULL) {\n    return NULL;\n  }\n  return list->tail;\n}",
          "fn_code_pos": [
            [
              388,
              0
            ],
            [
              394,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_last",
            "parameters": {
              "list": "ares__slist_t"
            },
            "return_type": "ares__slist_node_t"
          }
        },
        {
          "fn_code": "ares__slist_node_t *ares__slist_node_next(ares__slist_node_t *node)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n  return node->next[0];\n}",
          "fn_code_pos": [
            [
              396,
              0
            ],
            [
              402,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_next",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": "ares__slist_node_t"
          }
        },
        {
          "fn_code": "ares__slist_node_t *ares__slist_node_prev(ares__slist_node_t *node)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n  return node->prev[0];\n}",
          "fn_code_pos": [
            [
              404,
              0
            ],
            [
              410,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_prev",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": "ares__slist_node_t"
          }
        },
        {
          "fn_code": "void *ares__slist_node_val(ares__slist_node_t *node)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n\n  return node->data;\n}",
          "fn_code_pos": [
            [
              412,
              0
            ],
            [
              419,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_val",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "size_t ares__slist_len(const ares__slist_t *list)\n{\n  if (list == NULL) {\n    return 0;\n  }\n  return list->cnt;\n}",
          "fn_code_pos": [
            [
              421,
              0
            ],
            [
              427,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_len",
            "parameters": {
              "list": "ares__slist_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares__slist_t *ares__slist_node_parent(ares__slist_node_t *node)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n  return node->parent;\n}",
          "fn_code_pos": [
            [
              429,
              0
            ],
            [
              435,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_parent",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": "ares__slist_t"
          }
        },
        {
          "fn_code": "void *ares__slist_first_val(ares__slist_t *list)\n{\n  return ares__slist_node_val(ares__slist_node_first(list));\n}",
          "fn_code_pos": [
            [
              437,
              0
            ],
            [
              440,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_first_val",
            "parameters": {
              "list": "ares__slist_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void *ares__slist_last_val(ares__slist_t *list)\n{\n  return ares__slist_node_val(ares__slist_node_last(list));\n}",
          "fn_code_pos": [
            [
              442,
              0
            ],
            [
              445,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_last_val",
            "parameters": {
              "list": "ares__slist_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__slist_node_destroy(ares__slist_node_t *node)\n{\n  ares__slist_destructor_t destruct;\n  void                    *val;\n\n  if (node == NULL) {\n    return;\n  }\n\n  destruct = node->parent->destruct;\n  val      = ares__slist_node_claim(node);\n\n  if (val != NULL && destruct != NULL) {\n    destruct(val);\n  }\n}",
          "fn_code_pos": [
            [
              447,
              0
            ],
            [
              462,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_destroy",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__slist_destroy(ares__slist_t *list)\n{\n  ares__slist_node_t *node;\n\n  if (list == NULL) {\n    return;\n  }\n\n  while ((node = ares__slist_node_first(list)) != NULL) {\n    ares__slist_node_destroy(node);\n  }\n\n  ares_free(list->head);\n  ares_free(list);\n}",
          "fn_code_pos": [
            [
              464,
              0
            ],
            [
              478,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_destroy",
            "parameters": {
              "list": "ares__slist_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares__slist_create(ares_rand_state         *rand_state,\n                                  ares__slist_cmp_t        cmp,\n                                  ares__slist_destructor_t destruct)",
          "fn_dec_pos": [
            [
              56,
              15
            ],
            [
              58,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_create",
            "parameters": {
              "rand_state": "ares_rand_state",
              "cmp": "ares__slist_cmp_t",
              "destruct": "ares__slist_destructor_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_insert(ares__slist_t *list, void *val)",
          "fn_dec_pos": [
            [
              197,
              20
            ],
            [
              197,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_insert",
            "parameters": {
              "list": "ares__slist_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_node_claim(ares__slist_node_t *node)",
          "fn_dec_pos": [
            [
              283,
              6
            ],
            [
              283,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_claim",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_node_find(ares__slist_t *list, const void *val)",
          "fn_dec_pos": [
            [
              320,
              20
            ],
            [
              320,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_find",
            "parameters": {
              "list": "ares__slist_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_node_first(ares__slist_t *list)",
          "fn_dec_pos": [
            [
              379,
              20
            ],
            [
              379,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_first",
            "parameters": {
              "list": "ares__slist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_node_last(ares__slist_t *list)",
          "fn_dec_pos": [
            [
              388,
              20
            ],
            [
              388,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_last",
            "parameters": {
              "list": "ares__slist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_node_next(ares__slist_node_t *node)",
          "fn_dec_pos": [
            [
              396,
              20
            ],
            [
              396,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_next",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_node_prev(ares__slist_node_t *node)",
          "fn_dec_pos": [
            [
              404,
              20
            ],
            [
              404,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_prev",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_node_val(ares__slist_node_t *node)",
          "fn_dec_pos": [
            [
              412,
              6
            ],
            [
              412,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_val",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_node_parent(ares__slist_node_t *node)",
          "fn_dec_pos": [
            [
              429,
              15
            ],
            [
              429,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_parent",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_first_val(ares__slist_t *list)",
          "fn_dec_pos": [
            [
              437,
              6
            ],
            [
              437,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_first_val",
            "parameters": {
              "list": "ares__slist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_last_val(ares__slist_t *list)",
          "fn_dec_pos": [
            [
              442,
              6
            ],
            [
              442,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_last_val",
            "parameters": {
              "list": "ares__slist_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares__slist {\n  ares_rand_state         *rand_state;\n  unsigned char            rand_data[8];\n  size_t                   rand_bits;\n\n  ares__slist_node_t     **head;\n  size_t                   levels;\n  ares__slist_node_t      *tail;\n\n  ares__slist_cmp_t        cmp;\n  ares__slist_destructor_t destruct;\n  size_t                   cnt;\n}",
          {
            "*rand_state": "ares_rand_state",
            "rand_data[8]": "unsigned char",
            "rand_bits": "size_t",
            "**head": "ares__slist_node_t",
            "levels": "size_t",
            "*tail": "ares__slist_node_t",
            "cmp": "ares__slist_cmp_t",
            "destruct": "ares__slist_destructor_t",
            "cnt": "size_t"
          },
          "ares__slist",
          [
            34,
            0
          ],
          [
            46,
            1
          ]
        ],
        [
          "struct ares__slist_node {\n  void                *data;\n  ares__slist_node_t **prev;\n  ares__slist_node_t **next;\n  size_t               levels;\n  ares__slist_t       *parent;\n}",
          {
            "*data": "void",
            "**prev": "ares__slist_node_t",
            "**next": "ares__slist_node_t",
            "levels": "size_t",
            "*parent": "ares__slist_t"
          },
          "ares__slist_node",
          [
            48,
            0
          ],
          [
            54,
            1
          ]
        ],
        [
          "struct ares__slist {\n  ares_rand_state         *rand_state;\n  unsigned char            rand_data[8];\n  size_t                   rand_bits;\n\n  ares__slist_node_t     **head;\n  size_t                   levels;\n  ares__slist_node_t      *tail;\n\n  ares__slist_cmp_t        cmp;\n  ares__slist_destructor_t destruct;\n  size_t                   cnt;\n}",
          {
            "*rand_state": "ares_rand_state",
            "rand_data[8]": "unsigned char",
            "rand_bits": "size_t",
            "**head": "ares__slist_node_t",
            "levels": "size_t",
            "*tail": "ares__slist_node_t",
            "cmp": "ares__slist_cmp_t",
            "destruct": "ares__slist_destructor_t",
            "cnt": "size_t"
          },
          "ares__slist",
          [
            34,
            0
          ],
          [
            46,
            1
          ]
        ],
        [
          "struct ares__slist_node {\n  void                *data;\n  ares__slist_node_t **prev;\n  ares__slist_node_t **next;\n  size_t               levels;\n  ares__slist_t       *parent;\n}",
          {
            "*data": "void",
            "**prev": "ares__slist_node_t",
            "**next": "ares__slist_node_t",
            "levels": "size_t",
            "*parent": "ares__slist_t"
          },
          "ares__slist_node",
          [
            48,
            0
          ],
          [
            54,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares__slist.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_event_win32.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares_iocpevent_signal(const ares_event_t *event)\n{\n  ares_event_thread_t *e  = event->e;\n  ares_evsys_win32_t  *ew = e->ev_sys_data;\n\n  if (e == NULL) {\n    return;\n  }\n\n  PostQueuedCompletionStatus(ew->iocp_handle, 0, (ULONG_PTR)event->data, NULL);\n}",
          "fn_code_pos": [
            [
              180,
              0
            ],
            [
              190,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iocpevent_signal",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_iocpevent_cb(ares_event_thread_t *e, ares_socket_t fd,\n                              void *data, ares_event_flags_t flags)\n{\n  (void)e;\n  (void)data;\n  (void)fd;\n  (void)flags;\n}",
          "fn_code_pos": [
            [
              192,
              0
            ],
            [
              199,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iocpevent_cb",
            "parameters": {
              "e": "ares_event_thread_t",
              "fd": "ares_socket_t",
              "data": "void",
              "flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_event_t *ares_iocpevent_create(ares_event_thread_t *e)\n{\n  ares_event_t *event = NULL;\n  ares_status_t status;\n\n  status =\n    ares_event_update(&event, e, ARES_EVENT_FLAG_OTHER, ares_iocpevent_cb,\n                      ARES_SOCKET_BAD, NULL, NULL, ares_iocpevent_signal);\n  if (status != ARES_SUCCESS) {\n    return NULL;\n  }\n\n  return event;\n}",
          "fn_code_pos": [
            [
              201,
              0
            ],
            [
              214,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iocpevent_create",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_event_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_win32_destroy(ares_event_thread_t *e)\n{\n  ares_evsys_win32_t *ew = NULL;\n\n  if (e == NULL) {\n    return;\n  }\n\n  ew = e->ev_sys_data;\n  if (ew == NULL) {\n    return;\n  }\n\n  if (ew->iocp_handle != NULL) {\n    CloseHandle(ew->iocp_handle);\n  }\n\n  ares_free(ew);\n  e->ev_sys_data = NULL;\n}",
          "fn_code_pos": [
            [
              216,
              0
            ],
            [
              235,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_destroy",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_win32_init(ares_event_thread_t *e)\n{\n  ares_evsys_win32_t *ew = NULL;\n  HMODULE             ntdll;\n\n  ew = ares_malloc_zero(sizeof(*ew));\n  if (ew == NULL) {\n    return ARES_FALSE;\n  }\n\n  e->ev_sys_data = ew;\n\n  /* All apps should have ntdll.dll already loaded, so just get a handle to\n   * this */\n  ntdll = GetModuleHandleA(\"ntdll.dll\");\n  if (ntdll == NULL) {\n    goto fail;\n  }\n\n  /* Load Internal symbols not typically accessible */\n  ew->NtDeviceIoControlFile = (NtDeviceIoControlFile_t)(void *)GetProcAddress(\n    ntdll, \"NtDeviceIoControlFile\");\n  ew->NtCancelIoFileEx =\n    (NtCancelIoFileEx_t)(void *)GetProcAddress(ntdll, \"NtCancelIoFileEx\");\n\n  if (ew->NtCancelIoFileEx == NULL || ew->NtDeviceIoControlFile == NULL) {\n    goto fail;\n  }\n\n  ew->iocp_handle = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);\n  if (ew->iocp_handle == NULL) {\n    goto fail;\n  }\n\n  e->ev_signal = ares_iocpevent_create(e);\n  if (e->ev_signal == NULL) {\n    goto fail;\n  }\n\n  return ARES_TRUE;\n\nfail:\n  ares_evsys_win32_destroy(e);\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              237,
              0
            ],
            [
              281,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_init",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_socket_t ares_evsys_win32_basesocket(ares_socket_t socket)\n{\n  while (1) {\n    DWORD         bytes; /* Not used */\n    ares_socket_t base_socket = ARES_SOCKET_BAD;\n    int           rv;\n\n    rv = WSAIoctl(socket, SIO_BASE_HANDLE, NULL, 0, &base_socket,\n                  sizeof(base_socket), &bytes, NULL, NULL);\n    if (rv != SOCKET_ERROR && base_socket != ARES_SOCKET_BAD) {\n      socket = base_socket;\n      break;\n    }\n\n    /* If we're here, an error occurred */\n    if (GetLastError() == WSAENOTSOCK) {\n      /* This is critical, exit */\n      return ARES_SOCKET_BAD;\n    }\n\n    /* Work around known bug in Komodia based LSPs, use ARES_BSP_HANDLE_POLL\n     * to retrieve the underlying socket to then loop and get the base socket:\n     *  https://docs.microsoft.com/en-us/windows/win32/winsock/winsock-ioctls\n     *  https://www.komodia.com/newwiki/index.php?title=Komodia%27s_Redirector_bug_fixes#Version_2.2.2.6\n     */\n    base_socket = ARES_SOCKET_BAD;\n    rv          = WSAIoctl(socket, SIO_BSP_HANDLE_POLL, NULL, 0, &base_socket,\n                           sizeof(base_socket), &bytes, NULL, NULL);\n\n    if (rv != SOCKET_ERROR && base_socket != ARES_SOCKET_BAD &&\n        base_socket != socket) {\n      socket = base_socket;\n      continue; /* loop! */\n    }\n\n    return ARES_SOCKET_BAD;\n  }\n\n  return socket;\n}",
          "fn_code_pos": [
            [
              283,
              0
            ],
            [
              322,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_basesocket",
            "parameters": {
              "socket": "ares_socket_t"
            },
            "return_type": "ares_socket_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_win32_afd_enqueue(ares_event_t      *event,\n                                                ares_event_flags_t flags)\n{\n  ares_event_thread_t          *e  = event->e;\n  ares_evsys_win32_t           *ew = e->ev_sys_data;\n  ares_evsys_win32_eventdata_t *ed = event->data;\n  NTSTATUS                      status;\n  IO_STATUS_BLOCK              *iosb_ptr;\n\n  if (e == NULL || ed == NULL || ew == NULL) {\n    return ARES_FALSE;\n  }\n\n  /* Enqueue AFD Poll */\n  ed->afd_poll_info.Exclusive         = TRUE;\n  ed->afd_poll_info.NumberOfHandles   = 1;\n  ed->afd_poll_info.Timeout.QuadPart  = LLONG_MAX;\n  ed->afd_poll_info.Handles[0].Handle = (HANDLE)ed->base_socket;\n  ed->afd_poll_info.Handles[0].Status = 0;\n  ed->afd_poll_info.Handles[0].Events = 0;\n\n  if (flags & ARES_EVENT_FLAG_READ) {\n    ed->afd_poll_info.Handles[0].Events |=\n      (AFD_POLL_RECEIVE | AFD_POLL_DISCONNECT | AFD_POLL_ACCEPT |\n       AFD_POLL_ABORT);\n  }\n  if (flags & ARES_EVENT_FLAG_WRITE) {\n    ed->afd_poll_info.Handles[0].Events |=\n      (AFD_POLL_SEND | AFD_POLL_CONNECT_FAIL);\n  }\n  if (flags == 0) {\n    ed->afd_poll_info.Handles[0].Events |= AFD_POLL_DISCONNECT;\n  }\n\n  memset(&ed->overlapped, 0, sizeof(ed->overlapped));\n  iosb_ptr         = (IO_STATUS_BLOCK *)&ed->overlapped.Internal;\n  iosb_ptr->Status = STATUS_PENDING;\n\n  status = ew->NtDeviceIoControlFile(\n    (HANDLE)ed->peer_socket, NULL, NULL, &ed->overlapped, iosb_ptr,\n    IOCTL_AFD_POLL, &ed->afd_poll_info, sizeof(ed->afd_poll_info),\n    &ed->afd_poll_info, sizeof(ed->afd_poll_info));\n  if (status != STATUS_SUCCESS && status != STATUS_PENDING) {\n    printf(\"%s(): failed to perform IOCTL_AFD_POLL operation\\n\", __FUNCTION__);\n    fflush(stdout);\n    return ARES_FALSE;\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              324,
              0
            ],
            [
              373,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_afd_enqueue",
            "parameters": {
              "event": "ares_event_t",
              "flags": "ares_event_flags_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_win32_afd_cancel(ares_evsys_win32_eventdata_t *ed)\n{\n  IO_STATUS_BLOCK    *iosb_ptr;\n  IO_STATUS_BLOCK     cancel_iosb;\n  ares_evsys_win32_t *ew;\n  NTSTATUS            status;\n\n  /* Detached due to destroy */\n  if (ed->event == NULL) {\n    return ARES_FALSE;\n  }\n\n  iosb_ptr = (IO_STATUS_BLOCK *)&ed->overlapped.Internal;\n  /* Not pending, nothing to do */\n  if (iosb_ptr->Status != STATUS_PENDING) {\n    return ARES_FALSE;\n  }\n\n  ew = ed->event->e->ev_sys_data;\n  status =\n    ew->NtCancelIoFileEx((HANDLE)ed->peer_socket, iosb_ptr, &cancel_iosb);\n\n  /* NtCancelIoFileEx() may return STATUS_NOT_FOUND if the operation completed\n   * just before calling NtCancelIoFileEx(), but we have not yet received the\n   * notifiction (but it should be queued for the next IOCP event).  */\n  if (status == STATUS_SUCCESS || status == STATUS_NOT_FOUND) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              375,
              0
            ],
            [
              405,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_afd_cancel",
            "parameters": {
              "ed": "ares_evsys_win32_eventdata_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_win32_eventdata_destroy(ares_evsys_win32_eventdata_t *ed)\n{\n  if (ed == NULL) {\n    return;\n  }\n\n  if (ed->peer_socket != ARES_SOCKET_BAD) {\n    closesocket(ed->peer_socket);\n  }\n\n  ares_free(ed);\n}",
          "fn_code_pos": [
            [
              407,
              0
            ],
            [
              418,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_eventdata_destroy",
            "parameters": {
              "ed": "ares_evsys_win32_eventdata_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_win32_event_add(ares_event_t *event)\n{\n  ares_event_thread_t          *e  = event->e;\n  ares_evsys_win32_t           *ew = e->ev_sys_data;\n  ares_evsys_win32_eventdata_t *ed;\n  WSAPROTOCOL_INFOW             protocol_info;\n\n  ed              = ares_malloc_zero(sizeof(*ed));\n  ed->event       = event;\n  ed->socket      = event->fd;\n  ed->base_socket = ARES_SOCKET_BAD;\n  ed->peer_socket = ARES_SOCKET_BAD;\n\n  /* Likely a signal event, not something we will directly handle.  We create\n   * the ares_evsys_win32_eventdata_t as the placeholder to use as the\n   * IOCP Completion Key */\n  if (ed->socket == ARES_SOCKET_BAD) {\n    event->data = ed;\n    return ARES_TRUE;\n  }\n\n  ed->base_socket = ares_evsys_win32_basesocket(ed->socket);\n  if (ed->base_socket == ARES_SOCKET_BAD) {\n    fprintf(stderr, \"%s(): could not determine base socket for fd %d\\n\",\n            __FUNCTION__, (int)event->fd);\n    ares_evsys_win32_eventdata_destroy(ed);\n    return ARES_FALSE;\n  }\n\n  /* Create a peer socket that supports OVERLAPPED so we can use IOCP on the\n   * socket handle */\n  if (WSADuplicateSocketW(ed->base_socket, GetCurrentProcessId(),\n                          &protocol_info) != 0) {\n    fprintf(stderr,\n            \"%s(): could not retrieve protocol info for creating peer socket\\n\",\n            __FUNCTION__);\n    ares_evsys_win32_eventdata_destroy(ed);\n    return ARES_FALSE;\n  }\n\n  ed->peer_socket =\n    WSASocketW(protocol_info.iAddressFamily, protocol_info.iSocketType,\n               protocol_info.iProtocol, &protocol_info, 0, WSA_FLAG_OVERLAPPED);\n  if (ed->peer_socket == ARES_SOCKET_BAD) {\n    fprintf(stderr, \"%s(): could not create peer socket\\n\", __FUNCTION__);\n    ares_evsys_win32_eventdata_destroy(ed);\n    return ARES_FALSE;\n  }\n\n  SetHandleInformation((HANDLE)ed->peer_socket, HANDLE_FLAG_INHERIT, 0);\n\n  if (CreateIoCompletionPort((HANDLE)ed->peer_socket, ew->iocp_handle,\n                             (ULONG_PTR)ed, 0) == NULL) {\n    fprintf(stderr, \"%s(): failed to bind peer socket to IOCP\\n\", __FUNCTION__);\n    ares_evsys_win32_eventdata_destroy(ed);\n    return ARES_FALSE;\n  }\n\n  event->data = ed;\n\n  if (!ares_evsys_win32_afd_enqueue(event, event->flags)) {\n    event->data = NULL;\n    ares_evsys_win32_eventdata_destroy(ed);\n    return ARES_FALSE;\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              420,
              0
            ],
            [
              487,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_event_add",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_win32_event_del(ares_event_t *event)\n{\n  ares_evsys_win32_eventdata_t *ed = event->data;\n  ares_event_thread_t          *e  = event->e;\n\n  if (event->fd == ARES_SOCKET_BAD || !e->isup || ed == NULL ||\n      !ares_evsys_win32_afd_cancel(ed)) {\n    /* Didn't need to enqueue a cancellation, for one of these reasons:\n     *  - Not an IOCP socket\n     *  - This is during shutdown of the event thread, no more signals can be\n     *    delivered.\n     *  - It has been determined there is no AFD POLL queued currently for the\n     *    socket.\n     */\n    ares_evsys_win32_eventdata_destroy(ed);\n    event->data = NULL;\n  } else {\n    /* Detach from event, so when the cancel event comes through,\n     * it will clean up */\n    ed->event   = NULL;\n    event->data = NULL;\n  }\n}",
          "fn_code_pos": [
            [
              489,
              0
            ],
            [
              511,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_event_del",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_evsys_win32_event_mod(ares_event_t      *event,\n                                       ares_event_flags_t new_flags)\n{\n  ares_evsys_win32_eventdata_t *ed = event->data;\n\n  /* Not for us */\n  if (event->fd == ARES_SOCKET_BAD || ed == NULL) {\n    return;\n  }\n\n  /* Try to cancel any current outstanding poll, if one is not running,\n   * go ahead and queue it up */\n  if (!ares_evsys_win32_afd_cancel(ed)) {\n    ares_evsys_win32_afd_enqueue(event, new_flags);\n  }\n}",
          "fn_code_pos": [
            [
              513,
              0
            ],
            [
              528,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_event_mod",
            "parameters": {
              "event": "ares_event_t",
              "new_flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static size_t ares_evsys_win32_wait(ares_event_thread_t *e,\n                                    unsigned long        timeout_ms)\n{\n  ares_evsys_win32_t *ew = e->ev_sys_data;\n  OVERLAPPED_ENTRY    entries[16];\n  ULONG               nentries = sizeof(entries) / sizeof(*entries);\n  BOOL                status;\n  size_t              i;\n  size_t              cnt = 0;\n\n  status = GetQueuedCompletionStatusEx(\n    ew->iocp_handle, entries, nentries, &nentries,\n    (timeout_ms == 0) ? INFINITE : (DWORD)timeout_ms, FALSE);\n\n  if (!status) {\n    return 0;\n  }\n\n  for (i = 0; i < (size_t)nentries; i++) {\n    ares_event_flags_t            flags = 0;\n    ares_evsys_win32_eventdata_t *ed =\n      (ares_evsys_win32_eventdata_t *)entries[i].lpCompletionKey;\n    ares_event_t *event = ed->event;\n\n    if (ed->socket == ARES_SOCKET_BAD) {\n      /* Some sort of signal event */\n      flags = ARES_EVENT_FLAG_OTHER;\n    } else {\n      /* Process events */\n      if (ed->afd_poll_info.NumberOfHandles > 0) {\n        if (ed->afd_poll_info.Handles[0].Events &\n            (AFD_POLL_RECEIVE | AFD_POLL_DISCONNECT | AFD_POLL_ACCEPT |\n             AFD_POLL_ABORT)) {\n          flags |= ARES_EVENT_FLAG_READ;\n        }\n        if (ed->afd_poll_info.Handles[0].Events &\n            (AFD_POLL_SEND | AFD_POLL_CONNECT_FAIL)) {\n          flags |= ARES_EVENT_FLAG_WRITE;\n        }\n\n        /* XXX: Handle ed->afd_poll_info.Handles[0].Events &\n         * AFD_POLL_LOCAL_CLOSE */\n      }\n\n      if (event == NULL) {\n        /* This means we need to cleanup the private event data as we've been\n         * detached */\n        ares_evsys_win32_eventdata_destroy(ed);\n      } else {\n        /* Re-enqueue so we can get more events on the socket */\n        ares_evsys_win32_afd_enqueue(event, event->flags);\n      }\n    }\n\n    if (event != NULL && flags != 0) {\n      cnt++;\n      event->cb(e, event->fd, event->data, flags);\n    }\n  }\n\n  return cnt;\n}",
          "fn_code_pos": [
            [
              530,
              0
            ],
            [
              591,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_win32_wait",
            "parameters": {
              "e": "ares_event_thread_t",
              "timeout_ms": "unsigned long"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_iocpevent_create(ares_event_thread_t *e)",
          "fn_dec_pos": [
            [
              201,
              21
            ],
            [
              201,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_iocpevent_create",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  /* Dynamically loaded symbols */\n  NtDeviceIoControlFile_t NtDeviceIoControlFile;\n  NtCancelIoFileEx_t      NtCancelIoFileEx;\n\n  /* Implementation details */\n  HANDLE                  iocp_handle;\n} ares_evsys_win32_t;",
          {
            "NtDeviceIoControlFile": "NtDeviceIoControlFile_t",
            "NtCancelIoFileEx": "NtCancelIoFileEx_t",
            "iocp_handle": "HANDLE"
          },
          "ares_evsys_win32_t",
          [
            154,
            0
          ],
          [
            161,
            21
          ]
        ],
        [
          "typedef struct {\n  /*! Pointer to parent event container */\n  ares_event_t *event;\n  /*! Socket passed in to monitor */\n  SOCKET        socket;\n  /*! Base socket derived from provided socket */\n  SOCKET        base_socket;\n  /*! New socket (duplicate base_socket handle) supporting OVERLAPPED operation\n   */\n  SOCKET        peer_socket;\n  /*! Structure for submitting AFD POLL requests (Internals!) */\n  AFD_POLL_INFO afd_poll_info;\n  /*! Overlapped structure submitted with AFD POLL requests and returned with\n   * IOCP results */\n  OVERLAPPED    overlapped;\n} ares_evsys_win32_eventdata_t;",
          {
            "*event": "ares_event_t",
            "socket": "SOCKET",
            "base_socket": "SOCKET",
            "peer_socket": "SOCKET",
            "afd_poll_info": "AFD_POLL_INFO",
            "overlapped": "OVERLAPPED"
          },
          "ares_evsys_win32_eventdata_t",
          [
            163,
            0
          ],
          [
            178,
            31
          ]
        ],
        [
          "typedef struct {\n  /* Dynamically loaded symbols */\n  NtDeviceIoControlFile_t NtDeviceIoControlFile;\n  NtCancelIoFileEx_t      NtCancelIoFileEx;\n\n  /* Implementation details */\n  HANDLE                  iocp_handle;\n} ares_evsys_win32_t;",
          {
            "NtDeviceIoControlFile": "NtDeviceIoControlFile_t",
            "NtCancelIoFileEx": "NtCancelIoFileEx_t",
            "iocp_handle": "HANDLE"
          },
          "ares_evsys_win32_t",
          [
            154,
            0
          ],
          [
            161,
            21
          ]
        ],
        [
          "typedef struct {\n  /*! Pointer to parent event container */\n  ares_event_t *event;\n  /*! Socket passed in to monitor */\n  SOCKET        socket;\n  /*! Base socket derived from provided socket */\n  SOCKET        base_socket;\n  /*! New socket (duplicate base_socket handle) supporting OVERLAPPED operation\n   */\n  SOCKET        peer_socket;\n  /*! Structure for submitting AFD POLL requests (Internals!) */\n  AFD_POLL_INFO afd_poll_info;\n  /*! Overlapped structure submitted with AFD POLL requests and returned with\n   * IOCP results */\n  OVERLAPPED    overlapped;\n} ares_evsys_win32_eventdata_t;",
          {
            "*event": "ares_event_t",
            "socket": "SOCKET",
            "base_socket": "SOCKET",
            "peer_socket": "SOCKET",
            "afd_poll_info": "AFD_POLL_INFO",
            "overlapped": "OVERLAPPED"
          },
          "ares_evsys_win32_eventdata_t",
          [
            163,
            0
          ],
          [
            178,
            31
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares_event.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"ares_event_win32.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <limits.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_query.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares_query_dnsrec_cb(void *arg, ares_status_t status,\n                                 size_t                   timeouts,\n                                 const ares_dns_record_t *dnsrec)\n{\n  ares_query_dnsrec_arg_t *qquery = arg;\n\n  if (status != ARES_SUCCESS) {\n    qquery->callback(qquery->arg, status, timeouts, dnsrec);\n  } else {\n    size_t           ancount;\n    ares_dns_rcode_t rcode;\n    /* Pull the response code and answer count from the packet and convert any\n     * errors.\n     */\n    rcode   = ares_dns_record_get_rcode(dnsrec);\n    ancount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER);\n    status  = ares_dns_query_reply_tostatus(rcode, ancount);\n    qquery->callback(qquery->arg, status, timeouts, dnsrec);\n  }\n  ares_free(qquery);\n}",
          "fn_code_pos": [
            [
              44,
              0
            ],
            [
              64,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_query_dnsrec_cb",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t ares_query_int(ares_channel_t *channel, const char *name,\n                                    ares_dns_class_t     dnsclass,\n                                    ares_dns_rec_type_t  type,\n                                    ares_callback_dnsrec callback, void *arg,\n                                    unsigned short *qid)\n{\n  ares_status_t            status;\n  ares_dns_record_t       *dnsrec = NULL;\n  ares_dns_flags_t         flags  = 0;\n  ares_query_dnsrec_arg_t *qquery = NULL;\n\n  if (channel == NULL || name == NULL || callback == NULL) {\n    status = ARES_EFORMERR;\n    if (callback != NULL) {\n      callback(arg, status, 0, NULL);\n    }\n    return status;\n  }\n\n  if (!(channel->flags & ARES_FLAG_NORECURSE)) {\n    flags |= ARES_FLAG_RD;\n  }\n\n  status = ares_dns_record_create_query(\n    &dnsrec, name, dnsclass, type, 0, flags,\n    (size_t)(channel->flags & ARES_FLAG_EDNS) ? channel->ednspsz : 0);\n  if (status != ARES_SUCCESS) {\n    callback(arg, status, 0, NULL);\n    return status;\n  }\n\n  qquery = ares_malloc(sizeof(*qquery));\n  if (qquery == NULL) {\n    status = ARES_ENOMEM;\n    callback(arg, status, 0, NULL);\n    ares_dns_record_destroy(dnsrec);\n    return status;\n  }\n\n  qquery->callback = callback;\n  qquery->arg      = arg;\n\n  /* Send it off.  qcallback will be called when we get an answer. */\n  status = ares_send_dnsrec(channel, dnsrec, ares_query_dnsrec_cb, qquery, qid);\n\n  ares_dns_record_destroy(dnsrec);\n  return status;\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              113,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_query_int",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "dnsclass": "ares_dns_class_t",
              "type": "ares_dns_rec_type_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void",
              "qid": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_query_dnsrec(ares_channel_t *channel, const char *name,\n                                ares_dns_class_t     dnsclass,\n                                ares_dns_rec_type_t  type,\n                                ares_callback_dnsrec callback, void *arg,\n                                unsigned short *qid)\n{\n  ares_status_t status;\n\n  if (channel == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  ares__channel_lock(channel);\n  status = ares_query_int(channel, name, dnsclass, type, callback, arg, qid);\n  ares__channel_unlock(channel);\n  return status;\n}",
          "fn_code_pos": [
            [
              115,
              0
            ],
            [
              131,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_query_dnsrec",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "dnsclass": "ares_dns_class_t",
              "type": "ares_dns_rec_type_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void",
              "qid": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares_query(ares_channel_t *channel, const char *name, int dnsclass,\n                int type, ares_callback callback, void *arg)\n{\n  void *carg = NULL;\n\n  if (channel == NULL) {\n    return;\n  }\n\n  carg = ares__dnsrec_convert_arg(callback, arg);\n  if (carg == NULL) {\n    callback(arg, ARES_ENOMEM, 0, NULL, 0);\n    return;\n  }\n\n  ares_query_dnsrec(channel, name, (ares_dns_class_t)dnsclass,\n                    (ares_dns_rec_type_t)type, ares__dnsrec_convert_cb, carg,\n                    NULL);\n}",
          "fn_code_pos": [
            [
              133,
              0
            ],
            [
              151,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_query",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "dnsclass": "int",
              "type": "int",
              "callback": "ares_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  ares_callback_dnsrec callback;\n  void                *arg;\n} ares_query_dnsrec_arg_t;",
          {
            "callback": "ares_callback_dnsrec",
            "*arg": "void"
          },
          "ares_query_dnsrec_arg_t",
          [
            39,
            0
          ],
          [
            42,
            26
          ]
        ],
        [
          "typedef struct {\n  ares_callback_dnsrec callback;\n  void                *arg;\n} ares_query_dnsrec_arg_t;",
          {
            "callback": "ares_callback_dnsrec",
            "*arg": "void"
          },
          "ares_query_dnsrec_arg_t",
          [
            39,
            0
          ],
          [
            42,
            26
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"ares_dns.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__htable_szvp.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares__htable_szvp_destroy(ares__htable_szvp_t *htable)\n{\n  if (htable == NULL) {\n    return;\n  }\n\n  ares__htable_destroy(htable->hash);\n  ares_free(htable);\n}",
          "fn_code_pos": [
            [
              42,
              0
            ],
            [
              50,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_szvp_destroy",
            "parameters": {
              "htable": "ares__htable_szvp_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static unsigned int hash_func(const void *key, unsigned int seed)\n{\n  const size_t *arg = key;\n  return ares__htable_hash_FNV1a((const unsigned char *)arg, sizeof(*arg),\n                                 seed);\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              57,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "hash_func",
            "parameters": {
              "key": "void",
              "seed": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static const void *bucket_key(const void *bucket)\n{\n  const ares__htable_szvp_bucket_t *arg = bucket;\n  return &arg->key;\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_key",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void bucket_free(void *bucket)\n{\n  ares__htable_szvp_bucket_t *arg = bucket;\n\n  if (arg->parent->free_val) {\n    arg->parent->free_val(arg->val);\n  }\n\n  ares_free(arg);\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              74,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_free",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t key_eq(const void *key1, const void *key2)\n{\n  const size_t *k1 = key1;\n  const size_t *k2 = key2;\n\n  if (*k1 == *k2) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "key_eq",
            "parameters": {
              "key1": "void",
              "key2": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__htable_szvp_t *\n  ares__htable_szvp_create(ares__htable_szvp_val_free_t val_free)\n{\n  ares__htable_szvp_t *htable = ares_malloc(sizeof(*htable));\n  if (htable == NULL) {\n    goto fail;\n  }\n\n  htable->hash =\n    ares__htable_create(hash_func, bucket_key, bucket_free, key_eq);\n  if (htable->hash == NULL) {\n    goto fail;\n  }\n\n  htable->free_val = val_free;\n\n  return htable;\n\nfail:\n  if (htable) {\n    ares__htable_destroy(htable->hash);\n    ares_free(htable);\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              88,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_szvp_create",
            "parameters": {
              "val_free": "ares__htable_szvp_val_free_t"
            },
            "return_type": "ares__htable_szvp_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares__htable_szvp_insert(ares__htable_szvp_t *htable, size_t key,\n                                     void *val)\n{\n  ares__htable_szvp_bucket_t *bucket = NULL;\n\n  if (htable == NULL) {\n    goto fail;\n  }\n\n  bucket = ares_malloc(sizeof(*bucket));\n  if (bucket == NULL) {\n    goto fail;\n  }\n\n  bucket->parent = htable;\n  bucket->key    = key;\n  bucket->val    = val;\n\n  if (!ares__htable_insert(htable->hash, bucket)) {\n    goto fail;\n  }\n\n  return ARES_TRUE;\n\nfail:\n  if (bucket) {\n    ares_free(bucket);\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              143,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_szvp_insert",
            "parameters": {
              "htable": "ares__htable_szvp_t",
              "key": "size_t",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares__htable_szvp_get(const ares__htable_szvp_t *htable, size_t key,\n                                  void **val)\n{\n  ares__htable_szvp_bucket_t *bucket = NULL;\n\n  if (val) {\n    *val = NULL;\n  }\n\n  if (htable == NULL) {\n    return ARES_FALSE;\n  }\n\n  bucket = ares__htable_get(htable->hash, &key);\n  if (bucket == NULL) {\n    return ARES_FALSE;\n  }\n\n  if (val) {\n    *val = bucket->val;\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              145,
              0
            ],
            [
              167,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_szvp_get",
            "parameters": {
              "htable": "ares__htable_szvp_t",
              "key": "size_t",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "void *ares__htable_szvp_get_direct(const ares__htable_szvp_t *htable,\n                                   size_t                     key)\n{\n  void *val = NULL;\n  ares__htable_szvp_get(htable, key, &val);\n  return val;\n}",
          "fn_code_pos": [
            [
              169,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_szvp_get_direct",
            "parameters": {
              "htable": "ares__htable_szvp_t",
              "key": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_bool_t ares__htable_szvp_remove(ares__htable_szvp_t *htable, size_t key)\n{\n  if (htable == NULL) {\n    return ARES_FALSE;\n  }\n\n  return ares__htable_remove(htable->hash, &key);\n}",
          "fn_code_pos": [
            [
              177,
              0
            ],
            [
              184,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_szvp_remove",
            "parameters": {
              "htable": "ares__htable_szvp_t",
              "key": "size_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "size_t ares__htable_szvp_num_keys(const ares__htable_szvp_t *htable)\n{\n  if (htable == NULL) {\n    return 0;\n  }\n  return ares__htable_num_keys(htable->hash);\n}",
          "fn_code_pos": [
            [
              186,
              0
            ],
            [
              192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_szvp_num_keys",
            "parameters": {
              "htable": "ares__htable_szvp_t"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "bucket_key(const void *bucket)",
          "fn_dec_pos": [
            [
              59,
              19
            ],
            [
              59,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_key",
            "parameters": {
              "bucket": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_szvp_create(ares__htable_szvp_val_free_t val_free)",
          "fn_dec_pos": [
            [
              89,
              2
            ],
            [
              89,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_szvp_create",
            "parameters": {
              "val_free": "ares__htable_szvp_val_free_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_szvp_get_direct(const ares__htable_szvp_t *htable,\n                                   size_t                     key)",
          "fn_dec_pos": [
            [
              169,
              6
            ],
            [
              170,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_szvp_get_direct",
            "parameters": {
              "htable": "ares__htable_szvp_t",
              "key": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares__htable_szvp {\n  ares__htable_szvp_val_free_t free_val;\n  ares__htable_t              *hash;\n}",
          {
            "free_val": "ares__htable_szvp_val_free_t",
            "*hash": "ares__htable_t"
          },
          "ares__htable_szvp",
          [
            31,
            0
          ],
          [
            34,
            1
          ]
        ],
        [
          "typedef struct {\n  size_t               key;\n  void                *val;\n  ares__htable_szvp_t *parent;\n} ares__htable_szvp_bucket_t;",
          {
            "key": "size_t",
            "*val": "void",
            "*parent": "ares__htable_szvp_t"
          },
          "ares__htable_szvp_bucket_t",
          [
            36,
            0
          ],
          [
            40,
            29
          ]
        ],
        [
          "struct ares__htable_szvp {\n  ares__htable_szvp_val_free_t free_val;\n  ares__htable_t              *hash;\n}",
          {
            "free_val": "ares__htable_szvp_val_free_t",
            "*hash": "ares__htable_t"
          },
          "ares__htable_szvp",
          [
            31,
            0
          ],
          [
            34,
            1
          ]
        ],
        [
          "typedef struct {\n  size_t               key;\n  void                *val;\n  ares__htable_szvp_t *parent;\n} ares__htable_szvp_bucket_t;",
          {
            "key": "size_t",
            "*val": "void",
            "*parent": "ares__htable_szvp_t"
          },
          "ares__htable_szvp_bucket_t",
          [
            36,
            0
          ],
          [
            40,
            29
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares__htable.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares__htable_szvp.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/date.c": {
      "fn_def_list": [
        {
          "fn_code": "Date::Date(int year, int month, int day) // constructor definition\n    : m_year{ year }\n    , m_month{ month }\n    , m_day{ day }\n{\n}",
          "fn_code_pos": [
            [
              2,
              0
            ],
            [
              7,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Date::Date",
            "parameters": {
              "year": "int",
              "month": "int",
              "day": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void Date::print() const // print function definition\n{\n    std::cout << \"Date(\" << m_year << \", \" << m_month << \", \" << m_day << \")\\n\";\n}",
          "fn_code_pos": [
            [
              9,
              0
            ],
            [
              12,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Date::print",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int Date::getYear() const { return m_year; }",
          "fn_code_pos": [
            [
              16,
              0
            ],
            [
              16,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Date::getYear",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int Date::getMonth() const { return m_month; }",
          "fn_code_pos": [
            [
              17,
              0
            ],
            [
              17,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Date::getMonth",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int Date::getDay() const { return m_day; }",
          "fn_code_pos": [
            [
              18,
              0
            ],
            [
              18,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Date::getDay",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"Date.h\"\n",
          [
            0,
            0
          ],
          [
            1,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_dns_mapping.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_bool_t ares_dns_opcode_isvalid(ares_dns_opcode_t opcode)\n{\n  switch (opcode) {\n    case ARES_OPCODE_QUERY:\n    case ARES_OPCODE_IQUERY:\n    case ARES_OPCODE_STATUS:\n    case ARES_OPCODE_NOTIFY:\n    case ARES_OPCODE_UPDATE:\n      return ARES_TRUE;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              29,
              0
            ],
            [
              40,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opcode_isvalid",
            "parameters": {
              "opcode": "ares_dns_opcode_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_rcode_isvalid(ares_dns_rcode_t rcode)\n{\n  switch (rcode) {\n    case ARES_RCODE_NOERROR:\n    case ARES_RCODE_FORMERR:\n    case ARES_RCODE_SERVFAIL:\n    case ARES_RCODE_NXDOMAIN:\n    case ARES_RCODE_NOTIMP:\n    case ARES_RCODE_REFUSED:\n    case ARES_RCODE_YXDOMAIN:\n    case ARES_RCODE_YXRRSET:\n    case ARES_RCODE_NXRRSET:\n    case ARES_RCODE_NOTAUTH:\n    case ARES_RCODE_NOTZONE:\n    case ARES_RCODE_DSOTYPEI:\n    case ARES_RCODE_BADSIG:\n    case ARES_RCODE_BADKEY:\n    case ARES_RCODE_BADTIME:\n    case ARES_RCODE_BADMODE:\n    case ARES_RCODE_BADNAME:\n    case ARES_RCODE_BADALG:\n    case ARES_RCODE_BADTRUNC:\n    case ARES_RCODE_BADCOOKIE:\n      return ARES_TRUE;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              42,
              0
            ],
            [
              68,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rcode_isvalid",
            "parameters": {
              "rcode": "ares_dns_rcode_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_flags_arevalid(unsigned short flags)\n{\n  unsigned short allflags = ARES_FLAG_QR | ARES_FLAG_AA | ARES_FLAG_TC |\n                            ARES_FLAG_RD | ARES_FLAG_RA | ARES_FLAG_AD |\n                            ARES_FLAG_CD;\n\n  if (flags & ~allflags) {\n    return ARES_FALSE;\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              70,
              0
            ],
            [
              81,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_flags_arevalid",
            "parameters": {
              "flags": "unsigned short"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_rec_type_isvalid(ares_dns_rec_type_t type,\n                                      ares_bool_t         is_query)\n{\n  switch (type) {\n    case ARES_REC_TYPE_A:\n    case ARES_REC_TYPE_NS:\n    case ARES_REC_TYPE_CNAME:\n    case ARES_REC_TYPE_SOA:\n    case ARES_REC_TYPE_PTR:\n    case ARES_REC_TYPE_HINFO:\n    case ARES_REC_TYPE_MX:\n    case ARES_REC_TYPE_TXT:\n    case ARES_REC_TYPE_AAAA:\n    case ARES_REC_TYPE_SRV:\n    case ARES_REC_TYPE_NAPTR:\n    case ARES_REC_TYPE_OPT:\n    case ARES_REC_TYPE_TLSA:\n    case ARES_REC_TYPE_SVCB:\n    case ARES_REC_TYPE_HTTPS:\n    case ARES_REC_TYPE_ANY:\n    case ARES_REC_TYPE_URI:\n    case ARES_REC_TYPE_CAA:\n      return ARES_TRUE;\n    case ARES_REC_TYPE_RAW_RR:\n      return is_query ? ARES_FALSE : ARES_TRUE;\n    default:\n      break;\n  }\n  return is_query ? ARES_TRUE : ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              83,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_type_isvalid",
            "parameters": {
              "type": "ares_dns_rec_type_t",
              "is_query": "ares_bool_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_rec_type_allow_name_compression(ares_dns_rec_type_t type)\n{\n  /* Only record types defined in RFC1035 allow name compression within the\n   * RDATA.  Otherwise nameservers that don't understand an RR may not be\n   * able to pass along the RR in a proper manner */\n  switch (type) {\n    case ARES_REC_TYPE_A:\n    case ARES_REC_TYPE_NS:\n    case ARES_REC_TYPE_CNAME:\n    case ARES_REC_TYPE_SOA:\n    case ARES_REC_TYPE_PTR:\n    case ARES_REC_TYPE_HINFO:\n    case ARES_REC_TYPE_MX:\n    case ARES_REC_TYPE_TXT:\n      return ARES_TRUE;\n    default:\n      break;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_type_allow_name_compression",
            "parameters": {
              "type": "ares_dns_rec_type_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_class_isvalid(ares_dns_class_t qclass,\n                                   ares_bool_t      is_query)\n{\n  switch (qclass) {\n    case ARES_CLASS_IN:\n    case ARES_CLASS_CHAOS:\n    case ARES_CLASS_HESOID:\n    case ARES_CLASS_NONE:\n      return ARES_TRUE;\n    case ARES_CLASS_ANY:\n      return is_query ? ARES_TRUE : ARES_FALSE;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              135,
              0
            ],
            [
              148,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_class_isvalid",
            "parameters": {
              "qclass": "ares_dns_class_t",
              "is_query": "ares_bool_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_section_isvalid(ares_dns_section_t sect)\n{\n  switch (sect) {\n    case ARES_SECTION_ANSWER:\n    case ARES_SECTION_AUTHORITY:\n    case ARES_SECTION_ADDITIONAL:\n      return ARES_TRUE;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              150,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_section_isvalid",
            "parameters": {
              "sect": "ares_dns_section_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_dns_rec_type_t ares_dns_rr_key_to_rec_type(ares_dns_rr_key_t key)\n{\n  /* NOTE: due to the way we've numerated the keys, we can simply divide by\n   *       100 to get the type rather than having to do a huge switch\n   *       statement.  That said, we do then validate the type returned is\n   *       valid in case something completely bogus is passed in */\n  ares_dns_rec_type_t type = key / 100;\n  if (!ares_dns_rec_type_isvalid(type, ARES_FALSE)) {\n    return 0;\n  }\n  return type;\n}",
          "fn_code_pos": [
            [
              161,
              0
            ],
            [
              172,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_key_to_rec_type",
            "parameters": {
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_dns_rec_type_t"
          }
        },
        {
          "fn_code": "const char *ares_dns_rec_type_tostr(ares_dns_rec_type_t type)\n{\n  switch (type) {\n    case ARES_REC_TYPE_A:\n      return \"A\";\n    case ARES_REC_TYPE_NS:\n      return \"NS\";\n    case ARES_REC_TYPE_CNAME:\n      return \"CNAME\";\n    case ARES_REC_TYPE_SOA:\n      return \"SOA\";\n    case ARES_REC_TYPE_PTR:\n      return \"PTR\";\n    case ARES_REC_TYPE_HINFO:\n      return \"HINFO\";\n    case ARES_REC_TYPE_MX:\n      return \"MX\";\n    case ARES_REC_TYPE_TXT:\n      return \"TXT\";\n    case ARES_REC_TYPE_AAAA:\n      return \"AAAA\";\n    case ARES_REC_TYPE_SRV:\n      return \"SRV\";\n    case ARES_REC_TYPE_NAPTR:\n      return \"NAPTR\";\n    case ARES_REC_TYPE_OPT:\n      return \"OPT\";\n    case ARES_REC_TYPE_TLSA:\n      return \"TLSA\";\n    case ARES_REC_TYPE_SVCB:\n      return \"SVCB\";\n    case ARES_REC_TYPE_HTTPS:\n      return \"HTTPS\";\n    case ARES_REC_TYPE_ANY:\n      return \"ANY\";\n    case ARES_REC_TYPE_URI:\n      return \"URI\";\n    case ARES_REC_TYPE_CAA:\n      return \"CAA\";\n    case ARES_REC_TYPE_RAW_RR:\n      return \"RAWRR\";\n  }\n  return \"UNKNOWN\";\n}",
          "fn_code_pos": [
            [
              174,
              0
            ],
            [
              217,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_type_tostr",
            "parameters": {
              "type": "ares_dns_rec_type_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "const char *ares_dns_class_tostr(ares_dns_class_t qclass)\n{\n  switch (qclass) {\n    case ARES_CLASS_IN:\n      return \"IN\";\n    case ARES_CLASS_CHAOS:\n      return \"CH\";\n    case ARES_CLASS_HESOID:\n      return \"HS\";\n    case ARES_CLASS_ANY:\n      return \"ANY\";\n    case ARES_CLASS_NONE:\n      return \"NONE\";\n  }\n  return \"UNKNOWN\";\n}",
          "fn_code_pos": [
            [
              219,
              0
            ],
            [
              234,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_class_tostr",
            "parameters": {
              "qclass": "ares_dns_class_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "const char *ares_dns_opcode_tostr(ares_dns_opcode_t opcode)\n{\n  switch (opcode) {\n    case ARES_OPCODE_QUERY:\n      return \"QUERY\";\n    case ARES_OPCODE_IQUERY:\n      return \"IQUERY\";\n    case ARES_OPCODE_STATUS:\n      return \"STATUS\";\n    case ARES_OPCODE_NOTIFY:\n      return \"NOTIFY\";\n    case ARES_OPCODE_UPDATE:\n      return \"UPDATE\";\n  }\n  return \"UNKNOWN\";\n}",
          "fn_code_pos": [
            [
              236,
              0
            ],
            [
              251,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opcode_tostr",
            "parameters": {
              "opcode": "ares_dns_opcode_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "const char *ares_dns_rr_key_tostr(ares_dns_rr_key_t key)\n{\n  switch (key) {\n    case ARES_RR_A_ADDR:\n      return \"ADDR\";\n\n    case ARES_RR_NS_NSDNAME:\n      return \"NSDNAME\";\n\n    case ARES_RR_CNAME_CNAME:\n      return \"CNAME\";\n\n    case ARES_RR_SOA_MNAME:\n      return \"MNAME\";\n\n    case ARES_RR_SOA_RNAME:\n      return \"RNAME\";\n\n    case ARES_RR_SOA_SERIAL:\n      return \"SERIAL\";\n\n    case ARES_RR_SOA_REFRESH:\n      return \"REFRESH\";\n\n    case ARES_RR_SOA_RETRY:\n      return \"RETRY\";\n\n    case ARES_RR_SOA_EXPIRE:\n      return \"EXPIRE\";\n\n    case ARES_RR_SOA_MINIMUM:\n      return \"MINIMUM\";\n\n    case ARES_RR_PTR_DNAME:\n      return \"DNAME\";\n\n    case ARES_RR_AAAA_ADDR:\n      return \"ADDR\";\n\n    case ARES_RR_HINFO_CPU:\n      return \"CPU\";\n\n    case ARES_RR_HINFO_OS:\n      return \"OS\";\n\n    case ARES_RR_MX_PREFERENCE:\n      return \"PREFERENCE\";\n\n    case ARES_RR_MX_EXCHANGE:\n      return \"EXCHANGE\";\n\n    case ARES_RR_TXT_DATA:\n      return \"DATA\";\n\n    case ARES_RR_SRV_PRIORITY:\n      return \"PRIORITY\";\n\n    case ARES_RR_SRV_WEIGHT:\n      return \"WEIGHT\";\n\n    case ARES_RR_SRV_PORT:\n      return \"PORT\";\n\n    case ARES_RR_SRV_TARGET:\n      return \"TARGET\";\n\n    case ARES_RR_NAPTR_ORDER:\n      return \"ORDER\";\n\n    case ARES_RR_NAPTR_PREFERENCE:\n      return \"PREFERENCE\";\n\n    case ARES_RR_NAPTR_FLAGS:\n      return \"FLAGS\";\n\n    case ARES_RR_NAPTR_SERVICES:\n      return \"SERVICES\";\n\n    case ARES_RR_NAPTR_REGEXP:\n      return \"REGEXP\";\n\n    case ARES_RR_NAPTR_REPLACEMENT:\n      return \"REPLACEMENT\";\n\n    case ARES_RR_OPT_UDP_SIZE:\n      return \"UDP_SIZE\";\n\n    case ARES_RR_OPT_VERSION:\n      return \"VERSION\";\n\n    case ARES_RR_OPT_FLAGS:\n      return \"FLAGS\";\n\n    case ARES_RR_OPT_OPTIONS:\n      return \"OPTIONS\";\n\n    case ARES_RR_TLSA_CERT_USAGE:\n      return \"CERT_USAGE\";\n\n    case ARES_RR_TLSA_SELECTOR:\n      return \"SELECTOR\";\n\n    case ARES_RR_TLSA_MATCH:\n      return \"MATCH\";\n\n    case ARES_RR_TLSA_DATA:\n      return \"DATA\";\n\n    case ARES_RR_SVCB_PRIORITY:\n      return \"PRIORITY\";\n\n    case ARES_RR_SVCB_TARGET:\n      return \"TARGET\";\n\n    case ARES_RR_SVCB_PARAMS:\n      return \"PARAMS\";\n\n    case ARES_RR_HTTPS_PRIORITY:\n      return \"PRIORITY\";\n\n    case ARES_RR_HTTPS_TARGET:\n      return \"TARGET\";\n\n    case ARES_RR_HTTPS_PARAMS:\n      return \"PARAMS\";\n\n    case ARES_RR_URI_PRIORITY:\n      return \"PRIORITY\";\n\n    case ARES_RR_URI_WEIGHT:\n      return \"WEIGHT\";\n\n    case ARES_RR_URI_TARGET:\n      return \"TARGET\";\n\n    case ARES_RR_CAA_CRITICAL:\n      return \"CRITICAL\";\n\n    case ARES_RR_CAA_TAG:\n      return \"TAG\";\n\n    case ARES_RR_CAA_VALUE:\n      return \"VALUE\";\n\n    case ARES_RR_RAW_RR_TYPE:\n      return \"TYPE\";\n\n    case ARES_RR_RAW_RR_DATA:\n      return \"DATA\";\n  }\n\n  return \"UNKNOWN\";\n}",
          "fn_code_pos": [
            [
              253,
              0
            ],
            [
              405,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_key_tostr",
            "parameters": {
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "ares_dns_datatype_t ares_dns_rr_key_datatype(ares_dns_rr_key_t key)\n{\n  switch (key) {\n    case ARES_RR_A_ADDR:\n      return ARES_DATATYPE_INADDR;\n\n    case ARES_RR_AAAA_ADDR:\n      return ARES_DATATYPE_INADDR6;\n\n    case ARES_RR_NS_NSDNAME:\n    case ARES_RR_CNAME_CNAME:\n    case ARES_RR_SOA_MNAME:\n    case ARES_RR_SOA_RNAME:\n    case ARES_RR_PTR_DNAME:\n    case ARES_RR_MX_EXCHANGE:\n    case ARES_RR_SRV_TARGET:\n    case ARES_RR_SVCB_TARGET:\n    case ARES_RR_HTTPS_TARGET:\n    case ARES_RR_NAPTR_REPLACEMENT:\n    case ARES_RR_URI_TARGET:\n      return ARES_DATATYPE_NAME;\n\n    case ARES_RR_HINFO_CPU:\n    case ARES_RR_HINFO_OS:\n    case ARES_RR_NAPTR_FLAGS:\n    case ARES_RR_NAPTR_SERVICES:\n    case ARES_RR_NAPTR_REGEXP:\n    case ARES_RR_CAA_TAG:\n      return ARES_DATATYPE_STR;\n\n    case ARES_RR_SOA_SERIAL:\n    case ARES_RR_SOA_REFRESH:\n    case ARES_RR_SOA_RETRY:\n    case ARES_RR_SOA_EXPIRE:\n    case ARES_RR_SOA_MINIMUM:\n      return ARES_DATATYPE_U32;\n\n    case ARES_RR_MX_PREFERENCE:\n    case ARES_RR_SRV_PRIORITY:\n    case ARES_RR_SRV_WEIGHT:\n    case ARES_RR_SRV_PORT:\n    case ARES_RR_NAPTR_ORDER:\n    case ARES_RR_NAPTR_PREFERENCE:\n    case ARES_RR_OPT_UDP_SIZE:\n    case ARES_RR_OPT_FLAGS:\n    case ARES_RR_SVCB_PRIORITY:\n    case ARES_RR_HTTPS_PRIORITY:\n    case ARES_RR_URI_PRIORITY:\n    case ARES_RR_URI_WEIGHT:\n    case ARES_RR_RAW_RR_TYPE:\n      return ARES_DATATYPE_U16;\n\n    case ARES_RR_OPT_VERSION:\n    case ARES_RR_TLSA_CERT_USAGE:\n    case ARES_RR_TLSA_SELECTOR:\n    case ARES_RR_TLSA_MATCH:\n    case ARES_RR_CAA_CRITICAL:\n      return ARES_DATATYPE_U8;\n\n    case ARES_RR_CAA_VALUE:\n    case ARES_RR_TXT_DATA:\n      return ARES_DATATYPE_BINP;\n\n    case ARES_RR_TLSA_DATA:\n    case ARES_RR_RAW_RR_DATA:\n      return ARES_DATATYPE_BIN;\n\n    case ARES_RR_OPT_OPTIONS:\n    case ARES_RR_SVCB_PARAMS:\n    case ARES_RR_HTTPS_PARAMS:\n      return ARES_DATATYPE_OPT;\n  }\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              407,
              0
            ],
            [
              481,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_key_datatype",
            "parameters": {
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_dns_datatype_t"
          }
        },
        {
          "fn_code": "const ares_dns_rr_key_t       *ares_dns_rr_get_keys(ares_dns_rec_type_t type,\n                                                    size_t             *cnt)\n{\n  if (cnt == NULL) {\n    return NULL;\n  }\n\n  *cnt = 0;\n\n  switch (type) {\n    case ARES_REC_TYPE_A:\n      *cnt = sizeof(rr_a_keys) / sizeof(*rr_a_keys);\n      return rr_a_keys;\n    case ARES_REC_TYPE_NS:\n      *cnt = sizeof(rr_ns_keys) / sizeof(*rr_ns_keys);\n      return rr_ns_keys;\n    case ARES_REC_TYPE_CNAME:\n      *cnt = sizeof(rr_cname_keys) / sizeof(*rr_cname_keys);\n      return rr_cname_keys;\n    case ARES_REC_TYPE_SOA:\n      *cnt = sizeof(rr_soa_keys) / sizeof(*rr_soa_keys);\n      return rr_soa_keys;\n    case ARES_REC_TYPE_PTR:\n      *cnt = sizeof(rr_ptr_keys) / sizeof(*rr_ptr_keys);\n      return rr_ptr_keys;\n    case ARES_REC_TYPE_HINFO:\n      *cnt = sizeof(rr_hinfo_keys) / sizeof(*rr_hinfo_keys);\n      return rr_hinfo_keys;\n    case ARES_REC_TYPE_MX:\n      *cnt = sizeof(rr_mx_keys) / sizeof(*rr_mx_keys);\n      return rr_mx_keys;\n    case ARES_REC_TYPE_TXT:\n      *cnt = sizeof(rr_txt_keys) / sizeof(*rr_txt_keys);\n      return rr_txt_keys;\n    case ARES_REC_TYPE_AAAA:\n      *cnt = sizeof(rr_aaaa_keys) / sizeof(*rr_aaaa_keys);\n      return rr_aaaa_keys;\n    case ARES_REC_TYPE_SRV:\n      *cnt = sizeof(rr_srv_keys) / sizeof(*rr_srv_keys);\n      return rr_srv_keys;\n    case ARES_REC_TYPE_NAPTR:\n      *cnt = sizeof(rr_naptr_keys) / sizeof(*rr_naptr_keys);\n      return rr_naptr_keys;\n    case ARES_REC_TYPE_OPT:\n      *cnt = sizeof(rr_opt_keys) / sizeof(*rr_opt_keys);\n      return rr_opt_keys;\n    case ARES_REC_TYPE_TLSA:\n      *cnt = sizeof(rr_tlsa_keys) / sizeof(*rr_tlsa_keys);\n      return rr_tlsa_keys;\n    case ARES_REC_TYPE_SVCB:\n      *cnt = sizeof(rr_svcb_keys) / sizeof(*rr_svcb_keys);\n      return rr_svcb_keys;\n    case ARES_REC_TYPE_HTTPS:\n      *cnt = sizeof(rr_https_keys) / sizeof(*rr_https_keys);\n      return rr_https_keys;\n    case ARES_REC_TYPE_ANY:\n      /* Not real */\n      break;\n    case ARES_REC_TYPE_URI:\n      *cnt = sizeof(rr_uri_keys) / sizeof(*rr_uri_keys);\n      return rr_uri_keys;\n    case ARES_REC_TYPE_CAA:\n      *cnt = sizeof(rr_caa_keys) / sizeof(*rr_caa_keys);\n      return rr_caa_keys;\n    case ARES_REC_TYPE_RAW_RR:\n      *cnt = sizeof(rr_raw_rr_keys) / sizeof(*rr_raw_rr_keys);\n      return rr_raw_rr_keys;\n  }\n\n  return NULL;\n}",
          "fn_code_pos": [
            [
              528,
              0
            ],
            [
              598,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_keys",
            "parameters": {
              "type": "ares_dns_rec_type_t",
              "cnt": "size_t"
            },
            "return_type": "ares_dns_rr_key_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_class_fromstr(ares_dns_class_t *qclass, const char *str)\n{\n  size_t i;\n\n  static const struct {\n    const char      *name;\n    ares_dns_class_t qclass;\n  } list[] = {\n    {\"IN\",    ARES_CLASS_IN    },\n    { \"CH\",   ARES_CLASS_CHAOS },\n    { \"HS\",   ARES_CLASS_HESOID},\n    { \"NONE\", ARES_CLASS_NONE  },\n    { \"ANY\",  ARES_CLASS_ANY   },\n    { NULL,   0                }\n  };\n\n  if (qclass == NULL || str == NULL) {\n    return ARES_FALSE;\n  }\n\n  for (i = 0; list[i].name != NULL; i++) {\n    if (strcasecmp(list[i].name, str) == 0) {\n      *qclass = list[i].qclass;\n      return ARES_TRUE;\n    }\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              600,
              0
            ],
            [
              627,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_class_fromstr",
            "parameters": {
              "qclass": "ares_dns_class_t",
              "str": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_rec_type_fromstr(ares_dns_rec_type_t *qtype,\n                                      const char          *str)\n{\n  size_t i;\n\n  static const struct {\n    const char         *name;\n    ares_dns_rec_type_t type;\n  } list[] = {\n    {\"A\",       ARES_REC_TYPE_A     },\n    { \"NS\",     ARES_REC_TYPE_NS    },\n    { \"CNAME\",  ARES_REC_TYPE_CNAME },\n    { \"SOA\",    ARES_REC_TYPE_SOA   },\n    { \"PTR\",    ARES_REC_TYPE_PTR   },\n    { \"HINFO\",  ARES_REC_TYPE_HINFO },\n    { \"MX\",     ARES_REC_TYPE_MX    },\n    { \"TXT\",    ARES_REC_TYPE_TXT   },\n    { \"AAAA\",   ARES_REC_TYPE_AAAA  },\n    { \"SRV\",    ARES_REC_TYPE_SRV   },\n    { \"NAPTR\",  ARES_REC_TYPE_NAPTR },\n    { \"OPT\",    ARES_REC_TYPE_OPT   },\n    { \"TLSA\",   ARES_REC_TYPE_TLSA  },\n    { \"SVCB\",   ARES_REC_TYPE_SVCB  },\n    { \"HTTPS\",  ARES_REC_TYPE_HTTPS },\n    { \"ANY\",    ARES_REC_TYPE_ANY   },\n    { \"URI\",    ARES_REC_TYPE_URI   },\n    { \"CAA\",    ARES_REC_TYPE_CAA   },\n    { \"RAW_RR\", ARES_REC_TYPE_RAW_RR},\n    { NULL,     0                   }\n  };\n\n  if (qtype == NULL || str == NULL) {\n    return ARES_FALSE;\n  }\n\n  for (i = 0; list[i].name != NULL; i++) {\n    if (strcasecmp(list[i].name, str) == 0) {\n      *qtype = list[i].type;\n      return ARES_TRUE;\n    }\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              629,
              0
            ],
            [
              671,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_type_fromstr",
            "parameters": {
              "qtype": "ares_dns_rec_type_t",
              "str": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "const char *ares_dns_section_tostr(ares_dns_section_t section)\n{\n  switch (section) {\n    case ARES_SECTION_ANSWER:\n      return \"ANSWER\";\n    case ARES_SECTION_AUTHORITY:\n      return \"AUTHORITY\";\n    case ARES_SECTION_ADDITIONAL:\n      return \"ADDITIONAL\";\n  }\n  return \"UNKNOWN\";\n}",
          "fn_code_pos": [
            [
              673,
              0
            ],
            [
              684,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_section_tostr",
            "parameters": {
              "section": "ares_dns_section_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static ares_dns_opt_datatype_t ares_dns_opt_get_type_opt(unsigned short opt)\n{\n  ares_opt_param_t param = (ares_opt_param_t)opt;\n  switch (param) {\n    case ARES_OPT_PARAM_LLQ:\n      /* Really it is u16 version, u16 opcode, u16 error, u64 id, u32 lease */\n      return ARES_OPT_DATATYPE_BIN;\n    case ARES_OPT_PARAM_UL:\n      return ARES_OPT_DATATYPE_U32;\n    case ARES_OPT_PARAM_NSID:\n      return ARES_OPT_DATATYPE_BIN;\n    case ARES_OPT_PARAM_DAU:\n      return ARES_OPT_DATATYPE_U8_LIST;\n    case ARES_OPT_PARAM_DHU:\n      return ARES_OPT_DATATYPE_U8_LIST;\n    case ARES_OPT_PARAM_N3U:\n      return ARES_OPT_DATATYPE_U8_LIST;\n    case ARES_OPT_PARAM_EDNS_CLIENT_SUBNET:\n      /* Really it is a u16 address family, u8 source prefix length,\n       * u8 scope prefix length, address */\n      return ARES_OPT_DATATYPE_BIN;\n    case ARES_OPT_PARAM_EDNS_EXPIRE:\n      return ARES_OPT_DATATYPE_U32;\n    case ARES_OPT_PARAM_COOKIE:\n      /* 8 bytes for client, 16-40 bytes for server */\n      return ARES_OPT_DATATYPE_BIN;\n    case ARES_OPT_PARAM_EDNS_TCP_KEEPALIVE:\n      /* Timeout in 100ms intervals */\n      return ARES_OPT_DATATYPE_U16;\n    case ARES_OPT_PARAM_PADDING:\n      /* Arbitrary padding */\n      return ARES_OPT_DATATYPE_BIN;\n    case ARES_OPT_PARAM_CHAIN:\n      return ARES_OPT_DATATYPE_NAME;\n    case ARES_OPT_PARAM_EDNS_KEY_TAG:\n      return ARES_OPT_DATATYPE_U16_LIST;\n    case ARES_OPT_PARAM_EXTENDED_DNS_ERROR:\n      /* Really 16bit code followed by textual message */\n      return ARES_OPT_DATATYPE_BIN;\n  }\n  return ARES_OPT_DATATYPE_BIN;\n}",
          "fn_code_pos": [
            [
              686,
              0
            ],
            [
              727,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_type_opt",
            "parameters": {
              "opt": "unsigned short"
            },
            "return_type": "ares_dns_opt_datatype_t"
          }
        },
        {
          "fn_code": "static ares_dns_opt_datatype_t ares_dns_opt_get_type_svcb(unsigned short opt)\n{\n  ares_svcb_param_t param = (ares_svcb_param_t)opt;\n  switch (param) {\n    case ARES_SVCB_PARAM_NO_DEFAULT_ALPN:\n      return ARES_OPT_DATATYPE_NONE;\n    case ARES_SVCB_PARAM_ECH:\n      return ARES_OPT_DATATYPE_BIN;\n    case ARES_SVCB_PARAM_MANDATORY:\n      return ARES_OPT_DATATYPE_U16_LIST;\n    case ARES_SVCB_PARAM_ALPN:\n      return ARES_OPT_DATATYPE_STR_LIST;\n    case ARES_SVCB_PARAM_PORT:\n      return ARES_OPT_DATATYPE_U16;\n    case ARES_SVCB_PARAM_IPV4HINT:\n      return ARES_OPT_DATATYPE_INADDR4_LIST;\n    case ARES_SVCB_PARAM_IPV6HINT:\n      return ARES_OPT_DATATYPE_INADDR6_LIST;\n  }\n  return ARES_OPT_DATATYPE_BIN;\n}",
          "fn_code_pos": [
            [
              729,
              0
            ],
            [
              749,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_type_svcb",
            "parameters": {
              "opt": "unsigned short"
            },
            "return_type": "ares_dns_opt_datatype_t"
          }
        },
        {
          "fn_code": "ares_dns_opt_datatype_t ares_dns_opt_get_datatype(ares_dns_rr_key_t key,\n                                                  unsigned short    opt)\n{\n  switch (key) {\n    case ARES_RR_OPT_OPTIONS:\n      return ares_dns_opt_get_type_opt(opt);\n    case ARES_RR_SVCB_PARAMS:\n    case ARES_RR_HTTPS_PARAMS:\n      return ares_dns_opt_get_type_svcb(opt);\n    default:\n      break;\n  }\n  return ARES_OPT_DATATYPE_BIN;\n}",
          "fn_code_pos": [
            [
              751,
              0
            ],
            [
              764,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_datatype",
            "parameters": {
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short"
            },
            "return_type": "ares_dns_opt_datatype_t"
          }
        },
        {
          "fn_code": "static const char *ares_dns_opt_get_name_opt(unsigned short opt)\n{\n  ares_opt_param_t param = (ares_opt_param_t)opt;\n  switch (param) {\n    case ARES_OPT_PARAM_LLQ:\n      return \"LLQ\";\n    case ARES_OPT_PARAM_UL:\n      return \"UL\";\n    case ARES_OPT_PARAM_NSID:\n      return \"NSID\";\n    case ARES_OPT_PARAM_DAU:\n      return \"DAU\";\n    case ARES_OPT_PARAM_DHU:\n      return \"DHU\";\n    case ARES_OPT_PARAM_N3U:\n      return \"N3U\";\n    case ARES_OPT_PARAM_EDNS_CLIENT_SUBNET:\n      return \"edns-client-subnet\";\n    case ARES_OPT_PARAM_EDNS_EXPIRE:\n      return \"edns-expire\";\n    case ARES_OPT_PARAM_COOKIE:\n      return \"COOKIE\";\n    case ARES_OPT_PARAM_EDNS_TCP_KEEPALIVE:\n      return \"edns-tcp-keepalive\";\n    case ARES_OPT_PARAM_PADDING:\n      return \"Padding\";\n    case ARES_OPT_PARAM_CHAIN:\n      return \"CHAIN\";\n    case ARES_OPT_PARAM_EDNS_KEY_TAG:\n      return \"edns-key-tag\";\n    case ARES_OPT_PARAM_EXTENDED_DNS_ERROR:\n      return \"extended-dns-error\";\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              766,
              0
            ],
            [
              800,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_name_opt",
            "parameters": {
              "opt": "unsigned short"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static const char *ares_dns_opt_get_name_svcb(unsigned short opt)\n{\n  ares_svcb_param_t param = (ares_svcb_param_t)opt;\n  switch (param) {\n    case ARES_SVCB_PARAM_NO_DEFAULT_ALPN:\n      return \"no-default-alpn\";\n    case ARES_SVCB_PARAM_ECH:\n      return \"ech\";\n    case ARES_SVCB_PARAM_MANDATORY:\n      return \"mandatory\";\n    case ARES_SVCB_PARAM_ALPN:\n      return \"alpn\";\n    case ARES_SVCB_PARAM_PORT:\n      return \"port\";\n    case ARES_SVCB_PARAM_IPV4HINT:\n      return \"ipv4hint\";\n    case ARES_SVCB_PARAM_IPV6HINT:\n      return \"ipv6hint\";\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              802,
              0
            ],
            [
              822,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_name_svcb",
            "parameters": {
              "opt": "unsigned short"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "const char *ares_dns_opt_get_name(ares_dns_rr_key_t key, unsigned short opt)\n{\n  switch (key) {\n    case ARES_RR_OPT_OPTIONS:\n      return ares_dns_opt_get_name_opt(opt);\n    case ARES_RR_SVCB_PARAMS:\n    case ARES_RR_HTTPS_PARAMS:\n      return ares_dns_opt_get_name_svcb(opt);\n    default:\n      break;\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              824,
              0
            ],
            [
              836,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_name",
            "parameters": {
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "const char *ares_dns_rcode_tostr(ares_dns_rcode_t rcode)\n{\n  switch (rcode) {\n    case ARES_RCODE_NOERROR:\n      return \"NOERROR\";\n    case ARES_RCODE_FORMERR:\n      return \"FORMERR\";\n    case ARES_RCODE_SERVFAIL:\n      return \"SERVFAIL\";\n    case ARES_RCODE_NXDOMAIN:\n      return \"NXDOMAIN\";\n    case ARES_RCODE_NOTIMP:\n      return \"NOTIMP\";\n    case ARES_RCODE_REFUSED:\n      return \"REFUSED\";\n    case ARES_RCODE_YXDOMAIN:\n      return \"YXDOMAIN\";\n    case ARES_RCODE_YXRRSET:\n      return \"YXRRSET\";\n    case ARES_RCODE_NXRRSET:\n      return \"NXRRSET\";\n    case ARES_RCODE_NOTAUTH:\n      return \"NOTAUTH\";\n    case ARES_RCODE_NOTZONE:\n      return \"NOTZONE\";\n    case ARES_RCODE_DSOTYPEI:\n      return \"DSOTYPEI\";\n    case ARES_RCODE_BADSIG:\n      return \"BADSIG\";\n    case ARES_RCODE_BADKEY:\n      return \"BADKEY\";\n    case ARES_RCODE_BADTIME:\n      return \"BADTIME\";\n    case ARES_RCODE_BADMODE:\n      return \"BADMODE\";\n    case ARES_RCODE_BADNAME:\n      return \"BADNAME\";\n    case ARES_RCODE_BADALG:\n      return \"BADALG\";\n    case ARES_RCODE_BADTRUNC:\n      return \"BADTRUNC\";\n    case ARES_RCODE_BADCOOKIE:\n      return \"BADCOOKIE\";\n  }\n\n  return \"UNKNOWN\";\n}",
          "fn_code_pos": [
            [
              838,
              0
            ],
            [
              884,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rcode_tostr",
            "parameters": {
              "rcode": "ares_dns_rcode_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_query_reply_tostatus(ares_dns_rcode_t rcode,\n                                            size_t           ancount)\n{\n  ares_status_t status = ARES_SUCCESS;\n\n  switch (rcode) {\n    case ARES_RCODE_NOERROR:\n      status = (ancount > 0) ? ARES_SUCCESS : ARES_ENODATA;\n      break;\n    case ARES_RCODE_FORMERR:\n      status = ARES_EFORMERR;\n      break;\n    case ARES_RCODE_SERVFAIL:\n      status = ARES_ESERVFAIL;\n      break;\n    case ARES_RCODE_NXDOMAIN:\n      status = ARES_ENOTFOUND;\n      break;\n    case ARES_RCODE_NOTIMP:\n      status = ARES_ENOTIMP;\n      break;\n    case ARES_RCODE_REFUSED:\n      status = ARES_EREFUSED;\n      break;\n    default:\n      break;\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              889,
              0
            ],
            [
              918,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_query_reply_tostatus",
            "parameters": {
              "rcode": "ares_dns_rcode_t",
              "ancount": "size_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_dns_rec_type_tostr(ares_dns_rec_type_t type)",
          "fn_dec_pos": [
            [
              174,
              12
            ],
            [
              174,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_type_tostr",
            "parameters": {
              "type": "ares_dns_rec_type_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_class_tostr(ares_dns_class_t qclass)",
          "fn_dec_pos": [
            [
              219,
              12
            ],
            [
              219,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_class_tostr",
            "parameters": {
              "qclass": "ares_dns_class_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_opcode_tostr(ares_dns_opcode_t opcode)",
          "fn_dec_pos": [
            [
              236,
              12
            ],
            [
              236,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opcode_tostr",
            "parameters": {
              "opcode": "ares_dns_opcode_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_key_tostr(ares_dns_rr_key_t key)",
          "fn_dec_pos": [
            [
              253,
              12
            ],
            [
              253,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_key_tostr",
            "parameters": {
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_keys(ares_dns_rec_type_t type,\n                                                    size_t             *cnt)",
          "fn_dec_pos": [
            [
              528,
              31
            ],
            [
              529,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_keys",
            "parameters": {
              "type": "ares_dns_rec_type_t",
              "cnt": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_section_tostr(ares_dns_section_t section)",
          "fn_dec_pos": [
            [
              673,
              12
            ],
            [
              673,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_section_tostr",
            "parameters": {
              "section": "ares_dns_section_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_opt_get_name_opt(unsigned short opt)",
          "fn_dec_pos": [
            [
              766,
              19
            ],
            [
              766,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_name_opt",
            "parameters": {
              "opt": "unsigned short"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_opt_get_name_svcb(unsigned short opt)",
          "fn_dec_pos": [
            [
              802,
              19
            ],
            [
              802,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_name_svcb",
            "parameters": {
              "opt": "unsigned short"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_opt_get_name(ares_dns_rr_key_t key, unsigned short opt)",
          "fn_dec_pos": [
            [
              824,
              12
            ],
            [
              824,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_name",
            "parameters": {
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rcode_tostr(ares_dns_rcode_t rcode)",
          "fn_dec_pos": [
            [
              838,
              12
            ],
            [
              838,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rcode_tostr",
            "parameters": {
              "rcode": "ares_dns_rcode_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct {\n    const char      *name;\n    ares_dns_class_t qclass;\n  }",
          {
            "char": "const",
            "qclass": "ares_dns_class_t"
          },
          "",
          [
            604,
            15
          ],
          [
            607,
            3
          ]
        ],
        [
          "struct {\n    const char         *name;\n    ares_dns_rec_type_t type;\n  }",
          {
            "char": "const",
            "type": "ares_dns_rec_type_t"
          },
          "",
          [
            634,
            15
          ],
          [
            637,
            3
          ]
        ],
        [
          "struct {\n    const char      *name;\n    ares_dns_class_t qclass;\n  }",
          {
            "char": "const",
            "qclass": "ares_dns_class_t"
          },
          "",
          [
            604,
            15
          ],
          [
            607,
            3
          ]
        ],
        [
          "struct {\n    const char         *name;\n    ares_dns_rec_type_t type;\n  }",
          {
            "char": "const",
            "type": "ares_dns_rec_type_t"
          },
          "",
          [
            634,
            15
          ],
          [
            637,
            3
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_strsplit.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares__strsplit_free(char **elms, size_t num_elm)\n{\n  size_t i;\n\n  if (elms == NULL) {\n    return;\n  }\n\n  for (i = 0; i < num_elm; i++) {\n    ares_free(elms[i]);\n  }\n  ares_free(elms);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              46,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__strsplit_free",
            "parameters": {
              "elms": "char",
              "num_elm": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "char **ares__strsplit_duplicate(char **elms, size_t num_elm)\n{\n  size_t i;\n  char **out;\n\n  if (elms == NULL || num_elm == 0) {\n    return NULL;\n  }\n\n  out = ares_malloc_zero(sizeof(*elms) * num_elm);\n  if (out == NULL) {\n    return NULL;\n  }\n\n  for (i = 0; i < num_elm; i++) {\n    out[i] = ares_strdup(elms[i]);\n    if (out[i] == NULL) {\n      ares__strsplit_free(out, num_elm);\n      return NULL;\n    }\n  }\n\n  return out;\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              71,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "char **ares__strsplit(const char *in, const char *delms, size_t *num_elm)\n{\n  ares_status_t       status;\n  ares__buf_t        *buf   = NULL;\n  ares__llist_t      *llist = NULL;\n  ares__llist_node_t *node;\n  char              **out = NULL;\n  size_t              cnt = 0;\n  size_t              idx = 0;\n\n  if (in == NULL || delms == NULL || num_elm == NULL) {\n    return NULL;\n  }\n\n  *num_elm = 0;\n\n  buf = ares__buf_create_const((const unsigned char *)in, ares_strlen(in));\n  if (buf == NULL) {\n    return NULL;\n  }\n\n  status = ares__buf_split(\n    buf, (const unsigned char *)delms, ares_strlen(delms),\n    ARES_BUF_SPLIT_NO_DUPLICATES | ARES_BUF_SPLIT_CASE_INSENSITIVE, 0, &llist);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  cnt = ares__llist_len(llist);\n  if (cnt == 0) {\n    status = ARES_EFORMERR;\n    goto done;\n  }\n\n\n  out = ares_malloc_zero(cnt * sizeof(*out));\n  if (out == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  for (node = ares__llist_node_first(llist); node != NULL;\n       node = ares__llist_node_next(node)) {\n    ares__buf_t *val  = ares__llist_node_val(node);\n    char        *temp = NULL;\n\n    status = ares__buf_fetch_str_dup(val, ares__buf_len(val), &temp);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    out[idx++] = temp;\n  }\n\n  *num_elm = cnt;\n  status   = ARES_SUCCESS;\n\ndone:\n  ares__llist_destroy(llist);\n  ares__buf_destroy(buf);\n  if (status != ARES_SUCCESS) {\n    ares__strsplit_free(out, cnt);\n    out = NULL;\n  }\n\n  return out;\n}",
          "fn_code_pos": [
            [
              73,
              0
            ],
            [
              139,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares__strsplit_duplicate(char **elms, size_t num_elm)",
          "fn_dec_pos": [
            [
              48,
              7
            ],
            [
              48,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__strsplit_duplicate",
            "parameters": {
              "elms": "char",
              "num_elm": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__strsplit(const char *in, const char *delms, size_t *num_elm)",
          "fn_dec_pos": [
            [
              73,
              7
            ],
            [
              73,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__strsplit",
            "parameters": {
              "in": "char",
              "delms": "char",
              "num_elm": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#  include <strings.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_setup.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_init.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_init(ares_channel_t **channelptr)\n{\n  return ares_init_options(channelptr, NULL, 0);\n}",
          "fn_code_pos": [
            [
              73,
              0
            ],
            [
              76,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init",
            "parameters": {
              "channelptr": "ares_channel_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int ares_query_timeout_cmp_cb(const void *arg1, const void *arg2)\n{\n  const struct query *q1 = arg1;\n  const struct query *q2 = arg2;\n\n  if (q1->timeout.tv_sec > q2->timeout.tv_sec) {\n    return 1;\n  }\n  if (q1->timeout.tv_sec < q2->timeout.tv_sec) {\n    return -1;\n  }\n\n  if (q1->timeout.tv_usec > q2->timeout.tv_usec) {\n    return 1;\n  }\n  if (q1->timeout.tv_usec < q2->timeout.tv_usec) {\n    return -1;\n  }\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              78,
              0
            ],
            [
              98,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_query_timeout_cmp_cb",
            "parameters": {
              "arg1": "void",
              "arg2": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int server_sort_cb(const void *data1, const void *data2)\n{\n  const struct server_state *s1 = data1;\n  const struct server_state *s2 = data2;\n\n  if (s1->consec_failures < s2->consec_failures) {\n    return -1;\n  }\n  if (s1->consec_failures > s2->consec_failures) {\n    return 1;\n  }\n  if (s1->idx < s2->idx) {\n    return -1;\n  }\n  if (s1->idx > s2->idx) {\n    return 1;\n  }\n  return 0;\n}",
          "fn_code_pos": [
            [
              100,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "server_sort_cb",
            "parameters": {
              "data1": "void",
              "data2": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void server_destroy_cb(void *data)\n{\n  if (data == NULL) {\n    return;\n  }\n  ares__destroy_server(data);\n}",
          "fn_code_pos": [
            [
              120,
              0
            ],
            [
              126,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "server_destroy_cb",
            "parameters": {
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t init_by_defaults(ares_channel_t *channel)\n{\n  char         *hostname = NULL;\n  ares_status_t rc       = ARES_SUCCESS;\n#ifdef HAVE_GETHOSTNAME\n  const char *dot;\n#endif\n  struct ares_addr addr;\n  ares__llist_t   *sconfig = NULL;\n\n  /* Enable EDNS by default */\n  if (!(channel->optmask & ARES_OPT_FLAGS)) {\n    channel->flags = ARES_FLAG_EDNS;\n  }\n  if (channel->ednspsz == 0) {\n    channel->ednspsz = EDNSPACKETSZ;\n  }\n\n  if (channel->timeout == 0) {\n    channel->timeout = DEFAULT_TIMEOUT;\n  }\n\n  if (channel->tries == 0) {\n    channel->tries = DEFAULT_TRIES;\n  }\n\n  if (ares__slist_len(channel->servers) == 0) {\n    /* Add a default local named server to the channel unless configured not\n     * to (in which case return an error).\n     */\n    if (channel->flags & ARES_FLAG_NO_DFLT_SVR) {\n      rc = ARES_ENOSERVER;\n      goto error;\n    }\n\n    addr.family            = AF_INET;\n    addr.addr.addr4.s_addr = htonl(INADDR_LOOPBACK);\n\n    rc = ares__sconfig_append(&sconfig, &addr, 0, 0, NULL);\n    if (rc != ARES_SUCCESS) {\n      goto error;\n    }\n\n    rc = ares__servers_update(channel, sconfig, ARES_FALSE);\n    ares__llist_destroy(sconfig);\n\n    if (rc != ARES_SUCCESS) {\n      goto error;\n    }\n  }\n\n#if defined(USE_WINSOCK)\n#  define toolong(x) (x == -1) && (SOCKERRNO == WSAEFAULT)\n#elif defined(ENAMETOOLONG)\n#  define toolong(x) \\\n    (x == -1) && ((SOCKERRNO == ENAMETOOLONG) || (SOCKERRNO == EINVAL))\n#else\n#  define toolong(x) (x == -1) && (SOCKERRNO == EINVAL)\n#endif\n\n  if (channel->ndomains == 0) {\n    /* Derive a default domain search list from the kernel hostname,\n     * or set it to empty if the hostname isn't helpful.\n     */\n#ifndef HAVE_GETHOSTNAME\n    channel->ndomains = 0; /* default to none */\n#else\n    GETHOSTNAME_TYPE_ARG2 lenv = 64;\n    size_t                len  = 64;\n    int                   res;\n    channel->ndomains = 0; /* default to none */\n\n    hostname = ares_malloc(len);\n    if (!hostname) {\n      rc = ARES_ENOMEM;\n      goto error;\n    }\n\n    do {\n      res = gethostname(hostname, lenv);\n\n      if (toolong(res)) {\n        char *p;\n        len  *= 2;\n        lenv *= 2;\n        p     = ares_realloc(hostname, len);\n        if (!p) {\n          rc = ARES_ENOMEM;\n          goto error;\n        }\n        hostname = p;\n        continue;\n      } else if (res) {\n        /* Lets not treat a gethostname failure as critical, since we\n         * are ok if gethostname doesn't even exist */\n        *hostname = '\\0';\n        break;\n      }\n\n    } while (res != 0);\n\n    dot = strchr(hostname, '.');\n    if (dot) {\n      /* a dot was found */\n      channel->domains = ares_malloc(sizeof(char *));\n      if (!channel->domains) {\n        rc = ARES_ENOMEM;\n        goto error;\n      }\n      channel->domains[0] = ares_strdup(dot + 1);\n      if (!channel->domains[0]) {\n        rc = ARES_ENOMEM;\n        goto error;\n      }\n      channel->ndomains = 1;\n    }\n#endif\n  }\n\n  if (channel->nsort == 0) {\n    channel->sortlist = NULL;\n  }\n\n  if (!channel->lookups) {\n    channel->lookups = ares_strdup(\"fb\");\n    if (!channel->lookups) {\n      rc = ARES_ENOMEM;\n    }\n  }\n\n  /* Set default fields for server failover behavior */\n  if (!(channel->optmask & ARES_OPT_SERVER_FAILOVER)) {\n    channel->server_retry_chance = DEFAULT_SERVER_RETRY_CHANCE;\n    channel->server_retry_delay  = DEFAULT_SERVER_RETRY_DELAY;\n  }\n\nerror:\n  if (hostname) {\n    ares_free(hostname);\n  }\n\n  return rc;\n}",
          "fn_code_pos": [
            [
              128,
              0
            ],
            [
              270,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "init_by_defaults",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "int ares_init_options(ares_channel_t           **channelptr,\n                      const struct ares_options *options, int optmask)\n{\n  ares_channel_t *channel;\n  ares_status_t   status = ARES_SUCCESS;\n\n  if (ares_library_initialized() != ARES_SUCCESS) {\n    return ARES_ENOTINITIALIZED; /* LCOV_EXCL_LINE: n/a on non-WinSock */\n  }\n\n  channel = ares_malloc_zero(sizeof(*channel));\n  if (!channel) {\n    *channelptr = NULL;\n    return ARES_ENOMEM;\n  }\n\n  /* One option where zero is valid, so set default value here */\n  channel->ndots = 1;\n\n  status = ares__channel_threading_init(channel);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Generate random key */\n  channel->rand_state = ares__init_rand_state();\n  if (channel->rand_state == NULL) {\n    status = ARES_ENOMEM;\n    DEBUGF(fprintf(stderr, \"Error: init_id_key failed: %s\\n\",\n                   ares_strerror(status)));\n    goto done;\n  }\n\n  /* Initialize Server List */\n  channel->servers =\n    ares__slist_create(channel->rand_state, server_sort_cb, server_destroy_cb);\n  if (channel->servers == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  /* Initialize our lists of queries */\n  channel->all_queries = ares__llist_create(NULL);\n  if (channel->all_queries == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  channel->queries_by_qid = ares__htable_szvp_create(NULL);\n  if (channel->queries_by_qid == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  channel->queries_by_timeout =\n    ares__slist_create(channel->rand_state, ares_query_timeout_cmp_cb, NULL);\n  if (channel->queries_by_timeout == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  channel->connnode_by_socket = ares__htable_asvp_create(NULL);\n  if (channel->connnode_by_socket == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  /* Initialize configuration by each of the four sources, from highest\n   * precedence to lowest.\n   */\n\n  status = ares__init_by_options(channel, options, optmask);\n  if (status != ARES_SUCCESS) {\n    DEBUGF(fprintf(stderr, \"Error: init_by_options failed: %s\\n\",\n                   ares_strerror(status)));\n    /* If we fail to apply user-specified options, fail the whole init process\n     */\n    goto done;\n  }\n\n  if (channel->qcache_max_ttl > 0) {\n    status = ares__qcache_create(channel->rand_state, channel->qcache_max_ttl,\n                                 &channel->qcache);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\n  if (status == ARES_SUCCESS) {\n    status = ares__init_by_sysconfig(channel);\n    if (status != ARES_SUCCESS) {\n      DEBUGF(fprintf(stderr, \"Error: init_by_sysconfig failed: %s\\n\",\n                     ares_strerror(status)));\n    }\n  }\n\n  /*\n   * No matter what failed or succeeded, seed defaults to provide\n   * useful behavior for things that we missed.\n   */\n  status = init_by_defaults(channel);\n  if (status != ARES_SUCCESS) {\n    DEBUGF(fprintf(stderr, \"Error: init_by_defaults failed: %s\\n\",\n                   ares_strerror(status)));\n    goto done;\n  }\n\n  /* Initialize the event thread */\n  if (channel->optmask & ARES_OPT_EVENT_THREAD) {\n    status = ares_event_thread_init(channel);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_destroy(channel);\n    return (int)status;\n  }\n\n  *channelptr = channel;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              272,
              0
            ],
            [
              395,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_options",
            "parameters": {
              "channelptr": "ares_channel_t",
              "options": "struct ares_options",
              "optmask": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_status_t ares_reinit(ares_channel_t *channel)\n{\n  ares_status_t status;\n\n  if (channel == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  ares__channel_lock(channel);\n\n  status = ares__init_by_sysconfig(channel);\n  if (status != ARES_SUCCESS) {\n    DEBUGF(fprintf(stderr, \"Error: init_by_sysconfig failed: %s\\n\",\n                   ares_strerror(status)));\n  }\n\n  /* Flush cached queries on reinit */\n  if (channel->qcache) {\n    ares__qcache_flush(channel->qcache);\n  }\n\n  ares__channel_unlock(channel);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              397,
              0
            ],
            [
              421,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_reinit",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "int ares_dup(ares_channel_t **dest, ares_channel_t *src)\n{\n  struct ares_options opts;\n  ares_status_t       rc;\n  int                 optmask;\n\n  if (dest == NULL || src == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *dest = NULL; /* in case of failure return NULL explicitly */\n\n  ares__channel_lock(src);\n  /* First get the options supported by the old ares_save_options() function,\n     which is most of them */\n  rc = (ares_status_t)ares_save_options(src, &opts, &optmask);\n  if (rc != ARES_SUCCESS) {\n    ares_destroy_options(&opts);\n    goto done;\n  }\n\n  /* Then create the new channel with those options */\n  rc = (ares_status_t)ares_init_options(dest, &opts, optmask);\n\n  /* destroy the options copy to not leak any memory */\n  ares_destroy_options(&opts);\n\n  if (rc != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Now clone the options that ares_save_options() doesn't support, but are\n   * user-provided */\n  (*dest)->sock_create_cb       = src->sock_create_cb;\n  (*dest)->sock_create_cb_data  = src->sock_create_cb_data;\n  (*dest)->sock_config_cb       = src->sock_config_cb;\n  (*dest)->sock_config_cb_data  = src->sock_config_cb_data;\n  (*dest)->sock_funcs           = src->sock_funcs;\n  (*dest)->sock_func_cb_data    = src->sock_func_cb_data;\n  (*dest)->server_state_cb      = src->server_state_cb;\n  (*dest)->server_state_cb_data = src->server_state_cb_data;\n\n  ares_strcpy((*dest)->local_dev_name, src->local_dev_name,\n              sizeof((*dest)->local_dev_name));\n  (*dest)->local_ip4 = src->local_ip4;\n  memcpy((*dest)->local_ip6, src->local_ip6, sizeof(src->local_ip6));\n\n\n  /* Servers are a bit unique as ares_init_options() only allows ipv4 servers\n   * and not a port per server, but there are other user specified ways, that\n   * too will toggle the optmask ARES_OPT_SERVERS to let us know.  If that's\n   * the case, pull them in.\n   *\n   * We don't want to clone system-configuration servers though.\n   *\n   * We must use the \"csv\" format to get things like link-local address support\n   */\n\n  if (optmask & ARES_OPT_SERVERS) {\n    char *csv = ares_get_servers_csv(src);\n    if (csv == NULL) {\n      ares_destroy(*dest);\n      *dest = NULL;\n      rc    = ARES_ENOMEM;\n      goto done;\n    }\n\n    rc = (ares_status_t)ares_set_servers_ports_csv(*dest, csv);\n    ares_free_string(csv);\n    if (rc != ARES_SUCCESS) {\n      ares_destroy(*dest);\n      *dest = NULL;\n      goto done;\n    }\n  }\n\n  rc = ARES_SUCCESS;\ndone:\n  ares__channel_unlock(src);\n  return (int)rc; /* everything went fine */\n}",
          "fn_code_pos": [
            [
              425,
              0
            ],
            [
              505,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dup",
            "parameters": {
              "dest": "ares_channel_t",
              "src": "ares_channel_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void ares_set_local_ip4(ares_channel_t *channel, unsigned int local_ip)\n{\n  if (channel == NULL) {\n    return;\n  }\n  ares__channel_lock(channel);\n  channel->local_ip4 = local_ip;\n  ares__channel_unlock(channel);\n}",
          "fn_code_pos": [
            [
              507,
              0
            ],
            [
              515,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_local_ip4",
            "parameters": {
              "channel": "ares_channel_t",
              "local_ip": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_set_local_ip6(ares_channel_t *channel, const unsigned char *local_ip6)\n{\n  if (channel == NULL) {\n    return;\n  }\n  ares__channel_lock(channel);\n  memcpy(&channel->local_ip6, local_ip6, sizeof(channel->local_ip6));\n  ares__channel_unlock(channel);\n}",
          "fn_code_pos": [
            [
              518,
              0
            ],
            [
              526,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_local_ip6",
            "parameters": {
              "channel": "ares_channel_t",
              "local_ip6": "unsigned char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_set_local_dev(ares_channel_t *channel, const char *local_dev_name)\n{\n  if (channel == NULL) {\n    return;\n  }\n\n  ares__channel_lock(channel);\n  ares_strcpy(channel->local_dev_name, local_dev_name,\n              sizeof(channel->local_dev_name));\n  channel->local_dev_name[sizeof(channel->local_dev_name) - 1] = 0;\n  ares__channel_unlock(channel);\n}",
          "fn_code_pos": [
            [
              529,
              0
            ],
            [
              540,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_local_dev",
            "parameters": {
              "channel": "ares_channel_t",
              "local_dev_name": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int ares_set_sortlist(ares_channel_t *channel, const char *sortstr)\n{\n  size_t           nsort    = 0;\n  struct apattern *sortlist = NULL;\n  ares_status_t    status;\n\n  if (!channel) {\n    return ARES_ENODATA;\n  }\n  ares__channel_lock(channel);\n\n  status = ares__parse_sortlist(&sortlist, &nsort, sortstr);\n  if (status == ARES_SUCCESS && sortlist) {\n    if (channel->sortlist) {\n      ares_free(channel->sortlist);\n    }\n    channel->sortlist = sortlist;\n    channel->nsort    = nsort;\n\n    /* Save sortlist as if it was passed in as an option */\n    channel->optmask |= ARES_OPT_SORTLIST;\n  }\n  ares__channel_unlock(channel);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              542,
              0
            ],
            [
              566,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_sortlist",
            "parameters": {
              "channel": "ares_channel_t",
              "sortstr": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct query",
          {},
          "",
          [
            80,
            8
          ],
          [
            80,
            20
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            81,
            8
          ],
          [
            81,
            20
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            102,
            8
          ],
          [
            102,
            27
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            103,
            8
          ],
          [
            103,
            27
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            135,
            2
          ],
          [
            135,
            18
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            273,
            28
          ],
          [
            273,
            47
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            427,
            2
          ],
          [
            427,
            21
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            545,
            2
          ],
          [
            545,
            17
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <sys/param.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#  include <sys/system_properties.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#  include \"ares_android.h\"\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#  include <resolv.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#  include <iphlpapi.h>\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            64,
            0
          ],
          [
            65,
            0
          ]
        ],
        [
          "#include \"ares_platform.h\"\n",
          [
            65,
            0
          ],
          [
            66,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            66,
            0
          ],
          [
            67,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_timeout.c": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares__timeval_remaining(struct timeval       *remaining,\n                             const struct timeval *now,\n                             const struct timeval *tout)",
          "fn_dec_pos": [
            [
              36,
              5
            ],
            [
              38,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__timeval_remaining",
            "parameters": {
              "remaining": "struct timeval",
              "now": "struct timeval",
              "tout": "struct timeval"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct timeval",
          {},
          "",
          [
            36,
            29
          ],
          [
            36,
            43
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            37,
            35
          ],
          [
            37,
            49
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            38,
            35
          ],
          [
            38,
            49
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <limits.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_parse_uri_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_parse_uri_reply(const unsigned char *abuf, int alen_int,\n                         struct ares_uri_reply **uri_out)\n{\n  ares_status_t          status;\n  size_t                 alen;\n  struct ares_uri_reply *uri_head = NULL;\n  struct ares_uri_reply *uri_last = NULL;\n  struct ares_uri_reply *uri_curr;\n  ares_dns_record_t     *dnsrec = NULL;\n  size_t                 i;\n\n  *uri_out = NULL;\n\n  if (alen_int < 0) {\n    return ARES_EBADRESP;\n  }\n\n  alen = (size_t)alen_int;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP;\n      goto done;\n    }\n\n    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN ||\n        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_URI) {\n      continue;\n    }\n\n    /* Allocate storage for this URI answer appending it to the list */\n    uri_curr = ares_malloc_data(ARES_DATATYPE_URI_REPLY);\n    if (uri_curr == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n\n    /* Link in the record */\n    if (uri_last) {\n      uri_last->next = uri_curr;\n    } else {\n      uri_head = uri_curr;\n    }\n    uri_last = uri_curr;\n\n\n    uri_curr->priority = ares_dns_rr_get_u16(rr, ARES_RR_URI_PRIORITY);\n    uri_curr->weight   = ares_dns_rr_get_u16(rr, ARES_RR_URI_WEIGHT);\n    uri_curr->uri = ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_URI_TARGET));\n    uri_curr->ttl = (int)ares_dns_rr_get_ttl(rr);\n\n    if (uri_curr->uri == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n  }\n\ndone:\n  /* clean up on error */\n  if (status != ARES_SUCCESS) {\n    if (uri_head) {\n      ares_free_data(uri_head);\n    }\n  } else {\n    /* everything looks fine, return the data */\n    *uri_out = uri_head;\n  }\n  ares_dns_record_destroy(dnsrec);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_uri_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen_int": "int",
              "uri_out": "struct ares_uri_reply"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            32,
            25
          ],
          [
            32,
            46
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            36,
            2
          ],
          [
            36,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            37,
            2
          ],
          [
            37,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            38,
            2
          ],
          [
            38,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_strcasecmp.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_strcasecmp(const char *a, const char *b)\n{\n#  if defined(HAVE_STRCMPI)\n  return strcmpi(a, b);\n#  elif defined(HAVE_STRICMP)\n  return stricmp(a, b);\n#  else\n  size_t i;\n\n  for (i = 0; i < (size_t)-1; i++) {\n    int c1 = ISUPPER(a[i]) ? tolower(a[i]) : a[i];\n    int c2 = ISUPPER(b[i]) ? tolower(b[i]) : b[i];\n    if (c1 != c2) {\n      return c1 - c2;\n    }\n    if (!c1) {\n      break;\n    }\n  }\n  return 0;\n#  endif\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              52,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strcasecmp",
            "parameters": {
              "a": "char",
              "b": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_strncasecmp(const char *a, const char *b, size_t n)\n{\n#  if defined(HAVE_STRNCMPI)\n  return strncmpi(a, b, n);\n#  elif defined(HAVE_STRNICMP)\n  return strnicmp(a, b, n);\n#  else\n  size_t i;\n\n  for (i = 0; i < n; i++) {\n    int c1 = ISUPPER(a[i]) ? tolower(a[i]) : a[i];\n    int c2 = ISUPPER(b[i]) ? tolower(b[i]) : b[i];\n    if (c1 != c2) {\n      return c1 - c2;\n    }\n    if (!c1) {\n      break;\n    }\n  }\n  return 0;\n#  endif\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              77,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strncasecmp",
            "parameters": {
              "a": "char",
              "b": "char",
              "n": "size_t"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_strcasecmp.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_dns_record.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_status_t ares_dns_record_create(ares_dns_record_t **dnsrec,\n                                     unsigned short id, unsigned short flags,\n                                     ares_dns_opcode_t opcode,\n                                     ares_dns_rcode_t  rcode)\n{\n  if (dnsrec == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *dnsrec = NULL;\n\n  if (!ares_dns_opcode_isvalid(opcode) || !ares_dns_rcode_isvalid(rcode) ||\n      !ares_dns_flags_arevalid(flags)) {\n    return ARES_EFORMERR;\n  }\n\n  *dnsrec = ares_malloc_zero(sizeof(**dnsrec));\n  if (*dnsrec == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  (*dnsrec)->id     = id;\n  (*dnsrec)->flags  = flags;\n  (*dnsrec)->opcode = opcode;\n  (*dnsrec)->rcode  = rcode;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_create",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "id": "unsigned short",
              "flags": "unsigned short",
              "opcode": "ares_dns_opcode_t",
              "rcode": "ares_dns_rcode_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "unsigned short ares_dns_record_get_id(const ares_dns_record_t *dnsrec)\n{\n  if (dnsrec == NULL) {\n    return 0;\n  }\n  return dnsrec->id;\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              68,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_get_id",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned short ares_dns_record_get_flags(const ares_dns_record_t *dnsrec)\n{\n  if (dnsrec == NULL) {\n    return 0;\n  }\n  return dnsrec->flags;\n}",
          "fn_code_pos": [
            [
              70,
              0
            ],
            [
              76,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_get_flags",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_opcode_t ares_dns_record_get_opcode(const ares_dns_record_t *dnsrec)\n{\n  if (dnsrec == NULL) {\n    return 0;\n  }\n  return dnsrec->opcode;\n}",
          "fn_code_pos": [
            [
              78,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_get_opcode",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_dns_opcode_t"
          }
        },
        {
          "fn_code": "ares_dns_rcode_t ares_dns_record_get_rcode(const ares_dns_record_t *dnsrec)\n{\n  if (dnsrec == NULL) {\n    return 0;\n  }\n  return dnsrec->rcode;\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              92,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_get_rcode",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_dns_rcode_t"
          }
        },
        {
          "fn_code": "static void ares__dns_options_free(ares__dns_options_t *options)\n{\n  size_t i;\n\n  if (options == NULL) {\n    return;\n  }\n\n  for (i = 0; i < options->cnt; i++) {\n    ares_free(options->optval[i].val);\n  }\n  ares_free(options->optval);\n  ares_free(options);\n}",
          "fn_code_pos": [
            [
              94,
              0
            ],
            [
              107,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__dns_options_free",
            "parameters": {
              "options": "ares__dns_options_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares__dns_rr_free(ares_dns_rr_t *rr)\n{\n  ares_free(rr->name);\n\n  switch (rr->type) {\n    case ARES_REC_TYPE_A:\n    case ARES_REC_TYPE_AAAA:\n    case ARES_REC_TYPE_ANY:\n      /* Nothing to free */\n      break;\n\n    case ARES_REC_TYPE_NS:\n      ares_free(rr->r.ns.nsdname);\n      break;\n\n    case ARES_REC_TYPE_CNAME:\n      ares_free(rr->r.cname.cname);\n      break;\n\n    case ARES_REC_TYPE_SOA:\n      ares_free(rr->r.soa.mname);\n      ares_free(rr->r.soa.rname);\n      break;\n\n    case ARES_REC_TYPE_PTR:\n      ares_free(rr->r.ptr.dname);\n      break;\n\n    case ARES_REC_TYPE_HINFO:\n      ares_free(rr->r.hinfo.cpu);\n      ares_free(rr->r.hinfo.os);\n      break;\n\n    case ARES_REC_TYPE_MX:\n      ares_free(rr->r.mx.exchange);\n      break;\n\n    case ARES_REC_TYPE_TXT:\n      ares_free(rr->r.txt.data);\n      break;\n\n    case ARES_REC_TYPE_SRV:\n      ares_free(rr->r.srv.target);\n      break;\n\n    case ARES_REC_TYPE_NAPTR:\n      ares_free(rr->r.naptr.flags);\n      ares_free(rr->r.naptr.services);\n      ares_free(rr->r.naptr.regexp);\n      ares_free(rr->r.naptr.replacement);\n      break;\n\n    case ARES_REC_TYPE_OPT:\n      ares__dns_options_free(rr->r.opt.options);\n      break;\n\n    case ARES_REC_TYPE_TLSA:\n      ares_free(rr->r.tlsa.data);\n      break;\n\n    case ARES_REC_TYPE_SVCB:\n      ares_free(rr->r.svcb.target);\n      ares__dns_options_free(rr->r.svcb.params);\n      break;\n\n    case ARES_REC_TYPE_HTTPS:\n      ares_free(rr->r.https.target);\n      ares__dns_options_free(rr->r.https.params);\n      break;\n\n    case ARES_REC_TYPE_URI:\n      ares_free(rr->r.uri.target);\n      break;\n\n    case ARES_REC_TYPE_CAA:\n      ares_free(rr->r.caa.tag);\n      ares_free(rr->r.caa.value);\n      break;\n\n    case ARES_REC_TYPE_RAW_RR:\n      ares_free(rr->r.raw_rr.data);\n      break;\n  }\n}",
          "fn_code_pos": [
            [
              109,
              0
            ],
            [
              192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__dns_rr_free",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_dns_record_destroy(ares_dns_record_t *dnsrec)\n{\n  size_t i;\n\n  if (dnsrec == NULL) {\n    return;\n  }\n\n  /* Free questions */\n  for (i = 0; i < dnsrec->qdcount; i++) {\n    ares_free(dnsrec->qd[i].name);\n  }\n  ares_free(dnsrec->qd);\n\n  /* Free answers */\n  for (i = 0; i < dnsrec->ancount; i++) {\n    ares__dns_rr_free(&dnsrec->an[i]);\n  }\n  ares_free(dnsrec->an);\n\n  /* Free authority */\n  for (i = 0; i < dnsrec->nscount; i++) {\n    ares__dns_rr_free(&dnsrec->ns[i]);\n  }\n  ares_free(dnsrec->ns);\n\n  /* Free additional */\n  for (i = 0; i < dnsrec->arcount; i++) {\n    ares__dns_rr_free(&dnsrec->ar[i]);\n  }\n  ares_free(dnsrec->ar);\n\n  ares_free(dnsrec);\n}",
          "fn_code_pos": [
            [
              194,
              0
            ],
            [
              227,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_destroy",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "size_t ares_dns_record_query_cnt(const ares_dns_record_t *dnsrec)\n{\n  if (dnsrec == NULL) {\n    return 0;\n  }\n  return dnsrec->qdcount;\n}",
          "fn_code_pos": [
            [
              229,
              0
            ],
            [
              235,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_query_cnt",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_query_add(ares_dns_record_t  *dnsrec,\n                                        const char         *name,\n                                        ares_dns_rec_type_t qtype,\n                                        ares_dns_class_t    qclass)\n{\n  ares_dns_qd_t *temp = NULL;\n  size_t         idx;\n\n  if (dnsrec == NULL || name == NULL ||\n      !ares_dns_rec_type_isvalid(qtype, ARES_TRUE) ||\n      !ares_dns_class_isvalid(qclass, ARES_TRUE)) {\n    return ARES_EFORMERR;\n  }\n\n  if (dnsrec->qdcount >= dnsrec->qdalloc) {\n    size_t alloc_cnt = ares__round_up_pow2(dnsrec->qdcount + 1);\n\n    temp = ares_realloc_zero(dnsrec->qd, sizeof(*temp) * (dnsrec->qdalloc),\n                             sizeof(*temp) * alloc_cnt);\n    if (temp == NULL) {\n      return ARES_ENOMEM;\n    }\n\n    dnsrec->qdalloc = alloc_cnt;\n    dnsrec->qd      = temp;\n  }\n\n  idx = dnsrec->qdcount;\n\n  dnsrec->qd[idx].name = ares_strdup(name);\n  if (dnsrec->qd[idx].name == NULL) {\n    /* No need to clean up anything */\n    return ARES_ENOMEM;\n  }\n\n  dnsrec->qd[idx].qtype  = qtype;\n  dnsrec->qd[idx].qclass = qclass;\n  dnsrec->qdcount++;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              237,
              0
            ],
            [
              276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_query_add",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "name": "char",
              "qtype": "ares_dns_rec_type_t",
              "qclass": "ares_dns_class_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_query_set_name(ares_dns_record_t *dnsrec,\n                                             size_t idx, const char *name)\n{\n  char *orig_name = NULL;\n\n  if (dnsrec == NULL || idx >= dnsrec->qdcount || name == NULL) {\n    return ARES_EFORMERR;\n  }\n  orig_name            = dnsrec->qd[idx].name;\n  dnsrec->qd[idx].name = ares_strdup(name);\n  if (dnsrec->qd[idx].name == NULL) {\n    dnsrec->qd[idx].name = orig_name;\n    return ARES_ENOMEM;\n  }\n\n  ares_free(orig_name);\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              278,
              0
            ],
            [
              295,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_query_set_name",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "idx": "size_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_query_set_type(ares_dns_record_t  *dnsrec,\n                                             size_t              idx,\n                                             ares_dns_rec_type_t qtype)\n{\n  if (dnsrec == NULL || idx >= dnsrec->qdcount ||\n      !ares_dns_rec_type_isvalid(qtype, ARES_TRUE)) {\n    return ARES_EFORMERR;\n  }\n\n  dnsrec->qd[idx].qtype = qtype;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              297,
              0
            ],
            [
              309,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_query_set_type",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "idx": "size_t",
              "qtype": "ares_dns_rec_type_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_query_get(const ares_dns_record_t *dnsrec,\n                                        size_t idx, const char **name,\n                                        ares_dns_rec_type_t *qtype,\n                                        ares_dns_class_t    *qclass)\n{\n  if (dnsrec == NULL || idx >= dnsrec->qdcount) {\n    return ARES_EFORMERR;\n  }\n\n  if (name != NULL) {\n    *name = dnsrec->qd[idx].name;\n  }\n\n  if (qtype != NULL) {\n    *qtype = dnsrec->qd[idx].qtype;\n  }\n\n  if (qclass != NULL) {\n    *qclass = dnsrec->qd[idx].qclass;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              311,
              0
            ],
            [
              333,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_query_get",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "idx": "size_t",
              "name": "char",
              "qtype": "ares_dns_rec_type_t",
              "qclass": "ares_dns_class_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "size_t ares_dns_record_rr_cnt(const ares_dns_record_t *dnsrec,\n                              ares_dns_section_t       sect)\n{\n  if (dnsrec == NULL || !ares_dns_section_isvalid(sect)) {\n    return 0;\n  }\n\n  switch (sect) {\n    case ARES_SECTION_ANSWER:\n      return dnsrec->ancount;\n    case ARES_SECTION_AUTHORITY:\n      return dnsrec->nscount;\n    case ARES_SECTION_ADDITIONAL:\n      return dnsrec->arcount;\n  }\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              335,
              0
            ],
            [
              352,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_cnt",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_rr_prealloc(ares_dns_record_t *dnsrec,\n                                          ares_dns_section_t sect, size_t cnt)\n{\n  ares_dns_rr_t **rr_ptr   = NULL;\n  size_t         *rr_alloc = NULL;\n  ares_dns_rr_t  *temp     = NULL;\n\n  if (dnsrec == NULL || cnt == 0 || !ares_dns_section_isvalid(sect)) {\n    return ARES_EFORMERR;\n  }\n\n  switch (sect) {\n    case ARES_SECTION_ANSWER:\n      rr_ptr   = &dnsrec->an;\n      rr_alloc = &dnsrec->analloc;\n      break;\n    case ARES_SECTION_AUTHORITY:\n      rr_ptr   = &dnsrec->ns;\n      rr_alloc = &dnsrec->nsalloc;\n      break;\n    case ARES_SECTION_ADDITIONAL:\n      rr_ptr   = &dnsrec->ar;\n      rr_alloc = &dnsrec->aralloc;\n      break;\n  }\n\n  /* Round up cnt to a power of 2 */\n  cnt = ares__round_up_pow2(cnt);\n\n  /* Already have that */\n  if (cnt <= *rr_alloc) {\n    return ARES_SUCCESS;\n  }\n\n  temp = ares_realloc_zero(*rr_ptr, sizeof(*temp) * (*rr_alloc),\n                           sizeof(*temp) * cnt);\n  if (temp == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  *rr_alloc = cnt;\n  *rr_ptr   = temp;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              354,
              0
            ],
            [
              397,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_prealloc",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "cnt": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_rr_add(ares_dns_rr_t    **rr_out,\n                                     ares_dns_record_t *dnsrec,\n                                     ares_dns_section_t sect, const char *name,\n                                     ares_dns_rec_type_t type,\n                                     ares_dns_class_t rclass, unsigned int ttl)\n{\n  ares_dns_rr_t **rr_ptr = NULL;\n  ares_dns_rr_t  *rr     = NULL;\n  size_t         *rr_len = NULL;\n  ares_status_t   status;\n  size_t          idx;\n\n  if (dnsrec == NULL || name == NULL || rr_out == NULL ||\n      !ares_dns_section_isvalid(sect) ||\n      !ares_dns_rec_type_isvalid(type, ARES_FALSE) ||\n      !ares_dns_class_isvalid(rclass, ARES_FALSE)) {\n    return ARES_EFORMERR;\n  }\n\n  *rr_out = NULL;\n\n  switch (sect) {\n    case ARES_SECTION_ANSWER:\n      rr_ptr = &dnsrec->an;\n      rr_len = &dnsrec->ancount;\n      break;\n    case ARES_SECTION_AUTHORITY:\n      rr_ptr = &dnsrec->ns;\n      rr_len = &dnsrec->nscount;\n      break;\n    case ARES_SECTION_ADDITIONAL:\n      rr_ptr = &dnsrec->ar;\n      rr_len = &dnsrec->arcount;\n      break;\n  }\n\n  status = ares_dns_record_rr_prealloc(dnsrec, sect, *rr_len + 1);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  idx = *rr_len;\n  rr  = &(*rr_ptr)[idx];\n\n  rr->name = ares_strdup(name);\n  if (rr->name == NULL) {\n    /* No need to clean up anything */\n    return ARES_ENOMEM;\n  }\n\n  rr->parent = dnsrec;\n  rr->type   = type;\n  rr->rclass = rclass;\n  rr->ttl    = ttl;\n  (*rr_len)++;\n\n  *rr_out = rr;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              399,
              0
            ],
            [
              458,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_add",
            "parameters": {
              "rr_out": "ares_dns_rr_t",
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "name": "char",
              "type": "ares_dns_rec_type_t",
              "rclass": "ares_dns_class_t",
              "ttl": "unsigned int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_rr_del(ares_dns_record_t *dnsrec,\n                                     ares_dns_section_t sect, size_t idx)\n{\n  ares_dns_rr_t *rr_ptr = NULL;\n  size_t        *rr_len = NULL;\n  size_t         cnt_after;\n\n  if (dnsrec == NULL || !ares_dns_section_isvalid(sect)) {\n    return ARES_EFORMERR;\n  }\n\n  switch (sect) {\n    case ARES_SECTION_ANSWER:\n      rr_ptr = dnsrec->an;\n      rr_len = &dnsrec->ancount;\n      break;\n    case ARES_SECTION_AUTHORITY:\n      rr_ptr = dnsrec->ns;\n      rr_len = &dnsrec->nscount;\n      break;\n    case ARES_SECTION_ADDITIONAL:\n      rr_ptr = dnsrec->ar;\n      rr_len = &dnsrec->arcount;\n      break;\n  }\n\n  if (idx >= *rr_len) {\n    return ARES_EFORMERR;\n  }\n\n  ares__dns_rr_free(&rr_ptr[idx]);\n\n  cnt_after = *rr_len - idx - 1;\n\n  if (cnt_after) {\n    memmove(&rr_ptr[idx], &rr_ptr[idx + 1], sizeof(*rr_ptr) * cnt_after);\n  }\n\n  (*rr_len)--;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              460,
              0
            ],
            [
              500,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_del",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "idx": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_rr_t *ares_dns_record_rr_get(ares_dns_record_t *dnsrec,\n                                      ares_dns_section_t sect, size_t idx)\n{\n  ares_dns_rr_t *rr_ptr = NULL;\n  size_t         rr_len = 0;\n\n  if (dnsrec == NULL || !ares_dns_section_isvalid(sect)) {\n    return NULL;\n  }\n\n  switch (sect) {\n    case ARES_SECTION_ANSWER:\n      rr_ptr = dnsrec->an;\n      rr_len = dnsrec->ancount;\n      break;\n    case ARES_SECTION_AUTHORITY:\n      rr_ptr = dnsrec->ns;\n      rr_len = dnsrec->nscount;\n      break;\n    case ARES_SECTION_ADDITIONAL:\n      rr_ptr = dnsrec->ar;\n      rr_len = dnsrec->arcount;\n      break;\n  }\n\n  if (idx >= rr_len) {\n    return NULL;\n  }\n\n  return &rr_ptr[idx];\n}",
          "fn_code_pos": [
            [
              502,
              0
            ],
            [
              532,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_get",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "idx": "size_t"
            },
            "return_type": "ares_dns_rr_t"
          }
        },
        {
          "fn_code": "const ares_dns_rr_t *\n  ares_dns_record_rr_get_const(const ares_dns_record_t *dnsrec,\n                               ares_dns_section_t sect, size_t idx)\n{\n  return ares_dns_record_rr_get((void *)((size_t)dnsrec), sect, idx);\n}",
          "fn_code_pos": [
            [
              534,
              0
            ],
            [
              539,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_get_const",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "idx": "size_t"
            },
            "return_type": "ares_dns_rr_t"
          }
        },
        {
          "fn_code": "const char *ares_dns_rr_get_name(const ares_dns_rr_t *rr)\n{\n  if (rr == NULL) {\n    return NULL;\n  }\n  return rr->name;\n}",
          "fn_code_pos": [
            [
              541,
              0
            ],
            [
              547,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_name",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "ares_dns_rec_type_t ares_dns_rr_get_type(const ares_dns_rr_t *rr)\n{\n  if (rr == NULL) {\n    return 0;\n  }\n  return rr->type;\n}",
          "fn_code_pos": [
            [
              549,
              0
            ],
            [
              555,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_type",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": "ares_dns_rec_type_t"
          }
        },
        {
          "fn_code": "ares_dns_class_t ares_dns_rr_get_class(const ares_dns_rr_t *rr)\n{\n  if (rr == NULL) {\n    return 0;\n  }\n  return rr->rclass;\n}",
          "fn_code_pos": [
            [
              557,
              0
            ],
            [
              563,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_class",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": "ares_dns_class_t"
          }
        },
        {
          "fn_code": "unsigned int ares_dns_rr_get_ttl(const ares_dns_rr_t *rr)\n{\n  if (rr == NULL) {\n    return 0;\n  }\n  return rr->ttl;\n}",
          "fn_code_pos": [
            [
              565,
              0
            ],
            [
              571,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_ttl",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void *ares_dns_rr_data_ptr(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                  size_t **lenptr)\n{\n  if (dns_rr == NULL || dns_rr->type != ares_dns_rr_key_to_rec_type(key)) {\n    return NULL;\n  }\n\n  switch (key) {\n    case ARES_RR_A_ADDR:\n      return &dns_rr->r.a.addr;\n\n    case ARES_RR_NS_NSDNAME:\n      return &dns_rr->r.ns.nsdname;\n\n    case ARES_RR_CNAME_CNAME:\n      return &dns_rr->r.cname.cname;\n\n    case ARES_RR_SOA_MNAME:\n      return &dns_rr->r.soa.mname;\n\n    case ARES_RR_SOA_RNAME:\n      return &dns_rr->r.soa.rname;\n\n    case ARES_RR_SOA_SERIAL:\n      return &dns_rr->r.soa.serial;\n\n    case ARES_RR_SOA_REFRESH:\n      return &dns_rr->r.soa.refresh;\n\n    case ARES_RR_SOA_RETRY:\n      return &dns_rr->r.soa.retry;\n\n    case ARES_RR_SOA_EXPIRE:\n      return &dns_rr->r.soa.expire;\n\n    case ARES_RR_SOA_MINIMUM:\n      return &dns_rr->r.soa.minimum;\n\n    case ARES_RR_PTR_DNAME:\n      return &dns_rr->r.ptr.dname;\n\n    case ARES_RR_AAAA_ADDR:\n      return &dns_rr->r.aaaa.addr;\n\n    case ARES_RR_HINFO_CPU:\n      return &dns_rr->r.hinfo.cpu;\n\n    case ARES_RR_HINFO_OS:\n      return &dns_rr->r.hinfo.os;\n\n    case ARES_RR_MX_PREFERENCE:\n      return &dns_rr->r.mx.preference;\n\n    case ARES_RR_MX_EXCHANGE:\n      return &dns_rr->r.mx.exchange;\n\n    case ARES_RR_TXT_DATA:\n      if (lenptr == NULL) {\n        return NULL;\n      }\n      *lenptr = &dns_rr->r.txt.data_len;\n      return &dns_rr->r.txt.data;\n\n    case ARES_RR_SRV_PRIORITY:\n      return &dns_rr->r.srv.priority;\n\n    case ARES_RR_SRV_WEIGHT:\n      return &dns_rr->r.srv.weight;\n\n    case ARES_RR_SRV_PORT:\n      return &dns_rr->r.srv.port;\n\n    case ARES_RR_SRV_TARGET:\n      return &dns_rr->r.srv.target;\n\n    case ARES_RR_NAPTR_ORDER:\n      return &dns_rr->r.naptr.order;\n\n    case ARES_RR_NAPTR_PREFERENCE:\n      return &dns_rr->r.naptr.preference;\n\n    case ARES_RR_NAPTR_FLAGS:\n      return &dns_rr->r.naptr.flags;\n\n    case ARES_RR_NAPTR_SERVICES:\n      return &dns_rr->r.naptr.services;\n\n    case ARES_RR_NAPTR_REGEXP:\n      return &dns_rr->r.naptr.regexp;\n\n    case ARES_RR_NAPTR_REPLACEMENT:\n      return &dns_rr->r.naptr.replacement;\n\n    case ARES_RR_OPT_UDP_SIZE:\n      return &dns_rr->r.opt.udp_size;\n\n    case ARES_RR_OPT_VERSION:\n      return &dns_rr->r.opt.version;\n\n    case ARES_RR_OPT_FLAGS:\n      return &dns_rr->r.opt.flags;\n\n    case ARES_RR_OPT_OPTIONS:\n      return &dns_rr->r.opt.options;\n\n    case ARES_RR_TLSA_CERT_USAGE:\n      return &dns_rr->r.tlsa.cert_usage;\n\n    case ARES_RR_TLSA_SELECTOR:\n      return &dns_rr->r.tlsa.selector;\n\n    case ARES_RR_TLSA_MATCH:\n      return &dns_rr->r.tlsa.match;\n\n    case ARES_RR_TLSA_DATA:\n      if (lenptr == NULL) {\n        return NULL;\n      }\n      *lenptr = &dns_rr->r.tlsa.data_len;\n      return &dns_rr->r.tlsa.data;\n\n    case ARES_RR_SVCB_PRIORITY:\n      return &dns_rr->r.svcb.priority;\n\n    case ARES_RR_SVCB_TARGET:\n      return &dns_rr->r.svcb.target;\n\n    case ARES_RR_SVCB_PARAMS:\n      return &dns_rr->r.svcb.params;\n\n    case ARES_RR_HTTPS_PRIORITY:\n      return &dns_rr->r.https.priority;\n\n    case ARES_RR_HTTPS_TARGET:\n      return &dns_rr->r.https.target;\n\n    case ARES_RR_HTTPS_PARAMS:\n      return &dns_rr->r.https.params;\n\n    case ARES_RR_URI_PRIORITY:\n      return &dns_rr->r.uri.priority;\n\n    case ARES_RR_URI_WEIGHT:\n      return &dns_rr->r.uri.weight;\n\n    case ARES_RR_URI_TARGET:\n      return &dns_rr->r.uri.target;\n\n    case ARES_RR_CAA_CRITICAL:\n      return &dns_rr->r.caa.critical;\n\n    case ARES_RR_CAA_TAG:\n      return &dns_rr->r.caa.tag;\n\n    case ARES_RR_CAA_VALUE:\n      if (lenptr == NULL) {\n        return NULL;\n      }\n      *lenptr = &dns_rr->r.caa.value_len;\n      return &dns_rr->r.caa.value;\n\n    case ARES_RR_RAW_RR_TYPE:\n      return &dns_rr->r.raw_rr.type;\n\n    case ARES_RR_RAW_RR_DATA:\n      if (lenptr == NULL) {\n        return NULL;\n      }\n      *lenptr = &dns_rr->r.raw_rr.length;\n      return &dns_rr->r.raw_rr.data;\n  }\n\n  return NULL;\n}",
          "fn_code_pos": [
            [
              573,
              0
            ],
            [
              746,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_data_ptr",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "lenptr": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static const void *ares_dns_rr_data_ptr_const(const ares_dns_rr_t *dns_rr,\n                                              ares_dns_rr_key_t    key,\n                                              const size_t       **lenptr)\n{\n  /* We're going to cast off the const */\n  return ares_dns_rr_data_ptr((void *)((size_t)dns_rr), key,\n                              (void *)((size_t)lenptr));\n}",
          "fn_code_pos": [
            [
              748,
              0
            ],
            [
              755,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_data_ptr_const",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "lenptr": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "const struct in_addr *ares_dns_rr_get_addr(const ares_dns_rr_t *dns_rr,\n                                           ares_dns_rr_key_t    key)\n{\n  const struct in_addr *addr;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_INADDR) {\n    return NULL;\n  }\n\n  addr = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (addr == NULL) {\n    return NULL;\n  }\n\n  return addr;\n}",
          "fn_code_pos": [
            [
              757,
              0
            ],
            [
              772,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_addr",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "const struct ares_in6_addr *ares_dns_rr_get_addr6(const ares_dns_rr_t *dns_rr,\n                                                  ares_dns_rr_key_t    key)\n{\n  const struct ares_in6_addr *addr;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_INADDR6) {\n    return NULL;\n  }\n\n  addr = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (addr == NULL) {\n    return NULL;\n  }\n\n  return addr;\n}",
          "fn_code_pos": [
            [
              774,
              0
            ],
            [
              789,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_addr6",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned char ares_dns_rr_get_u8(const ares_dns_rr_t *dns_rr,\n                                 ares_dns_rr_key_t    key)\n{\n  const unsigned char *u8;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U8) {\n    return 0;\n  }\n\n  u8 = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (u8 == NULL) {\n    return 0;\n  }\n\n  return *u8;\n}",
          "fn_code_pos": [
            [
              791,
              0
            ],
            [
              806,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_u8",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned short ares_dns_rr_get_u16(const ares_dns_rr_t *dns_rr,\n                                   ares_dns_rr_key_t    key)\n{\n  const unsigned short *u16;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U16) {\n    return 0;\n  }\n\n  u16 = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (u16 == NULL) {\n    return 0;\n  }\n\n  return *u16;\n}",
          "fn_code_pos": [
            [
              808,
              0
            ],
            [
              823,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_u16",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned int ares_dns_rr_get_u32(const ares_dns_rr_t *dns_rr,\n                                 ares_dns_rr_key_t    key)\n{\n  const unsigned int *u32;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U32) {\n    return 0;\n  }\n\n  u32 = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (u32 == NULL) {\n    return 0;\n  }\n\n  return *u32;\n}",
          "fn_code_pos": [
            [
              825,
              0
            ],
            [
              840,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_u32",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "const unsigned char *ares_dns_rr_get_bin(const ares_dns_rr_t *dns_rr,\n                                         ares_dns_rr_key_t key, size_t *len)\n{\n  unsigned char * const *bin     = NULL;\n  size_t const          *bin_len = NULL;\n\n  if ((ares_dns_rr_key_datatype(key) != ARES_DATATYPE_BIN &&\n       ares_dns_rr_key_datatype(key) != ARES_DATATYPE_BINP) ||\n      len == NULL) {\n    return NULL;\n  }\n\n  bin = ares_dns_rr_data_ptr_const(dns_rr, key, &bin_len);\n  if (bin == NULL) {\n    return 0;\n  }\n\n  /* Shouldn't be possible */\n  if (bin_len == NULL) {\n    return NULL;\n  }\n\n  *len = *bin_len;\n\n  return *bin;\n}",
          "fn_code_pos": [
            [
              842,
              0
            ],
            [
              867,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_bin",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "const char *ares_dns_rr_get_str(const ares_dns_rr_t *dns_rr,\n                                ares_dns_rr_key_t    key)\n{\n  char * const *str;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_STR &&\n      ares_dns_rr_key_datatype(key) != ARES_DATATYPE_NAME) {\n    return NULL;\n  }\n\n  str = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (str == NULL) {\n    return NULL;\n  }\n\n  return *str;\n}",
          "fn_code_pos": [
            [
              869,
              0
            ],
            [
              885,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_str",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "size_t ares_dns_rr_get_opt_cnt(const ares_dns_rr_t *dns_rr,\n                               ares_dns_rr_key_t    key)\n{\n  ares__dns_options_t * const *opts;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_OPT) {\n    return 0;\n  }\n\n  opts = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (opts == NULL || *opts == NULL) {\n    return 0;\n  }\n\n  return (*opts)->cnt;\n}",
          "fn_code_pos": [
            [
              887,
              0
            ],
            [
              902,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_opt_cnt",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "unsigned short ares_dns_rr_get_opt(const ares_dns_rr_t *dns_rr,\n                                   ares_dns_rr_key_t key, size_t idx,\n                                   const unsigned char **val, size_t *val_len)\n{\n  ares__dns_options_t * const *opts;\n\n  if (val) {\n    *val = NULL;\n  }\n  if (val_len) {\n    *val_len = 0;\n  }\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_OPT) {\n    return 65535;\n  }\n\n  opts = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (opts == NULL || *opts == NULL) {\n    return 65535;\n  }\n\n  if (idx >= (*opts)->cnt) {\n    return 65535;\n  }\n\n  if (val) {\n    *val = (*opts)->optval[idx].val;\n  }\n  if (val_len) {\n    *val_len = (*opts)->optval[idx].val_len;\n  }\n\n  return (*opts)->optval[idx].opt;\n}",
          "fn_code_pos": [
            [
              904,
              0
            ],
            [
              938,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_opt",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "idx": "size_t",
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_rr_get_opt_byid(const ares_dns_rr_t *dns_rr,\n                                     ares_dns_rr_key_t key, unsigned short opt,\n                                     const unsigned char **val, size_t *val_len)\n{\n  ares__dns_options_t * const *opts;\n  size_t                       i;\n\n  if (val) {\n    *val = NULL;\n  }\n  if (val_len) {\n    *val_len = 0;\n  }\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_OPT) {\n    return ARES_FALSE;\n  }\n\n  opts = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);\n  if (opts == NULL || *opts == NULL) {\n    return ARES_FALSE;\n  }\n\n  for (i = 0; i < (*opts)->cnt; i++) {\n    if ((*opts)->optval[i].opt == opt) {\n      break;\n    }\n  }\n\n  if (i >= (*opts)->cnt) {\n    return ARES_FALSE;\n  }\n\n  if (val) {\n    *val = (*opts)->optval[i].val;\n  }\n  if (val_len) {\n    *val_len = (*opts)->optval[i].val_len;\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              940,
              0
            ],
            [
              980,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_opt_byid",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short",
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_addr(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                   const struct in_addr *addr)\n{\n  struct in_addr *a;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_INADDR || addr == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  a = ares_dns_rr_data_ptr(dns_rr, key, NULL);\n  if (a == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  memcpy(a, addr, sizeof(*a));\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              982,
              0
            ],
            [
              998,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_addr",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "addr": "struct in_addr"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_addr6(ares_dns_rr_t              *dns_rr,\n                                    ares_dns_rr_key_t           key,\n                                    const struct ares_in6_addr *addr)\n{\n  struct ares_in6_addr *a;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_INADDR6 || addr == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  a = ares_dns_rr_data_ptr(dns_rr, key, NULL);\n  if (a == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  memcpy(a, addr, sizeof(*a));\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1000,
              0
            ],
            [
              1017,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_addr6",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "addr": "struct ares_in6_addr"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_u8(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                 unsigned char val)\n{\n  unsigned char *u8;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U8) {\n    return ARES_EFORMERR;\n  }\n\n  u8 = ares_dns_rr_data_ptr(dns_rr, key, NULL);\n  if (u8 == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *u8 = val;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1019,
              0
            ],
            [
              1035,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_u8",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_u16(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                  unsigned short val)\n{\n  unsigned short *u16;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U16) {\n    return ARES_EFORMERR;\n  }\n\n  u16 = ares_dns_rr_data_ptr(dns_rr, key, NULL);\n  if (u16 == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *u16 = val;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1037,
              0
            ],
            [
              1053,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_u16",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_u32(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                  unsigned int val)\n{\n  unsigned int *u32;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U32) {\n    return ARES_EFORMERR;\n  }\n\n  u32 = ares_dns_rr_data_ptr(dns_rr, key, NULL);\n  if (u32 == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *u32 = val;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1055,
              0
            ],
            [
              1071,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_u32",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_bin_own(ares_dns_rr_t    *dns_rr,\n                                      ares_dns_rr_key_t key, unsigned char *val,\n                                      size_t len)\n{\n  unsigned char **bin;\n  size_t         *bin_len = NULL;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_BIN &&\n      ares_dns_rr_key_datatype(key) != ARES_DATATYPE_BINP) {\n    return ARES_EFORMERR;\n  }\n\n  bin = ares_dns_rr_data_ptr(dns_rr, key, &bin_len);\n  if (bin == NULL || bin_len == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (*bin) {\n    ares_free(*bin);\n  }\n  *bin     = val;\n  *bin_len = len;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1073,
              0
            ],
            [
              1097,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_bin_own",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_bin(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                  const unsigned char *val, size_t len)\n{\n  ares_status_t       status;\n  ares_dns_datatype_t datatype = ares_dns_rr_key_datatype(key);\n  size_t         alloclen = (datatype == ARES_DATATYPE_BINP) ? len + 1 : len;\n  unsigned char *temp     = ares_malloc(alloclen);\n\n  if (temp == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  memcpy(temp, val, len);\n\n  /* NULL-term BINP */\n  if (datatype == ARES_DATATYPE_BINP) {\n    temp[len] = 0;\n  }\n\n  status = ares_dns_rr_set_bin_own(dns_rr, key, temp, len);\n  if (status != ARES_SUCCESS) {\n    ares_free(temp);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              1099,
              0
            ],
            [
              1124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_bin",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_str_own(ares_dns_rr_t    *dns_rr,\n                                      ares_dns_rr_key_t key, char *val)\n{\n  char **str;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_STR &&\n      ares_dns_rr_key_datatype(key) != ARES_DATATYPE_NAME) {\n    return ARES_EFORMERR;\n  }\n\n  str = ares_dns_rr_data_ptr(dns_rr, key, NULL);\n  if (str == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (*str) {\n    ares_free(*str);\n  }\n  *str = val;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1126,
              0
            ],
            [
              1147,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_str_own",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_str(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                  const char *val)\n{\n  ares_status_t status;\n  char         *temp = NULL;\n\n  if (val != NULL) {\n    temp = ares_strdup(val);\n    if (temp == NULL) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  status = ares_dns_rr_set_str_own(dns_rr, key, temp);\n  if (status != ARES_SUCCESS) {\n    ares_free(temp);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              1149,
              0
            ],
            [
              1168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_str",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_opt_own(ares_dns_rr_t    *dns_rr,\n                                      ares_dns_rr_key_t key, unsigned short opt,\n                                      unsigned char *val, size_t val_len)\n{\n  ares__dns_options_t **options;\n  size_t                idx;\n\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_OPT) {\n    return ARES_EFORMERR;\n  }\n\n  options = ares_dns_rr_data_ptr(dns_rr, key, NULL);\n  if (options == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (*options == NULL) {\n    *options = ares_malloc_zero(sizeof(**options));\n  }\n  if (*options == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  for (idx = 0; idx < (*options)->cnt; idx++) {\n    if ((*options)->optval[idx].opt == opt) {\n      break;\n    }\n  }\n\n  /* Duplicate entry, replace */\n  if (idx != (*options)->cnt) {\n    goto done;\n  }\n\n  idx = (*options)->cnt;\n\n  /* Expand by powers of 2 */\n  if (idx >= (*options)->alloc) {\n    size_t alloc_size = (*options)->alloc;\n    void  *temp;\n\n    if (alloc_size == 0) {\n      alloc_size = 1;\n    } else {\n      alloc_size <<= 1;\n    }\n\n    temp = ares_realloc_zero((*options)->optval,\n                             (*options)->alloc * sizeof(*(*options)->optval),\n                             alloc_size * sizeof(*(*options)->optval));\n    if (temp == NULL) {\n      return ARES_ENOMEM;\n    }\n\n    (*options)->optval = temp;\n    (*options)->alloc  = alloc_size;\n  }\n\n  (*options)->cnt++;\n\ndone:\n  ares_free((*options)->optval[idx].val);\n  (*options)->optval[idx].opt     = opt;\n  (*options)->optval[idx].val     = val;\n  (*options)->optval[idx].val_len = val_len;\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              1170,
              0
            ],
            [
              1237,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_opt_own",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short",
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_opt(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                  unsigned short opt, const unsigned char *val,\n                                  size_t val_len)\n{\n  unsigned char *temp = NULL;\n  ares_status_t  status;\n\n  if (val != NULL) {\n    temp = ares_malloc(val_len + 1);\n    if (temp == NULL) {\n      return ARES_ENOMEM;\n    }\n    memcpy(temp, val, val_len);\n    temp[val_len] = 0;\n  }\n\n  status = ares_dns_rr_set_opt_own(dns_rr, key, opt, temp, val_len);\n  if (status != ARES_SUCCESS) {\n    ares_free(temp);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              1239,
              0
            ],
            [
              1261,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_opt",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short",
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "char *ares_dns_addr_to_ptr(const struct ares_addr *addr)\n{\n  ares__buf_t               *buf     = NULL;\n  const unsigned char       *ptr     = NULL;\n  size_t                     ptr_len = 0;\n  size_t                     i;\n  ares_status_t              status;\n  static const unsigned char hexbytes[] = \"0123456789abcdef\";\n\n  if (addr->family != AF_INET && addr->family != AF_INET6) {\n    goto fail;\n  }\n\n  buf = ares__buf_create();\n  if (buf == NULL) {\n    goto fail;\n  }\n\n  if (addr->family == AF_INET) {\n    ptr     = (const unsigned char *)&addr->addr.addr4;\n    ptr_len = 4;\n  } else {\n    ptr     = (const unsigned char *)&addr->addr.addr6;\n    ptr_len = 16;\n  }\n\n  for (i = ptr_len; i > 0; i--) {\n    if (addr->family == AF_INET) {\n      status = ares__buf_append_num_dec(buf, (size_t)ptr[i - 1], 0);\n    } else {\n      unsigned char c;\n\n      c      = ptr[i - 1] & 0xF;\n      status = ares__buf_append_byte(buf, hexbytes[c]);\n      if (status != ARES_SUCCESS) {\n        goto fail;\n      }\n\n      status = ares__buf_append_byte(buf, '.');\n      if (status != ARES_SUCCESS) {\n        goto fail;\n      }\n\n      c      = (ptr[i - 1] >> 4) & 0xF;\n      status = ares__buf_append_byte(buf, hexbytes[c]);\n    }\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n\n    status = ares__buf_append_byte(buf, '.');\n    if (status != ARES_SUCCESS) {\n      goto fail;\n    }\n  }\n\n  if (addr->family == AF_INET) {\n    status = ares__buf_append(buf, (const unsigned char *)\"in-addr.arpa\", 12);\n  } else {\n    status = ares__buf_append(buf, (const unsigned char *)\"ip6.arpa\", 8);\n  }\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  return ares__buf_finish_str(buf, NULL);\n\nfail:\n  ares__buf_destroy(buf);\n  return NULL;\n}",
          "fn_code_pos": [
            [
              1263,
              0
            ],
            [
              1333,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_addr_to_ptr",
            "parameters": {
              "addr": "struct ares_addr"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_has_opt_rr(const ares_dns_record_t *rec)\n{\n  size_t i;\n  for (i = 0; i < ares_dns_record_rr_cnt(rec, ARES_SECTION_ADDITIONAL); i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get_const(rec, ARES_SECTION_ADDITIONAL, i);\n\n    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_OPT) {\n      return ARES_TRUE;\n    }\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              1336,
              0
            ],
            [
              1348,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_has_opt_rr",
            "parameters": {
              "rec": "ares_dns_record_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_status_t\n  ares_dns_record_create_query(ares_dns_record_t **dnsrec, const char *name,\n                               ares_dns_class_t    dnsclass,\n                               ares_dns_rec_type_t type, unsigned short id,\n                               ares_dns_flags_t flags, size_t max_udp_size)\n{\n  ares_status_t  status;\n  ares_dns_rr_t *rr = NULL;\n\n  if (dnsrec == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *dnsrec = NULL;\n\n  /* Per RFC 7686, reject queries for \".onion\" domain names with NXDOMAIN */\n  if (ares__is_onion_domain(name)) {\n    status = ARES_ENOTFOUND;\n    goto done;\n  }\n\n  status = ares_dns_record_create(dnsrec, id, (unsigned short)flags,\n                                  ARES_OPCODE_QUERY, ARES_RCODE_NOERROR);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_dns_record_query_add(*dnsrec, name, type, dnsclass);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* max_udp_size > 0 indicates EDNS, so send OPT RR as an additional record */\n  if (max_udp_size > 0) {\n    /* max_udp_size must fit into a 16 bit unsigned integer field on the OPT\n     * RR, so check here that it fits\n     */\n    if (max_udp_size > 65535) {\n      status = ARES_EFORMERR;\n      goto done;\n    }\n\n    status = ares_dns_record_rr_add(&rr, *dnsrec, ARES_SECTION_ADDITIONAL, \"\",\n                                    ARES_REC_TYPE_OPT, ARES_CLASS_IN, 0);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    status = ares_dns_rr_set_u16(rr, ARES_RR_OPT_UDP_SIZE,\n                                 (unsigned short)max_udp_size);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    status = ares_dns_rr_set_u8(rr, ARES_RR_OPT_VERSION, 0);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n\n    status = ares_dns_rr_set_u16(rr, ARES_RR_OPT_FLAGS, 0);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_dns_record_destroy(*dnsrec);\n    *dnsrec = NULL;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              1353,
              0
            ],
            [
              1424,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_create_query",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "name": "char",
              "dnsclass": "ares_dns_class_t",
              "type": "ares_dns_rec_type_t",
              "id": "unsigned short",
              "flags": "ares_dns_flags_t",
              "max_udp_size": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_record_t *ares_dns_record_duplicate(const ares_dns_record_t *dnsrec)\n{\n  unsigned char     *data     = NULL;\n  size_t             data_len = 0;\n  ares_dns_record_t *out      = NULL;\n  ares_status_t      status;\n\n  if (dnsrec == NULL) {\n    return NULL;\n  }\n\n  status = ares_dns_write(dnsrec, &data, &data_len);\n  if (status != ARES_SUCCESS) {\n    return NULL;\n  }\n\n  status = ares_dns_parse(data, data_len, 0, &out);\n  ares_free(data);\n  if (status != ARES_SUCCESS) {\n    return NULL;\n  }\n  return out;\n}",
          "fn_code_pos": [
            [
              1426,
              0
            ],
            [
              1448,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_duplicate",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_dns_record_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_dns_record_rr_get(ares_dns_record_t *dnsrec,\n                                      ares_dns_section_t sect, size_t idx)",
          "fn_dec_pos": [
            [
              502,
              15
            ],
            [
              503,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_get",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_record_rr_get_const(const ares_dns_record_t *dnsrec,\n                               ares_dns_section_t sect, size_t idx)",
          "fn_dec_pos": [
            [
              535,
              2
            ],
            [
              536,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_get_const",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_name(const ares_dns_rr_t *rr)",
          "fn_dec_pos": [
            [
              541,
              12
            ],
            [
              541,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_name",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_data_ptr(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                                  size_t **lenptr)",
          "fn_dec_pos": [
            [
              573,
              13
            ],
            [
              574,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_data_ptr",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "lenptr": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_data_ptr_const(const ares_dns_rr_t *dns_rr,\n                                              ares_dns_rr_key_t    key,\n                                              const size_t       **lenptr)",
          "fn_dec_pos": [
            [
              748,
              19
            ],
            [
              750,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_data_ptr_const",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "lenptr": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_addr(const ares_dns_rr_t *dns_rr,\n                                           ares_dns_rr_key_t    key)",
          "fn_dec_pos": [
            [
              757,
              22
            ],
            [
              758,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_addr",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_addr6(const ares_dns_rr_t *dns_rr,\n                                                  ares_dns_rr_key_t    key)",
          "fn_dec_pos": [
            [
              774,
              28
            ],
            [
              775,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_addr6",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_bin(const ares_dns_rr_t *dns_rr,\n                                         ares_dns_rr_key_t key, size_t *len)",
          "fn_dec_pos": [
            [
              842,
              21
            ],
            [
              843,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_bin",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_str(const ares_dns_rr_t *dns_rr,\n                                ares_dns_rr_key_t    key)",
          "fn_dec_pos": [
            [
              869,
              12
            ],
            [
              870,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_str",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_addr_to_ptr(const struct ares_addr *addr)",
          "fn_dec_pos": [
            [
              1263,
              6
            ],
            [
              1263,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_addr_to_ptr",
            "parameters": {
              "addr": "struct ares_addr"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_record_duplicate(const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              1426,
              19
            ],
            [
              1426,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_duplicate",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct in_addr",
          {},
          "",
          [
            757,
            6
          ],
          [
            757,
            20
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            760,
            8
          ],
          [
            760,
            22
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            774,
            6
          ],
          [
            774,
            26
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            777,
            8
          ],
          [
            777,
            28
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            983,
            41
          ],
          [
            983,
            55
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            985,
            2
          ],
          [
            985,
            16
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            1002,
            42
          ],
          [
            1002,
            62
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            1004,
            2
          ],
          [
            1004,
            22
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            1263,
            33
          ],
          [
            1263,
            49
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <stdint.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_getsock.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_getsock(ares_channel_t *channel, ares_socket_t *socks,\n                 int numsocks) /* size of the 'socks' array */\n{\n  ares__slist_node_t *snode;\n  size_t              sockindex = 0;\n  unsigned int        bitmap    = 0;\n  unsigned int        setbits   = 0xffffffff;\n\n  /* Are there any active queries? */\n  size_t              active_queries;\n\n  if (channel == NULL || numsocks <= 0) {\n    return 0;\n  }\n\n  ares__channel_lock(channel);\n\n  active_queries = ares__llist_len(channel->all_queries);\n\n  for (snode = ares__slist_node_first(channel->servers); snode != NULL;\n       snode = ares__slist_node_next(snode)) {\n    struct server_state *server = ares__slist_node_val(snode);\n    ares__llist_node_t  *node;\n\n    for (node = ares__llist_node_first(server->connections); node != NULL;\n         node = ares__llist_node_next(node)) {\n      const struct server_connection *conn = ares__llist_node_val(node);\n\n      if (sockindex >= (size_t)numsocks || sockindex >= ARES_GETSOCK_MAXNUM) {\n        break;\n      }\n\n      /* We only need to register interest in UDP sockets if we have\n       * outstanding queries.\n       */\n      if (!active_queries && !conn->is_tcp) {\n        continue;\n      }\n\n      socks[sockindex] = conn->fd;\n\n      if (active_queries || conn->is_tcp) {\n        bitmap |= ARES_GETSOCK_READABLE(setbits, sockindex);\n      }\n\n      if (conn->is_tcp && ares__buf_len(server->tcp_send)) {\n        /* then the tcp socket is also writable! */\n        bitmap |= ARES_GETSOCK_WRITABLE(setbits, sockindex);\n      }\n\n      sockindex++;\n    }\n  }\n\n  ares__channel_unlock(channel);\n  return (int)bitmap;\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getsock",
            "parameters": {
              "channel": "ares_channel_t",
              "socks": "ares_socket_t",
              "numsocks": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct server_state",
          {},
          "",
          [
            52,
            4
          ],
          [
            52,
            23
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            57,
            12
          ],
          [
            57,
            36
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__timeval.c": {
      "fn_def_list": [
        {
          "fn_code": "struct timeval ares__tvnow(void)\n{\n  /*\n  ** GetTickCount() is available on _all_ Windows versions from W95 up\n  ** to nowadays. Returns milliseconds elapsed since last system boot,\n  ** increases monotonically and wraps once 49.7 days have elapsed.\n  */\n  struct timeval now;\n  DWORD          milliseconds = GetTickCount();\n  now.tv_sec                  = (long)milliseconds / 1000;\n  now.tv_usec                 = (long)(milliseconds % 1000) * 1000;\n  return now;\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              44,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__tvnow",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "struct timeval ares__tvnow(void)\n{\n  /*\n  ** clock_gettime() is granted to be increased monotonically when the\n  ** monotonic clock is queried. Time starting point is unspecified, it\n  ** could be the system start-up time, the Epoch, or something else,\n  ** in any case the time starting point does not change once that the\n  ** system has started up.\n  */\n  struct timeval  now;\n  struct timespec tsnow;\n  if (0 == clock_gettime(CLOCK_MONOTONIC, &tsnow)) {\n    now.tv_sec  = tsnow.tv_sec;\n    now.tv_usec = (int)(tsnow.tv_nsec / 1000);\n  }\n  /*\n  ** Even when the configure process has truly detected monotonic clock\n  ** availability, it might happen that it is not actually available at\n  ** run-time. When this occurs simply fallback to other time source.\n  */\n#  ifdef HAVE_GETTIMEOFDAY\n  else\n    (void)gettimeofday(&now, NULL); /* LCOV_EXCL_LINE */\n#  else\n  else {\n    now.tv_sec  = (long)time(NULL);\n    now.tv_usec = 0;\n  }\n#  endif\n  return now;\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              78,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__tvnow",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "struct timeval ares__tvnow(void)\n{\n  /*\n  ** gettimeofday() is not granted to be increased monotonically, due to\n  ** clock drifting and external source time synchronization it can jump\n  ** forward or backward in time.\n  */\n  struct timeval now;\n  (void)gettimeofday(&now, NULL);\n  return now;\n}",
          "fn_code_pos": [
            [
              82,
              0
            ],
            [
              92,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__tvnow",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "struct timeval ares__tvnow(void)\n{\n  /*\n  ** time() returns the value of time in seconds since the Epoch.\n  */\n  struct timeval now;\n  now.tv_sec  = (long)time(NULL);\n  now.tv_usec = 0;\n  return now;\n}",
          "fn_code_pos": [
            [
              96,
              0
            ],
            [
              105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__tvnow",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "else\n    (void)",
          "fn_dec_pos": [
            [
              69,
              2
            ],
            [
              70,
              10
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "else",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct timeval",
          {},
          "",
          [
            32,
            0
          ],
          [
            32,
            14
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            39,
            2
          ],
          [
            39,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            48,
            0
          ],
          [
            48,
            14
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            57,
            2
          ],
          [
            57,
            16
          ]
        ],
        [
          "struct timespec",
          {},
          "",
          [
            58,
            2
          ],
          [
            58,
            17
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            82,
            0
          ],
          [
            82,
            14
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            89,
            2
          ],
          [
            89,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            96,
            0
          ],
          [
            96,
            14
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            101,
            2
          ],
          [
            101,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_strerror.c": {
      "fn_def_list": [
        {
          "fn_code": "const char *ares_strerror(int code)\n{\n  ares_status_t status = (ares_status_t)code;\n  switch (status) {\n    case ARES_SUCCESS:\n      return \"Successful completion\";\n    case ARES_ENODATA:\n      return \"DNS server returned answer with no data\";\n    case ARES_EFORMERR:\n      return \"DNS server claims query was misformatted\";\n    case ARES_ESERVFAIL:\n      return \"DNS server returned general failure\";\n    case ARES_ENOTFOUND:\n      return \"Domain name not found\";\n    case ARES_ENOTIMP:\n      return \"DNS server does not implement requested operation\";\n    case ARES_EREFUSED:\n      return \"DNS server refused query\";\n    case ARES_EBADQUERY:\n      return \"Misformatted DNS query\";\n    case ARES_EBADNAME:\n      return \"Misformatted domain name\";\n    case ARES_EBADFAMILY:\n      return \"Unsupported address family\";\n    case ARES_EBADRESP:\n      return \"Misformatted DNS reply\";\n    case ARES_ECONNREFUSED:\n      return \"Could not contact DNS servers\";\n    case ARES_ETIMEOUT:\n      return \"Timeout while contacting DNS servers\";\n    case ARES_EOF:\n      return \"End of file\";\n    case ARES_EFILE:\n      return \"Error reading file\";\n    case ARES_ENOMEM:\n      return \"Out of memory\";\n    case ARES_EDESTRUCTION:\n      return \"Channel is being destroyed\";\n    case ARES_EBADSTR:\n      return \"Misformatted string\";\n    case ARES_EBADFLAGS:\n      return \"Illegal flags specified\";\n    case ARES_ENONAME:\n      return \"Given hostname is not numeric\";\n    case ARES_EBADHINTS:\n      return \"Illegal hints flags specified\";\n    case ARES_ENOTINITIALIZED:\n      return \"c-ares library initialization not yet performed\";\n    case ARES_ELOADIPHLPAPI:\n      return \"Error loading iphlpapi.dll\";\n    case ARES_EADDRGETNETWORKPARAMS:\n      return \"Could not find GetNetworkParams function\";\n    case ARES_ECANCELLED:\n      return \"DNS query cancelled\";\n    case ARES_ESERVICE:\n      return \"Invalid service name or number\";\n    case ARES_ENOSERVER:\n      return \"No DNS servers were configured\";\n  }\n\n  return \"unknown\";\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              92,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strerror",
            "parameters": {
              "code": "int"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_strerror(int code)",
          "fn_dec_pos": [
            [
              31,
              12
            ],
            [
              31,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strerror",
            "parameters": {
              "code": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_str.c": {
      "fn_def_list": [
        {
          "fn_code": "size_t ares_strlen(const char *str)\n{\n  if (str == NULL) {\n    return 0;\n  }\n\n  return strlen(str);\n}",
          "fn_code_pos": [
            [
              36,
              0
            ],
            [
              43,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strlen",
            "parameters": {
              "str": "char"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "char *ares_strdup(const char *s1)\n{\n  size_t len;\n  char  *out;\n\n  if (s1 == NULL) {\n    return NULL;\n  }\n\n  len = ares_strlen(s1);\n\n  /* Don't see how this is possible */\n  if (len == SIZE_MAX) {\n    return NULL;\n  }\n\n  out = ares_malloc(len + 1);\n  if (out == NULL) {\n    return NULL;\n  }\n\n  if (len) {\n    memcpy(out, s1, len);\n  }\n\n  out[len] = 0;\n  return out;\n}",
          "fn_code_pos": [
            [
              45,
              0
            ],
            [
              72,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strdup",
            "parameters": {
              "s1": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "size_t ares_strcpy(char *dest, const char *src, size_t dest_size)\n{\n  size_t len = 0;\n\n  if (dest == NULL || dest_size == 0) {\n    return 0;\n  }\n\n  len = ares_strlen(src);\n\n  if (len >= dest_size) {\n    len = dest_size - 1;\n  }\n\n  if (len) {\n    memcpy(dest, src, len);\n  }\n\n  dest[len] = 0;\n  return len;\n}",
          "fn_code_pos": [
            [
              74,
              0
            ],
            [
              94,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strcpy",
            "parameters": {
              "dest": "char",
              "src": "char",
              "dest_size": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares_str_isnum(const char *str)\n{\n  size_t i;\n\n  if (str == NULL || *str == 0) {\n    return ARES_FALSE;\n  }\n\n  for (i = 0; str[i] != 0; i++) {\n    if (str[i] < '0' || str[i] > '9') {\n      return ARES_FALSE;\n    }\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              96,
              0
            ],
            [
              110,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_str_isnum",
            "parameters": {
              "str": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "void ares__str_rtrim(char *str)\n{\n  size_t len;\n  size_t i;\n\n  if (str == NULL) {\n    return;\n  }\n\n  len = ares_strlen(str);\n  for (i = len; i > 0; i--) {\n    if (!ares__isspace(str[i - 1])) {\n      break;\n    }\n  }\n  str[i] = 0;\n}",
          "fn_code_pos": [
            [
              112,
              0
            ],
            [
              128,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__str_rtrim",
            "parameters": {
              "str": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__str_ltrim(char *str)\n{\n  size_t i;\n  size_t len;\n\n  if (str == NULL) {\n    return;\n  }\n\n  for (i = 0; str[i] != 0 && ares__isspace(str[i]); i++) {\n    /* Do nothing */\n  }\n\n  if (i == 0) {\n    return;\n  }\n\n  len = ares_strlen(str);\n  if (i != len) {\n    memmove(str, str + i, len - i);\n  }\n  str[len - i] = 0;\n}",
          "fn_code_pos": [
            [
              130,
              0
            ],
            [
              152,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__str_ltrim",
            "parameters": {
              "str": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__str_trim(char *str)\n{\n  ares__str_ltrim(str);\n  ares__str_rtrim(str);\n}",
          "fn_code_pos": [
            [
              154,
              0
            ],
            [
              158,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__str_trim",
            "parameters": {
              "str": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "unsigned char ares__tolower(unsigned char c)\n{\n  return ares__tolower_lookup[c];\n}",
          "fn_code_pos": [
            [
              185,
              0
            ],
            [
              188,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__tolower",
            "parameters": {
              "c": "unsigned char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares__memeq_ci(const unsigned char *ptr, const unsigned char *val,\n                           size_t len)\n{\n  size_t i;\n  for (i = 0; i < len; i++) {\n    if (ares__tolower_lookup[ptr[i]] != ares__tolower_lookup[val[i]]) {\n      return ARES_FALSE;\n    }\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              190,
              0
            ],
            [
              200,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__memeq_ci",
            "parameters": {
              "ptr": "unsigned char",
              "val": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares__isspace(int ch)\n{\n  switch (ch) {\n    case '\\r':\n    case '\\t':\n    case ' ':\n    case '\\v':\n    case '\\f':\n    case '\\n':\n      return ARES_TRUE;\n    default:\n      break;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              202,
              0
            ],
            [
              216,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__isspace",
            "parameters": {
              "ch": "int"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares__isprint(int ch)\n{\n  if (ch >= 0x20 && ch <= 0x7E) {\n    return ARES_TRUE;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              218,
              0
            ],
            [
              224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__isprint",
            "parameters": {
              "ch": "int"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares__is_hostnamech(int ch)\n{\n  /* [A-Za-z0-9-*._/]\n   * Don't use isalnum() as it is locale-specific\n   */\n  if (ch >= 'A' && ch <= 'Z') {\n    return ARES_TRUE;\n  }\n  if (ch >= 'a' && ch <= 'z') {\n    return ARES_TRUE;\n  }\n  if (ch >= '0' && ch <= '9') {\n    return ARES_TRUE;\n  }\n  if (ch == '-' || ch == '.' || ch == '_' || ch == '/' || ch == '*') {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              238,
              0
            ],
            [
              257,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__is_hostnamech",
            "parameters": {
              "ch": "int"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares__is_hostname(const char *str)\n{\n  size_t i;\n  for (i = 0; str[i] != 0; i++) {\n    if (!ares__is_hostnamech(str[i])) {\n      return ARES_FALSE;\n    }\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              259,
              0
            ],
            [
              268,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__is_hostname",
            "parameters": {
              "str": "char"
            },
            "return_type": "ares_bool_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_strdup(const char *s1)",
          "fn_dec_pos": [
            [
              45,
              6
            ],
            [
              45,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strdup",
            "parameters": {
              "s1": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_str.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <stdint.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_event_thread.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares_event_destroy_cb(void *arg)\n{\n  ares_event_t *event = arg;\n  if (event == NULL) {\n    return;\n  }\n\n  /* Unregister from the event thread if it was registered with one */\n  if (event->e) {\n    const ares_event_thread_t *e = event->e;\n    e->ev_sys->event_del(event);\n    event->e = NULL;\n  }\n\n  if (event->free_data_cb && event->data) {\n    event->free_data_cb(event->data);\n  }\n\n  ares_free(event);\n}",
          "fn_code_pos": [
            [
              30,
              0
            ],
            [
              49,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_destroy_cb",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_event_t *ares_event_update_find(ares_event_thread_t *e,\n                                            ares_socket_t fd, const void *data)\n{\n  ares__llist_node_t *node;\n\n  for (node = ares__llist_node_first(e->ev_updates); node != NULL;\n       node = ares__llist_node_next(node)) {\n    ares_event_t *ev = ares__llist_node_val(node);\n\n    if (fd != ARES_SOCKET_BAD && fd == ev->fd && ev->flags != 0) {\n      return ev;\n    }\n\n    if (fd == ARES_SOCKET_BAD && ev->fd == ARES_SOCKET_BAD &&\n        data == ev->data && ev->flags != 0) {\n      return ev;\n    }\n  }\n\n  return NULL;\n}",
          "fn_code_pos": [
            [
              61,
              0
            ],
            [
              81,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_update_find",
            "parameters": {
              "e": "ares_event_thread_t",
              "fd": "ares_socket_t",
              "data": "void"
            },
            "return_type": "ares_event_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_event_update(ares_event_t **event, ares_event_thread_t *e,\n                                ares_event_flags_t flags, ares_event_cb_t cb,\n                                ares_socket_t fd, void *data,\n                                ares_event_free_data_t free_data_cb,\n                                ares_event_signal_cb_t signal_cb)\n{\n  ares_event_t *ev = NULL;\n\n  if (e == NULL || cb == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (event != NULL) {\n    *event = NULL;\n  }\n\n  /* Validate flags */\n  if (fd == ARES_SOCKET_BAD) {\n    if (flags & (ARES_EVENT_FLAG_READ | ARES_EVENT_FLAG_WRITE)) {\n      return ARES_EFORMERR;\n    }\n    if (!(flags & ARES_EVENT_FLAG_OTHER)) {\n      return ARES_EFORMERR;\n    }\n  } else {\n    if (flags & ARES_EVENT_FLAG_OTHER) {\n      return ARES_EFORMERR;\n    }\n  }\n\n  /* That's all the validation we can really do */\n\n  /* See if we have a queued update already */\n  ev = ares_event_update_find(e, fd, data);\n  if (ev == NULL) {\n    /* Allocate a new one */\n    ev = ares_malloc_zero(sizeof(*ev));\n    if (ev == NULL) {\n      return ARES_ENOMEM;\n    }\n\n    if (ares__llist_insert_last(e->ev_updates, ev) == NULL) {\n      ares_free(ev);\n      return ARES_ENOMEM;\n    }\n  }\n\n  ev->flags = flags;\n  ev->fd    = fd;\n  if (ev->cb == NULL) {\n    ev->cb = cb;\n  }\n  if (ev->data == NULL) {\n    ev->data = data;\n  }\n  if (ev->free_data_cb == NULL) {\n    ev->free_data_cb = free_data_cb;\n  }\n  if (ev->signal_cb == NULL) {\n    ev->signal_cb = signal_cb;\n  }\n\n  if (event != NULL) {\n    *event = ev;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              83,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_update",
            "parameters": {
              "event": "ares_event_t",
              "e": "ares_event_thread_t",
              "flags": "ares_event_flags_t",
              "cb": "ares_event_cb_t",
              "fd": "ares_socket_t",
              "data": "void",
              "free_data_cb": "ares_event_free_data_t",
              "signal_cb": "ares_event_signal_cb_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static void ares_event_signal(const ares_event_t *event)\n{\n  if (event == NULL || event->signal_cb == NULL) {\n    return;\n  }\n  event->signal_cb(event);\n}",
          "fn_code_pos": [
            [
              152,
              0
            ],
            [
              158,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_signal",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_event_thread_wake(const ares_event_thread_t *e)\n{\n  if (e == NULL) {\n    return;\n  }\n\n  ares_event_signal(e->ev_signal);\n}",
          "fn_code_pos": [
            [
              160,
              0
            ],
            [
              167,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread_wake",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_event_thread_process_fd(ares_event_thread_t *e,\n                                         ares_socket_t fd, void *data,\n                                         ares_event_flags_t flags)\n{\n  (void)data;\n\n  ares_process_fd(e->channel,\n                  (flags & ARES_EVENT_FLAG_READ) ? fd : ARES_SOCKET_BAD,\n                  (flags & ARES_EVENT_FLAG_WRITE) ? fd : ARES_SOCKET_BAD);\n}",
          "fn_code_pos": [
            [
              169,
              0
            ],
            [
              178,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread_process_fd",
            "parameters": {
              "e": "ares_event_thread_t",
              "fd": "ares_socket_t",
              "data": "void",
              "flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_event_thread_sockstate_cb(void *data, ares_socket_t socket_fd,\n                                           int readable, int writable)\n{\n  ares_event_thread_t *e     = data;\n  ares_event_flags_t   flags = ARES_EVENT_FLAG_NONE;\n\n  if (readable) {\n    flags |= ARES_EVENT_FLAG_READ;\n  }\n\n  if (writable) {\n    flags |= ARES_EVENT_FLAG_WRITE;\n  }\n\n  /* Update channel fd */\n  ares__thread_mutex_lock(e->mutex);\n  ares_event_update(NULL, e, flags, ares_event_thread_process_fd, socket_fd,\n                    NULL, NULL, NULL);\n\n  /* Wake the event thread so it properly enqueues any updates */\n  ares_event_thread_wake(e);\n\n  ares__thread_mutex_unlock(e->mutex);\n}",
          "fn_code_pos": [
            [
              180,
              0
            ],
            [
              203,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread_sockstate_cb",
            "parameters": {
              "data": "void",
              "socket_fd": "ares_socket_t",
              "readable": "int",
              "writable": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_event_process_updates(ares_event_thread_t *e)\n{\n  ares__llist_node_t *node;\n\n  /* Iterate across all updates and apply to internal list, removing from update\n   * list */\n  while ((node = ares__llist_node_first(e->ev_updates)) != NULL) {\n    ares_event_t *newev = ares__llist_node_claim(node);\n    ares_event_t *oldev =\n      ares__htable_asvp_get_direct(e->ev_handles, newev->fd);\n\n    /* Adding new */\n    if (oldev == NULL) {\n      newev->e = e;\n      /* Don't try to add a new event if all flags are cleared, that's basically\n       * someone trying to delete something already deleted.  Also if it fails\n       * to add, cleanup. */\n      if (newev->flags == ARES_EVENT_FLAG_NONE ||\n          !e->ev_sys->event_add(newev)) {\n        newev->e = NULL;\n        ares_event_destroy_cb(newev);\n      } else {\n        ares__htable_asvp_insert(e->ev_handles, newev->fd, newev);\n      }\n      continue;\n    }\n\n    /* Removal request */\n    if (newev->flags == ARES_EVENT_FLAG_NONE) {\n      /* the callback for the removal will call e->ev_sys->event_del(e, event)\n       */\n      ares__htable_asvp_remove(e->ev_handles, newev->fd);\n      ares_free(newev);\n      continue;\n    }\n\n    /* Modify request -- only flags can be changed */\n    e->ev_sys->event_mod(oldev, newev->flags);\n    oldev->flags = newev->flags;\n    ares_free(newev);\n  }\n}",
          "fn_code_pos": [
            [
              205,
              0
            ],
            [
              246,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_process_updates",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void *ares_event_thread(void *arg)\n{\n  ares_event_thread_t *e = arg;\n  ares__thread_mutex_lock(e->mutex);\n\n  while (e->isup) {\n    struct timeval        tv;\n    const struct timeval *tvout;\n    unsigned long         timeout_ms = 0; /* 0 = unlimited */\n\n    tvout = ares_timeout(e->channel, NULL, &tv);\n    if (tvout != NULL) {\n      timeout_ms =\n        (unsigned long)((tvout->tv_sec * 1000) + (tvout->tv_usec / 1000) + 1);\n    }\n\n    ares_event_process_updates(e);\n\n    /* Don't hold a mutex while waiting on events */\n    ares__thread_mutex_unlock(e->mutex);\n    e->ev_sys->wait(e, timeout_ms);\n\n    /* Each iteration should do timeout processing */\n    if (e->isup) {\n      ares_process_fd(e->channel, ARES_SOCKET_BAD, ARES_SOCKET_BAD);\n    }\n\n    /* Relock before we loop again */\n    ares__thread_mutex_lock(e->mutex);\n  }\n\n  ares__thread_mutex_unlock(e->mutex);\n  return NULL;\n}",
          "fn_code_pos": [
            [
              248,
              0
            ],
            [
              281,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_event_thread_destroy_int(ares_event_thread_t *e)\n{\n  ares__llist_node_t *node;\n\n  /* Wake thread and tell it to shutdown if it exists */\n  ares__thread_mutex_lock(e->mutex);\n  if (e->isup) {\n    e->isup = ARES_FALSE;\n    ares_event_thread_wake(e);\n  }\n  ares__thread_mutex_unlock(e->mutex);\n\n  /* Wait for thread to shutdown */\n  if (e->thread) {\n    ares__thread_join(e->thread, NULL);\n    e->thread = NULL;\n  }\n\n  /* Manually free any updates that weren't processed */\n  while ((node = ares__llist_node_first(e->ev_updates)) != NULL) {\n    ares_event_destroy_cb(ares__llist_node_claim(node));\n  }\n  ares__llist_destroy(e->ev_updates);\n  e->ev_updates = NULL;\n\n  ares__htable_asvp_destroy(e->ev_handles);\n  e->ev_handles = NULL;\n\n  if (e->ev_sys && e->ev_sys->destroy) {\n    e->ev_sys->destroy(e);\n  }\n\n  ares__thread_mutex_destroy(e->mutex);\n  e->mutex = NULL;\n\n  ares_free(e);\n}",
          "fn_code_pos": [
            [
              283,
              0
            ],
            [
              319,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread_destroy_int",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_event_thread_destroy(ares_channel_t *channel)\n{\n  ares_event_thread_t *e = channel->sock_state_cb_data;\n\n  if (e == NULL) {\n    return;\n  }\n\n  ares_event_thread_destroy_int(e);\n}",
          "fn_code_pos": [
            [
              321,
              0
            ],
            [
              330,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread_destroy",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static const ares_event_sys_t *ares_event_fetch_sys(ares_evsys_t evsys)\n{\n  switch (evsys) {\n    case ARES_EVSYS_WIN32:\n#if defined(_WIN32)\n      return &ares_evsys_win32;\n#else\n      return NULL;\n#endif\n\n    case ARES_EVSYS_EPOLL:\n#if defined(HAVE_EPOLL)\n      return &ares_evsys_epoll;\n#else\n      return NULL;\n#endif\n\n    case ARES_EVSYS_KQUEUE:\n#if defined(HAVE_KQUEUE)\n      return &ares_evsys_kqueue;\n#else\n      return NULL;\n#endif\n\n    case ARES_EVSYS_POLL:\n#if defined(HAVE_POLL)\n      return &ares_evsys_poll;\n#else\n      return NULL;\n#endif\n\n    case ARES_EVSYS_SELECT:\n#if defined(HAVE_PIPE)\n      return &ares_evsys_select;\n#else\n      return NULL;\n#endif\n\n    /* case ARES_EVSYS_DEFAULT: */\n    default:\n#if defined(_WIN32)\n      return &ares_evsys_win32;\n#elif defined(HAVE_KQUEUE)\n      return &ares_evsys_kqueue;\n#elif defined(HAVE_EPOLL)\n      return &ares_evsys_epoll;\n#elif defined(HAVE_POLL)\n      return &ares_evsys_poll;\n#elif defined(HAVE_PIPE)\n      return &ares_evsys_select;\n#else\n      break;\n#endif\n  }\n\n  return NULL;\n}",
          "fn_code_pos": [
            [
              332,
              0
            ],
            [
              388,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_fetch_sys",
            "parameters": {
              "evsys": "ares_evsys_t"
            },
            "return_type": "ares_event_sys_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_event_thread_init(ares_channel_t *channel)\n{\n  ares_event_thread_t *e;\n\n  e = ares_malloc_zero(sizeof(*e));\n  if (e == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  e->mutex = ares__thread_mutex_create();\n  if (e->mutex == NULL) {\n    ares_event_thread_destroy_int(e);\n    return ARES_ENOMEM;\n  }\n\n  e->ev_updates = ares__llist_create(NULL);\n  if (e->ev_updates == NULL) {\n    ares_event_thread_destroy_int(e);\n    return ARES_ENOMEM;\n  }\n\n  e->ev_handles = ares__htable_asvp_create(ares_event_destroy_cb);\n  if (e->ev_handles == NULL) {\n    ares_event_thread_destroy_int(e);\n    return ARES_ENOMEM;\n  }\n\n  e->channel = channel;\n  e->isup    = ARES_TRUE;\n  e->ev_sys  = ares_event_fetch_sys(channel->evsys);\n  if (e->ev_sys == NULL) {\n    ares_event_thread_destroy_int(e);\n    return ARES_ENOTIMP;\n  }\n\n  channel->sock_state_cb      = ares_event_thread_sockstate_cb;\n  channel->sock_state_cb_data = e;\n\n  if (!e->ev_sys->init(e)) {\n    ares_event_thread_destroy_int(e);\n    channel->sock_state_cb      = NULL;\n    channel->sock_state_cb_data = NULL;\n    return ARES_ESERVFAIL;\n  }\n\n  /* Before starting the thread, process any possible events the initialization\n   * might have enqueued as we may actually depend on these being valid\n   * immediately upon return, which may mean before the thread is fully spawned\n   * and processed the list itself. We don't want any sort of race conditions\n   * (like the event system wake handle itself). */\n  ares_event_process_updates(e);\n\n  /* Start thread */\n  if (ares__thread_create(&e->thread, ares_event_thread, e) != ARES_SUCCESS) {\n    ares_event_thread_destroy_int(e);\n    channel->sock_state_cb      = NULL;\n    channel->sock_state_cb_data = NULL;\n    return ARES_ESERVFAIL;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              390,
              0
            ],
            [
              451,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread_init",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_event_update_find(ares_event_thread_t *e,\n                                            ares_socket_t fd, const void *data)",
          "fn_dec_pos": [
            [
              61,
              21
            ],
            [
              62,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_update_find",
            "parameters": {
              "e": "ares_event_thread_t",
              "fd": "ares_socket_t",
              "data": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_event_thread(void *arg)",
          "fn_dec_pos": [
            [
              248,
              13
            ],
            [
              248,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread",
            "parameters": {
              "arg": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_event_fetch_sys(ares_evsys_t evsys)",
          "fn_dec_pos": [
            [
              332,
              31
            ],
            [
              332,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_fetch_sys",
            "parameters": {
              "evsys": "ares_evsys_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct timeval",
          {},
          "",
          [
            254,
            4
          ],
          [
            254,
            18
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            255,
            10
          ],
          [
            255,
            24
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_event.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_event_select.c": {
      "fn_def_list": [
        {
          "fn_code": "static ares_bool_t ares_evsys_select_init(ares_event_thread_t *e)\n{\n  e->ev_signal = ares_pipeevent_create(e);\n  if (e->ev_signal == NULL) {\n    return ARES_FALSE;\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              37,
              0
            ],
            [
              44,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_select_init",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_select_destroy(ares_event_thread_t *e)\n{\n  (void)e;\n}",
          "fn_code_pos": [
            [
              46,
              0
            ],
            [
              49,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_select_destroy",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_select_event_add(ares_event_t *event)\n{\n  (void)event;\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_select_event_add",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_select_event_del(ares_event_t *event)\n{\n  (void)event;\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_select_event_del",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_evsys_select_event_mod(ares_event_t      *event,\n                                        ares_event_flags_t new_flags)\n{\n  (void)event;\n  (void)new_flags;\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_select_event_mod",
            "parameters": {
              "event": "ares_event_t",
              "new_flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static size_t ares_evsys_select_wait(ares_event_thread_t *e,\n                                     unsigned long        timeout_ms)\n{\n  size_t          num_fds = 0;\n  ares_socket_t  *fdlist  = ares__htable_asvp_keys(e->ev_handles, &num_fds);\n  int             rv;\n  size_t          cnt = 0;\n  size_t          i;\n  fd_set          read_fds;\n  fd_set          write_fds;\n  int             nfds = 0;\n  struct timeval  tv;\n  struct timeval *tout = NULL;\n\n  FD_ZERO(&read_fds);\n  FD_ZERO(&write_fds);\n\n  for (i = 0; i < num_fds; i++) {\n    const ares_event_t *ev =\n      ares__htable_asvp_get_direct(e->ev_handles, fdlist[i]);\n    if (ev->flags & ARES_EVENT_FLAG_READ) {\n      FD_SET(ev->fd, &read_fds);\n    }\n    if (ev->flags & ARES_EVENT_FLAG_WRITE) {\n      FD_SET(ev->fd, &write_fds);\n    }\n    if (ev->fd + 1 > nfds) {\n      nfds = ev->fd + 1;\n    }\n  }\n\n  if (timeout_ms) {\n    tv.tv_sec  = (int)(timeout_ms / 1000);\n    tv.tv_usec = (int)((timeout_ms % 1000) * 1000);\n    tout       = &tv;\n  }\n\n  rv = select(nfds, &read_fds, &write_fds, NULL, tout);\n  if (rv > 0) {\n    for (i = 0; i < num_fds; i++) {\n      ares_event_t      *ev;\n      ares_event_flags_t flags = 0;\n\n      ev = ares__htable_asvp_get_direct(e->ev_handles, fdlist[i]);\n      if (ev == NULL || ev->cb == NULL) {\n        continue;\n      }\n\n      if (FD_ISSET(fdlist[i], &read_fds)) {\n        flags |= ARES_EVENT_FLAG_READ;\n      }\n\n      if (FD_ISSET(fdlist[i], &write_fds)) {\n        flags |= ARES_EVENT_FLAG_WRITE;\n      }\n\n      if (flags == 0) {\n        continue;\n      }\n\n      cnt++;\n\n      ev->cb(e, fdlist[i], ev->data, flags);\n    }\n  }\n\n  ares_free(fdlist);\n\n  return cnt;\n}",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_select_wait",
            "parameters": {
              "e": "ares_event_thread_t",
              "timeout_ms": "unsigned long"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct timeval",
          {},
          "",
          [
            80,
            2
          ],
          [
            80,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            81,
            2
          ],
          [
            81,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_event.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <sys/select.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__htable_asvp.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares__htable_asvp_destroy(ares__htable_asvp_t *htable)\n{\n  if (htable == NULL) {\n    return;\n  }\n\n  ares__htable_destroy(htable->hash);\n  ares_free(htable);\n}",
          "fn_code_pos": [
            [
              42,
              0
            ],
            [
              50,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_asvp_destroy",
            "parameters": {
              "htable": "ares__htable_asvp_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static unsigned int hash_func(const void *key, unsigned int seed)\n{\n  const ares_socket_t *arg = key;\n  return ares__htable_hash_FNV1a((const unsigned char *)arg, sizeof(*arg),\n                                 seed);\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              57,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "hash_func",
            "parameters": {
              "key": "void",
              "seed": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static const void *bucket_key(const void *bucket)\n{\n  const ares__htable_asvp_bucket_t *arg = bucket;\n  return &arg->key;\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_key",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void bucket_free(void *bucket)\n{\n  ares__htable_asvp_bucket_t *arg = bucket;\n\n  if (arg->parent->free_val) {\n    arg->parent->free_val(arg->val);\n  }\n\n  ares_free(arg);\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              74,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_free",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t key_eq(const void *key1, const void *key2)\n{\n  const ares_socket_t *k1 = key1;\n  const ares_socket_t *k2 = key2;\n\n  if (*k1 == *k2) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "key_eq",
            "parameters": {
              "key1": "void",
              "key2": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__htable_asvp_t *\n  ares__htable_asvp_create(ares__htable_asvp_val_free_t val_free)\n{\n  ares__htable_asvp_t *htable = ares_malloc(sizeof(*htable));\n  if (htable == NULL) {\n    goto fail;\n  }\n\n  htable->hash =\n    ares__htable_create(hash_func, bucket_key, bucket_free, key_eq);\n  if (htable->hash == NULL) {\n    goto fail;\n  }\n\n  htable->free_val = val_free;\n\n  return htable;\n\nfail:\n  if (htable) {\n    ares__htable_destroy(htable->hash);\n    ares_free(htable);\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              88,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_asvp_create",
            "parameters": {
              "val_free": "ares__htable_asvp_val_free_t"
            },
            "return_type": "ares__htable_asvp_t"
          }
        },
        {
          "fn_code": "ares_socket_t *ares__htable_asvp_keys(const ares__htable_asvp_t *htable,\n                                      size_t                    *num)\n{\n  const void   **buckets = NULL;\n  size_t         cnt     = 0;\n  ares_socket_t *out     = NULL;\n  size_t         i;\n\n  if (htable == NULL || num == NULL) {\n    return NULL;\n  }\n\n  *num = 0;\n\n  buckets = ares__htable_all_buckets(htable->hash, &cnt);\n  if (buckets == NULL || cnt == 0) {\n    return NULL;\n  }\n\n  out = ares_malloc_zero(sizeof(*out) * cnt);\n  if (out == NULL) {\n    ares_free(buckets);\n    return NULL;\n  }\n\n  for (i = 0; i < cnt; i++) {\n    out[i] = ((const ares__htable_asvp_bucket_t *)buckets[i])->key;\n  }\n\n  ares_free(buckets);\n  *num = cnt;\n  return out;\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              146,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_asvp_keys",
            "parameters": {
              "htable": "ares__htable_asvp_t",
              "num": "size_t"
            },
            "return_type": "ares_socket_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares__htable_asvp_insert(ares__htable_asvp_t *htable,\n                                     ares_socket_t key, void *val)\n{\n  ares__htable_asvp_bucket_t *bucket = NULL;\n\n  if (htable == NULL) {\n    goto fail;\n  }\n\n  bucket = ares_malloc(sizeof(*bucket));\n  if (bucket == NULL) {\n    goto fail;\n  }\n\n  bucket->parent = htable;\n  bucket->key    = key;\n  bucket->val    = val;\n\n  if (!ares__htable_insert(htable->hash, bucket)) {\n    goto fail;\n  }\n\n  return ARES_TRUE;\n\nfail:\n  if (bucket) {\n    ares_free(bucket);\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              148,
              0
            ],
            [
              177,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_asvp_insert",
            "parameters": {
              "htable": "ares__htable_asvp_t",
              "key": "ares_socket_t",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares__htable_asvp_get(const ares__htable_asvp_t *htable,\n                                  ares_socket_t key, void **val)\n{\n  ares__htable_asvp_bucket_t *bucket = NULL;\n\n  if (val) {\n    *val = NULL;\n  }\n\n  if (htable == NULL) {\n    return ARES_FALSE;\n  }\n\n  bucket = ares__htable_get(htable->hash, &key);\n  if (bucket == NULL) {\n    return ARES_FALSE;\n  }\n\n  if (val) {\n    *val = bucket->val;\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              179,
              0
            ],
            [
              201,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_asvp_get",
            "parameters": {
              "htable": "ares__htable_asvp_t",
              "key": "ares_socket_t",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "void *ares__htable_asvp_get_direct(const ares__htable_asvp_t *htable,\n                                   ares_socket_t              key)\n{\n  void *val = NULL;\n  ares__htable_asvp_get(htable, key, &val);\n  return val;\n}",
          "fn_code_pos": [
            [
              203,
              0
            ],
            [
              209,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_asvp_get_direct",
            "parameters": {
              "htable": "ares__htable_asvp_t",
              "key": "ares_socket_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_bool_t ares__htable_asvp_remove(ares__htable_asvp_t *htable,\n                                     ares_socket_t        key)\n{\n  if (htable == NULL) {\n    return ARES_FALSE;\n  }\n\n  return ares__htable_remove(htable->hash, &key);\n}",
          "fn_code_pos": [
            [
              211,
              0
            ],
            [
              219,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_asvp_remove",
            "parameters": {
              "htable": "ares__htable_asvp_t",
              "key": "ares_socket_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "size_t ares__htable_asvp_num_keys(const ares__htable_asvp_t *htable)\n{\n  if (htable == NULL) {\n    return 0;\n  }\n  return ares__htable_num_keys(htable->hash);\n}",
          "fn_code_pos": [
            [
              221,
              0
            ],
            [
              227,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_asvp_num_keys",
            "parameters": {
              "htable": "ares__htable_asvp_t"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "bucket_key(const void *bucket)",
          "fn_dec_pos": [
            [
              59,
              19
            ],
            [
              59,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bucket_key",
            "parameters": {
              "bucket": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_asvp_create(ares__htable_asvp_val_free_t val_free)",
          "fn_dec_pos": [
            [
              89,
              2
            ],
            [
              89,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_asvp_create",
            "parameters": {
              "val_free": "ares__htable_asvp_val_free_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_asvp_keys(const ares__htable_asvp_t *htable,\n                                      size_t                    *num)",
          "fn_dec_pos": [
            [
              114,
              15
            ],
            [
              115,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_asvp_keys",
            "parameters": {
              "htable": "ares__htable_asvp_t",
              "num": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_asvp_get_direct(const ares__htable_asvp_t *htable,\n                                   ares_socket_t              key)",
          "fn_dec_pos": [
            [
              203,
              6
            ],
            [
              204,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_asvp_get_direct",
            "parameters": {
              "htable": "ares__htable_asvp_t",
              "key": "ares_socket_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares__htable_asvp {\n  ares__htable_asvp_val_free_t free_val;\n  ares__htable_t              *hash;\n}",
          {
            "free_val": "ares__htable_asvp_val_free_t",
            "*hash": "ares__htable_t"
          },
          "ares__htable_asvp",
          [
            31,
            0
          ],
          [
            34,
            1
          ]
        ],
        [
          "typedef struct {\n  ares_socket_t        key;\n  void                *val;\n  ares__htable_asvp_t *parent;\n} ares__htable_asvp_bucket_t;",
          {
            "key": "ares_socket_t",
            "*val": "void",
            "*parent": "ares__htable_asvp_t"
          },
          "ares__htable_asvp_bucket_t",
          [
            36,
            0
          ],
          [
            40,
            29
          ]
        ],
        [
          "struct ares__htable_asvp {\n  ares__htable_asvp_val_free_t free_val;\n  ares__htable_t              *hash;\n}",
          {
            "free_val": "ares__htable_asvp_val_free_t",
            "*hash": "ares__htable_t"
          },
          "ares__htable_asvp",
          [
            31,
            0
          ],
          [
            34,
            1
          ]
        ],
        [
          "typedef struct {\n  ares_socket_t        key;\n  void                *val;\n  ares__htable_asvp_t *parent;\n} ares__htable_asvp_bucket_t;",
          {
            "key": "ares_socket_t",
            "*val": "void",
            "*parent": "ares__htable_asvp_t"
          },
          "ares__htable_asvp_bucket_t",
          [
            36,
            0
          ],
          [
            40,
            29
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares__htable.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares__htable_asvp.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_free_string.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_free_string(void *str)\n{\n  ares_free(str);\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              35,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_free_string",
            "parameters": {
              "str": "void"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_version.c": {
      "fn_def_list": [
        {
          "fn_code": "const char *ares_version(int *version)\n{\n  if (version) {\n    *version = ARES_VERSION;\n  }\n\n  return ARES_VERSION_STR;\n}",
          "fn_code_pos": [
            [
              29,
              0
            ],
            [
              36,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_version",
            "parameters": {
              "version": "int"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_version(int *version)",
          "fn_dec_pos": [
            [
              29,
              12
            ],
            [
              29,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_version",
            "parameters": {
              "version": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_parse_srv_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_parse_srv_reply(const unsigned char *abuf, int alen_int,\n                         struct ares_srv_reply **srv_out)\n{\n  ares_status_t          status;\n  size_t                 alen;\n  struct ares_srv_reply *srv_head = NULL;\n  struct ares_srv_reply *srv_last = NULL;\n  struct ares_srv_reply *srv_curr;\n  ares_dns_record_t     *dnsrec = NULL;\n  size_t                 i;\n\n  *srv_out = NULL;\n\n  if (alen_int < 0) {\n    return ARES_EBADRESP;\n  }\n\n  alen = (size_t)alen_int;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP;\n      goto done;\n    }\n\n    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN ||\n        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_SRV) {\n      continue;\n    }\n\n    /* Allocate storage for this SRV answer appending it to the list */\n    srv_curr = ares_malloc_data(ARES_DATATYPE_SRV_REPLY);\n    if (srv_curr == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n\n    /* Link in the record */\n    if (srv_last) {\n      srv_last->next = srv_curr;\n    } else {\n      srv_head = srv_curr;\n    }\n    srv_last = srv_curr;\n\n\n    srv_curr->priority = ares_dns_rr_get_u16(rr, ARES_RR_SRV_PRIORITY);\n    srv_curr->weight   = ares_dns_rr_get_u16(rr, ARES_RR_SRV_WEIGHT);\n    srv_curr->port     = ares_dns_rr_get_u16(rr, ARES_RR_SRV_PORT);\n\n    srv_curr->host = ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_SRV_TARGET));\n\n    if (srv_curr->host == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n  }\n\ndone:\n  /* clean up on error */\n  if (status != ARES_SUCCESS) {\n    if (srv_head) {\n      ares_free_data(srv_head);\n    }\n  } else {\n    /* everything looks fine, return the data */\n    *srv_out = srv_head;\n  }\n  ares_dns_record_destroy(dnsrec);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_srv_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen_int": "int",
              "srv_out": "struct ares_srv_reply"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            32,
            25
          ],
          [
            32,
            46
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            36,
            2
          ],
          [
            36,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            37,
            2
          ],
          [
            37,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            38,
            2
          ],
          [
            38,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_process.c": {
      "fn_def_list": [
        {
          "fn_code": "static void invoke_server_state_cb(const struct server_state *server,\n                                   ares_bool_t                success,\n                                   int                        flags)\n{\n  const ares_channel_t *channel = server->channel;\n  ares__buf_t          *buf;\n  ares_status_t         status;\n  char                 *server_string;\n\n  if (channel->server_state_cb == NULL) {\n    return;\n  }\n\n  buf = ares__buf_create();\n  if (buf == NULL) {\n    return;\n  }\n\n  status = ares_get_server_addr(server, buf);\n  if (status != ARES_SUCCESS) {\n    ares__buf_destroy(buf);\n    return;\n  }\n\n  server_string = ares__buf_finish_str(buf, NULL);\n  buf = NULL;\n  if (server_string == NULL) {\n    return;\n  }\n\n  channel->server_state_cb(server_string, success, flags,\n                           channel->server_state_cb_data);\n  ares_free(server_string);\n}",
          "fn_code_pos": [
            [
              74,
              0
            ],
            [
              107,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "invoke_server_state_cb",
            "parameters": {
              "server": "struct server_state",
              "success": "ares_bool_t",
              "flags": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void server_increment_failures(struct server_state *server,\n                                      ares_bool_t used_tcp)\n{\n  ares__slist_node_t   *node;\n  const ares_channel_t *channel = server->channel;\n  struct timeval        next_retry_time;\n\n  node = ares__slist_node_find(channel->servers, server);\n  if (node == NULL) {\n    return;\n  }\n\n  server->consec_failures++;\n  ares__slist_node_reinsert(node);\n\n  next_retry_time = ares__tvnow();\n  timeadd(&next_retry_time, channel->server_retry_delay);\n  server->next_retry_time = next_retry_time;\n\n  invoke_server_state_cb(server, ARES_FALSE, used_tcp == ARES_TRUE\n                                             ? ARES_SERV_STATE_TCP\n                                             : ARES_SERV_STATE_UDP);\n}",
          "fn_code_pos": [
            [
              109,
              0
            ],
            [
              131,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "server_increment_failures",
            "parameters": {
              "server": "struct server_state",
              "used_tcp": "ares_bool_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void server_set_good(struct server_state *server, ares_bool_t used_tcp)\n{\n  ares__slist_node_t   *node;\n  const ares_channel_t *channel = server->channel;\n\n  node = ares__slist_node_find(channel->servers, server);\n  if (node == NULL) {\n    return;\n  }\n\n  if (server->consec_failures > 0) {\n    server->consec_failures = 0;\n    ares__slist_node_reinsert(node);\n  }\n\n  server->next_retry_time.tv_sec = 0;\n  server->next_retry_time.tv_usec = 0;\n\n  invoke_server_state_cb(server, ARES_TRUE, used_tcp == ARES_TRUE\n                                            ? ARES_SERV_STATE_TCP\n                                            : ARES_SERV_STATE_UDP);\n}",
          "fn_code_pos": [
            [
              133,
              0
            ],
            [
              154,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "server_set_good",
            "parameters": {
              "server": "struct server_state",
              "used_tcp": "ares_bool_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_bool_t ares__timedout(const struct timeval *now,\n                           const struct timeval *check)\n{\n  ares_int64_t secs = ((ares_int64_t)now->tv_sec - (ares_int64_t)check->tv_sec);\n\n  if (secs > 0) {\n    return ARES_TRUE; /* yes, timed out */\n  }\n  if (secs < 0) {\n    return ARES_FALSE; /* nope, not timed out */\n  }\n\n  /* if the full seconds were identical, check the sub second parts */\n  return ((ares_int64_t)now->tv_usec - (ares_int64_t)check->tv_usec) >= 0\n           ? ARES_TRUE\n           : ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              157,
              0
            ],
            [
              173,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__timedout",
            "parameters": {
              "now": "struct timeval",
              "check": "struct timeval"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void timeadd(struct timeval *now, size_t millisecs)\n{\n  now->tv_sec  += (time_t)millisecs / 1000;\n  now->tv_usec += (time_t)((millisecs % 1000) * 1000);\n\n  if (now->tv_usec >= 1000000) {\n    ++(now->tv_sec);\n    now->tv_usec -= 1000000;\n  }\n}",
          "fn_code_pos": [
            [
              176,
              0
            ],
            [
              185,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "timeadd",
            "parameters": {
              "now": "struct timeval",
              "millisecs": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void processfds(ares_channel_t *channel, fd_set *read_fds,\n                       ares_socket_t read_fd, fd_set *write_fds,\n                       ares_socket_t write_fd)\n{\n  struct timeval now;\n\n  if (channel == NULL) {\n    return;\n  }\n\n  ares__channel_lock(channel);\n\n  now = ares__tvnow();\n  read_packets(channel, read_fds, read_fd, &now);\n  process_timeouts(channel, &now);\n  /* Write last as the other 2 operations might have triggered writes */\n  write_tcp_data(channel, write_fds, write_fd);\n\n  ares__channel_unlock(channel);\n}",
          "fn_code_pos": [
            [
              190,
              0
            ],
            [
              209,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processfds",
            "parameters": {
              "channel": "ares_channel_t",
              "read_fds": "fd_set",
              "read_fd": "ares_socket_t",
              "write_fds": "fd_set",
              "write_fd": "ares_socket_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_process(ares_channel_t *channel, fd_set *read_fds, fd_set *write_fds)\n{\n  processfds(channel, read_fds, ARES_SOCKET_BAD, write_fds, ARES_SOCKET_BAD);\n}",
          "fn_code_pos": [
            [
              214,
              0
            ],
            [
              217,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_process",
            "parameters": {
              "channel": "ares_channel_t",
              "read_fds": "fd_set",
              "write_fds": "fd_set"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_process_fd(ares_channel_t *channel,\n                     ares_socket_t   read_fd, /* use ARES_SOCKET_BAD or valid\n                                                 file descriptors */\n                     ares_socket_t   write_fd)\n{\n  processfds(channel, NULL, read_fd, NULL, write_fd);\n}",
          "fn_code_pos": [
            [
              222,
              0
            ],
            [
              228,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_process_fd",
            "parameters": {
              "channel": "ares_channel_t",
              "read_fd": "ares_socket_t",
              "write_fd": "ares_socket_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t try_again(int errnum)\n{\n#if !defined EWOULDBLOCK && !defined EAGAIN\n#  error \"Neither EWOULDBLOCK nor EAGAIN defined\"\n#endif\n\n#ifdef EWOULDBLOCK\n  if (errnum == EWOULDBLOCK) {\n    return ARES_TRUE;\n  }\n#endif\n\n#if defined EAGAIN && EAGAIN != EWOULDBLOCK\n  if (errnum == EAGAIN) {\n    return ARES_TRUE;\n  }\n#endif\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              237,
              0
            ],
            [
              256,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "try_again",
            "parameters": {
              "errnum": "int"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void write_tcp_data(ares_channel_t *channel, fd_set *write_fds,\n                           ares_socket_t write_fd)\n{\n  ares__slist_node_t *node;\n\n  if (!write_fds && (write_fd == ARES_SOCKET_BAD)) {\n    /* no possible action */\n    return;\n  }\n\n  for (node = ares__slist_node_first(channel->servers); node != NULL;\n       node = ares__slist_node_next(node)) {\n    struct server_state *server = ares__slist_node_val(node);\n    const unsigned char *data;\n    size_t               data_len;\n    ares_ssize_t         count;\n\n    /* Make sure server has data to send and is selected in write_fds or\n       write_fd. */\n    if (ares__buf_len(server->tcp_send) == 0 || server->tcp_conn == NULL) {\n      continue;\n    }\n\n    if (write_fds) {\n      if (!FD_ISSET(server->tcp_conn->fd, write_fds)) {\n        continue;\n      }\n    } else {\n      if (server->tcp_conn->fd != write_fd) {\n        continue;\n      }\n    }\n\n    if (write_fds) {\n      /* If there's an error and we close this socket, then open\n       * another with the same fd to talk to another server, then we\n       * don't want to think that it was the new socket that was\n       * ready. This is not disastrous, but is likely to result in\n       * extra system calls and confusion. */\n      FD_CLR(server->tcp_conn->fd, write_fds);\n    }\n\n    data  = ares__buf_peek(server->tcp_send, &data_len);\n    count = ares__socket_write(channel, server->tcp_conn->fd, data, data_len);\n    if (count <= 0) {\n      if (!try_again(SOCKERRNO)) {\n        handle_conn_error(server->tcp_conn, ARES_TRUE);\n      }\n      continue;\n    }\n\n    /* Strip data written from the buffer */\n    ares__buf_consume(server->tcp_send, (size_t)count);\n\n    /* Notify state callback all data is written */\n    if (ares__buf_len(server->tcp_send) == 0) {\n      SOCK_STATE_CALLBACK(channel, server->tcp_conn->fd, 1, 0);\n    }\n  }\n}",
          "fn_code_pos": [
            [
              261,
              0
            ],
            [
              320,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "write_tcp_data",
            "parameters": {
              "channel": "ares_channel_t",
              "write_fds": "fd_set",
              "write_fd": "ares_socket_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void read_tcp_data(ares_channel_t           *channel,\n                          struct server_connection *conn, struct timeval *now)\n{\n  ares_ssize_t         count;\n  struct server_state *server = conn->server;\n\n  /* Fetch buffer to store data we are reading */\n  size_t               ptr_len = 65535;\n  unsigned char       *ptr;\n\n  ptr = ares__buf_append_start(server->tcp_parser, &ptr_len);\n\n  if (ptr == NULL) {\n    handle_conn_error(conn, ARES_FALSE /* not critical to connection */);\n    return; /* bail out on malloc failure. TODO: make this\n               function return error codes */\n  }\n\n  /* Read from socket */\n  count = ares__socket_recv(channel, conn->fd, ptr, ptr_len);\n  if (count <= 0) {\n    ares__buf_append_finish(server->tcp_parser, 0);\n    if (!(count == -1 && try_again(SOCKERRNO))) {\n      handle_conn_error(conn, ARES_TRUE);\n    }\n    return;\n  }\n\n  /* Record amount of data read */\n  ares__buf_append_finish(server->tcp_parser, (size_t)count);\n\n  /* Process all queued answers */\n  while (1) {\n    unsigned short       dns_len  = 0;\n    const unsigned char *data     = NULL;\n    size_t               data_len = 0;\n    ares_status_t        status;\n\n    /* Tag so we can roll back */\n    ares__buf_tag(server->tcp_parser);\n\n    /* Read length indicator */\n    if (ares__buf_fetch_be16(server->tcp_parser, &dns_len) != ARES_SUCCESS) {\n      ares__buf_tag_rollback(server->tcp_parser);\n      break;\n    }\n\n    /* Not enough data for a full response yet */\n    if (ares__buf_consume(server->tcp_parser, dns_len) != ARES_SUCCESS) {\n      ares__buf_tag_rollback(server->tcp_parser);\n      break;\n    }\n\n    /* Can't fail except for misuse */\n    data = ares__buf_tag_fetch(server->tcp_parser, &data_len);\n    if (data == NULL) {\n      ares__buf_tag_clear(server->tcp_parser);\n      break;\n    }\n\n    /* Strip off 2 bytes length */\n    data     += 2;\n    data_len -= 2;\n\n    /* We finished reading this answer; process it */\n    status = process_answer(channel, data, data_len, conn, ARES_TRUE, now);\n    if (status != ARES_SUCCESS) {\n      handle_conn_error(conn, ARES_TRUE);\n      return;\n    }\n\n    /* Since we processed the answer, clear the tag so space can be reclaimed */\n    ares__buf_tag_clear(server->tcp_parser);\n  }\n\n  ares__check_cleanup_conn(channel, conn);\n}",
          "fn_code_pos": [
            [
              326,
              0
            ],
            [
              402,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_tcp_data",
            "parameters": {
              "channel": "ares_channel_t",
              "conn": "struct server_connection",
              "now": "struct timeval"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int socket_list_append(ares_socket_t **socketlist, ares_socket_t fd,\n                              size_t *alloc_cnt, size_t *num)\n{\n  if (*num >= *alloc_cnt) {\n    /* Grow by powers of 2 */\n    size_t         new_alloc = (*alloc_cnt) << 1;\n    ares_socket_t *new_list =\n      ares_realloc(socketlist, new_alloc * sizeof(*new_list));\n    if (new_list == NULL) {\n      return 0;\n    }\n    *alloc_cnt  = new_alloc;\n    *socketlist = new_list;\n  }\n\n  (*socketlist)[(*num)++] = fd;\n  return 1;\n}",
          "fn_code_pos": [
            [
              404,
              0
            ],
            [
              421,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "socket_list_append",
            "parameters": {
              "socketlist": "ares_socket_t",
              "fd": "ares_socket_t",
              "alloc_cnt": "size_t",
              "num": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static ares_socket_t *channel_socket_list(const ares_channel_t *channel,\n                                          size_t               *num)\n{\n  size_t              alloc_cnt = 1 << 4;\n  ares_socket_t      *out       = ares_malloc(alloc_cnt * sizeof(*out));\n  ares__slist_node_t *snode;\n\n  *num = 0;\n\n  if (out == NULL) {\n    return NULL;\n  }\n\n  for (snode = ares__slist_node_first(channel->servers); snode != NULL;\n       snode = ares__slist_node_next(snode)) {\n    struct server_state *server = ares__slist_node_val(snode);\n    ares__llist_node_t  *node;\n\n    for (node = ares__llist_node_first(server->connections); node != NULL;\n         node = ares__llist_node_next(node)) {\n      const struct server_connection *conn = ares__llist_node_val(node);\n\n      if (conn->fd == ARES_SOCKET_BAD) {\n        continue;\n      }\n\n      if (!socket_list_append(&out, conn->fd, &alloc_cnt, num)) {\n        goto fail;\n      }\n    }\n  }\n\n  return out;\n\nfail:\n  ares_free(out);\n  *num = 0;\n  return NULL;\n}",
          "fn_code_pos": [
            [
              423,
              0
            ],
            [
              461,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "channel_socket_list",
            "parameters": {
              "channel": "ares_channel_t",
              "num": "size_t"
            },
            "return_type": "ares_socket_t"
          }
        },
        {
          "fn_code": "static void read_udp_packets_fd(ares_channel_t           *channel,\n                                struct server_connection *conn,\n                                struct timeval           *now)\n{\n  ares_ssize_t  read_len;\n  unsigned char buf[MAXENDSSZ + 1];\n\n#ifdef HAVE_RECVFROM\n  ares_socklen_t fromlen;\n\n  union {\n    struct sockaddr     sa;\n    struct sockaddr_in  sa4;\n    struct sockaddr_in6 sa6;\n  } from;\n\n  memset(&from, 0, sizeof(from));\n#endif\n\n  /* To reduce event loop overhead, read and process as many\n   * packets as we can. */\n  do {\n    if (conn->fd == ARES_SOCKET_BAD) {\n      read_len = -1;\n    } else {\n      if (conn->server->addr.family == AF_INET) {\n        fromlen = sizeof(from.sa4);\n      } else {\n        fromlen = sizeof(from.sa6);\n      }\n      read_len = ares__socket_recvfrom(channel, conn->fd, (void *)buf,\n                                       sizeof(buf), 0, &from.sa, &fromlen);\n    }\n\n    if (read_len == 0) {\n      /* UDP is connectionless, so result code of 0 is a 0-length UDP\n       * packet, and not an indication the connection is closed like on\n       * tcp */\n      continue;\n    } else if (read_len < 0) {\n      if (try_again(SOCKERRNO)) {\n        break;\n      }\n\n      handle_conn_error(conn, ARES_TRUE);\n      return;\n#ifdef HAVE_RECVFROM\n    } else if (!same_address(&from.sa, &conn->server->addr)) {\n      /* The address the response comes from does not match the address we\n       * sent the request to. Someone may be attempting to perform a cache\n       * poisoning attack. */\n      continue;\n#endif\n\n    } else {\n      process_answer(channel, buf, (size_t)read_len, conn, ARES_FALSE, now);\n    }\n\n    /* Try to read again only if *we* set up the socket, otherwise it may be\n     * a blocking socket and would cause recvfrom to hang. */\n  } while (read_len >= 0 && channel->sock_funcs == NULL);\n\n  ares__check_cleanup_conn(channel, conn);\n}",
          "fn_code_pos": [
            [
              464,
              0
            ],
            [
              527,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_udp_packets_fd",
            "parameters": {
              "channel": "ares_channel_t",
              "conn": "struct server_connection",
              "now": "struct timeval"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void read_packets(ares_channel_t *channel, fd_set *read_fds,\n                         ares_socket_t read_fd, struct timeval *now)\n{\n  size_t                    i;\n  ares_socket_t            *socketlist  = NULL;\n  size_t                    num_sockets = 0;\n  struct server_connection *conn        = NULL;\n  ares__llist_node_t       *node        = NULL;\n\n  if (!read_fds && (read_fd == ARES_SOCKET_BAD)) {\n    /* no possible action */\n    return;\n  }\n\n  /* Single socket specified */\n  if (!read_fds) {\n    node = ares__htable_asvp_get_direct(channel->connnode_by_socket, read_fd);\n    if (node == NULL) {\n      return;\n    }\n\n    conn = ares__llist_node_val(node);\n\n    if (conn->is_tcp) {\n      read_tcp_data(channel, conn, now);\n    } else {\n      read_udp_packets_fd(channel, conn, now);\n    }\n\n    return;\n  }\n\n  /* There is no good way to iterate across an fd_set, instead we must pull a\n   * list of all known fds, and iterate across that checking against the fd_set.\n   */\n  socketlist = channel_socket_list(channel, &num_sockets);\n\n  for (i = 0; i < num_sockets; i++) {\n    if (!FD_ISSET(socketlist[i], read_fds)) {\n      continue;\n    }\n\n    /* If there's an error and we close this socket, then open\n     * another with the same fd to talk to another server, then we\n     * don't want to think that it was the new socket that was\n     * ready. This is not disastrous, but is likely to result in\n     * extra system calls and confusion. */\n    FD_CLR(socketlist[i], read_fds);\n\n    node =\n      ares__htable_asvp_get_direct(channel->connnode_by_socket, socketlist[i]);\n    if (node == NULL) {\n      return;\n    }\n\n    conn = ares__llist_node_val(node);\n\n    if (conn->is_tcp) {\n      read_tcp_data(channel, conn, now);\n    } else {\n      read_udp_packets_fd(channel, conn, now);\n    }\n  }\n\n  ares_free(socketlist);\n}",
          "fn_code_pos": [
            [
              529,
              0
            ],
            [
              594,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_packets",
            "parameters": {
              "channel": "ares_channel_t",
              "read_fds": "fd_set",
              "read_fd": "ares_socket_t",
              "now": "struct timeval"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void process_timeouts(ares_channel_t *channel, struct timeval *now)\n{\n  ares__slist_node_t *node =\n    ares__slist_node_first(channel->queries_by_timeout);\n  while (node != NULL) {\n    struct query             *query = ares__slist_node_val(node);\n    /* Node might be removed, cache next */\n    ares__slist_node_t       *next = ares__slist_node_next(node);\n    struct server_connection *conn;\n    /* Since this is sorted, as soon as we hit a query that isn't timed out,\n     * break */\n    if (!ares__timedout(now, &query->timeout)) {\n      break;\n    }\n\n    query->error_status = ARES_ETIMEOUT;\n    query->timeouts++;\n\n    conn = query->conn;\n    server_increment_failures(conn->server, query->using_tcp);\n    ares__requeue_query(query, now);\n    ares__check_cleanup_conn(channel, conn);\n\n    node = next;\n  }\n}",
          "fn_code_pos": [
            [
              597,
              0
            ],
            [
              622,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_timeouts",
            "parameters": {
              "channel": "ares_channel_t",
              "now": "struct timeval"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t rewrite_without_edns(ares_dns_record_t *qdnsrec,\n                                          struct query      *query)\n{\n  ares_status_t  status;\n  size_t         i;\n  ares_bool_t    found_opt_rr = ARES_FALSE;\n  unsigned char *msg          = NULL;\n  size_t         msglen       = 0;\n\n  /* Find and remove the OPT RR record */\n  for (i = 0; i < ares_dns_record_rr_cnt(qdnsrec, ARES_SECTION_ADDITIONAL);\n       i++) {\n    const ares_dns_rr_t *rr;\n    rr = ares_dns_record_rr_get(qdnsrec, ARES_SECTION_ADDITIONAL, i);\n    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_OPT) {\n      ares_dns_record_rr_del(qdnsrec, ARES_SECTION_ADDITIONAL, i);\n      found_opt_rr = ARES_TRUE;\n      break;\n    }\n  }\n\n  if (!found_opt_rr) {\n    status = ARES_EFORMERR;\n    goto done;\n  }\n\n  /* Rewrite the DNS message */\n  status = ares_dns_write(qdnsrec, &msg, &msglen);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  ares_free(query->qbuf);\n  query->qbuf = msg;\n  query->qlen = msglen;\n\ndone:\n  return status;\n}",
          "fn_code_pos": [
            [
              624,
              0
            ],
            [
              662,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rewrite_without_edns",
            "parameters": {
              "qdnsrec": "ares_dns_record_t",
              "query": "struct query"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t process_answer(ares_channel_t      *channel,\n                                    const unsigned char *abuf, size_t alen,\n                                    struct server_connection *conn,\n                                    ares_bool_t tcp, struct timeval *now)\n{\n  struct query        *query;\n  /* Cache these as once ares__send_query() gets called, it may end up\n   * invalidating the connection all-together */\n  struct server_state *server  = conn->server;\n  ares_dns_record_t   *rdnsrec = NULL;\n  ares_dns_record_t   *qdnsrec = NULL;\n  ares_status_t        status;\n  ares_bool_t          is_cached = ARES_FALSE;\n\n  /* Parse the response */\n  status = ares_dns_parse(abuf, alen, 0, &rdnsrec);\n  if (status != ARES_SUCCESS) {\n    /* Malformations are never accepted */\n    status = ARES_EBADRESP;\n    goto cleanup;\n  }\n\n  /* Find the query corresponding to this packet. The queries are\n   * hashed/bucketed by query id, so this lookup should be quick.\n   */\n  query = ares__htable_szvp_get_direct(channel->queries_by_qid,\n                                       ares_dns_record_get_id(rdnsrec));\n  if (!query) {\n    /* We may have stopped listening for this query, that's ok */\n    status = ARES_SUCCESS;\n    goto cleanup;\n  }\n\n  /* Parse the question we sent as we use it to compare */\n  status = ares_dns_parse(query->qbuf, query->qlen, 0, &qdnsrec);\n  if (status != ARES_SUCCESS) {\n    end_query(channel, query, status, NULL);\n    goto cleanup;\n  }\n\n  /* Both the query id and the questions must be the same. We will drop any\n   * replies that aren't for the same query as this is considered invalid. */\n  if (!same_questions(qdnsrec, rdnsrec)) {\n    /* Possible qid conflict due to delayed response, that's ok */\n    status = ARES_SUCCESS;\n    goto cleanup;\n  }\n\n  /* At this point we know we've received an answer for this query, so we should\n   * remove it from the connection's queue so we can possibly invalidate the\n   * connection. Delay cleaning up the connection though as we may enqueue\n   * something new.  */\n  ares__llist_node_destroy(query->node_queries_to_conn);\n  query->node_queries_to_conn = NULL;\n\n  /* If we use EDNS and server answers with FORMERR without an OPT RR, the\n   * protocol extension is not understood by the responder. We must retry the\n   * query without EDNS enabled. */\n  if (ares_dns_record_get_rcode(rdnsrec) == ARES_RCODE_FORMERR &&\n      ares_dns_has_opt_rr(qdnsrec) && !ares_dns_has_opt_rr(rdnsrec)) {\n    status = rewrite_without_edns(qdnsrec, query);\n    if (status != ARES_SUCCESS) {\n      end_query(channel, query, status, NULL);\n      goto cleanup;\n    }\n\n    ares__send_query(query, now);\n    status = ARES_SUCCESS;\n    goto cleanup;\n  }\n\n  /* If we got a truncated UDP packet and are not ignoring truncation,\n   * don't accept the packet, and switch the query to TCP if we hadn't\n   * done so already.\n   */\n  if (ares_dns_record_get_flags(rdnsrec) & ARES_FLAG_TC && !tcp &&\n      !(channel->flags & ARES_FLAG_IGNTC)) {\n    query->using_tcp = ARES_TRUE;\n    ares__send_query(query, now);\n    status = ARES_SUCCESS; /* Switched to TCP is ok */\n    goto cleanup;\n  }\n\n  /* If we aren't passing through all error packets, discard packets\n   * with SERVFAIL, NOTIMP, or REFUSED response codes.\n   */\n  if (!(channel->flags & ARES_FLAG_NOCHECKRESP)) {\n    ares_dns_rcode_t rcode = ares_dns_record_get_rcode(rdnsrec);\n    if (rcode == ARES_RCODE_SERVFAIL || rcode == ARES_RCODE_NOTIMP ||\n        rcode == ARES_RCODE_REFUSED) {\n      switch (rcode) {\n        case ARES_RCODE_SERVFAIL:\n          query->error_status = ARES_ESERVFAIL;\n          break;\n        case ARES_RCODE_NOTIMP:\n          query->error_status = ARES_ENOTIMP;\n          break;\n        case ARES_RCODE_REFUSED:\n          query->error_status = ARES_EREFUSED;\n          break;\n        default:\n          break;\n      }\n\n      server_increment_failures(server, query->using_tcp);\n      ares__requeue_query(query, now);\n\n      /* Should any of these cause a connection termination?\n       * Maybe SERVER_FAILURE? */\n      status = ARES_SUCCESS;\n      goto cleanup;\n    }\n  }\n\n  /* If cache insertion was successful, it took ownership.  We ignore\n   * other cache insertion failures. */\n  if (ares_qcache_insert(channel, now, query, rdnsrec) == ARES_SUCCESS) {\n    is_cached = ARES_TRUE;\n  }\n\n  server_set_good(server, query->using_tcp);\n  end_query(channel, query, ARES_SUCCESS, rdnsrec);\n\n  status = ARES_SUCCESS;\n\ncleanup:\n  /* Don't cleanup the cached pointer to the dns response */\n  if (!is_cached) {\n    ares_dns_record_destroy(rdnsrec);\n  }\n\n  ares_dns_record_destroy(qdnsrec);\n  return status;\n}",
          "fn_code_pos": [
            [
              667,
              0
            ],
            [
              800,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_answer",
            "parameters": {
              "channel": "ares_channel_t",
              "abuf": "unsigned char",
              "alen": "size_t",
              "conn": "struct server_connection",
              "tcp": "ares_bool_t",
              "now": "struct timeval"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static void handle_conn_error(struct server_connection *conn,\n                              ares_bool_t               critical_failure)\n{\n  struct server_state *server = conn->server;\n\n  /* Increment failures first before requeue so it is unlikely to requeue\n   * to the same server */\n  if (critical_failure) {\n    server_increment_failures(server, conn->is_tcp);\n  }\n\n  /* This will requeue any connections automatically */\n  ares__close_connection(conn);\n}",
          "fn_code_pos": [
            [
              802,
              0
            ],
            [
              815,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "handle_conn_error",
            "parameters": {
              "conn": "struct server_connection",
              "critical_failure": "ares_bool_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares__requeue_query(struct query *query, struct timeval *now)\n{\n  ares_channel_t *channel = query->channel;\n  size_t max_tries        = ares__slist_len(channel->servers) * channel->tries;\n\n  query->try_count++;\n\n  if (query->try_count < max_tries && !query->no_retries) {\n    return ares__send_query(query, now);\n  }\n\n  /* If we are here, all attempts to perform query failed. */\n  if (query->error_status == ARES_SUCCESS) {\n    query->error_status = ARES_ETIMEOUT;\n  }\n\n  end_query(channel, query, query->error_status, NULL);\n  return ARES_ETIMEOUT;\n}",
          "fn_code_pos": [
            [
              817,
              0
            ],
            [
              835,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__requeue_query",
            "parameters": {
              "query": "struct query",
              "now": "struct timeval"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static struct server_state *ares__random_server(ares_channel_t *channel)\n{\n  unsigned char       c;\n  size_t              cnt;\n  size_t              idx;\n  ares__slist_node_t *node;\n  size_t              num_servers = ares__slist_len(channel->servers);\n\n  /* Silence coverity, not possible */\n  if (num_servers == 0) {\n    return NULL;\n  }\n\n  ares__rand_bytes(channel->rand_state, &c, 1);\n\n  cnt = c;\n  idx = cnt % num_servers;\n\n  cnt = 0;\n  for (node = ares__slist_node_first(channel->servers); node != NULL;\n       node = ares__slist_node_next(node)) {\n    if (cnt == idx) {\n      return ares__slist_node_val(node);\n    }\n\n    cnt++;\n  }\n\n  return NULL;\n}",
          "fn_code_pos": [
            [
              840,
              0
            ],
            [
              869,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__random_server",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct server_state *ares__failover_server(ares_channel_t *channel)\n{\n  struct server_state *first_server = ares__slist_first_val(channel->servers);\n  struct server_state *last_server  = ares__slist_last_val(channel->servers);\n  unsigned short       r;\n\n  /* Defensive code against no servers being available on the channel. */\n  if (first_server == NULL) {\n    return NULL;\n  }\n\n  /* If no servers have failures, then prefer the first server in the list. */\n  if (last_server != NULL && last_server->consec_failures == 0) {\n    return first_server;\n  }\n\n  /* If we are not configured with a server retry chance then return the first\n   * server.\n   */\n  if (channel->server_retry_chance == 0) {\n    return first_server;\n  }\n\n  /* Generate a random value to decide whether to retry a failed server. The\n   * probability to use is 1/channel->server_retry_chance, rounded up to a\n   * precision of 1/2^B where B is the number of bits in the random value.\n   * We use an unsigned short for the random value for increased precision.\n   */\n  ares__rand_bytes(channel->rand_state, (unsigned char *)&r, sizeof(r));\n  if (r % channel->server_retry_chance == 0) {\n    /* Select a suitable failed server to retry. */\n    struct timeval      now = ares__tvnow();\n    ares__slist_node_t *node;\n    for (node = ares__slist_node_first(channel->servers); node != NULL;\n         node = ares__slist_node_next(node)) {\n      struct server_state *node_val = ares__slist_node_val(node);\n      if (node_val != NULL && node_val->consec_failures > 0 &&\n          ares__timedout(&now, &node_val->next_retry_time)) {\n        return node_val;\n      }\n    }\n  }\n\n  /* If we have not returned yet, then return the first server. */\n  return first_server;\n}",
          "fn_code_pos": [
            [
              884,
              0
            ],
            [
              929,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__failover_server",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static ares_status_t ares__append_tcpbuf(struct server_state *server,\n                                         const struct query  *query)\n{\n  ares_status_t status;\n\n  status = ares__buf_append_be16(server->tcp_send, (unsigned short)query->qlen);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n  return ares__buf_append(server->tcp_send, query->qbuf, query->qlen);\n}",
          "fn_code_pos": [
            [
              931,
              0
            ],
            [
              941,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__append_tcpbuf",
            "parameters": {
              "server": "struct server_state",
              "query": "struct query"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static size_t ares__calc_query_timeout(const struct query *query)\n{\n  const ares_channel_t *channel  = query->channel;\n  size_t                timeplus = channel->timeout;\n  size_t                rounds;\n  size_t                num_servers = ares__slist_len(channel->servers);\n\n  if (num_servers == 0) {\n    return 0;\n  }\n\n  /* For each trip through the entire server list, we want to double the\n   * retry from the last retry */\n  rounds = (query->try_count / num_servers);\n  if (rounds > 0) {\n    timeplus <<= rounds;\n  }\n\n  if (channel->maxtimeout && timeplus > channel->maxtimeout) {\n    timeplus = channel->maxtimeout;\n  }\n\n  /* Add some jitter to the retry timeout.\n   *\n   * Jitter is needed in situation when resolve requests are performed\n   * simultaneously from multiple hosts and DNS server throttle these requests.\n   * Adding randomness allows to avoid synchronisation of retries.\n   *\n   * Value of timeplus adjusted randomly to the range [0.5 * timeplus,\n   * timeplus].\n   */\n  if (rounds > 0) {\n    unsigned short r;\n    float          delta_multiplier;\n\n    ares__rand_bytes(channel->rand_state, (unsigned char *)&r, sizeof(r));\n    delta_multiplier  = ((float)r / USHRT_MAX) * 0.5f;\n    timeplus         -= (size_t)((float)timeplus * delta_multiplier);\n  }\n\n  /* We want explicitly guarantee that timeplus is greater or equal to timeout\n   * specified in channel options. */\n  if (timeplus < channel->timeout) {\n    timeplus = channel->timeout;\n  }\n\n  return timeplus;\n}",
          "fn_code_pos": [
            [
              943,
              0
            ],
            [
              990,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__calc_query_timeout",
            "parameters": {
              "query": "struct query"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__send_query(struct query *query, struct timeval *now)\n{\n  ares_channel_t           *channel = query->channel;\n  struct server_state      *server;\n  struct server_connection *conn;\n  size_t                    timeplus;\n  ares_status_t             status;\n  ares_bool_t               new_connection = ARES_FALSE;\n\n  query->conn = NULL;\n\n  /* Choose the server to send the query to */\n  if (channel->rotate) {\n    /* Pull random server */\n    server = ares__random_server(channel);\n  } else {\n    /* Pull server with failover behavior */\n    server = ares__failover_server(channel);\n  }\n\n  if (server == NULL) {\n    end_query(channel, query, ARES_ENOSERVER /* ? */, NULL);\n    return ARES_ENOSERVER;\n  }\n\n  if (query->using_tcp) {\n    size_t prior_len = 0;\n    /* Make sure the TCP socket for this server is set up and queue\n     * a send request.\n     */\n    if (server->tcp_conn == NULL) {\n      new_connection = ARES_TRUE;\n      status         = ares__open_connection(channel, server, ARES_TRUE);\n      switch (status) {\n        /* Good result, continue on */\n        case ARES_SUCCESS:\n          break;\n\n        /* These conditions are retryable as they are server-specific\n         * error codes */\n        case ARES_ECONNREFUSED:\n        case ARES_EBADFAMILY:\n          server_increment_failures(server, query->using_tcp);\n          query->error_status = status;\n          return ares__requeue_query(query, now);\n\n        /* Anything else is not retryable, likely ENOMEM */\n        default:\n          end_query(channel, query, status, NULL);\n          return status;\n      }\n    }\n\n    conn = server->tcp_conn;\n\n    prior_len = ares__buf_len(server->tcp_send);\n\n    status = ares__append_tcpbuf(server, query);\n    if (status != ARES_SUCCESS) {\n      end_query(channel, query, status, NULL);\n\n      /* Only safe to kill connection if it was new, otherwise it should be\n       * cleaned up by another process later */\n      if (new_connection) {\n        ares__close_connection(conn);\n      }\n      return status;\n    }\n\n    if (prior_len == 0) {\n      SOCK_STATE_CALLBACK(channel, conn->fd, 1, 1);\n    }\n\n  } else {\n    ares__llist_node_t *node = ares__llist_node_first(server->connections);\n\n    /* Don't use the found connection if we've gone over the maximum number\n     * of queries. Also, skip over the TCP connection if it is the first in\n     * the list */\n    if (node != NULL) {\n      conn = ares__llist_node_val(node);\n      if (conn->is_tcp) {\n        node = NULL;\n      } else if (channel->udp_max_queries > 0 &&\n                 conn->total_queries >= channel->udp_max_queries) {\n        node = NULL;\n      }\n    }\n\n    if (node == NULL) {\n      new_connection = ARES_TRUE;\n      status         = ares__open_connection(channel, server, ARES_FALSE);\n      switch (status) {\n        /* Good result, continue on */\n        case ARES_SUCCESS:\n          break;\n\n        /* These conditions are retryable as they are server-specific\n         * error codes */\n        case ARES_ECONNREFUSED:\n        case ARES_EBADFAMILY:\n          server_increment_failures(server, query->using_tcp);\n          query->error_status = status;\n          return ares__requeue_query(query, now);\n\n        /* Anything else is not retryable, likely ENOMEM */\n        default:\n          end_query(channel, query, status, NULL);\n          return status;\n      }\n      node = ares__llist_node_first(server->connections);\n    }\n\n    conn = ares__llist_node_val(node);\n    if (ares__socket_write(channel, conn->fd, query->qbuf, query->qlen) == -1) {\n      /* FIXME: Handle EAGAIN here since it likely can happen. */\n      server_increment_failures(server, query->using_tcp);\n      status = ares__requeue_query(query, now);\n\n      /* Only safe to kill connection if it was new, otherwise it should be\n       * cleaned up by another process later */\n      if (new_connection) {\n        ares__close_connection(conn);\n      }\n\n      return status;\n    }\n  }\n\n  timeplus = ares__calc_query_timeout(query);\n  /* Keep track of queries bucketed by timeout, so we can process\n   * timeout events quickly.\n   */\n  ares__slist_node_destroy(query->node_queries_by_timeout);\n  query->timeout = *now;\n  timeadd(&query->timeout, timeplus);\n  query->node_queries_by_timeout =\n    ares__slist_insert(channel->queries_by_timeout, query);\n  if (!query->node_queries_by_timeout) {\n    end_query(channel, query, ARES_ENOMEM, NULL);\n    /* Only safe to kill connection if it was new, otherwise it should be\n     * cleaned up by another process later */\n    if (new_connection) {\n      ares__close_connection(conn);\n    }\n    return ARES_ENOMEM;\n  }\n\n  /* Keep track of queries bucketed by connection, so we can process errors\n   * quickly. */\n  ares__llist_node_destroy(query->node_queries_to_conn);\n  query->node_queries_to_conn =\n    ares__llist_insert_last(conn->queries_to_conn, query);\n\n  if (query->node_queries_to_conn == NULL) {\n    end_query(channel, query, ARES_ENOMEM, NULL);\n    /* Only safe to kill connection if it was new, otherwise it should be\n     * cleaned up by another process later */\n    if (new_connection) {\n      ares__close_connection(conn);\n    }\n    return ARES_ENOMEM;\n  }\n\n  query->conn = conn;\n  conn->total_queries++;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              992,
              0
            ],
            [
              1159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__send_query",
            "parameters": {
              "query": "struct query",
              "now": "struct timeval"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_bool_t same_questions(const ares_dns_record_t *qrec,\n                                  const ares_dns_record_t *arec)\n{\n  size_t      i;\n  ares_bool_t rv = ARES_FALSE;\n\n\n  if (ares_dns_record_query_cnt(qrec) != ares_dns_record_query_cnt(arec)) {\n    goto done;\n  }\n\n  for (i = 0; i < ares_dns_record_query_cnt(qrec); i++) {\n    const char         *qname = NULL;\n    const char         *aname = NULL;\n    ares_dns_rec_type_t qtype;\n    ares_dns_rec_type_t atype;\n    ares_dns_class_t    qclass;\n    ares_dns_class_t    aclass;\n\n    if (ares_dns_record_query_get(qrec, i, &qname, &qtype, &qclass) !=\n          ARES_SUCCESS ||\n        qname == NULL) {\n      goto done;\n    }\n\n    if (ares_dns_record_query_get(arec, i, &aname, &atype, &aclass) !=\n          ARES_SUCCESS ||\n        aname == NULL) {\n      goto done;\n    }\n    if (strcasecmp(qname, aname) != 0 || qtype != atype || qclass != aclass) {\n      goto done;\n    }\n  }\n\n  rv = ARES_TRUE;\n\ndone:\n  return rv;\n}",
          "fn_code_pos": [
            [
              1161,
              0
            ],
            [
              1200,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "same_questions",
            "parameters": {
              "qrec": "ares_dns_record_t",
              "arec": "ares_dns_record_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t same_address(const struct sockaddr  *sa,\n                                const struct ares_addr *aa)\n{\n  const void *addr1;\n  const void *addr2;\n\n  if (sa->sa_family == aa->family) {\n    switch (aa->family) {\n      case AF_INET:\n        addr1 = &aa->addr.addr4;\n        addr2 = &(CARES_INADDR_CAST(struct sockaddr_in *, sa))->sin_addr;\n        if (memcmp(addr1, addr2, sizeof(aa->addr.addr4)) == 0) {\n          return ARES_TRUE; /* match */\n        }\n        break;\n      case AF_INET6:\n        addr1 = &aa->addr.addr6;\n        addr2 = &(CARES_INADDR_CAST(struct sockaddr_in6 *, sa))->sin6_addr;\n        if (memcmp(addr1, addr2, sizeof(aa->addr.addr6)) == 0) {\n          return ARES_TRUE; /* match */\n        }\n        break;\n      default:\n        break; /* LCOV_EXCL_LINE */\n    }\n  }\n  return ARES_FALSE; /* different */\n}",
          "fn_code_pos": [
            [
              1202,
              0
            ],
            [
              1229,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "same_address",
            "parameters": {
              "sa": "struct sockaddr",
              "aa": "struct ares_addr"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_detach_query(struct query *query)\n{\n  /* Remove the query from all the lists in which it is linked */\n  ares__htable_szvp_remove(query->channel->queries_by_qid, query->qid);\n  ares__slist_node_destroy(query->node_queries_by_timeout);\n  ares__llist_node_destroy(query->node_queries_to_conn);\n  ares__llist_node_destroy(query->node_all_queries);\n  query->node_queries_by_timeout = NULL;\n  query->node_queries_to_conn    = NULL;\n  query->node_all_queries        = NULL;\n}",
          "fn_code_pos": [
            [
              1231,
              0
            ],
            [
              1241,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_detach_query",
            "parameters": {
              "query": "struct query"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void end_query(ares_channel_t *channel, struct query *query,\n                      ares_status_t status, const ares_dns_record_t *dnsrec)\n{\n  /* Invoke the callback. */\n  query->callback(query->arg, status, query->timeouts, dnsrec);\n  ares__free_query(query);\n\n  /* Check and notify if no other queries are enqueued on the channel.  This\n   * must come after the callback and freeing the query for 2 reasons.\n   *  1) The callback itself may enqueue a new query\n   *  2) Technically the current query isn't detached until it is free()'d.\n   */\n  ares_queue_notify_empty(channel);\n}",
          "fn_code_pos": [
            [
              1243,
              0
            ],
            [
              1256,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "end_query",
            "parameters": {
              "channel": "ares_channel_t",
              "query": "struct query",
              "status": "ares_status_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__free_query(struct query *query)\n{\n  ares_detach_query(query);\n  /* Zero out some important stuff, to help catch bugs */\n  query->callback = NULL;\n  query->arg      = NULL;\n  /* Deallocate the memory associated with the query */\n  ares_free(query->qbuf);\n\n  ares_free(query);\n}",
          "fn_code_pos": [
            [
              1258,
              0
            ],
            [
              1268,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__free_query",
            "parameters": {
              "query": "struct query"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "timeadd(struct timeval *now, size_t millisecs)",
          "fn_dec_pos": [
            [
              52,
              19
            ],
            [
              52,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "timeadd",
            "parameters": {
              "now": "struct timeval",
              "millisecs": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "try_again(int errnum)",
          "fn_dec_pos": [
            [
              53,
              19
            ],
            [
              53,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "try_again",
            "parameters": {
              "errnum": "int"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "write_tcp_data(ares_channel_t *channel, fd_set *write_fds,\n                                  ares_socket_t write_fd)",
          "fn_dec_pos": [
            [
              54,
              19
            ],
            [
              55,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "write_tcp_data",
            "parameters": {
              "channel": "ares_channel_t",
              "write_fds": "fd_set",
              "write_fd": "ares_socket_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "read_packets(ares_channel_t *channel, fd_set *read_fds,\n                                ares_socket_t read_fd, struct timeval *now)",
          "fn_dec_pos": [
            [
              56,
              19
            ],
            [
              57,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_packets",
            "parameters": {
              "channel": "ares_channel_t",
              "read_fds": "fd_set",
              "read_fd": "ares_socket_t",
              "now": "struct timeval"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "process_timeouts(ares_channel_t *channel, struct timeval *now)",
          "fn_dec_pos": [
            [
              58,
              12
            ],
            [
              58,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_timeouts",
            "parameters": {
              "channel": "ares_channel_t",
              "now": "struct timeval"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "process_answer(ares_channel_t      *channel,\n                                    const unsigned char *abuf, size_t alen,\n                                    struct server_connection *conn,\n                                    ares_bool_t tcp, struct timeval *now)",
          "fn_dec_pos": [
            [
              59,
              21
            ],
            [
              62,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_answer",
            "parameters": {
              "channel": "ares_channel_t",
              "abuf": "unsigned char",
              "alen": "size_t",
              "conn": "struct server_connection",
              "tcp": "ares_bool_t",
              "now": "struct timeval"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "handle_conn_error(struct server_connection *conn,\n                                       ares_bool_t               critical_failure)",
          "fn_dec_pos": [
            [
              63,
              21
            ],
            [
              64,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "handle_conn_error",
            "parameters": {
              "conn": "struct server_connection",
              "critical_failure": "ares_bool_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "same_questions(const ares_dns_record_t *qrec,\n                                    const ares_dns_record_t *arec)",
          "fn_dec_pos": [
            [
              66,
              21
            ],
            [
              67,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "same_questions",
            "parameters": {
              "qrec": "ares_dns_record_t",
              "arec": "ares_dns_record_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "same_address(const struct sockaddr  *sa,\n                                  const struct ares_addr *aa)",
          "fn_dec_pos": [
            [
              68,
              21
            ],
            [
              69,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "same_address",
            "parameters": {
              "sa": "struct sockaddr",
              "aa": "struct ares_addr"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "end_query(ares_channel_t *channel, struct query *query,\n                               ares_status_t status, const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              70,
              21
            ],
            [
              71,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "end_query",
            "parameters": {
              "channel": "ares_channel_t",
              "query": "struct query",
              "status": "ares_status_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "channel_socket_list(const ares_channel_t *channel,\n                                          size_t               *num)",
          "fn_dec_pos": [
            [
              423,
              22
            ],
            [
              424,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "channel_socket_list",
            "parameters": {
              "channel": "ares_channel_t",
              "num": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__random_server(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              840,
              28
            ],
            [
              840,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__random_server",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__failover_server(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              884,
              28
            ],
            [
              884,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__failover_server",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct timeval",
          {},
          "",
          [
            52,
            27
          ],
          [
            52,
            41
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            57,
            55
          ],
          [
            57,
            69
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            58,
            54
          ],
          [
            58,
            68
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            61,
            36
          ],
          [
            61,
            60
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            62,
            53
          ],
          [
            62,
            67
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            63,
            39
          ],
          [
            63,
            63
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            68,
            40
          ],
          [
            68,
            55
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            69,
            40
          ],
          [
            69,
            56
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            70,
            56
          ],
          [
            70,
            68
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            74,
            41
          ],
          [
            74,
            60
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            109,
            38
          ],
          [
            109,
            57
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            114,
            2
          ],
          [
            114,
            16
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            133,
            28
          ],
          [
            133,
            47
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            157,
            33
          ],
          [
            157,
            47
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            158,
            33
          ],
          [
            158,
            47
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            176,
            20
          ],
          [
            176,
            34
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            194,
            2
          ],
          [
            194,
            16
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            273,
            4
          ],
          [
            273,
            23
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            327,
            26
          ],
          [
            327,
            50
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            327,
            58
          ],
          [
            327,
            72
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            330,
            2
          ],
          [
            330,
            21
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            438,
            4
          ],
          [
            438,
            23
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            443,
            12
          ],
          [
            443,
            36
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            465,
            32
          ],
          [
            465,
            56
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            466,
            32
          ],
          [
            466,
            46
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            475,
            4
          ],
          [
            475,
            19
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            476,
            4
          ],
          [
            476,
            22
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            477,
            4
          ],
          [
            477,
            23
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            530,
            48
          ],
          [
            530,
            62
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            535,
            2
          ],
          [
            535,
            26
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            597,
            54
          ],
          [
            597,
            68
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            602,
            4
          ],
          [
            602,
            16
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            605,
            4
          ],
          [
            605,
            28
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            625,
            42
          ],
          [
            625,
            54
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            669,
            36
          ],
          [
            669,
            60
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            670,
            53
          ],
          [
            670,
            67
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            672,
            2
          ],
          [
            672,
            14
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            675,
            2
          ],
          [
            675,
            21
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            802,
            30
          ],
          [
            802,
            54
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            805,
            2
          ],
          [
            805,
            21
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            817,
            34
          ],
          [
            817,
            46
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            817,
            55
          ],
          [
            817,
            69
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            840,
            7
          ],
          [
            840,
            26
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            884,
            7
          ],
          [
            884,
            26
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            886,
            2
          ],
          [
            886,
            21
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            887,
            2
          ],
          [
            887,
            21
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            915,
            4
          ],
          [
            915,
            18
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            919,
            6
          ],
          [
            919,
            25
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            931,
            41
          ],
          [
            931,
            60
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            932,
            47
          ],
          [
            932,
            59
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            943,
            45
          ],
          [
            943,
            57
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            992,
            31
          ],
          [
            992,
            43
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            992,
            52
          ],
          [
            992,
            66
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            995,
            2
          ],
          [
            995,
            21
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            996,
            2
          ],
          [
            996,
            26
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1202,
            38
          ],
          [
            1202,
            53
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            1203,
            38
          ],
          [
            1203,
            54
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            1212,
            36
          ],
          [
            1212,
            54
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            1219,
            36
          ],
          [
            1219,
            55
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            1231,
            30
          ],
          [
            1231,
            42
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            1243,
            47
          ],
          [
            1243,
            59
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            1258,
            22
          ],
          [
            1258,
            34
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#  include <sys/ioctl.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <sys/filio.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#  include <stdint.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include \"ares_dns.h\"\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_getnameinfo.c": {
      "fn_def_list": [
        {
          "fn_code": "static void  ares_getnameinfo_int(ares_channel_t        *channel,\n                                  const struct sockaddr *sa,\n                                  ares_socklen_t salen, int flags_int,\n                                  ares_nameinfo_callback callback, void *arg)\n{\n  const struct sockaddr_in  *addr  = NULL;\n  const struct sockaddr_in6 *addr6 = NULL;\n  struct nameinfo_query     *niquery;\n  unsigned short             port  = 0;\n  unsigned int               flags = (unsigned int)flags_int;\n\n  /* Validate socket address family and length */\n  if ((sa->sa_family == AF_INET) && (salen == sizeof(struct sockaddr_in))) {\n    addr = CARES_INADDR_CAST(struct sockaddr_in *, sa);\n    port = addr->sin_port;\n  } else if ((sa->sa_family == AF_INET6) &&\n             (salen == sizeof(struct sockaddr_in6))) {\n    addr6 = CARES_INADDR_CAST(struct sockaddr_in6 *, sa);\n    port  = addr6->sin6_port;\n  } else {\n    callback(arg, ARES_ENOTIMP, 0, NULL, NULL);\n    return;\n  }\n\n  /* If neither, assume they want a host */\n  if (!(flags & ARES_NI_LOOKUPSERVICE) && !(flags & ARES_NI_LOOKUPHOST)) {\n    flags |= ARES_NI_LOOKUPHOST;\n  }\n\n  /* All they want is a service, no need for DNS */\n  if ((flags & ARES_NI_LOOKUPSERVICE) && !(flags & ARES_NI_LOOKUPHOST)) {\n    char  buf[33];\n    char *service;\n\n    service =\n      lookup_service((unsigned short)(port & 0xffff), flags, buf, sizeof(buf));\n    callback(arg, ARES_SUCCESS, 0, NULL, service);\n    return;\n  }\n\n  /* They want a host lookup */\n  if (flags & ARES_NI_LOOKUPHOST) {\n    /* A numeric host can be handled without DNS */\n    if (flags & ARES_NI_NUMERICHOST) {\n      char  ipbuf[IPBUFSIZ];\n      char  srvbuf[33];\n      char *service = NULL;\n      ipbuf[0]      = 0;\n\n      /* Specifying not to lookup a host, but then saying a host\n       * is required has to be illegal.\n       */\n      if (flags & ARES_NI_NAMEREQD) {\n        callback(arg, ARES_EBADFLAGS, 0, NULL, NULL);\n        return;\n      }\n      if (salen == sizeof(struct sockaddr_in6)) {\n        ares_inet_ntop(AF_INET6, &addr6->sin6_addr, ipbuf, IPBUFSIZ);\n        /* If the system supports scope IDs, use it */\n#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID\n        append_scopeid(addr6, flags, ipbuf, sizeof(ipbuf));\n#endif\n      } else {\n        ares_inet_ntop(AF_INET, &addr->sin_addr, ipbuf, IPBUFSIZ);\n      }\n      /* They also want a service */\n      if (flags & ARES_NI_LOOKUPSERVICE) {\n        service = lookup_service((unsigned short)(port & 0xffff), flags, srvbuf,\n                                 sizeof(srvbuf));\n      }\n      callback(arg, ARES_SUCCESS, 0, ipbuf, service);\n      return;\n    }\n    /* This is where a DNS lookup becomes necessary */\n    else {\n      niquery = ares_malloc(sizeof(struct nameinfo_query));\n      if (!niquery) {\n        callback(arg, ARES_ENOMEM, 0, NULL, NULL);\n        return;\n      }\n      niquery->callback = callback;\n      niquery->arg      = arg;\n      niquery->flags    = flags;\n      niquery->timeouts = 0;\n      if (sa->sa_family == AF_INET) {\n        niquery->family = AF_INET;\n        memcpy(&niquery->addr.addr4, addr, sizeof(niquery->addr.addr4));\n        ares_gethostbyaddr(channel, &addr->sin_addr, sizeof(struct in_addr),\n                           AF_INET, nameinfo_callback, niquery);\n      } else {\n        niquery->family = AF_INET6;\n        memcpy(&niquery->addr.addr6, addr6, sizeof(niquery->addr.addr6));\n        ares_gethostbyaddr(channel, &addr6->sin6_addr,\n                           sizeof(struct ares_in6_addr), AF_INET6,\n                           nameinfo_callback, niquery);\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              88,
              0
            ],
            [
              186,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getnameinfo_int",
            "parameters": {
              "channel": "ares_channel_t",
              "sa": "struct sockaddr",
              "salen": "ares_socklen_t",
              "flags_int": "int",
              "callback": "ares_nameinfo_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_getnameinfo(ares_channel_t *channel, const struct sockaddr *sa,\n                      ares_socklen_t salen, int flags_int,\n                      ares_nameinfo_callback callback, void *arg)\n{\n  if (channel == NULL) {\n    return;\n  }\n\n  ares__channel_lock(channel);\n  ares_getnameinfo_int(channel, sa, salen, flags_int, callback, arg);\n  ares__channel_unlock(channel);\n}",
          "fn_code_pos": [
            [
              188,
              0
            ],
            [
              199,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getnameinfo",
            "parameters": {
              "channel": "ares_channel_t",
              "sa": "struct sockaddr",
              "salen": "ares_socklen_t",
              "flags_int": "int",
              "callback": "ares_nameinfo_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void nameinfo_callback(void *arg, int status, int timeouts,\n                              struct hostent *host)\n{\n  struct nameinfo_query *niquery = (struct nameinfo_query *)arg;\n  char                   srvbuf[33];\n  char                  *service = NULL;\n\n  niquery->timeouts += (size_t)timeouts;\n  if (status == ARES_SUCCESS) {\n    /* They want a service too */\n    if (niquery->flags & ARES_NI_LOOKUPSERVICE) {\n      if (niquery->family == AF_INET) {\n        service = lookup_service(niquery->addr.addr4.sin_port, niquery->flags,\n                                 srvbuf, sizeof(srvbuf));\n      } else {\n        service = lookup_service(niquery->addr.addr6.sin6_port, niquery->flags,\n                                 srvbuf, sizeof(srvbuf));\n      }\n    }\n    /* NOFQDN means we have to strip off the domain name portion.  We do\n       this by determining our own domain name, then searching the string\n       for this domain name and removing it.\n     */\n#ifdef HAVE_GETHOSTNAME\n    if (niquery->flags & ARES_NI_NOFQDN) {\n      char        buf[255];\n      const char *domain;\n      gethostname(buf, 255);\n      if ((domain = strchr(buf, '.')) != NULL) {\n        char *end = ares_striendstr(host->h_name, domain);\n        if (end) {\n          *end = 0;\n        }\n      }\n    }\n#endif\n    niquery->callback(niquery->arg, ARES_SUCCESS, (int)niquery->timeouts,\n                      host->h_name, service);\n    ares_free(niquery);\n    return;\n  }\n  /* We couldn't find the host, but it's OK, we can use the IP */\n  else if (status == ARES_ENOTFOUND && !(niquery->flags & ARES_NI_NAMEREQD)) {\n    char ipbuf[IPBUFSIZ];\n    if (niquery->family == AF_INET) {\n      ares_inet_ntop(AF_INET, &niquery->addr.addr4.sin_addr, ipbuf, IPBUFSIZ);\n    } else {\n      ares_inet_ntop(AF_INET6, &niquery->addr.addr6.sin6_addr, ipbuf, IPBUFSIZ);\n#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID\n      append_scopeid(&niquery->addr.addr6, niquery->flags, ipbuf,\n                     sizeof(ipbuf));\n#endif\n    }\n    /* They want a service too */\n    if (niquery->flags & ARES_NI_LOOKUPSERVICE) {\n      if (niquery->family == AF_INET) {\n        service = lookup_service(niquery->addr.addr4.sin_port, niquery->flags,\n                                 srvbuf, sizeof(srvbuf));\n      } else {\n        service = lookup_service(niquery->addr.addr6.sin6_port, niquery->flags,\n                                 srvbuf, sizeof(srvbuf));\n      }\n    }\n    niquery->callback(niquery->arg, ARES_SUCCESS, (int)niquery->timeouts, ipbuf,\n                      service);\n    ares_free(niquery);\n    return;\n  }\n  niquery->callback(niquery->arg, status, (int)niquery->timeouts, NULL, NULL);\n  ares_free(niquery);\n}",
          "fn_code_pos": [
            [
              201,
              0
            ],
            [
              271,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nameinfo_callback",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "host": "struct hostent"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static char *lookup_service(unsigned short port, unsigned int flags, char *buf,\n                            size_t buflen)\n{\n  const char     *proto;\n  struct servent *sep;\n#ifdef HAVE_GETSERVBYPORT_R\n  struct servent se;\n#endif\n  char        tmpbuf[4096];\n  const char *name;\n  size_t      name_len;\n\n  if (port) {\n    if (flags & ARES_NI_NUMERICSERV) {\n      sep = NULL;\n    } else {\n      if (flags & ARES_NI_UDP) {\n        proto = \"udp\";\n      } else if (flags & ARES_NI_SCTP) {\n        proto = \"sctp\";\n      } else if (flags & ARES_NI_DCCP) {\n        proto = \"dccp\";\n      } else {\n        proto = \"tcp\";\n      }\n#ifdef HAVE_GETSERVBYPORT_R\n      memset(&se, 0, sizeof(se));\n      sep = &se;\n      memset(tmpbuf, 0, sizeof(tmpbuf));\n#  if GETSERVBYPORT_R_ARGS == 6\n      if (getservbyport_r(port, proto, &se, (void *)tmpbuf, sizeof(tmpbuf),\n                          &sep) != 0) {\n        sep = NULL; /* LCOV_EXCL_LINE: buffer large so this never fails */\n      }\n#  elif GETSERVBYPORT_R_ARGS == 5\n      sep = getservbyport_r(port, proto, &se, (void *)tmpbuf, sizeof(tmpbuf));\n#  elif GETSERVBYPORT_R_ARGS == 4\n      if (getservbyport_r(port, proto, &se, (void *)tmpbuf) != 0) {\n        sep = NULL;\n      }\n#  else\n      /* Lets just hope the OS uses TLS! */\n      sep = getservbyport(port, proto);\n#  endif\n#else\n      /* Lets just hope the OS uses TLS! */\n#  if (defined(NETWARE) && !defined(__NOVELL_LIBC__))\n      sep = getservbyport(port, (char *)proto);\n#  else\n      sep = getservbyport(port, proto);\n#  endif\n#endif\n    }\n    if (sep && sep->s_name) {\n      /* get service name */\n      name = sep->s_name;\n    } else {\n      /* get port as a string */\n      snprintf(tmpbuf, sizeof(tmpbuf), \"%u\", (unsigned int)ntohs(port));\n      name = tmpbuf;\n    }\n    name_len = ares_strlen(name);\n    if (name_len < buflen) {\n      /* return it if buffer big enough */\n      memcpy(buf, name, name_len + 1);\n    } else {\n      /* avoid reusing previous one */\n      buf[0] = '\\0'; /* LCOV_EXCL_LINE: no real service names are too big */\n    }\n    return buf;\n  }\n  buf[0] = '\\0';\n  return NULL;\n}",
          "fn_code_pos": [
            [
              273,
              0
            ],
            [
              346,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lookup_service",
            "parameters": {
              "port": "unsigned short",
              "flags": "unsigned int",
              "buf": "char",
              "buflen": "size_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static void append_scopeid(const struct sockaddr_in6 *addr6, unsigned int flags,\n                           char *buf, size_t buflen)\n{\n#  ifdef HAVE_IF_INDEXTONAME\n  int is_ll;\n  int is_mcll;\n#  endif\n  char   tmpbuf[IF_NAMESIZE + 2];\n  size_t bufl;\n\n  tmpbuf[0] = '%';\n\n#  ifdef HAVE_IF_INDEXTONAME\n  is_ll   = IN6_IS_ADDR_LINKLOCAL(&addr6->sin6_addr);\n  is_mcll = IN6_IS_ADDR_MC_LINKLOCAL(&addr6->sin6_addr);\n  if ((flags & ARES_NI_NUMERICSCOPE) || (!is_ll && !is_mcll)) {\n    snprintf(&tmpbuf[1], sizeof(tmpbuf) - 1, \"%lu\",\n             (unsigned long)addr6->sin6_scope_id);\n  } else {\n    if (if_indextoname(addr6->sin6_scope_id, &tmpbuf[1]) == NULL) {\n      snprintf(&tmpbuf[1], sizeof(tmpbuf) - 1, \"%lu\",\n               (unsigned long)addr6->sin6_scope_id);\n    }\n  }\n#  else\n  snprintf(&tmpbuf[1], sizeof(tmpbuf) - 1, \"%lu\",\n           (unsigned long)addr6->sin6_scope_id);\n  (void)flags;\n#  endif\n  tmpbuf[IF_NAMESIZE + 1] = '\\0';\n  bufl                    = ares_strlen(buf);\n\n  if (bufl + ares_strlen(tmpbuf) < buflen) {\n    /* only append the scopeid string if it fits in the target buffer */\n    ares_strcpy(&buf[bufl], tmpbuf, buflen - bufl);\n  }\n}",
          "fn_code_pos": [
            [
              349,
              0
            ],
            [
              385,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "append_scopeid",
            "parameters": {
              "addr6": "struct sockaddr_in6",
              "flags": "unsigned int",
              "buf": "char",
              "buflen": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static char *ares_striendstr(const char *s1, const char *s2)\n{\n  const char *c1;\n  const char *c2;\n  const char *c1_begin;\n  int         lo1;\n  int         lo2;\n  size_t      s1_len = ares_strlen(s1);\n  size_t      s2_len = ares_strlen(s2);\n\n  if (s1 == NULL || s2 == NULL) {\n    return NULL;\n  }\n\n  /* If the substr is longer than the full str, it can't match */\n  if (s2_len > s1_len) {\n    return NULL;\n  }\n\n  /* Jump to the end of s1 minus the length of s2 */\n  c1_begin = s1 + s1_len - s2_len;\n  c1       = c1_begin;\n  c2       = s2;\n  while (c2 < s2 + s2_len) {\n    lo1 = TOLOWER(*c1);\n    lo2 = TOLOWER(*c2);\n    if (lo1 != lo2) {\n      return NULL;\n    } else {\n      c1++;\n      c2++;\n    }\n  }\n  /* Cast off const */\n  return (char *)((size_t)c1_begin);\n}",
          "fn_code_pos": [
            [
              389,
              0
            ],
            [
              424,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_striendstr",
            "parameters": {
              "s1": "char",
              "s2": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "ares_bool_t ares__is_onion_domain(const char *name)\n{\n  if (ares_striendstr(name, \".onion\")) {\n    return ARES_TRUE;\n  }\n\n  if (ares_striendstr(name, \".onion.\")) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              426,
              0
            ],
            [
              437,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__is_onion_domain",
            "parameters": {
              "name": "char"
            },
            "return_type": "ares_bool_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "nameinfo_callback(void *arg, int status, int timeouts,\n                               struct hostent *host)",
          "fn_dec_pos": [
            [
              78,
              13
            ],
            [
              79,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nameinfo_callback",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "host": "struct hostent"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "lookup_service(unsigned short port, unsigned int flags, char *buf,\n                            size_t buflen)",
          "fn_dec_pos": [
            [
              80,
              13
            ],
            [
              81,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lookup_service",
            "parameters": {
              "port": "unsigned short",
              "flags": "unsigned int",
              "buf": "char",
              "buflen": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "append_scopeid(const struct sockaddr_in6 *addr6,\n                           unsigned int scopeid, char *buf, size_t buflen)",
          "fn_dec_pos": [
            [
              83,
              12
            ],
            [
              84,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "append_scopeid",
            "parameters": {
              "addr6": "struct sockaddr_in6",
              "scopeid": "unsigned int",
              "buf": "char",
              "buflen": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_striendstr(const char *s1, const char *s2)",
          "fn_dec_pos": [
            [
              86,
              13
            ],
            [
              86,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_striendstr",
            "parameters": {
              "s1": "char",
              "s2": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "lookup_service(unsigned short port, unsigned int flags, char *buf,\n                            size_t buflen)",
          "fn_dec_pos": [
            [
              273,
              13
            ],
            [
              274,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lookup_service",
            "parameters": {
              "port": "unsigned short",
              "flags": "unsigned int",
              "buf": "char",
              "buflen": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_striendstr(const char *s1, const char *s2)",
          "fn_dec_pos": [
            [
              389,
              13
            ],
            [
              389,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_striendstr",
            "parameters": {
              "s1": "char",
              "s2": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct nameinfo_query {\n  ares_nameinfo_callback callback;\n  void                  *arg;\n\n  union {\n    struct sockaddr_in  addr4;\n    struct sockaddr_in6 addr6;\n  } addr;\n\n  int          family;\n  unsigned int flags;\n  size_t       timeouts;\n}",
          {
            "callback": "ares_nameinfo_callback",
            "*arg": "void",
            "addr": "union {\n    struct sockaddr_in  addr4;\n    struct sockaddr_in6 addr6;\n  }",
            "addr4": "struct sockaddr_in",
            "addr6": "struct sockaddr_in6",
            "family": "int",
            "flags": "unsigned int",
            "timeouts": "size_t"
          },
          "nameinfo_query",
          [
            57,
            0
          ],
          [
            69,
            1
          ]
        ],
        [
          "struct nameinfo_query {\n  ares_nameinfo_callback callback;\n  void                  *arg;\n\n  union {\n    struct sockaddr_in  addr4;\n    struct sockaddr_in6 addr6;\n  } addr;\n\n  int          family;\n  unsigned int flags;\n  size_t       timeouts;\n}",
          {
            "callback": "ares_nameinfo_callback",
            "*arg": "void",
            "addr": "union {\n    struct sockaddr_in  addr4;\n    struct sockaddr_in6 addr6;\n  }",
            "addr4": "struct sockaddr_in",
            "addr6": "struct sockaddr_in6",
            "family": "int",
            "flags": "unsigned int",
            "timeouts": "size_t"
          },
          "nameinfo_query",
          [
            57,
            0
          ],
          [
            69,
            1
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            62,
            4
          ],
          [
            62,
            22
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            63,
            4
          ],
          [
            63,
            23
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            79,
            31
          ],
          [
            79,
            45
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            83,
            33
          ],
          [
            83,
            52
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            89,
            40
          ],
          [
            89,
            55
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            93,
            8
          ],
          [
            93,
            26
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            94,
            8
          ],
          [
            94,
            27
          ]
        ],
        [
          "struct nameinfo_query",
          {},
          "",
          [
            95,
            2
          ],
          [
            95,
            23
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            100,
            53
          ],
          [
            100,
            71
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            104,
            30
          ],
          [
            104,
            49
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            144,
            26
          ],
          [
            144,
            45
          ]
        ],
        [
          "struct nameinfo_query",
          {},
          "",
          [
            163,
            35
          ],
          [
            163,
            56
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            175,
            60
          ],
          [
            175,
            74
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            181,
            34
          ],
          [
            181,
            54
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            188,
            53
          ],
          [
            188,
            68
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            202,
            30
          ],
          [
            202,
            44
          ]
        ],
        [
          "struct nameinfo_query",
          {},
          "",
          [
            204,
            2
          ],
          [
            204,
            23
          ]
        ],
        [
          "struct nameinfo_query",
          {},
          "",
          [
            204,
            36
          ],
          [
            204,
            57
          ]
        ],
        [
          "struct servent",
          {},
          "",
          [
            277,
            2
          ],
          [
            277,
            16
          ]
        ],
        [
          "struct servent",
          {},
          "",
          [
            279,
            2
          ],
          [
            279,
            16
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            349,
            33
          ],
          [
            349,
            52
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#  include <net/if.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#  include <iphlpapi.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include \"ares_ipv6.h\"\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__socket.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_ssize_t ares__socket_recvfrom(ares_channel_t *channel, ares_socket_t s,\n                                   void *data, size_t data_len, int flags,\n                                   struct sockaddr *from,\n                                   ares_socklen_t  *from_len)\n{\n  if (channel->sock_funcs && channel->sock_funcs->arecvfrom) {\n    return channel->sock_funcs->arecvfrom(s, data, data_len, flags, from,\n                                          from_len, channel->sock_func_cb_data);\n  }\n\n#ifdef HAVE_RECVFROM\n  return (ares_ssize_t)recvfrom(s, data, (RECVFROM_TYPE_ARG3)data_len, flags,\n                                from, from_len);\n#else\n  return sread(s, data, data_len);\n#endif\n}",
          "fn_code_pos": [
            [
              61,
              0
            ],
            [
              77,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__socket_recvfrom",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_socket_t",
              "data": "void",
              "data_len": "size_t",
              "flags": "int",
              "from": "struct sockaddr",
              "from_len": "ares_socklen_t"
            },
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "ares_ssize_t ares__socket_recv(ares_channel_t *channel, ares_socket_t s,\n                               void *data, size_t data_len)\n{\n  if (channel->sock_funcs && channel->sock_funcs->arecvfrom) {\n    return channel->sock_funcs->arecvfrom(s, data, data_len, 0, 0, 0,\n                                          channel->sock_func_cb_data);\n  }\n\n  /* sread() is a wrapper for read() or recv() depending on the system */\n  return sread(s, data, data_len);\n}",
          "fn_code_pos": [
            [
              79,
              0
            ],
            [
              89,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__socket_recv",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_socket_t",
              "data": "void",
              "data_len": "size_t"
            },
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "static int setsocknonblock(ares_socket_t sockfd, /* operate on this */\n                           int           nonblock /* TRUE or FALSE */)\n{\n#if defined(USE_BLOCKING_SOCKETS)\n\n  return 0; /* returns success */\n\n#elif defined(HAVE_FCNTL_O_NONBLOCK)\n\n  /* most recent unix versions */\n  int flags;\n  flags = fcntl(sockfd, F_GETFL, 0);\n  if (nonblock) {\n    return fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);\n  } else {\n    return fcntl(sockfd, F_SETFL, flags & (~O_NONBLOCK)); /* LCOV_EXCL_LINE */\n  }\n\n#elif defined(HAVE_IOCTL_FIONBIO)\n\n  /* older unix versions */\n  int flags = nonblock ? 1 : 0;\n  return ioctl(sockfd, FIONBIO, &flags);\n\n#elif defined(HAVE_IOCTLSOCKET_FIONBIO)\n\n#  ifdef WATT32\n  char flags = nonblock ? 1 : 0;\n#  else\n  /* Windows */\n  unsigned long flags = nonblock ? 1UL : 0UL;\n#  endif\n  return ioctlsocket(sockfd, (long)FIONBIO, &flags);\n\n#elif defined(HAVE_IOCTLSOCKET_CAMEL_FIONBIO)\n\n  /* Amiga */\n  long flags = nonblock ? 1L : 0L;\n  return IoctlSocket(sockfd, FIONBIO, flags);\n\n#elif defined(HAVE_SETSOCKOPT_SO_NONBLOCK)\n\n  /* BeOS */\n  long b = nonblock ? 1L : 0L;\n  return setsockopt(sockfd, SOL_SOCKET, SO_NONBLOCK, &b, sizeof(b));\n\n#else\n#  error \"no non-blocking method was found/used/set\"\n#endif\n}",
          "fn_code_pos": [
            [
              96,
              0
            ],
            [
              145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setsocknonblock",
            "parameters": {
              "sockfd": "ares_socket_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void set_ipv6_v6only(ares_socket_t sockfd, int on)\n{\n  (void)setsockopt(sockfd, IPPROTO_IPV6, IPV6_V6ONLY, (void *)&on, sizeof(on));\n}",
          "fn_code_pos": [
            [
              155,
              0
            ],
            [
              158,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_ipv6_v6only",
            "parameters": {
              "sockfd": "ares_socket_t",
              "on": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int configure_socket(ares_socket_t s, struct server_state *server)\n{\n  union {\n    struct sockaddr     sa;\n    struct sockaddr_in  sa4;\n    struct sockaddr_in6 sa6;\n  } local;\n\n  ares_socklen_t  bindlen = 0;\n  ares_channel_t *channel = server->channel;\n\n  /* do not set options for user-managed sockets */\n  if (channel->sock_funcs && channel->sock_funcs->asocket) {\n    return 0;\n  }\n\n  (void)setsocknonblock(s, 1);\n\n#if defined(FD_CLOEXEC) && !defined(MSDOS)\n  /* Configure the socket fd as close-on-exec. */\n  if (fcntl(s, F_SETFD, FD_CLOEXEC) == -1) {\n    return -1; /* LCOV_EXCL_LINE */\n  }\n#endif\n\n  /* Set the socket's send and receive buffer sizes. */\n  if ((channel->socket_send_buffer_size > 0) &&\n      setsockopt(s, SOL_SOCKET, SO_SNDBUF,\n                 (void *)&channel->socket_send_buffer_size,\n                 sizeof(channel->socket_send_buffer_size)) == -1) {\n    return -1;\n  }\n\n  if ((channel->socket_receive_buffer_size > 0) &&\n      setsockopt(s, SOL_SOCKET, SO_RCVBUF,\n                 (void *)&channel->socket_receive_buffer_size,\n                 sizeof(channel->socket_receive_buffer_size)) == -1) {\n    return -1;\n  }\n\n#ifdef SO_BINDTODEVICE\n  if (channel->local_dev_name[0] &&\n      setsockopt(s, SOL_SOCKET, SO_BINDTODEVICE, channel->local_dev_name,\n                 sizeof(channel->local_dev_name))) {\n    /* Only root can do this, and usually not fatal if it doesn't work, so */\n    /* just continue on. */\n  }\n#endif\n\n  if (server->addr.family == AF_INET && channel->local_ip4) {\n    memset(&local.sa4, 0, sizeof(local.sa4));\n    local.sa4.sin_family      = AF_INET;\n    local.sa4.sin_addr.s_addr = htonl(channel->local_ip4);\n    bindlen                   = sizeof(local.sa4);\n  } else if (server->addr.family == AF_INET6 && server->ll_scope == 0 &&\n             memcmp(channel->local_ip6, ares_in6addr_any._S6_un._S6_u8,\n                    sizeof(channel->local_ip6)) != 0) {\n    /* Only if not link-local and an ip other than \"::\" is specified */\n    memset(&local.sa6, 0, sizeof(local.sa6));\n    local.sa6.sin6_family = AF_INET6;\n    memcpy(&local.sa6.sin6_addr, channel->local_ip6,\n           sizeof(channel->local_ip6));\n    bindlen = sizeof(local.sa6);\n  }\n\n  if (bindlen && bind(s, &local.sa, bindlen) < 0) {\n    return -1;\n  }\n\n  if (server->addr.family == AF_INET6) {\n    set_ipv6_v6only(s, 0);\n  }\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              163,
              0
            ],
            [
              237,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "configure_socket",
            "parameters": {
              "s": "ares_socket_t",
              "server": "struct server_state"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_status_t ares__open_connection(ares_channel_t      *channel,\n                                    struct server_state *server,\n                                    ares_bool_t          is_tcp)\n{\n  ares_socket_t  s;\n  int            opt;\n  ares_socklen_t salen;\n\n  union {\n    struct sockaddr_in  sa4;\n    struct sockaddr_in6 sa6;\n  } saddr;\n  struct sockaddr          *sa;\n  struct server_connection *conn;\n  ares__llist_node_t       *node;\n  int                       type = is_tcp ? SOCK_STREAM : SOCK_DGRAM;\n#ifdef __OpenBSD__\n  if ((is_tcp && server->tcp_port == 53) ||\n      (!is_tcp && server->udp_port == 53)) {\n    type |= SOCK_DNS;\n  }\n#endif\n\n  switch (server->addr.family) {\n    case AF_INET:\n      sa    = (void *)&saddr.sa4;\n      salen = sizeof(saddr.sa4);\n      memset(sa, 0, (size_t)salen);\n      saddr.sa4.sin_family = AF_INET;\n      saddr.sa4.sin_port = htons(is_tcp ? server->tcp_port : server->udp_port);\n      memcpy(&saddr.sa4.sin_addr, &server->addr.addr.addr4,\n             sizeof(saddr.sa4.sin_addr));\n      break;\n    case AF_INET6:\n      sa    = (void *)&saddr.sa6;\n      salen = sizeof(saddr.sa6);\n      memset(sa, 0, (size_t)salen);\n      saddr.sa6.sin6_family = AF_INET6;\n      saddr.sa6.sin6_port = htons(is_tcp ? server->tcp_port : server->udp_port);\n      memcpy(&saddr.sa6.sin6_addr, &server->addr.addr.addr6,\n             sizeof(saddr.sa6.sin6_addr));\n#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID\n      saddr.sa6.sin6_scope_id = server->ll_scope;\n#endif\n      break;\n    default:\n      return ARES_EBADFAMILY; /* LCOV_EXCL_LINE */\n  }\n\n  /* Acquire a socket. */\n  s = ares__open_socket(channel, server->addr.family, type, 0);\n  if (s == ARES_SOCKET_BAD) {\n    return ARES_ECONNREFUSED;\n  }\n\n  /* Configure it. */\n  if (configure_socket(s, server) < 0) {\n    ares__close_socket(channel, s);\n    return ARES_ECONNREFUSED;\n  }\n\n#ifdef TCP_NODELAY\n  if (is_tcp) {\n    /*\n     * Disable the Nagle algorithm (only relevant for TCP sockets, and thus not\n     * in configure_socket). In general, in DNS lookups we're pretty much\n     * interested in firing off a single request and then waiting for a reply,\n     * so batching isn't very interesting.\n     */\n    opt = 1;\n    if ((!channel->sock_funcs || !channel->sock_funcs->asocket) &&\n        setsockopt(s, IPPROTO_TCP, TCP_NODELAY, (void *)&opt, sizeof(opt)) ==\n          -1) {\n      ares__close_socket(channel, s);\n      return ARES_ECONNREFUSED;\n    }\n  }\n#endif\n\n  if (channel->sock_config_cb) {\n    int err = channel->sock_config_cb(s, type, channel->sock_config_cb_data);\n    if (err < 0) {\n      ares__close_socket(channel, s);\n      return ARES_ECONNREFUSED;\n    }\n  }\n\n  /* Connect to the server. */\n  if (ares__connect_socket(channel, s, sa, salen) == -1) {\n    int err = SOCKERRNO;\n\n    if (err != EINPROGRESS && err != EWOULDBLOCK) {\n      ares__close_socket(channel, s);\n      return ARES_ECONNREFUSED;\n    }\n  }\n\n  if (channel->sock_create_cb) {\n    int err = channel->sock_create_cb(s, type, channel->sock_create_cb_data);\n    if (err < 0) {\n      ares__close_socket(channel, s);\n      return ARES_ECONNREFUSED;\n    }\n  }\n\n  conn = ares_malloc(sizeof(*conn));\n  if (conn == NULL) {\n    ares__close_socket(channel, s);\n    return ARES_ENOMEM;\n  }\n  memset(conn, 0, sizeof(*conn));\n  conn->fd              = s;\n  conn->server          = server;\n  conn->queries_to_conn = ares__llist_create(NULL);\n  conn->is_tcp          = is_tcp;\n  if (conn->queries_to_conn == NULL) {\n    ares__close_socket(channel, s);\n    ares_free(conn);\n    return ARES_ENOMEM;\n  }\n\n  /* TCP connections are thrown to the end as we don't spawn multiple TCP\n   * connections. UDP connections are put on front where the newest connection\n   * can be quickly pulled */\n  if (is_tcp) {\n    node = ares__llist_insert_last(server->connections, conn);\n  } else {\n    node = ares__llist_insert_first(server->connections, conn);\n  }\n  if (node == NULL) {\n    ares__close_socket(channel, s);\n    ares__llist_destroy(conn->queries_to_conn);\n    ares_free(conn);\n    return ARES_ENOMEM;\n  }\n\n  /* Register globally to quickly map event on file descriptor to connection\n   * node object */\n  if (!ares__htable_asvp_insert(channel->connnode_by_socket, s, node)) {\n    ares__close_socket(channel, s);\n    ares__llist_destroy(conn->queries_to_conn);\n    ares__llist_node_claim(node);\n    ares_free(conn);\n    return ARES_ENOMEM;\n  }\n\n  SOCK_STATE_CALLBACK(channel, s, 1, 0);\n\n  if (is_tcp) {\n    server->tcp_conn = conn;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              239,
              0
            ],
            [
              392,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__open_connection",
            "parameters": {
              "channel": "ares_channel_t",
              "server": "struct server_state",
              "is_tcp": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_socket_t ares__open_socket(ares_channel_t *channel, int af, int type,\n                                int protocol)\n{\n  if (channel->sock_funcs && channel->sock_funcs->asocket) {\n    return channel->sock_funcs->asocket(af, type, protocol,\n                                        channel->sock_func_cb_data);\n  }\n\n  return socket(af, type, protocol);\n}",
          "fn_code_pos": [
            [
              394,
              0
            ],
            [
              403,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__open_socket",
            "parameters": {
              "channel": "ares_channel_t",
              "af": "int",
              "type": "int",
              "protocol": "int"
            },
            "return_type": "ares_socket_t"
          }
        },
        {
          "fn_code": "int ares__connect_socket(ares_channel_t *channel, ares_socket_t sockfd,\n                         const struct sockaddr *addr, ares_socklen_t addrlen)\n{\n  if (channel->sock_funcs && channel->sock_funcs->aconnect) {\n    return channel->sock_funcs->aconnect(sockfd, addr, addrlen,\n                                         channel->sock_func_cb_data);\n  }\n\n  return connect(sockfd, addr, addrlen);\n}",
          "fn_code_pos": [
            [
              405,
              0
            ],
            [
              414,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__connect_socket",
            "parameters": {
              "channel": "ares_channel_t",
              "sockfd": "ares_socket_t",
              "addr": "struct sockaddr",
              "addrlen": "ares_socklen_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void ares__close_socket(ares_channel_t *channel, ares_socket_t s)\n{\n  if (s == ARES_SOCKET_BAD) {\n    return;\n  }\n\n  if (channel->sock_funcs && channel->sock_funcs->aclose) {\n    channel->sock_funcs->aclose(s, channel->sock_func_cb_data);\n  } else {\n    sclose(s);\n  }\n}",
          "fn_code_pos": [
            [
              416,
              0
            ],
            [
              427,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__close_socket",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_socket_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_ssize_t ares__socket_write(ares_channel_t *channel, ares_socket_t s,\n                                const void *data, size_t len)\n{\n  if (channel->sock_funcs && channel->sock_funcs->asendv) {\n    struct iovec vec;\n    vec.iov_base = (void *)((size_t)data); /* Cast off const */\n    vec.iov_len  = len;\n    return channel->sock_funcs->asendv(s, &vec, 1, channel->sock_func_cb_data);\n  }\n  return swrite(s, data, len);\n}",
          "fn_code_pos": [
            [
              437,
              0
            ],
            [
              447,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__socket_write",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_socket_t",
              "data": "void",
              "len": "size_t"
            },
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "void ares_set_socket_callback(ares_channel_t           *channel,\n                              ares_sock_create_callback cb, void *data)\n{\n  if (channel == NULL) {\n    return;\n  }\n  channel->sock_create_cb      = cb;\n  channel->sock_create_cb_data = data;\n}",
          "fn_code_pos": [
            [
              449,
              0
            ],
            [
              457,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_socket_callback",
            "parameters": {
              "channel": "ares_channel_t",
              "cb": "ares_sock_create_callback",
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_set_socket_configure_callback(ares_channel_t           *channel,\n                                        ares_sock_config_callback cb,\n                                        void                     *data)\n{\n  if (channel == NULL || channel->optmask & ARES_OPT_EVENT_THREAD) {\n    return;\n  }\n  channel->sock_config_cb      = cb;\n  channel->sock_config_cb_data = data;\n}",
          "fn_code_pos": [
            [
              459,
              0
            ],
            [
              468,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_socket_configure_callback",
            "parameters": {
              "channel": "ares_channel_t",
              "cb": "ares_sock_config_callback",
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_set_socket_functions(ares_channel_t                     *channel,\n                               const struct ares_socket_functions *funcs,\n                               void                               *data)\n{\n  if (channel == NULL || channel->optmask & ARES_OPT_EVENT_THREAD) {\n    return;\n  }\n  channel->sock_funcs        = funcs;\n  channel->sock_func_cb_data = data;\n}",
          "fn_code_pos": [
            [
              470,
              0
            ],
            [
              479,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_socket_functions",
            "parameters": {
              "channel": "ares_channel_t",
              "funcs": "struct ares_socket_functions",
              "data": "void"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct iovec {\n  void  *iov_base; /* Pointer to data. */\n  size_t iov_len;  /* Length of data.  */\n}",
          {
            "*iov_base": "void",
            "iov_len": "size_t"
          },
          "iovec",
          [
            431,
            0
          ],
          [
            434,
            1
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            63,
            35
          ],
          [
            63,
            50
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            163,
            45
          ],
          [
            163,
            64
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            166,
            4
          ],
          [
            166,
            19
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            167,
            4
          ],
          [
            167,
            22
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            168,
            4
          ],
          [
            168,
            23
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            240,
            36
          ],
          [
            240,
            55
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            248,
            4
          ],
          [
            248,
            22
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            249,
            4
          ],
          [
            249,
            23
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            251,
            2
          ],
          [
            251,
            17
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            252,
            2
          ],
          [
            252,
            26
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            406,
            31
          ],
          [
            406,
            46
          ]
        ],
        [
          "struct iovec {\n  void  *iov_base; /* Pointer to data. */\n  size_t iov_len;  /* Length of data.  */\n}",
          {
            "*iov_base": "void",
            "iov_len": "size_t"
          },
          "iovec",
          [
            431,
            0
          ],
          [
            434,
            1
          ]
        ],
        [
          "struct iovec",
          {},
          "",
          [
            441,
            4
          ],
          [
            441,
            16
          ]
        ],
        [
          "struct ares_socket_functions",
          {},
          "",
          [
            471,
            37
          ],
          [
            471,
            65
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <sys/uio.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#  include <netinet/tcp.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#  include <sys/ioctl.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#  include <sys/filio.h>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__iface_ips.c": {
      "fn_def_list": [
        {
          "fn_code": "static ares__iface_ips_t *ares__iface_ips_alloc(ares__iface_ip_flags_t flags)\n{\n  ares__iface_ips_t *ips = ares_malloc_zero(sizeof(*ips));\n  if (ips == NULL) {\n    return NULL;\n  }\n\n  /* Prealloc 4 entries */\n  ips->alloc_size = 4;\n  ips->ips        = ares_malloc_zero(ips->alloc_size * sizeof(*ips->ips));\n  if (ips->ips == NULL) {\n    ares_free(ips);\n    return NULL;\n  }\n  ips->enum_flags = flags;\n  return ips;\n}",
          "fn_code_pos": [
            [
              79,
              0
            ],
            [
              95,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_alloc",
            "parameters": {
              "flags": "ares__iface_ip_flags_t"
            },
            "return_type": "ares__iface_ips_t"
          }
        },
        {
          "fn_code": "static void ares__iface_ip_destroy(ares__iface_ip_t *ip)\n{\n  if (ip == NULL) {\n    return;\n  }\n  ares_free(ip->name);\n  memset(ip, 0, sizeof(*ip));\n}",
          "fn_code_pos": [
            [
              97,
              0
            ],
            [
              104,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ip_destroy",
            "parameters": {
              "ip": "ares__iface_ip_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__iface_ips_destroy(ares__iface_ips_t *ips)\n{\n  size_t i;\n\n  if (ips == NULL) {\n    return;\n  }\n\n  for (i = 0; i < ips->cnt; i++) {\n    ares__iface_ip_destroy(&ips->ips[i]);\n  }\n  ares_free(ips->ips);\n  ares_free(ips);\n}",
          "fn_code_pos": [
            [
              106,
              0
            ],
            [
              119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_destroy",
            "parameters": {
              "ips": "ares__iface_ips_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares__iface_ips(ares__iface_ips_t    **ips,\n                              ares__iface_ip_flags_t flags, const char *name)\n{\n  ares_status_t status;\n\n  if (ips == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *ips = ares__iface_ips_alloc(flags);\n  if (*ips == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  status = ares__iface_ips_enumerate(*ips, name);\n  if (status != ARES_SUCCESS) {\n    ares__iface_ips_destroy(*ips);\n    *ips = NULL;\n    return status;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              143,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips",
            "parameters": {
              "ips": "ares__iface_ips_t",
              "flags": "ares__iface_ip_flags_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t\n  ares__iface_ips_add(ares__iface_ips_t *ips, ares__iface_ip_flags_t flags,\n                      const char *name, const struct ares_addr *addr,\n                      unsigned char netmask, unsigned int ll_scope)\n{\n  size_t idx;\n\n  if (ips == NULL || name == NULL || addr == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  /* Don't want loopback */\n  if (flags & ARES_IFACE_IP_LOOPBACK &&\n      !(ips->enum_flags & ARES_IFACE_IP_LOOPBACK)) {\n    return ARES_SUCCESS;\n  }\n\n  /* Don't want offline */\n  if (flags & ARES_IFACE_IP_OFFLINE &&\n      !(ips->enum_flags & ARES_IFACE_IP_OFFLINE)) {\n    return ARES_SUCCESS;\n  }\n\n  /* Check for link-local */\n  if (ares__addr_is_linklocal(addr)) {\n    flags |= ARES_IFACE_IP_LINKLOCAL;\n  }\n  if (flags & ARES_IFACE_IP_LINKLOCAL &&\n      !(ips->enum_flags & ARES_IFACE_IP_LINKLOCAL)) {\n    return ARES_SUCCESS;\n  }\n\n  /* Set address flag based on address provided */\n  if (addr->family == AF_INET) {\n    flags |= ARES_IFACE_IP_V4;\n  }\n\n  if (addr->family == AF_INET6) {\n    flags |= ARES_IFACE_IP_V6;\n  }\n\n  /* If they specified either v4 or v6 validate flags otherwise assume they\n   * want to enumerate both */\n  if (ips->enum_flags & (ARES_IFACE_IP_V4 | ARES_IFACE_IP_V6)) {\n    if (flags & ARES_IFACE_IP_V4 && !(ips->enum_flags & ARES_IFACE_IP_V4)) {\n      return ARES_SUCCESS;\n    }\n    if (flags & ARES_IFACE_IP_V6 && !(ips->enum_flags & ARES_IFACE_IP_V6)) {\n      return ARES_SUCCESS;\n    }\n  }\n\n  /* Allocate more ips */\n  if (ips->cnt + 1 > ips->alloc_size) {\n    void  *temp;\n    size_t alloc_size;\n\n    alloc_size = ares__round_up_pow2(ips->alloc_size + 1);\n    temp = ares_realloc_zero(ips->ips, ips->alloc_size * sizeof(*ips->ips),\n                             alloc_size * sizeof(*ips->ips));\n    if (temp == NULL) {\n      return ARES_ENOMEM;\n    }\n    ips->ips        = temp;\n    ips->alloc_size = alloc_size;\n  }\n\n  /* Add */\n  idx = ips->cnt++;\n\n  ips->ips[idx].flags    = flags;\n  ips->ips[idx].netmask  = netmask;\n  ips->ips[idx].ll_scope = ll_scope;\n  memcpy(&ips->ips[idx].addr, addr, sizeof(*addr));\n  ips->ips[idx].name = ares_strdup(name);\n  if (ips->ips[idx].name == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              145,
              0
            ],
            [
              225,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_add",
            "parameters": {
              "ips": "ares__iface_ips_t",
              "flags": "ares__iface_ip_flags_t",
              "name": "char",
              "addr": "struct ares_addr",
              "netmask": "unsigned char",
              "ll_scope": "unsigned int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "size_t ares__iface_ips_cnt(const ares__iface_ips_t *ips)\n{\n  if (ips == NULL) {\n    return 0;\n  }\n  return ips->cnt;\n}",
          "fn_code_pos": [
            [
              227,
              0
            ],
            [
              233,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_cnt",
            "parameters": {
              "ips": "ares__iface_ips_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "const char *ares__iface_ips_get_name(const ares__iface_ips_t *ips, size_t idx)\n{\n  if (ips == NULL || idx >= ips->cnt) {\n    return NULL;\n  }\n  return ips->ips[idx].name;\n}",
          "fn_code_pos": [
            [
              235,
              0
            ],
            [
              241,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_get_name",
            "parameters": {
              "ips": "ares__iface_ips_t",
              "idx": "size_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "const struct ares_addr *ares__iface_ips_get_addr(const ares__iface_ips_t *ips,\n                                                 size_t                   idx)\n{\n  if (ips == NULL || idx >= ips->cnt) {\n    return NULL;\n  }\n  return &ips->ips[idx].addr;\n}",
          "fn_code_pos": [
            [
              243,
              0
            ],
            [
              250,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_get_addr",
            "parameters": {
              "ips": "ares__iface_ips_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__iface_ip_flags_t ares__iface_ips_get_flags(const ares__iface_ips_t *ips,\n                                                 size_t                   idx)\n{\n  if (ips == NULL || idx >= ips->cnt) {\n    return 0;\n  }\n  return ips->ips[idx].flags;\n}",
          "fn_code_pos": [
            [
              252,
              0
            ],
            [
              259,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_get_flags",
            "parameters": {
              "ips": "ares__iface_ips_t",
              "idx": "size_t"
            },
            "return_type": "ares__iface_ip_flags_t"
          }
        },
        {
          "fn_code": "unsigned char ares__iface_ips_get_netmask(const ares__iface_ips_t *ips,\n                                          size_t                   idx)\n{\n  if (ips == NULL || idx >= ips->cnt) {\n    return 0;\n  }\n  return ips->ips[idx].netmask;\n}",
          "fn_code_pos": [
            [
              261,
              0
            ],
            [
              268,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_get_netmask",
            "parameters": {
              "ips": "ares__iface_ips_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned int ares__iface_ips_get_ll_scope(const ares__iface_ips_t *ips,\n                                          size_t                   idx)\n{\n  if (ips == NULL || idx >= ips->cnt) {\n    return 0;\n  }\n  return ips->ips[idx].ll_scope;\n}",
          "fn_code_pos": [
            [
              270,
              0
            ],
            [
              277,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_get_ll_scope",
            "parameters": {
              "ips": "ares__iface_ips_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static char *wcharp_to_charp(const wchar_t *in)\n{\n  char *out;\n  int   len;\n\n  len = WideCharToMultiByte(CP_UTF8, 0, in, -1, NULL, 0, NULL, NULL);\n  if (len == -1) {\n    return NULL;\n  }\n\n  out = ares_malloc_zero((size_t)len + 1);\n\n  if (WideCharToMultiByte(CP_UTF8, 0, in, -1, out, len, NULL, NULL) == -1) {\n    ares_free(out);\n    return NULL;\n  }\n\n  return out;\n}",
          "fn_code_pos": [
            [
              283,
              0
            ],
            [
              301,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "wcharp_to_charp",
            "parameters": {
              "in": "wchar_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static ares_bool_t name_match(const char *name, const char *adapter_name,\n                              unsigned int ll_scope)\n{\n  if (name == NULL || *name == 0) {\n    return ARES_TRUE;\n  }\n\n  if (strcasecmp(name, adapter_name) == 0) {\n    return ARES_TRUE;\n  }\n\n  if (ares_str_isnum(name) && (unsigned int)atoi(name) == ll_scope) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              304,
              0
            ],
            [
              320,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "name_match",
            "parameters": {
              "name": "char",
              "adapter_name": "char",
              "ll_scope": "unsigned int"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__iface_ips_enumerate(ares__iface_ips_t *ips,\n                                               const char        *name)\n{\n  ULONG myflags = GAA_FLAG_INCLUDE_PREFIX /*|GAA_FLAG_INCLUDE_ALL_INTERFACES */;\n  ULONG outBufLen = 0;\n  DWORD retval;\n  IP_ADAPTER_ADDRESSES *addresses = NULL;\n  IP_ADAPTER_ADDRESSES *address   = NULL;\n  ares_status_t         status    = ARES_SUCCESS;\n\n  /* Get necessary buffer size */\n  GetAdaptersAddresses(AF_UNSPEC, myflags, NULL, NULL, &outBufLen);\n  if (outBufLen == 0) {\n    status = ARES_EFILE;\n    goto done;\n  }\n\n  addresses = ares_malloc_zero(outBufLen);\n  if (addresses == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  retval =\n    GetAdaptersAddresses(AF_UNSPEC, myflags, NULL, addresses, &outBufLen);\n  if (retval != ERROR_SUCCESS) {\n    status = ARES_EFILE;\n    goto done;\n  }\n\n  for (address = addresses; address != NULL; address = address->Next) {\n    IP_ADAPTER_UNICAST_ADDRESS *ipaddr     = NULL;\n    ares__iface_ip_flags_t      addrflag   = 0;\n    char                        ifname[64] = \"\";\n\n#  if defined(HAVE_CONVERTINTERFACEINDEXTOLUID) && \\\n    defined(HAVE_CONVERTINTERFACELUIDTONAMEA)\n    /* Retrieve name from interface index.\n     * address->AdapterName appears to be a GUID/UUID of some sort, not a name.\n     * address->FriendlyName is user-changeable.\n     * That said, this doesn't appear to help us out on systems that don't\n     * have if_nametoindex() or if_indextoname() as they don't have these\n     * functions either! */\n    NET_LUID luid;\n    ConvertInterfaceIndexToLuid(address->IfIndex, &luid);\n    ConvertInterfaceLuidToNameA(&luid, ifname, sizeof(ifname));\n#  else\n    ares_strcpy(ifname, address->AdapterName, sizeof(ifname));\n#  endif\n\n    if (address->OperStatus != IfOperStatusUp) {\n      addrflag |= ARES_IFACE_IP_OFFLINE;\n    }\n\n    if (address->IfType == IF_TYPE_SOFTWARE_LOOPBACK) {\n      addrflag |= ARES_IFACE_IP_LOOPBACK;\n    }\n\n    for (ipaddr = address->FirstUnicastAddress; ipaddr != NULL;\n         ipaddr = ipaddr->Next) {\n      struct ares_addr addr;\n\n      if (ipaddr->Address.lpSockaddr->sa_family == AF_INET) {\n        const struct sockaddr_in *sockaddr_in =\n          (const struct sockaddr_in *)((void *)ipaddr->Address.lpSockaddr);\n        addr.family = AF_INET;\n        memcpy(&addr.addr.addr4, &sockaddr_in->sin_addr,\n               sizeof(addr.addr.addr4));\n      } else if (ipaddr->Address.lpSockaddr->sa_family == AF_INET6) {\n        const struct sockaddr_in6 *sockaddr_in6 =\n          (const struct sockaddr_in6 *)((void *)ipaddr->Address.lpSockaddr);\n        addr.family = AF_INET6;\n        memcpy(&addr.addr.addr6, &sockaddr_in6->sin6_addr,\n               sizeof(addr.addr.addr6));\n      } else {\n        /* Unknown */\n        continue;\n      }\n\n      /* Sometimes windows may use numerics to indicate a DNS server's adapter,\n       * which corresponds to the index rather than the name.  Check and\n       * validate both. */\n      if (!name_match(name, ifname, address->Ipv6IfIndex)) {\n        continue;\n      }\n\n      status = ares__iface_ips_add(ips, addrflag, ifname, &addr,\n                                   ipaddr->OnLinkPrefixLength /* netmask */,\n                                   address->Ipv6IfIndex /* ll_scope */);\n\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n    }\n  }\n\ndone:\n  ares_free(addresses);\n  return status;\n}",
          "fn_code_pos": [
            [
              322,
              0
            ],
            [
              421,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_enumerate",
            "parameters": {
              "ips": "ares__iface_ips_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static unsigned char count_addr_bits(const unsigned char *addr, size_t addr_len)\n{\n  size_t        i;\n  unsigned char count = 0;\n\n  for (i = 0; i < addr_len; i++) {\n    count += ares__count_bits_u8(addr[i]);\n  }\n  return count;\n}",
          "fn_code_pos": [
            [
              425,
              0
            ],
            [
              434,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "count_addr_bits",
            "parameters": {
              "addr": "unsigned char",
              "addr_len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static ares_status_t ares__iface_ips_enumerate(ares__iface_ips_t *ips,\n                                               const char        *name)\n{\n  struct ifaddrs *ifap   = NULL;\n  struct ifaddrs *ifa    = NULL;\n  ares_status_t   status = ARES_SUCCESS;\n\n  if (getifaddrs(&ifap) != 0) {\n    status = ARES_EFILE;\n    goto done;\n  }\n\n  for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {\n    ares__iface_ip_flags_t addrflag = 0;\n    struct ares_addr       addr;\n    unsigned char          netmask  = 0;\n    unsigned int           ll_scope = 0;\n\n    if (ifa->ifa_addr == NULL) {\n      continue;\n    }\n\n    if (!(ifa->ifa_flags & IFF_UP)) {\n      addrflag |= ARES_IFACE_IP_OFFLINE;\n    }\n\n    if (ifa->ifa_flags & IFF_LOOPBACK) {\n      addrflag |= ARES_IFACE_IP_LOOPBACK;\n    }\n\n    if (ifa->ifa_addr->sa_family == AF_INET) {\n      const struct sockaddr_in *sockaddr_in =\n        (const struct sockaddr_in *)((void *)ifa->ifa_addr);\n      addr.family = AF_INET;\n      memcpy(&addr.addr.addr4, &sockaddr_in->sin_addr, sizeof(addr.addr.addr4));\n      /* netmask */\n      sockaddr_in = (struct sockaddr_in *)((void *)ifa->ifa_netmask);\n      netmask     = count_addr_bits((const void *)&sockaddr_in->sin_addr, 4);\n    } else if (ifa->ifa_addr->sa_family == AF_INET6) {\n      const struct sockaddr_in6 *sockaddr_in6 =\n        (const struct sockaddr_in6 *)((void *)ifa->ifa_addr);\n      addr.family = AF_INET6;\n      memcpy(&addr.addr.addr6, &sockaddr_in6->sin6_addr,\n             sizeof(addr.addr.addr6));\n      /* netmask */\n      sockaddr_in6 = (struct sockaddr_in6 *)((void *)ifa->ifa_netmask);\n      netmask = count_addr_bits((const void *)&sockaddr_in6->sin6_addr, 16);\n#  ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID\n      ll_scope = sockaddr_in6->sin6_scope_id;\n#  endif\n    } else {\n      /* unknown */\n      continue;\n    }\n\n    /* Name mismatch */\n    if (strcasecmp(ifa->ifa_name, name) != 0) {\n      continue;\n    }\n\n    status = ares__iface_ips_add(ips, addrflag, ifa->ifa_name, &addr, netmask,\n                                 ll_scope);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\ndone:\n  freeifaddrs(ifap);\n  return status;\n}",
          "fn_code_pos": [
            [
              436,
              0
            ],
            [
              506,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_enumerate",
            "parameters": {
              "ips": "ares__iface_ips_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__iface_ips_enumerate(ares__iface_ips_t *ips,\n                                               const char        *name)\n{\n  (void)ips;\n  (void)name;\n  return ARES_ENOTIMP;\n}",
          "fn_code_pos": [
            [
              510,
              0
            ],
            [
              516,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_enumerate",
            "parameters": {
              "ips": "ares__iface_ips_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "unsigned int ares__if_nametoindex(const char *name)\n{\n#ifdef HAVE_IF_NAMETOINDEX\n  return if_nametoindex(name);\n#else\n  ares_status_t      status;\n  ares__iface_ips_t *ips = NULL;\n  size_t             i;\n  unsigned int       index = 0;\n\n  status =\n    ares__iface_ips(&ips, ARES_IFACE_IP_V6 | ARES_IFACE_IP_LINKLOCAL, name);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  for (i = 0; i < ares__iface_ips_cnt(ips); i++) {\n    if (ares__iface_ips_get_flags(ips, i) & ARES_IFACE_IP_LINKLOCAL) {\n      index = ares__iface_ips_get_ll_scope(ips, i);\n      goto done;\n    }\n  }\n\ndone:\n  ares__iface_ips_destroy(ips);\n  return index;\n#endif\n}",
          "fn_code_pos": [
            [
              521,
              0
            ],
            [
              548,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__if_nametoindex",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "const char *ares__if_indextoname(unsigned int index, char *name,\n                                 size_t name_len)\n{\n#ifdef HAVE_IF_INDEXTONAME\n  if (name_len < IF_NAMESIZE) {\n    return NULL;\n  }\n  return if_indextoname(index, name);\n#else\n  ares_status_t      status;\n  ares__iface_ips_t *ips = NULL;\n  size_t             i;\n  const char        *ptr = NULL;\n\n  if (name_len < IF_NAMESIZE) {\n    goto done;\n  }\n\n  if (index == 0) {\n    goto done;\n  }\n\n  status =\n    ares__iface_ips(&ips, ARES_IFACE_IP_V6 | ARES_IFACE_IP_LINKLOCAL, NULL);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  for (i = 0; i < ares__iface_ips_cnt(ips); i++) {\n    if (ares__iface_ips_get_flags(ips, i) & ARES_IFACE_IP_LINKLOCAL &&\n        ares__iface_ips_get_ll_scope(ips, i) == index) {\n      ares_strcpy(name, ares__iface_ips_get_name(ips, i), name_len);\n      ptr = name;\n      goto done;\n    }\n  }\n\ndone:\n  ares__iface_ips_destroy(ips);\n  return ptr;\n#endif\n}",
          "fn_code_pos": [
            [
              550,
              0
            ],
            [
              591,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__if_indextoname",
            "parameters": {
              "index": "unsigned int",
              "name": "char",
              "name_len": "size_t"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares__iface_ips_enumerate(ares__iface_ips_t *ips,\n                                               const char        *name)",
          "fn_dec_pos": [
            [
              61,
              21
            ],
            [
              62,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_enumerate",
            "parameters": {
              "ips": "ares__iface_ips_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__iface_ips_alloc(ares__iface_ip_flags_t flags)",
          "fn_dec_pos": [
            [
              79,
              26
            ],
            [
              79,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_alloc",
            "parameters": {
              "flags": "ares__iface_ip_flags_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__iface_ips_get_name(const ares__iface_ips_t *ips, size_t idx)",
          "fn_dec_pos": [
            [
              235,
              12
            ],
            [
              235,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_get_name",
            "parameters": {
              "ips": "ares__iface_ips_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__iface_ips_get_addr(const ares__iface_ips_t *ips,\n                                                 size_t                   idx)",
          "fn_dec_pos": [
            [
              243,
              24
            ],
            [
              244,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_get_addr",
            "parameters": {
              "ips": "ares__iface_ips_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "wcharp_to_charp(const wchar_t *in)",
          "fn_dec_pos": [
            [
              283,
              13
            ],
            [
              283,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "wcharp_to_charp",
            "parameters": {
              "in": "wchar_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__if_indextoname(unsigned int index, char *name,\n                                 size_t name_len)",
          "fn_dec_pos": [
            [
              550,
              12
            ],
            [
              551,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__if_indextoname",
            "parameters": {
              "index": "unsigned int",
              "name": "char",
              "name_len": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  char                  *name;\n  struct ares_addr       addr;\n  unsigned char          netmask;\n  unsigned int           ll_scope;\n  ares__iface_ip_flags_t flags;\n} ares__iface_ip_t;",
          {
            "*name": "char",
            "addr": "struct ares_addr",
            "netmask": "unsigned char",
            "ll_scope": "unsigned int",
            "flags": "ares__iface_ip_flags_t"
          },
          "ares__iface_ip_t",
          [
            64,
            0
          ],
          [
            70,
            19
          ]
        ],
        [
          "struct ares__iface_ips {\n  ares__iface_ip_t      *ips;\n  size_t                 cnt;\n  size_t                 alloc_size;\n  ares__iface_ip_flags_t enum_flags;\n}",
          {
            "*ips": "ares__iface_ip_t",
            "cnt": "size_t",
            "alloc_size": "size_t",
            "enum_flags": "ares__iface_ip_flags_t"
          },
          "ares__iface_ips",
          [
            72,
            0
          ],
          [
            77,
            1
          ]
        ],
        [
          "typedef struct {\n  char                  *name;\n  struct ares_addr       addr;\n  unsigned char          netmask;\n  unsigned int           ll_scope;\n  ares__iface_ip_flags_t flags;\n} ares__iface_ip_t;",
          {
            "*name": "char",
            "addr": "struct ares_addr",
            "netmask": "unsigned char",
            "ll_scope": "unsigned int",
            "flags": "ares__iface_ip_flags_t"
          },
          "ares__iface_ip_t",
          [
            64,
            0
          ],
          [
            70,
            19
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            66,
            2
          ],
          [
            66,
            18
          ]
        ],
        [
          "struct ares__iface_ips {\n  ares__iface_ip_t      *ips;\n  size_t                 cnt;\n  size_t                 alloc_size;\n  ares__iface_ip_flags_t enum_flags;\n}",
          {
            "*ips": "ares__iface_ip_t",
            "cnt": "size_t",
            "alloc_size": "size_t",
            "enum_flags": "ares__iface_ip_flags_t"
          },
          "ares__iface_ips",
          [
            72,
            0
          ],
          [
            77,
            1
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            147,
            46
          ],
          [
            147,
            62
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            243,
            6
          ],
          [
            243,
            22
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            382,
            6
          ],
          [
            382,
            22
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            385,
            14
          ],
          [
            385,
            32
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            386,
            17
          ],
          [
            386,
            35
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            391,
            14
          ],
          [
            391,
            33
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            392,
            17
          ],
          [
            392,
            36
          ]
        ],
        [
          "struct ifaddrs",
          {},
          "",
          [
            439,
            2
          ],
          [
            439,
            16
          ]
        ],
        [
          "struct ifaddrs",
          {},
          "",
          [
            440,
            2
          ],
          [
            440,
            16
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            450,
            4
          ],
          [
            450,
            20
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            467,
            12
          ],
          [
            467,
            30
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            468,
            15
          ],
          [
            468,
            33
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            472,
            21
          ],
          [
            472,
            39
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            475,
            12
          ],
          [
            475,
            31
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            476,
            15
          ],
          [
            476,
            34
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            481,
            22
          ],
          [
            481,
            41
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#  include <winsock2.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#  include <ws2tcpip.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#    include <iphlpapi.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#    include <netioapi.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#  include <sys/types.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#  include <sys/socket.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#  include <net/if.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#  include <ifaddrs.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#  include <sys/ioctl.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__htable.c": {
      "fn_def_list": [
        {
          "fn_code": "static unsigned int ares__htable_generate_seed(ares__htable_t *htable)\n{\n  unsigned int seed = 0;\n  time_t       t    = time(NULL);\n\n  /* Mix stack address, heap address, and time to generate a random seed, it\n   * doesn't have to be super secure, just quick.  Likelihood of a hash\n   * collision attack is very low with a small amount of effort */\n  seed |= (unsigned int)((size_t)htable & 0xFFFFFFFF);\n  seed |= (unsigned int)((size_t)&seed & 0xFFFFFFFF);\n  seed |= (unsigned int)(t & 0xFFFFFFFF);\n  return seed;\n}",
          "fn_code_pos": [
            [
              53,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_generate_seed",
            "parameters": {
              "htable": "ares__htable_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void ares__htable_buckets_destroy(ares__llist_t **buckets,\n                                         unsigned int    size,\n                                         ares_bool_t     destroy_vals)\n{\n  unsigned int i;\n\n  if (buckets == NULL) {\n    return;\n  }\n\n  for (i = 0; i < size; i++) {\n    if (buckets[i] == NULL) {\n      continue;\n    }\n\n    if (!destroy_vals) {\n      ares__llist_replace_destructor(buckets[i], NULL);\n    }\n\n    ares__llist_destroy(buckets[i]);\n  }\n\n  ares_free(buckets);\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              90,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_buckets_destroy",
            "parameters": {
              "buckets": "ares__llist_t",
              "size": "unsigned int",
              "destroy_vals": "ares_bool_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__htable_destroy(ares__htable_t *htable)\n{\n  if (htable == NULL) {\n    return;\n  }\n  ares__htable_buckets_destroy(htable->buckets, htable->size, ARES_TRUE);\n  ares_free(htable);\n}",
          "fn_code_pos": [
            [
              92,
              0
            ],
            [
              99,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_destroy",
            "parameters": {
              "htable": "ares__htable_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__htable_t *ares__htable_create(ares__htable_hashfunc_t    hash_func,\n                                    ares__htable_bucket_key_t  bucket_key,\n                                    ares__htable_bucket_free_t bucket_free,\n                                    ares__htable_key_eq_t      key_eq)\n{\n  ares__htable_t *htable = NULL;\n\n  if (hash_func == NULL || bucket_key == NULL || bucket_free == NULL ||\n      key_eq == NULL) {\n    goto fail;\n  }\n\n  htable = ares_malloc_zero(sizeof(*htable));\n  if (htable == NULL) {\n    goto fail;\n  }\n\n  htable->hash        = hash_func;\n  htable->bucket_key  = bucket_key;\n  htable->bucket_free = bucket_free;\n  htable->key_eq      = key_eq;\n  htable->seed        = ares__htable_generate_seed(htable);\n  htable->size        = ARES__HTABLE_MIN_BUCKETS;\n  htable->buckets = ares_malloc_zero(sizeof(*htable->buckets) * htable->size);\n\n  if (htable->buckets == NULL) {\n    goto fail;\n  }\n\n  return htable;\n\nfail:\n  ares__htable_destroy(htable);\n  return NULL;\n}",
          "fn_code_pos": [
            [
              101,
              0
            ],
            [
              135,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_create",
            "parameters": {
              "hash_func": "ares__htable_hashfunc_t",
              "bucket_key": "ares__htable_bucket_key_t",
              "bucket_free": "ares__htable_bucket_free_t",
              "key_eq": "ares__htable_key_eq_t"
            },
            "return_type": "ares__htable_t"
          }
        },
        {
          "fn_code": "const void **ares__htable_all_buckets(const ares__htable_t *htable, size_t *num)\n{\n  const void **out = NULL;\n  size_t       cnt = 0;\n  size_t       i;\n\n  if (htable == NULL || num == NULL) {\n    return NULL;\n  }\n\n  *num = 0;\n\n  out = ares_malloc_zero(sizeof(*out) * htable->num_keys);\n  if (out == NULL) {\n    return NULL;\n  }\n\n  for (i = 0; i < htable->size; i++) {\n    ares__llist_node_t *node;\n    for (node = ares__llist_node_first(htable->buckets[i]); node != NULL;\n         node = ares__llist_node_next(node)) {\n      out[cnt++] = ares__llist_node_val(node);\n    }\n  }\n\n  *num = cnt;\n  return out;\n}",
          "fn_code_pos": [
            [
              137,
              0
            ],
            [
              164,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares__llist_node_t *ares__htable_find(const ares__htable_t *htable,\n                                             unsigned int idx, const void *key)\n{\n  ares__llist_node_t *node = NULL;\n\n  for (node = ares__llist_node_first(htable->buckets[idx]); node != NULL;\n       node = ares__llist_node_next(node)) {\n    if (htable->key_eq(key, htable->bucket_key(ares__llist_node_val(node)))) {\n      break;\n    }\n  }\n\n  return node;\n}",
          "fn_code_pos": [
            [
              173,
              0
            ],
            [
              186,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_find",
            "parameters": {
              "htable": "ares__htable_t",
              "idx": "unsigned int",
              "key": "void"
            },
            "return_type": "ares__llist_node_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares__htable_expand(ares__htable_t *htable)\n{\n  ares__llist_t **buckets  = NULL;\n  unsigned int    old_size = htable->size;\n  size_t          i;\n  ares__llist_t **prealloc_llist     = NULL;\n  size_t          prealloc_llist_len = 0;\n  ares_bool_t     rv                 = ARES_FALSE;\n\n  /* Not a failure, just won't expand */\n  if (old_size == ARES__HTABLE_MAX_BUCKETS) {\n    return ARES_TRUE;\n  }\n\n  htable->size <<= 1;\n\n  /* We must pre-allocate all memory we'll need before moving entries to the\n   * new hash array.  Otherwise if there's a memory allocation failure in the\n   * middle, we wouldn't be able to recover. */\n  buckets = ares_malloc_zero(sizeof(*buckets) * htable->size);\n  if (buckets == NULL) {\n    goto done;\n  }\n\n  /* The maximum number of new llists we'll need is the number of collisions\n   * that were recorded */\n  prealloc_llist_len = htable->num_collisions;\n  if (prealloc_llist_len) {\n    prealloc_llist =\n      ares_malloc_zero(sizeof(*prealloc_llist) * prealloc_llist_len);\n    if (prealloc_llist == NULL) {\n      goto done;\n    }\n  }\n  for (i = 0; i < prealloc_llist_len; i++) {\n    prealloc_llist[i] = ares__llist_create(htable->bucket_free);\n    if (prealloc_llist[i] == NULL) {\n      goto done;\n    }\n  }\n\n  /* Iterate across all buckets and move the entries to the new buckets */\n  htable->num_collisions = 0;\n  for (i = 0; i < old_size; i++) {\n    ares__llist_node_t *node;\n\n    /* Nothing in this bucket */\n    if (htable->buckets[i] == NULL) {\n      continue;\n    }\n\n    /* Fast path optimization (most likely case), there is likely only a single\n     * entry in both the source and destination, check for this to confirm and\n     * if so, just move the bucket over */\n    if (ares__llist_len(htable->buckets[i]) == 1) {\n      const void *val = ares__llist_first_val(htable->buckets[i]);\n      size_t      idx = HASH_IDX(htable, htable->bucket_key(val));\n\n      if (buckets[idx] == NULL) {\n        /* Swap! */\n        buckets[idx]       = htable->buckets[i];\n        htable->buckets[i] = NULL;\n        continue;\n      }\n    }\n\n    /* Slow path, collisions */\n    while ((node = ares__llist_node_first(htable->buckets[i])) != NULL) {\n      const void *val = ares__llist_node_val(node);\n      size_t      idx = HASH_IDX(htable, htable->bucket_key(val));\n\n      /* Try fast path again as maybe we popped one collision off and the\n       * next we can reuse the llist parent */\n      if (buckets[idx] == NULL && ares__llist_len(htable->buckets[i]) == 1) {\n        /* Swap! */\n        buckets[idx]       = htable->buckets[i];\n        htable->buckets[i] = NULL;\n        break;\n      }\n\n      /* Grab one off our preallocated list */\n      if (buckets[idx] == NULL) {\n        /* Silence static analysis, this isn't possible but it doesn't know */\n        if (prealloc_llist == NULL || prealloc_llist_len == 0) {\n          goto done;\n        }\n        buckets[idx] = prealloc_llist[prealloc_llist_len - 1];\n        prealloc_llist_len--;\n      } else {\n        /* Collision occurred since the bucket wasn't empty */\n        htable->num_collisions++;\n      }\n\n      ares__llist_node_move_parent_first(node, buckets[idx]);\n    }\n\n    /* Abandoned bucket, destroy */\n    if (htable->buckets[i] != NULL) {\n      ares__llist_destroy(htable->buckets[i]);\n      htable->buckets[i] = NULL;\n    }\n  }\n\n  /* We have guaranteed all the buckets have either been moved or destroyed,\n   * so we just call ares_free() on the array and swap out the pointer */\n  ares_free(htable->buckets);\n  htable->buckets = buckets;\n  buckets         = NULL;\n  rv              = ARES_TRUE;\n\ndone:\n  ares_free(buckets);\n  /* destroy any unused preallocated buckets */\n  ares__htable_buckets_destroy(prealloc_llist, (unsigned int)prealloc_llist_len,\n                               ARES_FALSE);\n\n  /* On failure, we need to restore the htable size */\n  if (rv != ARES_TRUE) {\n    htable->size = old_size;\n  }\n\n  return rv;\n}",
          "fn_code_pos": [
            [
              188,
              0
            ],
            [
              310,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_expand",
            "parameters": {
              "htable": "ares__htable_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares__htable_insert(ares__htable_t *htable, void *bucket)\n{\n  unsigned int        idx  = 0;\n  ares__llist_node_t *node = NULL;\n  const void         *key  = NULL;\n\n  if (htable == NULL || bucket == NULL) {\n    return ARES_FALSE;\n  }\n\n\n  key = htable->bucket_key(bucket);\n  idx = HASH_IDX(htable, key);\n\n  /* See if we have a matching bucket already, if so, replace it */\n  node = ares__htable_find(htable, idx, key);\n  if (node != NULL) {\n    ares__llist_node_replace(node, bucket);\n    return ARES_TRUE;\n  }\n\n  /* Check to see if we should rehash because likelihood of collisions has\n   * increased beyond our threshold */\n  if (htable->num_keys + 1 >\n      (htable->size * ARES__HTABLE_EXPAND_PERCENT) / 100) {\n    if (!ares__htable_expand(htable)) {\n      return ARES_FALSE;\n    }\n    /* If we expanded, need to calculate a new index */\n    idx = HASH_IDX(htable, key);\n  }\n\n  /* We lazily allocate the linked list */\n  if (htable->buckets[idx] == NULL) {\n    htable->buckets[idx] = ares__llist_create(htable->bucket_free);\n    if (htable->buckets[idx] == NULL) {\n      return ARES_FALSE;\n    }\n  }\n\n  node = ares__llist_insert_first(htable->buckets[idx], bucket);\n  if (node == NULL) {\n    return ARES_FALSE;\n  }\n\n  /* Track collisions for rehash stability */\n  if (ares__llist_len(htable->buckets[idx]) > 1) {\n    htable->num_collisions++;\n  }\n\n  htable->num_keys++;\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              312,
              0
            ],
            [
              365,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_insert",
            "parameters": {
              "htable": "ares__htable_t",
              "bucket": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "void *ares__htable_get(const ares__htable_t *htable, const void *key)\n{\n  unsigned int idx;\n\n  if (htable == NULL || key == NULL) {\n    return NULL;\n  }\n\n  idx = HASH_IDX(htable, key);\n\n  return ares__llist_node_val(ares__htable_find(htable, idx, key));\n}",
          "fn_code_pos": [
            [
              367,
              0
            ],
            [
              378,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_get",
            "parameters": {
              "htable": "ares__htable_t",
              "key": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_bool_t ares__htable_remove(ares__htable_t *htable, const void *key)\n{\n  ares__llist_node_t *node;\n  unsigned int        idx;\n\n  if (htable == NULL || key == NULL) {\n    return ARES_FALSE;\n  }\n\n  idx  = HASH_IDX(htable, key);\n  node = ares__htable_find(htable, idx, key);\n  if (node == NULL) {\n    return ARES_FALSE;\n  }\n\n  htable->num_keys--;\n\n  /* Reduce collisions */\n  if (ares__llist_len(ares__llist_node_parent(node)) > 1) {\n    htable->num_collisions--;\n  }\n\n  ares__llist_node_destroy(node);\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              380,
              0
            ],
            [
              404,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_remove",
            "parameters": {
              "htable": "ares__htable_t",
              "key": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "size_t ares__htable_num_keys(const ares__htable_t *htable)\n{\n  if (htable == NULL) {\n    return 0;\n  }\n  return htable->num_keys;\n}",
          "fn_code_pos": [
            [
              406,
              0
            ],
            [
              412,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_num_keys",
            "parameters": {
              "htable": "ares__htable_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "unsigned int ares__htable_hash_FNV1a(const unsigned char *key, size_t key_len,\n                                     unsigned int seed)\n{\n  /* recommended seed is 2166136261U, but we don't want collisions */\n  unsigned int hv = seed;\n  size_t       i;\n\n  for (i = 0; i < key_len; i++) {\n    hv ^= (unsigned int)key[i];\n    /* hv *= 0x01000193 */\n    hv += (hv << 1) + (hv << 4) + (hv << 7) + (hv << 8) + (hv << 24);\n  }\n\n  return hv;\n}",
          "fn_code_pos": [
            [
              414,
              0
            ],
            [
              428,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_hash_FNV1a",
            "parameters": {
              "key": "unsigned char",
              "key_len": "size_t",
              "seed": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned int ares__htable_hash_FNV1a_casecmp(const unsigned char *key,\n                                             size_t key_len, unsigned int seed)\n{\n  /* recommended seed is 2166136261U, but we don't want collisions */\n  unsigned int hv = seed;\n  size_t       i;\n\n  for (i = 0; i < key_len; i++) {\n    hv ^= (unsigned int)ares__tolower(key[i]);\n    /* hv *= 0x01000193 */\n    hv += (hv << 1) + (hv << 4) + (hv << 7) + (hv << 8) + (hv << 24);\n  }\n\n  return hv;\n}",
          "fn_code_pos": [
            [
              431,
              0
            ],
            [
              445,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_hash_FNV1a_casecmp",
            "parameters": {
              "key": "unsigned char",
              "key_len": "size_t",
              "seed": "unsigned int"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares__htable_create(ares__htable_hashfunc_t    hash_func,\n                                    ares__htable_bucket_key_t  bucket_key,\n                                    ares__htable_bucket_free_t bucket_free,\n                                    ares__htable_key_eq_t      key_eq)",
          "fn_dec_pos": [
            [
              101,
              16
            ],
            [
              104,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_create",
            "parameters": {
              "hash_func": "ares__htable_hashfunc_t",
              "bucket_key": "ares__htable_bucket_key_t",
              "bucket_free": "ares__htable_bucket_free_t",
              "key_eq": "ares__htable_key_eq_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_all_buckets(const ares__htable_t *htable, size_t *num)",
          "fn_dec_pos": [
            [
              137,
              13
            ],
            [
              137,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_all_buckets",
            "parameters": {
              "htable": "ares__htable_t",
              "num": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_find(const ares__htable_t *htable,\n                                             unsigned int idx, const void *key)",
          "fn_dec_pos": [
            [
              173,
              27
            ],
            [
              174,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_find",
            "parameters": {
              "htable": "ares__htable_t",
              "idx": "unsigned int",
              "key": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_get(const ares__htable_t *htable, const void *key)",
          "fn_dec_pos": [
            [
              367,
              6
            ],
            [
              367,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_get",
            "parameters": {
              "htable": "ares__htable_t",
              "key": "void"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares__htable {\n  ares__htable_hashfunc_t    hash;\n  ares__htable_bucket_key_t  bucket_key;\n  ares__htable_bucket_free_t bucket_free;\n  ares__htable_key_eq_t      key_eq;\n  unsigned int               seed;\n  unsigned int               size;\n  size_t                     num_keys;\n  size_t                     num_collisions;\n  /* NOTE: if we converted buckets into ares__slist_t we could guarantee on\n   *       hash collisions we would have O(log n) worst case insert and search\n   *       performance.  (We'd also need to make key_eq into a key_cmp to\n   *       support sort).  That said, risk with a random hash seed is near zero,\n   *       and ares__slist_t is heavier weight, so I think using ares__llist_t\n   *       is an overall win. */\n  ares__llist_t            **buckets;\n}",
          {
            "hash": "ares__htable_hashfunc_t",
            "bucket_key": "ares__htable_bucket_key_t",
            "bucket_free": "ares__htable_bucket_free_t",
            "key_eq": "ares__htable_key_eq_t",
            "seed": "unsigned int",
            "size": "unsigned int",
            "num_keys": "size_t",
            "num_collisions": "size_t",
            "**buckets": "ares__llist_t"
          },
          "ares__htable",
          [
            35,
            0
          ],
          [
            51,
            1
          ]
        ],
        [
          "struct ares__htable {\n  ares__htable_hashfunc_t    hash;\n  ares__htable_bucket_key_t  bucket_key;\n  ares__htable_bucket_free_t bucket_free;\n  ares__htable_key_eq_t      key_eq;\n  unsigned int               seed;\n  unsigned int               size;\n  size_t                     num_keys;\n  size_t                     num_collisions;\n  /* NOTE: if we converted buckets into ares__slist_t we could guarantee on\n   *       hash collisions we would have O(log n) worst case insert and search\n   *       performance.  (We'd also need to make key_eq into a key_cmp to\n   *       support sort).  That said, risk with a random hash seed is near zero,\n   *       and ares__slist_t is heavier weight, so I think using ares__llist_t\n   *       is an overall win. */\n  ares__llist_t            **buckets;\n}",
          {
            "hash": "ares__htable_hashfunc_t",
            "bucket_key": "ares__htable_bucket_key_t",
            "bucket_free": "ares__htable_bucket_free_t",
            "key_eq": "ares__htable_key_eq_t",
            "seed": "unsigned int",
            "size": "unsigned int",
            "num_keys": "size_t",
            "num_collisions": "size_t",
            "**buckets": "ares__llist_t"
          },
          "ares__htable",
          [
            35,
            0
          ],
          [
            51,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares__llist.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares__htable.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_parse_aaaa_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_parse_aaaa_reply(const unsigned char *abuf, int alen,\n                          struct hostent **host, struct ares_addr6ttl *addrttls,\n                          int *naddrttls)\n{\n  struct ares_addrinfo ai;\n  char                *question_hostname = NULL;\n  ares_status_t        status;\n  size_t               req_naddrttls = 0;\n  ares_dns_record_t   *dnsrec        = NULL;\n\n  if (alen < 0) {\n    return ARES_EBADRESP;\n  }\n\n  if (naddrttls) {\n    req_naddrttls = (size_t)*naddrttls;\n    *naddrttls    = 0;\n  }\n\n  memset(&ai, 0, sizeof(ai));\n\n  status = ares_dns_parse(abuf, (size_t)alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto fail;\n  }\n\n  status = ares__parse_into_addrinfo(dnsrec, 0, 0, &ai);\n  if (status != ARES_SUCCESS && status != ARES_ENODATA) {\n    goto fail;\n  }\n\n  if (host != NULL) {\n    status = ares__addrinfo2hostent(&ai, AF_INET6, host);\n    if (status != ARES_SUCCESS && status != ARES_ENODATA) {\n      goto fail;\n    }\n  }\n\n  if (addrttls != NULL && req_naddrttls) {\n    size_t temp_naddrttls = 0;\n    ares__addrinfo2addrttl(&ai, AF_INET6, req_naddrttls, NULL, addrttls,\n                           &temp_naddrttls);\n    *naddrttls = (int)temp_naddrttls;\n  }\n\nfail:\n  ares__freeaddrinfo_cnames(ai.cnames);\n  ares__freeaddrinfo_nodes(ai.nodes);\n  ares_free(question_hostname);\n  ares_free(ai.name);\n  ares_dns_record_destroy(dnsrec);\n\n  if (status == ARES_EBADNAME) {\n    status = ARES_EBADRESP;\n  }\n\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              55,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_aaaa_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "host": "struct hostent",
              "addrttls": "struct ares_addr6ttl",
              "naddrttls": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            56,
            26
          ],
          [
            56,
            40
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            56,
            49
          ],
          [
            56,
            69
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            59,
            2
          ],
          [
            59,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#  include <limits.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include \"ares_dns.h\"\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_parse_soa_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "int ares_parse_soa_reply(const unsigned char *abuf, int alen_int,\n                         struct ares_soa_reply **soa_out)\n{\n  ares_status_t          status;\n  size_t                 alen;\n  struct ares_soa_reply *soa    = NULL;\n  ares_dns_record_t     *dnsrec = NULL;\n  size_t                 i;\n\n  *soa_out = NULL;\n\n  if (alen_int < 0) {\n    return ARES_EBADRESP;\n  }\n\n  alen = (size_t)alen_int;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {\n    status = ARES_EBADRESP; /* ENODATA might make more sense */\n    goto done;\n  }\n\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP;\n      goto done;\n    }\n\n    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN ||\n        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_SOA) {\n      continue;\n    }\n\n    /* allocate result struct */\n    soa = ares_malloc_data(ARES_DATATYPE_SOA_REPLY);\n    if (soa == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n\n    soa->serial  = ares_dns_rr_get_u32(rr, ARES_RR_SOA_SERIAL);\n    soa->refresh = ares_dns_rr_get_u32(rr, ARES_RR_SOA_REFRESH);\n    soa->retry   = ares_dns_rr_get_u32(rr, ARES_RR_SOA_RETRY);\n    soa->expire  = ares_dns_rr_get_u32(rr, ARES_RR_SOA_EXPIRE);\n    soa->minttl  = ares_dns_rr_get_u32(rr, ARES_RR_SOA_MINIMUM);\n    soa->nsname  = ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_SOA_MNAME));\n    if (soa->nsname == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    soa->hostmaster = ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_SOA_RNAME));\n    if (soa->hostmaster == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    break;\n  }\n\n  if (soa == NULL) {\n    status = ARES_EBADRESP;\n  }\n\ndone:\n  /* clean up on error */\n  if (status != ARES_SUCCESS) {\n    ares_free_data(soa);\n    /* Compatibility */\n    if (status == ARES_EBADNAME) {\n      status = ARES_EBADRESP;\n    }\n  } else {\n    /* everything looks fine, return the data */\n    *soa_out = soa;\n  }\n  ares_dns_record_destroy(dnsrec);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              116,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_soa_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen_int": "int",
              "soa_out": "struct ares_soa_reply"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            32,
            25
          ],
          [
            32,
            46
          ]
        ],
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            36,
            2
          ],
          [
            36,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__close_sockets.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares__requeue_queries(struct server_connection *conn)\n{\n  struct query  *query;\n  struct timeval now = ares__tvnow();\n\n  while ((query = ares__llist_first_val(conn->queries_to_conn)) != NULL) {\n    ares__requeue_query(query, &now);\n  }\n}",
          "fn_code_pos": [
            [
              33,
              0
            ],
            [
              41,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__requeue_queries",
            "parameters": {
              "conn": "struct server_connection"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__close_connection(struct server_connection *conn)\n{\n  struct server_state *server  = conn->server;\n  ares_channel_t      *channel = server->channel;\n\n  /* Unlink */\n  ares__llist_node_claim(\n    ares__htable_asvp_get_direct(channel->connnode_by_socket, conn->fd));\n  ares__htable_asvp_remove(channel->connnode_by_socket, conn->fd);\n\n  if (conn->is_tcp) {\n    /* Reset any existing input and output buffer. */\n    ares__buf_consume(server->tcp_parser, ares__buf_len(server->tcp_parser));\n    ares__buf_consume(server->tcp_send, ares__buf_len(server->tcp_send));\n    server->tcp_conn = NULL;\n  }\n\n  /* Requeue queries to other connections */\n  ares__requeue_queries(conn);\n\n  ares__llist_destroy(conn->queries_to_conn);\n\n  SOCK_STATE_CALLBACK(channel, conn->fd, 0, 0);\n  ares__close_socket(channel, conn->fd);\n\n  ares_free(conn);\n}",
          "fn_code_pos": [
            [
              43,
              0
            ],
            [
              69,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__close_connection",
            "parameters": {
              "conn": "struct server_connection"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__close_sockets(struct server_state *server)\n{\n  ares__llist_node_t *node;\n\n  while ((node = ares__llist_node_first(server->connections)) != NULL) {\n    struct server_connection *conn = ares__llist_node_val(node);\n    ares__close_connection(conn);\n  }\n}",
          "fn_code_pos": [
            [
              71,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__close_sockets",
            "parameters": {
              "server": "struct server_state"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__check_cleanup_conn(const ares_channel_t     *channel,\n                              struct server_connection *conn)\n{\n  ares_bool_t do_cleanup = ARES_FALSE;\n\n  if (channel == NULL || conn == NULL) {\n    return;\n  }\n\n  if (ares__llist_len(conn->queries_to_conn)) {\n    return;\n  }\n\n  /* If we are configured not to stay open, close it out */\n  if (!(channel->flags & ARES_FLAG_STAYOPEN)) {\n    do_cleanup = ARES_TRUE;\n  }\n\n  /* If the associated server has failures, close it out. Resetting the\n   * connection (and specifically the source port number) can help resolve\n   * situations where packets are being dropped.\n   */\n  if (conn->server->consec_failures > 0) {\n    do_cleanup = ARES_TRUE;\n  }\n\n  /* If the udp connection hit its max queries, always close it */\n  if (!conn->is_tcp && channel->udp_max_queries > 0 &&\n      conn->total_queries >= channel->udp_max_queries) {\n    do_cleanup = ARES_TRUE;\n  }\n\n  if (!do_cleanup) {\n    return;\n  }\n\n  ares__close_connection(conn);\n}",
          "fn_code_pos": [
            [
              81,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__check_cleanup_conn",
            "parameters": {
              "channel": "ares_channel_t",
              "conn": "struct server_connection"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct server_connection",
          {},
          "",
          [
            33,
            34
          ],
          [
            33,
            58
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            35,
            2
          ],
          [
            35,
            14
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            36,
            2
          ],
          [
            36,
            16
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            43,
            28
          ],
          [
            43,
            52
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            45,
            2
          ],
          [
            45,
            21
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            71,
            25
          ],
          [
            71,
            44
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            76,
            4
          ],
          [
            76,
            28
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            82,
            30
          ],
          [
            82,
            54
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_dns_write.c": {
      "fn_def_list": [
        {
          "fn_code": "static ares_status_t ares_dns_write_header(const ares_dns_record_t *dnsrec,\n                                           ares__buf_t             *buf)\n{\n  unsigned short u16;\n  unsigned short opcode;\n  unsigned short rcode;\n\n  ares_status_t  status;\n\n  /* ID */\n  status = ares__buf_append_be16(buf, dnsrec->id);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Flags */\n  u16 = 0;\n\n  /* QR */\n  if (dnsrec->flags & ARES_FLAG_QR) {\n    u16 |= 0x8000;\n  }\n\n  /* OPCODE */\n  opcode   = (unsigned short)(dnsrec->opcode & 0xF);\n  opcode <<= 11;\n  u16     |= opcode;\n\n  /* AA */\n  if (dnsrec->flags & ARES_FLAG_AA) {\n    u16 |= 0x400;\n  }\n\n  /* TC */\n  if (dnsrec->flags & ARES_FLAG_TC) {\n    u16 |= 0x200;\n  }\n\n  /* RD */\n  if (dnsrec->flags & ARES_FLAG_RD) {\n    u16 |= 0x100;\n  }\n\n  /* RA */\n  if (dnsrec->flags & ARES_FLAG_RA) {\n    u16 |= 0x80;\n  }\n\n  /* Z -- unused */\n\n  /* AD */\n  if (dnsrec->flags & ARES_FLAG_AD) {\n    u16 |= 0x20;\n  }\n\n  /* CD */\n  if (dnsrec->flags & ARES_FLAG_CD) {\n    u16 |= 0x10;\n  }\n\n  /* RCODE */\n  if (dnsrec->rcode > 15 && !ares_dns_has_opt_rr(dnsrec)) {\n    /* Must have OPT RR in order to write extended error codes */\n    rcode = ARES_RCODE_SERVFAIL;\n  } else {\n    rcode = (unsigned short)(dnsrec->rcode & 0xF);\n  }\n  u16 |= rcode;\n\n  status = ares__buf_append_be16(buf, u16);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* QDCOUNT */\n  status = ares__buf_append_be16(buf, (unsigned short)dnsrec->qdcount);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* ANCOUNT */\n  status = ares__buf_append_be16(buf, (unsigned short)dnsrec->ancount);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* NSCOUNT */\n  status = ares__buf_append_be16(buf, (unsigned short)dnsrec->nscount);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* ARCOUNT */\n  status = ares__buf_append_be16(buf, (unsigned short)dnsrec->arcount);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_header",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "buf": "ares__buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_questions(const ares_dns_record_t *dnsrec,\n                                              ares__llist_t          **namelist,\n                                              ares__buf_t             *buf)\n{\n  size_t i;\n\n  for (i = 0; i < ares_dns_record_query_cnt(dnsrec); i++) {\n    ares_status_t       status;\n    const char         *name = NULL;\n    ares_dns_rec_type_t qtype;\n    ares_dns_class_t    qclass;\n\n    status = ares_dns_record_query_get(dnsrec, i, &name, &qtype, &qclass);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Name */\n    status = ares__dns_name_write(buf, namelist, ARES_TRUE, name);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Type */\n    status = ares__buf_append_be16(buf, (unsigned short)qtype);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Class */\n    status = ares__buf_append_be16(buf, (unsigned short)qclass);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              135,
              0
            ],
            [
              172,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_questions",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "namelist": "ares__llist_t",
              "buf": "ares__buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_name(ares__buf_t         *buf,\n                                            const ares_dns_rr_t *rr,\n                                            ares__llist_t      **namelist,\n                                            ares_bool_t       validate_hostname,\n                                            ares_dns_rr_key_t key)\n{\n  const char *name;\n\n  name = ares_dns_rr_get_str(rr, key);\n  if (name == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  return ares__dns_name_write(buf, namelist, validate_hostname, name);\n}",
          "fn_code_pos": [
            [
              174,
              0
            ],
            [
              188,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_name",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares__llist_t",
              "validate_hostname": "ares_bool_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_str(ares__buf_t         *buf,\n                                           const ares_dns_rr_t *rr,\n                                           ares_dns_rr_key_t    key)\n{\n  const char   *str;\n  size_t        len;\n  ares_status_t status;\n\n  str = ares_dns_rr_get_str(rr, key);\n  if (str == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  len = ares_strlen(str);\n  if (len > 255) {\n    return ARES_EFORMERR;\n  }\n\n  /* Write 1 byte length */\n  status = ares__buf_append_byte(buf, (unsigned char)(len & 0xFF));\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  if (len == 0) {\n    return ARES_SUCCESS;\n  }\n\n  /* Write string */\n  return ares__buf_append(buf, (const unsigned char *)str, len);\n}",
          "fn_code_pos": [
            [
              190,
              0
            ],
            [
              220,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_str",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_binstrs(ares__buf_t         *buf,\n                                               const ares_dns_rr_t *rr,\n                                               ares_dns_rr_key_t    key)\n{\n  const unsigned char *bin;\n  const unsigned char *ptr;\n  size_t               bin_len;\n  size_t               ptr_len;\n  ares_status_t        status;\n\n  bin = ares_dns_rr_get_bin(rr, key, &bin_len);\n  if (bin == NULL) {\n    return ARES_EFORMERR;\n  }\n  /* split into possible multiple 255-byte or less length strings */\n  ptr     = bin;\n  ptr_len = bin_len;\n  do {\n    size_t len = ptr_len;\n    if (len > 255) {\n      len = 255;\n    }\n\n    /* Length */\n    status = ares__buf_append_byte(buf, (unsigned char)(len & 0xFF));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* String */\n    if (len) {\n      status = ares__buf_append(buf, ptr, len);\n      if (status != ARES_SUCCESS) {\n        return status;\n      }\n    }\n\n    ptr     += len;\n    ptr_len -= len;\n  } while (ptr_len > 0);\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              222,
              0
            ],
            [
              264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_binstrs",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_be32(ares__buf_t         *buf,\n                                            const ares_dns_rr_t *rr,\n                                            ares_dns_rr_key_t    key)\n{\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U32) {\n    return ARES_EFORMERR;\n  }\n  return ares__buf_append_be32(buf, ares_dns_rr_get_u32(rr, key));\n}",
          "fn_code_pos": [
            [
              266,
              0
            ],
            [
              274,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_be32",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_be16(ares__buf_t         *buf,\n                                            const ares_dns_rr_t *rr,\n                                            ares_dns_rr_key_t    key)\n{\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U16) {\n    return ARES_EFORMERR;\n  }\n  return ares__buf_append_be16(buf, ares_dns_rr_get_u16(rr, key));\n}",
          "fn_code_pos": [
            [
              276,
              0
            ],
            [
              284,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_be16",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_u8(ares__buf_t         *buf,\n                                          const ares_dns_rr_t *rr,\n                                          ares_dns_rr_key_t    key)\n{\n  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U8) {\n    return ARES_EFORMERR;\n  }\n  return ares__buf_append_byte(buf, ares_dns_rr_get_u8(rr, key));\n}",
          "fn_code_pos": [
            [
              286,
              0
            ],
            [
              294,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_u8",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_a(ares__buf_t         *buf,\n                                         const ares_dns_rr_t *rr,\n                                         ares__llist_t      **namelist)\n{\n  const struct in_addr *addr;\n  (void)namelist;\n\n  addr = ares_dns_rr_get_addr(rr, ARES_RR_A_ADDR);\n  if (addr == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  return ares__buf_append(buf, (const unsigned char *)addr, sizeof(*addr));\n}",
          "fn_code_pos": [
            [
              296,
              0
            ],
            [
              309,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_a",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_ns(ares__buf_t         *buf,\n                                          const ares_dns_rr_t *rr,\n                                          ares__llist_t      **namelist)\n{\n  return ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,\n                                ARES_RR_NS_NSDNAME);\n}",
          "fn_code_pos": [
            [
              311,
              0
            ],
            [
              317,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_ns",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_cname(ares__buf_t         *buf,\n                                             const ares_dns_rr_t *rr,\n                                             ares__llist_t      **namelist)\n{\n  return ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,\n                                ARES_RR_CNAME_CNAME);\n}",
          "fn_code_pos": [
            [
              319,
              0
            ],
            [
              325,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_cname",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_soa(ares__buf_t         *buf,\n                                           const ares_dns_rr_t *rr,\n                                           ares__llist_t      **namelist)\n{\n  ares_status_t status;\n\n  /* MNAME */\n  status =\n    ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE, ARES_RR_SOA_MNAME);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* RNAME */\n  status =\n    ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE, ARES_RR_SOA_RNAME);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* SERIAL */\n  status = ares_dns_write_rr_be32(buf, rr, ARES_RR_SOA_SERIAL);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* REFRESH */\n  status = ares_dns_write_rr_be32(buf, rr, ARES_RR_SOA_REFRESH);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* RETRY */\n  status = ares_dns_write_rr_be32(buf, rr, ARES_RR_SOA_RETRY);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* EXPIRE */\n  status = ares_dns_write_rr_be32(buf, rr, ARES_RR_SOA_EXPIRE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* MINIMUM */\n  return ares_dns_write_rr_be32(buf, rr, ARES_RR_SOA_MINIMUM);\n}",
          "fn_code_pos": [
            [
              327,
              0
            ],
            [
              373,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_soa",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_ptr(ares__buf_t         *buf,\n                                           const ares_dns_rr_t *rr,\n                                           ares__llist_t      **namelist)\n{\n  return ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,\n                                ARES_RR_PTR_DNAME);\n}",
          "fn_code_pos": [
            [
              375,
              0
            ],
            [
              381,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_ptr",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_hinfo(ares__buf_t         *buf,\n                                             const ares_dns_rr_t *rr,\n                                             ares__llist_t      **namelist)\n{\n  ares_status_t status;\n\n  (void)namelist;\n\n  /* CPU */\n  status = ares_dns_write_rr_str(buf, rr, ARES_RR_HINFO_CPU);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* OS */\n  return ares_dns_write_rr_str(buf, rr, ARES_RR_HINFO_OS);\n}",
          "fn_code_pos": [
            [
              383,
              0
            ],
            [
              399,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_hinfo",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_mx(ares__buf_t         *buf,\n                                          const ares_dns_rr_t *rr,\n                                          ares__llist_t      **namelist)\n{\n  ares_status_t status;\n\n  /* PREFERENCE */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_MX_PREFERENCE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* EXCHANGE */\n  return ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,\n                                ARES_RR_MX_EXCHANGE);\n}",
          "fn_code_pos": [
            [
              401,
              0
            ],
            [
              416,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_mx",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_txt(ares__buf_t         *buf,\n                                           const ares_dns_rr_t *rr,\n                                           ares__llist_t      **namelist)\n{\n  (void)namelist;\n  return ares_dns_write_rr_binstrs(buf, rr, ARES_RR_TXT_DATA);\n}",
          "fn_code_pos": [
            [
              418,
              0
            ],
            [
              424,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_txt",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_aaaa(ares__buf_t         *buf,\n                                            const ares_dns_rr_t *rr,\n                                            ares__llist_t      **namelist)\n{\n  const struct ares_in6_addr *addr;\n  (void)namelist;\n\n  addr = ares_dns_rr_get_addr6(rr, ARES_RR_AAAA_ADDR);\n  if (addr == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  return ares__buf_append(buf, (const unsigned char *)addr, sizeof(*addr));\n}",
          "fn_code_pos": [
            [
              426,
              0
            ],
            [
              439,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_aaaa",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_srv(ares__buf_t         *buf,\n                                           const ares_dns_rr_t *rr,\n                                           ares__llist_t      **namelist)\n{\n  ares_status_t status;\n\n  /* PRIORITY */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_SRV_PRIORITY);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* WEIGHT */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_SRV_WEIGHT);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* PORT */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_SRV_PORT);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* TARGET */\n  return ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,\n                                ARES_RR_SRV_TARGET);\n}",
          "fn_code_pos": [
            [
              441,
              0
            ],
            [
              468,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_srv",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_naptr(ares__buf_t         *buf,\n                                             const ares_dns_rr_t *rr,\n                                             ares__llist_t      **namelist)\n{\n  ares_status_t status;\n\n  /* ORDER */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_NAPTR_ORDER);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* PREFERENCE */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_NAPTR_PREFERENCE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* FLAGS */\n  status = ares_dns_write_rr_str(buf, rr, ARES_RR_NAPTR_FLAGS);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* SERVICES */\n  status = ares_dns_write_rr_str(buf, rr, ARES_RR_NAPTR_SERVICES);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* REGEXP */\n  status = ares_dns_write_rr_str(buf, rr, ARES_RR_NAPTR_REGEXP);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* REPLACEMENT */\n  return ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,\n                                ARES_RR_NAPTR_REPLACEMENT);\n}",
          "fn_code_pos": [
            [
              470,
              0
            ],
            [
              509,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_naptr",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_opt(ares__buf_t         *buf,\n                                           const ares_dns_rr_t *rr,\n                                           ares__llist_t      **namelist)\n{\n  size_t         len = ares__buf_len(buf);\n  ares_status_t  status;\n  unsigned int   ttl = 0;\n  size_t         i;\n  unsigned short rcode = (unsigned short)((rr->parent->rcode >> 4) & 0xFF);\n\n  (void)namelist;\n\n  /* We need to go back and overwrite the class and ttl that were emitted as\n   * the OPT record overloads them for its own use (yes, very strange!) */\n  status = ares__buf_set_length(buf, len - 2 /* RDLENGTH */\n                                       - 4   /* TTL */\n                                       - 2 /* CLASS */);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Class -> UDP Size */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_OPT_UDP_SIZE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* TTL -> rcode (u8) << 24 | version (u8) << 16 | flags (u16) */\n  ttl |= (unsigned int)rcode << 24;\n  ttl |= (unsigned int)ares_dns_rr_get_u8(rr, ARES_RR_OPT_VERSION) << 16;\n  ttl |= (unsigned int)ares_dns_rr_get_u16(rr, ARES_RR_OPT_FLAGS);\n\n  status = ares__buf_append_be32(buf, ttl);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Now go back to real end */\n  status = ares__buf_set_length(buf, len);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Append Options */\n  for (i = 0; i < ares_dns_rr_get_opt_cnt(rr, ARES_RR_OPT_OPTIONS); i++) {\n    unsigned short       opt;\n    size_t               val_len;\n    const unsigned char *val;\n\n    opt = ares_dns_rr_get_opt(rr, ARES_RR_OPT_OPTIONS, i, &val, &val_len);\n\n    /* BE16 option */\n    status = ares__buf_append_be16(buf, opt);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* BE16 length */\n    status = ares__buf_append_be16(buf, (unsigned short)(val_len & 0xFFFF));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Value */\n    if (val && val_len) {\n      status = ares__buf_append(buf, val, val_len);\n      if (status != ARES_SUCCESS) {\n        return status;\n      }\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              511,
              0
            ],
            [
              584,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_opt",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_tlsa(ares__buf_t         *buf,\n                                            const ares_dns_rr_t *rr,\n                                            ares__llist_t      **namelist)\n{\n  ares_status_t        status;\n  const unsigned char *data;\n  size_t               len = 0;\n\n  (void)namelist;\n\n  /* CERT_USAGE */\n  status = ares_dns_write_rr_u8(buf, rr, ARES_RR_TLSA_CERT_USAGE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* SELECTOR */\n  status = ares_dns_write_rr_u8(buf, rr, ARES_RR_TLSA_SELECTOR);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* MATCH */\n  status = ares_dns_write_rr_u8(buf, rr, ARES_RR_TLSA_MATCH);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* DATA -- binary, rest of buffer, required to be non-zero length */\n  data = ares_dns_rr_get_bin(rr, ARES_RR_TLSA_DATA, &len);\n  if (data == NULL || len == 0) {\n    return ARES_EFORMERR;\n  }\n\n  return ares__buf_append(buf, data, len);\n}",
          "fn_code_pos": [
            [
              586,
              0
            ],
            [
              621,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_tlsa",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_svcb(ares__buf_t         *buf,\n                                            const ares_dns_rr_t *rr,\n                                            ares__llist_t      **namelist)\n{\n  ares_status_t status;\n  size_t        i;\n\n  /* PRIORITY */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_SVCB_PRIORITY);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* TARGET */\n  status =\n    ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE, ARES_RR_SVCB_TARGET);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Append Params */\n  for (i = 0; i < ares_dns_rr_get_opt_cnt(rr, ARES_RR_SVCB_PARAMS); i++) {\n    unsigned short       opt;\n    size_t               val_len;\n    const unsigned char *val;\n\n    opt = ares_dns_rr_get_opt(rr, ARES_RR_SVCB_PARAMS, i, &val, &val_len);\n\n    /* BE16 option */\n    status = ares__buf_append_be16(buf, opt);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* BE16 length */\n    status = ares__buf_append_be16(buf, (unsigned short)(val_len & 0xFFFF));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Value */\n    if (val && val_len) {\n      status = ares__buf_append(buf, val, val_len);\n      if (status != ARES_SUCCESS) {\n        return status;\n      }\n    }\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              623,
              0
            ],
            [
              672,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_svcb",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_https(ares__buf_t         *buf,\n                                             const ares_dns_rr_t *rr,\n                                             ares__llist_t      **namelist)\n{\n  ares_status_t status;\n  size_t        i;\n\n  /* PRIORITY */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_HTTPS_PRIORITY);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* TARGET */\n  status =\n    ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE, ARES_RR_HTTPS_TARGET);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Append Params */\n  for (i = 0; i < ares_dns_rr_get_opt_cnt(rr, ARES_RR_HTTPS_PARAMS); i++) {\n    unsigned short       opt;\n    size_t               val_len;\n    const unsigned char *val;\n\n    opt = ares_dns_rr_get_opt(rr, ARES_RR_HTTPS_PARAMS, i, &val, &val_len);\n\n    /* BE16 option */\n    status = ares__buf_append_be16(buf, opt);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* BE16 length */\n    status = ares__buf_append_be16(buf, (unsigned short)(val_len & 0xFFFF));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Value */\n    if (val && val_len) {\n      status = ares__buf_append(buf, val, val_len);\n      if (status != ARES_SUCCESS) {\n        return status;\n      }\n    }\n  }\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              674,
              0
            ],
            [
              723,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_https",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_uri(ares__buf_t         *buf,\n                                           const ares_dns_rr_t *rr,\n                                           ares__llist_t      **namelist)\n{\n  ares_status_t status;\n  const char   *target;\n\n  (void)namelist;\n\n  /* PRIORITY */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_URI_PRIORITY);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* WEIGHT */\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_URI_WEIGHT);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* TARGET -- not in DNS string format, rest of buffer, required to be\n   * non-zero length */\n  target = ares_dns_rr_get_str(rr, ARES_RR_URI_TARGET);\n  if (target == NULL || ares_strlen(target) == 0) {\n    return ARES_EFORMERR;\n  }\n\n  return ares__buf_append(buf, (const unsigned char *)target,\n                          ares_strlen(target));\n}",
          "fn_code_pos": [
            [
              725,
              0
            ],
            [
              755,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_uri",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_caa(ares__buf_t         *buf,\n                                           const ares_dns_rr_t *rr,\n                                           ares__llist_t      **namelist)\n{\n  const unsigned char *data     = NULL;\n  size_t               data_len = 0;\n  ares_status_t        status;\n\n  (void)namelist;\n\n  /* CRITICAL */\n  status = ares_dns_write_rr_u8(buf, rr, ARES_RR_CAA_CRITICAL);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Tag */\n  status = ares_dns_write_rr_str(buf, rr, ARES_RR_CAA_TAG);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Value - binary! (remaining buffer */\n  data = ares_dns_rr_get_bin(rr, ARES_RR_CAA_VALUE, &data_len);\n  if (data == NULL || data_len == 0) {\n    return ARES_EFORMERR;\n  }\n\n  return ares__buf_append(buf, data, data_len);\n}",
          "fn_code_pos": [
            [
              757,
              0
            ],
            [
              786,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_caa",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr_raw_rr(ares__buf_t         *buf,\n                                              const ares_dns_rr_t *rr,\n                                              ares__llist_t      **namelist)\n{\n  size_t               len = ares__buf_len(buf);\n  ares_status_t        status;\n  const unsigned char *data     = NULL;\n  size_t               data_len = 0;\n\n  (void)namelist;\n\n  /* We need to go back and overwrite the type that was emitted by the parent\n   * function */\n  status = ares__buf_set_length(buf, len - 2 /* RDLENGTH */\n                                       - 4   /* TTL */\n                                       - 2   /* CLASS */\n                                       - 2 /* TYPE */);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_RAW_RR_TYPE);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Now go back to real end */\n  status = ares__buf_set_length(buf, len);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Output raw data */\n  data = ares_dns_rr_get_bin(rr, ARES_RR_RAW_RR_DATA, &data_len);\n  if (data == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (data_len == 0) {\n    return ARES_SUCCESS;\n  }\n\n  return ares__buf_append(buf, data, data_len);\n}",
          "fn_code_pos": [
            [
              788,
              0
            ],
            [
              831,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr_raw_rr",
            "parameters": {
              "buf": "ares__buf_t",
              "rr": "ares_dns_rr_t",
              "namelist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_dns_write_rr(const ares_dns_record_t *dnsrec,\n                                       ares__llist_t          **namelist,\n                                       ares_dns_section_t       section,\n                                       ares__buf_t             *buf)\n{\n  size_t i;\n\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, section); i++) {\n    const ares_dns_rr_t *rr;\n    ares_dns_rec_type_t  type;\n    ares_bool_t          allow_compress;\n    ares__llist_t      **namelistptr = NULL;\n    size_t               pos_len;\n    ares_status_t        status;\n    size_t               rdlength;\n    size_t               end_length;\n    unsigned int         ttl;\n\n    rr = ares_dns_record_rr_get_const(dnsrec, section, i);\n    if (rr == NULL) {\n      return ARES_EFORMERR;\n    }\n\n    type           = ares_dns_rr_get_type(rr);\n    allow_compress = ares_dns_rec_type_allow_name_compression(type);\n    if (allow_compress) {\n      namelistptr = namelist;\n    }\n\n    /* Name */\n    status =\n      ares__dns_name_write(buf, namelist, ARES_TRUE, ares_dns_rr_get_name(rr));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Type */\n    status = ares__buf_append_be16(buf, (unsigned short)type);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Class */\n    status =\n      ares__buf_append_be16(buf, (unsigned short)ares_dns_rr_get_class(rr));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* TTL */\n    ttl = ares_dns_rr_get_ttl(rr);\n    if (rr->parent->ttl_decrement > ttl) {\n      ttl = 0;\n    } else {\n      ttl -= rr->parent->ttl_decrement;\n    }\n    status = ares__buf_append_be32(buf, ttl);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Length */\n    pos_len = ares__buf_len(buf); /* Save to write real length later */\n    status  = ares__buf_append_be16(buf, 0);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Data */\n    switch (type) {\n      case ARES_REC_TYPE_A:\n        status = ares_dns_write_rr_a(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_NS:\n        status = ares_dns_write_rr_ns(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_CNAME:\n        status = ares_dns_write_rr_cname(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_SOA:\n        status = ares_dns_write_rr_soa(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_PTR:\n        status = ares_dns_write_rr_ptr(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_HINFO:\n        status = ares_dns_write_rr_hinfo(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_MX:\n        status = ares_dns_write_rr_mx(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_TXT:\n        status = ares_dns_write_rr_txt(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_AAAA:\n        status = ares_dns_write_rr_aaaa(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_SRV:\n        status = ares_dns_write_rr_srv(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_NAPTR:\n        status = ares_dns_write_rr_naptr(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_ANY:\n        status = ARES_EFORMERR;\n        break;\n      case ARES_REC_TYPE_OPT:\n        status = ares_dns_write_rr_opt(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_TLSA:\n        status = ares_dns_write_rr_tlsa(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_SVCB:\n        status = ares_dns_write_rr_svcb(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_HTTPS:\n        status = ares_dns_write_rr_https(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_URI:\n        status = ares_dns_write_rr_uri(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_CAA:\n        status = ares_dns_write_rr_caa(buf, rr, namelistptr);\n        break;\n      case ARES_REC_TYPE_RAW_RR:\n        status = ares_dns_write_rr_raw_rr(buf, rr, namelistptr);\n        break;\n    }\n\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Back off write pointer, write real length, then go back to proper\n     * position */\n    end_length = ares__buf_len(buf);\n    rdlength   = end_length - pos_len - 2;\n\n    status = ares__buf_set_length(buf, pos_len);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    status = ares__buf_append_be16(buf, (unsigned short)(rdlength & 0xFFFF));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    status = ares__buf_set_length(buf, end_length);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              833,
              0
            ],
            [
              988,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write_rr",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "namelist": "ares__llist_t",
              "section": "ares_dns_section_t",
              "buf": "ares__buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_write(const ares_dns_record_t *dnsrec,\n                             unsigned char **buf, size_t *buf_len)\n{\n  ares__buf_t   *b = NULL;\n  ares_status_t  status;\n  ares__llist_t *namelist = NULL;\n\n  if (buf == NULL || buf_len == NULL || dnsrec == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  *buf     = NULL;\n  *buf_len = 0;\n\n  b = ares__buf_create();\n  if (b == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  status = ares_dns_write_header(dnsrec, b);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_dns_write_questions(dnsrec, &namelist, b);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_dns_write_rr(dnsrec, &namelist, ARES_SECTION_ANSWER, b);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_dns_write_rr(dnsrec, &namelist, ARES_SECTION_AUTHORITY, b);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_dns_write_rr(dnsrec, &namelist, ARES_SECTION_ADDITIONAL, b);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\ndone:\n  ares__llist_destroy(namelist);\n\n  if (status != ARES_SUCCESS) {\n    ares__buf_destroy(b);\n    return status;\n  }\n\n  *buf = ares__buf_finish_bin(b, buf_len);\n  return status;\n}",
          "fn_code_pos": [
            [
              990,
              0
            ],
            [
              1044,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_write",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "buf": "unsigned char",
              "buf_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares_dns_record_write_ttl_decrement(ares_dns_record_t *dnsrec,\n                                         unsigned int       ttl_decrement)\n{\n  if (dnsrec == NULL) {\n    return;\n  }\n  dnsrec->ttl_decrement = ttl_decrement;\n}",
          "fn_code_pos": [
            [
              1046,
              0
            ],
            [
              1053,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_write_ttl_decrement",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "ttl_decrement": "unsigned int"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct in_addr",
          {},
          "",
          [
            300,
            8
          ],
          [
            300,
            22
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            430,
            8
          ],
          [
            430,
            28
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <stdint.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_math.c": {
      "fn_def_list": [
        {
          "fn_code": "static unsigned int ares__round_up_pow2_u32(unsigned int n)\n{\n  /* NOTE: if already a power of 2, will return itself, not the next */\n  n--;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  n++;\n  return n;\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              43,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__round_up_pow2_u32",
            "parameters": {
              "n": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static ares_int64_t ares__round_up_pow2_u64(ares_int64_t n)\n{\n  /* NOTE: if already a power of 2, will return itself, not the next */\n  n--;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  n |= n >> 32;\n  n++;\n  return n;\n}",
          "fn_code_pos": [
            [
              45,
              0
            ],
            [
              57,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__round_up_pow2_u64",
            "parameters": {
              "n": "ares_int64_t"
            },
            "return_type": "ares_int64_t"
          }
        },
        {
          "fn_code": "size_t ares__round_up_pow2(size_t n)\n{\n  if (sizeof(size_t) > 4) {\n    return (size_t)ares__round_up_pow2_u64((ares_int64_t)n);\n  }\n\n  return (size_t)ares__round_up_pow2_u32((unsigned int)n);\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              66,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__round_up_pow2",
            "parameters": {
              "n": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "size_t ares__log2(size_t n)\n{\n  static const unsigned char tab32[32] = { 0,  1,  28, 2,  29, 14, 24, 3,\n                                           30, 22, 20, 15, 25, 17, 4,  8,\n                                           31, 27, 13, 23, 21, 19, 16, 7,\n                                           26, 12, 18, 6,  11, 5,  10, 9 };\n  static const unsigned char tab64[64] = {\n    63, 0,  58, 1,  59, 47, 53, 2,  60, 39, 48, 27, 54, 33, 42, 3,\n    61, 51, 37, 40, 49, 18, 28, 20, 55, 30, 34, 11, 43, 14, 22, 4,\n    62, 57, 46, 52, 38, 26, 32, 41, 50, 36, 17, 19, 29, 10, 13, 21,\n    56, 45, 25, 31, 35, 16, 9,  12, 44, 24, 15, 8,  23, 7,  6,  5\n  };\n\n  if (sizeof(size_t) == 4) {\n    return tab32[(n * 0x077CB531) >> 27];\n  }\n\n  return tab64[(n * 0x07EDD5E59A4E28C2) >> 58];\n}",
          "fn_code_pos": [
            [
              68,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__log2",
            "parameters": {
              "n": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "size_t ares__pow(size_t x, size_t y)\n{\n  size_t res = 1;\n\n  while (y > 0) {\n    /* If y is odd, multiply x with result */\n    if (y & 1) {\n      res = res * x;\n    }\n\n    /* y must be even now */\n    y = y >> 1; /* y /= 2; */\n    x = x * x;  /* x^2 */\n  }\n\n  return res;\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__pow",
            "parameters": {
              "x": "size_t",
              "y": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "size_t ares__count_digits(size_t n)\n{\n  size_t digits;\n\n  for (digits = 0; n > 0; digits++) {\n    n /= 10;\n  }\n  if (digits == 0) {\n    digits = 1;\n  }\n\n  return digits;\n}",
          "fn_code_pos": [
            [
              107,
              0
            ],
            [
              119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__count_digits",
            "parameters": {
              "n": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "size_t ares__count_hexdigits(size_t n)\n{\n  size_t digits;\n\n  for (digits = 0; n > 0; digits++) {\n    n /= 16;\n  }\n  if (digits == 0) {\n    digits = 1;\n  }\n\n  return digits;\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__count_hexdigits",
            "parameters": {
              "n": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "unsigned char ares__count_bits_u8(unsigned char x)\n{\n  /* Implementation obtained from:\n   * http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetTable */\n#define B2(n) n, n + 1, n + 1, n + 2\n#define B4(n) B2(n), B2(n + 1), B2(n + 1), B2(n + 2)\n#define B6(n) B4(n), B4(n + 1), B4(n + 1), B4(n + 2)\n  static const unsigned char lookup[256] = { B6(0), B6(1), B6(1), B6(2) };\n  return lookup[x];\n}",
          "fn_code_pos": [
            [
              135,
              0
            ],
            [
              144,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__count_bits_u8",
            "parameters": {
              "x": "unsigned char"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_expand_string.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_status_t ares_expand_string_ex(const unsigned char *encoded,\n                                    const unsigned char *abuf, size_t alen,\n                                    unsigned char **s, size_t *enclen)\n{\n  ares_status_t status;\n  ares__buf_t  *buf = NULL;\n  size_t        start_len;\n  size_t        len = 0;\n\n  if (encoded == NULL || abuf == NULL || alen == 0 || enclen == NULL) {\n    return ARES_EBADSTR; /* EFORMERR would be better */\n  }\n\n  if (encoded < abuf || encoded >= abuf + alen) {\n    return ARES_EBADSTR; /* EFORMERR would be better */\n  }\n\n  *enclen = 0;\n\n  /* NOTE: we allow 's' to be NULL to skip it */\n  if (s) {\n    *s = NULL;\n  }\n\n  buf = ares__buf_create_const(abuf, alen);\n\n  if (buf == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  status = ares__buf_set_position(buf, (size_t)(encoded - abuf));\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  start_len = ares__buf_len(buf);\n  status =\n    ares__buf_parse_dns_binstr(buf, ares__buf_len(buf), s, &len, ARES_FALSE);\n  /* hrm, no way to pass back 'len' with the prototype */\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  *enclen = start_len - ares__buf_len(buf);\n\ndone:\n  ares__buf_destroy(buf);\n  if (status == ARES_EBADNAME || status == ARES_EBADRESP) {\n    status = ARES_EBADSTR;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              43,
              0
            ],
            [
              94,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_expand_string_ex",
            "parameters": {
              "encoded": "unsigned char",
              "abuf": "unsigned char",
              "alen": "size_t",
              "s": "unsigned char",
              "enclen": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "int ares_expand_string(const unsigned char *encoded, const unsigned char *abuf,\n                       int alen, unsigned char **s, long *enclen)\n{\n  ares_status_t status;\n  size_t        temp_enclen = 0;\n\n  if (alen < 0) {\n    return ARES_EBADRESP;\n  }\n\n  status = ares_expand_string_ex(encoded, abuf, (size_t)alen, s, &temp_enclen);\n\n  *enclen = (long)temp_enclen;\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              96,
              0
            ],
            [
              110,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_expand_string",
            "parameters": {
              "encoded": "unsigned char",
              "abuf": "unsigned char",
              "alen": "int",
              "s": "unsigned char",
              "enclen": "long"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"ares_private.h\" /* for the memdebug */\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__parse_into_addrinfo.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_status_t ares__parse_into_addrinfo(const ares_dns_record_t *dnsrec,\n                                        ares_bool_t    cname_only_is_enodata,\n                                        unsigned short port,\n                                        struct ares_addrinfo *ai)\n{\n  ares_status_t               status;\n  size_t                      i;\n  size_t                      ancount;\n  const char                 *hostname  = NULL;\n  ares_bool_t                 got_a     = ARES_FALSE;\n  ares_bool_t                 got_aaaa  = ARES_FALSE;\n  ares_bool_t                 got_cname = ARES_FALSE;\n  struct ares_addrinfo_cname *cnames    = NULL;\n  struct ares_addrinfo_node  *nodes     = NULL;\n\n  /* Save question hostname */\n  status = ares_dns_record_query_get(dnsrec, 0, &hostname, NULL, NULL);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  ancount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER);\n  if (ancount == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  for (i = 0; i < ancount; i++) {\n    ares_dns_rec_type_t  rtype;\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get_const(dnsrec, ARES_SECTION_ANSWER, i);\n\n    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN) {\n      continue;\n    }\n\n    rtype = ares_dns_rr_get_type(rr);\n\n    /* Issue #683\n     * Old code did this hostname sanity check, however it appears this is\n     * flawed logic.  Other resolvers don't do this sanity check.  Leaving\n     * this code commented out for future reference.\n     *\n     * rname = ares_dns_rr_get_name(rr);\n     * if ((rtype == ARES_REC_TYPE_A || rtype == ARES_REC_TYPE_AAAA) &&\n     *     strcasecmp(rname, hostname) != 0) {\n     *   continue;\n     * }\n     */\n\n    if (rtype == ARES_REC_TYPE_CNAME) {\n      struct ares_addrinfo_cname *cname;\n\n      got_cname = ARES_TRUE;\n      /* replace hostname with data from cname\n       * SA: Seems wrong as it introduces order dependency. */\n      hostname = ares_dns_rr_get_str(rr, ARES_RR_CNAME_CNAME);\n\n      cname = ares__append_addrinfo_cname(&cnames);\n      if (cname == NULL) {\n        status = ARES_ENOMEM;\n        goto done;\n      }\n      cname->ttl   = (int)ares_dns_rr_get_ttl(rr);\n      cname->alias = ares_strdup(ares_dns_rr_get_name(rr));\n      if (cname->alias == NULL) {\n        status = ARES_ENOMEM;\n        goto done;\n      }\n      cname->name = ares_strdup(hostname);\n      if (cname->name == NULL) {\n        status = ARES_ENOMEM;\n        goto done;\n      }\n    } else if (rtype == ARES_REC_TYPE_A) {\n      got_a = ARES_TRUE;\n      status =\n        ares_append_ai_node(AF_INET, port, ares_dns_rr_get_ttl(rr),\n                            ares_dns_rr_get_addr(rr, ARES_RR_A_ADDR), &nodes);\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n    } else if (rtype == ARES_REC_TYPE_AAAA) {\n      got_aaaa = ARES_TRUE;\n      status   = ares_append_ai_node(AF_INET6, port, ares_dns_rr_get_ttl(rr),\n                                     ares_dns_rr_get_addr6(rr, ARES_RR_AAAA_ADDR),\n                                     &nodes);\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n    } else {\n      continue;\n    }\n  }\n\n  if (!got_a && !got_aaaa &&\n      (!got_cname || (got_cname && cname_only_is_enodata))) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  /* save the hostname as ai->name */\n  if (ai->name == NULL || strcasecmp(ai->name, hostname) != 0) {\n    ares_free(ai->name);\n    ai->name = ares_strdup(hostname);\n    if (ai->name == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n  }\n\n  if (got_a || got_aaaa) {\n    ares__addrinfo_cat_nodes(&ai->nodes, nodes);\n    nodes = NULL;\n  }\n\n  if (got_cname) {\n    ares__addrinfo_cat_cnames(&ai->cnames, cnames);\n    cnames = NULL;\n  }\n\ndone:\n  ares__freeaddrinfo_cnames(cnames);\n  ares__freeaddrinfo_nodes(nodes);\n\n  /* compatibility */\n  if (status == ARES_EBADNAME) {\n    status = ARES_EBADRESP;\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              49,
              0
            ],
            [
              180,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__parse_into_addrinfo",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "cname_only_is_enodata": "ares_bool_t",
              "port": "unsigned short",
              "ai": "struct ares_addrinfo"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            52,
            40
          ],
          [
            52,
            60
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            61,
            2
          ],
          [
            61,
            28
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            62,
            2
          ],
          [
            62,
            27
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            100,
            6
          ],
          [
            100,
            32
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#  include <limits.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_create_query.c": {
      "fn_def_list": [
        {
          "fn_code": "static int ares_create_query_int(const char *name, int dnsclass, int type,\n                                 unsigned short id, int rd,\n                                 unsigned char **bufp, int *buflenp,\n                                 int max_udp_size)\n{\n  ares_status_t      status;\n  ares_dns_record_t *dnsrec = NULL;\n  size_t             len;\n  ares_dns_flags_t   rd_flag = rd ? ARES_FLAG_RD : 0;\n\n  if (name == NULL || bufp == NULL || buflenp == NULL) {\n    status = ARES_EFORMERR;\n    goto done;\n  }\n\n  *bufp    = NULL;\n  *buflenp = 0;\n\n  status = ares_dns_record_create_query(\n    &dnsrec, name, (ares_dns_class_t)dnsclass, (ares_dns_rec_type_t)type, id,\n    rd_flag, (size_t)max_udp_size);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_dns_write(dnsrec, bufp, &len);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  *buflenp = (int)len;\n\ndone:\n  ares_dns_record_destroy(dnsrec);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              30,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_create_query_int",
            "parameters": {
              "name": "char",
              "dnsclass": "int",
              "type": "int",
              "id": "unsigned short",
              "rd": "int",
              "bufp": "unsigned char",
              "buflenp": "int",
              "max_udp_size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_create_query(const char *name, int dnsclass, int type,\n                      unsigned short id, int rd, unsigned char **bufp,\n                      int *buflenp, int max_udp_size)\n{\n  return ares_create_query_int(name, dnsclass, type, id, rd, bufp, buflenp,\n                               max_udp_size);\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              73,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_create_query",
            "parameters": {
              "name": "char",
              "dnsclass": "int",
              "type": "int",
              "id": "unsigned short",
              "rd": "int",
              "bufp": "unsigned char",
              "buflenp": "int",
              "max_udp_size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_mkquery(const char *name, int dnsclass, int type, unsigned short id,\n                 int rd, unsigned char **buf, int *buflen)\n{\n  return ares_create_query_int(name, dnsclass, type, id, rd, buf, buflen, 0);\n}",
          "fn_code_pos": [
            [
              75,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_mkquery",
            "parameters": {
              "name": "char",
              "dnsclass": "int",
              "type": "int",
              "id": "unsigned short",
              "rd": "int",
              "buf": "unsigned char",
              "buflen": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_getaddrinfo.c": {
      "fn_def_list": [
        {
          "fn_code": "struct ares_addrinfo_cname *\n  ares__append_addrinfo_cname(struct ares_addrinfo_cname **head)\n{\n  struct ares_addrinfo_cname *tail = ares_malloc_zero(sizeof(*tail));\n  struct ares_addrinfo_cname *last = *head;\n\n  if (tail == NULL) {\n    return NULL;\n  }\n\n  if (!last) {\n    *head = tail;\n    return tail;\n  }\n\n  while (last->next) {\n    last = last->next;\n  }\n\n  last->next = tail;\n  return tail;\n}",
          "fn_code_pos": [
            [
              107,
              0
            ],
            [
              128,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__append_addrinfo_cname",
            "parameters": {
              "head": "struct ares_addrinfo_cname"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void ares__addrinfo_cat_cnames(struct ares_addrinfo_cname **head,\n                               struct ares_addrinfo_cname  *tail)\n{\n  struct ares_addrinfo_cname *last = *head;\n  if (!last) {\n    *head = tail;\n    return;\n  }\n\n  while (last->next) {\n    last = last->next;\n  }\n\n  last->next = tail;\n}",
          "fn_code_pos": [
            [
              130,
              0
            ],
            [
              144,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__addrinfo_cat_cnames",
            "parameters": {
              "head": "struct ares_addrinfo_cname",
              "tail": "struct ares_addrinfo_cname"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "struct ares_addrinfo_node *\n  ares__append_addrinfo_node(struct ares_addrinfo_node **head)\n{\n  struct ares_addrinfo_node *tail = ares_malloc_zero(sizeof(*tail));\n  struct ares_addrinfo_node *last = *head;\n\n  if (tail == NULL) {\n    return NULL;\n  }\n\n  if (!last) {\n    *head = tail;\n    return tail;\n  }\n\n  while (last->ai_next) {\n    last = last->ai_next;\n  }\n\n  last->ai_next = tail;\n  return tail;\n}",
          "fn_code_pos": [
            [
              147,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__append_addrinfo_node",
            "parameters": {
              "head": "struct ares_addrinfo_node"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void ares__addrinfo_cat_nodes(struct ares_addrinfo_node **head,\n                              struct ares_addrinfo_node  *tail)\n{\n  struct ares_addrinfo_node *last = *head;\n  if (!last) {\n    *head = tail;\n    return;\n  }\n\n  while (last->ai_next) {\n    last = last->ai_next;\n  }\n\n  last->ai_next = tail;\n}",
          "fn_code_pos": [
            [
              170,
              0
            ],
            [
              184,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__addrinfo_cat_nodes",
            "parameters": {
              "head": "struct ares_addrinfo_node",
              "tail": "struct ares_addrinfo_node"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static unsigned short lookup_service(const char *service, int flags)\n{\n  const char     *proto;\n  struct servent *sep;\n#ifdef HAVE_GETSERVBYNAME_R\n  struct servent se;\n  char           tmpbuf[4096];\n#endif\n\n  if (service) {\n    if (flags & ARES_NI_UDP) {\n      proto = \"udp\";\n    } else if (flags & ARES_NI_SCTP) {\n      proto = \"sctp\";\n    } else if (flags & ARES_NI_DCCP) {\n      proto = \"dccp\";\n    } else {\n      proto = \"tcp\";\n    }\n#ifdef HAVE_GETSERVBYNAME_R\n    memset(&se, 0, sizeof(se));\n    sep = &se;\n    memset(tmpbuf, 0, sizeof(tmpbuf));\n#  if GETSERVBYNAME_R_ARGS == 6\n    if (getservbyname_r(service, proto, &se, (void *)tmpbuf, sizeof(tmpbuf),\n                        &sep) != 0) {\n      sep = NULL; /* LCOV_EXCL_LINE: buffer large so this never fails */\n    }\n#  elif GETSERVBYNAME_R_ARGS == 5\n    sep = getservbyname_r(service, proto, &se, (void *)tmpbuf, sizeof(tmpbuf));\n#  elif GETSERVBYNAME_R_ARGS == 4\n    if (getservbyname_r(service, proto, &se, (void *)tmpbuf) != 0) {\n      sep = NULL;\n    }\n#  else\n    /* Lets just hope the OS uses TLS! */\n    sep = getservbyname(service, proto);\n#  endif\n#else\n    /* Lets just hope the OS uses TLS! */\n#  if (defined(NETWARE) && !defined(__NOVELL_LIBC__))\n    sep = getservbyname(service, (char *)proto);\n#  else\n    sep = getservbyname(service, proto);\n#  endif\n#endif\n    return (sep ? ntohs((unsigned short)sep->s_port) : 0);\n  }\n  return 0;\n}",
          "fn_code_pos": [
            [
              189,
              0
            ],
            [
              238,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lookup_service",
            "parameters": {
              "service": "char",
              "flags": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static ares_bool_t fake_addrinfo(const char *name, unsigned short port,\n                                 const struct ares_addrinfo_hints *hints,\n                                 struct ares_addrinfo             *ai,\n                                 ares_addrinfo_callback callback, void *arg)\n{\n  struct ares_addrinfo_cname *cname;\n  ares_status_t               status = ARES_SUCCESS;\n  ares_bool_t                 result = ARES_FALSE;\n  int                         family = hints->ai_family;\n  if (family == AF_INET || family == AF_INET6 || family == AF_UNSPEC) {\n    /* It only looks like an IP address if it's all numbers and dots. */\n    size_t      numdots = 0;\n    ares_bool_t valid   = ARES_TRUE;\n    const char *p;\n    for (p = name; *p; p++) {\n      if (!ISDIGIT(*p) && *p != '.') {\n        valid = ARES_FALSE;\n        break;\n      } else if (*p == '.') {\n        numdots++;\n      }\n    }\n\n    /* if we don't have 3 dots, it is illegal\n     * (although inet_pton doesn't think so).\n     */\n    if (numdots != 3 || !valid) {\n      result = ARES_FALSE;\n    } else {\n      struct in_addr addr4;\n      result =\n        ares_inet_pton(AF_INET, name, &addr4) < 1 ? ARES_FALSE : ARES_TRUE;\n      if (result) {\n        status = ares_append_ai_node(AF_INET, port, 0, &addr4, &ai->nodes);\n        if (status != ARES_SUCCESS) {\n          callback(arg, (int)status, 0, NULL);\n          return ARES_TRUE;\n        }\n      }\n    }\n  }\n\n  if (!result && (family == AF_INET6 || family == AF_UNSPEC)) {\n    struct ares_in6_addr addr6;\n    result =\n      ares_inet_pton(AF_INET6, name, &addr6) < 1 ? ARES_FALSE : ARES_TRUE;\n    if (result) {\n      status = ares_append_ai_node(AF_INET6, port, 0, &addr6, &ai->nodes);\n      if (status != ARES_SUCCESS) {\n        callback(arg, (int)status, 0, NULL);\n        return ARES_TRUE;\n      }\n    }\n  }\n\n  if (!result) {\n    return ARES_FALSE;\n  }\n\n  if (hints->ai_flags & ARES_AI_CANONNAME) {\n    cname = ares__append_addrinfo_cname(&ai->cnames);\n    if (!cname) {\n      ares_freeaddrinfo(ai);\n      callback(arg, ARES_ENOMEM, 0, NULL);\n      return ARES_TRUE;\n    }\n\n    /* Duplicate the name, to avoid a constness violation. */\n    cname->name = ares_strdup(name);\n    if (!cname->name) {\n      ares_freeaddrinfo(ai);\n      callback(arg, ARES_ENOMEM, 0, NULL);\n      return ARES_TRUE;\n    }\n  }\n\n  ai->nodes->ai_socktype = hints->ai_socktype;\n  ai->nodes->ai_protocol = hints->ai_protocol;\n\n  callback(arg, ARES_SUCCESS, 0, ai);\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              244,
              0
            ],
            [
              325,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fake_addrinfo",
            "parameters": {
              "name": "char",
              "port": "unsigned short",
              "hints": "struct ares_addrinfo_hints",
              "ai": "struct ares_addrinfo",
              "callback": "ares_addrinfo_callback",
              "arg": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void hquery_free(struct host_query *hquery, ares_bool_t cleanup_ai)\n{\n  if (cleanup_ai) {\n    ares_freeaddrinfo(hquery->ai);\n  }\n  ares__strsplit_free(hquery->names, hquery->names_cnt);\n  ares_free(hquery->name);\n  ares_free(hquery->lookups);\n  ares_free(hquery);\n}",
          "fn_code_pos": [
            [
              327,
              0
            ],
            [
              336,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "hquery_free",
            "parameters": {
              "hquery": "struct host_query",
              "cleanup_ai": "ares_bool_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void end_hquery(struct host_query *hquery, ares_status_t status)\n{\n  struct ares_addrinfo_node  sentinel;\n  struct ares_addrinfo_node *next;\n\n  if (status == ARES_SUCCESS) {\n    if (!(hquery->hints.ai_flags & ARES_AI_NOSORT) && hquery->ai->nodes) {\n      sentinel.ai_next = hquery->ai->nodes;\n      ares__sortaddrinfo(hquery->channel, &sentinel);\n      hquery->ai->nodes = sentinel.ai_next;\n    }\n    next = hquery->ai->nodes;\n\n    while (next) {\n      next->ai_socktype = hquery->hints.ai_socktype;\n      next->ai_protocol = hquery->hints.ai_protocol;\n      next              = next->ai_next;\n    }\n  } else {\n    /* Clean up what we have collected by so far. */\n    ares_freeaddrinfo(hquery->ai);\n    hquery->ai = NULL;\n  }\n\n  hquery->callback(hquery->arg, (int)status, (int)hquery->timeouts, hquery->ai);\n  hquery_free(hquery, ARES_FALSE);\n}",
          "fn_code_pos": [
            [
              338,
              0
            ],
            [
              364,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "end_hquery",
            "parameters": {
              "hquery": "struct host_query",
              "status": "ares_status_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_bool_t ares__is_localhost(const char *name)\n{\n  /* RFC6761 6.3 says : The domain \"localhost.\" and any names falling within\n   * \".localhost.\" */\n  size_t len;\n\n  if (name == NULL) {\n    return ARES_FALSE;\n  }\n\n  if (strcmp(name, \"localhost\") == 0) {\n    return ARES_TRUE;\n  }\n\n  len = ares_strlen(name);\n  if (len < 10 /* strlen(\".localhost\") */) {\n    return ARES_FALSE;\n  }\n\n  if (strcmp(name + (len - 10 /* strlen(\".localhost\") */), \".localhost\") == 0) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              366,
              0
            ],
            [
              390,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__is_localhost",
            "parameters": {
              "name": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t file_lookup(struct host_query *hquery)\n{\n  const ares_hosts_entry_t *entry;\n  ares_status_t             status;\n\n  /* Per RFC 7686, reject queries for \".onion\" domain names with NXDOMAIN. */\n  if (ares__is_onion_domain(hquery->name)) {\n    return ARES_ENOTFOUND;\n  }\n\n  status = ares__hosts_search_host(\n    hquery->channel,\n    (hquery->hints.ai_flags & ARES_AI_ENVHOSTS) ? ARES_TRUE : ARES_FALSE,\n    hquery->name, &entry);\n\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares__hosts_entry_to_addrinfo(\n    entry, hquery->name, hquery->hints.ai_family, hquery->port,\n    (hquery->hints.ai_flags & ARES_AI_CANONNAME) ? ARES_TRUE : ARES_FALSE,\n    hquery->ai);\n\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n\ndone:\n  /* RFC6761 section 6.3 #3 states that \"Name resolution APIs and libraries\n   * SHOULD recognize localhost names as special and SHOULD always return the\n   * IP loopback address for address queries\".\n   * We will also ignore ALL errors when trying to resolve localhost, such\n   * as permissions errors reading /etc/hosts or a malformed /etc/hosts */\n  if (status != ARES_SUCCESS && status != ARES_ENOMEM &&\n      ares__is_localhost(hquery->name)) {\n    return ares__addrinfo_localhost(hquery->name, hquery->port, &hquery->hints,\n                                    hquery->ai);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              392,
              0
            ],
            [
              434,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_lookup",
            "parameters": {
              "hquery": "struct host_query"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static void next_lookup(struct host_query *hquery, ares_status_t status)\n{\n  switch (*hquery->remaining_lookups) {\n    case 'b':\n      /* RFC6761 section 6.3 #3 says \"Name resolution APIs SHOULD NOT send\n       * queries for localhost names to their configured caching DNS\n       * server(s).\"\n       * Otherwise, DNS lookup. */\n      if (!ares__is_localhost(hquery->name) && next_dns_lookup(hquery)) {\n        break;\n      }\n\n      hquery->remaining_lookups++;\n      next_lookup(hquery, status);\n      break;\n\n    case 'f':\n      /* Host file lookup */\n      if (file_lookup(hquery) == ARES_SUCCESS) {\n        end_hquery(hquery, ARES_SUCCESS);\n        break;\n      }\n      hquery->remaining_lookups++;\n      next_lookup(hquery, status);\n      break;\n    default:\n      /* No lookup left */\n      end_hquery(hquery, status);\n      break;\n  }\n}",
          "fn_code_pos": [
            [
              436,
              0
            ],
            [
              466,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "next_lookup",
            "parameters": {
              "hquery": "struct host_query",
              "status": "ares_status_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void terminate_retries(const struct host_query *hquery,\n                              unsigned short           qid)\n{\n  unsigned short term_qid =\n    (qid == hquery->qid_a) ? hquery->qid_aaaa : hquery->qid_a;\n  const ares_channel_t *channel = hquery->channel;\n  struct query         *query   = NULL;\n\n  /* No other outstanding queries, nothing to do */\n  if (!hquery->remaining) {\n    return;\n  }\n\n  query = ares__htable_szvp_get_direct(channel->queries_by_qid, term_qid);\n  if (query == NULL) {\n    return;\n  }\n\n  query->no_retries = ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              468,
              0
            ],
            [
              487,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "terminate_retries",
            "parameters": {
              "hquery": "struct host_query",
              "qid": "unsigned short"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void host_callback(void *arg, ares_status_t status, size_t timeouts,\n                          const ares_dns_record_t *dnsrec)\n{\n  struct host_query *hquery         = (struct host_query *)arg;\n  ares_status_t      addinfostatus  = ARES_SUCCESS;\n  hquery->timeouts                 += timeouts;\n  hquery->remaining--;\n\n  if (status == ARES_SUCCESS) {\n    if (dnsrec == NULL) {\n      addinfostatus = ARES_EBADRESP;\n    } else {\n      addinfostatus =\n        ares__parse_into_addrinfo(dnsrec, ARES_TRUE, hquery->port, hquery->ai);\n    }\n    if (addinfostatus == ARES_SUCCESS) {\n      terminate_retries(hquery, ares_dns_record_get_id(dnsrec));\n    }\n  }\n\n  if (!hquery->remaining) {\n    if (status == ARES_EDESTRUCTION || status == ARES_ECANCELLED) {\n      /* must make sure we don't do next_lookup() on destroy or cancel,\n       * and return the appropriate status.  We won't return a partial\n       * result in this case. */\n      end_hquery(hquery, status);\n    } else if (addinfostatus != ARES_SUCCESS && addinfostatus != ARES_ENODATA) {\n      /* error in parsing result e.g. no memory */\n      if (addinfostatus == ARES_EBADRESP && hquery->ai->nodes) {\n        /* We got a bad response from server, but at least one query\n         * ended with ARES_SUCCESS */\n        end_hquery(hquery, ARES_SUCCESS);\n      } else {\n        end_hquery(hquery, addinfostatus);\n      }\n    } else if (hquery->ai->nodes) {\n      /* at least one query ended with ARES_SUCCESS */\n      end_hquery(hquery, ARES_SUCCESS);\n    } else if (status == ARES_ENOTFOUND || status == ARES_ENODATA ||\n               addinfostatus == ARES_ENODATA) {\n      if (status == ARES_ENODATA || addinfostatus == ARES_ENODATA) {\n        hquery->nodata_cnt++;\n      }\n      next_lookup(hquery, hquery->nodata_cnt ? ARES_ENODATA : status);\n    } else {\n      end_hquery(hquery, status);\n    }\n  }\n\n  /* at this point we keep on waiting for the next query to finish */\n}",
          "fn_code_pos": [
            [
              489,
              0
            ],
            [
              539,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "host_callback",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_getaddrinfo_int(ares_channel_t *channel, const char *name,\n                                 const char                       *service,\n                                 const struct ares_addrinfo_hints *hints,\n                                 ares_addrinfo_callback callback, void *arg)\n{\n  struct host_query    *hquery;\n  unsigned short        port = 0;\n  int                   family;\n  struct ares_addrinfo *ai;\n  ares_status_t         status;\n\n  if (!hints) {\n    hints = &default_hints;\n  }\n\n  family = hints->ai_family;\n\n  /* Right now we only know how to look up Internet addresses\n     and unspec means try both basically. */\n  if (family != AF_INET && family != AF_INET6 && family != AF_UNSPEC) {\n    callback(arg, ARES_ENOTIMP, 0, NULL);\n    return;\n  }\n\n  if (ares__is_onion_domain(name)) {\n    callback(arg, ARES_ENOTFOUND, 0, NULL);\n    return;\n  }\n\n  if (service) {\n    if (hints->ai_flags & ARES_AI_NUMERICSERV) {\n      unsigned long val;\n      errno = 0;\n      val   = strtoul(service, NULL, 0);\n      if ((val == 0 && errno != 0) || val > 65535) {\n        callback(arg, ARES_ESERVICE, 0, NULL);\n        return;\n      }\n      port = (unsigned short)val;\n    } else {\n      port = lookup_service(service, 0);\n      if (!port) {\n        unsigned long val;\n        errno = 0;\n        val   = strtoul(service, NULL, 0);\n        if ((val == 0 && errno != 0) || val > 65535) {\n          callback(arg, ARES_ESERVICE, 0, NULL);\n          return;\n        }\n        port = (unsigned short)val;\n      }\n    }\n  }\n\n  ai = ares_malloc_zero(sizeof(*ai));\n  if (!ai) {\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    return;\n  }\n\n  if (fake_addrinfo(name, port, hints, ai, callback, arg)) {\n    return;\n  }\n\n  /* Allocate and fill in the host query structure. */\n  hquery = ares_malloc_zero(sizeof(*hquery));\n  if (!hquery) {\n    ares_freeaddrinfo(ai);\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    return;\n  }\n\n  hquery->port        = port;\n  hquery->channel     = channel;\n  hquery->hints       = *hints;\n  hquery->sent_family = -1; /* nothing is sent yet */\n  hquery->callback    = callback;\n  hquery->arg         = arg;\n  hquery->ai          = ai;\n  hquery->name        = ares_strdup(name);\n  if (hquery->name == NULL) {\n    hquery_free(hquery, ARES_TRUE);\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    return;\n  }\n\n  status =\n    ares__search_name_list(channel, name, &hquery->names, &hquery->names_cnt);\n  if (status != ARES_SUCCESS) {\n    hquery_free(hquery, ARES_TRUE);\n    callback(arg, (int)status, 0, NULL);\n    return;\n  }\n  hquery->next_name_idx = 0;\n\n\n  hquery->lookups = ares_strdup(channel->lookups);\n  if (hquery->lookups == NULL) {\n    hquery_free(hquery, ARES_TRUE);\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    return;\n  }\n  hquery->remaining_lookups = hquery->lookups;\n\n  /* Start performing lookups according to channel->lookups. */\n  next_lookup(hquery, ARES_ECONNREFUSED /* initial error code */);\n}",
          "fn_code_pos": [
            [
              541,
              0
            ],
            [
              647,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getaddrinfo_int",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "service": "char",
              "hints": "struct ares_addrinfo_hints",
              "callback": "ares_addrinfo_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_getaddrinfo(ares_channel_t *channel, const char *name,\n                      const char                       *service,\n                      const struct ares_addrinfo_hints *hints,\n                      ares_addrinfo_callback callback, void *arg)\n{\n  if (channel == NULL) {\n    return;\n  }\n  ares__channel_lock(channel);\n  ares_getaddrinfo_int(channel, name, service, hints, callback, arg);\n  ares__channel_unlock(channel);\n}",
          "fn_code_pos": [
            [
              649,
              0
            ],
            [
              660,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getaddrinfo",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "service": "char",
              "hints": "struct ares_addrinfo_hints",
              "callback": "ares_addrinfo_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t next_dns_lookup(struct host_query *hquery)\n{\n  const char *name = NULL;\n\n  if (hquery->next_name_idx >= hquery->names_cnt) {\n    return ARES_FALSE;\n  }\n\n  name = hquery->names[hquery->next_name_idx++];\n\n  /* NOTE: hquery may be invalidated during the call to ares_query_qid(),\n   *       so should not be referenced after this point */\n  switch (hquery->hints.ai_family) {\n    case AF_INET:\n      hquery->remaining += 1;\n      ares_query_dnsrec(hquery->channel, name, ARES_CLASS_IN, ARES_REC_TYPE_A,\n                        host_callback, hquery, &hquery->qid_a);\n      break;\n    case AF_INET6:\n      hquery->remaining += 1;\n      ares_query_dnsrec(hquery->channel, name, ARES_CLASS_IN,\n                        ARES_REC_TYPE_AAAA, host_callback, hquery,\n                        &hquery->qid_aaaa);\n      break;\n    case AF_UNSPEC:\n      hquery->remaining += 2;\n      ares_query_dnsrec(hquery->channel, name, ARES_CLASS_IN, ARES_REC_TYPE_A,\n                        host_callback, hquery, &hquery->qid_a);\n      ares_query_dnsrec(hquery->channel, name, ARES_CLASS_IN,\n                        ARES_REC_TYPE_AAAA, host_callback, hquery,\n                        &hquery->qid_aaaa);\n      break;\n    default:\n      break;\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              662,
              0
            ],
            [
              699,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "next_dns_lookup",
            "parameters": {
              "hquery": "struct host_query"
            },
            "return_type": "ares_bool_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "next_dns_lookup(struct host_query *hquery)",
          "fn_dec_pos": [
            [
              105,
              19
            ],
            [
              105,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "next_dns_lookup",
            "parameters": {
              "hquery": "struct host_query"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__append_addrinfo_cname(struct ares_addrinfo_cname **head)",
          "fn_dec_pos": [
            [
              108,
              2
            ],
            [
              108,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__append_addrinfo_cname",
            "parameters": {
              "head": "struct ares_addrinfo_cname"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__append_addrinfo_node(struct ares_addrinfo_node **head)",
          "fn_dec_pos": [
            [
              148,
              2
            ],
            [
              148,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__append_addrinfo_node",
            "parameters": {
              "head": "struct ares_addrinfo_node"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct host_query {\n  ares_channel_t            *channel;\n  char                      *name;\n  unsigned short             port; /* in host order */\n  ares_addrinfo_callback     callback;\n  void                      *arg;\n  struct ares_addrinfo_hints hints;\n  int    sent_family; /* this family is what was is being used */\n  size_t timeouts;    /* number of timeouts we saw for this request */\n  char  *lookups; /* Duplicate memory from channel because of ares_reinit() */\n  const char *remaining_lookups; /* types of lookup we need to perform (\"fb\" by\n                                    default, file and dns respectively) */\n\n  /* Search order for names */\n  char      **names;\n  size_t      names_cnt;\n  size_t      next_name_idx;       /* next name index being attempted */\n\n  struct ares_addrinfo *ai;        /* store results between lookups */\n  unsigned short        qid_a;     /* qid for A request */\n  unsigned short        qid_aaaa;  /* qid for AAAA request */\n\n  size_t                remaining; /* number of DNS answers waiting for */\n\n  /* Track nodata responses to possibly override final result */\n  size_t                nodata_cnt;\n}",
          {
            "*channel": "ares_channel_t",
            "*name": "char",
            "port": "unsigned short",
            "callback": "ares_addrinfo_callback",
            "*arg": "void",
            "hints": "struct ares_addrinfo_hints",
            "sent_family": "int",
            "timeouts": "size_t",
            "*lookups": "char",
            "char": "const",
            "**names": "char",
            "names_cnt": "size_t",
            "next_name_idx": "size_t",
            "*ai": "struct ares_addrinfo",
            "qid_a": "unsigned short",
            "qid_aaaa": "unsigned short",
            "remaining": "size_t",
            "nodata_cnt": "size_t"
          },
          "host_query",
          [
            69,
            0
          ],
          [
            95,
            1
          ]
        ],
        [
          "struct host_query {\n  ares_channel_t            *channel;\n  char                      *name;\n  unsigned short             port; /* in host order */\n  ares_addrinfo_callback     callback;\n  void                      *arg;\n  struct ares_addrinfo_hints hints;\n  int    sent_family; /* this family is what was is being used */\n  size_t timeouts;    /* number of timeouts we saw for this request */\n  char  *lookups; /* Duplicate memory from channel because of ares_reinit() */\n  const char *remaining_lookups; /* types of lookup we need to perform (\"fb\" by\n                                    default, file and dns respectively) */\n\n  /* Search order for names */\n  char      **names;\n  size_t      names_cnt;\n  size_t      next_name_idx;       /* next name index being attempted */\n\n  struct ares_addrinfo *ai;        /* store results between lookups */\n  unsigned short        qid_a;     /* qid for A request */\n  unsigned short        qid_aaaa;  /* qid for AAAA request */\n\n  size_t                remaining; /* number of DNS answers waiting for */\n\n  /* Track nodata responses to possibly override final result */\n  size_t                nodata_cnt;\n}",
          {
            "*channel": "ares_channel_t",
            "*name": "char",
            "port": "unsigned short",
            "callback": "ares_addrinfo_callback",
            "*arg": "void",
            "hints": "struct ares_addrinfo_hints",
            "sent_family": "int",
            "timeouts": "size_t",
            "*lookups": "char",
            "char": "const",
            "**names": "char",
            "names_cnt": "size_t",
            "next_name_idx": "size_t",
            "*ai": "struct ares_addrinfo",
            "qid_a": "unsigned short",
            "qid_aaaa": "unsigned short",
            "remaining": "size_t",
            "nodata_cnt": "size_t"
          },
          "host_query",
          [
            69,
            0
          ],
          [
            95,
            1
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            75,
            2
          ],
          [
            75,
            28
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            87,
            2
          ],
          [
            87,
            22
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            97,
            13
          ],
          [
            97,
            39
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            105,
            35
          ],
          [
            105,
            52
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            107,
            0
          ],
          [
            107,
            26
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            108,
            30
          ],
          [
            108,
            56
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            110,
            2
          ],
          [
            110,
            28
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            111,
            2
          ],
          [
            111,
            28
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            130,
            31
          ],
          [
            130,
            57
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            131,
            31
          ],
          [
            131,
            57
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            133,
            2
          ],
          [
            133,
            28
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            147,
            0
          ],
          [
            147,
            25
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            148,
            29
          ],
          [
            148,
            54
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            150,
            2
          ],
          [
            150,
            27
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            151,
            2
          ],
          [
            151,
            27
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            170,
            30
          ],
          [
            170,
            55
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            171,
            30
          ],
          [
            171,
            55
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            173,
            2
          ],
          [
            173,
            27
          ]
        ],
        [
          "struct servent",
          {},
          "",
          [
            192,
            2
          ],
          [
            192,
            16
          ]
        ],
        [
          "struct servent",
          {},
          "",
          [
            194,
            2
          ],
          [
            194,
            16
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            245,
            39
          ],
          [
            245,
            65
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            246,
            33
          ],
          [
            246,
            53
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            249,
            2
          ],
          [
            249,
            28
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            273,
            6
          ],
          [
            273,
            20
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            287,
            4
          ],
          [
            287,
            24
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            327,
            24
          ],
          [
            327,
            41
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            338,
            23
          ],
          [
            338,
            40
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            340,
            2
          ],
          [
            340,
            27
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            341,
            2
          ],
          [
            341,
            27
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            392,
            33
          ],
          [
            392,
            50
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            436,
            24
          ],
          [
            436,
            41
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            468,
            36
          ],
          [
            468,
            53
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            474,
            2
          ],
          [
            474,
            14
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            492,
            2
          ],
          [
            492,
            19
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            492,
            39
          ],
          [
            492,
            56
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            543,
            39
          ],
          [
            543,
            65
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            546,
            2
          ],
          [
            546,
            19
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            549,
            2
          ],
          [
            549,
            22
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            651,
            28
          ],
          [
            651,
            54
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            662,
            35
          ],
          [
            662,
            52
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#  include <limits.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ],
        [
          "#include \"ares_dns.h\"\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#  include \"ares_platform.h\"\n",
          [
            66,
            0
          ],
          [
            67,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_parse_txt_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "static int ares__parse_txt_reply(const unsigned char *abuf, size_t alen,\n                                 ares_bool_t ex, void **txt_out)\n{\n  ares_status_t        status;\n  struct ares_txt_ext *txt_head = NULL;\n  struct ares_txt_ext *txt_last = NULL;\n  struct ares_txt_ext *txt_curr;\n  ares_dns_record_t   *dnsrec = NULL;\n  size_t               i;\n\n  *txt_out = NULL;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);\n    const unsigned char *ptr;\n    size_t               ptr_len;\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP;\n      goto done;\n    }\n\n    /* XXX: Why Chaos? */\n    if ((ares_dns_rr_get_class(rr) != ARES_CLASS_IN &&\n         ares_dns_rr_get_class(rr) != ARES_CLASS_CHAOS) ||\n        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_TXT) {\n      continue;\n    }\n\n    /* Allocate storage for this TXT answer appending it to the list */\n    txt_curr =\n      ares_malloc_data(ex ? ARES_DATATYPE_TXT_EXT : ARES_DATATYPE_TXT_REPLY);\n    if (txt_curr == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n\n    /* Link in the record */\n    if (txt_last) {\n      txt_last->next = txt_curr;\n    } else {\n      txt_head = txt_curr;\n    }\n    txt_last = txt_curr;\n\n    /* These days, records are joined, always tag as start */\n    if (ex) {\n      txt_curr->record_start = 1;\n    }\n\n    ptr = ares_dns_rr_get_bin(rr, ARES_RR_TXT_DATA, &ptr_len);\n\n    txt_curr->txt = ares_malloc(ptr_len + 1);\n    if (txt_curr->txt == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    memcpy(txt_curr->txt, ptr, ptr_len);\n    txt_curr->txt[ptr_len] = 0;\n    txt_curr->length       = ptr_len;\n  }\n\ndone:\n  /* clean up on error */\n  if (status != ARES_SUCCESS) {\n    if (txt_head) {\n      ares_free_data(txt_head);\n    }\n  } else {\n    /* everything looks fine, return the data */\n    *txt_out = txt_head;\n  }\n  ares_dns_record_destroy(dnsrec);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              117,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__parse_txt_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "size_t",
              "ex": "ares_bool_t",
              "txt_out": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_parse_txt_reply(const unsigned char *abuf, int alen,\n                         struct ares_txt_reply **txt_out)\n{\n  if (alen < 0) {\n    return ARES_EBADRESP;\n  }\n  return ares__parse_txt_reply(abuf, (size_t)alen, ARES_FALSE,\n                               (void **)txt_out);\n}",
          "fn_code_pos": [
            [
              119,
              0
            ],
            [
              127,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_txt_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "txt_out": "struct ares_txt_reply"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_parse_txt_reply_ext(const unsigned char *abuf, int alen,\n                             struct ares_txt_ext **txt_out)\n{\n  if (alen < 0) {\n    return ARES_EBADRESP;\n  }\n  return ares__parse_txt_reply(abuf, (size_t)alen, ARES_TRUE, (void **)txt_out);\n}",
          "fn_code_pos": [
            [
              129,
              0
            ],
            [
              136,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_txt_reply_ext",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "txt_out": "struct ares_txt_ext"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            35,
            2
          ],
          [
            35,
            21
          ]
        ],
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            36,
            2
          ],
          [
            36,
            21
          ]
        ],
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            37,
            2
          ],
          [
            37,
            21
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            120,
            25
          ],
          [
            120,
            46
          ]
        ],
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            130,
            29
          ],
          [
            130,
            48
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/inet_ntop.c": {
      "fn_def_list": [
        {
          "fn_code": "const char        *ares_inet_ntop(int af, const void *src, char *dst,\n                                  ares_socklen_t size)\n{\n  switch (af) {\n    case AF_INET:\n      return inet_ntop4(src, dst, (size_t)size);\n    case AF_INET6:\n      return inet_ntop6(src, dst, (size_t)size);\n    default:\n      break;\n  }\n  SET_ERRNO(EAFNOSUPPORT);\n  return NULL;\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_ntop",
            "parameters": {
              "af": "int",
              "src": "void",
              "dst": "char",
              "size": "ares_socklen_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static const char *inet_ntop4(const unsigned char *src, char *dst, size_t size)\n{\n  static const char fmt[] = \"%u.%u.%u.%u\";\n  char              tmp[sizeof(\"255.255.255.255\")];\n\n  if (size < sizeof(tmp)) {\n    SET_ERRNO(ENOSPC);\n    return NULL;\n  }\n\n  if ((size_t)snprintf(tmp, sizeof(tmp), fmt, src[0], src[1], src[2], src[3]) >=\n      size) {\n    SET_ERRNO(ENOSPC);\n    return NULL;\n  }\n  ares_strcpy(dst, tmp, size);\n  return dst;\n}",
          "fn_code_pos": [
            [
              78,
              0
            ],
            [
              95,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inet_ntop4",
            "parameters": {
              "src": "unsigned char",
              "dst": "char",
              "size": "size_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static const char *inet_ntop6(const unsigned char *src, char *dst, size_t size)\n{\n  /*\n   * Note that int32_t and int16_t need only be \"at least\" large enough\n   * to contain a value of the specified size.  On some systems, like\n   * Crays, there is no such thing as an integer variable with 16 bits.\n   * Keep this in mind if you think this function should have been coded\n   * to use pointer overlays.  All the world's not a VAX.\n   */\n  char  tmp[sizeof(\"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\")];\n  char *tp;\n\n  struct {\n    ares_ssize_t base;\n    size_t       len;\n  } best, cur;\n\n  unsigned int words[NS_IN6ADDRSZ / NS_INT16SZ];\n  size_t       i;\n\n  /*\n   * Preprocess:\n   *  Copy the input (bytewise) array into a wordwise array.\n   *  Find the longest run of 0x00's in src[] for :: shorthanding.\n   */\n  memset(words, '\\0', sizeof(words));\n  for (i = 0; i < NS_IN6ADDRSZ; i++) {\n    words[i / 2] |= (unsigned int)(src[i] << ((1 - (i % 2)) << 3));\n  }\n  best.base = -1;\n  best.len  = 0;\n  cur.base  = -1;\n  cur.len   = 0;\n  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {\n    if (words[i] == 0) {\n      if (cur.base == -1) {\n        cur.base = (ares_ssize_t)i;\n        cur.len  = 1;\n      } else {\n        cur.len++;\n      }\n    } else {\n      if (cur.base != -1) {\n        if (best.base == -1 || cur.len > best.len) {\n          best = cur;\n        }\n        cur.base = -1;\n      }\n    }\n  }\n  if (cur.base != -1) {\n    if (best.base == -1 || cur.len > best.len) {\n      best = cur;\n    }\n  }\n  if (best.base != -1 && best.len < 2) {\n    best.base = -1;\n  }\n\n  /*\n   * Format the result.\n   */\n  tp = tmp;\n  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {\n    /* Are we inside the best run of 0x00's? */\n    if (best.base != -1 && i >= (size_t)best.base &&\n        i < ((size_t)best.base + best.len)) {\n      if (i == (size_t)best.base) {\n        *tp++ = ':';\n      }\n      continue;\n    }\n    /* Are we following an initial run of 0x00s or any real hex? */\n    if (i != 0) {\n      *tp++ = ':';\n    }\n    /* Is this address an encapsulated IPv4? */\n    if (i == 6 && best.base == 0 &&\n        (best.len == 6 || (best.len == 7 && words[7] != 0x0001) ||\n         (best.len == 5 && words[5] == 0xffff))) {\n      if (!inet_ntop4(src + 12, tp, sizeof(tmp) - (size_t)(tp - tmp))) {\n        return (NULL);\n      }\n      tp += ares_strlen(tp);\n      break;\n    }\n    tp += snprintf(tp, sizeof(tmp) - (size_t)(tp - tmp), \"%x\", words[i]);\n  }\n  /* Was it a trailing run of 0x00's? */\n  if (best.base != -1 &&\n      ((size_t)best.base + best.len) == (NS_IN6ADDRSZ / NS_INT16SZ)) {\n    *tp++ = ':';\n  }\n  *tp++ = '\\0';\n\n  /*\n   * Check for overflow, copy, and we're done.\n   */\n  if ((size_t)(tp - tmp) > size) {\n    SET_ERRNO(ENOSPC);\n    return NULL;\n  }\n  ares_strcpy(dst, tmp, size);\n  return dst;\n}",
          "fn_code_pos": [
            [
              103,
              0
            ],
            [
              207,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inet_ntop6",
            "parameters": {
              "src": "unsigned char",
              "dst": "char",
              "size": "size_t"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "inet_ntop4(const unsigned char *src, char *dst, size_t size)",
          "fn_dec_pos": [
            [
              36,
              19
            ],
            [
              36,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inet_ntop4",
            "parameters": {
              "src": "unsigned char",
              "dst": "char",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "inet_ntop6(const unsigned char *src, char *dst, size_t size)",
          "fn_dec_pos": [
            [
              37,
              19
            ],
            [
              37,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inet_ntop6",
            "parameters": {
              "src": "unsigned char",
              "dst": "char",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_inet_ntop(int af, const void *src, char *dst,\n                                  ares_socklen_t size)",
          "fn_dec_pos": [
            [
              52,
              19
            ],
            [
              53,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_ntop",
            "parameters": {
              "af": "int",
              "src": "void",
              "dst": "char",
              "size": "ares_socklen_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "inet_ntop4(const unsigned char *src, char *dst, size_t size)",
          "fn_dec_pos": [
            [
              78,
              19
            ],
            [
              78,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inet_ntop4",
            "parameters": {
              "src": "unsigned char",
              "dst": "char",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "inet_ntop6(const unsigned char *src, char *dst, size_t size)",
          "fn_dec_pos": [
            [
              103,
              19
            ],
            [
              103,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inet_ntop6",
            "parameters": {
              "src": "unsigned char",
              "dst": "char",
              "size": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct {\n    ares_ssize_t base;\n    size_t       len;\n  }",
          {
            "base": "ares_ssize_t",
            "len": "size_t"
          },
          "",
          [
            115,
            2
          ],
          [
            118,
            3
          ]
        ],
        [
          "struct {\n    ares_ssize_t base;\n    size_t       len;\n  }",
          {
            "base": "ares_ssize_t",
            "len": "size_t"
          },
          "",
          [
            115,
            2
          ],
          [
            118,
            3
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_private.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares_ipv6.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_sysconfig_files.c": {
      "fn_def_list": [
        {
          "fn_code": "static unsigned char ip_natural_mask(const struct ares_addr *addr)\n{\n  const unsigned char *ptr = NULL;\n  /* This is an odd one.  If a raw ipv4 address is specified, then we take\n   * what is called a natural mask, which means we look at the first octet\n   * of the ip address and for values 0-127 we assume it is a class A (/8),\n   * for values 128-191 we assume it is a class B (/16), and for 192-223\n   * we assume it is a class C (/24).  223-239 is Class D which and 240-255 is\n   * Class E, however, there is no pre-defined mask for this, so we'll use\n   * /24 as well as that's what the old code did.\n   *\n   * For IPv6, we'll use /64.\n   */\n\n  if (addr->family == AF_INET6) {\n    return 64;\n  }\n\n  ptr = (const unsigned char *)&addr->addr.addr4;\n  if (*ptr < 128) {\n    return 8;\n  }\n\n  if (*ptr < 192) {\n    return 16;\n  }\n\n  return 24;\n}",
          "fn_code_pos": [
            [
              68,
              0
            ],
            [
              96,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ip_natural_mask",
            "parameters": {
              "addr": "struct ares_addr"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static ares_bool_t sortlist_append(struct apattern **sortlist, size_t *nsort,\n                                   const struct apattern *pat)\n{\n  struct apattern *newsort;\n\n  newsort = ares_realloc(*sortlist, (*nsort + 1) * sizeof(*newsort));\n  if (newsort == NULL) {\n    return ARES_FALSE;\n  }\n\n  *sortlist = newsort;\n\n  memcpy(&(*sortlist)[*nsort], pat, sizeof(**sortlist));\n  (*nsort)++;\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              98,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sortlist_append",
            "parameters": {
              "sortlist": "struct apattern",
              "nsort": "size_t",
              "pat": "struct apattern"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t parse_sort(ares__buf_t *buf, struct apattern *pat)\n{\n  ares_status_t       status;\n  const unsigned char ip_charset[]             = \"ABCDEFabcdef0123456789.:\";\n  char                ipaddr[INET6_ADDRSTRLEN] = \"\";\n  size_t              addrlen;\n\n  memset(pat, 0, sizeof(*pat));\n\n  /* Consume any leading whitespace */\n  ares__buf_consume_whitespace(buf, ARES_TRUE);\n\n  /* If no length, just ignore, return ENOTFOUND as an indicator */\n  if (ares__buf_len(buf) == 0) {\n    return ARES_ENOTFOUND;\n  }\n\n  ares__buf_tag(buf);\n\n  /* Consume ip address */\n  if (ares__buf_consume_charset(buf, ip_charset, sizeof(ip_charset) - 1) == 0) {\n    return ARES_EBADSTR;\n  }\n\n  /* Fetch ip address */\n  status = ares__buf_tag_fetch_string(buf, ipaddr, sizeof(ipaddr));\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* Parse it to make sure its valid */\n  pat->addr.family = AF_UNSPEC;\n  if (ares_dns_pton(ipaddr, &pat->addr, &addrlen) == NULL) {\n    return ARES_EBADSTR;\n  }\n\n  /* See if there is a subnet mask */\n  if (ares__buf_begins_with(buf, (const unsigned char *)\"/\", 1)) {\n    char                maskstr[16];\n    const unsigned char ipv4_charset[] = \"0123456789.\";\n\n\n    /* Consume / */\n    ares__buf_consume(buf, 1);\n\n    ares__buf_tag(buf);\n\n    /* Consume mask */\n    if (ares__buf_consume_charset(buf, ipv4_charset,\n                                  sizeof(ipv4_charset) - 1) == 0) {\n      return ARES_EBADSTR;\n    }\n\n    /* Fetch mask */\n    status = ares__buf_tag_fetch_string(buf, maskstr, sizeof(maskstr));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    if (ares_str_isnum(maskstr)) {\n      /* Numeric mask */\n      int mask = atoi(maskstr);\n      if (mask < 0 || mask > 128) {\n        return ARES_EBADSTR;\n      }\n      if (pat->addr.family == AF_INET && mask > 32) {\n        return ARES_EBADSTR;\n      }\n      pat->mask = (unsigned char)mask;\n    } else {\n      /* Ipv4 subnet style mask */\n      struct ares_addr     maskaddr;\n      const unsigned char *ptr;\n\n      memset(&maskaddr, 0, sizeof(maskaddr));\n      maskaddr.family = AF_INET;\n      if (ares_dns_pton(maskstr, &maskaddr, &addrlen) == NULL) {\n        return ARES_EBADSTR;\n      }\n      ptr       = (const unsigned char *)&maskaddr.addr.addr4;\n      pat->mask = (unsigned char)(ares__count_bits_u8(ptr[0]) +\n                                  ares__count_bits_u8(ptr[1]) +\n                                  ares__count_bits_u8(ptr[2]) +\n                                  ares__count_bits_u8(ptr[3]));\n    }\n  } else {\n    pat->mask = ip_natural_mask(&pat->addr);\n  }\n\n  /* Consume any trailing whitespace */\n  ares__buf_consume_whitespace(buf, ARES_TRUE);\n\n  /* If we have any trailing bytes other than whitespace, its a parse failure */\n  if (ares__buf_len(buf) != 0) {\n    return ARES_EBADSTR;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              116,
              0
            ],
            [
              214,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_sort",
            "parameters": {
              "buf": "ares__buf_t",
              "pat": "struct apattern"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__parse_sortlist(struct apattern **sortlist, size_t *nsort,\n                                   const char *str)\n{\n  ares__buf_t        *buf    = NULL;\n  ares__llist_t      *list   = NULL;\n  ares_status_t       status = ARES_SUCCESS;\n  ares__llist_node_t *node   = NULL;\n\n  if (sortlist == NULL || nsort == NULL || str == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  if (*sortlist != NULL) {\n    ares_free(*sortlist);\n  }\n\n  *sortlist = NULL;\n  *nsort    = 0;\n\n  buf = ares__buf_create_const((const unsigned char *)str, ares_strlen(str));\n  if (buf == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  /* Split on space or semicolon */\n  status = ares__buf_split(buf, (const unsigned char *)\" ;\", 2,\n                           ARES_BUF_SPLIT_NONE, 0, &list);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  for (node = ares__llist_node_first(list); node != NULL;\n       node = ares__llist_node_next(node)) {\n    ares__buf_t    *entry = ares__llist_node_val(node);\n\n    struct apattern pat;\n\n    status = parse_sort(entry, &pat);\n    if (status != ARES_SUCCESS && status != ARES_ENOTFOUND) {\n      goto done;\n    }\n\n    if (status != ARES_SUCCESS) {\n      continue;\n    }\n\n    if (!sortlist_append(sortlist, nsort, &pat)) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  ares__buf_destroy(buf);\n  ares__llist_destroy(list);\n\n  if (status != ARES_SUCCESS) {\n    ares_free(*sortlist);\n    *sortlist = NULL;\n    *nsort    = 0;\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              216,
              0
            ],
            [
              282,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__parse_sortlist",
            "parameters": {
              "sortlist": "struct apattern",
              "nsort": "size_t",
              "str": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t config_search(ares_sysconfig_t *sysconfig, const char *str,\n                                   size_t max_domains)\n{\n  if (sysconfig->domains && sysconfig->ndomains > 0) {\n    /* if we already have some domains present, free them first */\n    ares__strsplit_free(sysconfig->domains, sysconfig->ndomains);\n    sysconfig->domains  = NULL;\n    sysconfig->ndomains = 0;\n  }\n\n  sysconfig->domains = ares__strsplit(str, \", \", &sysconfig->ndomains);\n  if (sysconfig->domains == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  /* Truncate if necessary */\n  if (max_domains && sysconfig->ndomains > max_domains) {\n    size_t i;\n    for (i = max_domains; i < sysconfig->ndomains; i++) {\n      ares_free(sysconfig->domains[i]);\n      sysconfig->domains[i] = NULL;\n    }\n    sysconfig->ndomains = max_domains;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              284,
              0
            ],
            [
              310,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "config_search",
            "parameters": {
              "sysconfig": "ares_sysconfig_t",
              "str": "char",
              "max_domains": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t buf_fetch_string(ares__buf_t *buf, char *str,\n                                      size_t str_len)\n{\n  ares_status_t status;\n  ares__buf_tag(buf);\n  ares__buf_consume(buf, ares__buf_len(buf));\n\n  status = ares__buf_tag_fetch_string(buf, str, str_len);\n  return status;\n}",
          "fn_code_pos": [
            [
              312,
              0
            ],
            [
              321,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "buf_fetch_string",
            "parameters": {
              "buf": "ares__buf_t",
              "str": "char",
              "str_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t config_lookup(ares_sysconfig_t *sysconfig,\n                                   ares__buf_t *buf, const char *separators)\n{\n  ares_status_t       status;\n  char                lookupstr[32];\n  size_t              lookupstr_cnt = 0;\n  ares__llist_t      *lookups       = NULL;\n  ares__llist_node_t *node;\n  size_t              separators_len = ares_strlen(separators);\n\n  status = ares__buf_split(buf, (const unsigned char *)separators,\n                           separators_len, ARES_BUF_SPLIT_TRIM, 0, &lookups);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  memset(lookupstr, 0, sizeof(lookupstr));\n\n  for (node = ares__llist_node_first(lookups); node != NULL;\n       node = ares__llist_node_next(node)) {\n    char         value[128];\n    char         ch;\n    ares__buf_t *valbuf = ares__llist_node_val(node);\n\n    status = buf_fetch_string(valbuf, value, sizeof(value));\n    if (status != ARES_SUCCESS) {\n      continue;\n    }\n\n    if (strcasecmp(value, \"dns\") == 0 || strcasecmp(value, \"bind\") == 0 ||\n        strcasecmp(value, \"resolv\") == 0 || strcasecmp(value, \"resolve\") == 0) {\n      ch = 'b';\n    } else if (strcasecmp(value, \"files\") == 0 ||\n               strcasecmp(value, \"file\") == 0 ||\n               strcasecmp(value, \"local\") == 0) {\n      ch = 'f';\n    } else {\n      continue;\n    }\n\n    /* Look for a duplicate and ignore */\n    if (memchr(lookupstr, ch, lookupstr_cnt) == NULL) {\n      lookupstr[lookupstr_cnt++] = ch;\n    }\n  }\n\n  if (lookupstr_cnt) {\n    ares_free(sysconfig->lookups);\n    sysconfig->lookups = ares_strdup(lookupstr);\n    if (sysconfig->lookups == NULL) {\n      return ARES_ENOMEM;\n    }\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  if (status != ARES_ENOMEM) {\n    status = ARES_SUCCESS;\n  }\n  ares__llist_destroy(lookups);\n  return status;\n}",
          "fn_code_pos": [
            [
              323,
              0
            ],
            [
              385,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "config_lookup",
            "parameters": {
              "sysconfig": "ares_sysconfig_t",
              "buf": "ares__buf_t",
              "separators": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t process_option(ares_sysconfig_t *sysconfig,\n                                    ares__buf_t      *option)\n{\n  ares__llist_t *kv      = NULL;\n  char           key[32] = \"\";\n  char           val[32] = \"\";\n  unsigned int   valint  = 0;\n  ares_status_t  status;\n\n  /* Split on : */\n  status = ares__buf_split(option, (const unsigned char *)\":\", 1,\n                           ARES_BUF_SPLIT_TRIM, 2, &kv);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = buf_fetch_string(ares__llist_first_val(kv), key, sizeof(key));\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n  if (ares__llist_len(kv) == 2) {\n    status = buf_fetch_string(ares__llist_last_val(kv), val, sizeof(val));\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n    valint = (unsigned int)strtoul(val, NULL, 10);\n  }\n\n  if (strcmp(key, \"ndots\") == 0) {\n    sysconfig->ndots = valint;\n  } else if (strcmp(key, \"retrans\") == 0 || strcmp(key, \"timeout\") == 0) {\n    if (valint == 0) {\n      return ARES_EFORMERR;\n    }\n    sysconfig->timeout_ms = valint * 1000;\n  } else if (strcmp(key, \"retry\") == 0 || strcmp(key, \"attempts\") == 0) {\n    if (valint == 0) {\n      return ARES_EFORMERR;\n    }\n    sysconfig->tries = valint;\n  } else if (strcmp(key, \"rotate\") == 0) {\n    sysconfig->rotate = ARES_TRUE;\n  } else if (strcmp(key, \"use-vc\") == 0 || strcmp(key, \"usevc\") == 0) {\n    sysconfig->usevc = ARES_TRUE;\n  }\n\ndone:\n  ares__llist_destroy(kv);\n  return status;\n}",
          "fn_code_pos": [
            [
              387,
              0
            ],
            [
              436,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_option",
            "parameters": {
              "sysconfig": "ares_sysconfig_t",
              "option": "ares__buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__sysconfig_set_options(ares_sysconfig_t *sysconfig,\n                                          const char       *str)\n{\n  ares__buf_t        *buf     = NULL;\n  ares__llist_t      *options = NULL;\n  ares_status_t       status;\n  ares__llist_node_t *node;\n\n  buf = ares__buf_create_const((const unsigned char *)str, ares_strlen(str));\n  if (buf == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  status = ares__buf_split(buf, (const unsigned char *)\" \\t\", 2,\n                           ARES_BUF_SPLIT_TRIM, 0, &options);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  for (node = ares__llist_node_first(options); node != NULL;\n       node = ares__llist_node_next(node)) {\n    ares__buf_t *valbuf = ares__llist_node_val(node);\n\n    status = process_option(sysconfig, valbuf);\n    /* Out of memory is the only fatal condition */\n    if (status == ARES_ENOMEM) {\n      goto done;\n    }\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  ares__llist_destroy(options);\n  ares__buf_destroy(buf);\n  return status;\n}",
          "fn_code_pos": [
            [
              438,
              0
            ],
            [
              474,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__sysconfig_set_options",
            "parameters": {
              "sysconfig": "ares_sysconfig_t",
              "str": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__init_by_environment(ares_sysconfig_t *sysconfig)\n{\n  const char   *localdomain;\n  const char   *res_options;\n  ares_status_t status;\n\n  localdomain = getenv(\"LOCALDOMAIN\");\n  if (localdomain) {\n    char *temp = ares_strdup(localdomain);\n    if (temp == NULL) {\n      return ARES_ENOMEM;\n    }\n    status = config_search(sysconfig, temp, 1);\n    ares_free(temp);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  res_options = getenv(\"RES_OPTIONS\");\n  if (res_options) {\n    status = ares__sysconfig_set_options(sysconfig, res_options);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              476,
              0
            ],
            [
              504,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_by_environment",
            "parameters": {
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t parse_resolvconf_line(ares_sysconfig_t *sysconfig,\n                                           ares__buf_t      *line)\n{\n  char          option[32];\n  char          value[512];\n  ares_status_t status = ARES_SUCCESS;\n\n  /* Ignore lines beginning with a comment */\n  if (ares__buf_begins_with(line, (const unsigned char *)\"#\", 1) ||\n      ares__buf_begins_with(line, (const unsigned char *)\";\", 1)) {\n    return ARES_SUCCESS;\n  }\n\n  ares__buf_tag(line);\n\n  /* Shouldn't be possible, but if it happens, ignore the line. */\n  if (ares__buf_consume_nonwhitespace(line) == 0) {\n    return ARES_SUCCESS;\n  }\n\n  status = ares__buf_tag_fetch_string(line, option, sizeof(option));\n  if (status != ARES_SUCCESS) {\n    return ARES_SUCCESS;\n  }\n\n  ares__buf_consume_whitespace(line, ARES_TRUE);\n\n  status = buf_fetch_string(line, value, sizeof(value));\n  if (status != ARES_SUCCESS) {\n    return ARES_SUCCESS;\n  }\n\n  ares__str_trim(value);\n  if (*value == 0) {\n    return ARES_SUCCESS;\n  }\n\n  /* At this point we have a string option and a string value, both trimmed\n   * of leading and trailing whitespace.  Lets try to evaluate them */\n  if (strcmp(option, \"domain\") == 0) {\n    /* Domain is legacy, don't overwrite an existing config set by search */\n    if (sysconfig->domains == NULL) {\n      status = config_search(sysconfig, value, 1);\n    }\n  } else if (strcmp(option, \"lookup\") == 0 ||\n             strcmp(option, \"hostresorder\") == 0) {\n    ares__buf_tag_rollback(line);\n    status = config_lookup(sysconfig, line, \" \\t\");\n  } else if (strcmp(option, \"search\") == 0) {\n    status = config_search(sysconfig, value, 0);\n  } else if (strcmp(option, \"nameserver\") == 0) {\n    status =\n      ares__sconfig_append_fromstr(&sysconfig->sconfig, value, ARES_TRUE);\n  } else if (strcmp(option, \"sortlist\") == 0) {\n    /* Ignore all failures except ENOMEM.  If the sysadmin set a bad\n     * sortlist, just ignore the sortlist, don't cause an inoperable\n     * channel */\n    status =\n      ares__parse_sortlist(&sysconfig->sortlist, &sysconfig->nsortlist, value);\n    if (status != ARES_ENOMEM) {\n      status = ARES_SUCCESS;\n    }\n  } else if (strcmp(option, \"options\") == 0) {\n    status = ares__sysconfig_set_options(sysconfig, value);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              557,
              0
            ],
            [
              624,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_resolvconf_line",
            "parameters": {
              "sysconfig": "ares_sysconfig_t",
              "line": "ares__buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t parse_nsswitch_line(ares_sysconfig_t *sysconfig,\n                                         ares__buf_t      *line)\n{\n  char           option[32];\n  ares__buf_t   *buf;\n  ares_status_t  status = ARES_SUCCESS;\n  ares__llist_t *sects  = NULL;\n\n  /* Ignore lines beginning with a comment */\n  if (ares__buf_begins_with(line, (const unsigned char *)\"#\", 1)) {\n    return ARES_SUCCESS;\n  }\n\n  /* database : values (space delimited) */\n  status = ares__buf_split(line, (const unsigned char *)\":\", 1,\n                           ARES_BUF_SPLIT_TRIM, 2, &sects);\n\n  if (status != ARES_SUCCESS || ares__llist_len(sects) != 2) {\n    goto done;\n  }\n\n  buf    = ares__llist_first_val(sects);\n  status = buf_fetch_string(buf, option, sizeof(option));\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Only support \"hosts:\" */\n  if (strcmp(option, \"hosts\") != 0) {\n    goto done;\n  }\n\n  /* Values are space separated */\n  buf    = ares__llist_last_val(sects);\n  status = config_lookup(sysconfig, buf, \" \\t\");\n\ndone:\n  ares__llist_destroy(sects);\n  if (status != ARES_ENOMEM) {\n    status = ARES_SUCCESS;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              629,
              0
            ],
            [
              671,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_nsswitch_line",
            "parameters": {
              "sysconfig": "ares_sysconfig_t",
              "line": "ares__buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t parse_svcconf_line(ares_sysconfig_t *sysconfig,\n                                        ares__buf_t      *line)\n{\n  char           option[32];\n  ares__buf_t   *buf;\n  ares_status_t  status = ARES_SUCCESS;\n  ares__llist_t *sects  = NULL;\n\n  /* Ignore lines beginning with a comment */\n  if (ares__buf_begins_with(line, (const unsigned char *)\"#\", 1)) {\n    return ARES_SUCCESS;\n  }\n\n  /* database = values (comma delimited)*/\n  status = ares__buf_split(line, (const unsigned char *)\"=\", 1,\n                           ARES_BUF_SPLIT_TRIM, 2, &sects);\n\n  if (status != ARES_SUCCESS || ares__llist_len(sects) != 2) {\n    goto done;\n  }\n\n  buf    = ares__llist_first_val(sects);\n  status = buf_fetch_string(buf, option, sizeof(option));\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* Only support \"hosts=\" */\n  if (strcmp(option, \"hosts\") != 0) {\n    goto done;\n  }\n\n  /* Values are comma separated */\n  buf    = ares__llist_last_val(sects);\n  status = config_lookup(sysconfig, buf, \",\");\n\ndone:\n  ares__llist_destroy(sects);\n  if (status != ARES_ENOMEM) {\n    status = ARES_SUCCESS;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              676,
              0
            ],
            [
              718,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_svcconf_line",
            "parameters": {
              "sysconfig": "ares_sysconfig_t",
              "line": "ares__buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t process_config_lines(const char       *filename,\n                                          ares_sysconfig_t *sysconfig,\n                                          line_callback_t   cb)\n{\n  ares_status_t       status = ARES_SUCCESS;\n  ares__llist_node_t *node;\n  ares__llist_t      *lines = NULL;\n  ares__buf_t        *buf   = NULL;\n\n  buf = ares__buf_create();\n  if (buf == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  status = ares__buf_load_file(filename, buf);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares__buf_split(buf, (const unsigned char *)\"\\n\", 1,\n                           ARES_BUF_SPLIT_TRIM, 0, &lines);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  for (node = ares__llist_node_first(lines); node != NULL;\n       node = ares__llist_node_next(node)) {\n    ares__buf_t *line = ares__llist_node_val(node);\n\n    status = cb(sysconfig, line);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\ndone:\n  ares__buf_destroy(buf);\n  ares__llist_destroy(lines);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              730,
              0
            ],
            [
              771,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_config_lines",
            "parameters": {
              "filename": "char",
              "sysconfig": "ares_sysconfig_t",
              "cb": "line_callback_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__init_sysconfig_files(const ares_channel_t *channel,\n                                         ares_sysconfig_t     *sysconfig)\n{\n  ares_status_t status = ARES_SUCCESS;\n\n  /* Resolv.conf */\n  status = process_config_lines((channel->resolvconf_path != NULL)\n                                  ? channel->resolvconf_path\n                                  : PATH_RESOLV_CONF,\n                                sysconfig, parse_resolvconf_line);\n  if (status != ARES_SUCCESS && status != ARES_ENOTFOUND) {\n    goto done;\n  }\n\n  /* Nsswitch.conf */\n  status =\n    process_config_lines(\"/etc/nsswitch.conf\", sysconfig, parse_nsswitch_line);\n  if (status != ARES_SUCCESS && status != ARES_ENOTFOUND) {\n    goto done;\n  }\n\n  /* netsvc.conf */\n  status =\n    process_config_lines(\"/etc/netsvc.conf\", sysconfig, parse_svcconf_line);\n  if (status != ARES_SUCCESS && status != ARES_ENOTFOUND) {\n    goto done;\n  }\n\n  /* svc.conf */\n  status = process_config_lines(\"/etc/svc.conf\", sysconfig, parse_svcconf_line);\n  if (status != ARES_SUCCESS && status != ARES_ENOTFOUND) {\n    goto done;\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  return status;\n}",
          "fn_code_pos": [
            [
              773,
              0
            ],
            [
              811,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_sysconfig_files",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*line_callback_t)(ares_sysconfig_t *sysconfig,\n                                         ares__buf_t      *line)",
          "fn_dec_pos": [
            [
              720,
              22
            ],
            [
              721,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "sysconfig": "ares_sysconfig_t",
              "line": "ares__buf_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_addr",
          {},
          "",
          [
            68,
            43
          ],
          [
            68,
            59
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            98,
            35
          ],
          [
            98,
            50
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            99,
            41
          ],
          [
            99,
            56
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            101,
            2
          ],
          [
            101,
            17
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            116,
            50
          ],
          [
            116,
            65
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            187,
            6
          ],
          [
            187,
            22
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            216,
            35
          ],
          [
            216,
            50
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            252,
            4
          ],
          [
            252,
            19
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <sys/param.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#  include <sys/system_properties.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#  include \"ares_android.h\"\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#  include <resolv.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#  include <iphlpapi.h>\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            64,
            0
          ],
          [
            65,
            0
          ]
        ],
        [
          "#include \"ares_platform.h\"\n",
          [
            65,
            0
          ],
          [
            66,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            66,
            0
          ],
          [
            67,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_getenv.c": {
      "fn_def_list": [
        {
          "fn_code": "char *ares_getenv(const char *name)\n{\n  return NULL;\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              35,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getenv",
            "parameters": {
              "name": "char"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_getenv(const char *name)",
          "fn_dec_pos": [
            [
              32,
              6
            ],
            [
              32,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getenv",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_getenv.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_gethostbyname.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares_gethostbyname_callback(void *arg, int status, int timeouts,\n                                        struct ares_addrinfo *result)\n{\n  struct hostent    *hostent  = NULL;\n  struct host_query *ghbn_arg = arg;\n\n  if (status == ARES_SUCCESS) {\n    status = (int)ares__addrinfo2hostent(result, AF_UNSPEC, &hostent);\n  }\n\n  /* addrinfo2hostent will only return ENODATA if there are no addresses _and_\n   * no cname/aliases.  However, gethostbyname will return ENODATA even if there\n   * is cname/alias data */\n  if (status == ARES_SUCCESS && hostent &&\n      (!hostent->h_addr_list || !hostent->h_addr_list[0])) {\n    status = ARES_ENODATA;\n  }\n\n  if (status == ARES_SUCCESS && ghbn_arg->channel->nsort && hostent) {\n    if (hostent->h_addrtype == AF_INET6) {\n      sort6_addresses(hostent, ghbn_arg->channel->sortlist,\n                      ghbn_arg->channel->nsort);\n    }\n    if (hostent->h_addrtype == AF_INET) {\n      sort_addresses(hostent, ghbn_arg->channel->sortlist,\n                     ghbn_arg->channel->nsort);\n    }\n  }\n\n  ghbn_arg->callback(ghbn_arg->arg, status, timeouts, hostent);\n\n  ares_freeaddrinfo(result);\n  ares_free(ghbn_arg);\n  ares_free_hostent(hostent);\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              99,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_gethostbyname_callback",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "result": "struct ares_addrinfo"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares_gethostbyname(ares_channel_t *channel, const char *name, int family,\n                        ares_host_callback callback, void *arg)\n{\n  const struct ares_addrinfo_hints hints = { ARES_AI_CANONNAME, family, 0, 0 };\n  struct host_query               *ghbn_arg;\n\n  if (!callback) {\n    return;\n  }\n\n  ghbn_arg = ares_malloc(sizeof(*ghbn_arg));\n  if (!ghbn_arg) {\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    return;\n  }\n\n  ghbn_arg->callback = callback;\n  ghbn_arg->arg      = arg;\n  ghbn_arg->channel  = channel;\n\n  /* NOTE: ares_getaddrinfo() locks the channel, we don't use the channel\n   *       outside so no need to lock */\n  ares_getaddrinfo(channel, name, NULL, &hints, ares_gethostbyname_callback,\n                   ghbn_arg);\n}",
          "fn_code_pos": [
            [
              101,
              0
            ],
            [
              125,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_gethostbyname",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "family": "int",
              "callback": "ares_host_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void sort_addresses(const struct hostent  *host,\n                           const struct apattern *sortlist, size_t nsort)\n{\n  struct in_addr a1;\n  struct in_addr a2;\n  int            i1;\n  int            i2;\n  size_t         ind1;\n  size_t         ind2;\n\n  /* This is a simple insertion sort, not optimized at all.  i1 walks\n   * through the address list, with the loop invariant that everything\n   * to the left of i1 is sorted.  In the loop body, the value at i1 is moved\n   * back through the list (via i2) until it is in sorted order.\n   */\n  for (i1 = 0; host->h_addr_list[i1]; i1++) {\n    memcpy(&a1, host->h_addr_list[i1], sizeof(struct in_addr));\n    ind1 = get_address_index(&a1, sortlist, nsort);\n    for (i2 = i1 - 1; i2 >= 0; i2--) {\n      memcpy(&a2, host->h_addr_list[i2], sizeof(struct in_addr));\n      ind2 = get_address_index(&a2, sortlist, nsort);\n      if (ind2 <= ind1) {\n        break;\n      }\n      memcpy(host->h_addr_list[i2 + 1], &a2, sizeof(struct in_addr));\n    }\n    memcpy(host->h_addr_list[i2 + 1], &a1, sizeof(struct in_addr));\n  }\n}",
          "fn_code_pos": [
            [
              127,
              0
            ],
            [
              155,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sort_addresses",
            "parameters": {
              "host": "struct hostent",
              "sortlist": "struct apattern",
              "nsort": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static size_t get_address_index(const struct in_addr  *addr,\n                                const struct apattern *sortlist, size_t nsort)\n{\n  size_t           i;\n  struct ares_addr aaddr;\n\n  memset(&aaddr, 0, sizeof(aaddr));\n  aaddr.family = AF_INET;\n  memcpy(&aaddr.addr.addr4, addr, 4);\n\n  for (i = 0; i < nsort; i++) {\n    if (sortlist[i].addr.family != AF_INET) {\n      continue;\n    }\n\n    if (ares__subnet_match(&aaddr, &sortlist[i].addr, sortlist[i].mask)) {\n      break;\n    }\n  }\n\n  return i;\n}",
          "fn_code_pos": [
            [
              160,
              0
            ],
            [
              181,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_address_index",
            "parameters": {
              "addr": "struct in_addr",
              "sortlist": "struct apattern",
              "nsort": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static void sort6_addresses(const struct hostent  *host,\n                            const struct apattern *sortlist, size_t nsort)\n{\n  struct ares_in6_addr a1;\n  struct ares_in6_addr a2;\n  int                  i1;\n  int                  i2;\n  size_t               ind1;\n  size_t               ind2;\n\n  /* This is a simple insertion sort, not optimized at all.  i1 walks\n   * through the address list, with the loop invariant that everything\n   * to the left of i1 is sorted.  In the loop body, the value at i1 is moved\n   * back through the list (via i2) until it is in sorted order.\n   */\n  for (i1 = 0; host->h_addr_list[i1]; i1++) {\n    memcpy(&a1, host->h_addr_list[i1], sizeof(struct ares_in6_addr));\n    ind1 = get6_address_index(&a1, sortlist, nsort);\n    for (i2 = i1 - 1; i2 >= 0; i2--) {\n      memcpy(&a2, host->h_addr_list[i2], sizeof(struct ares_in6_addr));\n      ind2 = get6_address_index(&a2, sortlist, nsort);\n      if (ind2 <= ind1) {\n        break;\n      }\n      memcpy(host->h_addr_list[i2 + 1], &a2, sizeof(struct ares_in6_addr));\n    }\n    memcpy(host->h_addr_list[i2 + 1], &a1, sizeof(struct ares_in6_addr));\n  }\n}",
          "fn_code_pos": [
            [
              183,
              0
            ],
            [
              211,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sort6_addresses",
            "parameters": {
              "host": "struct hostent",
              "sortlist": "struct apattern",
              "nsort": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static size_t get6_address_index(const struct ares_in6_addr *addr,\n                                 const struct apattern *sortlist, size_t nsort)\n{\n  size_t           i;\n  struct ares_addr aaddr;\n\n  memset(&aaddr, 0, sizeof(aaddr));\n  aaddr.family = AF_INET6;\n  memcpy(&aaddr.addr.addr6, addr, 16);\n\n  for (i = 0; i < nsort; i++) {\n    if (sortlist[i].addr.family != AF_INET6) {\n      continue;\n    }\n\n    if (ares__subnet_match(&aaddr, &sortlist[i].addr, sortlist[i].mask)) {\n      break;\n    }\n  }\n  return i;\n}",
          "fn_code_pos": [
            [
              216,
              0
            ],
            [
              236,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get6_address_index",
            "parameters": {
              "addr": "struct ares_in6_addr",
              "sortlist": "struct apattern",
              "nsort": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__hostent_localhost(const char *name, int family,\n                                             struct hostent **host_out)\n{\n  ares_status_t              status;\n  struct ares_addrinfo      *ai = NULL;\n  struct ares_addrinfo_hints hints;\n\n  memset(&hints, 0, sizeof(hints));\n  hints.ai_family = family;\n\n  ai = ares_malloc_zero(sizeof(*ai));\n  if (ai == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  status = ares__addrinfo_localhost(name, 0, &hints, ai);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares__addrinfo2hostent(ai, family, host_out);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\ndone:\n  ares_freeaddrinfo(ai);\n  return status;\n}",
          "fn_code_pos": [
            [
              238,
              0
            ],
            [
              267,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hostent_localhost",
            "parameters": {
              "name": "char",
              "family": "int",
              "host_out": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_gethostbyname_file_int(ares_channel_t *channel,\n                                                 const char *name, int family,\n                                                 struct hostent **host)\n{\n  const ares_hosts_entry_t *entry;\n  ares_status_t             status;\n\n  /* We only take the channel to ensure that ares_init() been called. */\n  if (channel == NULL || name == NULL || host == NULL) {\n    /* Anything will do, really.  This seems fine, and is consistent with\n       other error cases. */\n    if (host != NULL) {\n      *host = NULL;\n    }\n    return ARES_ENOTFOUND;\n  }\n\n  /* Per RFC 7686, reject queries for \".onion\" domain names with NXDOMAIN. */\n  if (ares__is_onion_domain(name)) {\n    return ARES_ENOTFOUND;\n  }\n\n  status = ares__hosts_search_host(channel, ARES_FALSE, name, &entry);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares__hosts_entry_to_hostent(entry, family, host);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\ndone:\n  /* RFC6761 section 6.3 #3 states that \"Name resolution APIs and libraries\n   * SHOULD recognize localhost names as special and SHOULD always return the\n   * IP loopback address for address queries\".\n   * We will also ignore ALL errors when trying to resolve localhost, such\n   * as permissions errors reading /etc/hosts or a malformed /etc/hosts */\n  if (status != ARES_SUCCESS && status != ARES_ENOMEM &&\n      ares__is_localhost(name)) {\n    return ares__hostent_localhost(name, family, host);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              271,
              0
            ],
            [
              315,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_gethostbyname_file_int",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "family": "int",
              "host": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "int ares_gethostbyname_file(ares_channel_t *channel, const char *name,\n                            int family, struct hostent **host)\n{\n  ares_status_t status;\n  if (channel == NULL) {\n    return ARES_ENOTFOUND;\n  }\n\n  ares__channel_lock(channel);\n  status = ares_gethostbyname_file_int(channel, name, family, host);\n  ares__channel_unlock(channel);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              317,
              0
            ],
            [
              329,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_gethostbyname_file",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "family": "int",
              "host": "struct hostent"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "sort_addresses(const struct hostent  *host,\n                             const struct apattern *sortlist, size_t nsort)",
          "fn_dec_pos": [
            [
              50,
              14
            ],
            [
              51,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sort_addresses",
            "parameters": {
              "host": "struct hostent",
              "sortlist": "struct apattern",
              "nsort": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "sort6_addresses(const struct hostent  *host,\n                              const struct apattern *sortlist, size_t nsort)",
          "fn_dec_pos": [
            [
              52,
              14
            ],
            [
              53,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sort6_addresses",
            "parameters": {
              "host": "struct hostent",
              "sortlist": "struct apattern",
              "nsort": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "get_address_index(const struct in_addr  *addr,\n                                const struct apattern *sortlist, size_t nsort)",
          "fn_dec_pos": [
            [
              54,
              14
            ],
            [
              55,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_address_index",
            "parameters": {
              "addr": "struct in_addr",
              "sortlist": "struct apattern",
              "nsort": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "get6_address_index(const struct ares_in6_addr *addr,\n                                 const struct apattern *sortlist, size_t nsort)",
          "fn_dec_pos": [
            [
              56,
              14
            ],
            [
              57,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get6_address_index",
            "parameters": {
              "addr": "struct ares_in6_addr",
              "sortlist": "struct apattern",
              "nsort": "size_t"
            },
            "return_type": "size_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct host_query {\n  ares_host_callback callback;\n  void              *arg;\n  ares_channel_t    *channel;\n}",
          {
            "callback": "ares_host_callback",
            "*arg": "void",
            "*channel": "ares_channel_t"
          },
          "host_query",
          [
            59,
            0
          ],
          [
            63,
            1
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            50,
            35
          ],
          [
            50,
            49
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            51,
            35
          ],
          [
            51,
            50
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            52,
            36
          ],
          [
            52,
            50
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            53,
            36
          ],
          [
            53,
            51
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            54,
            38
          ],
          [
            54,
            52
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            55,
            38
          ],
          [
            55,
            53
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            56,
            39
          ],
          [
            56,
            59
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            57,
            39
          ],
          [
            57,
            54
          ]
        ],
        [
          "struct host_query {\n  ares_host_callback callback;\n  void              *arg;\n  ares_channel_t    *channel;\n}",
          {
            "callback": "ares_host_callback",
            "*arg": "void",
            "*channel": "ares_channel_t"
          },
          "host_query",
          [
            59,
            0
          ],
          [
            63,
            1
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            66,
            40
          ],
          [
            66,
            60
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            68,
            2
          ],
          [
            68,
            16
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            69,
            2
          ],
          [
            69,
            19
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            104,
            8
          ],
          [
            104,
            34
          ]
        ],
        [
          "struct host_query",
          {},
          "",
          [
            105,
            2
          ],
          [
            105,
            19
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            127,
            33
          ],
          [
            127,
            47
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            128,
            33
          ],
          [
            128,
            48
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            130,
            2
          ],
          [
            130,
            16
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            131,
            2
          ],
          [
            131,
            16
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            143,
            46
          ],
          [
            143,
            60
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            146,
            48
          ],
          [
            146,
            62
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            151,
            52
          ],
          [
            151,
            66
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            153,
            50
          ],
          [
            153,
            64
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            160,
            38
          ],
          [
            160,
            52
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            161,
            38
          ],
          [
            161,
            53
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            164,
            2
          ],
          [
            164,
            18
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            183,
            34
          ],
          [
            183,
            48
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            184,
            34
          ],
          [
            184,
            49
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            186,
            2
          ],
          [
            186,
            22
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            187,
            2
          ],
          [
            187,
            22
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            199,
            46
          ],
          [
            199,
            66
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            202,
            48
          ],
          [
            202,
            68
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            207,
            52
          ],
          [
            207,
            72
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            209,
            50
          ],
          [
            209,
            70
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            216,
            39
          ],
          [
            216,
            59
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            217,
            39
          ],
          [
            217,
            54
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            220,
            2
          ],
          [
            220,
            18
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            239,
            45
          ],
          [
            239,
            59
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            242,
            2
          ],
          [
            242,
            22
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            243,
            2
          ],
          [
            243,
            28
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            273,
            49
          ],
          [
            273,
            63
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            318,
            40
          ],
          [
            318,
            54
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include \"ares_platform.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__llist.c": {
      "fn_def_list": [
        {
          "fn_code": "ares__llist_t *ares__llist_create(ares__llist_destructor_t destruct)\n{\n  ares__llist_t *list = ares_malloc_zero(sizeof(*list));\n\n  if (list == NULL) {\n    return NULL;\n  }\n\n  list->destruct = destruct;\n\n  return list;\n}",
          "fn_code_pos": [
            [
              44,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_create",
            "parameters": {
              "destruct": "ares__llist_destructor_t"
            },
            "return_type": "ares__llist_t"
          }
        },
        {
          "fn_code": "void ares__llist_replace_destructor(ares__llist_t           *list,\n                                    ares__llist_destructor_t destruct)\n{\n  if (list == NULL) {\n    return;\n  }\n\n  list->destruct = destruct;\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_replace_destructor",
            "parameters": {
              "list": "ares__llist_t",
              "destruct": "ares__llist_destructor_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares__llist_attach_at(ares__llist_t            *list,\n                                  ares__llist_insert_type_t type,\n                                  ares__llist_node_t       *at,\n                                  ares__llist_node_t       *node)\n{\n  if (list == NULL || node == NULL) {\n    return;\n  }\n\n  node->parent = list;\n\n  if (type == ARES__LLIST_INSERT_BEFORE && (at == list->head || at == NULL)) {\n    type = ARES__LLIST_INSERT_HEAD;\n  }\n\n  switch (type) {\n    case ARES__LLIST_INSERT_HEAD:\n      node->next = list->head;\n      node->prev = NULL;\n      if (list->head) {\n        list->head->prev = node;\n      }\n      list->head = node;\n      break;\n    case ARES__LLIST_INSERT_TAIL:\n      node->next = NULL;\n      node->prev = list->tail;\n      if (list->tail) {\n        list->tail->next = node;\n      }\n      list->tail = node;\n      break;\n    case ARES__LLIST_INSERT_BEFORE:\n      node->next = at;\n      node->prev = at->prev;\n      at->prev   = node;\n      break;\n  }\n  if (list->tail == NULL) {\n    list->tail = node;\n  }\n  if (list->head == NULL) {\n    list->head = node;\n  }\n\n  list->cnt++;\n}",
          "fn_code_pos": [
            [
              73,
              0
            ],
            [
              119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_attach_at",
            "parameters": {
              "list": "ares__llist_t",
              "type": "ares__llist_insert_type_t",
              "at": "ares__llist_node_t",
              "node": "ares__llist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares__llist_node_t *ares__llist_insert_at(ares__llist_t            *list,\n                                                 ares__llist_insert_type_t type,\n                                                 ares__llist_node_t       *at,\n                                                 void                     *val)\n{\n  ares__llist_node_t *node = NULL;\n\n  if (list == NULL || val == NULL) {\n    return NULL;\n  }\n\n  node = ares_malloc_zero(sizeof(*node));\n\n  if (node == NULL) {\n    return NULL;\n  }\n\n  node->data = val;\n  ares__llist_attach_at(list, type, at, node);\n\n  return node;\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              142,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_insert_at",
            "parameters": {
              "list": "ares__llist_t",
              "type": "ares__llist_insert_type_t",
              "at": "ares__llist_node_t",
              "val": "void"
            },
            "return_type": "ares__llist_node_t"
          }
        },
        {
          "fn_code": "ares__llist_node_t *ares__llist_insert_first(ares__llist_t *list, void *val)\n{\n  return ares__llist_insert_at(list, ARES__LLIST_INSERT_HEAD, NULL, val);\n}",
          "fn_code_pos": [
            [
              144,
              0
            ],
            [
              147,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_insert_first",
            "parameters": {
              "list": "ares__llist_t",
              "val": "void"
            },
            "return_type": "ares__llist_node_t"
          }
        },
        {
          "fn_code": "ares__llist_node_t *ares__llist_insert_last(ares__llist_t *list, void *val)\n{\n  return ares__llist_insert_at(list, ARES__LLIST_INSERT_TAIL, NULL, val);\n}",
          "fn_code_pos": [
            [
              149,
              0
            ],
            [
              152,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_insert_last",
            "parameters": {
              "list": "ares__llist_t",
              "val": "void"
            },
            "return_type": "ares__llist_node_t"
          }
        },
        {
          "fn_code": "ares__llist_node_t *ares__llist_insert_before(ares__llist_node_t *node,\n                                              void               *val)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n\n  return ares__llist_insert_at(node->parent, ARES__LLIST_INSERT_BEFORE, node,\n                               val);\n}",
          "fn_code_pos": [
            [
              154,
              0
            ],
            [
              163,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_insert_before",
            "parameters": {
              "node": "ares__llist_node_t",
              "val": "void"
            },
            "return_type": "ares__llist_node_t"
          }
        },
        {
          "fn_code": "ares__llist_node_t *ares__llist_insert_after(ares__llist_node_t *node,\n                                             void               *val)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n\n  if (node->next == NULL) {\n    return ares__llist_insert_last(node->parent, val);\n  }\n\n  return ares__llist_insert_at(node->parent, ARES__LLIST_INSERT_BEFORE,\n                               node->next, val);\n}",
          "fn_code_pos": [
            [
              165,
              0
            ],
            [
              178,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_insert_after",
            "parameters": {
              "node": "ares__llist_node_t",
              "val": "void"
            },
            "return_type": "ares__llist_node_t"
          }
        },
        {
          "fn_code": "ares__llist_node_t *ares__llist_node_first(ares__llist_t *list)\n{\n  if (list == NULL) {\n    return NULL;\n  }\n  return list->head;\n}",
          "fn_code_pos": [
            [
              180,
              0
            ],
            [
              186,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_first",
            "parameters": {
              "list": "ares__llist_t"
            },
            "return_type": "ares__llist_node_t"
          }
        },
        {
          "fn_code": "ares__llist_node_t *ares__llist_node_last(ares__llist_t *list)\n{\n  if (list == NULL) {\n    return NULL;\n  }\n  return list->tail;\n}",
          "fn_code_pos": [
            [
              188,
              0
            ],
            [
              194,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_last",
            "parameters": {
              "list": "ares__llist_t"
            },
            "return_type": "ares__llist_node_t"
          }
        },
        {
          "fn_code": "ares__llist_node_t *ares__llist_node_next(ares__llist_node_t *node)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n  return node->next;\n}",
          "fn_code_pos": [
            [
              196,
              0
            ],
            [
              202,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_next",
            "parameters": {
              "node": "ares__llist_node_t"
            },
            "return_type": "ares__llist_node_t"
          }
        },
        {
          "fn_code": "ares__llist_node_t *ares__llist_node_prev(ares__llist_node_t *node)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n  return node->prev;\n}",
          "fn_code_pos": [
            [
              204,
              0
            ],
            [
              210,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_prev",
            "parameters": {
              "node": "ares__llist_node_t"
            },
            "return_type": "ares__llist_node_t"
          }
        },
        {
          "fn_code": "void *ares__llist_node_val(ares__llist_node_t *node)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n\n  return node->data;\n}",
          "fn_code_pos": [
            [
              212,
              0
            ],
            [
              219,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_val",
            "parameters": {
              "node": "ares__llist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "size_t ares__llist_len(const ares__llist_t *list)\n{\n  if (list == NULL) {\n    return 0;\n  }\n  return list->cnt;\n}",
          "fn_code_pos": [
            [
              221,
              0
            ],
            [
              227,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_len",
            "parameters": {
              "list": "ares__llist_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares__llist_t *ares__llist_node_parent(ares__llist_node_t *node)\n{\n  if (node == NULL) {\n    return NULL;\n  }\n  return node->parent;\n}",
          "fn_code_pos": [
            [
              229,
              0
            ],
            [
              235,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_parent",
            "parameters": {
              "node": "ares__llist_node_t"
            },
            "return_type": "ares__llist_t"
          }
        },
        {
          "fn_code": "void *ares__llist_first_val(ares__llist_t *list)\n{\n  return ares__llist_node_val(ares__llist_node_first(list));\n}",
          "fn_code_pos": [
            [
              237,
              0
            ],
            [
              240,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_first_val",
            "parameters": {
              "list": "ares__llist_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void *ares__llist_last_val(ares__llist_t *list)\n{\n  return ares__llist_node_val(ares__llist_node_last(list));\n}",
          "fn_code_pos": [
            [
              242,
              0
            ],
            [
              245,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_last_val",
            "parameters": {
              "list": "ares__llist_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares__llist_node_detach(ares__llist_node_t *node)\n{\n  ares__llist_t *list;\n\n  if (node == NULL) {\n    return;\n  }\n\n  list = node->parent;\n\n  if (node->prev) {\n    node->prev->next = node->next;\n  }\n\n  if (node->next) {\n    node->next->prev = node->prev;\n  }\n\n  if (node == list->head) {\n    list->head = node->next;\n  }\n\n  if (node == list->tail) {\n    list->tail = node->prev;\n  }\n\n  node->parent = NULL;\n  list->cnt--;\n}",
          "fn_code_pos": [
            [
              247,
              0
            ],
            [
              275,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_detach",
            "parameters": {
              "node": "ares__llist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void *ares__llist_node_claim(ares__llist_node_t *node)\n{\n  void *val;\n\n  if (node == NULL) {\n    return NULL;\n  }\n\n  val = node->data;\n  ares__llist_node_detach(node);\n  ares_free(node);\n\n  return val;\n}",
          "fn_code_pos": [
            [
              277,
              0
            ],
            [
              290,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_claim",
            "parameters": {
              "node": "ares__llist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__llist_node_destroy(ares__llist_node_t *node)\n{\n  ares__llist_destructor_t destruct;\n  void                    *val;\n\n  if (node == NULL) {\n    return;\n  }\n\n  destruct = node->parent->destruct;\n\n  val = ares__llist_node_claim(node);\n  if (val != NULL && destruct != NULL) {\n    destruct(val);\n  }\n}",
          "fn_code_pos": [
            [
              292,
              0
            ],
            [
              307,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_destroy",
            "parameters": {
              "node": "ares__llist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__llist_node_replace(ares__llist_node_t *node, void *val)\n{\n  ares__llist_destructor_t destruct;\n\n  if (node == NULL) {\n    return;\n  }\n\n  destruct = node->parent->destruct;\n  if (destruct != NULL) {\n    destruct(node->data);\n  }\n\n  node->data = val;\n}",
          "fn_code_pos": [
            [
              309,
              0
            ],
            [
              323,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_replace",
            "parameters": {
              "node": "ares__llist_node_t",
              "val": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__llist_destroy(ares__llist_t *list)\n{\n  ares__llist_node_t *node;\n\n  if (list == NULL) {\n    return;\n  }\n\n  while ((node = ares__llist_node_first(list)) != NULL) {\n    ares__llist_node_destroy(node);\n  }\n  ares_free(list);\n}",
          "fn_code_pos": [
            [
              325,
              0
            ],
            [
              337,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_destroy",
            "parameters": {
              "list": "ares__llist_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__llist_node_move_parent_last(ares__llist_node_t *node,\n                                       ares__llist_t      *new_parent)\n{\n  if (node == NULL || new_parent == NULL) {\n    return;\n  }\n\n  ares__llist_node_detach(node);\n  ares__llist_attach_at(new_parent, ARES__LLIST_INSERT_TAIL, NULL, node);\n}",
          "fn_code_pos": [
            [
              339,
              0
            ],
            [
              348,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_move_parent_last",
            "parameters": {
              "node": "ares__llist_node_t",
              "new_parent": "ares__llist_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__llist_node_move_parent_first(ares__llist_node_t *node,\n                                        ares__llist_t      *new_parent)\n{\n  if (node == NULL || new_parent == NULL) {\n    return;\n  }\n\n  ares__llist_node_detach(node);\n  ares__llist_attach_at(new_parent, ARES__LLIST_INSERT_HEAD, NULL, node);\n}",
          "fn_code_pos": [
            [
              350,
              0
            ],
            [
              359,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_move_parent_first",
            "parameters": {
              "node": "ares__llist_node_t",
              "new_parent": "ares__llist_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares__llist_create(ares__llist_destructor_t destruct)",
          "fn_dec_pos": [
            [
              44,
              15
            ],
            [
              44,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_create",
            "parameters": {
              "destruct": "ares__llist_destructor_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_insert_at(ares__llist_t            *list,\n                                                 ares__llist_insert_type_t type,\n                                                 ares__llist_node_t       *at,\n                                                 void                     *val)",
          "fn_dec_pos": [
            [
              121,
              27
            ],
            [
              124,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_insert_at",
            "parameters": {
              "list": "ares__llist_t",
              "type": "ares__llist_insert_type_t",
              "at": "ares__llist_node_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_insert_first(ares__llist_t *list, void *val)",
          "fn_dec_pos": [
            [
              144,
              20
            ],
            [
              144,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_insert_first",
            "parameters": {
              "list": "ares__llist_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_insert_last(ares__llist_t *list, void *val)",
          "fn_dec_pos": [
            [
              149,
              20
            ],
            [
              149,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_insert_last",
            "parameters": {
              "list": "ares__llist_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_insert_before(ares__llist_node_t *node,\n                                              void               *val)",
          "fn_dec_pos": [
            [
              154,
              20
            ],
            [
              155,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_insert_before",
            "parameters": {
              "node": "ares__llist_node_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_insert_after(ares__llist_node_t *node,\n                                             void               *val)",
          "fn_dec_pos": [
            [
              165,
              20
            ],
            [
              166,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_insert_after",
            "parameters": {
              "node": "ares__llist_node_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_node_first(ares__llist_t *list)",
          "fn_dec_pos": [
            [
              180,
              20
            ],
            [
              180,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_first",
            "parameters": {
              "list": "ares__llist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_node_last(ares__llist_t *list)",
          "fn_dec_pos": [
            [
              188,
              20
            ],
            [
              188,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_last",
            "parameters": {
              "list": "ares__llist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_node_next(ares__llist_node_t *node)",
          "fn_dec_pos": [
            [
              196,
              20
            ],
            [
              196,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_next",
            "parameters": {
              "node": "ares__llist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_node_prev(ares__llist_node_t *node)",
          "fn_dec_pos": [
            [
              204,
              20
            ],
            [
              204,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_prev",
            "parameters": {
              "node": "ares__llist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_node_val(ares__llist_node_t *node)",
          "fn_dec_pos": [
            [
              212,
              6
            ],
            [
              212,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_val",
            "parameters": {
              "node": "ares__llist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_node_parent(ares__llist_node_t *node)",
          "fn_dec_pos": [
            [
              229,
              15
            ],
            [
              229,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_parent",
            "parameters": {
              "node": "ares__llist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_first_val(ares__llist_t *list)",
          "fn_dec_pos": [
            [
              237,
              6
            ],
            [
              237,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_first_val",
            "parameters": {
              "list": "ares__llist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_last_val(ares__llist_t *list)",
          "fn_dec_pos": [
            [
              242,
              6
            ],
            [
              242,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_last_val",
            "parameters": {
              "list": "ares__llist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_node_claim(ares__llist_node_t *node)",
          "fn_dec_pos": [
            [
              277,
              6
            ],
            [
              277,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_claim",
            "parameters": {
              "node": "ares__llist_node_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares__llist {\n  ares__llist_node_t      *head;\n  ares__llist_node_t      *tail;\n  ares__llist_destructor_t destruct;\n  size_t                   cnt;\n}",
          {
            "*head": "ares__llist_node_t",
            "*tail": "ares__llist_node_t",
            "destruct": "ares__llist_destructor_t",
            "cnt": "size_t"
          },
          "ares__llist",
          [
            30,
            0
          ],
          [
            35,
            1
          ]
        ],
        [
          "struct ares__llist_node {\n  void               *data;\n  ares__llist_node_t *prev;\n  ares__llist_node_t *next;\n  ares__llist_t      *parent;\n}",
          {
            "*data": "void",
            "*prev": "ares__llist_node_t",
            "*next": "ares__llist_node_t",
            "*parent": "ares__llist_t"
          },
          "ares__llist_node",
          [
            37,
            0
          ],
          [
            42,
            1
          ]
        ],
        [
          "struct ares__llist {\n  ares__llist_node_t      *head;\n  ares__llist_node_t      *tail;\n  ares__llist_destructor_t destruct;\n  size_t                   cnt;\n}",
          {
            "*head": "ares__llist_node_t",
            "*tail": "ares__llist_node_t",
            "destruct": "ares__llist_destructor_t",
            "cnt": "size_t"
          },
          "ares__llist",
          [
            30,
            0
          ],
          [
            35,
            1
          ]
        ],
        [
          "struct ares__llist_node {\n  void               *data;\n  ares__llist_node_t *prev;\n  ares__llist_node_t *next;\n  ares__llist_t      *parent;\n}",
          {
            "*data": "void",
            "*prev": "ares__llist_node_t",
            "*next": "ares__llist_node_t",
            "*parent": "ares__llist_t"
          },
          "ares__llist_node",
          [
            37,
            0
          ],
          [
            42,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares__llist.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  ARES__LLIST_INSERT_HEAD,\n  ARES__LLIST_INSERT_TAIL,\n  ARES__LLIST_INSERT_BEFORE\n} ares__llist_insert_type_t;",
          {
            "ARES__LLIST_INSERT_HEAD": "",
            "ARES__LLIST_INSERT_TAIL": "",
            "ARES__LLIST_INSERT_BEFORE": ""
          },
          "ares__llist_insert_type_t",
          [
            67,
            0
          ],
          [
            71,
            28
          ]
        ]
      ]
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_event_poll.c": {
      "fn_def_list": [
        {
          "fn_code": "static ares_bool_t ares_evsys_poll_init(ares_event_thread_t *e)\n{\n  e->ev_signal = ares_pipeevent_create(e);\n  if (e->ev_signal == NULL) {\n    return ARES_FALSE;\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              35,
              0
            ],
            [
              42,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_poll_init",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_poll_destroy(ares_event_thread_t *e)\n{\n  (void)e;\n}",
          "fn_code_pos": [
            [
              44,
              0
            ],
            [
              47,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_poll_destroy",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_evsys_poll_event_add(ares_event_t *event)\n{\n  (void)event;\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              49,
              0
            ],
            [
              53,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_poll_event_add",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares_evsys_poll_event_del(ares_event_t *event)\n{\n  (void)event;\n}",
          "fn_code_pos": [
            [
              55,
              0
            ],
            [
              58,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_poll_event_del",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_evsys_poll_event_mod(ares_event_t      *event,\n                                      ares_event_flags_t new_flags)\n{\n  (void)event;\n  (void)new_flags;\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_poll_event_mod",
            "parameters": {
              "event": "ares_event_t",
              "new_flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static size_t ares_evsys_poll_wait(ares_event_thread_t *e,\n                                   unsigned long        timeout_ms)\n{\n  size_t         num_fds = 0;\n  ares_socket_t *fdlist  = ares__htable_asvp_keys(e->ev_handles, &num_fds);\n  struct pollfd *pollfd  = NULL;\n  int            rv;\n  size_t         cnt = 0;\n  size_t         i;\n\n  if (fdlist != NULL && num_fds) {\n    pollfd = ares_malloc_zero(sizeof(*pollfd) * num_fds);\n    if (pollfd == NULL) {\n      goto done;\n    }\n    for (i = 0; i < num_fds; i++) {\n      const ares_event_t *ev =\n        ares__htable_asvp_get_direct(e->ev_handles, fdlist[i]);\n      pollfd[i].fd = ev->fd;\n      if (ev->flags & ARES_EVENT_FLAG_READ) {\n        pollfd[i].events |= POLLIN;\n      }\n      if (ev->flags & ARES_EVENT_FLAG_WRITE) {\n        pollfd[i].events |= POLLOUT;\n      }\n    }\n  }\n  ares_free(fdlist);\n\n  rv = poll(pollfd, (nfds_t)num_fds, (timeout_ms == 0) ? -1 : (int)timeout_ms);\n  if (rv <= 0) {\n    goto done;\n  }\n\n  for (i = 0; pollfd != NULL && i < num_fds; i++) {\n    ares_event_t      *ev;\n    ares_event_flags_t flags = 0;\n\n    if (pollfd[i].revents == 0) {\n      continue;\n    }\n\n    cnt++;\n\n    ev = ares__htable_asvp_get_direct(e->ev_handles, pollfd[i].fd);\n    if (ev == NULL || ev->cb == NULL) {\n      continue;\n    }\n\n    if (pollfd[i].revents & (POLLERR | POLLHUP | POLLIN)) {\n      flags |= ARES_EVENT_FLAG_READ;\n    }\n\n    if (pollfd[i].revents & POLLOUT) {\n      flags |= ARES_EVENT_FLAG_WRITE;\n    }\n\n    ev->cb(e, pollfd[i].fd, ev->data, flags);\n  }\n\ndone:\n  ares_free(pollfd);\n  return cnt;\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_evsys_poll_wait",
            "parameters": {
              "e": "ares_event_thread_t",
              "timeout_ms": "unsigned long"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pollfd",
          {},
          "",
          [
            72,
            2
          ],
          [
            72,
            15
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_event.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <poll.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_destroy.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_destroy(ares_channel_t *channel)\n{\n  size_t              i;\n  ares__llist_node_t *node = NULL;\n\n  if (channel == NULL) {\n    return;\n  }\n\n  /* Lock because callbacks will be triggered */\n  ares__channel_lock(channel);\n\n  /* Destroy all queries */\n  node = ares__llist_node_first(channel->all_queries);\n  while (node != NULL) {\n    ares__llist_node_t *next  = ares__llist_node_next(node);\n    struct query       *query = ares__llist_node_claim(node);\n\n    query->node_all_queries = NULL;\n    query->callback(query->arg, ARES_EDESTRUCTION, 0, NULL);\n    ares__free_query(query);\n\n    node = next;\n  }\n\n  ares_queue_notify_empty(channel);\n\n#ifndef NDEBUG\n  /* Freeing the query should remove it from all the lists in which it sits,\n   * so all query lists should be empty now.\n   */\n  assert(ares__llist_len(channel->all_queries) == 0);\n  assert(ares__htable_szvp_num_keys(channel->queries_by_qid) == 0);\n  assert(ares__slist_len(channel->queries_by_timeout) == 0);\n#endif\n\n  ares__destroy_servers_state(channel);\n\n#ifndef NDEBUG\n  assert(ares__htable_asvp_num_keys(channel->connnode_by_socket) == 0);\n#endif\n\n  /* No more callbacks will be triggered after this point, unlock */\n  ares__channel_unlock(channel);\n\n  /* Shut down the event thread */\n  if (channel->optmask & ARES_OPT_EVENT_THREAD) {\n    ares_event_thread_destroy(channel);\n  }\n\n  if (channel->domains) {\n    for (i = 0; i < channel->ndomains; i++) {\n      ares_free(channel->domains[i]);\n    }\n    ares_free(channel->domains);\n  }\n\n  ares__llist_destroy(channel->all_queries);\n  ares__slist_destroy(channel->queries_by_timeout);\n  ares__htable_szvp_destroy(channel->queries_by_qid);\n  ares__htable_asvp_destroy(channel->connnode_by_socket);\n\n  ares_free(channel->sortlist);\n  ares_free(channel->lookups);\n  ares_free(channel->resolvconf_path);\n  ares_free(channel->hosts_path);\n  ares__destroy_rand_state(channel->rand_state);\n\n  ares__hosts_file_destroy(channel->hf);\n\n  ares__qcache_destroy(channel->qcache);\n\n  ares__channel_threading_destroy(channel);\n\n  ares_free(channel);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              109,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_destroy",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__destroy_server(struct server_state *server)\n{\n  if (server == NULL) {\n    return;\n  }\n\n  ares__close_sockets(server);\n  ares__llist_destroy(server->connections);\n  ares__buf_destroy(server->tcp_parser);\n  ares__buf_destroy(server->tcp_send);\n  ares_free(server);\n}",
          "fn_code_pos": [
            [
              111,
              0
            ],
            [
              122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__destroy_server",
            "parameters": {
              "server": "struct server_state"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ares__destroy_servers_state(ares_channel_t *channel)\n{\n  ares__slist_node_t *node;\n\n  while ((node = ares__slist_node_first(channel->servers)) != NULL) {\n    struct server_state *server = ares__slist_node_claim(node);\n    ares__destroy_server(server);\n  }\n\n  ares__slist_destroy(channel->servers);\n  channel->servers = NULL;\n}",
          "fn_code_pos": [
            [
              124,
              0
            ],
            [
              135,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__destroy_servers_state",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct query",
          {},
          "",
          [
            50,
            4
          ],
          [
            50,
            16
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            111,
            26
          ],
          [
            111,
            45
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            129,
            4
          ],
          [
            129,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_update_servers.c": {
      "fn_def_list": [
        {
          "fn_code": "static ares_bool_t ares__addr_match(const struct ares_addr *addr1,\n                                    const struct ares_addr *addr2)\n{\n  if (addr1 == NULL && addr2 == NULL) {\n    return ARES_TRUE;\n  }\n\n  if (addr1 == NULL || addr2 == NULL) {\n    return ARES_FALSE;\n  }\n\n  if (addr1->family != addr2->family) {\n    return ARES_FALSE;\n  }\n\n  if (addr1->family == AF_INET && memcmp(&addr1->addr.addr4, &addr2->addr.addr4,\n                                         sizeof(addr1->addr.addr4)) == 0) {\n    return ARES_TRUE;\n  }\n\n  if (addr1->family == AF_INET6 &&\n      memcmp(&addr1->addr.addr6._S6_un._S6_u8, &addr2->addr.addr6._S6_un._S6_u8,\n             sizeof(addr1->addr.addr6._S6_un._S6_u8)) == 0) {\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              92,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__addr_match",
            "parameters": {
              "addr1": "struct ares_addr",
              "addr2": "struct ares_addr"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares__subnet_match(const struct ares_addr *addr,\n                               const struct ares_addr *subnet,\n                               unsigned char           netmask)\n{\n  const unsigned char *addr_ptr;\n  const unsigned char *subnet_ptr;\n  size_t               len;\n  size_t               i;\n\n  if (addr == NULL || subnet == NULL) {\n    return ARES_FALSE;\n  }\n\n  if (addr->family != subnet->family) {\n    return ARES_FALSE;\n  }\n\n  if (addr->family == AF_INET) {\n    addr_ptr   = (const unsigned char *)&addr->addr.addr4;\n    subnet_ptr = (const unsigned char *)&subnet->addr.addr4;\n    len        = 4;\n\n    if (netmask > 32) {\n      return ARES_FALSE;\n    }\n  } else if (addr->family == AF_INET6) {\n    addr_ptr   = (const unsigned char *)&addr->addr.addr6;\n    subnet_ptr = (const unsigned char *)&subnet->addr.addr6;\n    len        = 16;\n\n    if (netmask > 128) {\n      return ARES_FALSE;\n    }\n  } else {\n    return ARES_FALSE;\n  }\n\n  for (i = 0; i < len && netmask > 0; i++) {\n    unsigned char mask = 0xff;\n    if (netmask < 8) {\n      mask    <<= (8 - netmask);\n      netmask   = 0;\n    } else {\n      netmask -= 8;\n    }\n\n    if ((addr_ptr[i] & mask) != (subnet_ptr[i] & mask)) {\n      return ARES_FALSE;\n    }\n  }\n\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              94,
              0
            ],
            [
              146,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__subnet_match",
            "parameters": {
              "addr": "struct ares_addr",
              "subnet": "struct ares_addr",
              "netmask": "unsigned char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_bool_t ares__addr_is_linklocal(const struct ares_addr *addr)\n{\n  struct ares_addr    subnet;\n  const unsigned char subnetaddr[16] = { 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00,\n                                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                                         0x00, 0x00, 0x00, 0x00 };\n\n  /* fe80::/10 */\n  subnet.family = AF_INET6;\n  memcpy(&subnet.addr.addr6, subnetaddr, 16);\n\n  return ares__subnet_match(addr, &subnet, 10);\n}",
          "fn_code_pos": [
            [
              148,
              0
            ],
            [
              160,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__addr_is_linklocal",
            "parameters": {
              "addr": "struct ares_addr"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares_server_blacklisted(const struct ares_addr *addr)\n{\n  /* A list of blacklisted IPv6 subnets. */\n  const struct {\n    const unsigned char netbase[16];\n    unsigned char       netmask;\n  } blacklist_v6[] = {\n  /* fec0::/10 was deprecated by [RFC3879] in September 2004. Formerly a\n  * Site-Local scoped address prefix.  These are never valid DNS servers,\n  * but are known to be returned at least sometimes on Windows and Android.\n  */\n    {{ 0xfe, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00 },\n     10}\n  };\n\n  size_t i;\n\n  if (addr->family != AF_INET6) {\n    return ARES_FALSE;\n  }\n\n  /* See if ipaddr matches any of the entries in the blacklist. */\n  for (i = 0; i < sizeof(blacklist_v6) / sizeof(*blacklist_v6); i++) {\n    struct ares_addr subnet;\n    subnet.family = AF_INET6;\n    memcpy(&subnet.addr.addr6, blacklist_v6[i].netbase, 16);\n    if (ares__subnet_match(addr, &subnet, blacklist_v6[i].netmask)) {\n      return ARES_TRUE;\n    }\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              162,
              0
            ],
            [
              194,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_server_blacklisted",
            "parameters": {
              "addr": "struct ares_addr"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t parse_nameserver(ares__buf_t *buf, ares_sconfig_t *sconfig)\n{\n  ares_status_t status;\n  char          ipaddr[INET6_ADDRSTRLEN] = \"\";\n  size_t        addrlen;\n\n  memset(sconfig, 0, sizeof(*sconfig));\n\n  /* Consume any leading whitespace */\n  ares__buf_consume_whitespace(buf, ARES_TRUE);\n\n  /* pop off IP address.  If it is in [ ] then it can be ipv4 or ipv6.  If\n   * not, ipv4 only */\n  if (ares__buf_begins_with(buf, (const unsigned char *)\"[\", 1)) {\n    /* Consume [ */\n    ares__buf_consume(buf, 1);\n\n    ares__buf_tag(buf);\n\n    /* Consume until ] */\n    if (ares__buf_consume_until_charset(buf, (const unsigned char *)\"]\", 1,\n                                        ARES_TRUE) == 0) {\n      return ARES_EBADSTR;\n    }\n\n    status = ares__buf_tag_fetch_string(buf, ipaddr, sizeof(ipaddr));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    /* Skip over ] */\n    ares__buf_consume(buf, 1);\n  } else {\n    size_t offset;\n\n    /* Not in [ ], see if '.' is in first 4 characters, if it is, then its ipv4,\n     * otherwise treat as ipv6 */\n    ares__buf_tag(buf);\n\n    offset = ares__buf_consume_until_charset(buf, (const unsigned char *)\".\", 1,\n                                             ARES_TRUE);\n    ares__buf_tag_rollback(buf);\n    ares__buf_tag(buf);\n\n    if (offset > 0 && offset < 4) {\n      /* IPv4 */\n      if (ares__buf_consume_charset(buf, (const unsigned char *)\"0123456789.\",\n                                    11) == 0) {\n        return ARES_EBADSTR;\n      }\n    } else {\n      /* IPv6 */\n      const unsigned char ipv6_charset[] = \"ABCDEFabcdef0123456789.:\";\n      if (ares__buf_consume_charset(buf, ipv6_charset,\n                                    sizeof(ipv6_charset) - 1) == 0) {\n        return ARES_EBADSTR;\n      }\n    }\n\n    status = ares__buf_tag_fetch_string(buf, ipaddr, sizeof(ipaddr));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  /* Convert ip address from string to network byte order */\n  sconfig->addr.family = AF_UNSPEC;\n  if (ares_dns_pton(ipaddr, &sconfig->addr, &addrlen) == NULL) {\n    return ARES_EBADSTR;\n  }\n\n  /* Pull off port */\n  if (ares__buf_begins_with(buf, (const unsigned char *)\":\", 1)) {\n    char portstr[6];\n\n    /* Consume : */\n    ares__buf_consume(buf, 1);\n\n    ares__buf_tag(buf);\n\n    /* Read numbers */\n    if (ares__buf_consume_charset(buf, (const unsigned char *)\"0123456789\",\n                                  10) == 0) {\n      return ARES_EBADSTR;\n    }\n\n    status = ares__buf_tag_fetch_string(buf, portstr, sizeof(portstr));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    sconfig->udp_port = (unsigned short)atoi(portstr);\n    sconfig->tcp_port = sconfig->udp_port;\n  }\n\n  /* Pull off interface modifier */\n  if (ares__buf_begins_with(buf, (const unsigned char *)\"%\", 1)) {\n    const unsigned char iface_charset[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                                          \"abcdefghijklmnopqrstuvwxyz\"\n                                          \"0123456789.-_\\\\:{}\";\n    /* Consume % */\n    ares__buf_consume(buf, 1);\n\n    ares__buf_tag(buf);\n\n    if (ares__buf_consume_charset(buf, iface_charset,\n                                  sizeof(iface_charset) - 1) == 0) {\n      return ARES_EBADSTR;\n    }\n\n    status = ares__buf_tag_fetch_string(buf, sconfig->ll_iface,\n                                        sizeof(sconfig->ll_iface));\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  /* Consume any trailing whitespace so we can bail out if there is something\n   * after we didn't read */\n  ares__buf_consume_whitespace(buf, ARES_TRUE);\n\n  if (ares__buf_len(buf) != 0) {\n    return ARES_EBADSTR;\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              215,
              0
            ],
            [
              341,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_nameserver",
            "parameters": {
              "buf": "ares__buf_t",
              "sconfig": "ares_sconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__sconfig_linklocal(ares_sconfig_t *s,\n                                             const char     *ll_iface)\n{\n  unsigned int ll_scope = 0;\n\n  if (ares_str_isnum(ll_iface)) {\n    char ifname[IF_NAMESIZE] = \"\";\n    ll_scope                 = (unsigned int)atoi(ll_iface);\n    if (ares__if_indextoname(ll_scope, ifname, sizeof(ifname)) == NULL) {\n      DEBUGF(fprintf(stderr, \"Interface %s for ipv6 Link Local not found\\n\",\n                     ll_iface));\n      return ARES_ENOTFOUND;\n    }\n    ares_strcpy(s->ll_iface, ifname, sizeof(s->ll_iface));\n    s->ll_scope = ll_scope;\n    return ARES_SUCCESS;\n  }\n\n  ll_scope = ares__if_nametoindex(ll_iface);\n  if (ll_scope == 0) {\n    DEBUGF(fprintf(stderr, \"Interface %s for ipv6 Link Local not found\\n\",\n                   ll_iface));\n    return ARES_ENOTFOUND;\n  }\n  ares_strcpy(s->ll_iface, ll_iface, sizeof(s->ll_iface));\n  s->ll_scope = ll_scope;\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              343,
              0
            ],
            [
              370,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__sconfig_linklocal",
            "parameters": {
              "s": "ares_sconfig_t",
              "ll_iface": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__sconfig_append(ares__llist_t         **sconfig,\n                                   const struct ares_addr *addr,\n                                   unsigned short          udp_port,\n                                   unsigned short          tcp_port,\n                                   const char             *ll_iface)\n{\n  ares_sconfig_t *s;\n  ares_status_t   status;\n\n  if (sconfig == NULL || addr == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  /* Silently skip blacklisted IPv6 servers. */\n  if (ares_server_blacklisted(addr)) {\n    return ARES_SUCCESS;\n  }\n\n  s = ares_malloc_zero(sizeof(*s));\n  if (s == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  if (*sconfig == NULL) {\n    *sconfig = ares__llist_create(ares_free);\n    if (*sconfig == NULL) {\n      status = ARES_ENOMEM;\n      goto fail;\n    }\n  }\n\n  memcpy(&s->addr, addr, sizeof(s->addr));\n  s->udp_port = udp_port;\n  s->tcp_port = tcp_port;\n\n  /* Handle link-local enumeration. If an interface is specified on a\n   * non-link-local address, we'll simply end up ignoring that */\n  if (ares__addr_is_linklocal(&s->addr)) {\n    if (ares_strlen(ll_iface) == 0) {\n      /* Silently ignore this entry, we require an interface */\n      status = ARES_SUCCESS;\n      goto fail;\n    }\n    status = ares__sconfig_linklocal(s, ll_iface);\n    /* Silently ignore this entry, we can't validate the interface */\n    if (status != ARES_SUCCESS) {\n      status = ARES_SUCCESS;\n      goto fail;\n    }\n  }\n\n  if (ares__llist_insert_last(*sconfig, s) == NULL) {\n    status = ARES_ENOMEM;\n    goto fail;\n  }\n\n  return ARES_SUCCESS;\n\nfail:\n  ares_free(s);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              373,
              0
            ],
            [
              435,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__sconfig_append",
            "parameters": {
              "sconfig": "ares__llist_t",
              "addr": "struct ares_addr",
              "udp_port": "unsigned short",
              "tcp_port": "unsigned short",
              "ll_iface": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares__sconfig_append_fromstr(ares__llist_t **sconfig,\n                                           const char     *str,\n                                           ares_bool_t     ignore_invalid)\n{\n  ares_status_t       status = ARES_SUCCESS;\n  ares__buf_t        *buf    = NULL;\n  ares__llist_t      *list   = NULL;\n  ares__llist_node_t *node;\n\n  /* On Windows, there may be more than one nameserver specified in the same\n   * registry key, so we parse input as a space or comma separated list.\n   */\n  buf = ares__buf_create_const((const unsigned char *)str, ares_strlen(str));\n  if (buf == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  status = ares__buf_split(buf, (const unsigned char *)\" ,\", 2,\n                           ARES_BUF_SPLIT_NONE, 0, &list);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  for (node = ares__llist_node_first(list); node != NULL;\n       node = ares__llist_node_next(node)) {\n    ares__buf_t   *entry = ares__llist_node_val(node);\n    ares_sconfig_t s;\n\n    status = parse_nameserver(entry, &s);\n    if (status != ARES_SUCCESS) {\n      if (ignore_invalid) {\n        continue;\n      } else {\n        goto done;\n      }\n    }\n\n    status = ares__sconfig_append(sconfig, &s.addr, s.udp_port, s.tcp_port,\n                                  s.ll_iface);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  ares__llist_destroy(list);\n  ares__buf_destroy(buf);\n  return status;\n}",
          "fn_code_pos": [
            [
              453,
              0
            ],
            [
              504,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__sconfig_append_fromstr",
            "parameters": {
              "sconfig": "ares__llist_t",
              "str": "char",
              "ignore_invalid": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static unsigned short ares__sconfig_get_port(const ares_channel_t *channel,\n                                             const ares_sconfig_t *s,\n                                             ares_bool_t           is_tcp)\n{\n  unsigned short port = is_tcp ? s->tcp_port : s->udp_port;\n\n  if (port == 0) {\n    port = is_tcp ? channel->tcp_port : channel->udp_port;\n  }\n\n  if (port == 0) {\n    port = 53;\n  }\n\n  return port;\n}",
          "fn_code_pos": [
            [
              506,
              0
            ],
            [
              521,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__sconfig_get_port",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_sconfig_t",
              "is_tcp": "ares_bool_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static ares__slist_node_t *ares__server_find(ares_channel_t       *channel,\n                                             const ares_sconfig_t *s)\n{\n  ares__slist_node_t *node;\n\n  for (node = ares__slist_node_first(channel->servers); node != NULL;\n       node = ares__slist_node_next(node)) {\n    const struct server_state *server = ares__slist_node_val(node);\n\n    if (!ares__addr_match(&server->addr, &s->addr)) {\n      continue;\n    }\n\n    if (server->tcp_port != ares__sconfig_get_port(channel, s, ARES_TRUE)) {\n      continue;\n    }\n\n    if (server->udp_port != ares__sconfig_get_port(channel, s, ARES_FALSE)) {\n      continue;\n    }\n\n    return node;\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              523,
              0
            ],
            [
              547,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__server_find",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_sconfig_t"
            },
            "return_type": "ares__slist_node_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares__server_isdup(const ares_channel_t *channel,\n                                      ares__llist_node_t   *s)\n{\n  /* Scan backwards to see if this is a duplicate */\n  ares__llist_node_t   *prev;\n  const ares_sconfig_t *server = ares__llist_node_val(s);\n\n  for (prev = ares__llist_node_prev(s); prev != NULL;\n       prev = ares__llist_node_prev(prev)) {\n    const ares_sconfig_t *p = ares__llist_node_val(prev);\n\n    if (!ares__addr_match(&server->addr, &p->addr)) {\n      continue;\n    }\n\n    if (ares__sconfig_get_port(channel, server, ARES_TRUE) !=\n        ares__sconfig_get_port(channel, p, ARES_TRUE)) {\n      continue;\n    }\n\n    if (ares__sconfig_get_port(channel, server, ARES_FALSE) !=\n        ares__sconfig_get_port(channel, p, ARES_FALSE)) {\n      continue;\n    }\n\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              549,
              0
            ],
            [
              578,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__server_isdup",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares__llist_node_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares__server_create(ares_channel_t       *channel,\n                                         const ares_sconfig_t *sconfig,\n                                         size_t                idx)\n{\n  ares_status_t        status;\n  struct server_state *server = ares_malloc_zero(sizeof(*server));\n\n  if (server == NULL) {\n    return ARES_ENOMEM;\n  }\n\n  server->idx         = idx;\n  server->channel     = channel;\n  server->udp_port    = ares__sconfig_get_port(channel, sconfig, ARES_FALSE);\n  server->tcp_port    = ares__sconfig_get_port(channel, sconfig, ARES_TRUE);\n  server->addr.family = sconfig->addr.family;\n  server->next_retry_time.tv_sec = 0;\n  server->next_retry_time.tv_usec = 0;\n\n  if (sconfig->addr.family == AF_INET) {\n    memcpy(&server->addr.addr.addr4, &sconfig->addr.addr.addr4,\n           sizeof(server->addr.addr.addr4));\n  } else if (sconfig->addr.family == AF_INET6) {\n    memcpy(&server->addr.addr.addr6, &sconfig->addr.addr.addr6,\n           sizeof(server->addr.addr.addr6));\n  }\n\n  /* Copy over link-local settings */\n  if (ares_strlen(sconfig->ll_iface)) {\n    ares_strcpy(server->ll_iface, sconfig->ll_iface, sizeof(server->ll_iface));\n    server->ll_scope = sconfig->ll_scope;\n  }\n\n  server->tcp_parser = ares__buf_create();\n  if (server->tcp_parser == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  server->tcp_send = ares__buf_create();\n  if (server->tcp_send == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  server->connections = ares__llist_create(NULL);\n  if (server->connections == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  if (ares__slist_insert(channel->servers, server) == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  status = ARES_SUCCESS;\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares__destroy_server(server);\n  }\n\n  return status;\n}",
          "fn_code_pos": [
            [
              580,
              0
            ],
            [
              644,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__server_create",
            "parameters": {
              "channel": "ares_channel_t",
              "sconfig": "ares_sconfig_t",
              "idx": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_bool_t ares__server_in_newconfig(const struct server_state *server,\n                                             ares__llist_t             *srvlist)\n{\n  ares__llist_node_t   *node;\n  const ares_channel_t *channel = server->channel;\n\n  for (node = ares__llist_node_first(srvlist); node != NULL;\n       node = ares__llist_node_next(node)) {\n    const ares_sconfig_t *s = ares__llist_node_val(node);\n\n    if (!ares__addr_match(&server->addr, &s->addr)) {\n      continue;\n    }\n\n    if (server->tcp_port != ares__sconfig_get_port(channel, s, ARES_TRUE)) {\n      continue;\n    }\n\n    if (server->udp_port != ares__sconfig_get_port(channel, s, ARES_FALSE)) {\n      continue;\n    }\n\n    return ARES_TRUE;\n  }\n\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              646,
              0
            ],
            [
              672,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__server_in_newconfig",
            "parameters": {
              "server": "struct server_state",
              "srvlist": "ares__llist_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void ares__servers_remove_stale(ares_channel_t *channel,\n                                       ares__llist_t  *srvlist)\n{\n  ares__slist_node_t *snode = ares__slist_node_first(channel->servers);\n\n  while (snode != NULL) {\n    ares__slist_node_t        *snext  = ares__slist_node_next(snode);\n    const struct server_state *server = ares__slist_node_val(snode);\n    if (!ares__server_in_newconfig(server, srvlist)) {\n      /* This will clean up all server state via the destruction callback and\n       * move any queries to new servers */\n      ares__slist_node_destroy(snode);\n    }\n    snode = snext;\n  }\n}",
          "fn_code_pos": [
            [
              674,
              0
            ],
            [
              689,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__servers_remove_stale",
            "parameters": {
              "channel": "ares_channel_t",
              "srvlist": "ares__llist_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares__servers_trim_single(ares_channel_t *channel)\n{\n  while (ares__slist_len(channel->servers) > 1) {\n    ares__slist_node_destroy(ares__slist_node_last(channel->servers));\n  }\n}",
          "fn_code_pos": [
            [
              691,
              0
            ],
            [
              696,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__servers_trim_single",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares__servers_update(ares_channel_t *channel,\n                                   ares__llist_t  *server_list,\n                                   ares_bool_t     user_specified)\n{\n  ares__llist_node_t *node;\n  size_t              idx = 0;\n  ares_status_t       status;\n\n  if (channel == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  ares__channel_lock(channel);\n\n  /* NOTE: a NULL or zero entry server list is considered valid due to\n   *       real-world people needing support for this for their test harnesses\n   */\n\n  /* Add new entries */\n  for (node = ares__llist_node_first(server_list); node != NULL;\n       node = ares__llist_node_next(node)) {\n    const ares_sconfig_t *sconfig = ares__llist_node_val(node);\n    ares__slist_node_t   *snode;\n\n    /* If a server has already appeared in the list of new servers, skip it. */\n    if (ares__server_isdup(channel, node)) {\n      continue;\n    }\n\n    snode = ares__server_find(channel, sconfig);\n    if (snode != NULL) {\n      struct server_state *server = ares__slist_node_val(snode);\n\n      /* Copy over link-local settings.  Its possible some of this data has\n       * changed, maybe ...  */\n      if (ares_strlen(sconfig->ll_iface)) {\n        ares_strcpy(server->ll_iface, sconfig->ll_iface,\n                    sizeof(server->ll_iface));\n        server->ll_scope = sconfig->ll_scope;\n      }\n\n      if (server->idx != idx) {\n        server->idx = idx;\n        /* Index changed, reinsert node, doesn't require any memory\n         * allocations so can't fail. */\n        ares__slist_node_reinsert(snode);\n      }\n    } else {\n      status = ares__server_create(channel, sconfig, idx);\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n    }\n\n    idx++;\n  }\n\n  /* Remove any servers that don't exist in the current configuration */\n  ares__servers_remove_stale(channel, server_list);\n\n  /* Trim to one server if ARES_FLAG_PRIMARY is set. */\n  if (channel->flags & ARES_FLAG_PRIMARY) {\n    ares__servers_trim_single(channel);\n  }\n\n  if (user_specified) {\n    /* Save servers as if they were passed in as an option */\n    channel->optmask |= ARES_OPT_SERVERS;\n  }\n\n  /* Clear any cached query results */\n  ares__qcache_flush(channel->qcache);\n\n  status = ARES_SUCCESS;\n\ndone:\n  ares__channel_unlock(channel);\n  return status;\n}",
          "fn_code_pos": [
            [
              698,
              0
            ],
            [
              776,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__servers_update",
            "parameters": {
              "channel": "ares_channel_t",
              "server_list": "ares__llist_t",
              "user_specified": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t\n  ares_addr_node_to_server_config_llist(const struct ares_addr_node *servers,\n                                        ares__llist_t              **llist)\n{\n  const struct ares_addr_node *node;\n  ares__llist_t               *s;\n\n  *llist = NULL;\n\n  s = ares__llist_create(ares_free);\n  if (s == NULL) {\n    goto fail;\n  }\n\n  for (node = servers; node != NULL; node = node->next) {\n    ares_sconfig_t *sconfig;\n\n    /* Invalid entry */\n    if (node->family != AF_INET && node->family != AF_INET6) {\n      continue;\n    }\n\n    sconfig = ares_malloc_zero(sizeof(*sconfig));\n    if (sconfig == NULL) {\n      goto fail;\n    }\n\n    sconfig->addr.family = node->family;\n    if (node->family == AF_INET) {\n      memcpy(&sconfig->addr.addr.addr4, &node->addr.addr4,\n             sizeof(sconfig->addr.addr.addr4));\n    } else if (sconfig->addr.family == AF_INET6) {\n      memcpy(&sconfig->addr.addr.addr6, &node->addr.addr6,\n             sizeof(sconfig->addr.addr.addr6));\n    }\n\n    if (ares__llist_insert_last(s, sconfig) == NULL) {\n      ares_free(sconfig);\n      goto fail;\n    }\n  }\n\n  *llist = s;\n  return ARES_SUCCESS;\n\nfail:\n  ares__llist_destroy(s);\n  return ARES_ENOMEM;\n}",
          "fn_code_pos": [
            [
              778,
              0
            ],
            [
              826,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_addr_node_to_server_config_llist",
            "parameters": {
              "servers": "struct ares_addr_node",
              "llist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static ares_status_t ares_addr_port_node_to_server_config_llist(\n  const struct ares_addr_port_node *servers, ares__llist_t **llist)\n{\n  const struct ares_addr_port_node *node;\n  ares__llist_t                    *s;\n\n  *llist = NULL;\n\n  s = ares__llist_create(ares_free);\n  if (s == NULL) {\n    goto fail;\n  }\n\n  for (node = servers; node != NULL; node = node->next) {\n    ares_sconfig_t *sconfig;\n\n    /* Invalid entry */\n    if (node->family != AF_INET && node->family != AF_INET6) {\n      continue;\n    }\n\n    sconfig = ares_malloc_zero(sizeof(*sconfig));\n    if (sconfig == NULL) {\n      goto fail;\n    }\n\n    sconfig->addr.family = node->family;\n    if (node->family == AF_INET) {\n      memcpy(&sconfig->addr.addr.addr4, &node->addr.addr4,\n             sizeof(sconfig->addr.addr.addr4));\n    } else if (sconfig->addr.family == AF_INET6) {\n      memcpy(&sconfig->addr.addr.addr6, &node->addr.addr6,\n             sizeof(sconfig->addr.addr.addr6));\n    }\n\n    sconfig->tcp_port = (unsigned short)node->tcp_port;\n    sconfig->udp_port = (unsigned short)node->udp_port;\n\n    if (ares__llist_insert_last(s, sconfig) == NULL) {\n      ares_free(sconfig);\n      goto fail;\n    }\n  }\n\n  *llist = s;\n  return ARES_SUCCESS;\n\nfail:\n  ares__llist_destroy(s);\n  return ARES_ENOMEM;\n}",
          "fn_code_pos": [
            [
              828,
              0
            ],
            [
              878,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_addr_port_node_to_server_config_llist",
            "parameters": {
              "servers": "struct ares_addr_port_node",
              "llist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_in_addr_to_server_config_llist(const struct in_addr *servers,\n                                                  size_t          nservers,\n                                                  ares__llist_t **llist)\n{\n  size_t         i;\n  ares__llist_t *s;\n\n  *llist = NULL;\n\n  s = ares__llist_create(ares_free);\n  if (s == NULL) {\n    goto fail;\n  }\n\n  for (i = 0; servers != NULL && i < nservers; i++) {\n    ares_sconfig_t *sconfig;\n\n    sconfig = ares_malloc_zero(sizeof(*sconfig));\n    if (sconfig == NULL) {\n      goto fail;\n    }\n\n    sconfig->addr.family = AF_INET;\n    memcpy(&sconfig->addr.addr.addr4, &servers[i],\n           sizeof(sconfig->addr.addr.addr4));\n\n    if (ares__llist_insert_last(s, sconfig) == NULL) {\n      goto fail;\n    }\n  }\n\n  *llist = s;\n  return ARES_SUCCESS;\n\nfail:\n  ares__llist_destroy(s);\n  return ARES_ENOMEM;\n}",
          "fn_code_pos": [
            [
              880,
              0
            ],
            [
              917,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_in_addr_to_server_config_llist",
            "parameters": {
              "servers": "struct in_addr",
              "nservers": "size_t",
              "llist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_get_server_addr(const struct server_state *server,\n                                   ares__buf_t               *buf)\n{\n  ares_status_t status;\n  char          addr[INET6_ADDRSTRLEN];\n\n  /* ipv4addr or [ipv6addr] */\n  if (server->addr.family == AF_INET6) {\n    status = ares__buf_append_byte(buf, '[');\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  ares_inet_ntop(server->addr.family, &server->addr.addr, addr, sizeof(addr));\n\n  status = ares__buf_append_str(buf, addr);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  if (server->addr.family == AF_INET6) {\n    status = ares__buf_append_byte(buf, ']');\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  /* :port */\n  status = ares__buf_append_byte(buf, ':');\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  status = ares__buf_append_num_dec(buf, server->udp_port, 0);\n  if (status != ARES_SUCCESS) {\n    return status;\n  }\n\n  /* %iface */\n  if (ares_strlen(server->ll_iface)) {\n    status = ares__buf_append_byte(buf, '%');\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n\n    status = ares__buf_append_str(buf, server->ll_iface);\n    if (status != ARES_SUCCESS) {\n      return status;\n    }\n  }\n\n  return ARES_SUCCESS;\n}",
          "fn_code_pos": [
            [
              920,
              0
            ],
            [
              973,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_server_addr",
            "parameters": {
              "server": "struct server_state",
              "buf": "ares__buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "int ares_get_servers(ares_channel_t *channel, struct ares_addr_node **servers)\n{\n  struct ares_addr_node *srvr_head = NULL;\n  struct ares_addr_node *srvr_last = NULL;\n  struct ares_addr_node *srvr_curr;\n  ares_status_t          status = ARES_SUCCESS;\n  ares__slist_node_t    *node;\n\n  if (channel == NULL) {\n    return ARES_ENODATA;\n  }\n\n  ares__channel_lock(channel);\n\n  for (node = ares__slist_node_first(channel->servers); node != NULL;\n       node = ares__slist_node_next(node)) {\n    const struct server_state *server = ares__slist_node_val(node);\n\n    /* Allocate storage for this server node appending it to the list */\n    srvr_curr = ares_malloc_data(ARES_DATATYPE_ADDR_NODE);\n    if (!srvr_curr) {\n      status = ARES_ENOMEM;\n      break;\n    }\n    if (srvr_last) {\n      srvr_last->next = srvr_curr;\n    } else {\n      srvr_head = srvr_curr;\n    }\n    srvr_last = srvr_curr;\n\n    /* Fill this server node data */\n    srvr_curr->family = server->addr.family;\n    if (srvr_curr->family == AF_INET) {\n      memcpy(&srvr_curr->addr.addr4, &server->addr.addr.addr4,\n             sizeof(srvr_curr->addr.addr4));\n    } else {\n      memcpy(&srvr_curr->addr.addr6, &server->addr.addr.addr6,\n             sizeof(srvr_curr->addr.addr6));\n    }\n  }\n\n  if (status != ARES_SUCCESS) {\n    ares_free_data(srvr_head);\n    srvr_head = NULL;\n  }\n\n  *servers = srvr_head;\n\n  ares__channel_unlock(channel);\n\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              975,
              0
            ],
            [
              1027,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_servers",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "struct ares_addr_node"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_get_servers_ports(ares_channel_t              *channel,\n                           struct ares_addr_port_node **servers)\n{\n  struct ares_addr_port_node *srvr_head = NULL;\n  struct ares_addr_port_node *srvr_last = NULL;\n  struct ares_addr_port_node *srvr_curr;\n  ares_status_t               status = ARES_SUCCESS;\n  ares__slist_node_t         *node;\n\n  if (channel == NULL) {\n    return ARES_ENODATA;\n  }\n\n  ares__channel_lock(channel);\n\n  for (node = ares__slist_node_first(channel->servers); node != NULL;\n       node = ares__slist_node_next(node)) {\n    const struct server_state *server = ares__slist_node_val(node);\n\n    /* Allocate storage for this server node appending it to the list */\n    srvr_curr = ares_malloc_data(ARES_DATATYPE_ADDR_PORT_NODE);\n    if (!srvr_curr) {\n      status = ARES_ENOMEM;\n      break;\n    }\n    if (srvr_last) {\n      srvr_last->next = srvr_curr;\n    } else {\n      srvr_head = srvr_curr;\n    }\n    srvr_last = srvr_curr;\n\n    /* Fill this server node data */\n    srvr_curr->family   = server->addr.family;\n    srvr_curr->udp_port = server->udp_port;\n    srvr_curr->tcp_port = server->tcp_port;\n\n    if (srvr_curr->family == AF_INET) {\n      memcpy(&srvr_curr->addr.addr4, &server->addr.addr.addr4,\n             sizeof(srvr_curr->addr.addr4));\n    } else {\n      memcpy(&srvr_curr->addr.addr6, &server->addr.addr.addr6,\n             sizeof(srvr_curr->addr.addr6));\n    }\n  }\n\n  if (status != ARES_SUCCESS) {\n    ares_free_data(srvr_head);\n    srvr_head = NULL;\n  }\n\n  *servers = srvr_head;\n\n  ares__channel_unlock(channel);\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              1029,
              0
            ],
            [
              1084,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_servers_ports",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "struct ares_addr_port_node"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_set_servers(ares_channel_t              *channel,\n                     const struct ares_addr_node *servers)\n{\n  ares__llist_t *slist;\n  ares_status_t  status;\n\n  if (channel == NULL) {\n    return ARES_ENODATA;\n  }\n\n  status = ares_addr_node_to_server_config_llist(servers, &slist);\n  if (status != ARES_SUCCESS) {\n    return (int)status;\n  }\n\n  /* NOTE: lock is in ares__servers_update() */\n  status = ares__servers_update(channel, slist, ARES_TRUE);\n\n  ares__llist_destroy(slist);\n\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              1086,
              0
            ],
            [
              1107,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_servers",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "struct ares_addr_node"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_set_servers_ports(ares_channel_t                   *channel,\n                           const struct ares_addr_port_node *servers)\n{\n  ares__llist_t *slist;\n  ares_status_t  status;\n\n  if (channel == NULL) {\n    return ARES_ENODATA;\n  }\n\n  status = ares_addr_port_node_to_server_config_llist(servers, &slist);\n  if (status != ARES_SUCCESS) {\n    return (int)status;\n  }\n\n  /* NOTE: lock is in ares__servers_update() */\n  status = ares__servers_update(channel, slist, ARES_TRUE);\n\n  ares__llist_destroy(slist);\n\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              1109,
              0
            ],
            [
              1130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_servers_ports",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "struct ares_addr_port_node"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static ares_status_t set_servers_csv(ares_channel_t *channel, const char *_csv)\n{\n  ares_status_t  status;\n  ares__llist_t *slist = NULL;\n\n  if (channel == NULL) {\n    return ARES_ENODATA;\n  }\n\n  /* NOTE: lock is in ares__servers_update() */\n\n  if (ares_strlen(_csv) == 0) {\n    /* blank all servers */\n    return ares__servers_update(channel, NULL, ARES_TRUE);\n  }\n\n  status = ares__sconfig_append_fromstr(&slist, _csv, ARES_FALSE);\n  if (status != ARES_SUCCESS) {\n    ares__llist_destroy(slist);\n    return status;\n  }\n\n  /* NOTE: lock is in ares__servers_update() */\n  status = ares__servers_update(channel, slist, ARES_TRUE);\n\n  ares__llist_destroy(slist);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              1134,
              0
            ],
            [
              1162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_servers_csv",
            "parameters": {
              "channel": "ares_channel_t",
              "_csv": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "int ares_set_servers_csv(ares_channel_t *channel, const char *_csv)\n{\n  /* NOTE: lock is in ares__servers_update() */\n  return (int)set_servers_csv(channel, _csv);\n}",
          "fn_code_pos": [
            [
              1165,
              0
            ],
            [
              1169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_servers_csv",
            "parameters": {
              "channel": "ares_channel_t",
              "_csv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ares_set_servers_ports_csv(ares_channel_t *channel, const char *_csv)\n{\n  /* NOTE: lock is in ares__servers_update() */\n  return (int)set_servers_csv(channel, _csv);\n}",
          "fn_code_pos": [
            [
              1171,
              0
            ],
            [
              1175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_servers_ports_csv",
            "parameters": {
              "channel": "ares_channel_t",
              "_csv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "char *ares_get_servers_csv(ares_channel_t *channel)\n{\n  ares__buf_t        *buf = NULL;\n  char               *out = NULL;\n  ares__slist_node_t *node;\n\n  ares__channel_lock(channel);\n\n  buf = ares__buf_create();\n  if (buf == NULL) {\n    goto done;\n  }\n\n  for (node = ares__slist_node_first(channel->servers); node != NULL;\n       node = ares__slist_node_next(node)) {\n    ares_status_t              status;\n    const struct server_state *server = ares__slist_node_val(node);\n\n    if (ares__buf_len(buf)) {\n      status = ares__buf_append_byte(buf, ',');\n      if (status != ARES_SUCCESS) {\n        goto done;\n      }\n    }\n\n    status = ares_get_server_addr(server, buf);\n    if (status != ARES_SUCCESS) {\n      goto done;\n    }\n  }\n\n  out = ares__buf_finish_str(buf, NULL);\n  buf = NULL;\n\ndone:\n  ares__channel_unlock(channel);\n  ares__buf_destroy(buf);\n  return out;\n}",
          "fn_code_pos": [
            [
              1177,
              0
            ],
            [
              1215,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_servers_csv",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "void ares_set_server_state_callback(ares_channel_t            *channel,\n                                    ares_server_state_callback cb,\n                                    void                      *data)\n{\n  if (channel == NULL) {\n    return;\n  }\n  channel->server_state_cb      = cb;\n  channel->server_state_cb_data = data;\n}",
          "fn_code_pos": [
            [
              1217,
              0
            ],
            [
              1226,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_server_state_callback",
            "parameters": {
              "channel": "ares_channel_t",
              "cb": "ares_server_state_callback",
              "data": "void"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares__server_find(ares_channel_t       *channel,\n                                             const ares_sconfig_t *s)",
          "fn_dec_pos": [
            [
              523,
              27
            ],
            [
              524,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__server_find",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_sconfig_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_get_servers_csv(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              1177,
              6
            ],
            [
              1177,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_servers_csv",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  struct ares_addr addr;\n  unsigned short   tcp_port;\n  unsigned short   udp_port;\n\n  char             ll_iface[IF_NAMESIZE];\n  unsigned int     ll_scope;\n} ares_sconfig_t;",
          {
            "addr": "struct ares_addr",
            "tcp_port": "unsigned short",
            "udp_port": "unsigned short",
            "ll_iface[IF_NAMESIZE]": "char",
            "ll_scope": "unsigned int"
          },
          "ares_sconfig_t",
          [
            56,
            0
          ],
          [
            63,
            17
          ]
        ],
        [
          "struct {\n    const unsigned char netbase[16];\n    unsigned char       netmask;\n  }",
          {
            "unsigned char": "const",
            "netmask": "unsigned char"
          },
          "",
          [
            165,
            8
          ],
          [
            168,
            3
          ]
        ],
        [
          "typedef struct {\n  struct ares_addr addr;\n  unsigned short   tcp_port;\n  unsigned short   udp_port;\n\n  char             ll_iface[IF_NAMESIZE];\n  unsigned int     ll_scope;\n} ares_sconfig_t;",
          {
            "addr": "struct ares_addr",
            "tcp_port": "unsigned short",
            "udp_port": "unsigned short",
            "ll_iface[IF_NAMESIZE]": "char",
            "ll_scope": "unsigned int"
          },
          "ares_sconfig_t",
          [
            56,
            0
          ],
          [
            63,
            17
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            57,
            2
          ],
          [
            57,
            18
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            65,
            42
          ],
          [
            65,
            58
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            66,
            42
          ],
          [
            66,
            58
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            94,
            37
          ],
          [
            94,
            53
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            95,
            37
          ],
          [
            95,
            53
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            148,
            42
          ],
          [
            148,
            58
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            150,
            2
          ],
          [
            150,
            18
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            162,
            49
          ],
          [
            162,
            65
          ]
        ],
        [
          "struct {\n    const unsigned char netbase[16];\n    unsigned char       netmask;\n  }",
          {
            "unsigned char": "const",
            "netmask": "unsigned char"
          },
          "",
          [
            165,
            8
          ],
          [
            168,
            3
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            186,
            4
          ],
          [
            186,
            20
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            374,
            41
          ],
          [
            374,
            57
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            530,
            10
          ],
          [
            530,
            29
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            585,
            2
          ],
          [
            585,
            21
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            646,
            51
          ],
          [
            646,
            70
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            681,
            10
          ],
          [
            681,
            29
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            729,
            6
          ],
          [
            729,
            25
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            779,
            46
          ],
          [
            779,
            67
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            782,
            8
          ],
          [
            782,
            29
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            829,
            8
          ],
          [
            829,
            34
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            831,
            8
          ],
          [
            831,
            34
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            880,
            56
          ],
          [
            880,
            70
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            920,
            41
          ],
          [
            920,
            60
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            975,
            46
          ],
          [
            975,
            67
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            977,
            2
          ],
          [
            977,
            23
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            978,
            2
          ],
          [
            978,
            23
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            979,
            2
          ],
          [
            979,
            23
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            991,
            10
          ],
          [
            991,
            29
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            1030,
            27
          ],
          [
            1030,
            53
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            1032,
            2
          ],
          [
            1032,
            28
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            1033,
            2
          ],
          [
            1033,
            28
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            1034,
            2
          ],
          [
            1034,
            28
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            1046,
            10
          ],
          [
            1046,
            29
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            1087,
            27
          ],
          [
            1087,
            48
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            1110,
            33
          ],
          [
            1110,
            59
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            1193,
            10
          ],
          [
            1193,
            29
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <sys/types.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <sys/socket.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#  include <net/if.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#    include <iphlpapi.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#    include <netioapi.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_event_wake_pipe.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ares_pipeevent_destroy(ares_pipeevent_t *p)\n{\n  if (p->filedes[0] != -1) {\n    close(p->filedes[0]);\n  }\n  if (p->filedes[1] != -1) {\n    close(p->filedes[1]);\n  }\n\n  ares_free(p);\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              51,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pipeevent_destroy",
            "parameters": {
              "p": "ares_pipeevent_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_pipeevent_destroy_cb(void *arg)\n{\n  ares_pipeevent_destroy(arg);\n}",
          "fn_code_pos": [
            [
              53,
              0
            ],
            [
              56,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pipeevent_destroy_cb",
            "parameters": {
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_pipeevent_t *ares_pipeevent_init(void)\n{\n  ares_pipeevent_t *p = ares_malloc_zero(sizeof(*p));\n  if (p == NULL) {\n    return NULL;\n  }\n\n  p->filedes[0] = -1;\n  p->filedes[1] = -1;\n\n#  ifdef HAVE_PIPE2\n  if (pipe2(p->filedes, O_NONBLOCK | O_CLOEXEC) != 0) {\n    ares_pipeevent_destroy(p);\n    return NULL;\n  }\n#  else\n  if (pipe(p->filedes) != 0) {\n    ares_pipeevent_destroy(p);\n    return NULL;\n  }\n\n#    ifdef O_NONBLOCK\n  {\n    int val;\n    val = fcntl(p->filedes[0], F_GETFL, 0);\n    if (val >= 0) {\n      val |= O_NONBLOCK;\n    }\n    fcntl(p->filedes[0], F_SETFL, val);\n\n    val = fcntl(p->filedes[1], F_GETFL, 0);\n    if (val >= 0) {\n      val |= O_NONBLOCK;\n    }\n    fcntl(p->filedes[1], F_SETFL, val);\n  }\n#    endif\n\n#    ifdef O_CLOEXEC\n  fcntl(p->filedes[0], F_SETFD, O_CLOEXEC);\n  fcntl(p->filedes[1], F_SETFD, O_CLOEXEC);\n#    endif\n#  endif\n\n#  ifdef F_SETNOSIGPIPE\n  fcntl(p->filedes[0], F_SETNOSIGPIPE, 1);\n  fcntl(p->filedes[1], F_SETNOSIGPIPE, 1);\n#  endif\n\n  return p;\n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              108,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pipeevent_init",
            "parameters": {},
            "return_type": "ares_pipeevent_t"
          }
        },
        {
          "fn_code": "static void ares_pipeevent_signal(const ares_event_t *e)\n{\n  const ares_pipeevent_t *p;\n\n  if (e == NULL || e->data == NULL) {\n    return;\n  }\n\n  p = e->data;\n  (void)write(p->filedes[1], \"1\", 1);\n}",
          "fn_code_pos": [
            [
              110,
              0
            ],
            [
              120,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pipeevent_signal",
            "parameters": {
              "e": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ares_pipeevent_cb(ares_event_thread_t *e, ares_socket_t fd,\n                              void *data, ares_event_flags_t flags)\n{\n  unsigned char           buf[32];\n  const ares_pipeevent_t *p = NULL;\n\n  (void)e;\n  (void)fd;\n  (void)flags;\n\n  if (data == NULL) {\n    return;\n  }\n\n  p = data;\n\n  while (read(p->filedes[0], buf, sizeof(buf)) == sizeof(buf)) {\n    /* Do nothing */\n  }\n}",
          "fn_code_pos": [
            [
              122,
              0
            ],
            [
              141,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pipeevent_cb",
            "parameters": {
              "e": "ares_event_thread_t",
              "fd": "ares_socket_t",
              "data": "void",
              "flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_event_t *ares_pipeevent_create(ares_event_thread_t *e)\n{\n  ares_event_t     *event = NULL;\n  ares_pipeevent_t *p     = NULL;\n  ares_status_t     status;\n\n  p = ares_pipeevent_init();\n  if (p == NULL) {\n    return NULL;\n  }\n\n  status = ares_event_update(&event, e, ARES_EVENT_FLAG_READ, ares_pipeevent_cb,\n                             p->filedes[0], p, ares_pipeevent_destroy_cb,\n                             ares_pipeevent_signal);\n  if (status != ARES_SUCCESS) {\n    ares_pipeevent_destroy(p);\n    return NULL;\n  }\n\n  return event;\n}",
          "fn_code_pos": [
            [
              143,
              0
            ],
            [
              163,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pipeevent_create",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_event_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ares_pipeevent_init(void)",
          "fn_dec_pos": [
            [
              58,
              25
            ],
            [
              58,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pipeevent_init",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_pipeevent_create(ares_event_thread_t *e)",
          "fn_dec_pos": [
            [
              143,
              14
            ],
            [
              143,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pipeevent_create",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  int filedes[2];\n} ares_pipeevent_t;",
          {
            "filedes[2]": "int"
          },
          "ares_pipeevent_t",
          [
            37,
            0
          ],
          [
            39,
            19
          ]
        ],
        [
          "typedef struct {\n  int filedes[2];\n} ares_pipeevent_t;",
          {
            "filedes[2]": "int"
          },
          "ares_pipeevent_t",
          [
            37,
            0
          ],
          [
            39,
            19
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares_event.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <unistd.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <fcntl.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_send.c": {
      "fn_def_list": [
        {
          "fn_code": "static unsigned short generate_unique_qid(ares_channel_t *channel)\n{\n  unsigned short id;\n\n  do {\n    id = ares__generate_new_id(channel->rand_state);\n  } while (ares__htable_szvp_get(channel->queries_by_qid, id, NULL));\n\n  return id;\n}",
          "fn_code_pos": [
            [
              39,
              0
            ],
            [
              48,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "generate_unique_qid",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static ares_status_t ares_send_dnsrec_int(ares_channel_t          *channel,\n                                          const ares_dns_record_t *dnsrec,\n                                          ares_callback_dnsrec     callback,\n                                          void *arg, unsigned short *qid)\n{\n  struct query            *query;\n  size_t                   packetsz;\n  struct timeval           now = ares__tvnow();\n  ares_status_t            status;\n  unsigned short           id          = generate_unique_qid(channel);\n  const ares_dns_record_t *dnsrec_resp = NULL;\n\n  if (ares__slist_len(channel->servers) == 0) {\n    callback(arg, ARES_ENOSERVER, 0, NULL);\n    return ARES_ENOSERVER;\n  }\n\n  /* Check query cache */\n  status = ares_qcache_fetch(channel, &now, dnsrec, &dnsrec_resp);\n  if (status != ARES_ENOTFOUND) {\n    /* ARES_SUCCESS means we retrieved the cache, anything else is a critical\n     * failure, all result in termination */\n    callback(arg, status, 0, dnsrec_resp);\n    return status;\n  }\n\n  /* Allocate space for query and allocated fields. */\n  query = ares_malloc(sizeof(struct query));\n  if (!query) {\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    return ARES_ENOMEM;\n  }\n  memset(query, 0, sizeof(*query));\n\n  query->channel = channel;\n\n  status = ares_dns_write(dnsrec, &query->qbuf, &query->qlen);\n  if (status != ARES_SUCCESS) {\n    ares_free(query);\n    callback(arg, status, 0, NULL);\n    return status;\n  }\n\n  query->qid             = id;\n  query->timeout.tv_sec  = 0;\n  query->timeout.tv_usec = 0;\n\n  /* Ignore first 2 bytes, assign our own query id */\n  query->qbuf[0] = (unsigned char)((id >> 8) & 0xFF);\n  query->qbuf[1] = (unsigned char)(id & 0xFF);\n\n  /* Fill in query arguments. */\n  query->callback = callback;\n  query->arg      = arg;\n\n  /* Initialize query status. */\n  query->try_count = 0;\n\n  packetsz = (channel->flags & ARES_FLAG_EDNS) ? channel->ednspsz : PACKETSZ;\n  query->using_tcp =\n    (channel->flags & ARES_FLAG_USEVC) || query->qlen > packetsz;\n\n  query->error_status = ARES_SUCCESS;\n  query->timeouts     = 0;\n\n  /* Initialize our list nodes. */\n  query->node_queries_by_timeout = NULL;\n  query->node_queries_to_conn    = NULL;\n\n  /* Chain the query into the list of all queries. */\n  query->node_all_queries =\n    ares__llist_insert_last(channel->all_queries, query);\n  if (query->node_all_queries == NULL) {\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    ares__free_query(query);\n    return ARES_ENOMEM;\n  }\n\n  /* Keep track of queries bucketed by qid, so we can process DNS\n   * responses quickly.\n   */\n  if (!ares__htable_szvp_insert(channel->queries_by_qid, query->qid, query)) {\n    callback(arg, ARES_ENOMEM, 0, NULL);\n    ares__free_query(query);\n    return ARES_ENOMEM;\n  }\n\n  /* Perform the first query action. */\n\n  status = ares__send_query(query, &now);\n  if (status == ARES_SUCCESS && qid) {\n    *qid = id;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              50,
              0
            ],
            [
              144,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_send_dnsrec_int",
            "parameters": {
              "channel": "ares_channel_t",
              "dnsrec": "ares_dns_record_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void",
              "qid": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_status_t ares_send_dnsrec(ares_channel_t          *channel,\n                               const ares_dns_record_t *dnsrec,\n                               ares_callback_dnsrec callback, void *arg,\n                               unsigned short *qid)\n{\n  ares_status_t status;\n\n  if (channel == NULL) {\n    return ARES_EFORMERR;\n  }\n\n  ares__channel_lock(channel);\n\n  status = ares_send_dnsrec_int(channel, dnsrec, callback, arg, qid);\n\n  ares__channel_unlock(channel);\n\n  return status;\n}",
          "fn_code_pos": [
            [
              146,
              0
            ],
            [
              164,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_send_dnsrec",
            "parameters": {
              "channel": "ares_channel_t",
              "dnsrec": "ares_dns_record_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void",
              "qid": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "void ares_send(ares_channel_t *channel, const unsigned char *qbuf, int qlen,\n               ares_callback callback, void *arg)\n{\n  ares_dns_record_t *dnsrec = NULL;\n  ares_status_t      status;\n  void              *carg = NULL;\n\n  if (channel == NULL) {\n    return;\n  }\n\n  /* Verify that the query is at least long enough to hold the header. */\n  if (qlen < HFIXEDSZ || qlen >= (1 << 16)) {\n    callback(arg, ARES_EBADQUERY, 0, NULL, 0);\n    return;\n  }\n\n  status = ares_dns_parse(qbuf, (size_t)qlen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    callback(arg, (int)status, 0, NULL, 0);\n    return;\n  }\n\n  carg = ares__dnsrec_convert_arg(callback, arg);\n  if (carg == NULL) {\n    status = ARES_ENOMEM;\n    ares_dns_record_destroy(dnsrec);\n    callback(arg, (int)status, 0, NULL, 0);\n    return;\n  }\n\n  ares_send_dnsrec(channel, dnsrec, ares__dnsrec_convert_cb, carg, NULL);\n\n  ares_dns_record_destroy(dnsrec);\n}",
          "fn_code_pos": [
            [
              166,
              0
            ],
            [
              200,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_send",
            "parameters": {
              "channel": "ares_channel_t",
              "qbuf": "unsigned char",
              "qlen": "int",
              "callback": "ares_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "size_t ares_queue_active_queries(ares_channel_t *channel)\n{\n  size_t len;\n\n  if (channel == NULL) {\n    return 0;\n  }\n\n  ares__channel_lock(channel);\n\n  len = ares__llist_len(channel->all_queries);\n\n  ares__channel_unlock(channel);\n\n  return len;\n}",
          "fn_code_pos": [
            [
              202,
              0
            ],
            [
              217,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_queue_active_queries",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct query",
          {},
          "",
          [
            55,
            2
          ],
          [
            55,
            14
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            57,
            2
          ],
          [
            57,
            16
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            77,
            29
          ],
          [
            77,
            41
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"ares_dns.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_parse_ptr_reply.c": {
      "fn_def_list": [
        {
          "fn_code": "ares_status_t ares_parse_ptr_reply_dnsrec(const ares_dns_record_t *dnsrec,\n                                          const void *addr, int addrlen,\n                                          int family, struct hostent **host)\n{\n  ares_status_t   status;\n  size_t          ptrcount = 0;\n  struct hostent *hostent  = NULL;\n  const char     *hostname = NULL;\n  const char     *ptrname  = NULL;\n  size_t          i;\n  size_t          ancount;\n\n  *host = NULL;\n\n  /* Fetch name from query as we will use it to compare later on.  Old code\n   * did this check, so we'll retain it. */\n  status = ares_dns_record_query_get(dnsrec, 0, &ptrname, NULL, NULL);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  ancount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER);\n  if (ancount == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  }\n\n  /* Response structure */\n  hostent = ares_malloc(sizeof(*hostent));\n  if (hostent == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\n  memset(hostent, 0, sizeof(*hostent));\n\n  hostent->h_addr_list = ares_malloc(2 * sizeof(*hostent->h_addr_list));\n  if (hostent->h_addr_list == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n  memset(hostent->h_addr_list, 0, 2 * sizeof(*hostent->h_addr_list));\n  if (addr != NULL && addrlen > 0) {\n    hostent->h_addr_list[0] = ares_malloc((size_t)addrlen);\n    if (hostent->h_addr_list[0] == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    memcpy(hostent->h_addr_list[0], addr, (size_t)addrlen);\n  }\n  hostent->h_addrtype = (HOSTENT_ADDRTYPE_TYPE)family;\n  hostent->h_length   = (HOSTENT_LENGTH_TYPE)addrlen;\n\n  /* Preallocate the maximum number + 1 */\n  hostent->h_aliases = ares_malloc((ancount + 1) * sizeof(*hostent->h_aliases));\n  if (hostent->h_aliases == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n  memset(hostent->h_aliases, 0, (ancount + 1) * sizeof(*hostent->h_aliases));\n\n\n  /* Cycle through answers */\n  for (i = 0; i < ancount; i++) {\n    const ares_dns_rr_t *rr =\n      ares_dns_record_rr_get_const(dnsrec, ARES_SECTION_ANSWER, i);\n\n    if (rr == NULL) {\n      /* Shouldn't be possible */\n      status = ARES_EBADRESP;\n      goto done;\n    }\n\n    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN) {\n      continue;\n    }\n\n    /* Any time we see a CNAME, replace our ptrname with its value */\n    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_CNAME) {\n      ptrname = ares_dns_rr_get_str(rr, ARES_RR_CNAME_CNAME);\n      if (ptrname == NULL) {\n        status = ARES_EBADRESP;\n        goto done;\n      }\n    }\n\n    /* Handling for PTR records below this, otherwise skip */\n    if (ares_dns_rr_get_type(rr) != ARES_REC_TYPE_PTR) {\n      continue;\n    }\n\n    /* Issue #683\n     * Old code compared the name in the rr to the ptrname, but I think this\n     * is wrong since it was proven wrong for A & AAAA records.  Leaving\n     * this code commented out for future reference\n     *\n     * rname = ares_dns_rr_get_name(rr);\n     * if (rname == NULL) {\n     *   status = ARES_EBADRESP;\n     *   goto done;\n     * }\n     * if (strcasecmp(ptrname, rname) != 0) {\n     *   continue;\n     * }\n     */\n\n    /* Save most recent PTR record as the hostname */\n    hostname = ares_dns_rr_get_str(rr, ARES_RR_PTR_DNAME);\n    if (hostname == NULL) {\n      status = ARES_EBADRESP;\n      goto done;\n    }\n\n    /* Append as an alias */\n    hostent->h_aliases[ptrcount] = ares_strdup(hostname);\n    if (hostent->h_aliases[ptrcount] == NULL) {\n      status = ARES_ENOMEM;\n      goto done;\n    }\n    ptrcount++;\n  }\n\n  if (ptrcount == 0) {\n    status = ARES_ENODATA;\n    goto done;\n  } else {\n    status = ARES_SUCCESS;\n  }\n\n  /* Fill in hostname */\n  hostent->h_name = ares_strdup(hostname);\n  if (hostent->h_name == NULL) {\n    status = ARES_ENOMEM;\n    goto done;\n  }\n\ndone:\n  if (status != ARES_SUCCESS) {\n    ares_free_hostent(hostent);\n    /* Compatibility */\n    if (status == ARES_EBADNAME) {\n      status = ARES_EBADRESP;\n    }\n  } else {\n    *host = hostent;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              38,
              0
            ],
            [
              185,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_ptr_reply_dnsrec",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "addr": "void",
              "addrlen": "int",
              "family": "int",
              "host": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "int ares_parse_ptr_reply(const unsigned char *abuf, int alen_int,\n                         const void *addr, int addrlen, int family,\n                         struct hostent **host)\n{\n  size_t             alen;\n  ares_dns_record_t *dnsrec = NULL;\n  ares_status_t      status;\n\n  if (alen_int < 0) {\n    return ARES_EBADRESP;\n  }\n\n  alen = (size_t)alen_int;\n\n  status = ares_dns_parse(abuf, alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_parse_ptr_reply_dnsrec(dnsrec, addr, addrlen, family, host);\n\ndone:\n  ares_dns_record_destroy(dnsrec);\n  if (status == ARES_EBADNAME) {\n    status = ARES_EBADRESP;\n  }\n  return (int)status;\n}",
          "fn_code_pos": [
            [
              187,
              0
            ],
            [
              214,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_ptr_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen_int": "int",
              "addr": "void",
              "addrlen": "int",
              "family": "int",
              "host": "struct hostent"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            40,
            54
          ],
          [
            40,
            68
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            44,
            2
          ],
          [
            44,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            189,
            25
          ],
          [
            189,
            39
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/tools/ares_getopt.c": {
      "fn_def_list": [
        {
          "fn_code": "void ares_getopt_init(ares_getopt_state_t *state, int nargc, const char **nargv)\n{\n  memset(state, 0, sizeof(*state));\n  state->opterr = 1;\n  state->optind = 1;\n  state->place  = EMSG;\n  state->argc   = nargc;\n  state->argv   = nargv;\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              59,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getopt_init",
            "parameters": {
              "state": "ares_getopt_state_t",
              "nargc": "int",
              "nargv": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int ares_getopt(ares_getopt_state_t *state, const char *ostr)\n{\n  const char *oli; /* option letter list index */\n\n  /* update scanning pointer */\n  if (!*state->place) {\n    if (state->optind >= state->argc) {\n      return -1;\n    }\n    state->place = state->argv[state->optind];\n    if (*(state->place) != '-') {\n      return -1;\n    }\n    state->place++;\n\n    /* found \"--\" */\n    if (*(state->place) == '-') {\n      state->optind++;\n      return -1;\n    }\n\n    /* Found just - */\n    if (!*(state->place)) {\n      state->optopt = 0;\n      return BADCH;\n    }\n  }\n\n  /* option letter okay? */\n  state->optopt = *(state->place);\n  state->place++;\n  oli = strchr(ostr, state->optopt);\n\n  if (oli == NULL) {\n    if (!(*state->place)) {\n      ++state->optind;\n    }\n    if (state->opterr) {\n      (void)fprintf(stderr, \"%s: illegal option -- %c\\n\", __FILE__,\n                    state->optopt);\n    }\n    return BADCH;\n  }\n\n  /* don't need argument */\n  if (*++oli != ':') {\n    state->optarg = NULL;\n    if (!*state->place) {\n      ++state->optind;\n    }\n  } else {\n    /* need an argument */\n    if (*state->place) {                         /* no white space */\n      state->optarg = state->place;\n    } else if (state->argc <= ++state->optind) { /* no arg */\n      state->place = EMSG;\n      if (*ostr == ':') {\n        return BADARG;\n      }\n      if (state->opterr) {\n        (void)fprintf(stderr, \"%s: option requires an argument -- %c\\n\",\n                      __FILE__, state->optopt);\n      }\n      return BADARG;\n    } else { /* white space */\n      state->optarg = state->argv[state->optind];\n    }\n    state->place = EMSG;\n    ++state->optind;\n  }\n  return state->optopt; /* dump back option letter */\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              136,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getopt",
            "parameters": {
              "state": "ares_getopt_state_t",
              "ostr": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"ares_getopt.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/tools/adig.c": {
      "fn_def_list": [
        {
          "fn_code": "static int          lookup_flag(const nv_t *nv, size_t num_nv, const char *name)\n{\n  size_t i;\n\n  if (name == NULL) {\n    return 0;\n  }\n\n  for (i = 0; i < num_nv; i++) {\n    if (strcasecmp(nv[i].name, name) == 0) {\n      return nv[i].value;\n    }\n  }\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              95,
              0
            ],
            [
              110,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lookup_flag",
            "parameters": {
              "nv": "nv_t",
              "num_nv": "size_t",
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void free_config(adig_config_t *config)\n{\n  free(config->servers);\n  memset(config, 0, sizeof(*config));\n}",
          "fn_code_pos": [
            [
              112,
              0
            ],
            [
              116,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "free_config",
            "parameters": {
              "config": "adig_config_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_help(void)\n{\n  printf(\"adig version %s\\n\\n\", ares_version(NULL));\n  printf(\n    \"usage: adig [-h] [-d] [-f flag] [[-s server] ...] [-T|U port] [-c class]\\n\"\n    \"            [-t type] name ...\\n\\n\"\n    \"  -h : Display this help and exit.\\n\"\n    \"  -d : Print some extra debugging output.\\n\"\n    \"  -f flag   : Add a behavior control flag. Possible values are\\n\"\n    \"              igntc     - do not retry a truncated query as TCP, just\\n\"\n    \"                          return the truncated answer\\n\"\n    \"              noaliases - don't honor the HOSTALIASES environment\\n\"\n    \"                          variable\\n\"\n    \"              norecurse - don't query upstream servers recursively\\n\"\n    \"              primary   - use the first server\\n\"\n    \"              stayopen  - don't close the communication sockets\\n\"\n    \"              usevc     - use TCP only\\n\"\n    \"  -s server : Connect to the specified DNS server, instead of the\\n\"\n    \"              system's default one(s). Servers are tried in round-robin,\\n\"\n    \"              if the previous one failed.\\n\"\n    \"  -T port   : Connect to the specified TCP port of DNS server.\\n\"\n    \"  -U port   : Connect to the specified UDP port of DNS server.\\n\"\n    \"  -c class  : Set the query class. Possible values for class are:\\n\"\n    \"              ANY, CHAOS, HS and IN (default)\\n\"\n    \"  -t type   : Query records of the specified type. Possible values for\\n\"\n    \"              type are:\\n\"\n    \"              A (default), AAAA, ANY, CNAME, HINFO, MX, NAPTR, NS, PTR,\\n\"\n    \"              SOA, SRV, TXT, TLSA, URI, CAA, SVCB, HTTPS\\n\\n\");\n}",
          "fn_code_pos": [
            [
              118,
              0
            ],
            [
              146,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_help",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t read_cmdline(int argc, const char **argv,\n                                adig_config_t *config)\n{\n  ares_getopt_state_t state;\n  int                 c;\n\n  ares_getopt_init(&state, argc, argv);\n  state.opterr = 0;\n\n  while ((c = ares_getopt(&state, \"dh?f:s:c:t:T:U:\")) != -1) {\n    int f;\n\n    switch (c) {\n      case 'd':\n#ifdef WATT32\n        dbug_init();\n#endif\n        break;\n\n      case 'h':\n        config->is_help = ARES_TRUE;\n        return ARES_TRUE;\n\n      case 'f':\n        f = lookup_flag(configflags, nconfigflags, state.optarg);\n        if (f == 0) {\n          snprintf(config->error, sizeof(config->error), \"flag %s unknown\",\n                   state.optarg);\n        }\n\n        config->options.flags |= f;\n        config->optmask       |= ARES_OPT_FLAGS;\n        break;\n\n      case 's':\n        if (state.optarg == NULL) {\n          snprintf(config->error, sizeof(config->error), \"%s\",\n                   \"missing servers\");\n          return ARES_FALSE;\n        }\n        if (config->servers) {\n          free(config->servers);\n        }\n        config->servers = strdup(state.optarg);\n        break;\n\n      case 'c':\n        if (!ares_dns_class_fromstr(&config->qclass, state.optarg)) {\n          snprintf(config->error, sizeof(config->error),\n                   \"unrecognized class %s\", state.optarg);\n          return ARES_FALSE;\n        }\n        break;\n\n      case 't':\n        if (!ares_dns_rec_type_fromstr(&config->qtype, state.optarg)) {\n          snprintf(config->error, sizeof(config->error), \"unrecognized type %s\",\n                   state.optarg);\n          return ARES_FALSE;\n        }\n        break;\n\n      case 'T':\n        /* Set the TCP port number. */\n        if (!isdigit(*state.optarg)) {\n          snprintf(config->error, sizeof(config->error), \"invalid port number\");\n          return ARES_FALSE;\n        }\n        config->options.tcp_port =\n          (unsigned short)strtol(state.optarg, NULL, 0);\n        config->options.flags |= ARES_FLAG_USEVC;\n        config->optmask       |= ARES_OPT_TCP_PORT;\n        break;\n\n      case 'U':\n        /* Set the UDP port number. */\n        if (!isdigit(*state.optarg)) {\n          snprintf(config->error, sizeof(config->error), \"invalid port number\");\n          return ARES_FALSE;\n        }\n        config->options.udp_port =\n          (unsigned short)strtol(state.optarg, NULL, 0);\n        config->optmask |= ARES_OPT_UDP_PORT;\n        break;\n\n      case ':':\n        snprintf(config->error, sizeof(config->error),\n                 \"%c requires an argument\", state.optopt);\n        return ARES_FALSE;\n\n      default:\n        snprintf(config->error, sizeof(config->error),\n                 \"unrecognized option: %c\", state.optopt);\n        return ARES_FALSE;\n    }\n  }\n\n  config->args_processed = state.optind;\n  if (config->args_processed >= argc) {\n    snprintf(config->error, sizeof(config->error), \"missing query name\");\n    return ARES_FALSE;\n  }\n  return ARES_TRUE;\n}",
          "fn_code_pos": [
            [
              148,
              0
            ],
            [
              251,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_cmdline",
            "parameters": {
              "argc": "int",
              "argv": "char",
              "config": "adig_config_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void print_flags(ares_dns_flags_t flags)\n{\n  if (flags & ARES_FLAG_QR) {\n    printf(\" qr\");\n  }\n  if (flags & ARES_FLAG_AA) {\n    printf(\" aa\");\n  }\n  if (flags & ARES_FLAG_TC) {\n    printf(\" tc\");\n  }\n  if (flags & ARES_FLAG_RD) {\n    printf(\" rd\");\n  }\n  if (flags & ARES_FLAG_RA) {\n    printf(\" ra\");\n  }\n  if (flags & ARES_FLAG_AD) {\n    printf(\" ad\");\n  }\n  if (flags & ARES_FLAG_CD) {\n    printf(\" cd\");\n  }\n}",
          "fn_code_pos": [
            [
              253,
              0
            ],
            [
              276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_flags",
            "parameters": {
              "flags": "ares_dns_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_header(const ares_dns_record_t *dnsrec)\n{\n  printf(\";; ->>HEADER<<- opcode: %s, status: %s, id: %u\\n\",\n         ares_dns_opcode_tostr(ares_dns_record_get_opcode(dnsrec)),\n         ares_dns_rcode_tostr(ares_dns_record_get_rcode(dnsrec)),\n         ares_dns_record_get_id(dnsrec));\n  printf(\";; flags:\");\n  print_flags(ares_dns_record_get_flags(dnsrec));\n  printf(\"; QUERY: %u, ANSWER: %u, AUTHORITY: %u, ADDITIONAL: %u\\n\\n\",\n         (unsigned int)ares_dns_record_query_cnt(dnsrec),\n         (unsigned int)ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER),\n         (unsigned int)ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_AUTHORITY),\n         (unsigned int)ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ADDITIONAL));\n}",
          "fn_code_pos": [
            [
              278,
              0
            ],
            [
              291,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_header",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_question(const ares_dns_record_t *dnsrec)\n{\n  size_t i;\n  printf(\";; QUESTION SECTION:\\n\");\n  for (i = 0; i < ares_dns_record_query_cnt(dnsrec); i++) {\n    const char         *name;\n    ares_dns_rec_type_t qtype;\n    ares_dns_class_t    qclass;\n    size_t              len;\n    if (ares_dns_record_query_get(dnsrec, i, &name, &qtype, &qclass) !=\n        ARES_SUCCESS) {\n      return;\n    }\n    if (name == NULL) {\n      return;\n    }\n    len = strlen(name);\n    printf(\";%s.\\t\", name);\n    if (len + 1 < 24) {\n      printf(\"\\t\");\n    }\n    if (len + 1 < 16) {\n      printf(\"\\t\");\n    }\n    printf(\"%s\\t%s\\n\", ares_dns_class_tostr(qclass),\n           ares_dns_rec_type_tostr(qtype));\n  }\n  printf(\"\\n\");\n}",
          "fn_code_pos": [
            [
              293,
              0
            ],
            [
              321,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_question",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_none(const unsigned char *val, size_t val_len)\n{\n  (void)val;\n  if (val_len != 0) {\n    printf(\"INVALID!\");\n  }\n}",
          "fn_code_pos": [
            [
              323,
              0
            ],
            [
              329,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_none",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_addr_list(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n  if (val_len % 4 != 0) {\n    printf(\"INVALID!\");\n    return;\n  }\n  for (i = 0; i < val_len; i += 4) {\n    char buf[256] = \"\";\n    ares_inet_ntop(AF_INET, val + i, buf, sizeof(buf));\n    if (i != 0) {\n      printf(\",\");\n    }\n    printf(\"%s\", buf);\n  }\n}",
          "fn_code_pos": [
            [
              331,
              0
            ],
            [
              346,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_addr_list",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_addr6_list(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n  if (val_len % 16 != 0) {\n    printf(\"INVALID!\");\n    return;\n  }\n  for (i = 0; i < val_len; i += 16) {\n    char buf[256] = \"\";\n\n    ares_inet_ntop(AF_INET6, val + i, buf, sizeof(buf));\n    if (i != 0) {\n      printf(\",\");\n    }\n    printf(\"%s\", buf);\n  }\n}",
          "fn_code_pos": [
            [
              348,
              0
            ],
            [
              364,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_addr6_list",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_u8_list(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n\n  for (i = 0; i < val_len; i++) {\n    if (i != 0) {\n      printf(\",\");\n    }\n    printf(\"%u\", (unsigned int)val[i]);\n  }\n}",
          "fn_code_pos": [
            [
              366,
              0
            ],
            [
              376,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_u8_list",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_u16_list(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n  if (val_len < 2 || val_len % 2 != 0) {\n    printf(\"INVALID!\");\n    return;\n  }\n  for (i = 0; i < val_len; i += 2) {\n    unsigned short u16 = 0;\n    unsigned short c;\n    /* Jumping over backwards to try to avoid odd compiler warnings */\n    c    = (unsigned short)val[i];\n    u16 |= (unsigned short)((c << 8) & 0xFFFF);\n    c    = (unsigned short)val[i + 1];\n    u16 |= c;\n    if (i != 0) {\n      printf(\",\");\n    }\n    printf(\"%u\", (unsigned int)u16);\n  }\n}",
          "fn_code_pos": [
            [
              378,
              0
            ],
            [
              398,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_u16_list",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_u32_list(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n  if (val_len < 4 || val_len % 4 != 0) {\n    printf(\"INVALID!\");\n    return;\n  }\n  for (i = 0; i < val_len; i += 4) {\n    unsigned int u32 = 0;\n\n    u32 |= (unsigned int)(val[i] << 24);\n    u32 |= (unsigned int)(val[i + 1] << 16);\n    u32 |= (unsigned int)(val[i + 2] << 8);\n    u32 |= (unsigned int)(val[i + 3]);\n    if (i != 0) {\n      printf(\",\");\n    }\n    printf(\"%u\", u32);\n  }\n}",
          "fn_code_pos": [
            [
              400,
              0
            ],
            [
              419,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_u32_list",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_str_list(const unsigned char *val, size_t val_len)\n{\n  size_t cnt = 0;\n\n  printf(\"\\\"\");\n  while (val_len) {\n    long           read_len = 0;\n    unsigned char *str      = NULL;\n    ares_status_t  status;\n\n    if (cnt) {\n      printf(\",\");\n    }\n\n    status = (ares_status_t)ares_expand_string(val, val, (int)val_len, &str,\n                                               &read_len);\n    if (status != ARES_SUCCESS) {\n      printf(\"INVALID\");\n      break;\n    }\n    printf(\"%s\", str);\n    ares_free_string(str);\n    val_len -= (size_t)read_len;\n    val     += read_len;\n    cnt++;\n  }\n  printf(\"\\\"\");\n}",
          "fn_code_pos": [
            [
              421,
              0
            ],
            [
              448,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_str_list",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_name(const unsigned char *val, size_t val_len)\n{\n  char *str      = NULL;\n  long  read_len = 0;\n\n  if (ares_expand_name(val, val, (int)val_len, &str, &read_len) !=\n      ARES_SUCCESS) {\n    printf(\"INVALID!\");\n    return;\n  }\n\n  printf(\"%s.\", str);\n  ares_free_string(str);\n}",
          "fn_code_pos": [
            [
              450,
              0
            ],
            [
              463,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_name",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_bin(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n\n  for (i = 0; i < val_len; i++) {\n    printf(\"%02x\", (unsigned int)val[i]);\n  }\n}",
          "fn_code_pos": [
            [
              465,
              0
            ],
            [
              472,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_bin",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_bool_t adig_isprint(int ch)\n{\n  if (ch >= 0x20 && ch <= 0x7E) {\n    return ARES_TRUE;\n  }\n  return ARES_FALSE;\n}",
          "fn_code_pos": [
            [
              474,
              0
            ],
            [
              480,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "adig_isprint",
            "parameters": {
              "ch": "int"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "static void print_opt_binp(const unsigned char *val, size_t val_len)\n{\n  size_t i;\n  printf(\"\\\"\");\n  for (i = 0; i < val_len; i++) {\n    if (adig_isprint(val[i])) {\n      printf(\"%c\", val[i]);\n    } else {\n      printf(\"\\\\%03d\", val[i]);\n    }\n  }\n  printf(\"\\\"\");\n}",
          "fn_code_pos": [
            [
              482,
              0
            ],
            [
              494,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_binp",
            "parameters": {
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opts(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  size_t i;\n\n  for (i = 0; i < ares_dns_rr_get_opt_cnt(rr, key); i++) {\n    size_t               val_len = 0;\n    const unsigned char *val     = NULL;\n    unsigned short       opt;\n    const char          *name;\n\n    if (i != 0) {\n      printf(\" \");\n    }\n\n    opt  = ares_dns_rr_get_opt(rr, key, i, &val, &val_len);\n    name = ares_dns_opt_get_name(key, opt);\n    if (name == NULL) {\n      printf(\"key%u\", (unsigned int)opt);\n    } else {\n      printf(\"%s\", name);\n    }\n    if (val_len == 0) {\n      return;\n    }\n\n    printf(\"=\");\n\n    switch (ares_dns_opt_get_datatype(key, opt)) {\n      case ARES_OPT_DATATYPE_NONE:\n        print_opt_none(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_U8_LIST:\n        print_opt_u8_list(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_INADDR4_LIST:\n        print_opt_addr_list(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_INADDR6_LIST:\n        print_opt_addr6_list(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_U16:\n      case ARES_OPT_DATATYPE_U16_LIST:\n        print_opt_u16_list(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_U32:\n      case ARES_OPT_DATATYPE_U32_LIST:\n        print_opt_u32_list(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_STR_LIST:\n        print_opt_str_list(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_BIN:\n        print_opt_bin(val, val_len);\n        break;\n      case ARES_OPT_DATATYPE_NAME:\n        print_opt_name(val, val_len);\n        break;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              496,
              0
            ],
            [
              555,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opts",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_addr(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  const struct in_addr *addr     = ares_dns_rr_get_addr(rr, key);\n  char                  buf[256] = \"\";\n\n  ares_inet_ntop(AF_INET, addr, buf, sizeof(buf));\n  printf(\"%s\", buf);\n}",
          "fn_code_pos": [
            [
              557,
              0
            ],
            [
              564,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_addr",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_addr6(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  const struct ares_in6_addr *addr     = ares_dns_rr_get_addr6(rr, key);\n  char                        buf[256] = \"\";\n\n  ares_inet_ntop(AF_INET6, addr, buf, sizeof(buf));\n  printf(\"%s\", buf);\n}",
          "fn_code_pos": [
            [
              566,
              0
            ],
            [
              573,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_addr6",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_u8(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  unsigned char u8 = ares_dns_rr_get_u8(rr, key);\n  printf(\"%u\", (unsigned int)u8);\n}",
          "fn_code_pos": [
            [
              575,
              0
            ],
            [
              579,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_u8",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_u16(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  unsigned short u16 = ares_dns_rr_get_u16(rr, key);\n  printf(\"%u\", (unsigned int)u16);\n}",
          "fn_code_pos": [
            [
              581,
              0
            ],
            [
              585,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_u16",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_u32(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  unsigned int u32 = ares_dns_rr_get_u32(rr, key);\n  printf(\"%u\", u32);\n}",
          "fn_code_pos": [
            [
              587,
              0
            ],
            [
              591,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_u32",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_name(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  const char *str = ares_dns_rr_get_str(rr, key);\n  printf(\"%s.\", str);\n}",
          "fn_code_pos": [
            [
              593,
              0
            ],
            [
              597,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_name",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_str(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  const char *str = ares_dns_rr_get_str(rr, key);\n  printf(\"\\\"%s\\\"\", str);\n}",
          "fn_code_pos": [
            [
              599,
              0
            ],
            [
              603,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_str",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_bin(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  size_t               len  = 0;\n  const unsigned char *binp = ares_dns_rr_get_bin(rr, key, &len);\n  print_opt_bin(binp, len);\n}",
          "fn_code_pos": [
            [
              605,
              0
            ],
            [
              610,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_bin",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_binp(const ares_dns_rr_t *rr, ares_dns_rr_key_t key)\n{\n  size_t               len;\n  const unsigned char *binp = ares_dns_rr_get_bin(rr, key, &len);\n\n  print_opt_binp(binp, len);\n}",
          "fn_code_pos": [
            [
              612,
              0
            ],
            [
              618,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_binp",
            "parameters": {
              "rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_rr(const ares_dns_rr_t *rr)\n{\n  const char              *name     = ares_dns_rr_get_name(rr);\n  size_t                   len      = 0;\n  size_t                   keys_cnt = 0;\n  ares_dns_rec_type_t      rtype    = ares_dns_rr_get_type(rr);\n  const ares_dns_rr_key_t *keys     = ares_dns_rr_get_keys(rtype, &keys_cnt);\n  size_t                   i;\n\n  if (name == NULL) {\n    return;\n  }\n\n  len = strlen(name);\n\n  printf(\"%s.\\t\", name);\n  if (len < 24) {\n    printf(\"\\t\");\n  }\n\n  printf(\"%u\\t%s\\t%s\\t\", ares_dns_rr_get_ttl(rr),\n         ares_dns_class_tostr(ares_dns_rr_get_class(rr)),\n         ares_dns_rec_type_tostr(rtype));\n\n  /* Output params here */\n  for (i = 0; i < keys_cnt; i++) {\n    ares_dns_datatype_t datatype = ares_dns_rr_key_datatype(keys[i]);\n    if (i != 0) {\n      printf(\" \");\n    }\n\n    switch (datatype) {\n      case ARES_DATATYPE_INADDR:\n        print_addr(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_INADDR6:\n        print_addr6(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_U8:\n        print_u8(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_U16:\n        print_u16(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_U32:\n        print_u32(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_NAME:\n        print_name(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_STR:\n        print_str(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_BIN:\n        print_bin(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_BINP:\n        print_binp(rr, keys[i]);\n        break;\n      case ARES_DATATYPE_OPT:\n        print_opts(rr, keys[i]);\n        break;\n    }\n  }\n\n  printf(\"\\n\");\n}",
          "fn_code_pos": [
            [
              620,
              0
            ],
            [
              686,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_rr",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static const ares_dns_rr_t *has_opt(ares_dns_record_t *dnsrec,\n                                    ares_dns_section_t section)\n{\n  size_t i;\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, section); i++) {\n    const ares_dns_rr_t *rr = ares_dns_record_rr_get(dnsrec, section, i);\n    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_OPT) {\n      return rr;\n    }\n  }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              688,
              0
            ],
            [
              699,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "has_opt",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "section": "ares_dns_section_t"
            },
            "return_type": "ares_dns_rr_t"
          }
        },
        {
          "fn_code": "static void print_section(ares_dns_record_t *dnsrec, ares_dns_section_t section)\n{\n  size_t i;\n\n  if (ares_dns_record_rr_cnt(dnsrec, section) == 0 ||\n      (ares_dns_record_rr_cnt(dnsrec, section) == 1 &&\n       has_opt(dnsrec, section) != NULL)) {\n    return;\n  }\n\n  printf(\";; %s SECTION:\\n\", ares_dns_section_tostr(section));\n  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, section); i++) {\n    const ares_dns_rr_t *rr = ares_dns_record_rr_get(dnsrec, section, i);\n    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_OPT) {\n      continue;\n    }\n    print_rr(rr);\n  }\n  printf(\"\\n\");\n}",
          "fn_code_pos": [
            [
              701,
              0
            ],
            [
              720,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_section",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "section": "ares_dns_section_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_opt_psuedosection(ares_dns_record_t *dnsrec)\n{\n  const ares_dns_rr_t *rr = has_opt(dnsrec, ARES_SECTION_ADDITIONAL);\n  if (rr == NULL) {\n    return;\n  }\n\n  printf(\";; OPT PSEUDOSECTION:\\n\");\n  printf(\"; EDNS: version: %u, flags: %u; udp: %u\\t\",\n         (unsigned int)ares_dns_rr_get_u8(rr, ARES_RR_OPT_VERSION),\n         (unsigned int)ares_dns_rr_get_u16(rr, ARES_RR_OPT_FLAGS),\n         (unsigned int)ares_dns_rr_get_u16(rr, ARES_RR_OPT_UDP_SIZE));\n\n  printf(\"\\n\");\n}",
          "fn_code_pos": [
            [
              722,
              0
            ],
            [
              736,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_opt_psuedosection",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void callback(void *arg, int status, int timeouts, unsigned char *abuf,\n                     int alen)\n{\n  ares_dns_record_t *dnsrec = NULL;\n  (void)arg;\n  (void)timeouts;\n\n  /* We got a \"Server status\" */\n  if (status >= ARES_SUCCESS && status <= ARES_EREFUSED) {\n    printf(\";; Got answer:\");\n  } else {\n    printf(\";;\");\n  }\n\n  if (status != ARES_SUCCESS) {\n    printf(\" %s\", ares_strerror(status));\n  }\n  printf(\"\\n\");\n\n  if (abuf == NULL || alen == 0) {\n    return;\n  }\n\n  status = (int)ares_dns_parse(abuf, (size_t)alen, 0, &dnsrec);\n  if (status != ARES_SUCCESS) {\n    fprintf(stderr, \";; FAILED TO PARSE DNS PACKET: %s\\n\",\n            ares_strerror(status));\n    return;\n  }\n\n  print_header(dnsrec);\n  print_opt_psuedosection(dnsrec);\n  print_question(dnsrec);\n  print_section(dnsrec, ARES_SECTION_ANSWER);\n  print_section(dnsrec, ARES_SECTION_ADDITIONAL);\n  print_section(dnsrec, ARES_SECTION_AUTHORITY);\n\n  printf(\";; MSG SIZE  rcvd: %d\\n\\n\", alen);\n  ares_dns_record_destroy(dnsrec);\n}",
          "fn_code_pos": [
            [
              738,
              0
            ],
            [
              777,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "callback",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "abuf": "unsigned char",
              "alen": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ares_status_t enqueue_query(ares_channel_t      *channel,\n                                   const adig_config_t *config,\n                                   const char          *name)\n{\n  ares_dns_record_t *dnsrec = NULL;\n  ares_dns_rr_t     *rr     = NULL;\n  ares_status_t      status;\n  unsigned char     *buf      = NULL;\n  size_t             buf_len  = 0;\n  unsigned short     flags    = 0;\n  char              *nametemp = NULL;\n\n  if (!(config->options.flags & ARES_FLAG_NORECURSE)) {\n    flags |= ARES_FLAG_RD;\n  }\n\n  status = ares_dns_record_create(&dnsrec, 0, flags, ARES_OPCODE_QUERY,\n                                  ARES_RCODE_NOERROR);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  /* If it is a PTR record, convert from ip address into in-arpa form\n   * automatically */\n  if (config->qtype == ARES_REC_TYPE_PTR) {\n    struct ares_addr addr;\n    size_t           len;\n    addr.family = AF_UNSPEC;\n\n    if (ares_dns_pton(name, &addr, &len) != NULL) {\n      nametemp = ares_dns_addr_to_ptr(&addr);\n      name     = nametemp;\n    }\n  }\n\n  status =\n    ares_dns_record_query_add(dnsrec, name, config->qtype, config->qclass);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  status = ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL, \"\",\n                                  ARES_REC_TYPE_OPT, ARES_CLASS_IN, 0);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n  ares_dns_rr_set_u16(rr, ARES_RR_OPT_UDP_SIZE, 1280);\n  ares_dns_rr_set_u8(rr, ARES_RR_OPT_VERSION, 0);\n\n  status = ares_dns_write(dnsrec, &buf, &buf_len);\n  if (status != ARES_SUCCESS) {\n    goto done;\n  }\n\n  ares_send(channel, buf, (int)buf_len, callback, NULL);\n  ares_free_string(buf);\n\ndone:\n  ares_free_string(nametemp);\n  ares_dns_record_destroy(dnsrec);\n  return status;\n}",
          "fn_code_pos": [
            [
              779,
              0
            ],
            [
              840,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "enqueue_query",
            "parameters": {
              "channel": "ares_channel_t",
              "config": "adig_config_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "static int event_loop(ares_channel_t *channel)\n{\n  while (1) {\n    fd_set          read_fds;\n    fd_set          write_fds;\n    int             nfds;\n    struct timeval  tv;\n    struct timeval *tvp;\n    int             count;\n\n    FD_ZERO(&read_fds);\n    FD_ZERO(&write_fds);\n    memset(&tv, 0, sizeof(tv));\n\n    nfds = ares_fds(channel, &read_fds, &write_fds);\n    if (nfds == 0) {\n      break;\n    }\n    tvp = ares_timeout(channel, NULL, &tv);\n    if (tvp == NULL) {\n      break;\n    }\n    count = select(nfds, &read_fds, &write_fds, NULL, tvp);\n    if (count < 0) {\n#ifdef USE_WINSOCK\n      int err = WSAGetLastError();\n#else\n      int err = errno;\n#endif\n      if (err != EAGAIN && err != EINTR) {\n        fprintf(stderr, \"select fail: %d\", err);\n        return 1;\n      }\n    }\n    ares_process(channel, &read_fds, &write_fds);\n  }\n  return 0;\n}",
          "fn_code_pos": [
            [
              842,
              0
            ],
            [
              879,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "event_loop",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int main(int argc, char **argv)\n{\n  ares_channel_t *channel = NULL;\n  ares_status_t   status;\n  adig_config_t   config;\n  int             i;\n  int             rv = 0;\n\n#ifdef USE_WINSOCK\n  WORD    wVersionRequested = MAKEWORD(USE_WINSOCK, USE_WINSOCK);\n  WSADATA wsaData;\n  WSAStartup(wVersionRequested, &wsaData);\n#endif\n\n  status = (ares_status_t)ares_library_init(ARES_LIB_INIT_ALL);\n  if (status != ARES_SUCCESS) {\n    fprintf(stderr, \"ares_library_init: %s\\n\", ares_strerror((int)status));\n    return 1;\n  }\n\n  memset(&config, 0, sizeof(config));\n  config.qclass = ARES_CLASS_IN;\n  config.qtype  = ARES_REC_TYPE_A;\n  if (!read_cmdline(argc, (const char **)argv, &config)) {\n    printf(\"\\n** ERROR: %s\\n\\n\", config.error);\n    print_help();\n    rv = 1;\n    goto done;\n  }\n\n  if (config.is_help) {\n    print_help();\n    goto done;\n  }\n\n  status =\n    (ares_status_t)ares_init_options(&channel, &config.options, config.optmask);\n  if (status != ARES_SUCCESS) {\n    fprintf(stderr, \"ares_init_options: %s\\n\", ares_strerror((int)status));\n    rv = 1;\n    goto done;\n  }\n\n  if (config.servers) {\n    status = (ares_status_t)ares_set_servers_ports_csv(channel, config.servers);\n    if (status != ARES_SUCCESS) {\n      fprintf(stderr, \"ares_set_servers_ports_csv: %s\\n\",\n              ares_strerror((int)status));\n      rv = 1;\n      goto done;\n    }\n  }\n\n  /* Enqueue a query for each separate name */\n  for (i = config.args_processed; i < argc; i++) {\n    status = enqueue_query(channel, &config, argv[i]);\n    if (status != ARES_SUCCESS) {\n      fprintf(stderr, \"Failed to create query for %s: %s\\n\", argv[i],\n              ares_strerror((int)status));\n      rv = 1;\n      goto done;\n    }\n  }\n\n  /* Debug */\n  printf(\"\\n; <<>> c-ares DiG %s <<>>\", ares_version(NULL));\n  for (i = config.args_processed; i < argc; i++) {\n    printf(\" %s\", argv[i]);\n  }\n  printf(\"\\n\");\n\n  /* Process events */\n  rv = event_loop(channel);\n\ndone:\n  free_config(&config);\n  ares_destroy(channel);\n  ares_library_cleanup();\n\n#ifdef USE_WINSOCK\n  WSACleanup();\n#endif\n  return rv;\n}",
          "fn_code_pos": [
            [
              881,
              0
            ],
            [
              964,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "has_opt(ares_dns_record_t *dnsrec,\n                                    ares_dns_section_t section)",
          "fn_dec_pos": [
            [
              688,
              28
            ],
            [
              689,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "has_opt",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "section": "ares_dns_section_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  ares_bool_t         is_help;\n  struct ares_options options;\n  int                 optmask;\n  ares_dns_class_t    qclass;\n  ares_dns_rec_type_t qtype;\n  int                 args_processed;\n  char               *servers;\n  char                error[256];\n} adig_config_t;",
          {
            "is_help": "ares_bool_t",
            "options": "struct ares_options",
            "optmask": "int",
            "qclass": "ares_dns_class_t",
            "qtype": "ares_dns_rec_type_t",
            "args_processed": "int",
            "*servers": "char",
            "error[256]": "char"
          },
          "adig_config_t",
          [
            69,
            0
          ],
          [
            78,
            16
          ]
        ],
        [
          "typedef struct {\n  const char *name;\n  int         value;\n} nv_t;",
          {
            "char": "const",
            "value": "int"
          },
          "nv_t",
          [
            80,
            0
          ],
          [
            83,
            7
          ]
        ],
        [
          "typedef struct {\n  ares_bool_t         is_help;\n  struct ares_options options;\n  int                 optmask;\n  ares_dns_class_t    qclass;\n  ares_dns_rec_type_t qtype;\n  int                 args_processed;\n  char               *servers;\n  char                error[256];\n} adig_config_t;",
          {
            "is_help": "ares_bool_t",
            "options": "struct ares_options",
            "optmask": "int",
            "qclass": "ares_dns_class_t",
            "qtype": "ares_dns_rec_type_t",
            "args_processed": "int",
            "*servers": "char",
            "error[256]": "char"
          },
          "adig_config_t",
          [
            69,
            0
          ],
          [
            78,
            16
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            71,
            2
          ],
          [
            71,
            21
          ]
        ],
        [
          "typedef struct {\n  const char *name;\n  int         value;\n} nv_t;",
          {
            "char": "const",
            "value": "int"
          },
          "nv_t",
          [
            80,
            0
          ],
          [
            83,
            7
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            559,
            8
          ],
          [
            559,
            22
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            568,
            8
          ],
          [
            568,
            28
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            804,
            4
          ],
          [
            804,
            20
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            848,
            4
          ],
          [
            848,
            18
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            849,
            4
          ],
          [
            849,
            18
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"ares_dns.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#  include \"ares_str.h\"\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#  include \"ares_strcasecmp.h\"\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#  include \"ares_strcasecmp.h\"\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include \"ares_getopt.h\"\n",
          [
            62,
            0
          ],
          [
            63,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/tools/ahost.c": {
      "fn_def_list": [
        {
          "fn_code": "int         main(int argc, char **argv)\n{\n  struct ares_options  options;\n  int                  optmask = 0;\n  ares_channel_t      *channel;\n  int                  status;\n  int                  nfds;\n  int                  c;\n  int                  addr_family = AF_UNSPEC;\n  fd_set               read_fds;\n  fd_set               write_fds;\n  struct timeval      *tvp;\n  struct timeval       tv;\n  struct in_addr       addr4;\n  struct ares_in6_addr addr6;\n  ares_getopt_state_t  state;\n  char                *servers = NULL;\n\n#ifdef USE_WINSOCK\n  WORD    wVersionRequested = MAKEWORD(USE_WINSOCK, USE_WINSOCK);\n  WSADATA wsaData;\n  WSAStartup(wVersionRequested, &wsaData);\n#endif\n\n  memset(&options, 0, sizeof(options));\n\n  status = ares_library_init(ARES_LIB_INIT_ALL);\n  if (status != ARES_SUCCESS) {\n    fprintf(stderr, \"ares_library_init: %s\\n\", ares_strerror(status));\n    return 1;\n  }\n\n  ares_getopt_init(&state, argc, (const char **)argv);\n  while ((c = ares_getopt(&state, \"dt:h?D:s:\")) != -1) {\n    switch (c) {\n      case 'd':\n#ifdef WATT32\n        dbug_init();\n#endif\n        break;\n      case 'D':\n        optmask |= ARES_OPT_DOMAINS;\n        options.ndomains++;\n        options.domains = (char **)realloc(\n          options.domains, (size_t)options.ndomains * sizeof(char *));\n        options.domains[options.ndomains - 1] = strdup(state.optarg);\n        break;\n      case 't':\n        if (!strcasecmp(state.optarg, \"a\")) {\n          addr_family = AF_INET;\n        } else if (!strcasecmp(state.optarg, \"aaaa\")) {\n          addr_family = AF_INET6;\n        } else if (!strcasecmp(state.optarg, \"u\")) {\n          addr_family = AF_UNSPEC;\n        } else {\n          usage();\n        }\n        break;\n      case 's':\n        if (state.optarg == NULL) {\n          fprintf(stderr, \"%s\", \"missing servers\");\n          usage();\n          break;\n        }\n        if (servers) {\n          free(servers);\n        }\n        servers = strdup(state.optarg);\n        break;\n      case 'h':\n      case '?':\n        print_help_info_ahost();\n        break;\n      default:\n        usage();\n        break;\n    }\n  }\n\n  argc -= state.optind;\n  argv += state.optind;\n  if (argc < 1) {\n    usage();\n  }\n\n  status = ares_init_options(&channel, &options, optmask);\n  if (status != ARES_SUCCESS) {\n    free(servers);\n    fprintf(stderr, \"ares_init: %s\\n\", ares_strerror(status));\n    return 1;\n  }\n\n  if (servers) {\n    status = ares_set_servers_csv(channel, servers);\n    if (status != ARES_SUCCESS) {\n      fprintf(stderr, \"ares_set_serveres_csv: %s\\n\", ares_strerror(status));\n      free(servers);\n      usage();\n      return 1;\n    }\n    free(servers);\n  }\n\n  /* Initiate the queries, one per command-line argument. */\n  for (; *argv; argv++) {\n    if (ares_inet_pton(AF_INET, *argv, &addr4) == 1) {\n      ares_gethostbyaddr(channel, &addr4, sizeof(addr4), AF_INET, callback,\n                         *argv);\n    } else if (ares_inet_pton(AF_INET6, *argv, &addr6) == 1) {\n      ares_gethostbyaddr(channel, &addr6, sizeof(addr6), AF_INET6, callback,\n                         *argv);\n    } else {\n      struct ares_addrinfo_hints hints;\n      memset(&hints, 0, sizeof(hints));\n      hints.ai_family = addr_family;\n      ares_getaddrinfo(channel, *argv, NULL, &hints, ai_callback, *argv);\n    }\n  }\n\n  /* Wait for all queries to complete. */\n  for (;;) {\n    int res;\n    FD_ZERO(&read_fds);\n    FD_ZERO(&write_fds);\n    nfds = ares_fds(channel, &read_fds, &write_fds);\n    if (nfds == 0) {\n      break;\n    }\n    tvp = ares_timeout(channel, NULL, &tv);\n    if (tvp == NULL) {\n      break;\n    }\n    res = select(nfds, &read_fds, &write_fds, NULL, tvp);\n    if (-1 == res) {\n      break;\n    }\n    ares_process(channel, &read_fds, &write_fds);\n  }\n\n  ares_destroy(channel);\n\n  ares_library_cleanup();\n\n#ifdef USE_WINSOCK\n  WSACleanup();\n#endif\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              213,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void callback(void *arg, int status, int timeouts, struct hostent *host)\n{\n  char **p;\n\n  (void)timeouts;\n\n  if (status != ARES_SUCCESS) {\n    fprintf(stderr, \"%s: %s\\n\", (char *)arg, ares_strerror(status));\n    return;\n  }\n\n  for (p = host->h_addr_list; *p; p++) {\n    char addr_buf[46] = \"??\";\n\n    ares_inet_ntop(host->h_addrtype, *p, addr_buf, sizeof(addr_buf));\n    printf(\"%-32s\\t%s\", host->h_name, addr_buf);\n    puts(\"\");\n  }\n}",
          "fn_code_pos": [
            [
              215,
              0
            ],
            [
              233,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "callback",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "host": "struct hostent"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ai_callback(void *arg, int status, int timeouts,\n                        struct ares_addrinfo *result)\n{\n  struct ares_addrinfo_node *node = NULL;\n  (void)timeouts;\n\n\n  if (status != ARES_SUCCESS) {\n    fprintf(stderr, \"%s: %s\\n\", (char *)arg, ares_strerror(status));\n    return;\n  }\n\n  for (node = result->nodes; node != NULL; node = node->ai_next) {\n    char        addr_buf[64] = \"\";\n    const void *ptr          = NULL;\n    if (node->ai_family == AF_INET) {\n      const struct sockaddr_in *in_addr =\n        (const struct sockaddr_in *)((void *)node->ai_addr);\n      ptr = &in_addr->sin_addr;\n    } else if (node->ai_family == AF_INET6) {\n      const struct sockaddr_in6 *in_addr =\n        (const struct sockaddr_in6 *)((void *)node->ai_addr);\n      ptr = &in_addr->sin6_addr;\n    } else {\n      continue;\n    }\n    ares_inet_ntop(node->ai_family, ptr, addr_buf, sizeof(addr_buf));\n    printf(\"%-32s\\t%s\\n\", result->name, addr_buf);\n  }\n\n  ares_freeaddrinfo(result);\n}",
          "fn_code_pos": [
            [
              235,
              0
            ],
            [
              266,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ai_callback",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "result": "struct ares_addrinfo"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void usage(void)\n{\n  fprintf(stderr, \"usage: ahost [-h] [-d] [[-D {domain}] ...] [-s {server}] \"\n                  \"[-t {a|aaaa|u}] {host|addr} ...\\n\");\n  exit(1);\n}",
          "fn_code_pos": [
            [
              268,
              0
            ],
            [
              273,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_help_info_ahost(void)\n{\n  printf(\"ahost, version %s\\n\\n\", ARES_VERSION_STR);\n  printf(\n    \"usage: ahost [-h] [-d] [-D domain] [-s server] [-t a|aaaa|u] host|addr \"\n    \"...\\n\\n\"\n    \"  -h : Display this help and exit.\\n\"\n    \"  -d : Print some extra debugging output.\\n\\n\"\n    \"  -D domain : Specify the domain to search instead of using the default \"\n    \"values\\n\"\n    \"  -s server : Connect to the specified DNS server, instead of the\\n\"\n    \"              system's default one(s). Servers are tried in round-robin,\\n\"\n    \"              if the previous one failed.\\n\"\n    \"  -t type   : If type is \\\"a\\\", print the A record.\\n\"\n    \"              If type is \\\"aaaa\\\", print the AAAA record.\\n\"\n    \"              If type is \\\"u\\\" (default), print both A and AAAA records.\\n\"\n    \"\\n\");\n  exit(0);\n}",
          "fn_code_pos": [
            [
              276,
              0
            ],
            [
              294,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_help_info_ahost",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "callback(void *arg, int status, int timeouts, struct hostent *host)",
          "fn_dec_pos": [
            [
              59,
              12
            ],
            [
              59,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "callback",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "host": "struct hostent"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ai_callback(void *arg, int status, int timeouts,\n                        struct ares_addrinfo *result)",
          "fn_dec_pos": [
            [
              60,
              12
            ],
            [
              61,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ai_callback",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "result": "struct ares_addrinfo"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              62,
              12
            ],
            [
              62,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "print_help_info_ahost(void)",
          "fn_dec_pos": [
            [
              63,
              12
            ],
            [
              63,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_help_info_ahost",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            59,
            58
          ],
          [
            59,
            72
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            61,
            24
          ],
          [
            61,
            44
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            67,
            2
          ],
          [
            67,
            21
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            76,
            2
          ],
          [
            76,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            77,
            2
          ],
          [
            77,
            16
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            78,
            2
          ],
          [
            78,
            16
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            79,
            2
          ],
          [
            79,
            22
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            177,
            6
          ],
          [
            177,
            32
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            215,
            58
          ],
          [
            215,
            72
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            236,
            24
          ],
          [
            236,
            44
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            238,
            2
          ],
          [
            238,
            27
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            251,
            12
          ],
          [
            251,
            30
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            252,
            15
          ],
          [
            252,
            33
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            255,
            12
          ],
          [
            255,
            31
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            256,
            15
          ],
          [
            256,
            34
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#  include <netdb.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#  include <strings.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include \"ares_dns.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include \"ares_getopt.h\"\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include \"ares_ipv6.h\"\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#  include \"ares_str.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#  include \"ares_strcasecmp.h\"\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#  include \"ares_strcasecmp.h\"\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/test.cc": {
      "fn_def_list": [
        {
          "fn_code": "double calculate_area() {\n        return length * breadth;\n    }",
          "fn_code_pos": [
            [
              14,
              4
            ],
            [
              16,
              5
            ]
          ],
          "class_code": "2b4f165567b3ce2172f7ffab0da3356e81ecf0b9d69ba22575ff4aea305666d1",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              25,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "calculate_area",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "double calculate_volume() {\n        return length * breadth * height;\n    }",
          "fn_code_pos": [
            [
              18,
              4
            ],
            [
              20,
              5
            ]
          ],
          "class_code": "2b4f165567b3ce2172f7ffab0da3356e81ecf0b9d69ba22575ff4aea305666d1",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              25,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "calculate_volume",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "double calculate_volume_11() {\n        return length * breadth * height;\n    }",
          "fn_code_pos": [
            [
              22,
              5
            ],
            [
              24,
              5
            ]
          ],
          "class_code": "2b4f165567b3ce2172f7ffab0da3356e81ecf0b9d69ba22575ff4aea305666d1",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              25,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "calculate_volume_11",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "double ddd() {\n        return length * breadth;\n    }",
          "fn_code_pos": [
            [
              35,
              4
            ],
            [
              37,
              5
            ]
          ],
          "class_code": "5783bc97d77e95cce8966764537b63d218c0f5709b3e3fee61bbe84c30940ec4",
          "class_node_pos": [
            [
              28,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ddd",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "double d2() {\n        return length * breadth * height;\n    }",
          "fn_code_pos": [
            [
              39,
              4
            ],
            [
              41,
              5
            ]
          ],
          "class_code": "5783bc97d77e95cce8966764537b63d218c0f5709b3e3fee61bbe84c30940ec4",
          "class_node_pos": [
            [
              28,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "d2",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "double d3() {\n        return length * breadth * height;\n    }",
          "fn_code_pos": [
            [
              43,
              5
            ],
            [
              45,
              5
            ]
          ],
          "class_code": "5783bc97d77e95cce8966764537b63d218c0f5709b3e3fee61bbe84c30940ec4",
          "class_node_pos": [
            [
              28,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "d3",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "int main() {\n\n    // create object of Room class\n    Room room1;\n\n    // assign values to data members\n    room1.length = 42.5;\n    room1.breadth = 30.8;\n    room1.height = 19.2;\n\n    // calculate and display the area and volume of the room\n    cout << \"Area of Room =  \" << room1.calculate_area() << endl;\n    cout << \"Volume of Room =  \" << room1.calculate_volume() << endl;\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "2b4f165567b3ce2172f7ffab0da3356e81ecf0b9d69ba22575ff4aea305666d1": {
          "class_code": "class Room {\n\n   public:\n    double length;\n    double breadth;\n    double height;\n\n    double calculate_area() {\n        return length * breadth;\n    }\n\n    double calculate_volume() {\n        return length * breadth * height;\n    }\n\n     double calculate_volume_11() {\n        return length * breadth * height;\n    }\n}",
          "class_name": "Room",
          "class_pos": [
            [
              7,
              0
            ],
            [
              25,
              1
            ]
          ]
        },
        "5783bc97d77e95cce8966764537b63d218c0f5709b3e3fee61bbe84c30940ec4": {
          "class_code": "class DDDDD {\n\n   public:\n    double length;\n    double breadth;\n    double height;\n\n    double ddd() {\n        return length * breadth;\n    }\n\n    double d2() {\n        return length * breadth * height;\n    }\n\n     double d3() {\n        return length * breadth * height;\n    }\n}",
          "class_name": "DDDDD",
          "class_pos": [
            [
              28,
              0
            ],
            [
              46,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <iostream>\n",
          [
            3,
            0
          ],
          [
            4,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    }
  },
  "head": {
    "../docker_shared/source_code/c-ares/src/lib/ares_private.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "_w32_GetHostsFile(void)",
          "fn_dec_pos": [
            [
              78,
              21
            ],
            [
              78,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_w32_GetHostsFile",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares__is_onion_domain(const char *name)",
          "fn_dec_pos": [
            [
              342,
              12
            ],
            [
              342,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__is_onion_domain",
            "parameters": {
              "name": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "(*ares_malloc)(size_t size)",
          "fn_dec_pos": [
            [
              345,
              13
            ],
            [
              345,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*ares_realloc)(void *ptr, size_t size)",
          "fn_dec_pos": [
            [
              346,
              13
            ],
            [
              346,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*ares_free)(void *ptr)",
          "fn_dec_pos": [
            [
              347,
              12
            ],
            [
              347,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_malloc_zero(size_t size)",
          "fn_dec_pos": [
            [
              348,
              14
            ],
            [
              348,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_malloc_zero",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_realloc_zero(void *ptr, size_t orig_size, size_t new_size)",
          "fn_dec_pos": [
            [
              349,
              14
            ],
            [
              349,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_realloc_zero",
            "parameters": {
              "ptr": "void",
              "orig_size": "size_t",
              "new_size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__timedout(const struct timeval *now,\n                             const struct timeval *check)",
          "fn_dec_pos": [
            [
              352,
              14
            ],
            [
              353,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__timedout",
            "parameters": {
              "now": "struct timeval",
              "check": "struct timeval"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__send_query(struct query *query, struct timeval *now)",
          "fn_dec_pos": [
            [
              356,
              14
            ],
            [
              356,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__send_query",
            "parameters": {
              "query": "struct query",
              "now": "struct timeval"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__requeue_query(struct query *query, struct timeval *now)",
          "fn_dec_pos": [
            [
              357,
              14
            ],
            [
              357,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__requeue_query",
            "parameters": {
              "query": "struct query",
              "now": "struct timeval"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__search_name_list(const ares_channel_t *channel,\n                                     const char *name, char ***names,\n                                     size_t *names_len)",
          "fn_dec_pos": [
            [
              370,
              14
            ],
            [
              372,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__search_name_list",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "names": "char",
              "names_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__dnsrec_convert_arg(ares_callback callback, void *arg)",
          "fn_dec_pos": [
            [
              376,
              14
            ],
            [
              376,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__dnsrec_convert_arg",
            "parameters": {
              "callback": "ares_callback",
              "arg": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__dnsrec_convert_cb(void *arg, ares_status_t status, size_t timeouts,\n                             const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              382,
              5
            ],
            [
              383,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__dnsrec_convert_cb",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__close_connection(struct server_connection *conn)",
          "fn_dec_pos": [
            [
              385,
              5
            ],
            [
              385,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__close_connection",
            "parameters": {
              "conn": "struct server_connection"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__close_sockets(struct server_state *server)",
          "fn_dec_pos": [
            [
              386,
              5
            ],
            [
              386,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__close_sockets",
            "parameters": {
              "server": "struct server_state"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__check_cleanup_conn(const ares_channel_t     *channel,\n                              struct server_connection *conn)",
          "fn_dec_pos": [
            [
              387,
              5
            ],
            [
              388,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__check_cleanup_conn",
            "parameters": {
              "channel": "ares_channel_t",
              "conn": "struct server_connection"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__free_query(struct query *query)",
          "fn_dec_pos": [
            [
              389,
              5
            ],
            [
              389,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__free_query",
            "parameters": {
              "query": "struct query"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__init_rand_state(void)",
          "fn_dec_pos": [
            [
              391,
              17
            ],
            [
              391,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_rand_state",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares__destroy_rand_state(ares_rand_state *state)",
          "fn_dec_pos": [
            [
              392,
              17
            ],
            [
              392,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__destroy_rand_state",
            "parameters": {
              "state": "ares_rand_state"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__rand_bytes(ares_rand_state *state, unsigned char *buf, size_t len)",
          "fn_dec_pos": [
            [
              393,
              5
            ],
            [
              393,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__rand_bytes",
            "parameters": {
              "state": "ares_rand_state",
              "buf": "unsigned char",
              "len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__generate_new_id(ares_rand_state *state)",
          "fn_dec_pos": [
            [
              395,
              15
            ],
            [
              395,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__generate_new_id",
            "parameters": {
              "state": "ares_rand_state"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__tvnow(void)",
          "fn_dec_pos": [
            [
              396,
              15
            ],
            [
              396,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__tvnow",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares__timeval_remaining(struct timeval       *remaining,\n                                       const struct timeval *now,\n                                       const struct timeval *tout)",
          "fn_dec_pos": [
            [
              397,
              15
            ],
            [
              399,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__timeval_remaining",
            "parameters": {
              "remaining": "struct timeval",
              "now": "struct timeval",
              "tout": "struct timeval"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__expand_name_validated(const unsigned char *encoded,\n                                           const unsigned char *abuf,\n                                           size_t alen, char **s, size_t *enclen,\n                                           ares_bool_t is_hostname)",
          "fn_dec_pos": [
            [
              400,
              15
            ],
            [
              403,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__expand_name_validated",
            "parameters": {
              "encoded": "unsigned char",
              "abuf": "unsigned char",
              "alen": "size_t",
              "s": "char",
              "enclen": "size_t",
              "is_hostname": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__expand_name_for_response(const unsigned char *encoded,\n                                              const unsigned char *abuf,\n                                              size_t alen, char **s,\n                                              size_t     *enclen,\n                                              ares_bool_t is_hostname)",
          "fn_dec_pos": [
            [
              404,
              15
            ],
            [
              408,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__expand_name_for_response",
            "parameters": {
              "encoded": "unsigned char",
              "abuf": "unsigned char",
              "alen": "size_t",
              "s": "char",
              "enclen": "size_t",
              "is_hostname": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_expand_string_ex(const unsigned char *encoded,\n                                     const unsigned char *abuf, size_t alen,\n                                     unsigned char **s, size_t *enclen)",
          "fn_dec_pos": [
            [
              409,
              15
            ],
            [
              411,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_expand_string_ex",
            "parameters": {
              "encoded": "unsigned char",
              "abuf": "unsigned char",
              "alen": "size_t",
              "s": "unsigned char",
              "enclen": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__init_servers_state(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              412,
              15
            ],
            [
              412,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_servers_state",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__init_by_options(ares_channel_t            *channel,\n                                     const struct ares_options *options,\n                                     int                        optmask)",
          "fn_dec_pos": [
            [
              413,
              15
            ],
            [
              415,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_by_options",
            "parameters": {
              "channel": "ares_channel_t",
              "options": "struct ares_options",
              "optmask": "int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__init_by_sysconfig(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              416,
              15
            ],
            [
              416,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_by_sysconfig",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__sysconfig_set_options(ares_sysconfig_t *sysconfig,\n                                          const char       *str)",
          "fn_dec_pos": [
            [
              432,
              14
            ],
            [
              433,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__sysconfig_set_options",
            "parameters": {
              "sysconfig": "ares_sysconfig_t",
              "str": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__init_by_environment(ares_sysconfig_t *sysconfig)",
          "fn_dec_pos": [
            [
              435,
              14
            ],
            [
              435,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_by_environment",
            "parameters": {
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__init_sysconfig_files(const ares_channel_t *channel,\n                                         ares_sysconfig_t     *sysconfig)",
          "fn_dec_pos": [
            [
              437,
              14
            ],
            [
              438,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_sysconfig_files",
            "parameters": {
              "channel": "ares_channel_t",
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__init_sysconfig_macos(ares_sysconfig_t *sysconfig)",
          "fn_dec_pos": [
            [
              440,
              14
            ],
            [
              440,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__init_sysconfig_macos",
            "parameters": {
              "sysconfig": "ares_sysconfig_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__parse_sortlist(struct apattern **sortlist, size_t *nsort,\n                                   const char *str)",
          "fn_dec_pos": [
            [
              443,
              14
            ],
            [
              444,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__parse_sortlist",
            "parameters": {
              "sortlist": "struct apattern",
              "nsort": "size_t",
              "str": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__destroy_servers_state(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              446,
              14
            ],
            [
              446,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__destroy_servers_state",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__lookup_hostaliases(const ares_channel_t *channel,\n                                       const char *name, char **alias)",
          "fn_dec_pos": [
            [
              451,
              14
            ],
            [
              452,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__lookup_hostaliases",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "alias": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__cat_domain(const char *name, const char *domain, char **s)",
          "fn_dec_pos": [
            [
              454,
              14
            ],
            [
              454,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__cat_domain",
            "parameters": {
              "name": "char",
              "domain": "char",
              "s": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__sortaddrinfo(ares_channel_t            *channel,\n                                 struct ares_addrinfo_node *ai_node)",
          "fn_dec_pos": [
            [
              455,
              14
            ],
            [
              456,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__sortaddrinfo",
            "parameters": {
              "channel": "ares_channel_t",
              "ai_node": "struct ares_addrinfo_node"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__freeaddrinfo_nodes(struct ares_addrinfo_node *ai_node)",
          "fn_dec_pos": [
            [
              458,
              14
            ],
            [
              458,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__freeaddrinfo_nodes",
            "parameters": {
              "ai_node": "struct ares_addrinfo_node"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__is_localhost(const char *name)",
          "fn_dec_pos": [
            [
              459,
              14
            ],
            [
              459,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__is_localhost",
            "parameters": {
              "name": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__append_addrinfo_node(struct ares_addrinfo_node **ai_node)",
          "fn_dec_pos": [
            [
              462,
              2
            ],
            [
              462,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__append_addrinfo_node",
            "parameters": {
              "ai_node": "struct ares_addrinfo_node"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__addrinfo_cat_nodes(struct ares_addrinfo_node **head,\n                              struct ares_addrinfo_node  *tail)",
          "fn_dec_pos": [
            [
              463,
              5
            ],
            [
              464,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__addrinfo_cat_nodes",
            "parameters": {
              "head": "struct ares_addrinfo_node",
              "tail": "struct ares_addrinfo_node"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__freeaddrinfo_cnames(struct ares_addrinfo_cname *ai_cname)",
          "fn_dec_pos": [
            [
              466,
              5
            ],
            [
              466,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__freeaddrinfo_cnames",
            "parameters": {
              "ai_cname": "struct ares_addrinfo_cname"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__append_addrinfo_cname(struct ares_addrinfo_cname **ai_cname)",
          "fn_dec_pos": [
            [
              469,
              2
            ],
            [
              469,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__append_addrinfo_cname",
            "parameters": {
              "ai_cname": "struct ares_addrinfo_cname"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_append_ai_node(int aftype, unsigned short port,\n                                  unsigned int ttl, const void *adata,\n                                  struct ares_addrinfo_node **nodes)",
          "fn_dec_pos": [
            [
              471,
              14
            ],
            [
              473,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_append_ai_node",
            "parameters": {
              "aftype": "int",
              "port": "unsigned short",
              "ttl": "unsigned int",
              "adata": "void",
              "nodes": "struct ares_addrinfo_node"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__addrinfo_cat_cnames(struct ares_addrinfo_cname **head,\n                                        struct ares_addrinfo_cname  *tail)",
          "fn_dec_pos": [
            [
              475,
              14
            ],
            [
              476,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__addrinfo_cat_cnames",
            "parameters": {
              "head": "struct ares_addrinfo_cname",
              "tail": "struct ares_addrinfo_cname"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__parse_into_addrinfo(const ares_dns_record_t *dnsrec,\n                                        ares_bool_t    cname_only_is_enodata,\n                                        unsigned short port,\n                                        struct ares_addrinfo *ai)",
          "fn_dec_pos": [
            [
              478,
              14
            ],
            [
              481,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__parse_into_addrinfo",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "cname_only_is_enodata": "ares_bool_t",
              "port": "unsigned short",
              "ai": "struct ares_addrinfo"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_parse_ptr_reply_dnsrec(const ares_dns_record_t *dnsrec,\n                                          const void *addr, int addrlen,\n                                          int family, struct hostent **host)",
          "fn_dec_pos": [
            [
              482,
              14
            ],
            [
              484,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_ptr_reply_dnsrec",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "addr": "void",
              "addrlen": "int",
              "family": "int",
              "host": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__addrinfo2hostent(const struct ares_addrinfo *ai, int family,\n                                     struct hostent **host)",
          "fn_dec_pos": [
            [
              486,
              14
            ],
            [
              487,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__addrinfo2hostent",
            "parameters": {
              "ai": "struct ares_addrinfo",
              "family": "int",
              "host": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__addrinfo2addrttl(const struct ares_addrinfo *ai, int family,\n                                     size_t                req_naddrttls,\n                                     struct ares_addrttl  *addrttls,\n                                     struct ares_addr6ttl *addr6ttls,\n                                     size_t               *naddrttls)",
          "fn_dec_pos": [
            [
              488,
              14
            ],
            [
              492,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__addrinfo2addrttl",
            "parameters": {
              "ai": "struct ares_addrinfo",
              "family": "int",
              "req_naddrttls": "size_t",
              "addrttls": "struct ares_addrttl",
              "addr6ttls": "struct ares_addr6ttl",
              "naddrttls": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__addrinfo_localhost(const char *name, unsigned short port,\n                                       const struct ares_addrinfo_hints *hints,\n                                       struct ares_addrinfo             *ai)",
          "fn_dec_pos": [
            [
              493,
              14
            ],
            [
              495,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__addrinfo_localhost",
            "parameters": {
              "name": "char",
              "port": "unsigned short",
              "hints": "struct ares_addrinfo_hints",
              "ai": "struct ares_addrinfo"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__open_connection(ares_channel_t      *channel,\n                                    struct server_state *server,\n                                    ares_bool_t          is_tcp)",
          "fn_dec_pos": [
            [
              496,
              14
            ],
            [
              498,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__open_connection",
            "parameters": {
              "channel": "ares_channel_t",
              "server": "struct server_state",
              "is_tcp": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__open_socket(ares_channel_t *channel, int af, int type,\n                                int protocol)",
          "fn_dec_pos": [
            [
              499,
              14
            ],
            [
              500,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__open_socket",
            "parameters": {
              "channel": "ares_channel_t",
              "af": "int",
              "type": "int",
              "protocol": "int"
            },
            "return_type": "ares_socket_t"
          }
        },
        {
          "fn_code": "ares__socket_write(ares_channel_t *channel, ares_socket_t s,\n                                 const void *data, size_t len)",
          "fn_dec_pos": [
            [
              501,
              14
            ],
            [
              502,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__socket_write",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_socket_t",
              "data": "void",
              "len": "size_t"
            },
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "ares__socket_recvfrom(ares_channel_t *channel, ares_socket_t s,\n                                    void *data, size_t data_len, int flags,\n                                    struct sockaddr *from,\n                                    ares_socklen_t  *from_len)",
          "fn_dec_pos": [
            [
              503,
              14
            ],
            [
              506,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__socket_recvfrom",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_socket_t",
              "data": "void",
              "data_len": "size_t",
              "flags": "int",
              "from": "struct sockaddr",
              "from_len": "ares_socklen_t"
            },
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "ares__socket_recv(ares_channel_t *channel, ares_socket_t s,\n                                void *data, size_t data_len)",
          "fn_dec_pos": [
            [
              507,
              14
            ],
            [
              508,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__socket_recv",
            "parameters": {
              "channel": "ares_channel_t",
              "s": "ares_socket_t",
              "data": "void",
              "data_len": "size_t"
            },
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "ares__close_socket(ares_channel, ares_socket_t)",
          "fn_dec_pos": [
            [
              509,
              14
            ],
            [
              509,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__close_socket",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__connect_socket(ares_channel_t *channel, ares_socket_t sockfd,\n                          const struct sockaddr *addr, ares_socklen_t addrlen)",
          "fn_dec_pos": [
            [
              510,
              5
            ],
            [
              511,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__connect_socket",
            "parameters": {
              "channel": "ares_channel_t",
              "sockfd": "ares_socket_t",
              "addr": "struct sockaddr",
              "addrlen": "ares_socklen_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares__destroy_server(struct server_state *server)",
          "fn_dec_pos": [
            [
              512,
              5
            ],
            [
              512,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__destroy_server",
            "parameters": {
              "server": "struct server_state"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__servers_update(ares_channel_t *channel,\n                                   ares__llist_t  *server_list,\n                                   ares_bool_t     user_specified)",
          "fn_dec_pos": [
            [
              514,
              14
            ],
            [
              516,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__servers_update",
            "parameters": {
              "channel": "ares_channel_t",
              "server_list": "ares__llist_t",
              "user_specified": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__sconfig_append(ares__llist_t         **sconfig,\n                                   const struct ares_addr *addr,\n                                   unsigned short          udp_port,\n                                   unsigned short          tcp_port,\n                                   const char             *ll_iface)",
          "fn_dec_pos": [
            [
              517,
              14
            ],
            [
              521,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__sconfig_append",
            "parameters": {
              "sconfig": "ares__llist_t",
              "addr": "struct ares_addr",
              "udp_port": "unsigned short",
              "tcp_port": "unsigned short",
              "ll_iface": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__sconfig_append_fromstr(ares__llist_t **sconfig,\n                                           const char     *str,\n                                           ares_bool_t     ignore_invalid)",
          "fn_dec_pos": [
            [
              522,
              14
            ],
            [
              524,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__sconfig_append_fromstr",
            "parameters": {
              "sconfig": "ares__llist_t",
              "str": "char",
              "ignore_invalid": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_in_addr_to_server_config_llist(const struct in_addr *servers,\n                                                  size_t          nservers,\n                                                  ares__llist_t **llist)",
          "fn_dec_pos": [
            [
              525,
              14
            ],
            [
              527,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_in_addr_to_server_config_llist",
            "parameters": {
              "servers": "struct in_addr",
              "nservers": "size_t",
              "llist": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_get_server_addr(const struct server_state *server,\n                                   ares__buf_t               *buf)",
          "fn_dec_pos": [
            [
              528,
              14
            ],
            [
              529,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_server_addr",
            "parameters": {
              "server": "struct server_state",
              "buf": "ares__buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__hosts_file_destroy(ares_hosts_file_t *hf)",
          "fn_dec_pos": [
            [
              534,
              32
            ],
            [
              534,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_file_destroy",
            "parameters": {
              "hf": "ares_hosts_file_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__hosts_search_ipaddr(ares_channel_t *channel,\n                                        ares_bool_t use_env, const char *ipaddr,\n                                        const ares_hosts_entry_t **entry)",
          "fn_dec_pos": [
            [
              535,
              14
            ],
            [
              537,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_search_ipaddr",
            "parameters": {
              "channel": "ares_channel_t",
              "use_env": "ares_bool_t",
              "ipaddr": "char",
              "entry": "ares_hosts_entry_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__hosts_search_host(ares_channel_t *channel,\n                                      ares_bool_t use_env, const char *host,\n                                      const ares_hosts_entry_t **entry)",
          "fn_dec_pos": [
            [
              538,
              14
            ],
            [
              540,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_search_host",
            "parameters": {
              "channel": "ares_channel_t",
              "use_env": "ares_bool_t",
              "host": "char",
              "entry": "ares_hosts_entry_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__hosts_entry_to_hostent(const ares_hosts_entry_t *entry,\n                                           int                       family,\n                                           struct hostent          **hostent)",
          "fn_dec_pos": [
            [
              541,
              14
            ],
            [
              543,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_entry_to_hostent",
            "parameters": {
              "entry": "ares_hosts_entry_t",
              "family": "int",
              "hostent": "struct hostent"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__hosts_entry_to_addrinfo(const ares_hosts_entry_t *entry,\n                                            const char *name, int family,\n                                            unsigned short        port,\n                                            ares_bool_t           want_cnames,\n                                            struct ares_addrinfo *ai)",
          "fn_dec_pos": [
            [
              544,
              14
            ],
            [
              548,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__hosts_entry_to_addrinfo",
            "parameters": {
              "entry": "ares_hosts_entry_t",
              "name": "char",
              "family": "int",
              "port": "unsigned short",
              "want_cnames": "ares_bool_t",
              "ai": "struct ares_addrinfo"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__dns_name_parse(ares__buf_t *buf, char **name,\n                                   ares_bool_t is_hostname)",
          "fn_dec_pos": [
            [
              565,
              14
            ],
            [
              566,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__dns_name_parse",
            "parameters": {
              "buf": "ares__buf_t",
              "name": "char",
              "is_hostname": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__dns_name_write(ares__buf_t *buf, ares__llist_t **list,\n                                   ares_bool_t validate_hostname,\n                                   const char *name)",
          "fn_dec_pos": [
            [
              585,
              14
            ],
            [
              587,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__dns_name_write",
            "parameters": {
              "buf": "ares__buf_t",
              "list": "ares__llist_t",
              "validate_hostname": "ares_bool_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_queue_notify_empty(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              596,
              14
            ],
            [
              596,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_queue_notify_empty",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__subnet_match(const struct ares_addr *addr,\n                                 const struct ares_addr *subnet,\n                                 unsigned char           netmask)",
          "fn_dec_pos": [
            [
              617,
              14
            ],
            [
              619,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__subnet_match",
            "parameters": {
              "addr": "struct ares_addr",
              "subnet": "struct ares_addr",
              "netmask": "unsigned char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__addr_is_linklocal(const struct ares_addr *addr)",
          "fn_dec_pos": [
            [
              620,
              14
            ],
            [
              620,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__addr_is_linklocal",
            "parameters": {
              "addr": "struct ares_addr"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__round_up_pow2(size_t n)",
          "fn_dec_pos": [
            [
              622,
              14
            ],
            [
              622,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__round_up_pow2",
            "parameters": {
              "n": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares__log2(size_t n)",
          "fn_dec_pos": [
            [
              623,
              14
            ],
            [
              623,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__log2",
            "parameters": {
              "n": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares__pow(size_t x, size_t y)",
          "fn_dec_pos": [
            [
              624,
              14
            ],
            [
              624,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__pow",
            "parameters": {
              "x": "size_t",
              "y": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares__count_digits(size_t n)",
          "fn_dec_pos": [
            [
              625,
              14
            ],
            [
              625,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__count_digits",
            "parameters": {
              "n": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares__count_hexdigits(size_t n)",
          "fn_dec_pos": [
            [
              626,
              14
            ],
            [
              626,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__count_hexdigits",
            "parameters": {
              "n": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares__count_bits_u8(unsigned char x)",
          "fn_dec_pos": [
            [
              627,
              14
            ],
            [
              627,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__count_bits_u8",
            "parameters": {
              "x": "unsigned char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__qcache_destroy(ares__qcache_t *cache)",
          "fn_dec_pos": [
            [
              628,
              14
            ],
            [
              628,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__qcache_destroy",
            "parameters": {
              "cache": "ares__qcache_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__qcache_create(ares_rand_state *rand_state,\n                                  unsigned int     max_ttl,\n                                  ares__qcache_t **cache_out)",
          "fn_dec_pos": [
            [
              629,
              14
            ],
            [
              631,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__qcache_create",
            "parameters": {
              "rand_state": "ares_rand_state",
              "max_ttl": "unsigned int",
              "cache_out": "ares__qcache_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__qcache_flush(ares__qcache_t *cache)",
          "fn_dec_pos": [
            [
              632,
              14
            ],
            [
              632,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__qcache_flush",
            "parameters": {
              "cache": "ares__qcache_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_qcache_insert(ares_channel_t       *channel,\n                                 const struct timeval *now,\n                                 const struct query   *query,\n                                 ares_dns_record_t    *dnsrec)",
          "fn_dec_pos": [
            [
              633,
              14
            ],
            [
              636,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_insert",
            "parameters": {
              "channel": "ares_channel_t",
              "now": "struct timeval",
              "query": "struct query",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_qcache_fetch(ares_channel_t           *channel,\n                                const struct timeval     *now,\n                                const ares_dns_record_t  *dnsrec,\n                                const ares_dns_record_t **dnsrec_resp)",
          "fn_dec_pos": [
            [
              637,
              14
            ],
            [
              640,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_qcache_fetch",
            "parameters": {
              "channel": "ares_channel_t",
              "now": "struct timeval",
              "dnsrec": "ares_dns_record_t",
              "dnsrec_resp": "ares_dns_record_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__channel_threading_init(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              642,
              14
            ],
            [
              642,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__channel_threading_init",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__channel_threading_destroy(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              643,
              14
            ],
            [
              643,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__channel_threading_destroy",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__channel_lock(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              644,
              14
            ],
            [
              644,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__channel_lock",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__channel_unlock(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              645,
              14
            ],
            [
              645,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__channel_unlock",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_event_thread_destroy(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              650,
              14
            ],
            [
              650,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread_destroy",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_event_thread_init(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              651,
              14
            ],
            [
              651,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_thread_init",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct server_connection {\n  struct server_state *server;\n  ares_socket_t        fd;\n  ares_bool_t          is_tcp;\n  /* total number of queries run on this connection since it was established */\n  size_t               total_queries;\n  /* list of outstanding queries to this connection */\n  ares__llist_t       *queries_to_conn;\n}",
          {
            "*server": "struct server_state",
            "fd": "ares_socket_t",
            "is_tcp": "ares_bool_t",
            "total_queries": "size_t",
            "*queries_to_conn": "ares__llist_t"
          },
          "server_connection",
          [
            158,
            0
          ],
          [
            166,
            1
          ]
        ],
        [
          "struct server_state {\n  /* Configuration */\n  size_t                    idx; /* index for server in system configuration */\n  struct ares_addr          addr;\n  unsigned short            udp_port;        /* host byte order */\n  unsigned short            tcp_port;        /* host byte order */\n  char                      ll_iface[64];    /* IPv6 Link Local Interface */\n  unsigned int              ll_scope;        /* IPv6 Link Local Scope */\n\n  size_t                    consec_failures; /* Consecutive query failure count\n                                              * can be hard errors or timeouts\n                                              */\n  ares__llist_t            *connections;\n  struct server_connection *tcp_conn;\n\n  /* The next time when we will retry this server if it has hit failures */\n  struct timeval            next_retry_time;\n\n  /* TCP buffer since multiple responses can come back in one read, or partial\n   * in a read */\n  ares__buf_t              *tcp_parser;\n\n  /* TCP output queue */\n  ares__buf_t              *tcp_send;\n\n  /* Link back to owning channel */\n  ares_channel_t           *channel;\n}",
          {
            "idx": "size_t",
            "addr": "struct ares_addr",
            "udp_port": "unsigned short",
            "tcp_port": "unsigned short",
            "ll_iface[64]": "char",
            "ll_scope": "unsigned int",
            "consec_failures": "size_t",
            "*connections": "ares__llist_t",
            "*tcp_conn": "struct server_connection",
            "next_retry_time": "struct timeval",
            "*tcp_parser": "ares__buf_t",
            "*tcp_send": "ares__buf_t",
            "*channel": "ares_channel_t"
          },
          "server_state",
          [
            168,
            0
          ],
          [
            195,
            1
          ]
        ],
        [
          "struct query {\n  /* Query ID from qbuf, for faster lookup, and current timeout */\n  unsigned short            qid; /* host byte order */\n  struct timeval            timeout;\n  ares_channel_t           *channel;\n\n  /*\n   * Node object for each list entry the query belongs to in order to\n   * make removal operations O(1).\n   */\n  ares__slist_node_t       *node_queries_by_timeout;\n  ares__llist_node_t       *node_queries_to_conn;\n  ares__llist_node_t       *node_all_queries;\n\n  /* connection handle query is associated with */\n  struct server_connection *conn;\n\n  /* Arguments passed to ares_send() */\n  unsigned char            *qbuf;\n  size_t                    qlen;\n\n  ares_callback_dnsrec      callback;\n  void                     *arg;\n\n  /* Query status */\n  size_t        try_count; /* Number of times we tried this query already. */\n  ares_bool_t   using_tcp;\n  ares_status_t error_status;\n  size_t        timeouts; /* number of timeouts we saw for this request */\n  ares_bool_t no_retries; /* do not perform any additional retries, this is set\n                           * when a query is to be canceled */\n}",
          {
            "qid": "unsigned short",
            "timeout": "struct timeval",
            "*channel": "ares_channel_t",
            "*node_queries_by_timeout": "ares__slist_node_t",
            "*node_queries_to_conn": "ares__llist_node_t",
            "*node_all_queries": "ares__llist_node_t",
            "*conn": "struct server_connection",
            "*qbuf": "unsigned char",
            "qlen": "size_t",
            "callback": "ares_callback_dnsrec",
            "*arg": "void",
            "try_count": "size_t",
            "using_tcp": "ares_bool_t",
            "error_status": "ares_status_t",
            "timeouts": "size_t",
            "no_retries": "ares_bool_t"
          },
          "query",
          [
            198,
            0
          ],
          [
            229,
            1
          ]
        ],
        [
          "struct apattern {\n  struct ares_addr addr;\n  unsigned char    mask;\n}",
          {
            "addr": "struct ares_addr",
            "mask": "unsigned char"
          },
          "apattern",
          [
            231,
            0
          ],
          [
            234,
            1
          ]
        ],
        [
          "struct ares_channeldata {\n  /* Configuration data */\n  unsigned int          flags;\n  size_t                timeout; /* in milliseconds */\n  size_t                tries;\n  size_t                ndots;\n  size_t                maxtimeout;              /* in milliseconds */\n  ares_bool_t           rotate;\n  unsigned short        udp_port;                /* stored in network order */\n  unsigned short        tcp_port;                /* stored in network order */\n  int                   socket_send_buffer_size; /* setsockopt takes int */\n  int                   socket_receive_buffer_size; /* setsockopt takes int */\n  char                **domains;\n  size_t                ndomains;\n  struct apattern      *sortlist;\n  size_t                nsort;\n  char                 *lookups;\n  size_t                ednspsz;\n  unsigned int          qcache_max_ttl;\n  ares_evsys_t          evsys;\n  unsigned int          optmask;\n\n  /* For binding to local devices and/or IP addresses.  Leave\n   * them null/zero for no binding.\n   */\n  char                  local_dev_name[32];\n  unsigned int          local_ip4;\n  unsigned char         local_ip6[16];\n\n  /* Thread safety lock */\n  ares__thread_mutex_t *lock;\n\n  /* Conditional to wake waiters when queue is empty */\n  ares__thread_cond_t  *cond_empty;\n\n  /* Server addresses and communications state. Sorted by least consecutive\n   * failures, followed by the configuration order if failures are equal. */\n  ares__slist_t        *servers;\n\n  /* random state to use when generating new ids and generating retry penalties\n   */\n  ares_rand_state      *rand_state;\n\n  /* All active queries in a single list */\n  ares__llist_t        *all_queries;\n  /* Queries bucketed by qid, for quickly dispatching DNS responses: */\n  ares__htable_szvp_t  *queries_by_qid;\n\n  /* Queries bucketed by timeout, for quickly handling timeouts: */\n  ares__slist_t        *queries_by_timeout;\n\n  /* Map linked list node member for connection to file descriptor.  We use\n   * the node instead of the connection object itself so we can quickly look\n   * up a connection and remove it if necessary (as otherwise we'd have to\n   * scan all connections) */\n  ares__htable_asvp_t  *connnode_by_socket;\n\n  ares_sock_state_cb    sock_state_cb;\n  void                 *sock_state_cb_data;\n\n  ares_sock_create_callback           sock_create_cb;\n  void                               *sock_create_cb_data;\n\n  ares_sock_config_callback           sock_config_cb;\n  void                               *sock_config_cb_data;\n\n  const struct ares_socket_functions *sock_funcs;\n  void                               *sock_func_cb_data;\n\n  /* Path for resolv.conf file, configurable via ares_options */\n  char                               *resolvconf_path;\n\n  /* Path for hosts file, configurable via ares_options */\n  char                               *hosts_path;\n\n  /* Maximum UDP queries per connection allowed */\n  size_t                              udp_max_queries;\n\n  /* Cache of local hosts file */\n  ares_hosts_file_t                  *hf;\n\n  /* Query Cache */\n  ares__qcache_t                     *qcache;\n\n  /* Fields controlling server failover behavior.\n   * The retry chance is the probability (1/N) by which we will retry a failed\n   * server instead of the best server when selecting a server to send queries\n   * to.\n   * The retry delay is the minimum time in milliseconds to wait between doing\n   * such retries (applied per-server).\n   */\n  unsigned short                      server_retry_chance;\n  size_t                              server_retry_delay;\n\n  /* Callback triggered when a server has a successful or failed response */\n  ares_server_state_callback          server_state_cb;\n  void                               *server_state_cb_data;\n}",
          {
            "flags": "unsigned int",
            "timeout": "size_t",
            "tries": "size_t",
            "ndots": "size_t",
            "maxtimeout": "size_t",
            "rotate": "ares_bool_t",
            "udp_port": "unsigned short",
            "tcp_port": "unsigned short",
            "socket_send_buffer_size": "int",
            "socket_receive_buffer_size": "int",
            "**domains": "char",
            "ndomains": "size_t",
            "*sortlist": "struct apattern",
            "nsort": "size_t",
            "*lookups": "char",
            "ednspsz": "size_t",
            "qcache_max_ttl": "unsigned int",
            "evsys": "ares_evsys_t",
            "optmask": "unsigned int",
            "local_dev_name[32]": "char",
            "local_ip4": "unsigned int",
            "local_ip6[16]": "unsigned char",
            "*lock": "ares__thread_mutex_t",
            "*cond_empty": "ares__thread_cond_t",
            "*servers": "ares__slist_t",
            "*rand_state": "ares_rand_state",
            "*all_queries": "ares__llist_t",
            "*queries_by_qid": "ares__htable_szvp_t",
            "*queries_by_timeout": "ares__slist_t",
            "*connnode_by_socket": "ares__htable_asvp_t",
            "sock_state_cb": "ares_sock_state_cb",
            "*sock_state_cb_data": "void",
            "sock_create_cb": "ares_sock_create_callback",
            "*sock_create_cb_data": "void",
            "sock_config_cb": "ares_sock_config_callback",
            "*sock_config_cb_data": "void",
            "struct ares_socket_functions": "const",
            "*sock_func_cb_data": "void",
            "*resolvconf_path": "char",
            "*hosts_path": "char",
            "udp_max_queries": "size_t",
            "*hf": "ares_hosts_file_t",
            "*qcache": "ares__qcache_t",
            "server_retry_chance": "unsigned short",
            "server_retry_delay": "size_t",
            "server_state_cb": "ares_server_state_callback",
            "*server_state_cb_data": "void"
          },
          "ares_channeldata",
          [
            242,
            0
          ],
          [
            339,
            1
          ]
        ],
        [
          "typedef struct {\n  ares__llist_t   *sconfig;\n  struct apattern *sortlist;\n  size_t           nsortlist;\n  char           **domains;\n  size_t           ndomains;\n  char            *lookups;\n  size_t           ndots;\n  size_t           tries;\n  ares_bool_t      rotate;\n  size_t           timeout_ms;\n  ares_bool_t      usevc;\n} ares_sysconfig_t;",
          {
            "*sconfig": "ares__llist_t",
            "*sortlist": "struct apattern",
            "nsortlist": "size_t",
            "**domains": "char",
            "ndomains": "size_t",
            "*lookups": "char",
            "ndots": "size_t",
            "tries": "size_t",
            "rotate": "ares_bool_t",
            "timeout_ms": "size_t",
            "usevc": "ares_bool_t"
          },
          "ares_sysconfig_t",
          [
            418,
            0
          ],
          [
            430,
            19
          ]
        ],
        [
          "struct ares_rand_state",
          {},
          "",
          [
            108,
            0
          ],
          [
            108,
            22
          ]
        ],
        [
          "typedef struct ares_rand_state ares_rand_state;",
          {},
          "ares_rand_state",
          [
            109,
            0
          ],
          [
            109,
            47
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            154,
            0
          ],
          [
            154,
            12
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            156,
            0
          ],
          [
            156,
            19
          ]
        ],
        [
          "struct server_connection {\n  struct server_state *server;\n  ares_socket_t        fd;\n  ares_bool_t          is_tcp;\n  /* total number of queries run on this connection since it was established */\n  size_t               total_queries;\n  /* list of outstanding queries to this connection */\n  ares__llist_t       *queries_to_conn;\n}",
          {
            "*server": "struct server_state",
            "fd": "ares_socket_t",
            "is_tcp": "ares_bool_t",
            "total_queries": "size_t",
            "*queries_to_conn": "ares__llist_t"
          },
          "server_connection",
          [
            158,
            0
          ],
          [
            166,
            1
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            159,
            2
          ],
          [
            159,
            21
          ]
        ],
        [
          "struct server_state {\n  /* Configuration */\n  size_t                    idx; /* index for server in system configuration */\n  struct ares_addr          addr;\n  unsigned short            udp_port;        /* host byte order */\n  unsigned short            tcp_port;        /* host byte order */\n  char                      ll_iface[64];    /* IPv6 Link Local Interface */\n  unsigned int              ll_scope;        /* IPv6 Link Local Scope */\n\n  size_t                    consec_failures; /* Consecutive query failure count\n                                              * can be hard errors or timeouts\n                                              */\n  ares__llist_t            *connections;\n  struct server_connection *tcp_conn;\n\n  /* The next time when we will retry this server if it has hit failures */\n  struct timeval            next_retry_time;\n\n  /* TCP buffer since multiple responses can come back in one read, or partial\n   * in a read */\n  ares__buf_t              *tcp_parser;\n\n  /* TCP output queue */\n  ares__buf_t              *tcp_send;\n\n  /* Link back to owning channel */\n  ares_channel_t           *channel;\n}",
          {
            "idx": "size_t",
            "addr": "struct ares_addr",
            "udp_port": "unsigned short",
            "tcp_port": "unsigned short",
            "ll_iface[64]": "char",
            "ll_scope": "unsigned int",
            "consec_failures": "size_t",
            "*connections": "ares__llist_t",
            "*tcp_conn": "struct server_connection",
            "next_retry_time": "struct timeval",
            "*tcp_parser": "ares__buf_t",
            "*tcp_send": "ares__buf_t",
            "*channel": "ares_channel_t"
          },
          "server_state",
          [
            168,
            0
          ],
          [
            195,
            1
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            171,
            2
          ],
          [
            171,
            18
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            181,
            2
          ],
          [
            181,
            26
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            184,
            2
          ],
          [
            184,
            16
          ]
        ],
        [
          "struct query {\n  /* Query ID from qbuf, for faster lookup, and current timeout */\n  unsigned short            qid; /* host byte order */\n  struct timeval            timeout;\n  ares_channel_t           *channel;\n\n  /*\n   * Node object for each list entry the query belongs to in order to\n   * make removal operations O(1).\n   */\n  ares__slist_node_t       *node_queries_by_timeout;\n  ares__llist_node_t       *node_queries_to_conn;\n  ares__llist_node_t       *node_all_queries;\n\n  /* connection handle query is associated with */\n  struct server_connection *conn;\n\n  /* Arguments passed to ares_send() */\n  unsigned char            *qbuf;\n  size_t                    qlen;\n\n  ares_callback_dnsrec      callback;\n  void                     *arg;\n\n  /* Query status */\n  size_t        try_count; /* Number of times we tried this query already. */\n  ares_bool_t   using_tcp;\n  ares_status_t error_status;\n  size_t        timeouts; /* number of timeouts we saw for this request */\n  ares_bool_t no_retries; /* do not perform any additional retries, this is set\n                           * when a query is to be canceled */\n}",
          {
            "qid": "unsigned short",
            "timeout": "struct timeval",
            "*channel": "ares_channel_t",
            "*node_queries_by_timeout": "ares__slist_node_t",
            "*node_queries_to_conn": "ares__llist_node_t",
            "*node_all_queries": "ares__llist_node_t",
            "*conn": "struct server_connection",
            "*qbuf": "unsigned char",
            "qlen": "size_t",
            "callback": "ares_callback_dnsrec",
            "*arg": "void",
            "try_count": "size_t",
            "using_tcp": "ares_bool_t",
            "error_status": "ares_status_t",
            "timeouts": "size_t",
            "no_retries": "ares_bool_t"
          },
          "query",
          [
            198,
            0
          ],
          [
            229,
            1
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            201,
            2
          ],
          [
            201,
            16
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            213,
            2
          ],
          [
            213,
            26
          ]
        ],
        [
          "struct apattern {\n  struct ares_addr addr;\n  unsigned char    mask;\n}",
          {
            "addr": "struct ares_addr",
            "mask": "unsigned char"
          },
          "apattern",
          [
            231,
            0
          ],
          [
            234,
            1
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            232,
            2
          ],
          [
            232,
            18
          ]
        ],
        [
          "struct ares__qcache",
          {},
          "",
          [
            236,
            0
          ],
          [
            236,
            19
          ]
        ],
        [
          "typedef struct ares__qcache ares__qcache_t;",
          {},
          "ares__qcache_t",
          [
            237,
            0
          ],
          [
            237,
            43
          ]
        ],
        [
          "struct ares_hosts_file",
          {},
          "",
          [
            239,
            0
          ],
          [
            239,
            22
          ]
        ],
        [
          "typedef struct ares_hosts_file ares_hosts_file_t;",
          {},
          "ares_hosts_file_t",
          [
            240,
            0
          ],
          [
            240,
            49
          ]
        ],
        [
          "struct ares_channeldata {\n  /* Configuration data */\n  unsigned int          flags;\n  size_t                timeout; /* in milliseconds */\n  size_t                tries;\n  size_t                ndots;\n  size_t                maxtimeout;              /* in milliseconds */\n  ares_bool_t           rotate;\n  unsigned short        udp_port;                /* stored in network order */\n  unsigned short        tcp_port;                /* stored in network order */\n  int                   socket_send_buffer_size; /* setsockopt takes int */\n  int                   socket_receive_buffer_size; /* setsockopt takes int */\n  char                **domains;\n  size_t                ndomains;\n  struct apattern      *sortlist;\n  size_t                nsort;\n  char                 *lookups;\n  size_t                ednspsz;\n  unsigned int          qcache_max_ttl;\n  ares_evsys_t          evsys;\n  unsigned int          optmask;\n\n  /* For binding to local devices and/or IP addresses.  Leave\n   * them null/zero for no binding.\n   */\n  char                  local_dev_name[32];\n  unsigned int          local_ip4;\n  unsigned char         local_ip6[16];\n\n  /* Thread safety lock */\n  ares__thread_mutex_t *lock;\n\n  /* Conditional to wake waiters when queue is empty */\n  ares__thread_cond_t  *cond_empty;\n\n  /* Server addresses and communications state. Sorted by least consecutive\n   * failures, followed by the configuration order if failures are equal. */\n  ares__slist_t        *servers;\n\n  /* random state to use when generating new ids and generating retry penalties\n   */\n  ares_rand_state      *rand_state;\n\n  /* All active queries in a single list */\n  ares__llist_t        *all_queries;\n  /* Queries bucketed by qid, for quickly dispatching DNS responses: */\n  ares__htable_szvp_t  *queries_by_qid;\n\n  /* Queries bucketed by timeout, for quickly handling timeouts: */\n  ares__slist_t        *queries_by_timeout;\n\n  /* Map linked list node member for connection to file descriptor.  We use\n   * the node instead of the connection object itself so we can quickly look\n   * up a connection and remove it if necessary (as otherwise we'd have to\n   * scan all connections) */\n  ares__htable_asvp_t  *connnode_by_socket;\n\n  ares_sock_state_cb    sock_state_cb;\n  void                 *sock_state_cb_data;\n\n  ares_sock_create_callback           sock_create_cb;\n  void                               *sock_create_cb_data;\n\n  ares_sock_config_callback           sock_config_cb;\n  void                               *sock_config_cb_data;\n\n  const struct ares_socket_functions *sock_funcs;\n  void                               *sock_func_cb_data;\n\n  /* Path for resolv.conf file, configurable via ares_options */\n  char                               *resolvconf_path;\n\n  /* Path for hosts file, configurable via ares_options */\n  char                               *hosts_path;\n\n  /* Maximum UDP queries per connection allowed */\n  size_t                              udp_max_queries;\n\n  /* Cache of local hosts file */\n  ares_hosts_file_t                  *hf;\n\n  /* Query Cache */\n  ares__qcache_t                     *qcache;\n\n  /* Fields controlling server failover behavior.\n   * The retry chance is the probability (1/N) by which we will retry a failed\n   * server instead of the best server when selecting a server to send queries\n   * to.\n   * The retry delay is the minimum time in milliseconds to wait between doing\n   * such retries (applied per-server).\n   */\n  unsigned short                      server_retry_chance;\n  size_t                              server_retry_delay;\n\n  /* Callback triggered when a server has a successful or failed response */\n  ares_server_state_callback          server_state_cb;\n  void                               *server_state_cb_data;\n}",
          {
            "flags": "unsigned int",
            "timeout": "size_t",
            "tries": "size_t",
            "ndots": "size_t",
            "maxtimeout": "size_t",
            "rotate": "ares_bool_t",
            "udp_port": "unsigned short",
            "tcp_port": "unsigned short",
            "socket_send_buffer_size": "int",
            "socket_receive_buffer_size": "int",
            "**domains": "char",
            "ndomains": "size_t",
            "*sortlist": "struct apattern",
            "nsort": "size_t",
            "*lookups": "char",
            "ednspsz": "size_t",
            "qcache_max_ttl": "unsigned int",
            "evsys": "ares_evsys_t",
            "optmask": "unsigned int",
            "local_dev_name[32]": "char",
            "local_ip4": "unsigned int",
            "local_ip6[16]": "unsigned char",
            "*lock": "ares__thread_mutex_t",
            "*cond_empty": "ares__thread_cond_t",
            "*servers": "ares__slist_t",
            "*rand_state": "ares_rand_state",
            "*all_queries": "ares__llist_t",
            "*queries_by_qid": "ares__htable_szvp_t",
            "*queries_by_timeout": "ares__slist_t",
            "*connnode_by_socket": "ares__htable_asvp_t",
            "sock_state_cb": "ares_sock_state_cb",
            "*sock_state_cb_data": "void",
            "sock_create_cb": "ares_sock_create_callback",
            "*sock_create_cb_data": "void",
            "sock_config_cb": "ares_sock_config_callback",
            "*sock_config_cb_data": "void",
            "struct ares_socket_functions": "const",
            "*sock_func_cb_data": "void",
            "*resolvconf_path": "char",
            "*hosts_path": "char",
            "udp_max_queries": "size_t",
            "*hf": "ares_hosts_file_t",
            "*qcache": "ares__qcache_t",
            "server_retry_chance": "unsigned short",
            "server_retry_delay": "size_t",
            "server_state_cb": "ares_server_state_callback",
            "*server_state_cb_data": "void"
          },
          "ares_channeldata",
          [
            242,
            0
          ],
          [
            339,
            1
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            256,
            2
          ],
          [
            256,
            17
          ]
        ],
        [
          "struct ares_socket_functions",
          {},
          "",
          [
            308,
            8
          ],
          [
            308,
            36
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            352,
            35
          ],
          [
            352,
            49
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            353,
            35
          ],
          [
            353,
            49
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            356,
            31
          ],
          [
            356,
            43
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            356,
            52
          ],
          [
            356,
            66
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            357,
            34
          ],
          [
            357,
            46
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            357,
            55
          ],
          [
            357,
            69
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            385,
            28
          ],
          [
            385,
            52
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            386,
            25
          ],
          [
            386,
            44
          ]
        ],
        [
          "struct server_connection",
          {},
          "",
          [
            388,
            30
          ],
          [
            388,
            54
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            389,
            22
          ],
          [
            389,
            34
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            396,
            0
          ],
          [
            396,
            14
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            397,
            39
          ],
          [
            397,
            53
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            398,
            45
          ],
          [
            398,
            59
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            399,
            45
          ],
          [
            399,
            59
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            414,
            43
          ],
          [
            414,
            62
          ]
        ],
        [
          "typedef struct {\n  ares__llist_t   *sconfig;\n  struct apattern *sortlist;\n  size_t           nsortlist;\n  char           **domains;\n  size_t           ndomains;\n  char            *lookups;\n  size_t           ndots;\n  size_t           tries;\n  ares_bool_t      rotate;\n  size_t           timeout_ms;\n  ares_bool_t      usevc;\n} ares_sysconfig_t;",
          {
            "*sconfig": "ares__llist_t",
            "*sortlist": "struct apattern",
            "nsortlist": "size_t",
            "**domains": "char",
            "ndomains": "size_t",
            "*lookups": "char",
            "ndots": "size_t",
            "tries": "size_t",
            "rotate": "ares_bool_t",
            "timeout_ms": "size_t",
            "usevc": "ares_bool_t"
          },
          "ares_sysconfig_t",
          [
            418,
            0
          ],
          [
            430,
            19
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            420,
            2
          ],
          [
            420,
            17
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            443,
            35
          ],
          [
            443,
            50
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            456,
            33
          ],
          [
            456,
            58
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            458,
            39
          ],
          [
            458,
            64
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            461,
            0
          ],
          [
            461,
            25
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            462,
            29
          ],
          [
            462,
            54
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            463,
            30
          ],
          [
            463,
            55
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            464,
            30
          ],
          [
            464,
            55
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            466,
            31
          ],
          [
            466,
            57
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            468,
            0
          ],
          [
            468,
            26
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            469,
            30
          ],
          [
            469,
            56
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            473,
            34
          ],
          [
            473,
            59
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            475,
            40
          ],
          [
            475,
            66
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            476,
            40
          ],
          [
            476,
            66
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            481,
            40
          ],
          [
            481,
            60
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            484,
            54
          ],
          [
            484,
            68
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            486,
            43
          ],
          [
            486,
            63
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            487,
            37
          ],
          [
            487,
            51
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            488,
            43
          ],
          [
            488,
            63
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            490,
            37
          ],
          [
            490,
            56
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            491,
            37
          ],
          [
            491,
            57
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            494,
            45
          ],
          [
            494,
            71
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            495,
            39
          ],
          [
            495,
            59
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            497,
            36
          ],
          [
            497,
            55
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            505,
            36
          ],
          [
            505,
            51
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            511,
            32
          ],
          [
            511,
            47
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            512,
            26
          ],
          [
            512,
            45
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            518,
            41
          ],
          [
            518,
            57
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            525,
            56
          ],
          [
            525,
            70
          ]
        ],
        [
          "struct server_state",
          {},
          "",
          [
            528,
            41
          ],
          [
            528,
            60
          ]
        ],
        [
          "struct ares_hosts_entry",
          {},
          "",
          [
            531,
            0
          ],
          [
            531,
            23
          ]
        ],
        [
          "typedef struct ares_hosts_entry ares_hosts_entry_t;",
          {},
          "ares_hosts_entry_t",
          [
            532,
            0
          ],
          [
            532,
            51
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            543,
            43
          ],
          [
            543,
            57
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            548,
            44
          ],
          [
            548,
            64
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            617,
            39
          ],
          [
            617,
            55
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            618,
            39
          ],
          [
            618,
            55
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            620,
            44
          ],
          [
            620,
            60
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            634,
            39
          ],
          [
            634,
            53
          ]
        ],
        [
          "struct query",
          {},
          "",
          [
            635,
            39
          ],
          [
            635,
            51
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            638,
            38
          ],
          [
            638,
            52
          ]
        ],
        [
          "struct ares_event_thread",
          {},
          "",
          [
            647,
            0
          ],
          [
            647,
            24
          ]
        ],
        [
          "typedef struct ares_event_thread ares_event_thread_t;",
          {},
          "ares_event_thread_t",
          [
            648,
            0
          ],
          [
            648,
            53
          ]
        ]
      ],
      "include_list": [
        [
          "#  include <netinet/in.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <tcp.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#  include <sys/ioctl.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include \"ares_ipv6.h\"\n",
          [
            106,
            0
          ],
          [
            107,
            0
          ]
        ],
        [
          "#include \"ares__llist.h\"\n",
          [
            111,
            0
          ],
          [
            112,
            0
          ]
        ],
        [
          "#include \"ares__slist.h\"\n",
          [
            112,
            0
          ],
          [
            113,
            0
          ]
        ],
        [
          "#include \"ares__htable_strvp.h\"\n",
          [
            113,
            0
          ],
          [
            114,
            0
          ]
        ],
        [
          "#include \"ares__htable_szvp.h\"\n",
          [
            114,
            0
          ],
          [
            115,
            0
          ]
        ],
        [
          "#include \"ares__htable_asvp.h\"\n",
          [
            115,
            0
          ],
          [
            116,
            0
          ]
        ],
        [
          "#include \"ares__buf.h\"\n",
          [
            116,
            0
          ],
          [
            117,
            0
          ]
        ],
        [
          "#include \"ares_dns_private.h\"\n",
          [
            117,
            0
          ],
          [
            118,
            0
          ]
        ],
        [
          "#include \"ares__iface_ips.h\"\n",
          [
            118,
            0
          ],
          [
            119,
            0
          ]
        ],
        [
          "#include \"ares__threads.h\"\n",
          [
            119,
            0
          ],
          [
            120,
            0
          ]
        ],
        [
          "#  include \"ares_getenv.h\"\n",
          [
            122,
            0
          ],
          [
            123,
            0
          ]
        ],
        [
          "#include \"ares_str.h\"\n",
          [
            126,
            0
          ],
          [
            127,
            0
          ]
        ],
        [
          "#include \"ares_strsplit.h\"\n",
          [
            127,
            0
          ],
          [
            128,
            0
          ]
        ],
        [
          "#  include \"ares_strcasecmp.h\"\n",
          [
            130,
            0
          ],
          [
            131,
            0
          ]
        ],
        [
          "#  include \"ares_strcasecmp.h\"\n",
          [
            135,
            0
          ],
          [
            136,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__slist.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*ares__slist_destructor_t)(void *data)",
          "fn_dec_pos": [
            [
              65,
              13
            ],
            [
              65,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares__slist_cmp_t)(const void *data1, const void *data2)",
          "fn_dec_pos": [
            [
              73,
              12
            ],
            [
              73,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "data1": "void",
              "data2": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares__slist_create(ares_rand_state         *rand_state,\n                                       ares__slist_cmp_t        cmp,\n                                       ares__slist_destructor_t destruct)",
          "fn_dec_pos": [
            [
              82,
              20
            ],
            [
              84,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_create",
            "parameters": {
              "rand_state": "ares_rand_state",
              "cmp": "ares__slist_cmp_t",
              "destruct": "ares__slist_destructor_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_replace_destructor(ares__slist_t           *list,\n                                                   ares__slist_destructor_t destruct)",
          "fn_dec_pos": [
            [
              91,
              20
            ],
            [
              92,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_replace_destructor",
            "parameters": {
              "list": "ares__slist_t",
              "destruct": "ares__slist_destructor_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__slist_insert(ares__slist_t *list, void *val)",
          "fn_dec_pos": [
            [
              101,
              20
            ],
            [
              101,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_insert",
            "parameters": {
              "list": "ares__slist_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_node_first(ares__slist_t *list)",
          "fn_dec_pos": [
            [
              108,
              20
            ],
            [
              108,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_first",
            "parameters": {
              "list": "ares__slist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_node_last(ares__slist_t *list)",
          "fn_dec_pos": [
            [
              115,
              20
            ],
            [
              115,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_last",
            "parameters": {
              "list": "ares__slist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_node_next(ares__slist_node_t *node)",
          "fn_dec_pos": [
            [
              122,
              20
            ],
            [
              122,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_next",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_node_prev(ares__slist_node_t *node)",
          "fn_dec_pos": [
            [
              129,
              20
            ],
            [
              129,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_prev",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_node_find(ares__slist_t *list, const void *val)",
          "fn_dec_pos": [
            [
              137,
              20
            ],
            [
              137,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_find",
            "parameters": {
              "list": "ares__slist_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_node_val(ares__slist_node_t *node)",
          "fn_dec_pos": [
            [
              145,
              20
            ],
            [
              145,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_val",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_len(const ares__slist_t *list)",
          "fn_dec_pos": [
            [
              152,
              20
            ],
            [
              152,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_len",
            "parameters": {
              "list": "ares__slist_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares__slist_node_parent(ares__slist_node_t *node)",
          "fn_dec_pos": [
            [
              159,
              20
            ],
            [
              159,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_parent",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_first_val(ares__slist_t *list)",
          "fn_dec_pos": [
            [
              166,
              20
            ],
            [
              166,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_first_val",
            "parameters": {
              "list": "ares__slist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_last_val(ares__slist_t *list)",
          "fn_dec_pos": [
            [
              173,
              20
            ],
            [
              173,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_last_val",
            "parameters": {
              "list": "ares__slist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_node_claim(ares__slist_node_t *node)",
          "fn_dec_pos": [
            [
              180,
              20
            ],
            [
              180,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_claim",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__slist_node_reinsert(ares__slist_node_t *node)",
          "fn_dec_pos": [
            [
              189,
              20
            ],
            [
              189,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_reinsert",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__slist_node_destroy(ares__slist_node_t *node)",
          "fn_dec_pos": [
            [
              195,
              20
            ],
            [
              195,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_node_destroy",
            "parameters": {
              "node": "ares__slist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__slist_destroy(ares__slist_t *list)",
          "fn_dec_pos": [
            [
              201,
              20
            ],
            [
              201,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__slist_destroy",
            "parameters": {
              "list": "ares__slist_t"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares__slist",
          {},
          "",
          [
            51,
            0
          ],
          [
            51,
            18
          ]
        ],
        [
          "typedef struct ares__slist ares__slist_t;",
          {},
          "ares__slist_t",
          [
            54,
            0
          ],
          [
            54,
            41
          ]
        ],
        [
          "struct ares__slist_node",
          {},
          "",
          [
            56,
            0
          ],
          [
            56,
            23
          ]
        ],
        [
          "typedef struct ares__slist_node ares__slist_node_t;",
          {},
          "ares__slist_node_t",
          [
            59,
            0
          ],
          [
            59,
            51
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_event_win32.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(NTAPI *PIO_APC_ROUTINE)(PVOID            ApcContext,\n                                     PIO_STATUS_BLOCK IoStatusBlock,\n                                     ULONG            Reserved)",
          "fn_dec_pos": [
            [
              57,
              12
            ],
            [
              59,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ApcContext": "PVOID",
              "IoStatusBlock": "PIO_STATUS_BLOCK",
              "Reserved": "ULONG"
            },
            "return_type": "VOID"
          }
        },
        {
          "fn_code": "(NTAPI *NtCancelIoFileEx_t)(HANDLE           FileHandle,\n                                            PIO_STATUS_BLOCK IoRequestToCancel,\n                                            PIO_STATUS_BLOCK IoStatusBlock)",
          "fn_dec_pos": [
            [
              95,
              16
            ],
            [
              97,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "FileHandle": "HANDLE",
              "IoRequestToCancel": "PIO_STATUS_BLOCK",
              "IoStatusBlock": "PIO_STATUS_BLOCK"
            },
            "return_type": "NTSTATUS"
          }
        },
        {
          "fn_code": "(NTAPI *NtDeviceIoControlFile_t)(\n  HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext,\n  PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer,\n  ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength)",
          "fn_dec_pos": [
            [
              98,
              16
            ],
            [
              101,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "FileHandle": "HANDLE",
              "Event": "HANDLE",
              "ApcRoutine": "PIO_APC_ROUTINE",
              "ApcContext": "PVOID",
              "IoStatusBlock": "PIO_STATUS_BLOCK",
              "IoControlCode": "ULONG",
              "InputBuffer": "PVOID",
              "InputBufferLength": "ULONG",
              "OutputBuffer": "PVOID",
              "OutputBufferLength": "ULONG"
            },
            "return_type": "NTSTATUS"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct _IO_STATUS_BLOCK {\n  union {\n    NTSTATUS Status;\n    PVOID    Pointer;\n  };\n\n  ULONG_PTR Information;\n} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;",
          {
            ";": "union {\n    NTSTATUS Status;\n    PVOID    Pointer;\n  }",
            "Status": "NTSTATUS",
            "Pointer": "PVOID",
            "Information": "ULONG_PTR"
          },
          "IO_STATUS_BLOCK",
          [
            48,
            0
          ],
          [
            55,
            37
          ]
        ],
        [
          "typedef struct _IO_STATUS_BLOCK {\n  union {\n    NTSTATUS Status;\n    PVOID    Pointer;\n  };\n\n  ULONG_PTR Information;\n} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;",
          {
            ";": "union {\n    NTSTATUS Status;\n    PVOID    Pointer;\n  }",
            "Status": "NTSTATUS",
            "Pointer": "PVOID",
            "Information": "ULONG_PTR"
          },
          "PIO_STATUS_BLOCK",
          [
            48,
            0
          ],
          [
            55,
            37
          ]
        ],
        [
          "typedef struct _AFD_POLL_HANDLE_INFO {\n  HANDLE   Handle;\n  ULONG    Events;\n  NTSTATUS Status;\n} AFD_POLL_HANDLE_INFO, *PAFD_POLL_HANDLE_INFO;",
          {
            "Handle": "HANDLE",
            "Events": "ULONG",
            "Status": "NTSTATUS"
          },
          "AFD_POLL_HANDLE_INFO",
          [
            81,
            0
          ],
          [
            85,
            47
          ]
        ],
        [
          "typedef struct _AFD_POLL_HANDLE_INFO {\n  HANDLE   Handle;\n  ULONG    Events;\n  NTSTATUS Status;\n} AFD_POLL_HANDLE_INFO, *PAFD_POLL_HANDLE_INFO;",
          {
            "Handle": "HANDLE",
            "Events": "ULONG",
            "Status": "NTSTATUS"
          },
          "PAFD_POLL_HANDLE_INFO",
          [
            81,
            0
          ],
          [
            85,
            47
          ]
        ],
        [
          "typedef struct _AFD_POLL_INFO {\n  LARGE_INTEGER        Timeout;\n  ULONG                NumberOfHandles;\n  ULONG                Exclusive;\n  AFD_POLL_HANDLE_INFO Handles[1];\n} AFD_POLL_INFO, *PAFD_POLL_INFO;",
          {
            "Timeout": "LARGE_INTEGER",
            "NumberOfHandles": "ULONG",
            "Exclusive": "ULONG",
            "Handles[1]": "AFD_POLL_HANDLE_INFO"
          },
          "AFD_POLL_INFO",
          [
            87,
            0
          ],
          [
            92,
            33
          ]
        ],
        [
          "typedef struct _AFD_POLL_INFO {\n  LARGE_INTEGER        Timeout;\n  ULONG                NumberOfHandles;\n  ULONG                Exclusive;\n  AFD_POLL_HANDLE_INFO Handles[1];\n} AFD_POLL_INFO, *PAFD_POLL_INFO;",
          {
            "Timeout": "LARGE_INTEGER",
            "NumberOfHandles": "ULONG",
            "Exclusive": "ULONG",
            "Handles[1]": "AFD_POLL_HANDLE_INFO"
          },
          "PAFD_POLL_INFO",
          [
            87,
            0
          ],
          [
            92,
            33
          ]
        ],
        [
          "typedef struct _IO_STATUS_BLOCK {\n  union {\n    NTSTATUS Status;\n    PVOID    Pointer;\n  };\n\n  ULONG_PTR Information;\n} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;",
          {
            ";": "union {\n    NTSTATUS Status;\n    PVOID    Pointer;\n  }",
            "Status": "NTSTATUS",
            "Pointer": "PVOID",
            "Information": "ULONG_PTR"
          },
          "IO_STATUS_BLOCK",
          [
            48,
            0
          ],
          [
            55,
            37
          ]
        ],
        [
          "typedef struct _IO_STATUS_BLOCK {\n  union {\n    NTSTATUS Status;\n    PVOID    Pointer;\n  };\n\n  ULONG_PTR Information;\n} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;",
          {
            ";": "union {\n    NTSTATUS Status;\n    PVOID    Pointer;\n  }",
            "Status": "NTSTATUS",
            "Pointer": "PVOID",
            "Information": "ULONG_PTR"
          },
          "PIO_STATUS_BLOCK",
          [
            48,
            0
          ],
          [
            55,
            37
          ]
        ],
        [
          "typedef struct _AFD_POLL_HANDLE_INFO {\n  HANDLE   Handle;\n  ULONG    Events;\n  NTSTATUS Status;\n} AFD_POLL_HANDLE_INFO, *PAFD_POLL_HANDLE_INFO;",
          {
            "Handle": "HANDLE",
            "Events": "ULONG",
            "Status": "NTSTATUS"
          },
          "AFD_POLL_HANDLE_INFO",
          [
            81,
            0
          ],
          [
            85,
            47
          ]
        ],
        [
          "typedef struct _AFD_POLL_HANDLE_INFO {\n  HANDLE   Handle;\n  ULONG    Events;\n  NTSTATUS Status;\n} AFD_POLL_HANDLE_INFO, *PAFD_POLL_HANDLE_INFO;",
          {
            "Handle": "HANDLE",
            "Events": "ULONG",
            "Status": "NTSTATUS"
          },
          "PAFD_POLL_HANDLE_INFO",
          [
            81,
            0
          ],
          [
            85,
            47
          ]
        ],
        [
          "typedef struct _AFD_POLL_INFO {\n  LARGE_INTEGER        Timeout;\n  ULONG                NumberOfHandles;\n  ULONG                Exclusive;\n  AFD_POLL_HANDLE_INFO Handles[1];\n} AFD_POLL_INFO, *PAFD_POLL_INFO;",
          {
            "Timeout": "LARGE_INTEGER",
            "NumberOfHandles": "ULONG",
            "Exclusive": "ULONG",
            "Handles[1]": "AFD_POLL_HANDLE_INFO"
          },
          "AFD_POLL_INFO",
          [
            87,
            0
          ],
          [
            92,
            33
          ]
        ],
        [
          "typedef struct _AFD_POLL_INFO {\n  LARGE_INTEGER        Timeout;\n  ULONG                NumberOfHandles;\n  ULONG                Exclusive;\n  AFD_POLL_HANDLE_INFO Handles[1];\n} AFD_POLL_INFO, *PAFD_POLL_INFO;",
          {
            "Timeout": "LARGE_INTEGER",
            "NumberOfHandles": "ULONG",
            "Exclusive": "ULONG",
            "Handles[1]": "AFD_POLL_HANDLE_INFO"
          },
          "PAFD_POLL_INFO",
          [
            87,
            0
          ],
          [
            92,
            33
          ]
        ]
      ],
      "include_list": [
        [
          "#    include <winsock2.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#    include <ws2tcpip.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#    include <mswsock.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#    include <windows.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_getenv.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_getenv(const char *name)",
          "fn_dec_pos": [
            [
              32,
              13
            ],
            [
              32,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getenv",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_strcasecmp.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_strcasecmp(const char *a, const char *b)",
          "fn_dec_pos": [
            [
              32,
              11
            ],
            [
              32,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strcasecmp",
            "parameters": {
              "a": "char",
              "b": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_strncasecmp(const char *a, const char *b, size_t n)",
          "fn_dec_pos": [
            [
              36,
              11
            ],
            [
              36,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strncasecmp",
            "parameters": {
              "a": "char",
              "b": "char",
              "n": "size_t"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__llist.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*ares__llist_destructor_t)(void *data)",
          "fn_dec_pos": [
            [
              54,
              13
            ],
            [
              54,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__llist_create(ares__llist_destructor_t destruct)",
          "fn_dec_pos": [
            [
              61,
              20
            ],
            [
              61,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_create",
            "parameters": {
              "destruct": "ares__llist_destructor_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_replace_destructor(ares__llist_t           *list,\n                                                   ares__llist_destructor_t destruct)",
          "fn_dec_pos": [
            [
              69,
              20
            ],
            [
              70,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_replace_destructor",
            "parameters": {
              "list": "ares__llist_t",
              "destruct": "ares__llist_destructor_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__llist_insert_first(ares__llist_t *list, void *val)",
          "fn_dec_pos": [
            [
              79,
              20
            ],
            [
              79,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_insert_first",
            "parameters": {
              "list": "ares__llist_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_insert_last(ares__llist_t *list, void *val)",
          "fn_dec_pos": [
            [
              88,
              20
            ],
            [
              88,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_insert_last",
            "parameters": {
              "list": "ares__llist_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_insert_before(ares__llist_node_t *node,\n                                              void               *val)",
          "fn_dec_pos": [
            [
              97,
              20
            ],
            [
              98,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_insert_before",
            "parameters": {
              "node": "ares__llist_node_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_insert_after(ares__llist_node_t *node,\n                                             void               *val)",
          "fn_dec_pos": [
            [
              107,
              20
            ],
            [
              108,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_insert_after",
            "parameters": {
              "node": "ares__llist_node_t",
              "val": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_node_first(ares__llist_t *list)",
          "fn_dec_pos": [
            [
              115,
              20
            ],
            [
              115,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_first",
            "parameters": {
              "list": "ares__llist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_node_last(ares__llist_t *list)",
          "fn_dec_pos": [
            [
              122,
              20
            ],
            [
              122,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_last",
            "parameters": {
              "list": "ares__llist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_node_next(ares__llist_node_t *node)",
          "fn_dec_pos": [
            [
              129,
              20
            ],
            [
              129,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_next",
            "parameters": {
              "node": "ares__llist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_node_prev(ares__llist_node_t *node)",
          "fn_dec_pos": [
            [
              136,
              20
            ],
            [
              136,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_prev",
            "parameters": {
              "node": "ares__llist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_node_val(ares__llist_node_t *node)",
          "fn_dec_pos": [
            [
              143,
              20
            ],
            [
              143,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_val",
            "parameters": {
              "node": "ares__llist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_len(const ares__llist_t *list)",
          "fn_dec_pos": [
            [
              150,
              20
            ],
            [
              150,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_len",
            "parameters": {
              "list": "ares__llist_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares__llist_node_parent(ares__llist_node_t *node)",
          "fn_dec_pos": [
            [
              157,
              20
            ],
            [
              157,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_parent",
            "parameters": {
              "node": "ares__llist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_first_val(ares__llist_t *list)",
          "fn_dec_pos": [
            [
              164,
              20
            ],
            [
              164,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_first_val",
            "parameters": {
              "list": "ares__llist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_last_val(ares__llist_t *list)",
          "fn_dec_pos": [
            [
              171,
              20
            ],
            [
              171,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_last_val",
            "parameters": {
              "list": "ares__llist_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_node_claim(ares__llist_node_t *node)",
          "fn_dec_pos": [
            [
              179,
              20
            ],
            [
              179,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_claim",
            "parameters": {
              "node": "ares__llist_node_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__llist_node_replace(ares__llist_node_t *node, void *val)",
          "fn_dec_pos": [
            [
              186,
              5
            ],
            [
              186,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_replace",
            "parameters": {
              "node": "ares__llist_node_t",
              "val": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__llist_node_destroy(ares__llist_node_t *node)",
          "fn_dec_pos": [
            [
              192,
              5
            ],
            [
              192,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_destroy",
            "parameters": {
              "node": "ares__llist_node_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__llist_destroy(ares__llist_t *list)",
          "fn_dec_pos": [
            [
              198,
              5
            ],
            [
              198,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_destroy",
            "parameters": {
              "list": "ares__llist_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__llist_node_move_parent_last(ares__llist_node_t *node,\n                                       ares__llist_t      *new_parent)",
          "fn_dec_pos": [
            [
              206,
              5
            ],
            [
              207,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_move_parent_last",
            "parameters": {
              "node": "ares__llist_node_t",
              "new_parent": "ares__llist_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__llist_node_move_parent_first(ares__llist_node_t *node,\n                                        ares__llist_t      *new_parent)",
          "fn_dec_pos": [
            [
              215,
              5
            ],
            [
              216,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__llist_node_move_parent_first",
            "parameters": {
              "node": "ares__llist_node_t",
              "new_parent": "ares__llist_t"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares__llist",
          {},
          "",
          [
            40,
            0
          ],
          [
            40,
            18
          ]
        ],
        [
          "typedef struct ares__llist ares__llist_t;",
          {},
          "ares__llist_t",
          [
            43,
            0
          ],
          [
            43,
            41
          ]
        ],
        [
          "struct ares__llist_node",
          {},
          "",
          [
            45,
            0
          ],
          [
            45,
            23
          ]
        ],
        [
          "typedef struct ares__llist_node ares__llist_node_t;",
          {},
          "ares__llist_node_t",
          [
            48,
            0
          ],
          [
            48,
            51
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_inet_net_pton.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_inet_net_pton(int af, const char *src, void *dst, size_t size)",
          "fn_dec_pos": [
            [
              31,
              4
            ],
            [
              31,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_net_pton",
            "parameters": {
              "af": "int",
              "src": "char",
              "dst": "void",
              "size": "size_t"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__htable_szvp.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*ares__htable_szvp_val_free_t)(void *val)",
          "fn_dec_pos": [
            [
              51,
              13
            ],
            [
              51,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "val": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__htable_szvp_destroy(ares__htable_szvp_t *htable)",
          "fn_dec_pos": [
            [
              57,
              5
            ],
            [
              57,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_szvp_destroy",
            "parameters": {
              "htable": "ares__htable_szvp_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__htable_szvp_create(ares__htable_szvp_val_free_t val_free)",
          "fn_dec_pos": [
            [
              66,
              2
            ],
            [
              66,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_szvp_create",
            "parameters": {
              "val_free": "ares__htable_szvp_val_free_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_szvp_insert(ares__htable_szvp_t *htable, size_t key,\n                                     void *val)",
          "fn_dec_pos": [
            [
              75,
              12
            ],
            [
              76,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_szvp_insert",
            "parameters": {
              "htable": "ares__htable_szvp_t",
              "key": "size_t",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__htable_szvp_get(const ares__htable_szvp_t *htable, size_t key,\n                                  void **val)",
          "fn_dec_pos": [
            [
              85,
              12
            ],
            [
              86,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_szvp_get",
            "parameters": {
              "htable": "ares__htable_szvp_t",
              "key": "size_t",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__htable_szvp_get_direct(const ares__htable_szvp_t *htable,\n                                         size_t                     key)",
          "fn_dec_pos": [
            [
              96,
              12
            ],
            [
              97,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_szvp_get_direct",
            "parameters": {
              "htable": "ares__htable_szvp_t",
              "key": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_szvp_remove(ares__htable_szvp_t *htable, size_t key)",
          "fn_dec_pos": [
            [
              105,
              12
            ],
            [
              105,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_szvp_remove",
            "parameters": {
              "htable": "ares__htable_szvp_t",
              "key": "size_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__htable_szvp_num_keys(const ares__htable_szvp_t *htable)",
          "fn_dec_pos": [
            [
              112,
              12
            ],
            [
              112,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_szvp_num_keys",
            "parameters": {
              "htable": "ares__htable_szvp_t"
            },
            "return_type": "size_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares__htable_szvp",
          {},
          "",
          [
            42,
            0
          ],
          [
            42,
            24
          ]
        ],
        [
          "typedef struct ares__htable_szvp ares__htable_szvp_t;",
          {},
          "ares__htable_szvp_t",
          [
            45,
            0
          ],
          [
            45,
            53
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_android.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_get_android_server_list(size_t max_servers, size_t *num_servers)",
          "fn_dec_pos": [
            [
              31,
              7
            ],
            [
              31,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_android_server_list",
            "parameters": {
              "max_servers": "size_t",
              "num_servers": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_get_android_search_domains_list(void)",
          "fn_dec_pos": [
            [
              32,
              7
            ],
            [
              32,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_android_search_domains_list",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares_library_cleanup_android(void)",
          "fn_dec_pos": [
            [
              33,
              7
            ],
            [
              33,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_cleanup_android",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/setup_once.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct timeval {\n  long tv_sec;\n  long tv_usec;\n}",
          {
            "tv_sec": "long",
            "tv_usec": "long"
          },
          "timeval",
          [
            116,
            0
          ],
          [
            119,
            1
          ]
        ],
        [
          "struct timeval {\n  long tv_sec;\n  long tv_usec;\n}",
          {
            "tv_sec": "long",
            "tv_usec": "long"
          },
          "timeval",
          [
            116,
            0
          ],
          [
            119,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#  include <errno.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#  include <sys/types.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#  include <malloc.h>\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#  include <memory.h>\n",
          [
            62,
            0
          ],
          [
            63,
            0
          ]
        ],
        [
          "#  include <sys/stat.h>\n",
          [
            66,
            0
          ],
          [
            67,
            0
          ]
        ],
        [
          "#  include <sys/time.h>\n",
          [
            70,
            0
          ],
          [
            71,
            0
          ]
        ],
        [
          "#  include <time.h>\n",
          [
            74,
            0
          ],
          [
            75,
            0
          ]
        ],
        [
          "#  include <io.h>\n",
          [
            78,
            0
          ],
          [
            79,
            0
          ]
        ],
        [
          "#  include <fcntl.h>\n",
          [
            79,
            0
          ],
          [
            80,
            0
          ]
        ],
        [
          "#  include <unistd.h>\n",
          [
            83,
            0
          ],
          [
            84,
            0
          ]
        ],
        [
          "#  include <sys/socket.h>\n",
          [
            98,
            0
          ],
          [
            99,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__threads.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares__thread_mutex_create(void)",
          "fn_dec_pos": [
            [
              31,
              34
            ],
            [
              31,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_mutex_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares__thread_mutex_destroy(ares__thread_mutex_t *mut)",
          "fn_dec_pos": [
            [
              32,
              5
            ],
            [
              32,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_mutex_destroy",
            "parameters": {
              "mut": "ares__thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__thread_mutex_lock(ares__thread_mutex_t *mut)",
          "fn_dec_pos": [
            [
              33,
              5
            ],
            [
              33,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_mutex_lock",
            "parameters": {
              "mut": "ares__thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__thread_mutex_unlock(ares__thread_mutex_t *mut)",
          "fn_dec_pos": [
            [
              34,
              5
            ],
            [
              34,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_mutex_unlock",
            "parameters": {
              "mut": "ares__thread_mutex_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__thread_cond_create(void)",
          "fn_dec_pos": [
            [
              40,
              33
            ],
            [
              40,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares__thread_cond_destroy(ares__thread_cond_t *cond)",
          "fn_dec_pos": [
            [
              41,
              14
            ],
            [
              41,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_destroy",
            "parameters": {
              "cond": "ares__thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__thread_cond_signal(ares__thread_cond_t *cond)",
          "fn_dec_pos": [
            [
              42,
              14
            ],
            [
              42,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_signal",
            "parameters": {
              "cond": "ares__thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__thread_cond_broadcast(ares__thread_cond_t *cond)",
          "fn_dec_pos": [
            [
              43,
              14
            ],
            [
              43,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_broadcast",
            "parameters": {
              "cond": "ares__thread_cond_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__thread_cond_wait(ares__thread_cond_t  *cond,\n                                     ares__thread_mutex_t *mut)",
          "fn_dec_pos": [
            [
              44,
              14
            ],
            [
              45,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_wait",
            "parameters": {
              "cond": "ares__thread_cond_t",
              "mut": "ares__thread_mutex_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__thread_cond_timedwait(ares__thread_cond_t  *cond,\n                                          ares__thread_mutex_t *mut,\n                                          unsigned long         timeout_ms)",
          "fn_dec_pos": [
            [
              46,
              14
            ],
            [
              48,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_cond_timedwait",
            "parameters": {
              "cond": "ares__thread_cond_t",
              "mut": "ares__thread_mutex_t",
              "timeout_ms": "unsigned long"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "(*ares__thread_func_t)(void *arg)",
          "fn_dec_pos": [
            [
              54,
              14
            ],
            [
              54,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "arg": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__thread_create(ares__thread_t    **thread,\n                                  ares__thread_func_t func, void *arg)",
          "fn_dec_pos": [
            [
              55,
              14
            ],
            [
              56,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_create",
            "parameters": {
              "thread": "ares__thread_t",
              "func": "ares__thread_func_t",
              "arg": "void"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__thread_join(ares__thread_t *thread, void **rv)",
          "fn_dec_pos": [
            [
              57,
              14
            ],
            [
              57,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__thread_join",
            "parameters": {
              "thread": "ares__thread_t",
              "rv": "void"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares__thread_mutex",
          {},
          "",
          [
            28,
            0
          ],
          [
            28,
            25
          ]
        ],
        [
          "typedef struct ares__thread_mutex ares__thread_mutex_t;",
          {},
          "ares__thread_mutex_t",
          [
            29,
            0
          ],
          [
            29,
            55
          ]
        ],
        [
          "struct ares__thread_cond",
          {},
          "",
          [
            37,
            0
          ],
          [
            37,
            24
          ]
        ],
        [
          "typedef struct ares__thread_cond ares__thread_cond_t;",
          {},
          "ares__thread_cond_t",
          [
            38,
            0
          ],
          [
            38,
            53
          ]
        ],
        [
          "struct ares__thread",
          {},
          "",
          [
            51,
            0
          ],
          [
            51,
            19
          ]
        ],
        [
          "typedef struct ares__thread ares__thread_t;",
          {},
          "ares__thread_t",
          [
            52,
            0
          ],
          [
            52,
            43
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__iface_ips.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares__iface_ips_destroy(ares__iface_ips_t *ips)",
          "fn_dec_pos": [
            [
              55,
              31
            ],
            [
              55,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_destroy",
            "parameters": {
              "ips": "ares__iface_ips_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__iface_ips(ares__iface_ips_t    **ips,\n                                               ares__iface_ip_flags_t flags, const char *name)",
          "fn_dec_pos": [
            [
              65,
              31
            ],
            [
              66,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips",
            "parameters": {
              "ips": "ares__iface_ips_t",
              "flags": "ares__iface_ip_flags_t",
              "name": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__iface_ips_cnt(const ares__iface_ips_t *ips)",
          "fn_dec_pos": [
            [
              73,
              12
            ],
            [
              73,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_cnt",
            "parameters": {
              "ips": "ares__iface_ips_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares__iface_ips_get_name(const ares__iface_ips_t *ips, size_t idx)",
          "fn_dec_pos": [
            [
              81,
              12
            ],
            [
              81,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_get_name",
            "parameters": {
              "ips": "ares__iface_ips_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__iface_ips_get_addr(const ares__iface_ips_t *ips,\n                                                 size_t                   idx)",
          "fn_dec_pos": [
            [
              89,
              24
            ],
            [
              90,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_get_addr",
            "parameters": {
              "ips": "ares__iface_ips_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__iface_ips_get_flags(const ares__iface_ips_t *ips,\n                                                  size_t                   idx)",
          "fn_dec_pos": [
            [
              98,
              24
            ],
            [
              99,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_get_flags",
            "parameters": {
              "ips": "ares__iface_ips_t",
              "idx": "size_t"
            },
            "return_type": "ares__iface_ip_flags_t"
          }
        },
        {
          "fn_code": "ares__iface_ips_get_netmask(const ares__iface_ips_t *ips,\n                                          size_t                   idx)",
          "fn_dec_pos": [
            [
              107,
              14
            ],
            [
              108,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_get_netmask",
            "parameters": {
              "ips": "ares__iface_ips_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__iface_ips_get_ll_scope(const ares__iface_ips_t *ips,\n                                           size_t                   idx)",
          "fn_dec_pos": [
            [
              116,
              14
            ],
            [
              117,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__iface_ips_get_ll_scope",
            "parameters": {
              "ips": "ares__iface_ips_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__if_nametoindex(const char *name)",
          "fn_dec_pos": [
            [
              126,
              14
            ],
            [
              126,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__if_nametoindex",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__if_indextoname(unsigned int index, char *name,\n                                   size_t name_len)",
          "fn_dec_pos": [
            [
              135,
              14
            ],
            [
              136,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__if_indextoname",
            "parameters": {
              "index": "unsigned int",
              "name": "char",
              "name_len": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares__iface_ips",
          {},
          "",
          [
            46,
            0
          ],
          [
            46,
            22
          ]
        ],
        [
          "typedef struct ares__iface_ips ares__iface_ips_t;",
          {},
          "ares__iface_ips_t",
          [
            49,
            0
          ],
          [
            49,
            49
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            89,
            6
          ],
          [
            89,
            22
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  ARES_IFACE_IP_V4 = 1 << 0,        /*!< IPv4 address. During enumeration if\n                                     *   this flag is set ARES_IFACE_IP_V6\n                                     *   is not, will only enumerate v4\n                                     *   addresses. */\n  ARES_IFACE_IP_V6 = 1 << 1,        /*!< IPv6 address. During enumeration if\n                                     *   this flag is set ARES_IFACE_IP_V4\n                                     *   is not, will only enumerate v6\n                                     *   addresses. */\n  ARES_IFACE_IP_LOOPBACK  = 1 << 2, /*!< Loopback adapter */\n  ARES_IFACE_IP_OFFLINE   = 1 << 3, /*!< Adapter offline */\n  ARES_IFACE_IP_LINKLOCAL = 1 << 4, /*!< Link-local ip address */\n  /*! Default, enumerate all ips for online interfaces, including loopback */\n  ARES_IFACE_IP_DEFAULT = (ARES_IFACE_IP_V4 | ARES_IFACE_IP_V6 |\n                           ARES_IFACE_IP_LOOPBACK | ARES_IFACE_IP_LINKLOCAL)\n} ares__iface_ip_flags_t;",
          {
            "ARES_IFACE_IP_V4": "",
            "ARES_IFACE_IP_V6": "",
            "ARES_IFACE_IP_LOOPBACK": "",
            "ARES_IFACE_IP_OFFLINE": "",
            "ARES_IFACE_IP_LINKLOCAL": "",
            "ARES_IFACE_IP_DEFAULT": ""
          },
          "ares__iface_ip_flags_t",
          [
            29,
            0
          ],
          [
            44,
            25
          ]
        ]
      ]
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_ipv6.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct sockaddr_in6 {\n  unsigned short       sin6_family;\n  unsigned short       sin6_port;\n  unsigned long        sin6_flowinfo;\n  struct ares_in6_addr sin6_addr;\n  unsigned int         sin6_scope_id;\n}",
          {
            "sin6_family": "unsigned short",
            "sin6_port": "unsigned short",
            "sin6_flowinfo": "unsigned long",
            "sin6_addr": "struct ares_in6_addr",
            "sin6_scope_id": "unsigned int"
          },
          "sockaddr_in6",
          [
            38,
            0
          ],
          [
            44,
            1
          ]
        ],
        [
          "struct addrinfo {\n  int              ai_flags;\n  int              ai_family;\n  int              ai_socktype;\n  int              ai_protocol;\n  ares_socklen_t   ai_addrlen; /* Follow rfc3493 struct addrinfo */\n  char            *ai_canonname;\n  struct sockaddr *ai_addr;\n  struct addrinfo *ai_next;\n}",
          {
            "ai_flags": "int",
            "ai_family": "int",
            "ai_socktype": "int",
            "ai_protocol": "int",
            "ai_addrlen": "ares_socklen_t",
            "*ai_canonname": "char",
            "*ai_addr": "struct sockaddr",
            "*ai_next": "struct addrinfo"
          },
          "addrinfo",
          [
            54,
            0
          ],
          [
            63,
            1
          ]
        ],
        [
          "struct sockaddr_in6 {\n  unsigned short       sin6_family;\n  unsigned short       sin6_port;\n  unsigned long        sin6_flowinfo;\n  struct ares_in6_addr sin6_addr;\n  unsigned int         sin6_scope_id;\n}",
          {
            "sin6_family": "unsigned short",
            "sin6_port": "unsigned short",
            "sin6_flowinfo": "unsigned long",
            "sin6_addr": "struct ares_in6_addr",
            "sin6_scope_id": "unsigned int"
          },
          "sockaddr_in6",
          [
            38,
            0
          ],
          [
            44,
            1
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            42,
            2
          ],
          [
            42,
            22
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            48,
            2
          ],
          [
            48,
            17
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            49,
            2
          ],
          [
            49,
            20
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            50,
            2
          ],
          [
            50,
            21
          ]
        ],
        [
          "struct addrinfo {\n  int              ai_flags;\n  int              ai_family;\n  int              ai_socktype;\n  int              ai_protocol;\n  ares_socklen_t   ai_addrlen; /* Follow rfc3493 struct addrinfo */\n  char            *ai_canonname;\n  struct sockaddr *ai_addr;\n  struct addrinfo *ai_next;\n}",
          {
            "ai_flags": "int",
            "ai_family": "int",
            "ai_socktype": "int",
            "ai_protocol": "int",
            "ai_addrlen": "ares_socklen_t",
            "*ai_canonname": "char",
            "*ai_addr": "struct sockaddr",
            "*ai_next": "struct addrinfo"
          },
          "addrinfo",
          [
            54,
            0
          ],
          [
            63,
            1
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            61,
            2
          ],
          [
            61,
            17
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            62,
            2
          ],
          [
            62,
            17
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            92,
            13
          ],
          [
            92,
            33
          ]
        ]
      ],
      "include_list": [
        [
          "#  include <netinet6/in6.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_data.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_malloc_data(ares_datatype type)",
          "fn_dec_pos": [
            [
              88,
              6
            ],
            [
              88,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_malloc_data",
            "parameters": {
              "type": "ares_datatype"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_data {\n  ares_datatype type; /* Actual data type identifier. */\n  unsigned int  mark; /* Private ares_data signature. */\n\n  union {\n    struct ares_txt_reply      txt_reply;\n    struct ares_txt_ext        txt_ext;\n    struct ares_srv_reply      srv_reply;\n    struct ares_addr_node      addr_node;\n    struct ares_addr_port_node addr_port_node;\n    struct ares_mx_reply       mx_reply;\n    struct ares_naptr_reply    naptr_reply;\n    struct ares_soa_reply      soa_reply;\n    struct ares_caa_reply      caa_reply;\n    struct ares_uri_reply      uri_reply;\n  } data;\n}",
          {
            "type": "ares_datatype",
            "mark": "unsigned int",
            "data": "union {\n    struct ares_txt_reply      txt_reply;\n    struct ares_txt_ext        txt_ext;\n    struct ares_srv_reply      srv_reply;\n    struct ares_addr_node      addr_node;\n    struct ares_addr_port_node addr_port_node;\n    struct ares_mx_reply       mx_reply;\n    struct ares_naptr_reply    naptr_reply;\n    struct ares_soa_reply      soa_reply;\n    struct ares_caa_reply      caa_reply;\n    struct ares_uri_reply      uri_reply;\n  }",
            "txt_reply": "struct ares_txt_reply",
            "txt_ext": "struct ares_txt_ext",
            "srv_reply": "struct ares_srv_reply",
            "addr_node": "struct ares_addr_node",
            "addr_port_node": "struct ares_addr_port_node",
            "mx_reply": "struct ares_mx_reply",
            "naptr_reply": "struct ares_naptr_reply",
            "soa_reply": "struct ares_soa_reply",
            "caa_reply": "struct ares_caa_reply",
            "uri_reply": "struct ares_uri_reply"
          },
          "ares_data",
          [
            70,
            0
          ],
          [
            86,
            1
          ]
        ],
        [
          "struct ares_data {\n  ares_datatype type; /* Actual data type identifier. */\n  unsigned int  mark; /* Private ares_data signature. */\n\n  union {\n    struct ares_txt_reply      txt_reply;\n    struct ares_txt_ext        txt_ext;\n    struct ares_srv_reply      srv_reply;\n    struct ares_addr_node      addr_node;\n    struct ares_addr_port_node addr_port_node;\n    struct ares_mx_reply       mx_reply;\n    struct ares_naptr_reply    naptr_reply;\n    struct ares_soa_reply      soa_reply;\n    struct ares_caa_reply      caa_reply;\n    struct ares_uri_reply      uri_reply;\n  } data;\n}",
          {
            "type": "ares_datatype",
            "mark": "unsigned int",
            "data": "union {\n    struct ares_txt_reply      txt_reply;\n    struct ares_txt_ext        txt_ext;\n    struct ares_srv_reply      srv_reply;\n    struct ares_addr_node      addr_node;\n    struct ares_addr_port_node addr_port_node;\n    struct ares_mx_reply       mx_reply;\n    struct ares_naptr_reply    naptr_reply;\n    struct ares_soa_reply      soa_reply;\n    struct ares_caa_reply      caa_reply;\n    struct ares_uri_reply      uri_reply;\n  }",
            "txt_reply": "struct ares_txt_reply",
            "txt_ext": "struct ares_txt_ext",
            "srv_reply": "struct ares_srv_reply",
            "addr_node": "struct ares_addr_node",
            "addr_port_node": "struct ares_addr_port_node",
            "mx_reply": "struct ares_mx_reply",
            "naptr_reply": "struct ares_naptr_reply",
            "soa_reply": "struct ares_soa_reply",
            "caa_reply": "struct ares_caa_reply",
            "uri_reply": "struct ares_uri_reply"
          },
          "ares_data",
          [
            70,
            0
          ],
          [
            86,
            1
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            75,
            4
          ],
          [
            75,
            25
          ]
        ],
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            76,
            4
          ],
          [
            76,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            77,
            4
          ],
          [
            77,
            25
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            78,
            4
          ],
          [
            78,
            25
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            79,
            4
          ],
          [
            79,
            30
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            80,
            4
          ],
          [
            80,
            24
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            81,
            4
          ],
          [
            81,
            27
          ]
        ],
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            82,
            4
          ],
          [
            82,
            25
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            83,
            4
          ],
          [
            83,
            25
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            84,
            4
          ],
          [
            84,
            25
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  ARES_DATATYPE_UNKNOWN = 1, /* unknown data type     - introduced in 1.7.0 */\n  ARES_DATATYPE_SRV_REPLY,   /* struct ares_srv_reply - introduced in 1.7.0 */\n  ARES_DATATYPE_TXT_REPLY,   /* struct ares_txt_reply - introduced in 1.7.0 */\n  ARES_DATATYPE_TXT_EXT,     /* struct ares_txt_ext   - introduced in 1.11.0 */\n  ARES_DATATYPE_ADDR_NODE,   /* struct ares_addr_node - introduced in 1.7.1 */\n  ARES_DATATYPE_MX_REPLY,    /* struct ares_mx_reply   - introduced in 1.7.2 */\n  ARES_DATATYPE_NAPTR_REPLY, /* struct ares_naptr_reply - introduced in 1.7.6 */\n  ARES_DATATYPE_SOA_REPLY,   /* struct ares_soa_reply - introduced in 1.9.0 */\n  ARES_DATATYPE_URI_REPLY,   /* struct ares_uri_reply */\n#if 0\n  ARES_DATATYPE_ADDR6TTL,     /* struct ares_addrttl   */\n  ARES_DATATYPE_ADDRTTL,      /* struct ares_addr6ttl  */\n  ARES_DATATYPE_HOSTENT,      /* struct hostent        */\n  ARES_DATATYPE_OPTIONS,      /* struct ares_options   */\n#endif\n  ARES_DATATYPE_ADDR_PORT_NODE, /* struct ares_addr_port_node - introduced\n                                   in 1.11.0 */\n  ARES_DATATYPE_CAA_REPLY, /* struct ares_caa_reply   - introduced in 1.17 */\n  ARES_DATATYPE_LAST       /* not used              - introduced in 1.7.0 */\n} ares_datatype;",
          {
            "ARES_DATATYPE_UNKNOWN": "",
            "ARES_DATATYPE_SRV_REPLY": "",
            "ARES_DATATYPE_TXT_REPLY": "",
            "ARES_DATATYPE_TXT_EXT": "",
            "ARES_DATATYPE_ADDR_NODE": "",
            "ARES_DATATYPE_MX_REPLY": "",
            "ARES_DATATYPE_NAPTR_REPLY": "",
            "ARES_DATATYPE_SOA_REPLY": "",
            "ARES_DATATYPE_URI_REPLY": "",
            "ARES_DATATYPE_ADDR6TTL": "",
            "ARES_DATATYPE_ADDRTTL": "",
            "ARES_DATATYPE_HOSTENT": "",
            "ARES_DATATYPE_OPTIONS": "",
            "ARES_DATATYPE_ADDR_PORT_NODE": "",
            "ARES_DATATYPE_CAA_REPLY": "",
            "ARES_DATATYPE_LAST": ""
          },
          "ares_datatype",
          [
            28,
            0
          ],
          [
            48,
            16
          ]
        ]
      ]
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_platform.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares__getplatform(void)",
          "fn_dec_pos": [
            [
              41,
              13
            ],
            [
              41,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__getplatform",
            "parameters": {},
            "return_type": "win_platform"
          }
        },
        {
          "fn_code": "getservbyport(int port, const char *proto)",
          "fn_dec_pos": [
            [
              47,
              16
            ],
            [
              47,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getservbyport",
            "parameters": {
              "port": "int",
              "proto": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct servent",
          {},
          "",
          [
            47,
            0
          ],
          [
            47,
            14
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  WIN_UNKNOWN,\n  WIN_3X,\n  WIN_9X,\n  WIN_NT,\n  WIN_CE\n} win_platform;",
          {
            "WIN_UNKNOWN": "",
            "WIN_3X": "",
            "WIN_9X": "",
            "WIN_NT": "",
            "WIN_CE": ""
          },
          "win_platform",
          [
            33,
            0
          ],
          [
            39,
            15
          ]
        ]
      ]
    },
    "../docker_shared/source_code/c-ares/src/lib/config-win32.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__htable.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*ares__htable_hashfunc_t)(const void  *key,\n                                                unsigned int seed)",
          "fn_dec_pos": [
            [
              60,
              21
            ],
            [
              61,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "key": "void",
              "seed": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*ares__htable_bucket_free_t)(void *bucket)",
          "fn_dec_pos": [
            [
              67,
              13
            ],
            [
              67,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "bucket": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares__htable_bucket_key_t)(const void *bucket)",
          "fn_dec_pos": [
            [
              74,
              20
            ],
            [
              74,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "bucket": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*ares__htable_key_eq_t)(const void *key1,\n                                             const void *key2)",
          "fn_dec_pos": [
            [
              82,
              20
            ],
            [
              83,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "key1": "void",
              "key2": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__htable_destroy(ares__htable_t *htable)",
          "fn_dec_pos": [
            [
              90,
              16
            ],
            [
              90,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_destroy",
            "parameters": {
              "htable": "ares__htable_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__htable_create(ares__htable_hashfunc_t    hash_func,\n                                    ares__htable_bucket_key_t  bucket_key,\n                                    ares__htable_bucket_free_t bucket_free,\n                                    ares__htable_key_eq_t      key_eq)",
          "fn_dec_pos": [
            [
              100,
              16
            ],
            [
              103,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_create",
            "parameters": {
              "hash_func": "ares__htable_hashfunc_t",
              "bucket_key": "ares__htable_bucket_key_t",
              "bucket_free": "ares__htable_bucket_free_t",
              "key_eq": "ares__htable_key_eq_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_num_keys(const ares__htable_t *htable)",
          "fn_dec_pos": [
            [
              110,
              16
            ],
            [
              110,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_num_keys",
            "parameters": {
              "htable": "ares__htable_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares__htable_all_buckets(const ares__htable_t *htable,\n                                         size_t               *num)",
          "fn_dec_pos": [
            [
              122,
              16
            ],
            [
              123,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_all_buckets",
            "parameters": {
              "htable": "ares__htable_t",
              "num": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_insert(ares__htable_t *htable, void *bucket)",
          "fn_dec_pos": [
            [
              132,
              16
            ],
            [
              132,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_insert",
            "parameters": {
              "htable": "ares__htable_t",
              "bucket": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__htable_get(const ares__htable_t *htable, const void *key)",
          "fn_dec_pos": [
            [
              140,
              16
            ],
            [
              140,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_get",
            "parameters": {
              "htable": "ares__htable_t",
              "key": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_remove(ares__htable_t *htable, const void *key)",
          "fn_dec_pos": [
            [
              148,
              16
            ],
            [
              148,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_remove",
            "parameters": {
              "htable": "ares__htable_t",
              "key": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__htable_hash_FNV1a(const unsigned char *key, size_t key_len,\n                                     unsigned int seed)",
          "fn_dec_pos": [
            [
              158,
              13
            ],
            [
              159,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_hash_FNV1a",
            "parameters": {
              "key": "unsigned char",
              "key_len": "size_t",
              "seed": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_hash_FNV1a_casecmp(const unsigned char *key,\n                                             size_t key_len, unsigned int seed)",
          "fn_dec_pos": [
            [
              170,
              13
            ],
            [
              171,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_hash_FNV1a_casecmp",
            "parameters": {
              "key": "unsigned char",
              "key_len": "size_t",
              "seed": "unsigned int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares__htable",
          {},
          "",
          [
            47,
            0
          ],
          [
            47,
            19
          ]
        ],
        [
          "typedef struct ares__htable ares__htable_t;",
          {},
          "ares__htable_t",
          [
            50,
            0
          ],
          [
            50,
            43
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_strsplit.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares__strsplit(const char *in, const char *delms, size_t *num_elm)",
          "fn_dec_pos": [
            [
              44,
              7
            ],
            [
              44,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__strsplit",
            "parameters": {
              "in": "char",
              "delms": "char",
              "num_elm": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__strsplit_free(char **elms, size_t num_elm)",
          "fn_dec_pos": [
            [
              47,
              7
            ],
            [
              47,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__strsplit_free",
            "parameters": {
              "elms": "char",
              "num_elm": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__strsplit_duplicate(char **elms, size_t num_elm)",
          "fn_dec_pos": [
            [
              50,
              7
            ],
            [
              50,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__strsplit_duplicate",
            "parameters": {
              "elms": "char",
              "num_elm": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__htable_strvp.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*ares__htable_strvp_val_free_t)(void *val)",
          "fn_dec_pos": [
            [
              51,
              13
            ],
            [
              51,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "val": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__htable_strvp_destroy(ares__htable_strvp_t *htable)",
          "fn_dec_pos": [
            [
              57,
              5
            ],
            [
              57,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_strvp_destroy",
            "parameters": {
              "htable": "ares__htable_strvp_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__htable_strvp_create(ares__htable_strvp_val_free_t val_free)",
          "fn_dec_pos": [
            [
              66,
              2
            ],
            [
              66,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_strvp_create",
            "parameters": {
              "val_free": "ares__htable_strvp_val_free_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_strvp_insert(ares__htable_strvp_t *htable,\n                                      const char *key, void *val)",
          "fn_dec_pos": [
            [
              75,
              12
            ],
            [
              76,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_strvp_insert",
            "parameters": {
              "htable": "ares__htable_strvp_t",
              "key": "char",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__htable_strvp_get(const ares__htable_strvp_t *htable,\n                                   const char *key, void **val)",
          "fn_dec_pos": [
            [
              85,
              12
            ],
            [
              86,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_strvp_get",
            "parameters": {
              "htable": "ares__htable_strvp_t",
              "key": "char",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__htable_strvp_get_direct(const ares__htable_strvp_t *htable,\n                                          const char                 *key)",
          "fn_dec_pos": [
            [
              96,
              12
            ],
            [
              97,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_strvp_get_direct",
            "parameters": {
              "htable": "ares__htable_strvp_t",
              "key": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_strvp_remove(ares__htable_strvp_t *htable,\n                                      const char           *key)",
          "fn_dec_pos": [
            [
              105,
              12
            ],
            [
              106,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_strvp_remove",
            "parameters": {
              "htable": "ares__htable_strvp_t",
              "key": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__htable_strvp_num_keys(const ares__htable_strvp_t *htable)",
          "fn_dec_pos": [
            [
              113,
              12
            ],
            [
              113,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_strvp_num_keys",
            "parameters": {
              "htable": "ares__htable_strvp_t"
            },
            "return_type": "size_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares__htable_strvp",
          {},
          "",
          [
            42,
            0
          ],
          [
            42,
            25
          ]
        ],
        [
          "typedef struct ares__htable_strvp ares__htable_strvp_t;",
          {},
          "ares__htable_strvp_t",
          [
            45,
            0
          ],
          [
            45,
            55
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_str.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_strdup(const char *s1)",
          "fn_dec_pos": [
            [
              32,
              14
            ],
            [
              32,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strdup",
            "parameters": {
              "s1": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_strlen(const char *str)",
          "fn_dec_pos": [
            [
              34,
              14
            ],
            [
              34,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strlen",
            "parameters": {
              "str": "char"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_strcpy(char *dest, const char *src, size_t dest_size)",
          "fn_dec_pos": [
            [
              46,
              14
            ],
            [
              46,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strcpy",
            "parameters": {
              "dest": "char",
              "src": "char",
              "dest_size": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_str_isnum(const char *str)",
          "fn_dec_pos": [
            [
              48,
              14
            ],
            [
              48,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_str_isnum",
            "parameters": {
              "str": "char"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__str_ltrim(char *str)",
          "fn_dec_pos": [
            [
              50,
              14
            ],
            [
              50,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__str_ltrim",
            "parameters": {
              "str": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__str_rtrim(char *str)",
          "fn_dec_pos": [
            [
              51,
              14
            ],
            [
              51,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__str_rtrim",
            "parameters": {
              "str": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__str_trim(char *str)",
          "fn_dec_pos": [
            [
              52,
              14
            ],
            [
              52,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__str_trim",
            "parameters": {
              "str": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__tolower(unsigned char c)",
          "fn_dec_pos": [
            [
              54,
              14
            ],
            [
              54,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__tolower",
            "parameters": {
              "c": "unsigned char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__memeq_ci(const unsigned char *ptr, const unsigned char *val,\n                             size_t len)",
          "fn_dec_pos": [
            [
              55,
              14
            ],
            [
              56,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__memeq_ci",
            "parameters": {
              "ptr": "unsigned char",
              "val": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__isspace(int ch)",
          "fn_dec_pos": [
            [
              58,
              14
            ],
            [
              58,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__isspace",
            "parameters": {
              "ch": "int"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__isprint(int ch)",
          "fn_dec_pos": [
            [
              59,
              14
            ],
            [
              59,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__isprint",
            "parameters": {
              "ch": "int"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__is_hostnamech(int ch)",
          "fn_dec_pos": [
            [
              60,
              14
            ],
            [
              60,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__is_hostnamech",
            "parameters": {
              "ch": "int"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__is_hostname(const char *str)",
          "fn_dec_pos": [
            [
              62,
              14
            ],
            [
              62,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__is_hostname",
            "parameters": {
              "str": "char"
            },
            "return_type": "ares_bool_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__htable_asvp.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*ares__htable_asvp_val_free_t)(void *val)",
          "fn_dec_pos": [
            [
              53,
              13
            ],
            [
              53,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "val": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__htable_asvp_destroy(ares__htable_asvp_t *htable)",
          "fn_dec_pos": [
            [
              59,
              5
            ],
            [
              59,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_asvp_destroy",
            "parameters": {
              "htable": "ares__htable_asvp_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__htable_asvp_create(ares__htable_asvp_val_free_t val_free)",
          "fn_dec_pos": [
            [
              68,
              2
            ],
            [
              68,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_asvp_create",
            "parameters": {
              "val_free": "ares__htable_asvp_val_free_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_asvp_keys(const ares__htable_asvp_t *htable,\n                                      size_t                    *num)",
          "fn_dec_pos": [
            [
              76,
              15
            ],
            [
              77,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_asvp_keys",
            "parameters": {
              "htable": "ares__htable_asvp_t",
              "num": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_asvp_insert(ares__htable_asvp_t *htable,\n                                        ares_socket_t key, void *val)",
          "fn_dec_pos": [
            [
              87,
              15
            ],
            [
              88,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_asvp_insert",
            "parameters": {
              "htable": "ares__htable_asvp_t",
              "key": "ares_socket_t",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__htable_asvp_get(const ares__htable_asvp_t *htable,\n                                     ares_socket_t key, void **val)",
          "fn_dec_pos": [
            [
              97,
              15
            ],
            [
              98,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_asvp_get",
            "parameters": {
              "htable": "ares__htable_asvp_t",
              "key": "ares_socket_t",
              "val": "void"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__htable_asvp_get_direct(const ares__htable_asvp_t *htable,\n                                            ares_socket_t              key)",
          "fn_dec_pos": [
            [
              108,
              15
            ],
            [
              109,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_asvp_get_direct",
            "parameters": {
              "htable": "ares__htable_asvp_t",
              "key": "ares_socket_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__htable_asvp_remove(ares__htable_asvp_t *htable,\n                                        ares_socket_t        key)",
          "fn_dec_pos": [
            [
              117,
              15
            ],
            [
              118,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_asvp_remove",
            "parameters": {
              "htable": "ares__htable_asvp_t",
              "key": "ares_socket_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__htable_asvp_num_keys(const ares__htable_asvp_t *htable)",
          "fn_dec_pos": [
            [
              125,
              15
            ],
            [
              125,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__htable_asvp_num_keys",
            "parameters": {
              "htable": "ares__htable_asvp_t"
            },
            "return_type": "size_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares__htable_asvp",
          {},
          "",
          [
            43,
            0
          ],
          [
            43,
            24
          ]
        ],
        [
          "typedef struct ares__htable_asvp ares__htable_asvp_t;",
          {},
          "ares__htable_asvp_t",
          [
            47,
            0
          ],
          [
            47,
            53
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_dns_private.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_dns_rec_type_allow_name_compression(ares_dns_rec_type_t type)",
          "fn_dec_pos": [
            [
              28,
              12
            ],
            [
              28,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_type_allow_name_compression",
            "parameters": {
              "type": "ares_dns_rec_type_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_dns_opcode_isvalid(ares_dns_opcode_t opcode)",
          "fn_dec_pos": [
            [
              29,
              12
            ],
            [
              29,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opcode_isvalid",
            "parameters": {
              "opcode": "ares_dns_opcode_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_dns_rcode_isvalid(ares_dns_rcode_t rcode)",
          "fn_dec_pos": [
            [
              30,
              12
            ],
            [
              30,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rcode_isvalid",
            "parameters": {
              "rcode": "ares_dns_rcode_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_dns_flags_arevalid(unsigned short flags)",
          "fn_dec_pos": [
            [
              31,
              12
            ],
            [
              31,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_flags_arevalid",
            "parameters": {
              "flags": "unsigned short"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_dns_rec_type_isvalid(ares_dns_rec_type_t type,\n                                      ares_bool_t         is_query)",
          "fn_dec_pos": [
            [
              32,
              12
            ],
            [
              33,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_type_isvalid",
            "parameters": {
              "type": "ares_dns_rec_type_t",
              "is_query": "ares_bool_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_dns_class_isvalid(ares_dns_class_t qclass,\n                                   ares_bool_t      is_query)",
          "fn_dec_pos": [
            [
              34,
              12
            ],
            [
              35,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_class_isvalid",
            "parameters": {
              "qclass": "ares_dns_class_t",
              "is_query": "ares_bool_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_dns_section_isvalid(ares_dns_section_t sect)",
          "fn_dec_pos": [
            [
              36,
              12
            ],
            [
              36,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_section_isvalid",
            "parameters": {
              "sect": "ares_dns_section_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_dns_rr_set_str_own(ares_dns_rr_t    *dns_rr,\n                                      ares_dns_rr_key_t key, char *val)",
          "fn_dec_pos": [
            [
              37,
              14
            ],
            [
              38,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_str_own",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_rr_set_bin_own(ares_dns_rr_t    *dns_rr,\n                                      ares_dns_rr_key_t key, unsigned char *val,\n                                      size_t len)",
          "fn_dec_pos": [
            [
              39,
              14
            ],
            [
              41,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_bin_own",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_rr_set_opt_own(ares_dns_rr_t    *dns_rr,\n                                      ares_dns_rr_key_t key, unsigned short opt,\n                                      unsigned char *val, size_t val_len)",
          "fn_dec_pos": [
            [
              42,
              14
            ],
            [
              44,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_set_opt_own",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short",
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_record_rr_prealloc(ares_dns_record_t *dnsrec,\n                                          ares_dns_section_t sect, size_t cnt)",
          "fn_dec_pos": [
            [
              45,
              14
            ],
            [
              46,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_prealloc",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "cnt": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_has_opt_rr(const ares_dns_record_t *rec)",
          "fn_dec_pos": [
            [
              47,
              14
            ],
            [
              47,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_has_opt_rr",
            "parameters": {
              "rec": "ares_dns_record_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares_dns_record_write_ttl_decrement(ares_dns_record_t *dnsrec,\n                                                  unsigned int       ttl_decrement)",
          "fn_dec_pos": [
            [
              48,
              14
            ],
            [
              49,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_write_ttl_decrement",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "ttl_decrement": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_dns_record_create_query(ares_dns_record_t **dnsrec, const char *name,\n                               ares_dns_class_t    dnsclass,\n                               ares_dns_rec_type_t type, unsigned short id,\n                               ares_dns_flags_t flags, size_t max_udp_size)",
          "fn_dec_pos": [
            [
              64,
              2
            ],
            [
              67,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_create_query",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "name": "char",
              "dnsclass": "ares_dns_class_t",
              "type": "ares_dns_rec_type_t",
              "id": "unsigned short",
              "flags": "ares_dns_flags_t",
              "max_udp_size": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_dns_query_reply_tostatus(ares_dns_rcode_t rcode,\n                                            size_t           ancount)",
          "fn_dec_pos": [
            [
              75,
              14
            ],
            [
              76,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_query_reply_tostatus",
            "parameters": {
              "rcode": "ares_dns_rcode_t",
              "ancount": "size_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_dns_qd {\n  char               *name;\n  ares_dns_rec_type_t qtype;\n  ares_dns_class_t    qclass;\n}",
          {
            "*name": "char",
            "qtype": "ares_dns_rec_type_t",
            "qclass": "ares_dns_class_t"
          },
          "ares_dns_qd",
          [
            78,
            0
          ],
          [
            82,
            1
          ]
        ],
        [
          "typedef struct {\n  struct in_addr addr;\n} ares__dns_a_t;",
          {
            "addr": "struct in_addr"
          },
          "ares__dns_a_t",
          [
            84,
            0
          ],
          [
            86,
            16
          ]
        ],
        [
          "typedef struct {\n  char *nsdname;\n} ares__dns_ns_t;",
          {
            "*nsdname": "char"
          },
          "ares__dns_ns_t",
          [
            88,
            0
          ],
          [
            90,
            17
          ]
        ],
        [
          "typedef struct {\n  char *cname;\n} ares__dns_cname_t;",
          {
            "*cname": "char"
          },
          "ares__dns_cname_t",
          [
            92,
            0
          ],
          [
            94,
            20
          ]
        ],
        [
          "typedef struct {\n  char        *mname;\n  char        *rname;\n  unsigned int serial;\n  unsigned int refresh;\n  unsigned int retry;\n  unsigned int expire;\n  unsigned int minimum;\n} ares__dns_soa_t;",
          {
            "*mname": "char",
            "*rname": "char",
            "serial": "unsigned int",
            "refresh": "unsigned int",
            "retry": "unsigned int",
            "expire": "unsigned int",
            "minimum": "unsigned int"
          },
          "ares__dns_soa_t",
          [
            96,
            0
          ],
          [
            104,
            18
          ]
        ],
        [
          "typedef struct {\n  char *dname;\n} ares__dns_ptr_t;",
          {
            "*dname": "char"
          },
          "ares__dns_ptr_t",
          [
            106,
            0
          ],
          [
            108,
            18
          ]
        ],
        [
          "typedef struct {\n  char *cpu;\n  char *os;\n} ares__dns_hinfo_t;",
          {
            "*cpu": "char",
            "*os": "char"
          },
          "ares__dns_hinfo_t",
          [
            110,
            0
          ],
          [
            113,
            20
          ]
        ],
        [
          "typedef struct {\n  unsigned short preference;\n  char          *exchange;\n} ares__dns_mx_t;",
          {
            "preference": "unsigned short",
            "*exchange": "char"
          },
          "ares__dns_mx_t",
          [
            115,
            0
          ],
          [
            118,
            17
          ]
        ],
        [
          "typedef struct {\n  char  *data;\n  size_t data_len;\n} ares__dns_txt_t;",
          {
            "*data": "char",
            "data_len": "size_t"
          },
          "ares__dns_txt_t",
          [
            120,
            0
          ],
          [
            123,
            18
          ]
        ],
        [
          "typedef struct {\n  struct ares_in6_addr addr;\n} ares__dns_aaaa_t;",
          {
            "addr": "struct ares_in6_addr"
          },
          "ares__dns_aaaa_t",
          [
            125,
            0
          ],
          [
            127,
            19
          ]
        ],
        [
          "typedef struct {\n  unsigned short priority;\n  unsigned short weight;\n  unsigned short port;\n  char          *target;\n} ares__dns_srv_t;",
          {
            "priority": "unsigned short",
            "weight": "unsigned short",
            "port": "unsigned short",
            "*target": "char"
          },
          "ares__dns_srv_t",
          [
            129,
            0
          ],
          [
            134,
            18
          ]
        ],
        [
          "typedef struct {\n  unsigned short order;\n  unsigned short preference;\n  char          *flags;\n  char          *services;\n  char          *regexp;\n  char          *replacement;\n} ares__dns_naptr_t;",
          {
            "order": "unsigned short",
            "preference": "unsigned short",
            "*flags": "char",
            "*services": "char",
            "*regexp": "char",
            "*replacement": "char"
          },
          "ares__dns_naptr_t",
          [
            136,
            0
          ],
          [
            143,
            20
          ]
        ],
        [
          "typedef struct {\n  unsigned short opt;\n  unsigned char *val;\n  size_t         val_len;\n} ares__dns_optval_t;",
          {
            "opt": "unsigned short",
            "*val": "unsigned char",
            "val_len": "size_t"
          },
          "ares__dns_optval_t",
          [
            145,
            0
          ],
          [
            149,
            21
          ]
        ],
        [
          "typedef struct {\n  ares__dns_optval_t *optval; /*!< Attribute/value pairs */\n  size_t              cnt;    /*!< Count of Attribute/Value pairs */\n  size_t              alloc;  /*!< Allocated count of attribute/value\n                               *   pairs */\n} ares__dns_options_t;",
          {
            "*optval": "ares__dns_optval_t",
            "cnt": "size_t",
            "alloc": "size_t"
          },
          "ares__dns_options_t",
          [
            151,
            0
          ],
          [
            156,
            22
          ]
        ],
        [
          "typedef struct {\n  unsigned short       udp_size; /*!< taken from class */\n  unsigned char        version;  /*!< taken from bits 8-16 of ttl */\n  unsigned short       flags;    /*!< Flags, remaining 16 bits, though only\n                                  *   1 currently defined */\n  ares__dns_options_t *options;  /*!< Attribute/Value pairs */\n} ares__dns_opt_t;",
          {
            "udp_size": "unsigned short",
            "version": "unsigned char",
            "flags": "unsigned short",
            "*options": "ares__dns_options_t"
          },
          "ares__dns_opt_t",
          [
            158,
            0
          ],
          [
            164,
            18
          ]
        ],
        [
          "typedef struct {\n  unsigned char  cert_usage;\n  unsigned char  selector;\n  unsigned char  match;\n  unsigned char *data;\n  size_t         data_len;\n} ares__dns_tlsa_t;",
          {
            "cert_usage": "unsigned char",
            "selector": "unsigned char",
            "match": "unsigned char",
            "*data": "unsigned char",
            "data_len": "size_t"
          },
          "ares__dns_tlsa_t",
          [
            166,
            0
          ],
          [
            172,
            19
          ]
        ],
        [
          "typedef struct {\n  unsigned short       priority;\n  char                *target;\n  ares__dns_options_t *params;\n} ares__dns_svcb_t;",
          {
            "priority": "unsigned short",
            "*target": "char",
            "*params": "ares__dns_options_t"
          },
          "ares__dns_svcb_t",
          [
            174,
            0
          ],
          [
            178,
            19
          ]
        ],
        [
          "typedef struct {\n  unsigned short priority;\n  unsigned short weight;\n  char          *target;\n} ares__dns_uri_t;",
          {
            "priority": "unsigned short",
            "weight": "unsigned short",
            "*target": "char"
          },
          "ares__dns_uri_t",
          [
            180,
            0
          ],
          [
            184,
            18
          ]
        ],
        [
          "typedef struct {\n  unsigned char  critical;\n  char          *tag;\n  unsigned char *value;\n  size_t         value_len;\n} ares__dns_caa_t;",
          {
            "critical": "unsigned char",
            "*tag": "char",
            "*value": "unsigned char",
            "value_len": "size_t"
          },
          "ares__dns_caa_t",
          [
            186,
            0
          ],
          [
            191,
            18
          ]
        ],
        [
          "typedef struct {\n  unsigned short type;   /*!< Not ares_rec_type_t because it likely isn't one\n                          *   of those values since it wasn't parsed */\n  unsigned char *data;   /*!< Raw RR data */\n  size_t         length; /*!< Length of raw RR data */\n} ares__dns_raw_rr_t;",
          {
            "type": "unsigned short",
            "*data": "unsigned char",
            "length": "size_t"
          },
          "ares__dns_raw_rr_t",
          [
            194,
            0
          ],
          [
            199,
            21
          ]
        ],
        [
          "struct ares_dns_rr {\n  ares_dns_record_t  *parent;\n  char               *name;\n  ares_dns_rec_type_t type;\n  ares_dns_class_t    rclass;\n  unsigned int        ttl;\n\n  union {\n    ares__dns_a_t      a;\n    ares__dns_ns_t     ns;\n    ares__dns_cname_t  cname;\n    ares__dns_soa_t    soa;\n    ares__dns_ptr_t    ptr;\n    ares__dns_hinfo_t  hinfo;\n    ares__dns_mx_t     mx;\n    ares__dns_txt_t    txt;\n    ares__dns_aaaa_t   aaaa;\n    ares__dns_srv_t    srv;\n    ares__dns_naptr_t  naptr;\n    ares__dns_opt_t    opt;\n    ares__dns_tlsa_t   tlsa;\n    ares__dns_svcb_t   svcb;\n    ares__dns_svcb_t   https; /*!< https is a type of svcb, so this is right */\n    ares__dns_uri_t    uri;\n    ares__dns_caa_t    caa;\n    ares__dns_raw_rr_t raw_rr;\n  } r;\n}",
          {
            "*parent": "ares_dns_record_t",
            "*name": "char",
            "type": "ares_dns_rec_type_t",
            "rclass": "ares_dns_class_t",
            "ttl": "unsigned int",
            "r": "union {\n    ares__dns_a_t      a;\n    ares__dns_ns_t     ns;\n    ares__dns_cname_t  cname;\n    ares__dns_soa_t    soa;\n    ares__dns_ptr_t    ptr;\n    ares__dns_hinfo_t  hinfo;\n    ares__dns_mx_t     mx;\n    ares__dns_txt_t    txt;\n    ares__dns_aaaa_t   aaaa;\n    ares__dns_srv_t    srv;\n    ares__dns_naptr_t  naptr;\n    ares__dns_opt_t    opt;\n    ares__dns_tlsa_t   tlsa;\n    ares__dns_svcb_t   svcb;\n    ares__dns_svcb_t   https; /*!< https is a type of svcb, so this is right */\n    ares__dns_uri_t    uri;\n    ares__dns_caa_t    caa;\n    ares__dns_raw_rr_t raw_rr;\n  }",
            "a": "ares__dns_a_t",
            "ns": "ares__dns_ns_t",
            "cname": "ares__dns_cname_t",
            "soa": "ares__dns_soa_t",
            "ptr": "ares__dns_ptr_t",
            "hinfo": "ares__dns_hinfo_t",
            "mx": "ares__dns_mx_t",
            "txt": "ares__dns_txt_t",
            "aaaa": "ares__dns_aaaa_t",
            "srv": "ares__dns_srv_t",
            "naptr": "ares__dns_naptr_t",
            "opt": "ares__dns_opt_t",
            "tlsa": "ares__dns_tlsa_t",
            "svcb": "ares__dns_svcb_t",
            "https": "ares__dns_svcb_t",
            "uri": "ares__dns_uri_t",
            "caa": "ares__dns_caa_t",
            "raw_rr": "ares__dns_raw_rr_t"
          },
          "ares_dns_rr",
          [
            202,
            0
          ],
          [
            229,
            1
          ]
        ],
        [
          "struct ares_dns_record {\n  unsigned short    id;            /*!< DNS query id */\n  unsigned short    flags;         /*!< One or more ares_dns_flags_t */\n  ares_dns_opcode_t opcode;        /*!< DNS Opcode */\n  ares_dns_rcode_t  rcode;         /*!< DNS RCODE */\n  unsigned short    raw_rcode;     /*!< Raw rcode, used to ultimately form real\n                                    *   rcode after reading OPT record if it\n                                    *   exists */\n  unsigned int      ttl_decrement; /*!< Special case to apply to writing out\n                                    *   this record, where it will decrement\n                                    *   the ttl of any resource records by\n                                    *   this amount.  Used for cache */\n\n  ares_dns_qd_t    *qd;\n  size_t            qdcount;\n  size_t            qdalloc;\n\n  ares_dns_rr_t    *an;\n  size_t            ancount;\n  size_t            analloc;\n\n  ares_dns_rr_t    *ns;\n  size_t            nscount;\n  size_t            nsalloc;\n\n  ares_dns_rr_t    *ar;\n  size_t            arcount;\n  size_t            aralloc;\n}",
          {
            "id": "unsigned short",
            "flags": "unsigned short",
            "opcode": "ares_dns_opcode_t",
            "rcode": "ares_dns_rcode_t",
            "raw_rcode": "unsigned short",
            "ttl_decrement": "unsigned int",
            "*qd": "ares_dns_qd_t",
            "qdcount": "size_t",
            "qdalloc": "size_t",
            "*an": "ares_dns_rr_t",
            "ancount": "size_t",
            "analloc": "size_t",
            "*ns": "ares_dns_rr_t",
            "nscount": "size_t",
            "nsalloc": "size_t",
            "*ar": "ares_dns_rr_t",
            "arcount": "size_t",
            "aralloc": "size_t"
          },
          "ares_dns_record",
          [
            232,
            0
          ],
          [
            260,
            1
          ]
        ],
        [
          "struct ares_dns_qd {\n  char               *name;\n  ares_dns_rec_type_t qtype;\n  ares_dns_class_t    qclass;\n}",
          {
            "*name": "char",
            "qtype": "ares_dns_rec_type_t",
            "qclass": "ares_dns_class_t"
          },
          "ares_dns_qd",
          [
            78,
            0
          ],
          [
            82,
            1
          ]
        ],
        [
          "typedef struct {\n  struct in_addr addr;\n} ares__dns_a_t;",
          {
            "addr": "struct in_addr"
          },
          "ares__dns_a_t",
          [
            84,
            0
          ],
          [
            86,
            16
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            85,
            2
          ],
          [
            85,
            16
          ]
        ],
        [
          "typedef struct {\n  char *nsdname;\n} ares__dns_ns_t;",
          {
            "*nsdname": "char"
          },
          "ares__dns_ns_t",
          [
            88,
            0
          ],
          [
            90,
            17
          ]
        ],
        [
          "typedef struct {\n  char *cname;\n} ares__dns_cname_t;",
          {
            "*cname": "char"
          },
          "ares__dns_cname_t",
          [
            92,
            0
          ],
          [
            94,
            20
          ]
        ],
        [
          "typedef struct {\n  char        *mname;\n  char        *rname;\n  unsigned int serial;\n  unsigned int refresh;\n  unsigned int retry;\n  unsigned int expire;\n  unsigned int minimum;\n} ares__dns_soa_t;",
          {
            "*mname": "char",
            "*rname": "char",
            "serial": "unsigned int",
            "refresh": "unsigned int",
            "retry": "unsigned int",
            "expire": "unsigned int",
            "minimum": "unsigned int"
          },
          "ares__dns_soa_t",
          [
            96,
            0
          ],
          [
            104,
            18
          ]
        ],
        [
          "typedef struct {\n  char *dname;\n} ares__dns_ptr_t;",
          {
            "*dname": "char"
          },
          "ares__dns_ptr_t",
          [
            106,
            0
          ],
          [
            108,
            18
          ]
        ],
        [
          "typedef struct {\n  char *cpu;\n  char *os;\n} ares__dns_hinfo_t;",
          {
            "*cpu": "char",
            "*os": "char"
          },
          "ares__dns_hinfo_t",
          [
            110,
            0
          ],
          [
            113,
            20
          ]
        ],
        [
          "typedef struct {\n  unsigned short preference;\n  char          *exchange;\n} ares__dns_mx_t;",
          {
            "preference": "unsigned short",
            "*exchange": "char"
          },
          "ares__dns_mx_t",
          [
            115,
            0
          ],
          [
            118,
            17
          ]
        ],
        [
          "typedef struct {\n  char  *data;\n  size_t data_len;\n} ares__dns_txt_t;",
          {
            "*data": "char",
            "data_len": "size_t"
          },
          "ares__dns_txt_t",
          [
            120,
            0
          ],
          [
            123,
            18
          ]
        ],
        [
          "typedef struct {\n  struct ares_in6_addr addr;\n} ares__dns_aaaa_t;",
          {
            "addr": "struct ares_in6_addr"
          },
          "ares__dns_aaaa_t",
          [
            125,
            0
          ],
          [
            127,
            19
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            126,
            2
          ],
          [
            126,
            22
          ]
        ],
        [
          "typedef struct {\n  unsigned short priority;\n  unsigned short weight;\n  unsigned short port;\n  char          *target;\n} ares__dns_srv_t;",
          {
            "priority": "unsigned short",
            "weight": "unsigned short",
            "port": "unsigned short",
            "*target": "char"
          },
          "ares__dns_srv_t",
          [
            129,
            0
          ],
          [
            134,
            18
          ]
        ],
        [
          "typedef struct {\n  unsigned short order;\n  unsigned short preference;\n  char          *flags;\n  char          *services;\n  char          *regexp;\n  char          *replacement;\n} ares__dns_naptr_t;",
          {
            "order": "unsigned short",
            "preference": "unsigned short",
            "*flags": "char",
            "*services": "char",
            "*regexp": "char",
            "*replacement": "char"
          },
          "ares__dns_naptr_t",
          [
            136,
            0
          ],
          [
            143,
            20
          ]
        ],
        [
          "typedef struct {\n  unsigned short opt;\n  unsigned char *val;\n  size_t         val_len;\n} ares__dns_optval_t;",
          {
            "opt": "unsigned short",
            "*val": "unsigned char",
            "val_len": "size_t"
          },
          "ares__dns_optval_t",
          [
            145,
            0
          ],
          [
            149,
            21
          ]
        ],
        [
          "typedef struct {\n  ares__dns_optval_t *optval; /*!< Attribute/value pairs */\n  size_t              cnt;    /*!< Count of Attribute/Value pairs */\n  size_t              alloc;  /*!< Allocated count of attribute/value\n                               *   pairs */\n} ares__dns_options_t;",
          {
            "*optval": "ares__dns_optval_t",
            "cnt": "size_t",
            "alloc": "size_t"
          },
          "ares__dns_options_t",
          [
            151,
            0
          ],
          [
            156,
            22
          ]
        ],
        [
          "typedef struct {\n  unsigned short       udp_size; /*!< taken from class */\n  unsigned char        version;  /*!< taken from bits 8-16 of ttl */\n  unsigned short       flags;    /*!< Flags, remaining 16 bits, though only\n                                  *   1 currently defined */\n  ares__dns_options_t *options;  /*!< Attribute/Value pairs */\n} ares__dns_opt_t;",
          {
            "udp_size": "unsigned short",
            "version": "unsigned char",
            "flags": "unsigned short",
            "*options": "ares__dns_options_t"
          },
          "ares__dns_opt_t",
          [
            158,
            0
          ],
          [
            164,
            18
          ]
        ],
        [
          "typedef struct {\n  unsigned char  cert_usage;\n  unsigned char  selector;\n  unsigned char  match;\n  unsigned char *data;\n  size_t         data_len;\n} ares__dns_tlsa_t;",
          {
            "cert_usage": "unsigned char",
            "selector": "unsigned char",
            "match": "unsigned char",
            "*data": "unsigned char",
            "data_len": "size_t"
          },
          "ares__dns_tlsa_t",
          [
            166,
            0
          ],
          [
            172,
            19
          ]
        ],
        [
          "typedef struct {\n  unsigned short       priority;\n  char                *target;\n  ares__dns_options_t *params;\n} ares__dns_svcb_t;",
          {
            "priority": "unsigned short",
            "*target": "char",
            "*params": "ares__dns_options_t"
          },
          "ares__dns_svcb_t",
          [
            174,
            0
          ],
          [
            178,
            19
          ]
        ],
        [
          "typedef struct {\n  unsigned short priority;\n  unsigned short weight;\n  char          *target;\n} ares__dns_uri_t;",
          {
            "priority": "unsigned short",
            "weight": "unsigned short",
            "*target": "char"
          },
          "ares__dns_uri_t",
          [
            180,
            0
          ],
          [
            184,
            18
          ]
        ],
        [
          "typedef struct {\n  unsigned char  critical;\n  char          *tag;\n  unsigned char *value;\n  size_t         value_len;\n} ares__dns_caa_t;",
          {
            "critical": "unsigned char",
            "*tag": "char",
            "*value": "unsigned char",
            "value_len": "size_t"
          },
          "ares__dns_caa_t",
          [
            186,
            0
          ],
          [
            191,
            18
          ]
        ],
        [
          "typedef struct {\n  unsigned short type;   /*!< Not ares_rec_type_t because it likely isn't one\n                          *   of those values since it wasn't parsed */\n  unsigned char *data;   /*!< Raw RR data */\n  size_t         length; /*!< Length of raw RR data */\n} ares__dns_raw_rr_t;",
          {
            "type": "unsigned short",
            "*data": "unsigned char",
            "length": "size_t"
          },
          "ares__dns_raw_rr_t",
          [
            194,
            0
          ],
          [
            199,
            21
          ]
        ],
        [
          "struct ares_dns_rr {\n  ares_dns_record_t  *parent;\n  char               *name;\n  ares_dns_rec_type_t type;\n  ares_dns_class_t    rclass;\n  unsigned int        ttl;\n\n  union {\n    ares__dns_a_t      a;\n    ares__dns_ns_t     ns;\n    ares__dns_cname_t  cname;\n    ares__dns_soa_t    soa;\n    ares__dns_ptr_t    ptr;\n    ares__dns_hinfo_t  hinfo;\n    ares__dns_mx_t     mx;\n    ares__dns_txt_t    txt;\n    ares__dns_aaaa_t   aaaa;\n    ares__dns_srv_t    srv;\n    ares__dns_naptr_t  naptr;\n    ares__dns_opt_t    opt;\n    ares__dns_tlsa_t   tlsa;\n    ares__dns_svcb_t   svcb;\n    ares__dns_svcb_t   https; /*!< https is a type of svcb, so this is right */\n    ares__dns_uri_t    uri;\n    ares__dns_caa_t    caa;\n    ares__dns_raw_rr_t raw_rr;\n  } r;\n}",
          {
            "*parent": "ares_dns_record_t",
            "*name": "char",
            "type": "ares_dns_rec_type_t",
            "rclass": "ares_dns_class_t",
            "ttl": "unsigned int",
            "r": "union {\n    ares__dns_a_t      a;\n    ares__dns_ns_t     ns;\n    ares__dns_cname_t  cname;\n    ares__dns_soa_t    soa;\n    ares__dns_ptr_t    ptr;\n    ares__dns_hinfo_t  hinfo;\n    ares__dns_mx_t     mx;\n    ares__dns_txt_t    txt;\n    ares__dns_aaaa_t   aaaa;\n    ares__dns_srv_t    srv;\n    ares__dns_naptr_t  naptr;\n    ares__dns_opt_t    opt;\n    ares__dns_tlsa_t   tlsa;\n    ares__dns_svcb_t   svcb;\n    ares__dns_svcb_t   https; /*!< https is a type of svcb, so this is right */\n    ares__dns_uri_t    uri;\n    ares__dns_caa_t    caa;\n    ares__dns_raw_rr_t raw_rr;\n  }",
            "a": "ares__dns_a_t",
            "ns": "ares__dns_ns_t",
            "cname": "ares__dns_cname_t",
            "soa": "ares__dns_soa_t",
            "ptr": "ares__dns_ptr_t",
            "hinfo": "ares__dns_hinfo_t",
            "mx": "ares__dns_mx_t",
            "txt": "ares__dns_txt_t",
            "aaaa": "ares__dns_aaaa_t",
            "srv": "ares__dns_srv_t",
            "naptr": "ares__dns_naptr_t",
            "opt": "ares__dns_opt_t",
            "tlsa": "ares__dns_tlsa_t",
            "svcb": "ares__dns_svcb_t",
            "https": "ares__dns_svcb_t",
            "uri": "ares__dns_uri_t",
            "caa": "ares__dns_caa_t",
            "raw_rr": "ares__dns_raw_rr_t"
          },
          "ares_dns_rr",
          [
            202,
            0
          ],
          [
            229,
            1
          ]
        ],
        [
          "struct ares_dns_record {\n  unsigned short    id;            /*!< DNS query id */\n  unsigned short    flags;         /*!< One or more ares_dns_flags_t */\n  ares_dns_opcode_t opcode;        /*!< DNS Opcode */\n  ares_dns_rcode_t  rcode;         /*!< DNS RCODE */\n  unsigned short    raw_rcode;     /*!< Raw rcode, used to ultimately form real\n                                    *   rcode after reading OPT record if it\n                                    *   exists */\n  unsigned int      ttl_decrement; /*!< Special case to apply to writing out\n                                    *   this record, where it will decrement\n                                    *   the ttl of any resource records by\n                                    *   this amount.  Used for cache */\n\n  ares_dns_qd_t    *qd;\n  size_t            qdcount;\n  size_t            qdalloc;\n\n  ares_dns_rr_t    *an;\n  size_t            ancount;\n  size_t            analloc;\n\n  ares_dns_rr_t    *ns;\n  size_t            nscount;\n  size_t            nsalloc;\n\n  ares_dns_rr_t    *ar;\n  size_t            arcount;\n  size_t            aralloc;\n}",
          {
            "id": "unsigned short",
            "flags": "unsigned short",
            "opcode": "ares_dns_opcode_t",
            "rcode": "ares_dns_rcode_t",
            "raw_rcode": "unsigned short",
            "ttl_decrement": "unsigned int",
            "*qd": "ares_dns_qd_t",
            "qdcount": "size_t",
            "qdalloc": "size_t",
            "*an": "ares_dns_rr_t",
            "ancount": "size_t",
            "analloc": "size_t",
            "*ns": "ares_dns_rr_t",
            "nscount": "size_t",
            "nsalloc": "size_t",
            "*ar": "ares_dns_rr_t",
            "arcount": "size_t",
            "aralloc": "size_t"
          },
          "ares_dns_record",
          [
            232,
            0
          ],
          [
            260,
            1
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/inet_ntop.c.h": {
      "fn_def_list": [
        {
          "fn_code": "static const char *inet_ntop6(const unsigned char *src, char *dst, size_t size){return 0}",
          "fn_code_pos": [
            [
              78,
              0
            ],
            [
              78,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inet_ntop6",
            "parameters": {
              "src": "unsigned char",
              "dst": "char",
              "size": "size_t"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "inet_ntop4(const unsigned char *src, char *dst, size_t size)",
          "fn_dec_pos": [
            [
              41,
              19
            ],
            [
              41,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inet_ntop4",
            "parameters": {
              "src": "unsigned char",
              "dst": "char",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_inet_ntop(int af, const void *src, char *dst,\n                                  ares_socklen_t size)",
          "fn_dec_pos": [
            [
              57,
              19
            ],
            [
              58,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_ntop",
            "parameters": {
              "af": "int",
              "src": "void",
              "dst": "char",
              "size": "ares_socklen_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "inet_ntop4(const unsigned char *src, char *dst, size_t size)",
          "fn_dec_pos": [
            [
              71,
              19
            ],
            [
              71,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inet_ntop4",
            "parameters": {
              "src": "unsigned char",
              "dst": "char",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "inet_ntop6(const unsigned char *src, char *dst, size_t size)",
          "fn_dec_pos": [
            [
              78,
              19
            ],
            [
              78,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inet_ntop6",
            "parameters": {
              "src": "unsigned char",
              "dst": "char",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_inet_ntop(int af, const void *src, char *dst,\n                           ares_socklen_t size)",
          "fn_dec_pos": [
            [
              81,
              12
            ],
            [
              82,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_ntop",
            "parameters": {
              "af": "int",
              "src": "void",
              "dst": "char",
              "size": "ares_socklen_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#  include <arpa/inet.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares_ipv6.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_event.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*ares_event_cb_t)(ares_event_thread_t *e, ares_socket_t fd,\n                                void *data, ares_event_flags_t flags)",
          "fn_dec_pos": [
            [
              40,
              13
            ],
            [
              41,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "e": "ares_event_thread_t",
              "fd": "ares_socket_t",
              "data": "void",
              "flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_event_free_data_t)(void *data)",
          "fn_dec_pos": [
            [
              43,
              13
            ],
            [
              43,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_event_signal_cb_t)(const ares_event_t *event)",
          "fn_dec_pos": [
            [
              45,
              13
            ],
            [
              45,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*init)(ares_event_thread_t *e)",
          "fn_dec_pos": [
            [
              73,
              14
            ],
            [
              73,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "(*destroy)(ares_event_thread_t *e)",
          "fn_dec_pos": [
            [
              74,
              7
            ],
            [
              74,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*event_add)(ares_event_t *event)",
          "fn_dec_pos": [
            [
              75,
              14
            ],
            [
              75,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "(*event_del)(ares_event_t *event)",
          "fn_dec_pos": [
            [
              76,
              7
            ],
            [
              76,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "event": "ares_event_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*event_mod)(ares_event_t *event, ares_event_flags_t new_flags)",
          "fn_dec_pos": [
            [
              77,
              7
            ],
            [
              77,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "event": "ares_event_t",
              "new_flags": "ares_event_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*wait)(ares_event_thread_t *e, unsigned long timeout_ms)",
          "fn_dec_pos": [
            [
              78,
              9
            ],
            [
              78,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "e": "ares_event_thread_t",
              "timeout_ms": "unsigned long"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares_event_update(ares_event_t **event, ares_event_thread_t *e,\n                                ares_event_flags_t flags, ares_event_cb_t cb,\n                                ares_socket_t fd, void *data,\n                                ares_event_free_data_t free_data_cb,\n                                ares_event_signal_cb_t signal_cb)",
          "fn_dec_pos": [
            [
              140,
              14
            ],
            [
              144,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_event_update",
            "parameters": {
              "event": "ares_event_t",
              "e": "ares_event_thread_t",
              "flags": "ares_event_flags_t",
              "cb": "ares_event_cb_t",
              "fd": "ares_socket_t",
              "data": "void",
              "free_data_cb": "ares_event_free_data_t",
              "signal_cb": "ares_event_signal_cb_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares_pipeevent_create(ares_event_thread_t *e)",
          "fn_dec_pos": [
            [
              148,
              14
            ],
            [
              148,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_pipeevent_create",
            "parameters": {
              "e": "ares_event_thread_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_event {\n  /*! Registered event thread this event is bound to */\n  ares_event_thread_t   *e;\n  /*! Flags to monitor. OTHER is only allowed if the socket is ARES_SOCKET_BAD.\n   */\n  ares_event_flags_t     flags;\n  /*! Callback to be called when event is triggered */\n  ares_event_cb_t        cb;\n  /*! Socket to monitor, allowed to be ARES_SOCKET_BAD if not monitoring a\n   *  socket. */\n  ares_socket_t          fd;\n  /*! Data associated with event handle that will be passed to the callback.\n   *  Typically OS/event subsystem specific data.\n   *  Optional, may be NULL. */\n  /*! Data to be passed to callback. Optional, may be NULL. */\n  void                  *data;\n  /*! When cleaning up the registered event (either when removed or during\n   *  shutdown), this function will be called to clean up the user-supplied\n   *  data. Optional, May be NULL. */\n  ares_event_free_data_t free_data_cb;\n  /*! Callback to call to trigger an event. */\n  ares_event_signal_cb_t signal_cb;\n}",
          {
            "*e": "ares_event_thread_t",
            "flags": "ares_event_flags_t",
            "cb": "ares_event_cb_t",
            "fd": "ares_socket_t",
            "*data": "void",
            "free_data_cb": "ares_event_free_data_t",
            "signal_cb": "ares_event_signal_cb_t"
          },
          "ares_event",
          [
            47,
            0
          ],
          [
            69,
            1
          ]
        ],
        [
          "typedef struct {\n  const char *name;\n  ares_bool_t (*init)(ares_event_thread_t *e);\n  void (*destroy)(ares_event_thread_t *e);\n  ares_bool_t (*event_add)(ares_event_t *event);\n  void (*event_del)(ares_event_t *event);\n  void (*event_mod)(ares_event_t *event, ares_event_flags_t new_flags);\n  size_t (*wait)(ares_event_thread_t *e, unsigned long timeout_ms);\n} ares_event_sys_t;",
          {
            "char": "const",
            "(*init)(ares_event_thread_t *e)": "ares_bool_t",
            "(*destroy)(ares_event_thread_t *e)": "void",
            "(*event_add)(ares_event_t *event)": "ares_bool_t",
            "(*event_del)(ares_event_t *event)": "void",
            "(*event_mod)(ares_event_t *event, ares_event_flags_t new_flags)": "void",
            "(*wait)(ares_event_thread_t *e, unsigned long timeout_ms)": "size_t"
          },
          "ares_event_sys_t",
          [
            71,
            0
          ],
          [
            79,
            19
          ]
        ],
        [
          "struct ares_event_thread {\n  /*! Whether the event thread should be online or not.  Checked on every wake\n   *  event before sleeping. */\n  ares_bool_t             isup;\n  /*! Handle to the thread for joining during shutdown */\n  ares__thread_t         *thread;\n  /*! Lock to protect the data contained within the event thread itself */\n  ares__thread_mutex_t   *mutex;\n  /*! Reference to the ares channel, for being able to call things like\n   *  ares_timeout() and ares_process_fd(). */\n  ares_channel_t         *channel;\n  /*! Not-yet-processed event handle updates.  These will get enqueued by a\n   *  thread other than the event thread itself. The event thread will then\n   *  be woken then process these updates itself */\n  ares__llist_t          *ev_updates;\n  /*! Registered event handles. */\n  ares__htable_asvp_t    *ev_handles;\n  /*! Pointer to the event handle which is used to signal and wake the event\n   *  thread itself.  This is needed to be able to do things like update the\n   *  file descriptors being waited on and to wake the event subsystem during\n   *  shutdown */\n  ares_event_t           *ev_signal;\n  /* Event subsystem callbacks */\n  const ares_event_sys_t *ev_sys;\n  /* Event subsystem private data */\n  void                   *ev_sys_data;\n}",
          {
            "isup": "ares_bool_t",
            "*thread": "ares__thread_t",
            "*mutex": "ares__thread_mutex_t",
            "*channel": "ares_channel_t",
            "*ev_updates": "ares__llist_t",
            "*ev_handles": "ares__htable_asvp_t",
            "*ev_signal": "ares_event_t",
            "ares_event_sys_t": "const",
            "*ev_sys_data": "void"
          },
          "ares_event_thread",
          [
            81,
            0
          ],
          [
            107,
            1
          ]
        ],
        [
          "struct ares_event",
          {},
          "",
          [
            30,
            0
          ],
          [
            30,
            17
          ]
        ],
        [
          "typedef struct ares_event ares_event_t;",
          {},
          "ares_event_t",
          [
            31,
            0
          ],
          [
            31,
            39
          ]
        ],
        [
          "struct ares_event {\n  /*! Registered event thread this event is bound to */\n  ares_event_thread_t   *e;\n  /*! Flags to monitor. OTHER is only allowed if the socket is ARES_SOCKET_BAD.\n   */\n  ares_event_flags_t     flags;\n  /*! Callback to be called when event is triggered */\n  ares_event_cb_t        cb;\n  /*! Socket to monitor, allowed to be ARES_SOCKET_BAD if not monitoring a\n   *  socket. */\n  ares_socket_t          fd;\n  /*! Data associated with event handle that will be passed to the callback.\n   *  Typically OS/event subsystem specific data.\n   *  Optional, may be NULL. */\n  /*! Data to be passed to callback. Optional, may be NULL. */\n  void                  *data;\n  /*! When cleaning up the registered event (either when removed or during\n   *  shutdown), this function will be called to clean up the user-supplied\n   *  data. Optional, May be NULL. */\n  ares_event_free_data_t free_data_cb;\n  /*! Callback to call to trigger an event. */\n  ares_event_signal_cb_t signal_cb;\n}",
          {
            "*e": "ares_event_thread_t",
            "flags": "ares_event_flags_t",
            "cb": "ares_event_cb_t",
            "fd": "ares_socket_t",
            "*data": "void",
            "free_data_cb": "ares_event_free_data_t",
            "signal_cb": "ares_event_signal_cb_t"
          },
          "ares_event",
          [
            47,
            0
          ],
          [
            69,
            1
          ]
        ],
        [
          "typedef struct {\n  const char *name;\n  ares_bool_t (*init)(ares_event_thread_t *e);\n  void (*destroy)(ares_event_thread_t *e);\n  ares_bool_t (*event_add)(ares_event_t *event);\n  void (*event_del)(ares_event_t *event);\n  void (*event_mod)(ares_event_t *event, ares_event_flags_t new_flags);\n  size_t (*wait)(ares_event_thread_t *e, unsigned long timeout_ms);\n} ares_event_sys_t;",
          {
            "char": "const",
            "(*init)(ares_event_thread_t *e)": "ares_bool_t",
            "(*destroy)(ares_event_thread_t *e)": "void",
            "(*event_add)(ares_event_t *event)": "ares_bool_t",
            "(*event_del)(ares_event_t *event)": "void",
            "(*event_mod)(ares_event_t *event, ares_event_flags_t new_flags)": "void",
            "(*wait)(ares_event_thread_t *e, unsigned long timeout_ms)": "size_t"
          },
          "ares_event_sys_t",
          [
            71,
            0
          ],
          [
            79,
            19
          ]
        ],
        [
          "struct ares_event_thread {\n  /*! Whether the event thread should be online or not.  Checked on every wake\n   *  event before sleeping. */\n  ares_bool_t             isup;\n  /*! Handle to the thread for joining during shutdown */\n  ares__thread_t         *thread;\n  /*! Lock to protect the data contained within the event thread itself */\n  ares__thread_mutex_t   *mutex;\n  /*! Reference to the ares channel, for being able to call things like\n   *  ares_timeout() and ares_process_fd(). */\n  ares_channel_t         *channel;\n  /*! Not-yet-processed event handle updates.  These will get enqueued by a\n   *  thread other than the event thread itself. The event thread will then\n   *  be woken then process these updates itself */\n  ares__llist_t          *ev_updates;\n  /*! Registered event handles. */\n  ares__htable_asvp_t    *ev_handles;\n  /*! Pointer to the event handle which is used to signal and wake the event\n   *  thread itself.  This is needed to be able to do things like update the\n   *  file descriptors being waited on and to wake the event subsystem during\n   *  shutdown */\n  ares_event_t           *ev_signal;\n  /* Event subsystem callbacks */\n  const ares_event_sys_t *ev_sys;\n  /* Event subsystem private data */\n  void                   *ev_sys_data;\n}",
          {
            "isup": "ares_bool_t",
            "*thread": "ares__thread_t",
            "*mutex": "ares__thread_mutex_t",
            "*channel": "ares_channel_t",
            "*ev_updates": "ares__llist_t",
            "*ev_handles": "ares__htable_asvp_t",
            "*ev_signal": "ares_event_t",
            "ares_event_sys_t": "const",
            "*ev_sys_data": "void"
          },
          "ares_event_thread",
          [
            81,
            0
          ],
          [
            107,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  ARES_EVENT_FLAG_NONE  = 0,\n  ARES_EVENT_FLAG_READ  = 1 << 0,\n  ARES_EVENT_FLAG_WRITE = 1 << 1,\n  ARES_EVENT_FLAG_OTHER = 1 << 2\n} ares_event_flags_t;",
          {
            "ARES_EVENT_FLAG_NONE": "",
            "ARES_EVENT_FLAG_READ": "",
            "ARES_EVENT_FLAG_WRITE": "",
            "ARES_EVENT_FLAG_OTHER": ""
          },
          "ares_event_flags_t",
          [
            33,
            0
          ],
          [
            38,
            21
          ]
        ]
      ]
    },
    "../docker_shared/source_code/c-ares/src/lib/ares_setup.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#  include \"ares_config.h\"\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#    include \"config-win32.h\"\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <ares_build.h>\n",
          [
            93,
            0
          ],
          [
            94,
            0
          ]
        ],
        [
          "#include <ares_rules.h>\n",
          [
            99,
            0
          ],
          [
            100,
            0
          ]
        ],
        [
          "#  include <windows.h>\n",
          [
            121,
            0
          ],
          [
            122,
            0
          ]
        ],
        [
          "#    include <winsock2.h>\n",
          [
            123,
            0
          ],
          [
            124,
            0
          ]
        ],
        [
          "#      include <ws2tcpip.h>\n",
          [
            125,
            0
          ],
          [
            126,
            0
          ]
        ],
        [
          "#      include <winsock.h>\n",
          [
            129,
            0
          ],
          [
            130,
            0
          ]
        ],
        [
          "#  include <sys/types.h>\n",
          [
            184,
            0
          ],
          [
            185,
            0
          ]
        ],
        [
          "#  include <unistd.h>\n",
          [
            185,
            0
          ],
          [
            186,
            0
          ]
        ],
        [
          "#  include \"setup_once.h\"\n",
          [
            242,
            0
          ],
          [
            243,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/config-dos.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#  include <sys/types.h> /* For 'ssize_t' */\n",
          [
            67,
            0
          ],
          [
            68,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/date.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "Date(int year, int month, int day)",
          "fn_dec_pos": [
            [
              11,
              4
            ],
            [
              11,
              38
            ]
          ],
          "class_code": "ced13827b2e9b731b82f1847da07d27b0ab901665ded1bf4c698d15d4aff46f7",
          "class_node_pos": [
            [
              3,
              0
            ],
            [
              18,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Date",
            "parameters": {
              "year": "int",
              "month": "int",
              "day": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "print() const",
          "fn_dec_pos": [
            [
              13,
              9
            ],
            [
              13,
              22
            ]
          ],
          "class_code": "ced13827b2e9b731b82f1847da07d27b0ab901665ded1bf4c698d15d4aff46f7",
          "class_node_pos": [
            [
              3,
              0
            ],
            [
              18,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "print",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "getYear() const",
          "fn_dec_pos": [
            [
              15,
              8
            ],
            [
              15,
              23
            ]
          ],
          "class_code": "ced13827b2e9b731b82f1847da07d27b0ab901665ded1bf4c698d15d4aff46f7",
          "class_node_pos": [
            [
              3,
              0
            ],
            [
              18,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "getYear",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "getMonth() const",
          "fn_dec_pos": [
            [
              16,
              8
            ],
            [
              16,
              24
            ]
          ],
          "class_code": "ced13827b2e9b731b82f1847da07d27b0ab901665ded1bf4c698d15d4aff46f7",
          "class_node_pos": [
            [
              3,
              0
            ],
            [
              18,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "getMonth",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "getDay() const",
          "fn_dec_pos": [
            [
              17,
              8
            ],
            [
              17,
              22
            ]
          ],
          "class_code": "ced13827b2e9b731b82f1847da07d27b0ab901665ded1bf4c698d15d4aff46f7",
          "class_node_pos": [
            [
              3,
              0
            ],
            [
              18,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "getDay",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {
        "ced13827b2e9b731b82f1847da07d27b0ab901665ded1bf4c698d15d4aff46f7": {
          "class_code": "class Date\n{\nprivate:\n    int m_year{};\n    int m_month{};\n    int m_day{};\n\npublic:\n    Date(int year, int month, int day);\n\n    void print() const;\n\n    int getYear() const;\n    int getMonth() const ;\n    int getDay() const ;\n}",
          "class_name": "Date",
          "class_pos": [
            [
              3,
              0
            ],
            [
              18,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/lib/ares__buf.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares__buf_create(void)",
          "fn_dec_pos": [
            [
              53,
              25
            ],
            [
              53,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ares__buf_create_const(const unsigned char *data, size_t data_len)",
          "fn_dec_pos": [
            [
              64,
              13
            ],
            [
              64,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_create_const",
            "parameters": {
              "data": "unsigned char",
              "data_len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__buf_destroy(ares__buf_t *buf)",
          "fn_dec_pos": [
            [
              71,
              13
            ],
            [
              71,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_destroy",
            "parameters": {
              "buf": "ares__buf_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__buf_append(ares__buf_t *buf, const unsigned char *data,\n                                size_t data_len)",
          "fn_dec_pos": [
            [
              81,
              15
            ],
            [
              82,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_append",
            "parameters": {
              "buf": "ares__buf_t",
              "data": "unsigned char",
              "data_len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_append_byte(ares__buf_t *buf, unsigned char byte)",
          "fn_dec_pos": [
            [
              90,
              15
            ],
            [
              90,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_append_byte",
            "parameters": {
              "buf": "ares__buf_t",
              "byte": "unsigned char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_append_str(ares__buf_t *buf, const char *str)",
          "fn_dec_pos": [
            [
              98,
              15
            ],
            [
              98,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_append_str",
            "parameters": {
              "buf": "ares__buf_t",
              "str": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_append_be16(ares__buf_t *buf, unsigned short u16)",
          "fn_dec_pos": [
            [
              106,
              15
            ],
            [
              106,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_append_be16",
            "parameters": {
              "buf": "ares__buf_t",
              "u16": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_append_be32(ares__buf_t *buf, unsigned int u32)",
          "fn_dec_pos": [
            [
              114,
              15
            ],
            [
              114,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_append_be32",
            "parameters": {
              "buf": "ares__buf_t",
              "u32": "unsigned int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_append_num_dec(ares__buf_t *buf, size_t num,\n                                        size_t len)",
          "fn_dec_pos": [
            [
              123,
              15
            ],
            [
              124,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_append_num_dec",
            "parameters": {
              "buf": "ares__buf_t",
              "num": "size_t",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_append_num_hex(ares__buf_t *buf, size_t num,\n                                        size_t len)",
          "fn_dec_pos": [
            [
              133,
              15
            ],
            [
              134,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_append_num_hex",
            "parameters": {
              "buf": "ares__buf_t",
              "num": "size_t",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_set_length(ares__buf_t *buf, size_t len)",
          "fn_dec_pos": [
            [
              149,
              15
            ],
            [
              149,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_set_length",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_append_start(ares__buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              163,
              15
            ],
            [
              163,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_append_start",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__buf_append_finish(ares__buf_t *buf, size_t len)",
          "fn_dec_pos": [
            [
              173,
              15
            ],
            [
              173,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_append_finish",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__buf_hexdump(ares__buf_t *buf, const unsigned char *data,\n                                 size_t len)",
          "fn_dec_pos": [
            [
              182,
              15
            ],
            [
              183,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_hexdump",
            "parameters": {
              "buf": "ares__buf_t",
              "data": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_finish_bin(ares__buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              193,
              15
            ],
            [
              193,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_finish_bin",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__buf_finish_str(ares__buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              209,
              15
            ],
            [
              209,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_finish_str",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__buf_tag(ares__buf_t *buf)",
          "fn_dec_pos": [
            [
              218,
              15
            ],
            [
              218,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_tag",
            "parameters": {
              "buf": "ares__buf_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__buf_tag_rollback(ares__buf_t *buf)",
          "fn_dec_pos": [
            [
              225,
              15
            ],
            [
              225,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_tag_rollback",
            "parameters": {
              "buf": "ares__buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_tag_clear(ares__buf_t *buf)",
          "fn_dec_pos": [
            [
              234,
              15
            ],
            [
              234,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_tag_clear",
            "parameters": {
              "buf": "ares__buf_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_tag_fetch(const ares__buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              245,
              21
            ],
            [
              245,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_tag_fetch",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__buf_tag_length(const ares__buf_t *buf)",
          "fn_dec_pos": [
            [
              252,
              21
            ],
            [
              252,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_tag_length",
            "parameters": {
              "buf": "ares__buf_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares__buf_tag_fetch_bytes(const ares__buf_t *buf,\n                                               unsigned char *bytes, size_t *len)",
          "fn_dec_pos": [
            [
              263,
              21
            ],
            [
              264,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_tag_fetch_bytes",
            "parameters": {
              "buf": "ares__buf_t",
              "bytes": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_tag_fetch_string(const ares__buf_t *buf, char *str,\n                                         size_t len)",
          "fn_dec_pos": [
            [
              278,
              14
            ],
            [
              279,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_tag_fetch_string",
            "parameters": {
              "buf": "ares__buf_t",
              "str": "char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_consume(ares__buf_t *buf, size_t len)",
          "fn_dec_pos": [
            [
              287,
              14
            ],
            [
              287,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_consume",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_fetch_be16(ares__buf_t *buf, unsigned short *u16)",
          "fn_dec_pos": [
            [
              295,
              14
            ],
            [
              295,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_fetch_be16",
            "parameters": {
              "buf": "ares__buf_t",
              "u16": "unsigned short"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_fetch_be32(ares__buf_t *buf, unsigned int *u32)",
          "fn_dec_pos": [
            [
              303,
              14
            ],
            [
              303,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_fetch_be32",
            "parameters": {
              "buf": "ares__buf_t",
              "u32": "unsigned int"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_fetch_bytes(ares__buf_t *buf, unsigned char *bytes,\n                                    size_t len)",
          "fn_dec_pos": [
            [
              313,
              14
            ],
            [
              314,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_fetch_bytes",
            "parameters": {
              "buf": "ares__buf_t",
              "bytes": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_fetch_bytes_dup(ares__buf_t *buf, size_t len,\n                                        ares_bool_t     null_term,\n                                        unsigned char **bytes)",
          "fn_dec_pos": [
            [
              328,
              14
            ],
            [
              330,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_fetch_bytes_dup",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t",
              "null_term": "ares_bool_t",
              "bytes": "unsigned char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_fetch_bytes_into_buf(ares__buf_t *buf,\n                                             ares__buf_t *dest, size_t len)",
          "fn_dec_pos": [
            [
              340,
              14
            ],
            [
              341,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_fetch_bytes_into_buf",
            "parameters": {
              "buf": "ares__buf_t",
              "dest": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_fetch_str_dup(ares__buf_t *buf, size_t len, char **str)",
          "fn_dec_pos": [
            [
              352,
              14
            ],
            [
              352,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_fetch_str_dup",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t",
              "str": "char"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_consume_whitespace(ares__buf_t *buf,\n                                           ares_bool_t  include_linefeed)",
          "fn_dec_pos": [
            [
              362,
              14
            ],
            [
              363,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_consume_whitespace",
            "parameters": {
              "buf": "ares__buf_t",
              "include_linefeed": "ares_bool_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares__buf_consume_nonwhitespace(ares__buf_t *buf)",
          "fn_dec_pos": [
            [
              372,
              14
            ],
            [
              372,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_consume_nonwhitespace",
            "parameters": {
              "buf": "ares__buf_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares__buf_consume_until_charset(ares__buf_t         *buf,\n                                              const unsigned char *charset, size_t len,\n                                              ares_bool_t require_charset)",
          "fn_dec_pos": [
            [
              387,
              14
            ],
            [
              389,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_consume_until_charset",
            "parameters": {
              "buf": "ares__buf_t",
              "charset": "unsigned char",
              "len": "size_t",
              "require_charset": "ares_bool_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares__buf_consume_charset(ares__buf_t *buf, const unsigned char *charset,\n                                 size_t len)",
          "fn_dec_pos": [
            [
              399,
              7
            ],
            [
              400,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_consume_charset",
            "parameters": {
              "buf": "ares__buf_t",
              "charset": "unsigned char",
              "len": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares__buf_consume_line(ares__buf_t *buf, ares_bool_t include_linefeed)",
          "fn_dec_pos": [
            [
              411,
              7
            ],
            [
              411,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_consume_line",
            "parameters": {
              "buf": "ares__buf_t",
              "include_linefeed": "ares_bool_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares__buf_split(ares__buf_t *buf, const unsigned char *delims,\n                              size_t delims_len, ares__buf_split_t flags,\n                              size_t max_sections, ares__llist_t **list)",
          "fn_dec_pos": [
            [
              459,
              14
            ],
            [
              461,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_split",
            "parameters": {
              "buf": "ares__buf_t",
              "delims": "unsigned char",
              "delims_len": "size_t",
              "flags": "ares__buf_split_t",
              "max_sections": "size_t",
              "list": "ares__llist_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_begins_with(const ares__buf_t   *buf,\n                                    const unsigned char *data, size_t data_len)",
          "fn_dec_pos": [
            [
              472,
              14
            ],
            [
              473,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_begins_with",
            "parameters": {
              "buf": "ares__buf_t",
              "data": "unsigned char",
              "data_len": "size_t"
            },
            "return_type": "ares_bool_t"
          }
        },
        {
          "fn_code": "ares__buf_len(const ares__buf_t *buf)",
          "fn_dec_pos": [
            [
              481,
              14
            ],
            [
              481,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_len",
            "parameters": {
              "buf": "ares__buf_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares__buf_peek(const ares__buf_t *buf, size_t *len)",
          "fn_dec_pos": [
            [
              491,
              21
            ],
            [
              491,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_peek",
            "parameters": {
              "buf": "ares__buf_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares__buf_reclaim(ares__buf_t *buf)",
          "fn_dec_pos": [
            [
              514,
              21
            ],
            [
              514,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_reclaim",
            "parameters": {
              "buf": "ares__buf_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares__buf_set_position(ares__buf_t *buf, size_t idx)",
          "fn_dec_pos": [
            [
              530,
              21
            ],
            [
              530,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_set_position",
            "parameters": {
              "buf": "ares__buf_t",
              "idx": "size_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_get_position(const ares__buf_t *buf)",
          "fn_dec_pos": [
            [
              544,
              21
            ],
            [
              544,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_get_position",
            "parameters": {
              "buf": "ares__buf_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "ares__buf_parse_dns_str(ares__buf_t *buf, size_t remaining_len,\n                                      char **name, ares_bool_t allow_multiple)",
          "fn_dec_pos": [
            [
              561,
              14
            ],
            [
              562,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_parse_dns_str",
            "parameters": {
              "buf": "ares__buf_t",
              "remaining_len": "size_t",
              "name": "char",
              "allow_multiple": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_parse_dns_binstr(ares__buf_t *buf, size_t remaining_len,\n                                         unsigned char **bin, size_t *bin_len,\n                                         ares_bool_t allow_multiple)",
          "fn_dec_pos": [
            [
              581,
              14
            ],
            [
              583,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_parse_dns_binstr",
            "parameters": {
              "buf": "ares__buf_t",
              "remaining_len": "size_t",
              "bin": "unsigned char",
              "bin_len": "size_t",
              "allow_multiple": "ares_bool_t"
            },
            "return_type": "ares_status_t"
          }
        },
        {
          "fn_code": "ares__buf_load_file(const char *filename, ares__buf_t *buf)",
          "fn_dec_pos": [
            [
              594,
              14
            ],
            [
              594,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__buf_load_file",
            "parameters": {
              "filename": "char",
              "buf": "ares__buf_t"
            },
            "return_type": "ares_status_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares__buf",
          {},
          "",
          [
            44,
            0
          ],
          [
            44,
            16
          ]
        ],
        [
          "typedef struct ares__buf ares__buf_t;",
          {},
          "ares__buf_t",
          [
            47,
            0
          ],
          [
            47,
            37
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  /*! No flags */\n  ARES_BUF_SPLIT_NONE = 0,\n  /*! The delimiter will be the first character in the buffer, except the\n   *  first buffer since the start doesn't have a delimiter.  This option is\n   *  incompatible with ARES_BUF_SPLIT_LTRIM since the delimiter is always\n   *  the first character.\n   */\n  ARES_BUF_SPLIT_DONT_CONSUME_DELIMS = 1 << 0,\n  /*! Allow blank sections, by default blank sections are not emitted.  If using\n   *  ARES_BUF_SPLIT_DONT_CONSUME_DELIMS, the delimiter is not counted as part\n   *  of the section */\n  ARES_BUF_SPLIT_ALLOW_BLANK = 1 << 1,\n  /*! Remove duplicate entries */\n  ARES_BUF_SPLIT_NO_DUPLICATES = 1 << 2,\n  /*! Perform case-insensitive matching when comparing values */\n  ARES_BUF_SPLIT_CASE_INSENSITIVE = 1 << 3,\n  /*! Trim leading whitespace from buffer */\n  ARES_BUF_SPLIT_LTRIM = 1 << 4,\n  /*! Trim trailing whitespace from buffer */\n  ARES_BUF_SPLIT_RTRIM = 1 << 5,\n  /*! Trim leading and trailing whitespace from buffer */\n  ARES_BUF_SPLIT_TRIM = (ARES_BUF_SPLIT_LTRIM | ARES_BUF_SPLIT_RTRIM)\n} ares__buf_split_t;",
          {
            "ARES_BUF_SPLIT_NONE": "",
            "ARES_BUF_SPLIT_DONT_CONSUME_DELIMS": "",
            "ARES_BUF_SPLIT_ALLOW_BLANK": "",
            "ARES_BUF_SPLIT_NO_DUPLICATES": "",
            "ARES_BUF_SPLIT_CASE_INSENSITIVE": "",
            "ARES_BUF_SPLIT_LTRIM": "",
            "ARES_BUF_SPLIT_RTRIM": "",
            "ARES_BUF_SPLIT_TRIM": ""
          },
          "ares__buf_split_t",
          [
            413,
            0
          ],
          [
            436,
            20
          ]
        ]
      ]
    },
    "../docker_shared/source_code/c-ares/src/lib/thirdparty/apple/dnsinfo.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "DNS_PTR(char *,\t\t\tdomain)",
          "fn_dec_pos": [
            [
              61,
              1
            ],
            [
              61,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_PTR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(int32_t,\t\tn_nameserver)",
          "fn_dec_pos": [
            [
              62,
              1
            ],
            [
              62,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_PTR(struct sockaddr **,\tnameserver)",
          "fn_dec_pos": [
            [
              63,
              1
            ],
            [
              63,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_PTR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(uint16_t,\t\tport)",
          "fn_dec_pos": [
            [
              64,
              1
            ],
            [
              64,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(int32_t,\t\tn_search)",
          "fn_dec_pos": [
            [
              65,
              1
            ],
            [
              65,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_PTR(char **,\t\tsearch)",
          "fn_dec_pos": [
            [
              66,
              1
            ],
            [
              66,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_PTR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(int32_t,\t\tn_sortaddr)",
          "fn_dec_pos": [
            [
              67,
              1
            ],
            [
              67,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_PTR(dns_sortaddr_t **,\tsortaddr)",
          "fn_dec_pos": [
            [
              68,
              1
            ],
            [
              68,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_PTR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_PTR(char *,\t\t\toptions)",
          "fn_dec_pos": [
            [
              69,
              1
            ],
            [
              69,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_PTR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(uint32_t,\t\ttimeout)",
          "fn_dec_pos": [
            [
              70,
              1
            ],
            [
              70,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(uint32_t,\t\tsearch_order)",
          "fn_dec_pos": [
            [
              71,
              1
            ],
            [
              71,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(uint32_t,\t\tif_index)",
          "fn_dec_pos": [
            [
              72,
              1
            ],
            [
              72,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(uint32_t,\t\tflags)",
          "fn_dec_pos": [
            [
              73,
              1
            ],
            [
              73,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(uint32_t,\t\treach_flags)",
          "fn_dec_pos": [
            [
              74,
              1
            ],
            [
              74,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(uint32_t,\t\tservice_identifier)",
          "fn_dec_pos": [
            [
              75,
              1
            ],
            [
              75,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_PTR(char *,\t\t\tcid)",
          "fn_dec_pos": [
            [
              76,
              1
            ],
            [
              76,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_PTR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_PTR(char *,\t\t\tif_name)",
          "fn_dec_pos": [
            [
              77,
              1
            ],
            [
              77,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_PTR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(int32_t,\t\tn_resolver)",
          "fn_dec_pos": [
            [
              95,
              1
            ],
            [
              95,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_PTR(dns_resolver_t **,\tresolver)",
          "fn_dec_pos": [
            [
              96,
              1
            ],
            [
              96,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_PTR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(int32_t,\t\tn_scoped_resolver)",
          "fn_dec_pos": [
            [
              97,
              1
            ],
            [
              97,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_PTR(dns_resolver_t **,\tscoped_resolver)",
          "fn_dec_pos": [
            [
              98,
              1
            ],
            [
              98,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_PTR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(uint64_t,\t\tgeneration)",
          "fn_dec_pos": [
            [
              99,
              1
            ],
            [
              99,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(int32_t,\t\tn_service_specific_resolver)",
          "fn_dec_pos": [
            [
              100,
              1
            ],
            [
              100,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_PTR(dns_resolver_t **,\tservice_specific_resolver)",
          "fn_dec_pos": [
            [
              101,
              1
            ],
            [
              101,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_PTR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNS_VAR(uint32_t,\t\tversion)",
          "fn_dec_pos": [
            [
              102,
              1
            ],
            [
              102,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNS_VAR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "dns_configuration_notify_key    (void)",
          "fn_dec_pos": [
            [
              113,
              0
            ],
            [
              113,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dns_configuration_notify_key",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "dns_configuration_copy\t\t(void)",
          "fn_dec_pos": [
            [
              116,
              0
            ],
            [
              116,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dns_configuration_copy",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "dns_configuration_free\t\t(dns_config_t\t*config)",
          "fn_dec_pos": [
            [
              119,
              0
            ],
            [
              119,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dns_configuration_free",
            "parameters": {
              "config": "dns_config_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_dns_configuration_ack\t\t(dns_config_t\t*config,\n\t\t\t\t const char\t*bundle_id)",
          "fn_dec_pos": [
            [
              122,
              0
            ],
            [
              123,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_dns_configuration_ack",
            "parameters": {
              "config": "dns_config_t",
              "bundle_id": "char"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\tstruct in_addr\taddress;\n\tstruct in_addr\tmask;\n} dns_sortaddr_t;",
          {
            "address": "struct in_addr",
            "mask": "struct in_addr"
          },
          "dns_sortaddr_t",
          [
            52,
            0
          ],
          [
            55,
            17
          ]
        ],
        [
          "typedef struct {\n\tDNS_PTR(char *,\t\t\tdomain);\t/* domain */\n\tDNS_VAR(int32_t,\t\tn_nameserver);\t/* # nameserver */\n\tDNS_PTR(struct sockaddr **,\tnameserver);\n\tDNS_VAR(uint16_t,\t\tport);\t\t/* port (in host byte order) */\n\tDNS_VAR(int32_t,\t\tn_search);\t/* # search */\n\tDNS_PTR(char **,\t\tsearch);\n\tDNS_VAR(int32_t,\t\tn_sortaddr);\t/* # sortaddr */\n\tDNS_PTR(dns_sortaddr_t **,\tsortaddr);\n\tDNS_PTR(char *,\t\t\toptions);\t/* options */\n\tDNS_VAR(uint32_t,\t\ttimeout);\t/* timeout */\n\tDNS_VAR(uint32_t,\t\tsearch_order);\t/* search_order */\n\tDNS_VAR(uint32_t,\t\tif_index);\n\tDNS_VAR(uint32_t,\t\tflags);\n\tDNS_VAR(uint32_t,\t\treach_flags);\t/* SCNetworkReachabilityFlags */\n\tDNS_VAR(uint32_t,\t\tservice_identifier);\n\tDNS_PTR(char *,\t\t\tcid);\t\t/* configuration identifer */\n\tDNS_PTR(char *,\t\t\tif_name);\t/* if_index interface name */\n} dns_resolver_t;",
          {},
          "dns_resolver_t",
          [
            60,
            0
          ],
          [
            78,
            17
          ]
        ],
        [
          "typedef struct {\n\tDNS_VAR(int32_t,\t\tn_resolver);\t\t/* resolver configurations */\n\tDNS_PTR(dns_resolver_t **,\tresolver);\n\tDNS_VAR(int32_t,\t\tn_scoped_resolver);\t/* \"scoped\" resolver configurations */\n\tDNS_PTR(dns_resolver_t **,\tscoped_resolver);\n\tDNS_VAR(uint64_t,\t\tgeneration);\n\tDNS_VAR(int32_t,\t\tn_service_specific_resolver);\n\tDNS_PTR(dns_resolver_t **,\tservice_specific_resolver);\n\tDNS_VAR(uint32_t,\t\tversion);\n} dns_config_t;",
          {},
          "dns_config_t",
          [
            94,
            0
          ],
          [
            103,
            15
          ]
        ],
        [
          "typedef struct {\n\tstruct in_addr\taddress;\n\tstruct in_addr\tmask;\n} dns_sortaddr_t;",
          {
            "address": "struct in_addr",
            "mask": "struct in_addr"
          },
          "dns_sortaddr_t",
          [
            52,
            0
          ],
          [
            55,
            17
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            53,
            1
          ],
          [
            53,
            15
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            54,
            1
          ],
          [
            54,
            15
          ]
        ],
        [
          "typedef struct {\n\tDNS_PTR(char *,\t\t\tdomain);\t/* domain */\n\tDNS_VAR(int32_t,\t\tn_nameserver);\t/* # nameserver */\n\tDNS_PTR(struct sockaddr **,\tnameserver);\n\tDNS_VAR(uint16_t,\t\tport);\t\t/* port (in host byte order) */\n\tDNS_VAR(int32_t,\t\tn_search);\t/* # search */\n\tDNS_PTR(char **,\t\tsearch);\n\tDNS_VAR(int32_t,\t\tn_sortaddr);\t/* # sortaddr */\n\tDNS_PTR(dns_sortaddr_t **,\tsortaddr);\n\tDNS_PTR(char *,\t\t\toptions);\t/* options */\n\tDNS_VAR(uint32_t,\t\ttimeout);\t/* timeout */\n\tDNS_VAR(uint32_t,\t\tsearch_order);\t/* search_order */\n\tDNS_VAR(uint32_t,\t\tif_index);\n\tDNS_VAR(uint32_t,\t\tflags);\n\tDNS_VAR(uint32_t,\t\treach_flags);\t/* SCNetworkReachabilityFlags */\n\tDNS_VAR(uint32_t,\t\tservice_identifier);\n\tDNS_PTR(char *,\t\t\tcid);\t\t/* configuration identifer */\n\tDNS_PTR(char *,\t\t\tif_name);\t/* if_index interface name */\n} dns_resolver_t;",
          {},
          "dns_resolver_t",
          [
            60,
            0
          ],
          [
            78,
            17
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            63,
            9
          ],
          [
            63,
            24
          ]
        ],
        [
          "typedef struct {\n\tDNS_VAR(int32_t,\t\tn_resolver);\t\t/* resolver configurations */\n\tDNS_PTR(dns_resolver_t **,\tresolver);\n\tDNS_VAR(int32_t,\t\tn_scoped_resolver);\t/* \"scoped\" resolver configurations */\n\tDNS_PTR(dns_resolver_t **,\tscoped_resolver);\n\tDNS_VAR(uint64_t,\t\tgeneration);\n\tDNS_VAR(int32_t,\t\tn_service_specific_resolver);\n\tDNS_PTR(dns_resolver_t **,\tservice_specific_resolver);\n\tDNS_VAR(uint32_t,\t\tversion);\n} dns_config_t;",
          {},
          "dns_config_t",
          [
            94,
            0
          ],
          [
            103,
            15
          ]
        ]
      ],
      "include_list": [
        [
          "#include <os/availability.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <sys/cdefs.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <stdint.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/src/tools/ares_getopt.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_getopt_init(ares_getopt_state_t *state, int argc, const char **argv)",
          "fn_dec_pos": [
            [
              45,
              5
            ],
            [
              45,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getopt_init",
            "parameters": {
              "state": "ares_getopt_state_t",
              "argc": "int",
              "argv": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_getopt(ares_getopt_state_t *state, const char *ostr)",
          "fn_dec_pos": [
            [
              46,
              5
            ],
            [
              46,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getopt",
            "parameters": {
              "state": "ares_getopt_state_t",
              "ostr": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  const char  *optarg; /* argument associated with option */\n  int          optind; /* index into parent argv vector */\n  int          opterr; /* if error message should be printed */\n  int          optopt; /* character checked for validity */\n  const char  *place;\n  int          argc;\n  const char **argv;\n} ares_getopt_state_t;",
          {
            "char": "const",
            "optind": "int",
            "opterr": "int",
            "optopt": "int",
            "argc": "int"
          },
          "ares_getopt_state_t",
          [
            35,
            0
          ],
          [
            43,
            22
          ]
        ],
        [
          "typedef struct {\n  const char  *optarg; /* argument associated with option */\n  int          optind; /* index into parent argv vector */\n  int          opterr; /* if error message should be printed */\n  int          optopt; /* character checked for validity */\n  const char  *place;\n  int          argc;\n  const char **argv;\n} ares_getopt_state_t;",
          {
            "char": "const",
            "optind": "int",
            "opterr": "int",
            "optopt": "int",
            "argc": "int"
          },
          "ares_getopt_state_t",
          [
            35,
            0
          ],
          [
            43,
            22
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/include/ares_version.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/include/ares.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*ares_sock_state_cb)(void *data, ares_socket_t socket_fd,\n                                   int readable, int writable)",
          "fn_dec_pos": [
            [
              327,
              13
            ],
            [
              328,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "data": "void",
              "socket_fd": "ares_socket_t",
              "readable": "int",
              "writable": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_callback)(void *arg, int status, int timeouts,\n                              unsigned char *abuf, int alen)",
          "fn_dec_pos": [
            [
              427,
              13
            ],
            [
              428,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "abuf": "unsigned char",
              "alen": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_callback_dnsrec)(void *arg, ares_status_t status,\n                                     size_t                   timeouts,\n                                     const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              430,
              13
            ],
            [
              432,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "arg": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_host_callback)(void *arg, int status, int timeouts,\n                                   struct hostent *hostent)",
          "fn_dec_pos": [
            [
              434,
              13
            ],
            [
              435,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "hostent": "struct hostent"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_nameinfo_callback)(void *arg, int status, int timeouts,\n                                       char *node, char *service)",
          "fn_dec_pos": [
            [
              437,
              13
            ],
            [
              438,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "node": "char",
              "service": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_sock_create_callback)(ares_socket_t socket_fd, int type,\n                                         void *data)",
          "fn_dec_pos": [
            [
              440,
              12
            ],
            [
              441,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "socket_fd": "ares_socket_t",
              "type": "int",
              "data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*ares_sock_config_callback)(ares_socket_t socket_fd, int type,\n                                         void *data)",
          "fn_dec_pos": [
            [
              443,
              12
            ],
            [
              444,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "socket_fd": "ares_socket_t",
              "type": "int",
              "data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*ares_addrinfo_callback)(void *arg, int status, int timeouts,\n                                       struct ares_addrinfo *res)",
          "fn_dec_pos": [
            [
              446,
              13
            ],
            [
              447,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "arg": "void",
              "status": "int",
              "timeouts": "int",
              "res": "struct ares_addrinfo"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ares_server_state_callback)(const char *server_string,\n                                           ares_bool_t success, int flags,\n                                           void *data)",
          "fn_dec_pos": [
            [
              449,
              13
            ],
            [
              451,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "server_string": "char",
              "success": "ares_bool_t",
              "flags": "int",
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_library_init(int flags)",
          "fn_dec_pos": [
            [
              453,
              17
            ],
            [
              453,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_init",
            "parameters": {
              "flags": "int"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_library_init_mem(int flags, void *(*amalloc)(size_t size),\n                                       void (*afree)(void *ptr),\n                                       void *(*arealloc)(void  *ptr,\n                                                         size_t size))",
          "fn_dec_pos": [
            [
              455,
              17
            ],
            [
              458,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_init_mem",
            "parameters": {
              "flags": "int",
              "amalloc": "void",
              "size": "size_t",
              "afree": "void",
              "ptr": "void",
              "arealloc": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "(*amalloc)(size_t size)",
          "fn_dec_pos": [
            [
              455,
              56
            ],
            [
              455,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*afree)(void *ptr)",
          "fn_dec_pos": [
            [
              456,
              44
            ],
            [
              456,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*arealloc)(void  *ptr,\n                                                         size_t size)",
          "fn_dec_pos": [
            [
              457,
              45
            ],
            [
              458,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_library_init_jvm(JavaVM *jvm)",
          "fn_dec_pos": [
            [
              461,
              18
            ],
            [
              461,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_init_jvm",
            "parameters": {
              "jvm": "JavaVM"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_library_init_android(jobject connectivity_manager)",
          "fn_dec_pos": [
            [
              462,
              18
            ],
            [
              462,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_init_android",
            "parameters": {
              "connectivity_manager": "jobject"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_library_android_initialized(void)",
          "fn_dec_pos": [
            [
              463,
              18
            ],
            [
              463,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_android_initialized",
            "parameters": {},
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_library_initialized(void)",
          "fn_dec_pos": [
            [
              466,
              25
            ],
            [
              466,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_initialized",
            "parameters": {},
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_library_cleanup(void)",
          "fn_dec_pos": [
            [
              468,
              25
            ],
            [
              468,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_library_cleanup",
            "parameters": {},
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_version(int *version)",
          "fn_dec_pos": [
            [
              470,
              25
            ],
            [
              470,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_version",
            "parameters": {
              "version": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_init(\n  ares_channel_t **channelptr)",
          "fn_dec_pos": [
            [
              472,
              69
            ],
            [
              473,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init",
            "parameters": {
              "channelptr": "ares_channel_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_init_options(ares_channel_t           **channelptr,\n                                             const struct ares_options *options,\n                                             int                        optmask)",
          "fn_dec_pos": [
            [
              475,
              27
            ],
            [
              477,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_init_options",
            "parameters": {
              "channelptr": "ares_channel_t",
              "options": "struct ares_options",
              "optmask": "int"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_save_options(ares_channel_t      *channel,\n                                             struct ares_options *options, int *optmask)",
          "fn_dec_pos": [
            [
              479,
              27
            ],
            [
              480,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_save_options",
            "parameters": {
              "channel": "ares_channel_t",
              "options": "struct ares_options",
              "optmask": "int"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_destroy_options(struct ares_options *options)",
          "fn_dec_pos": [
            [
              482,
              27
            ],
            [
              482,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_destroy_options",
            "parameters": {
              "options": "struct ares_options"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dup(ares_channel_t **dest, ares_channel_t *src)",
          "fn_dec_pos": [
            [
              484,
              27
            ],
            [
              484,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dup",
            "parameters": {
              "dest": "ares_channel_t",
              "src": "ares_channel_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_reinit(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              486,
              13
            ],
            [
              486,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_reinit",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_destroy(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              488,
              27
            ],
            [
              488,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_destroy",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_cancel(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              490,
              27
            ],
            [
              490,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_cancel",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_set_local_ip4(ares_channel_t *channel,\n                                              unsigned int    local_ip)",
          "fn_dec_pos": [
            [
              496,
              27
            ],
            [
              497,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_local_ip4",
            "parameters": {
              "channel": "ares_channel_t",
              "local_ip": "unsigned int"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_set_local_ip6(ares_channel_t      *channel,\n                                              const unsigned char *local_ip6)",
          "fn_dec_pos": [
            [
              500,
              27
            ],
            [
              501,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_local_ip6",
            "parameters": {
              "channel": "ares_channel_t",
              "local_ip6": "unsigned char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_set_local_dev(ares_channel_t *channel,\n                                              const char     *local_dev_name)",
          "fn_dec_pos": [
            [
              504,
              27
            ],
            [
              505,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_local_dev",
            "parameters": {
              "channel": "ares_channel_t",
              "local_dev_name": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_set_socket_callback(ares_channel_t           *channel,\n                                                    ares_sock_create_callback callback,\n                                                    void                     *user_data)",
          "fn_dec_pos": [
            [
              507,
              27
            ],
            [
              509,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_socket_callback",
            "parameters": {
              "channel": "ares_channel_t",
              "callback": "ares_sock_create_callback",
              "user_data": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_set_socket_configure_callback(\n           ares_channel_t *channel, ares_sock_config_callback callback, void *user_data)",
          "fn_dec_pos": [
            [
              511,
              27
            ],
            [
              512,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_socket_configure_callback",
            "parameters": {
              "channel": "ares_channel_t",
              "callback": "ares_sock_config_callback",
              "user_data": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_set_server_state_callback(\n           ares_channel_t *channel, ares_server_state_callback callback, void *user_data)",
          "fn_dec_pos": [
            [
              514,
              27
            ],
            [
              515,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_server_state_callback",
            "parameters": {
              "channel": "ares_channel_t",
              "callback": "ares_server_state_callback",
              "user_data": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_set_sortlist(ares_channel_t *channel,\n                                    const char     *sortstr)",
          "fn_dec_pos": [
            [
              517,
              18
            ],
            [
              518,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_sortlist",
            "parameters": {
              "channel": "ares_channel_t",
              "sortstr": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_getaddrinfo(ares_channel_t *channel, const char *node,\n                                   const char                       *service,\n                                   const struct ares_addrinfo_hints *hints,\n                                   ares_addrinfo_callback callback, void *arg)",
          "fn_dec_pos": [
            [
              520,
              18
            ],
            [
              523,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getaddrinfo",
            "parameters": {
              "channel": "ares_channel_t",
              "node": "char",
              "service": "char",
              "hints": "struct ares_addrinfo_hints",
              "callback": "ares_addrinfo_callback",
              "arg": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_freeaddrinfo(struct ares_addrinfo *ai)",
          "fn_dec_pos": [
            [
              525,
              18
            ],
            [
              525,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_freeaddrinfo",
            "parameters": {
              "ai": "struct ares_addrinfo"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "(*asocket)(int, int, int, void *)",
          "fn_dec_pos": [
            [
              538,
              16
            ],
            [
              538,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "ares_socket_t"
          }
        },
        {
          "fn_code": "(*aclose)(ares_socket_t, void *)",
          "fn_dec_pos": [
            [
              539,
              6
            ],
            [
              539,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*aconnect)(ares_socket_t, const struct sockaddr *, ares_socklen_t,\n                  void *)",
          "fn_dec_pos": [
            [
              540,
              6
            ],
            [
              541,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*arecvfrom)(ares_socket_t, void *, size_t, int,\n                            struct sockaddr *, ares_socklen_t *, void *)",
          "fn_dec_pos": [
            [
              542,
              15
            ],
            [
              543,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "(*asendv)(ares_socket_t, const struct iovec *, int, void *)",
          "fn_dec_pos": [
            [
              544,
              15
            ],
            [
              544,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "ares_ssize_t"
          }
        },
        {
          "fn_code": "ares_set_socket_functions(ares_channel_t                     *channel,\n                                       const struct ares_socket_functions *funcs,\n                                       void                               *user_data)",
          "fn_dec_pos": [
            [
              548,
              13
            ],
            [
              550,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_socket_functions",
            "parameters": {
              "channel": "ares_channel_t",
              "funcs": "struct ares_socket_functions",
              "user_data": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_send(\n  ares_channel_t *channel, const unsigned char *qbuf, int qlen,\n  ares_callback callback, void *arg)",
          "fn_dec_pos": [
            [
              552,
              57
            ],
            [
              554,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_send",
            "parameters": {
              "channel": "ares_channel_t",
              "qbuf": "unsigned char",
              "qlen": "int",
              "callback": "ares_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_send_dnsrec(ares_channel_t          *channel,\n                                            const ares_dns_record_t *dnsrec,\n                                            ares_callback_dnsrec     callback,\n                                            void *arg, unsigned short *qid)",
          "fn_dec_pos": [
            [
              567,
              13
            ],
            [
              570,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_send_dnsrec",
            "parameters": {
              "channel": "ares_channel_t",
              "dnsrec": "ares_dns_record_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void",
              "qid": "unsigned short"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_query(\n  ares_channel_t *channel, const char *name, int dnsclass, int type,\n  ares_callback callback, void *arg)",
          "fn_dec_pos": [
            [
              572,
              58
            ],
            [
              574,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_query",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "dnsclass": "int",
              "type": "int",
              "callback": "ares_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_query_dnsrec(ares_channel_t      *channel,\n                                             const char          *name,\n                                             ares_dns_class_t     dnsclass,\n                                             ares_dns_rec_type_t  type,\n                                             ares_callback_dnsrec callback,\n                                             void *arg, unsigned short *qid)",
          "fn_dec_pos": [
            [
              588,
              13
            ],
            [
              593,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_query_dnsrec",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "dnsclass": "ares_dns_class_t",
              "type": "ares_dns_rec_type_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void",
              "qid": "unsigned short"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_search(\n  ares_channel_t *channel, const char *name, int dnsclass, int type,\n  ares_callback callback, void *arg)",
          "fn_dec_pos": [
            [
              595,
              59
            ],
            [
              597,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_search",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "dnsclass": "int",
              "type": "int",
              "callback": "ares_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_status_t ares_search_dnsrec(ares_channel_t          *channel,\n                                              const ares_dns_record_t *dnsrec,\n                                              ares_callback_dnsrec     callback,\n                                              void                    *arg)",
          "fn_dec_pos": [
            [
              610,
              13
            ],
            [
              613,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_search_dnsrec",
            "parameters": {
              "channel": "ares_channel_t",
              "dnsrec": "ares_dns_record_t",
              "callback": "ares_callback_dnsrec",
              "arg": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_gethostbyname(\n  ares_channel_t *channel, const char *name, int family,\n  ares_host_callback callback, void *arg)",
          "fn_dec_pos": [
            [
              615,
              57
            ],
            [
              617,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_gethostbyname",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "family": "int",
              "callback": "ares_host_callback",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_gethostbyname_file(ares_channel_t *channel,\n                                          const char *name, int family,\n                                          struct hostent **host)",
          "fn_dec_pos": [
            [
              619,
              18
            ],
            [
              621,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_gethostbyname_file",
            "parameters": {
              "channel": "ares_channel_t",
              "name": "char",
              "family": "int",
              "host": "struct hostent"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_gethostbyaddr(ares_channel_t *channel, const void *addr,\n                                     int addrlen, int family,\n                                     ares_host_callback callback, void *arg)",
          "fn_dec_pos": [
            [
              623,
              18
            ],
            [
              625,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_gethostbyaddr",
            "parameters": {
              "channel": "ares_channel_t",
              "addr": "void",
              "addrlen": "int",
              "family": "int",
              "callback": "ares_host_callback",
              "arg": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_getnameinfo(ares_channel_t        *channel,\n                                   const struct sockaddr *sa,\n                                   ares_socklen_t salen, int flags,\n                                   ares_nameinfo_callback callback, void *arg)",
          "fn_dec_pos": [
            [
              627,
              18
            ],
            [
              630,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getnameinfo",
            "parameters": {
              "channel": "ares_channel_t",
              "sa": "struct sockaddr",
              "salen": "ares_socklen_t",
              "flags": "int",
              "callback": "ares_nameinfo_callback",
              "arg": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_fds(ares_channel_t *channel,\n                                            fd_set *read_fds, fd_set *write_fds)",
          "fn_dec_pos": [
            [
              634,
              30
            ],
            [
              635,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_fds",
            "parameters": {
              "channel": "ares_channel_t",
              "read_fds": "fd_set",
              "write_fds": "fd_set"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_getsock(ares_channel_t *channel,\n                                           ares_socket_t *socks, int numsocks)",
          "fn_dec_pos": [
            [
              639,
              30
            ],
            [
              640,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_getsock",
            "parameters": {
              "channel": "ares_channel_t",
              "socks": "ares_socket_t",
              "numsocks": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_timeout(ares_channel_t *channel,\n                                          struct timeval *maxtv,\n                                          struct timeval *tv)",
          "fn_dec_pos": [
            [
              642,
              29
            ],
            [
              644,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_timeout",
            "parameters": {
              "channel": "ares_channel_t",
              "maxtv": "struct timeval",
              "tv": "struct timeval"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_process(\n  ares_channel_t *channel, fd_set *read_fds, fd_set *write_fds)",
          "fn_dec_pos": [
            [
              646,
              56
            ],
            [
              647,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_process",
            "parameters": {
              "channel": "ares_channel_t",
              "read_fds": "fd_set",
              "write_fds": "fd_set"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ares_process_fd(ares_channel_t *channel,\n                                  ares_socket_t   read_fd,\n                                  ares_socket_t   write_fd)",
          "fn_dec_pos": [
            [
              649,
              18
            ],
            [
              651,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_process_fd",
            "parameters": {
              "channel": "ares_channel_t",
              "read_fd": "ares_socket_t",
              "write_fd": "ares_socket_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_create_query(\n  const char *name, int dnsclass, int type, unsigned short id, int rd,\n  unsigned char **buf, int *buflen, int max_udp_size)",
          "fn_dec_pos": [
            [
              653,
              62
            ],
            [
              655,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_create_query",
            "parameters": {
              "name": "char",
              "dnsclass": "int",
              "type": "int",
              "id": "unsigned short",
              "rd": "int",
              "buf": "unsigned char",
              "buflen": "int",
              "max_udp_size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_mkquery(\n  const char *name, int dnsclass, int type, unsigned short id, int rd,\n  unsigned char **buf, int *buflen)",
          "fn_dec_pos": [
            [
              657,
              62
            ],
            [
              659,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_mkquery",
            "parameters": {
              "name": "char",
              "dnsclass": "int",
              "type": "int",
              "id": "unsigned short",
              "rd": "int",
              "buf": "unsigned char",
              "buflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_expand_name(const unsigned char *encoded,\n                                  const unsigned char *abuf, int alen, char **s,\n                                  long *enclen)",
          "fn_dec_pos": [
            [
              661,
              17
            ],
            [
              663,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_expand_name",
            "parameters": {
              "encoded": "unsigned char",
              "abuf": "unsigned char",
              "alen": "int",
              "s": "char",
              "enclen": "long"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_expand_string(const unsigned char *encoded,\n                                    const unsigned char *abuf, int alen,\n                                    unsigned char **s, long *enclen)",
          "fn_dec_pos": [
            [
              665,
              17
            ],
            [
              667,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_expand_string",
            "parameters": {
              "encoded": "unsigned char",
              "abuf": "unsigned char",
              "alen": "int",
              "s": "unsigned char",
              "enclen": "long"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_parse_a_reply(\n  const unsigned char *abuf, int alen, struct hostent **host,\n  struct ares_addrttl *addrttls, int *naddrttls)",
          "fn_dec_pos": [
            [
              794,
              54
            ],
            [
              796,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_a_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "host": "struct hostent",
              "addrttls": "struct ares_addrttl",
              "naddrttls": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_aaaa_reply(\n  const unsigned char *abuf, int alen, struct hostent **host,\n  struct ares_addr6ttl *addrttls, int *naddrttls)",
          "fn_dec_pos": [
            [
              798,
              54
            ],
            [
              800,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_aaaa_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "host": "struct hostent",
              "addrttls": "struct ares_addr6ttl",
              "naddrttls": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_caa_reply(\n  const unsigned char *abuf, int alen, struct ares_caa_reply **caa_out)",
          "fn_dec_pos": [
            [
              802,
              54
            ],
            [
              803,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_caa_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "caa_out": "struct ares_caa_reply"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_ptr_reply(\n  const unsigned char *abuf, int alen, const void *addr, int addrlen,\n  int family, struct hostent **host)",
          "fn_dec_pos": [
            [
              805,
              54
            ],
            [
              807,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_ptr_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "addr": "void",
              "addrlen": "int",
              "family": "int",
              "host": "struct hostent"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_ns_reply(\n  const unsigned char *abuf, int alen, struct hostent **host)",
          "fn_dec_pos": [
            [
              809,
              54
            ],
            [
              810,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_ns_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "host": "struct hostent"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_srv_reply(\n  const unsigned char *abuf, int alen, struct ares_srv_reply **srv_out)",
          "fn_dec_pos": [
            [
              812,
              54
            ],
            [
              813,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_srv_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "srv_out": "struct ares_srv_reply"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_mx_reply(\n  const unsigned char *abuf, int alen, struct ares_mx_reply **mx_out)",
          "fn_dec_pos": [
            [
              815,
              54
            ],
            [
              816,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_mx_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "mx_out": "struct ares_mx_reply"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_txt_reply(\n  const unsigned char *abuf, int alen, struct ares_txt_reply **txt_out)",
          "fn_dec_pos": [
            [
              818,
              54
            ],
            [
              819,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_txt_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "txt_out": "struct ares_txt_reply"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_txt_reply_ext(\n  const unsigned char *abuf, int alen, struct ares_txt_ext **txt_out)",
          "fn_dec_pos": [
            [
              821,
              54
            ],
            [
              822,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_txt_reply_ext",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "txt_out": "struct ares_txt_ext"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_naptr_reply(\n  const unsigned char *abuf, int alen, struct ares_naptr_reply **naptr_out)",
          "fn_dec_pos": [
            [
              824,
              54
            ],
            [
              825,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_naptr_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "naptr_out": "struct ares_naptr_reply"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_soa_reply(\n  const unsigned char *abuf, int alen, struct ares_soa_reply **soa_out)",
          "fn_dec_pos": [
            [
              827,
              54
            ],
            [
              828,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_soa_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "soa_out": "struct ares_soa_reply"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_parse_uri_reply(\n  const unsigned char *abuf, int alen, struct ares_uri_reply **uri_out)",
          "fn_dec_pos": [
            [
              830,
              54
            ],
            [
              831,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_parse_uri_reply",
            "parameters": {
              "abuf": "unsigned char",
              "alen": "int",
              "uri_out": "struct ares_uri_reply"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_free_string(void *str)",
          "fn_dec_pos": [
            [
              833,
              25
            ],
            [
              833,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_free_string",
            "parameters": {
              "str": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_free_hostent(struct hostent *host)",
          "fn_dec_pos": [
            [
              835,
              25
            ],
            [
              835,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_free_hostent",
            "parameters": {
              "host": "struct hostent"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_free_data(void *dataptr)",
          "fn_dec_pos": [
            [
              837,
              25
            ],
            [
              837,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_free_data",
            "parameters": {
              "dataptr": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_strerror(int code)",
          "fn_dec_pos": [
            [
              839,
              25
            ],
            [
              839,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_strerror",
            "parameters": {
              "code": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_set_servers(\n  ares_channel_t *channel, const struct ares_addr_node *servers)",
          "fn_dec_pos": [
            [
              864,
              60
            ],
            [
              865,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_servers",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "struct ares_addr_node"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_set_servers_ports(\n    ares_channel_t *channel, const struct ares_addr_port_node *servers)",
          "fn_dec_pos": [
            [
              868,
              55
            ],
            [
              869,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_servers_ports",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "struct ares_addr_port_node"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_set_servers_csv(ares_channel_t *channel,\n                                        const char     *servers)",
          "fn_dec_pos": [
            [
              872,
              19
            ],
            [
              873,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_servers_csv",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_set_servers_ports_csv(ares_channel_t *channel,\n                                              const char     *servers)",
          "fn_dec_pos": [
            [
              874,
              19
            ],
            [
              875,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_set_servers_ports_csv",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_get_servers_csv(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              876,
              19
            ],
            [
              876,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_servers_csv",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_get_servers(\n  ares_channel_t *channel, struct ares_addr_node **servers)",
          "fn_dec_pos": [
            [
              878,
              60
            ],
            [
              879,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_servers",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "struct ares_addr_node"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_get_servers_ports(\n    ares_channel_t *channel, struct ares_addr_port_node **servers)",
          "fn_dec_pos": [
            [
              882,
              55
            ],
            [
              883,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_get_servers_ports",
            "parameters": {
              "channel": "ares_channel_t",
              "servers": "struct ares_addr_port_node"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ares_inet_ntop(int af, const void *src, char *dst,\n                                          ares_socklen_t size)",
          "fn_dec_pos": [
            [
              885,
              27
            ],
            [
              886,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_ntop",
            "parameters": {
              "af": "int",
              "src": "void",
              "dst": "char",
              "size": "ares_socklen_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_inet_pton(int af, const char *src, void *dst)",
          "fn_dec_pos": [
            [
              888,
              27
            ],
            [
              888,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_inet_pton",
            "parameters": {
              "af": "int",
              "src": "char",
              "dst": "void"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t   ares_threadsafety(void)",
          "fn_dec_pos": [
            [
              894,
              13
            ],
            [
              894,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t   ares_threadsafety",
            "parameters": {},
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_queue_wait_empty(ares_channel_t *channel,\n                                                 int             timeout_ms)",
          "fn_dec_pos": [
            [
              906,
              13
            ],
            [
              907,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_queue_wait_empty",
            "parameters": {
              "channel": "ares_channel_t",
              "timeout_ms": "int"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_queue_active_queries(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              917,
              27
            ],
            [
              917,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_queue_active_queries",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": "CARES_EXTERN"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_server_failover_options {\n  unsigned short retry_chance;\n  size_t         retry_delay;\n}",
          {
            "retry_chance": "unsigned short",
            "retry_delay": "size_t"
          },
          "ares_server_failover_options",
          [
            339,
            0
          ],
          [
            342,
            1
          ]
        ],
        [
          "struct ares_options {\n  int            flags;\n  int            timeout; /* in seconds or milliseconds, depending on options */\n  int            tries;\n  int            ndots;\n  unsigned short udp_port; /* host byte order */\n  unsigned short tcp_port; /* host byte order */\n  int            socket_send_buffer_size;\n  int            socket_receive_buffer_size;\n  struct in_addr    *servers;\n  int                nservers;\n  char             **domains;\n  int                ndomains;\n  char              *lookups;\n  ares_sock_state_cb sock_state_cb;\n  void              *sock_state_cb_data;\n  struct apattern   *sortlist;\n  int                nsort;\n  int                ednspsz;\n  char              *resolvconf_path;\n  char              *hosts_path;\n  int                udp_max_queries;\n  int                maxtimeout; /* in milliseconds */\n  unsigned int qcache_max_ttl;   /* Maximum TTL for query cache, 0=disabled */\n  ares_evsys_t evsys;\n  struct ares_server_failover_options server_failover_opts;\n}",
          {
            "flags": "int",
            "timeout": "int",
            "tries": "int",
            "ndots": "int",
            "udp_port": "unsigned short",
            "tcp_port": "unsigned short",
            "socket_send_buffer_size": "int",
            "socket_receive_buffer_size": "int",
            "*servers": "struct in_addr",
            "nservers": "int",
            "**domains": "char",
            "ndomains": "int",
            "*lookups": "char",
            "sock_state_cb": "ares_sock_state_cb",
            "*sock_state_cb_data": "void",
            "*sortlist": "struct apattern",
            "nsort": "int",
            "ednspsz": "int",
            "*resolvconf_path": "char",
            "*hosts_path": "char",
            "udp_max_queries": "int",
            "maxtimeout": "int",
            "qcache_max_ttl": "unsigned int",
            "evsys": "ares_evsys_t",
            "server_failover_opts": "struct ares_server_failover_options"
          },
          "ares_options",
          [
            361,
            0
          ],
          [
            387,
            1
          ]
        ],
        [
          "struct ares_in6_addr {\n  union {\n    unsigned char _S6_u8[16];\n  } _S6_un;\n}",
          {
            "_S6_un": "union {\n    unsigned char _S6_u8[16];\n  }",
            "_S6_u8[16]": "unsigned char"
          },
          "ares_in6_addr",
          [
            409,
            0
          ],
          [
            413,
            1
          ]
        ],
        [
          "struct ares_addr {\n  int family;\n\n  union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  } addr;\n}",
          {
            "family": "int",
            "addr": "union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  }",
            "addr4": "struct in_addr",
            "addr6": "struct ares_in6_addr"
          },
          "ares_addr",
          [
            415,
            0
          ],
          [
            422,
            1
          ]
        ],
        [
          "struct ares_socket_functions {\n  ares_socket_t (*asocket)(int, int, int, void *);\n  int (*aclose)(ares_socket_t, void *);\n  int (*aconnect)(ares_socket_t, const struct sockaddr *, ares_socklen_t,\n                  void *);\n  ares_ssize_t (*arecvfrom)(ares_socket_t, void *, size_t, int,\n                            struct sockaddr *, ares_socklen_t *, void *);\n  ares_ssize_t (*asendv)(ares_socket_t, const struct iovec *, int, void *);\n}",
          {
            "(*asocket)(int, int, int, void *)": "ares_socket_t",
            "(*aclose)(ares_socket_t, void *)": "int",
            "(*aconnect)(ares_socket_t, const struct sockaddr *, ares_socklen_t,\n                  void *)": "int",
            "(*arecvfrom)(ares_socket_t, void *, size_t, int,\n                            struct sockaddr *, ares_socklen_t *, void *)": "ares_ssize_t",
            "(*asendv)(ares_socket_t, const struct iovec *, int, void *)": "ares_ssize_t"
          },
          "ares_socket_functions",
          [
            537,
            0
          ],
          [
            545,
            1
          ]
        ],
        [
          "struct ares_addrttl {\n  struct in_addr ipaddr;\n  int            ttl;\n}",
          {
            "ipaddr": "struct in_addr",
            "ttl": "int"
          },
          "ares_addrttl",
          [
            669,
            0
          ],
          [
            672,
            1
          ]
        ],
        [
          "struct ares_addr6ttl {\n  struct ares_in6_addr ip6addr;\n  int                  ttl;\n}",
          {
            "ip6addr": "struct ares_in6_addr",
            "ttl": "int"
          },
          "ares_addr6ttl",
          [
            674,
            0
          ],
          [
            677,
            1
          ]
        ],
        [
          "struct ares_caa_reply {\n  struct ares_caa_reply *next;\n  int                    critical;\n  unsigned char         *property;\n  size_t                 plength; /* plength excludes null termination */\n  unsigned char         *value;\n  size_t                 length;  /* length excludes null termination */\n}",
          {
            "*next": "struct ares_caa_reply",
            "critical": "int",
            "*property": "unsigned char",
            "plength": "size_t",
            "*value": "unsigned char",
            "length": "size_t"
          },
          "ares_caa_reply",
          [
            679,
            0
          ],
          [
            686,
            1
          ]
        ],
        [
          "struct ares_srv_reply {\n  struct ares_srv_reply *next;\n  char                  *host;\n  unsigned short         priority;\n  unsigned short         weight;\n  unsigned short         port;\n}",
          {
            "*next": "struct ares_srv_reply",
            "*host": "char",
            "priority": "unsigned short",
            "weight": "unsigned short",
            "port": "unsigned short"
          },
          "ares_srv_reply",
          [
            688,
            0
          ],
          [
            694,
            1
          ]
        ],
        [
          "struct ares_mx_reply {\n  struct ares_mx_reply *next;\n  char                 *host;\n  unsigned short        priority;\n}",
          {
            "*next": "struct ares_mx_reply",
            "*host": "char",
            "priority": "unsigned short"
          },
          "ares_mx_reply",
          [
            696,
            0
          ],
          [
            700,
            1
          ]
        ],
        [
          "struct ares_txt_reply {\n  struct ares_txt_reply *next;\n  unsigned char         *txt;\n  size_t                 length; /* length excludes null termination */\n}",
          {
            "*next": "struct ares_txt_reply",
            "*txt": "unsigned char",
            "length": "size_t"
          },
          "ares_txt_reply",
          [
            702,
            0
          ],
          [
            706,
            1
          ]
        ],
        [
          "struct ares_txt_ext {\n  struct ares_txt_ext *next;\n  unsigned char       *txt;\n  size_t               length;\n  /* 1 - if start of new record\n   * 0 - if a chunk in the same record */\n  unsigned char        record_start;\n}",
          {
            "*next": "struct ares_txt_ext",
            "*txt": "unsigned char",
            "length": "size_t",
            "record_start": "unsigned char"
          },
          "ares_txt_ext",
          [
            710,
            0
          ],
          [
            717,
            1
          ]
        ],
        [
          "struct ares_naptr_reply {\n  struct ares_naptr_reply *next;\n  unsigned char           *flags;\n  unsigned char           *service;\n  unsigned char           *regexp;\n  char                    *replacement;\n  unsigned short           order;\n  unsigned short           preference;\n}",
          {
            "*next": "struct ares_naptr_reply",
            "*flags": "unsigned char",
            "*service": "unsigned char",
            "*regexp": "unsigned char",
            "*replacement": "char",
            "order": "unsigned short",
            "preference": "unsigned short"
          },
          "ares_naptr_reply",
          [
            719,
            0
          ],
          [
            727,
            1
          ]
        ],
        [
          "struct ares_soa_reply {\n  char        *nsname;\n  char        *hostmaster;\n  unsigned int serial;\n  unsigned int refresh;\n  unsigned int retry;\n  unsigned int expire;\n  unsigned int minttl;\n}",
          {
            "*nsname": "char",
            "*hostmaster": "char",
            "serial": "unsigned int",
            "refresh": "unsigned int",
            "retry": "unsigned int",
            "expire": "unsigned int",
            "minttl": "unsigned int"
          },
          "ares_soa_reply",
          [
            729,
            0
          ],
          [
            737,
            1
          ]
        ],
        [
          "struct ares_uri_reply {\n  struct ares_uri_reply *next;\n  unsigned short         priority;\n  unsigned short         weight;\n  char                  *uri;\n  int                    ttl;\n}",
          {
            "*next": "struct ares_uri_reply",
            "priority": "unsigned short",
            "weight": "unsigned short",
            "*uri": "char",
            "ttl": "int"
          },
          "ares_uri_reply",
          [
            739,
            0
          ],
          [
            745,
            1
          ]
        ],
        [
          "struct ares_addrinfo_node {\n  int                        ai_ttl;\n  int                        ai_flags;\n  int                        ai_family;\n  int                        ai_socktype;\n  int                        ai_protocol;\n  ares_socklen_t             ai_addrlen;\n  struct sockaddr           *ai_addr;\n  struct ares_addrinfo_node *ai_next;\n}",
          {
            "ai_ttl": "int",
            "ai_flags": "int",
            "ai_family": "int",
            "ai_socktype": "int",
            "ai_protocol": "int",
            "ai_addrlen": "ares_socklen_t",
            "*ai_addr": "struct sockaddr",
            "*ai_next": "struct ares_addrinfo_node"
          },
          "ares_addrinfo_node",
          [
            750,
            0
          ],
          [
            759,
            1
          ]
        ],
        [
          "struct ares_addrinfo_cname {\n  int                         ttl;\n  char                       *alias;\n  char                       *name;\n  struct ares_addrinfo_cname *next;\n}",
          {
            "ttl": "int",
            "*alias": "char",
            "*name": "char",
            "*next": "struct ares_addrinfo_cname"
          },
          "ares_addrinfo_cname",
          [
            766,
            0
          ],
          [
            771,
            1
          ]
        ],
        [
          "struct ares_addrinfo {\n  struct ares_addrinfo_cname *cnames;\n  struct ares_addrinfo_node  *nodes;\n  char                       *name;\n}",
          {
            "*cnames": "struct ares_addrinfo_cname",
            "*nodes": "struct ares_addrinfo_node",
            "*name": "char"
          },
          "ares_addrinfo",
          [
            773,
            0
          ],
          [
            777,
            1
          ]
        ],
        [
          "struct ares_addrinfo_hints {\n  int ai_flags;\n  int ai_family;\n  int ai_socktype;\n  int ai_protocol;\n}",
          {
            "ai_flags": "int",
            "ai_family": "int",
            "ai_socktype": "int",
            "ai_protocol": "int"
          },
          "ares_addrinfo_hints",
          [
            779,
            0
          ],
          [
            784,
            1
          ]
        ],
        [
          "struct ares_addr_node {\n  struct ares_addr_node *next;\n  int                    family;\n\n  union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  } addr;\n}",
          {
            "*next": "struct ares_addr_node",
            "family": "int",
            "addr": "union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  }",
            "addr4": "struct in_addr",
            "addr6": "struct ares_in6_addr"
          },
          "ares_addr_node",
          [
            841,
            0
          ],
          [
            849,
            1
          ]
        ],
        [
          "struct ares_addr_port_node {\n  struct ares_addr_port_node *next;\n  int                         family;\n\n  union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  } addr;\n\n  int udp_port;\n  int tcp_port;\n}",
          {
            "*next": "struct ares_addr_port_node",
            "family": "int",
            "addr": "union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  }",
            "addr4": "struct in_addr",
            "addr6": "struct ares_in6_addr",
            "udp_port": "int",
            "tcp_port": "int"
          },
          "ares_addr_port_node",
          [
            851,
            0
          ],
          [
            862,
            1
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            330,
            0
          ],
          [
            330,
            15
          ]
        ],
        [
          "struct ares_server_failover_options {\n  unsigned short retry_chance;\n  size_t         retry_delay;\n}",
          {
            "retry_chance": "unsigned short",
            "retry_delay": "size_t"
          },
          "ares_server_failover_options",
          [
            339,
            0
          ],
          [
            342,
            1
          ]
        ],
        [
          "struct ares_options {\n  int            flags;\n  int            timeout; /* in seconds or milliseconds, depending on options */\n  int            tries;\n  int            ndots;\n  unsigned short udp_port; /* host byte order */\n  unsigned short tcp_port; /* host byte order */\n  int            socket_send_buffer_size;\n  int            socket_receive_buffer_size;\n  struct in_addr    *servers;\n  int                nservers;\n  char             **domains;\n  int                ndomains;\n  char              *lookups;\n  ares_sock_state_cb sock_state_cb;\n  void              *sock_state_cb_data;\n  struct apattern   *sortlist;\n  int                nsort;\n  int                ednspsz;\n  char              *resolvconf_path;\n  char              *hosts_path;\n  int                udp_max_queries;\n  int                maxtimeout; /* in milliseconds */\n  unsigned int qcache_max_ttl;   /* Maximum TTL for query cache, 0=disabled */\n  ares_evsys_t evsys;\n  struct ares_server_failover_options server_failover_opts;\n}",
          {
            "flags": "int",
            "timeout": "int",
            "tries": "int",
            "ndots": "int",
            "udp_port": "unsigned short",
            "tcp_port": "unsigned short",
            "socket_send_buffer_size": "int",
            "socket_receive_buffer_size": "int",
            "*servers": "struct in_addr",
            "nservers": "int",
            "**domains": "char",
            "ndomains": "int",
            "*lookups": "char",
            "sock_state_cb": "ares_sock_state_cb",
            "*sock_state_cb_data": "void",
            "*sortlist": "struct apattern",
            "nsort": "int",
            "ednspsz": "int",
            "*resolvconf_path": "char",
            "*hosts_path": "char",
            "udp_max_queries": "int",
            "maxtimeout": "int",
            "qcache_max_ttl": "unsigned int",
            "evsys": "ares_evsys_t",
            "server_failover_opts": "struct ares_server_failover_options"
          },
          "ares_options",
          [
            361,
            0
          ],
          [
            387,
            1
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            370,
            2
          ],
          [
            370,
            16
          ]
        ],
        [
          "struct apattern",
          {},
          "",
          [
            377,
            2
          ],
          [
            377,
            17
          ]
        ],
        [
          "struct ares_server_failover_options",
          {},
          "",
          [
            386,
            2
          ],
          [
            386,
            37
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            389,
            0
          ],
          [
            389,
            14
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            390,
            0
          ],
          [
            390,
            14
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            391,
            0
          ],
          [
            391,
            15
          ]
        ],
        [
          "struct ares_channeldata",
          {},
          "",
          [
            392,
            0
          ],
          [
            392,
            23
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            393,
            0
          ],
          [
            393,
            20
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            394,
            0
          ],
          [
            394,
            26
          ]
        ],
        [
          "typedef struct ares_channeldata *ares_channel;",
          {},
          "ares_channel",
          [
            397,
            0
          ],
          [
            397,
            46
          ]
        ],
        [
          "typedef struct ares_channeldata  ares_channel_t;",
          {},
          "ares_channel_t",
          [
            400,
            0
          ],
          [
            400,
            48
          ]
        ],
        [
          "struct ares_in6_addr {\n  union {\n    unsigned char _S6_u8[16];\n  } _S6_un;\n}",
          {
            "_S6_un": "union {\n    unsigned char _S6_u8[16];\n  }",
            "_S6_u8[16]": "unsigned char"
          },
          "ares_in6_addr",
          [
            409,
            0
          ],
          [
            413,
            1
          ]
        ],
        [
          "struct ares_addr {\n  int family;\n\n  union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  } addr;\n}",
          {
            "family": "int",
            "addr": "union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  }",
            "addr4": "struct in_addr",
            "addr6": "struct ares_in6_addr"
          },
          "ares_addr",
          [
            415,
            0
          ],
          [
            422,
            1
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            419,
            4
          ],
          [
            419,
            18
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            420,
            4
          ],
          [
            420,
            24
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            435,
            35
          ],
          [
            435,
            49
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            447,
            39
          ],
          [
            447,
            59
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            476,
            51
          ],
          [
            476,
            70
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            480,
            45
          ],
          [
            480,
            64
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            482,
            48
          ],
          [
            482,
            67
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            522,
            41
          ],
          [
            522,
            67
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            525,
            36
          ],
          [
            525,
            56
          ]
        ],
        [
          "struct iovec",
          {},
          "",
          [
            535,
            0
          ],
          [
            535,
            12
          ]
        ],
        [
          "struct ares_socket_functions {\n  ares_socket_t (*asocket)(int, int, int, void *);\n  int (*aclose)(ares_socket_t, void *);\n  int (*aconnect)(ares_socket_t, const struct sockaddr *, ares_socklen_t,\n                  void *);\n  ares_ssize_t (*arecvfrom)(ares_socket_t, void *, size_t, int,\n                            struct sockaddr *, ares_socklen_t *, void *);\n  ares_ssize_t (*asendv)(ares_socket_t, const struct iovec *, int, void *);\n}",
          {
            "(*asocket)(int, int, int, void *)": "ares_socket_t",
            "(*aclose)(ares_socket_t, void *)": "int",
            "(*aconnect)(ares_socket_t, const struct sockaddr *, ares_socklen_t,\n                  void *)": "int",
            "(*arecvfrom)(ares_socket_t, void *, size_t, int,\n                            struct sockaddr *, ares_socklen_t *, void *)": "ares_ssize_t",
            "(*asendv)(ares_socket_t, const struct iovec *, int, void *)": "ares_ssize_t"
          },
          "ares_socket_functions",
          [
            537,
            0
          ],
          [
            545,
            1
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            540,
            39
          ],
          [
            540,
            54
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            543,
            28
          ],
          [
            543,
            43
          ]
        ],
        [
          "struct iovec",
          {},
          "",
          [
            544,
            46
          ],
          [
            544,
            58
          ]
        ],
        [
          "struct ares_socket_functions",
          {},
          "",
          [
            549,
            45
          ],
          [
            549,
            73
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            621,
            42
          ],
          [
            621,
            56
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            628,
            41
          ],
          [
            628,
            56
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            643,
            42
          ],
          [
            643,
            56
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            644,
            42
          ],
          [
            644,
            56
          ]
        ],
        [
          "struct ares_addrttl {\n  struct in_addr ipaddr;\n  int            ttl;\n}",
          {
            "ipaddr": "struct in_addr",
            "ttl": "int"
          },
          "ares_addrttl",
          [
            669,
            0
          ],
          [
            672,
            1
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            670,
            2
          ],
          [
            670,
            16
          ]
        ],
        [
          "struct ares_addr6ttl {\n  struct ares_in6_addr ip6addr;\n  int                  ttl;\n}",
          {
            "ip6addr": "struct ares_in6_addr",
            "ttl": "int"
          },
          "ares_addr6ttl",
          [
            674,
            0
          ],
          [
            677,
            1
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            675,
            2
          ],
          [
            675,
            22
          ]
        ],
        [
          "struct ares_caa_reply {\n  struct ares_caa_reply *next;\n  int                    critical;\n  unsigned char         *property;\n  size_t                 plength; /* plength excludes null termination */\n  unsigned char         *value;\n  size_t                 length;  /* length excludes null termination */\n}",
          {
            "*next": "struct ares_caa_reply",
            "critical": "int",
            "*property": "unsigned char",
            "plength": "size_t",
            "*value": "unsigned char",
            "length": "size_t"
          },
          "ares_caa_reply",
          [
            679,
            0
          ],
          [
            686,
            1
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            680,
            2
          ],
          [
            680,
            23
          ]
        ],
        [
          "struct ares_srv_reply {\n  struct ares_srv_reply *next;\n  char                  *host;\n  unsigned short         priority;\n  unsigned short         weight;\n  unsigned short         port;\n}",
          {
            "*next": "struct ares_srv_reply",
            "*host": "char",
            "priority": "unsigned short",
            "weight": "unsigned short",
            "port": "unsigned short"
          },
          "ares_srv_reply",
          [
            688,
            0
          ],
          [
            694,
            1
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            689,
            2
          ],
          [
            689,
            23
          ]
        ],
        [
          "struct ares_mx_reply {\n  struct ares_mx_reply *next;\n  char                 *host;\n  unsigned short        priority;\n}",
          {
            "*next": "struct ares_mx_reply",
            "*host": "char",
            "priority": "unsigned short"
          },
          "ares_mx_reply",
          [
            696,
            0
          ],
          [
            700,
            1
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            697,
            2
          ],
          [
            697,
            22
          ]
        ],
        [
          "struct ares_txt_reply {\n  struct ares_txt_reply *next;\n  unsigned char         *txt;\n  size_t                 length; /* length excludes null termination */\n}",
          {
            "*next": "struct ares_txt_reply",
            "*txt": "unsigned char",
            "length": "size_t"
          },
          "ares_txt_reply",
          [
            702,
            0
          ],
          [
            706,
            1
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            703,
            2
          ],
          [
            703,
            23
          ]
        ],
        [
          "struct ares_txt_ext {\n  struct ares_txt_ext *next;\n  unsigned char       *txt;\n  size_t               length;\n  /* 1 - if start of new record\n   * 0 - if a chunk in the same record */\n  unsigned char        record_start;\n}",
          {
            "*next": "struct ares_txt_ext",
            "*txt": "unsigned char",
            "length": "size_t",
            "record_start": "unsigned char"
          },
          "ares_txt_ext",
          [
            710,
            0
          ],
          [
            717,
            1
          ]
        ],
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            711,
            2
          ],
          [
            711,
            21
          ]
        ],
        [
          "struct ares_naptr_reply {\n  struct ares_naptr_reply *next;\n  unsigned char           *flags;\n  unsigned char           *service;\n  unsigned char           *regexp;\n  char                    *replacement;\n  unsigned short           order;\n  unsigned short           preference;\n}",
          {
            "*next": "struct ares_naptr_reply",
            "*flags": "unsigned char",
            "*service": "unsigned char",
            "*regexp": "unsigned char",
            "*replacement": "char",
            "order": "unsigned short",
            "preference": "unsigned short"
          },
          "ares_naptr_reply",
          [
            719,
            0
          ],
          [
            727,
            1
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            720,
            2
          ],
          [
            720,
            25
          ]
        ],
        [
          "struct ares_soa_reply {\n  char        *nsname;\n  char        *hostmaster;\n  unsigned int serial;\n  unsigned int refresh;\n  unsigned int retry;\n  unsigned int expire;\n  unsigned int minttl;\n}",
          {
            "*nsname": "char",
            "*hostmaster": "char",
            "serial": "unsigned int",
            "refresh": "unsigned int",
            "retry": "unsigned int",
            "expire": "unsigned int",
            "minttl": "unsigned int"
          },
          "ares_soa_reply",
          [
            729,
            0
          ],
          [
            737,
            1
          ]
        ],
        [
          "struct ares_uri_reply {\n  struct ares_uri_reply *next;\n  unsigned short         priority;\n  unsigned short         weight;\n  char                  *uri;\n  int                    ttl;\n}",
          {
            "*next": "struct ares_uri_reply",
            "priority": "unsigned short",
            "weight": "unsigned short",
            "*uri": "char",
            "ttl": "int"
          },
          "ares_uri_reply",
          [
            739,
            0
          ],
          [
            745,
            1
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            740,
            2
          ],
          [
            740,
            23
          ]
        ],
        [
          "struct ares_addrinfo_node {\n  int                        ai_ttl;\n  int                        ai_flags;\n  int                        ai_family;\n  int                        ai_socktype;\n  int                        ai_protocol;\n  ares_socklen_t             ai_addrlen;\n  struct sockaddr           *ai_addr;\n  struct ares_addrinfo_node *ai_next;\n}",
          {
            "ai_ttl": "int",
            "ai_flags": "int",
            "ai_family": "int",
            "ai_socktype": "int",
            "ai_protocol": "int",
            "ai_addrlen": "ares_socklen_t",
            "*ai_addr": "struct sockaddr",
            "*ai_next": "struct ares_addrinfo_node"
          },
          "ares_addrinfo_node",
          [
            750,
            0
          ],
          [
            759,
            1
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            757,
            2
          ],
          [
            757,
            17
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            758,
            2
          ],
          [
            758,
            27
          ]
        ],
        [
          "struct ares_addrinfo_cname {\n  int                         ttl;\n  char                       *alias;\n  char                       *name;\n  struct ares_addrinfo_cname *next;\n}",
          {
            "ttl": "int",
            "*alias": "char",
            "*name": "char",
            "*next": "struct ares_addrinfo_cname"
          },
          "ares_addrinfo_cname",
          [
            766,
            0
          ],
          [
            771,
            1
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            770,
            2
          ],
          [
            770,
            28
          ]
        ],
        [
          "struct ares_addrinfo {\n  struct ares_addrinfo_cname *cnames;\n  struct ares_addrinfo_node  *nodes;\n  char                       *name;\n}",
          {
            "*cnames": "struct ares_addrinfo_cname",
            "*nodes": "struct ares_addrinfo_node",
            "*name": "char"
          },
          "ares_addrinfo",
          [
            773,
            0
          ],
          [
            777,
            1
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            774,
            2
          ],
          [
            774,
            28
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            775,
            2
          ],
          [
            775,
            27
          ]
        ],
        [
          "struct ares_addrinfo_hints {\n  int ai_flags;\n  int ai_family;\n  int ai_socktype;\n  int ai_protocol;\n}",
          {
            "ai_flags": "int",
            "ai_family": "int",
            "ai_socktype": "int",
            "ai_protocol": "int"
          },
          "ares_addrinfo_hints",
          [
            779,
            0
          ],
          [
            784,
            1
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            795,
            39
          ],
          [
            795,
            53
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            796,
            2
          ],
          [
            796,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            799,
            39
          ],
          [
            799,
            53
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            800,
            2
          ],
          [
            800,
            22
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            803,
            39
          ],
          [
            803,
            60
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            807,
            14
          ],
          [
            807,
            28
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            810,
            39
          ],
          [
            810,
            53
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            813,
            39
          ],
          [
            813,
            60
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            816,
            39
          ],
          [
            816,
            59
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            819,
            39
          ],
          [
            819,
            60
          ]
        ],
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            822,
            39
          ],
          [
            822,
            58
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            825,
            39
          ],
          [
            825,
            62
          ]
        ],
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            828,
            39
          ],
          [
            828,
            60
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            831,
            39
          ],
          [
            831,
            60
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            835,
            43
          ],
          [
            835,
            57
          ]
        ],
        [
          "struct ares_addr_node {\n  struct ares_addr_node *next;\n  int                    family;\n\n  union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  } addr;\n}",
          {
            "*next": "struct ares_addr_node",
            "family": "int",
            "addr": "union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  }",
            "addr4": "struct in_addr",
            "addr6": "struct ares_in6_addr"
          },
          "ares_addr_node",
          [
            841,
            0
          ],
          [
            849,
            1
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            842,
            2
          ],
          [
            842,
            23
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            846,
            4
          ],
          [
            846,
            18
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            847,
            4
          ],
          [
            847,
            24
          ]
        ],
        [
          "struct ares_addr_port_node {\n  struct ares_addr_port_node *next;\n  int                         family;\n\n  union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  } addr;\n\n  int udp_port;\n  int tcp_port;\n}",
          {
            "*next": "struct ares_addr_port_node",
            "family": "int",
            "addr": "union {\n    struct in_addr       addr4;\n    struct ares_in6_addr addr6;\n  }",
            "addr4": "struct in_addr",
            "addr6": "struct ares_in6_addr",
            "udp_port": "int",
            "tcp_port": "int"
          },
          "ares_addr_port_node",
          [
            851,
            0
          ],
          [
            862,
            1
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            852,
            2
          ],
          [
            852,
            28
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            856,
            4
          ],
          [
            856,
            18
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            857,
            4
          ],
          [
            857,
            24
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            865,
            33
          ],
          [
            865,
            54
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            869,
            35
          ],
          [
            869,
            61
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            879,
            27
          ],
          [
            879,
            48
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            883,
            29
          ],
          [
            883,
            55
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_version.h\" /* c-ares version defines   */\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares_build.h\"   /* c-ares build definitions */\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include \"ares_rules.h\"   /* c-ares rules enforcement */\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#  include <sys/select.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#  include <sys/bsdskt.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ],
        [
          "#  include <sys/socket.h>\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#  include <tcp.h>\n",
          [
            61,
            0
          ],
          [
            62,
            0
          ]
        ],
        [
          "#  include <windows.h>\n",
          [
            66,
            0
          ],
          [
            67,
            0
          ]
        ],
        [
          "#  include <winsock.h>\n",
          [
            67,
            0
          ],
          [
            68,
            0
          ]
        ],
        [
          "#  include <windows.h>\n",
          [
            72,
            0
          ],
          [
            73,
            0
          ]
        ],
        [
          "#  include <winsock2.h>\n",
          [
            73,
            0
          ],
          [
            74,
            0
          ]
        ],
        [
          "#  include <ws2tcpip.h>\n",
          [
            74,
            0
          ],
          [
            75,
            0
          ]
        ],
        [
          "#  include <sys/socket.h>\n",
          [
            83,
            0
          ],
          [
            84,
            0
          ]
        ],
        [
          "#  include <netinet/in.h>\n",
          [
            84,
            0
          ],
          [
            85,
            0
          ]
        ],
        [
          "#  include <jni.h>\n",
          [
            88,
            0
          ],
          [
            89,
            0
          ]
        ],
        [
          "#include \"ares_dns_record.h\"\n",
          [
            425,
            0
          ],
          [
            426,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  ARES_SUCCESS = 0,\n\n  /* Server error codes (ARES_ENODATA indicates no relevant answer) */\n  ARES_ENODATA   = 1,\n  ARES_EFORMERR  = 2,\n  ARES_ESERVFAIL = 3,\n  ARES_ENOTFOUND = 4,\n  ARES_ENOTIMP   = 5,\n  ARES_EREFUSED  = 6,\n\n  /* Locally generated error codes */\n  ARES_EBADQUERY    = 7,\n  ARES_EBADNAME     = 8,\n  ARES_EBADFAMILY   = 9,\n  ARES_EBADRESP     = 10,\n  ARES_ECONNREFUSED = 11,\n  ARES_ETIMEOUT     = 12,\n  ARES_EOF          = 13,\n  ARES_EFILE        = 14,\n  ARES_ENOMEM       = 15,\n  ARES_EDESTRUCTION = 16,\n  ARES_EBADSTR      = 17,\n\n  /* ares_getnameinfo error codes */\n  ARES_EBADFLAGS = 18,\n\n  /* ares_getaddrinfo error codes */\n  ARES_ENONAME   = 19,\n  ARES_EBADHINTS = 20,\n\n  /* Uninitialized library error code */\n  ARES_ENOTINITIALIZED = 21, /* introduced in 1.7.0 */\n\n  /* ares_library_init error codes */\n  ARES_ELOADIPHLPAPI         = 22, /* introduced in 1.7.0 */\n  ARES_EADDRGETNETWORKPARAMS = 23, /* introduced in 1.7.0 */\n\n  /* More error codes */\n  ARES_ECANCELLED = 24, /* introduced in 1.7.0 */\n\n  /* More ares_getaddrinfo error codes */\n  ARES_ESERVICE = 25, /* ares_getaddrinfo() was passed a text service name that\n                       * is not recognized. introduced in 1.16.0 */\n\n  ARES_ENOSERVER = 26 /* No DNS servers were configured */\n} ares_status_t;",
          {
            "ARES_SUCCESS": "",
            "ARES_ENODATA": "",
            "ARES_EFORMERR": "",
            "ARES_ESERVFAIL": "",
            "ARES_ENOTFOUND": "",
            "ARES_ENOTIMP": "",
            "ARES_EREFUSED": "",
            "ARES_EBADQUERY": "",
            "ARES_EBADNAME": "",
            "ARES_EBADFAMILY": "",
            "ARES_EBADRESP": "",
            "ARES_ECONNREFUSED": "",
            "ARES_ETIMEOUT": "",
            "ARES_EOF": "",
            "ARES_EFILE": "",
            "ARES_ENOMEM": "",
            "ARES_EDESTRUCTION": "",
            "ARES_EBADSTR": "",
            "ARES_EBADFLAGS": "",
            "ARES_ENONAME": "",
            "ARES_EBADHINTS": "",
            "ARES_ENOTINITIALIZED": "",
            "ARES_ELOADIPHLPAPI": "",
            "ARES_EADDRGETNETWORKPARAMS": "",
            "ARES_ECANCELLED": "",
            "ARES_ESERVICE": "",
            "ARES_ENOSERVER": ""
          },
          "ares_status_t",
          [
            152,
            0
          ],
          [
            198,
            16
          ]
        ],
        [
          "typedef enum {\n  ARES_FALSE = 0,\n  ARES_TRUE  = 1\n} ares_bool_t;",
          {
            "ARES_FALSE": "",
            "ARES_TRUE": ""
          },
          "ares_bool_t",
          [
            200,
            0
          ],
          [
            203,
            14
          ]
        ],
        [
          "typedef enum {\n  /*! Default (best choice) event system */\n  ARES_EVSYS_DEFAULT = 0,\n  /*! Win32 IOCP/AFD_POLL event system */\n  ARES_EVSYS_WIN32 = 1,\n  /*! Linux epoll */\n  ARES_EVSYS_EPOLL = 2,\n  /*! BSD/MacOS kqueue */\n  ARES_EVSYS_KQUEUE = 3,\n  /*! POSIX poll() */\n  ARES_EVSYS_POLL = 4,\n  /*! last fallback on Unix-like systems, select() */\n  ARES_EVSYS_SELECT = 5\n} ares_evsys_t;",
          {
            "ARES_EVSYS_DEFAULT": "",
            "ARES_EVSYS_WIN32": "",
            "ARES_EVSYS_EPOLL": "",
            "ARES_EVSYS_KQUEUE": "",
            "ARES_EVSYS_POLL": "",
            "ARES_EVSYS_SELECT": ""
          },
          "ares_evsys_t",
          [
            206,
            0
          ],
          [
            219,
            15
          ]
        ]
      ]
    },
    "../docker_shared/source_code/c-ares/include/ares_rules.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/include/ares_nameser.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_build.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <arpa/nameser.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <arpa/nameser_compat.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum __ns_class {\n  ns_c_invalid = 0, /* Cookie. */\n  ns_c_in      = 1, /* Internet. */\n  ns_c_2       = 2, /* unallocated/unsupported. */\n  ns_c_chaos   = 3, /* MIT Chaos-net. */\n  ns_c_hs      = 4, /* MIT Hesiod. */\n  /* Query class values which do not appear in resource records */\n  ns_c_none = 254, /* for prereq. sections in update requests */\n  ns_c_any  = 255, /* Wildcard match. */\n  ns_c_max  = 65536\n} ns_class;",
          {
            "ns_c_invalid": "",
            "ns_c_in": "",
            "ns_c_2": "",
            "ns_c_chaos": "",
            "ns_c_hs": "",
            "ns_c_none": "",
            "ns_c_any": "",
            "ns_c_max": ""
          },
          "ns_class",
          [
            100,
            0
          ],
          [
            110,
            11
          ]
        ],
        [
          "typedef enum __ns_type {\n  ns_t_invalid  = 0,   /* Cookie. */\n  ns_t_a        = 1,   /* Host address. */\n  ns_t_ns       = 2,   /* Authoritative server. */\n  ns_t_md       = 3,   /* Mail destination. */\n  ns_t_mf       = 4,   /* Mail forwarder. */\n  ns_t_cname    = 5,   /* Canonical name. */\n  ns_t_soa      = 6,   /* Start of authority zone. */\n  ns_t_mb       = 7,   /* Mailbox domain name. */\n  ns_t_mg       = 8,   /* Mail group member. */\n  ns_t_mr       = 9,   /* Mail rename name. */\n  ns_t_null     = 10,  /* Null resource record. */\n  ns_t_wks      = 11,  /* Well known service. */\n  ns_t_ptr      = 12,  /* Domain name pointer. */\n  ns_t_hinfo    = 13,  /* Host information. */\n  ns_t_minfo    = 14,  /* Mailbox information. */\n  ns_t_mx       = 15,  /* Mail routing information. */\n  ns_t_txt      = 16,  /* Text strings. */\n  ns_t_rp       = 17,  /* Responsible person. */\n  ns_t_afsdb    = 18,  /* AFS cell database. */\n  ns_t_x25      = 19,  /* X_25 calling address. */\n  ns_t_isdn     = 20,  /* ISDN calling address. */\n  ns_t_rt       = 21,  /* Router. */\n  ns_t_nsap     = 22,  /* NSAP address. */\n  ns_t_nsap_ptr = 23,  /* Reverse NSAP lookup (deprecated). */\n  ns_t_sig      = 24,  /* Security signature. */\n  ns_t_key      = 25,  /* Security key. */\n  ns_t_px       = 26,  /* X.400 mail mapping. */\n  ns_t_gpos     = 27,  /* Geographical position (withdrawn). */\n  ns_t_aaaa     = 28,  /* Ip6 Address. */\n  ns_t_loc      = 29,  /* Location Information. */\n  ns_t_nxt      = 30,  /* Next domain (security). */\n  ns_t_eid      = 31,  /* Endpoint identifier. */\n  ns_t_nimloc   = 32,  /* Nimrod Locator. */\n  ns_t_srv      = 33,  /* Server Selection. */\n  ns_t_atma     = 34,  /* ATM Address */\n  ns_t_naptr    = 35,  /* Naming Authority PoinTeR */\n  ns_t_kx       = 36,  /* Key Exchange */\n  ns_t_cert     = 37,  /* Certification record */\n  ns_t_a6       = 38,  /* IPv6 address (deprecates AAAA) */\n  ns_t_dname    = 39,  /* Non-terminal DNAME (for IPv6) */\n  ns_t_sink     = 40,  /* Kitchen sink (experimental) */\n  ns_t_opt      = 41,  /* EDNS0 option (meta-RR) */\n  ns_t_apl      = 42,  /* Address prefix list (RFC3123) */\n  ns_t_ds       = 43,  /* Delegation Signer (RFC4034) */\n  ns_t_sshfp    = 44,  /* SSH Key Fingerprint (RFC4255) */\n  ns_t_rrsig    = 46,  /* Resource Record Signature (RFC4034) */\n  ns_t_nsec     = 47,  /* Next Secure (RFC4034) */\n  ns_t_dnskey   = 48,  /* DNS Public Key (RFC4034) */\n  ns_t_tkey     = 249, /* Transaction key */\n  ns_t_tsig     = 250, /* Transaction signature. */\n  ns_t_ixfr     = 251, /* Incremental zone transfer. */\n  ns_t_axfr     = 252, /* Transfer zone of authority. */\n  ns_t_mailb    = 253, /* Transfer mailbox records. */\n  ns_t_maila    = 254, /* Transfer mail agent records. */\n  ns_t_any      = 255, /* Wildcard match. */\n  ns_t_uri      = 256, /* Uniform Resource Identifier (RFC7553) */\n  ns_t_caa      = 257, /* Certification Authority Authorization. */\n  ns_t_max      = 65536\n} ns_type;",
          {
            "ns_t_invalid": "",
            "ns_t_a": "",
            "ns_t_ns": "",
            "ns_t_md": "",
            "ns_t_mf": "",
            "ns_t_cname": "",
            "ns_t_soa": "",
            "ns_t_mb": "",
            "ns_t_mg": "",
            "ns_t_mr": "",
            "ns_t_null": "",
            "ns_t_wks": "",
            "ns_t_ptr": "",
            "ns_t_hinfo": "",
            "ns_t_minfo": "",
            "ns_t_mx": "",
            "ns_t_txt": "",
            "ns_t_rp": "",
            "ns_t_afsdb": "",
            "ns_t_x25": "",
            "ns_t_isdn": "",
            "ns_t_rt": "",
            "ns_t_nsap": "",
            "ns_t_nsap_ptr": "",
            "ns_t_sig": "",
            "ns_t_key": "",
            "ns_t_px": "",
            "ns_t_gpos": "",
            "ns_t_aaaa": "",
            "ns_t_loc": "",
            "ns_t_nxt": "",
            "ns_t_eid": "",
            "ns_t_nimloc": "",
            "ns_t_srv": "",
            "ns_t_atma": "",
            "ns_t_naptr": "",
            "ns_t_kx": "",
            "ns_t_cert": "",
            "ns_t_a6": "",
            "ns_t_dname": "",
            "ns_t_sink": "",
            "ns_t_opt": "",
            "ns_t_apl": "",
            "ns_t_ds": "",
            "ns_t_sshfp": "",
            "ns_t_rrsig": "",
            "ns_t_nsec": "",
            "ns_t_dnskey": "",
            "ns_t_tkey": "",
            "ns_t_tsig": "",
            "ns_t_ixfr": "",
            "ns_t_axfr": "",
            "ns_t_mailb": "",
            "ns_t_maila": "",
            "ns_t_any": "",
            "ns_t_uri": "",
            "ns_t_caa": "",
            "ns_t_max": ""
          },
          "ns_type",
          [
            112,
            0
          ],
          [
            171,
            10
          ]
        ],
        [
          "typedef enum __ns_opcode {\n  ns_o_query  = 0, /* Standard query. */\n  ns_o_iquery = 1, /* Inverse query (deprecated/unsupported). */\n  ns_o_status = 2, /* Name server status query (unsupported). */\n                   /* Opcode 3 is undefined/reserved. */\n  ns_o_notify = 4, /* Zone change notification. */\n  ns_o_update = 5, /* Zone update message. */\n  ns_o_max    = 6\n} ns_opcode;",
          {
            "ns_o_query": "",
            "ns_o_iquery": "",
            "ns_o_status": "",
            "ns_o_notify": "",
            "ns_o_update": "",
            "ns_o_max": ""
          },
          "ns_opcode",
          [
            173,
            0
          ],
          [
            181,
            12
          ]
        ],
        [
          "typedef enum __ns_rcode {\n  ns_r_noerror  = 0, /* No error occurred. */\n  ns_r_formerr  = 1, /* Format error. */\n  ns_r_servfail = 2, /* Server failure. */\n  ns_r_nxdomain = 3, /* Name error. */\n  ns_r_notimpl  = 4, /* Unimplemented. */\n  ns_r_refused  = 5, /* Operation refused. */\n  /* these are for BIND_UPDATE */\n  ns_r_yxdomain = 6,  /* Name exists */\n  ns_r_yxrrset  = 7,  /* RRset exists */\n  ns_r_nxrrset  = 8,  /* RRset does not exist */\n  ns_r_notauth  = 9,  /* Not authoritative for zone */\n  ns_r_notzone  = 10, /* Zone of record different from zone section */\n  ns_r_max      = 11,\n  /* The following are TSIG extended errors */\n  ns_r_badsig  = 16,\n  ns_r_badkey  = 17,\n  ns_r_badtime = 18\n} ns_rcode;",
          {
            "ns_r_noerror": "",
            "ns_r_formerr": "",
            "ns_r_servfail": "",
            "ns_r_nxdomain": "",
            "ns_r_notimpl": "",
            "ns_r_refused": "",
            "ns_r_yxdomain": "",
            "ns_r_yxrrset": "",
            "ns_r_nxrrset": "",
            "ns_r_notauth": "",
            "ns_r_notzone": "",
            "ns_r_max": "",
            "ns_r_badsig": "",
            "ns_r_badkey": "",
            "ns_r_badtime": ""
          },
          "ns_rcode",
          [
            183,
            0
          ],
          [
            201,
            11
          ]
        ]
      ]
    },
    "../docker_shared/source_code/c-ares/include/ares_dns.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/include/ares_dns_record.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares_dns_rec_type_tostr(ares_dns_rec_type_t type)",
          "fn_dec_pos": [
            [
              407,
              25
            ],
            [
              407,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_type_tostr",
            "parameters": {
              "type": "ares_dns_rec_type_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_class_tostr(ares_dns_class_t qclass)",
          "fn_dec_pos": [
            [
              414,
              25
            ],
            [
              414,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_class_tostr",
            "parameters": {
              "qclass": "ares_dns_class_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_opcode_tostr(ares_dns_opcode_t opcode)",
          "fn_dec_pos": [
            [
              421,
              25
            ],
            [
              421,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opcode_tostr",
            "parameters": {
              "opcode": "ares_dns_opcode_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_key_tostr(ares_dns_rr_key_t key)",
          "fn_dec_pos": [
            [
              428,
              25
            ],
            [
              428,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_key_tostr",
            "parameters": {
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_section_tostr(ares_dns_section_t section)",
          "fn_dec_pos": [
            [
              435,
              25
            ],
            [
              435,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_section_tostr",
            "parameters": {
              "section": "ares_dns_section_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_class_fromstr(ares_dns_class_t *qclass,\n                                                const char       *str)",
          "fn_dec_pos": [
            [
              443,
              13
            ],
            [
              444,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_dns_class_fromstr",
            "parameters": {
              "qclass": "ares_dns_class_t",
              "str": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_bool_t ares_dns_rec_type_fromstr(ares_dns_rec_type_t *qtype,\n                                                   const char          *str)",
          "fn_dec_pos": [
            [
              452,
              13
            ],
            [
              453,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t ares_dns_rec_type_fromstr",
            "parameters": {
              "qtype": "ares_dns_rec_type_t",
              "str": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_rcode_tostr(ares_dns_rcode_t rcode)",
          "fn_dec_pos": [
            [
              461,
              25
            ],
            [
              461,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rcode_tostr",
            "parameters": {
              "rcode": "ares_dns_rcode_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_pton(const char       *ipaddr,\n                                       struct ares_addr *addr, size_t *out_len)",
          "fn_dec_pos": [
            [
              473,
              25
            ],
            [
              474,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_pton",
            "parameters": {
              "ipaddr": "char",
              "addr": "struct ares_addr",
              "out_len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_addr_to_ptr(const struct ares_addr *addr)",
          "fn_dec_pos": [
            [
              481,
              25
            ],
            [
              481,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_addr_to_ptr",
            "parameters": {
              "addr": "struct ares_addr"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_opt_datatype_t\n  ares_dns_opt_get_datatype(ares_dns_rr_key_t key, unsigned short opt)",
          "fn_dec_pos": [
            [
              492,
              13
            ],
            [
              493,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_datatype_t\n  ares_dns_opt_get_datatype",
            "parameters": {
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_opt_get_name(ares_dns_rr_key_t key,\n                                               unsigned short    opt)",
          "fn_dec_pos": [
            [
              502,
              25
            ],
            [
              503,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opt_get_name",
            "parameters": {
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_keys(ares_dns_rec_type_t type, size_t *cnt)",
          "fn_dec_pos": [
            [
              514,
              2
            ],
            [
              514,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "type": "ares_dns_rec_type_t",
              "cnt": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_datatype_t\n  ares_dns_rr_key_datatype(ares_dns_rr_key_t key)",
          "fn_dec_pos": [
            [
              521,
              13
            ],
            [
              522,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_datatype_t\n  ares_dns_rr_key_datatype",
            "parameters": {
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_rec_type_t\n  ares_dns_rr_key_to_rec_type(ares_dns_rr_key_t key)",
          "fn_dec_pos": [
            [
              529,
              13
            ],
            [
              530,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_type_t\n  ares_dns_rr_key_to_rec_type",
            "parameters": {
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_create(ares_dns_record_t **dnsrec,\n                                                  unsigned short      id,\n                                                  unsigned short      flags,\n                                                  ares_dns_opcode_t   opcode,\n                                                  ares_dns_rcode_t    rcode)",
          "fn_dec_pos": [
            [
              563,
              13
            ],
            [
              567,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_record_create",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "id": "unsigned short",
              "flags": "unsigned short",
              "opcode": "ares_dns_opcode_t",
              "rcode": "ares_dns_rcode_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_record_destroy(ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              573,
              27
            ],
            [
              573,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_destroy",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_record_get_id(const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              581,
              2
            ],
            [
              581,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_get_id",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_record_get_flags(const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              589,
              2
            ],
            [
              589,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_get_flags",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_opcode_t\n  ares_dns_record_get_opcode(const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              596,
              13
            ],
            [
              597,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_opcode_t\n  ares_dns_record_get_opcode",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_rcode_t\n  ares_dns_record_get_rcode(const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              604,
              13
            ],
            [
              605,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rcode_t\n  ares_dns_record_get_rcode",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_query_add(ares_dns_record_t  *dnsrec,\n                                                     const char         *name,\n                                                     ares_dns_rec_type_t qtype,\n                                                     ares_dns_class_t qclass)",
          "fn_dec_pos": [
            [
              616,
              13
            ],
            [
              619,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_record_query_add",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "name": "char",
              "qtype": "ares_dns_rec_type_t",
              "qclass": "ares_dns_class_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_query_set_name(\n  ares_dns_record_t *dnsrec, size_t idx, const char *name)",
          "fn_dec_pos": [
            [
              632,
              13
            ],
            [
              633,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_record_query_set_name",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "idx": "size_t",
              "name": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_query_set_type(\n  ares_dns_record_t *dnsrec, size_t idx, ares_dns_rec_type_t qtype)",
          "fn_dec_pos": [
            [
              644,
              13
            ],
            [
              645,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_record_query_set_type",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "idx": "size_t",
              "qtype": "ares_dns_rec_type_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_record_query_cnt(const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              652,
              20
            ],
            [
              652,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_query_cnt",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_query_get(\n  const ares_dns_record_t *dnsrec, size_t idx, const char **name,\n  ares_dns_rec_type_t *qtype, ares_dns_class_t *qclass)",
          "fn_dec_pos": [
            [
              665,
              13
            ],
            [
              667,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_record_query_get",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "idx": "size_t",
              "name": "char",
              "qtype": "ares_dns_rec_type_t",
              "qclass": "ares_dns_class_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_record_rr_cnt(const ares_dns_record_t *dnsrec,\n                                           ares_dns_section_t       sect)",
          "fn_dec_pos": [
            [
              675,
              20
            ],
            [
              676,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_record_rr_cnt",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_rr_add(\n  ares_dns_rr_t **rr_out, ares_dns_record_t *dnsrec, ares_dns_section_t sect,\n  const char *name, ares_dns_rec_type_t type, ares_dns_class_t rclass,\n  unsigned int ttl)",
          "fn_dec_pos": [
            [
              692,
              13
            ],
            [
              695,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_record_rr_add",
            "parameters": {
              "rr_out": "ares_dns_rr_t",
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "name": "char",
              "type": "ares_dns_rec_type_t",
              "rclass": "ares_dns_class_t",
              "ttl": "unsigned int"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_record_rr_get(ares_dns_record_t *dnsrec,\n                                                   ares_dns_section_t sect,\n                                                   size_t             idx)",
          "fn_dec_pos": [
            [
              704,
              28
            ],
            [
              706,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_record_rr_get_const(const ares_dns_record_t *dnsrec,\n                               ares_dns_section_t sect, size_t idx)",
          "fn_dec_pos": [
            [
              716,
              2
            ],
            [
              717,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_record_rr_del(ares_dns_record_t *dnsrec,\n                                                  ares_dns_section_t sect,\n                                                  size_t             idx)",
          "fn_dec_pos": [
            [
              727,
              13
            ],
            [
              729,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_record_rr_del",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "sect": "ares_dns_section_t",
              "idx": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_rr_get_name(const ares_dns_rr_t *rr)",
          "fn_dec_pos": [
            [
              737,
              27
            ],
            [
              737,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_name",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rec_type_t ares_dns_rr_get_type(const ares_dns_rr_t *rr)",
          "fn_dec_pos": [
            [
              744,
              13
            ],
            [
              744,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rec_type_t ares_dns_rr_get_type",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_class_t    ares_dns_rr_get_class(const ares_dns_rr_t *rr)",
          "fn_dec_pos": [
            [
              751,
              13
            ],
            [
              751,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_class_t    ares_dns_rr_get_class",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_rr_get_ttl(const ares_dns_rr_t *rr)",
          "fn_dec_pos": [
            [
              758,
              33
            ],
            [
              758,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_ttl",
            "parameters": {
              "rr": "ares_dns_rr_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_status_t       ares_dns_rr_set_addr(ares_dns_rr_t        *dns_rr,\n                                                      ares_dns_rr_key_t     key,\n                                                      const struct in_addr *addr)",
          "fn_dec_pos": [
            [
              768,
              13
            ],
            [
              770,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t       ares_dns_rr_set_addr",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "addr": "struct in_addr"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t\n  ares_dns_rr_set_addr6(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                        const struct ares_in6_addr *addr)",
          "fn_dec_pos": [
            [
              780,
              13
            ],
            [
              782,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t\n  ares_dns_rr_set_addr6",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "addr": "struct ares_in6_addr"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_str(ares_dns_rr_t    *dns_rr,\n                                               ares_dns_rr_key_t key,\n                                               const char       *val)",
          "fn_dec_pos": [
            [
              792,
              13
            ],
            [
              794,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_rr_set_str",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_u8(ares_dns_rr_t    *dns_rr,\n                                              ares_dns_rr_key_t key,\n                                              unsigned char     val)",
          "fn_dec_pos": [
            [
              804,
              13
            ],
            [
              806,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_rr_set_u8",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned char"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_u16(ares_dns_rr_t    *dns_rr,\n                                               ares_dns_rr_key_t key,\n                                               unsigned short    val)",
          "fn_dec_pos": [
            [
              816,
              13
            ],
            [
              818,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_rr_set_u16",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned short"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_u32(ares_dns_rr_t    *dns_rr,\n                                               ares_dns_rr_key_t key,\n                                               unsigned int      val)",
          "fn_dec_pos": [
            [
              828,
              13
            ],
            [
              830,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_rr_set_u32",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned int"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_bin(ares_dns_rr_t       *dns_rr,\n                                               ares_dns_rr_key_t    key,\n                                               const unsigned char *val,\n                                               size_t               len)",
          "fn_dec_pos": [
            [
              841,
              13
            ],
            [
              844,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_rr_set_bin",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "val": "unsigned char",
              "len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_rr_set_opt(ares_dns_rr_t       *dns_rr,\n                                               ares_dns_rr_key_t    key,\n                                               unsigned short       opt,\n                                               const unsigned char *val,\n                                               size_t               val_len)",
          "fn_dec_pos": [
            [
              855,
              13
            ],
            [
              859,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_rr_set_opt",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short",
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_rr_get_addr(const ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key)",
          "fn_dec_pos": [
            [
              869,
              2
            ],
            [
              869,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_addr",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_addr6(const ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key)",
          "fn_dec_pos": [
            [
              879,
              2
            ],
            [
              879,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_addr6",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_str(const ares_dns_rr_t *dns_rr,\n                                                ares_dns_rr_key_t    key)",
          "fn_dec_pos": [
            [
              888,
              28
            ],
            [
              889,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_str",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_u8(const ares_dns_rr_t *dns_rr,\n                                               ares_dns_rr_key_t    key)",
          "fn_dec_pos": [
            [
              898,
              28
            ],
            [
              899,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_u8",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_u16(const ares_dns_rr_t *dns_rr,\n                                                ares_dns_rr_key_t    key)",
          "fn_dec_pos": [
            [
              908,
              28
            ],
            [
              909,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_u16",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_u32(const ares_dns_rr_t *dns_rr,\n                                                ares_dns_rr_key_t    key)",
          "fn_dec_pos": [
            [
              918,
              28
            ],
            [
              919,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_u32",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_bin(const ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                      size_t *len)",
          "fn_dec_pos": [
            [
              931,
              2
            ],
            [
              932,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_bin",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_dns_rr_get_opt_cnt(const ares_dns_rr_t *dns_rr,\n                                            ares_dns_rr_key_t    key)",
          "fn_dec_pos": [
            [
              940,
              20
            ],
            [
              941,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_opt_cnt",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_rr_get_opt(const ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,\n                      size_t idx, const unsigned char **val, size_t *val_len)",
          "fn_dec_pos": [
            [
              957,
              2
            ],
            [
              958,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_dns_rr_get_opt",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "idx": "size_t",
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ares_bool_t   ares_dns_rr_get_opt_byid(const ares_dns_rr_t  *dns_rr,\n                                                    ares_dns_rr_key_t     key,\n                                                    unsigned short        opt,\n                                                    const unsigned char **val,\n                                                    size_t *val_len)",
          "fn_dec_pos": [
            [
              973,
              13
            ],
            [
              977,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_bool_t   ares_dns_rr_get_opt_byid",
            "parameters": {
              "dns_rr": "ares_dns_rr_t",
              "key": "ares_dns_rr_key_t",
              "opt": "unsigned short",
              "val": "unsigned char",
              "val_len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_parse(const unsigned char *buf,\n                                          size_t buf_len, unsigned int flags,\n                                          ares_dns_record_t **dnsrec)",
          "fn_dec_pos": [
            [
              988,
              13
            ],
            [
              990,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_parse",
            "parameters": {
              "buf": "unsigned char",
              "buf_len": "size_t",
              "flags": "unsigned int",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_status_t ares_dns_write(const ares_dns_record_t *dnsrec,\n                                          unsigned char **buf, size_t *buf_len)",
          "fn_dec_pos": [
            [
              1000,
              13
            ],
            [
              1001,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares_status_t ares_dns_write",
            "parameters": {
              "dnsrec": "ares_dns_record_t",
              "buf": "unsigned char",
              "buf_len": "size_t"
            },
            "return_type": "CARES_EXTERN"
          }
        },
        {
          "fn_code": "ares_dns_record_duplicate(const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              1011,
              2
            ],
            [
              1011,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_addr",
          {},
          "",
          [
            474,
            39
          ],
          [
            474,
            55
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            481,
            52
          ],
          [
            481,
            68
          ]
        ],
        [
          "struct ares_dns_rr",
          {},
          "",
          [
            533,
            0
          ],
          [
            533,
            18
          ]
        ],
        [
          "typedef struct ares_dns_rr ares_dns_rr_t;",
          {},
          "ares_dns_rr_t",
          [
            536,
            0
          ],
          [
            536,
            41
          ]
        ],
        [
          "struct ares_dns_qd",
          {},
          "",
          [
            539,
            0
          ],
          [
            539,
            18
          ]
        ],
        [
          "typedef struct ares_dns_qd ares_dns_qd_t;",
          {},
          "ares_dns_qd_t",
          [
            542,
            0
          ],
          [
            542,
            41
          ]
        ],
        [
          "struct ares_dns_record",
          {},
          "",
          [
            545,
            0
          ],
          [
            545,
            22
          ]
        ],
        [
          "typedef struct ares_dns_record ares_dns_record_t;",
          {},
          "ares_dns_record_t",
          [
            548,
            0
          ],
          [
            548,
            49
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            770,
            60
          ],
          [
            770,
            74
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            782,
            30
          ],
          [
            782,
            50
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  ARES_REC_TYPE_A     = 1,     /*!< Host address. */\n  ARES_REC_TYPE_NS    = 2,     /*!< Authoritative server. */\n  ARES_REC_TYPE_CNAME = 5,     /*!< Canonical name. */\n  ARES_REC_TYPE_SOA   = 6,     /*!< Start of authority zone. */\n  ARES_REC_TYPE_PTR   = 12,    /*!< Domain name pointer. */\n  ARES_REC_TYPE_HINFO = 13,    /*!< Host information. */\n  ARES_REC_TYPE_MX    = 15,    /*!< Mail routing information. */\n  ARES_REC_TYPE_TXT   = 16,    /*!< Text strings. */\n  ARES_REC_TYPE_AAAA  = 28,    /*!< RFC 3596. Ip6 Address. */\n  ARES_REC_TYPE_SRV   = 33,    /*!< RFC 2782. Server Selection. */\n  ARES_REC_TYPE_NAPTR = 35,    /*!< RFC 3403. Naming Authority Pointer */\n  ARES_REC_TYPE_OPT   = 41,    /*!< RFC 6891. EDNS0 option (meta-RR) */\n\n  ARES_REC_TYPE_TLSA = 52,     /*!< RFC 6698. DNS-Based Authentication of Named\n                                *   Entities (DANE) Transport Layer Security\n                                *   (TLS) Protocol: TLSA */\n  ARES_REC_TYPE_SVCB  = 64,    /*!< RFC 9460. General Purpose Service Binding */\n  ARES_REC_TYPE_HTTPS = 65,    /*!< RFC 9460. Service Binding type for use with\n                                *   HTTPS */\n  ARES_REC_TYPE_ANY = 255,     /*!< Wildcard match.  Not response RR. */\n  ARES_REC_TYPE_URI = 256,     /*!< RFC 7553. Uniform Resource Identifier */\n  ARES_REC_TYPE_CAA = 257,     /*!< RFC 6844. Certification Authority\n                                *   Authorization. */\n  ARES_REC_TYPE_RAW_RR = 65536 /*!< Used as an indicator that the RR record\n                                *   is not parsed, but provided in wire\n                                *   format */\n} ares_dns_rec_type_t;",
          {
            "ARES_REC_TYPE_A": "",
            "ARES_REC_TYPE_NS": "",
            "ARES_REC_TYPE_CNAME": "",
            "ARES_REC_TYPE_SOA": "",
            "ARES_REC_TYPE_PTR": "",
            "ARES_REC_TYPE_HINFO": "",
            "ARES_REC_TYPE_MX": "",
            "ARES_REC_TYPE_TXT": "",
            "ARES_REC_TYPE_AAAA": "",
            "ARES_REC_TYPE_SRV": "",
            "ARES_REC_TYPE_NAPTR": "",
            "ARES_REC_TYPE_OPT": "",
            "ARES_REC_TYPE_TLSA": "",
            "ARES_REC_TYPE_SVCB": "",
            "ARES_REC_TYPE_HTTPS": "",
            "ARES_REC_TYPE_ANY": "",
            "ARES_REC_TYPE_URI": "",
            "ARES_REC_TYPE_CAA": "",
            "ARES_REC_TYPE_RAW_RR": ""
          },
          "ares_dns_rec_type_t",
          [
            44,
            0
          ],
          [
            71,
            22
          ]
        ],
        [
          "typedef enum {\n  ARES_CLASS_IN     = 1,   /*!< Internet */\n  ARES_CLASS_CHAOS  = 3,   /*!< CHAOS */\n  ARES_CLASS_HESOID = 4,   /*!< Hesoid [Dyer 87] */\n  ARES_CLASS_NONE   = 254, /*!< RFC 2136 */\n  ARES_CLASS_ANY    = 255  /*!< Any class (requests only) */\n} ares_dns_class_t;",
          {
            "ARES_CLASS_IN": "",
            "ARES_CLASS_CHAOS": "",
            "ARES_CLASS_HESOID": "",
            "ARES_CLASS_NONE": "",
            "ARES_CLASS_ANY": ""
          },
          "ares_dns_class_t",
          [
            74,
            0
          ],
          [
            80,
            19
          ]
        ],
        [
          "typedef enum {\n  ARES_SECTION_ANSWER     = 1, /*!< Answer section */\n  ARES_SECTION_AUTHORITY  = 2, /*!< Authority section */\n  ARES_SECTION_ADDITIONAL = 3  /*!< Additional information section */\n} ares_dns_section_t;",
          {
            "ARES_SECTION_ANSWER": "",
            "ARES_SECTION_AUTHORITY": "",
            "ARES_SECTION_ADDITIONAL": ""
          },
          "ares_dns_section_t",
          [
            83,
            0
          ],
          [
            87,
            21
          ]
        ],
        [
          "typedef enum {\n  ARES_OPCODE_QUERY  = 0, /*!< Standard query */\n  ARES_OPCODE_IQUERY = 1, /*!< Inverse query. Obsolete. */\n  ARES_OPCODE_STATUS = 2, /*!< Name server status query */\n  ARES_OPCODE_NOTIFY = 4, /*!< Zone change notification (RFC 1996) */\n  ARES_OPCODE_UPDATE = 5, /*!< Zone update message (RFC2136) */\n} ares_dns_opcode_t;",
          {
            "ARES_OPCODE_QUERY": "",
            "ARES_OPCODE_IQUERY": "",
            "ARES_OPCODE_STATUS": "",
            "ARES_OPCODE_NOTIFY": "",
            "ARES_OPCODE_UPDATE": ""
          },
          "ares_dns_opcode_t",
          [
            90,
            0
          ],
          [
            96,
            20
          ]
        ],
        [
          "typedef enum {\n  ARES_FLAG_QR = 1 << 0, /*!< QR. If set, is a response */\n  ARES_FLAG_AA = 1 << 1, /*!< Authoritative Answer. If set, is authoritative */\n  ARES_FLAG_TC = 1 << 2, /*!< Truncation. If set, is truncated response */\n  ARES_FLAG_RD = 1 << 3, /*!< Recursion Desired. If set, recursion is desired */\n  ARES_FLAG_RA = 1 << 4, /*!< Recursion Available. If set, server supports\n                          *   recursion */\n  ARES_FLAG_AD = 1 << 5, /*!< RFC 2065. Authentic Data bit indicates in a\n                          * response that the data included has been verified by\n                          * the server providing it */\n  ARES_FLAG_CD = 1 << 6, /*!< RFC 2065. Checking Disabled bit indicates in a\n                          * query that non-verified data is acceptable to the\n                          * resolver sending the query. */\n} ares_dns_flags_t;",
          {
            "ARES_FLAG_QR": "",
            "ARES_FLAG_AA": "",
            "ARES_FLAG_TC": "",
            "ARES_FLAG_RD": "",
            "ARES_FLAG_RA": "",
            "ARES_FLAG_AD": "",
            "ARES_FLAG_CD": ""
          },
          "ares_dns_flags_t",
          [
            99,
            0
          ],
          [
            112,
            19
          ]
        ],
        [
          "typedef enum {\n  ARES_RCODE_NOERROR = 0,    /*!< Success */\n  ARES_RCODE_FORMERR = 1,    /*!< Format error. The name server was unable\n                              *   to interpret the query. */\n  ARES_RCODE_SERVFAIL = 2,   /*!< Server Failure. The name server was\n                              *   unable to process this query due to a\n                              *   problem with the nameserver */\n  ARES_RCODE_NXDOMAIN = 3,   /*!< Name Error.  Meaningful only for\n                              *   responses from an authoritative name\n                              *   server, this code signifies that the\n                              *   domain name referenced in the query does\n                              *   not exist. */\n  ARES_RCODE_NOTIMP = 4,     /*!< Not implemented.  The name server does\n                              *   not support the requested kind of\n                              *   query */\n  ARES_RCODE_REFUSED = 5,    /*!< Refused. The name server refuses to\n                              *   perform the specified operation for\n                              *   policy reasons. */\n  ARES_RCODE_YXDOMAIN = 6,   /*!< RFC 2136. Some name that ought not to\n                              *   exist, does exist. */\n  ARES_RCODE_YXRRSET = 7,    /*!< RFC 2136. Some RRset that ought to not\n                              *   exist, does exist. */\n  ARES_RCODE_NXRRSET = 8,    /*!< RFC 2136. Some RRset that ought to exist,\n                              *   does not exist. */\n  ARES_RCODE_NOTAUTH = 9,    /*!< RFC 2136. The server is not authoritative\n                              *   for the zone named in the Zone section.\n                              */\n  ARES_RCODE_NOTZONE = 10,   /*!< RFC 2136. A name used in the Prerequisite\n                              *   or Update Section is not within the zone\n                              *   denoted by the Zone Section. */\n  ARES_RCODE_DSOTYPEI  = 11, /*!< RFC 8409. DSO-TYPE Not implemented */\n  ARES_RCODE_BADSIG    = 16, /*!< RFC 8945. TSIG Signature Failure */\n  ARES_RCODE_BADKEY    = 17, /*!< RFC 8945. Key not recognized. */\n  ARES_RCODE_BADTIME   = 18, /*!< RFC 8945. Signature out of time window. */\n  ARES_RCODE_BADMODE   = 19, /*!< RFC 2930. Bad TKEY Mode */\n  ARES_RCODE_BADNAME   = 20, /*!< RFC 2930. Duplicate Key Name */\n  ARES_RCODE_BADALG    = 21, /*!< RFC 2930. Algorithm not supported */\n  ARES_RCODE_BADTRUNC  = 22, /*!< RFC 8945. Bad Truncation */\n  ARES_RCODE_BADCOOKIE = 23, /*!< RVC 7973. Bad/missing Server Cookie */\n} ares_dns_rcode_t;",
          {
            "ARES_RCODE_NOERROR": "",
            "ARES_RCODE_FORMERR": "",
            "ARES_RCODE_SERVFAIL": "",
            "ARES_RCODE_NXDOMAIN": "",
            "ARES_RCODE_NOTIMP": "",
            "ARES_RCODE_REFUSED": "",
            "ARES_RCODE_YXDOMAIN": "",
            "ARES_RCODE_YXRRSET": "",
            "ARES_RCODE_NXRRSET": "",
            "ARES_RCODE_NOTAUTH": "",
            "ARES_RCODE_NOTZONE": "",
            "ARES_RCODE_DSOTYPEI": "",
            "ARES_RCODE_BADSIG": "",
            "ARES_RCODE_BADKEY": "",
            "ARES_RCODE_BADTIME": "",
            "ARES_RCODE_BADMODE": "",
            "ARES_RCODE_BADNAME": "",
            "ARES_RCODE_BADALG": "",
            "ARES_RCODE_BADTRUNC": "",
            "ARES_RCODE_BADCOOKIE": ""
          },
          "ares_dns_rcode_t",
          [
            115,
            0
          ],
          [
            154,
            19
          ]
        ],
        [
          "typedef enum {\n  ARES_DATATYPE_INADDR  = 1, /*!< struct in_addr * type */\n  ARES_DATATYPE_INADDR6 = 2, /*!< struct ares_in6_addr * type */\n  ARES_DATATYPE_U8      = 3, /*!< 8bit unsigned integer */\n  ARES_DATATYPE_U16     = 4, /*!< 16bit unsigned integer */\n  ARES_DATATYPE_U32     = 5, /*!< 32bit unsigned integer */\n  ARES_DATATYPE_NAME    = 6, /*!< Null-terminated string of a domain name */\n  ARES_DATATYPE_STR     = 7, /*!< Null-terminated string */\n  ARES_DATATYPE_BIN     = 8, /*!< Binary data */\n  ARES_DATATYPE_BINP    = 9, /*!< Officially defined as binary data, but likely\n                              *   printable. Guaranteed to have a NULL\n                              *   terminator for convenience (not included in\n                              *   length) */\n  ARES_DATATYPE_OPT = 10,    /*!< Array of options.  16bit identifier, BIN\n                              *   data. */\n} ares_dns_datatype_t;",
          {
            "ARES_DATATYPE_INADDR": "",
            "ARES_DATATYPE_INADDR6": "",
            "ARES_DATATYPE_U8": "",
            "ARES_DATATYPE_U16": "",
            "ARES_DATATYPE_U32": "",
            "ARES_DATATYPE_NAME": "",
            "ARES_DATATYPE_STR": "",
            "ARES_DATATYPE_BIN": "",
            "ARES_DATATYPE_BINP": "",
            "ARES_DATATYPE_OPT": ""
          },
          "ares_dns_datatype_t",
          [
            157,
            0
          ],
          [
            172,
            22
          ]
        ],
        [
          "typedef enum {\n  /*! A Record. Address. Datatype: INADDR */\n  ARES_RR_A_ADDR = (ARES_REC_TYPE_A * 100) + 1,\n  /*! NS Record. Name. Datatype: NAME */\n  ARES_RR_NS_NSDNAME = (ARES_REC_TYPE_NS * 100) + 1,\n  /*! CNAME Record. CName. Datatype: NAME */\n  ARES_RR_CNAME_CNAME = (ARES_REC_TYPE_CNAME * 100) + 1,\n  /*! SOA Record. MNAME, Primary Source of Data. Datatype: NAME */\n  ARES_RR_SOA_MNAME = (ARES_REC_TYPE_SOA * 100) + 1,\n  /*! SOA Record. RNAME, Mailbox of person responsible. Datatype: NAME */\n  ARES_RR_SOA_RNAME = (ARES_REC_TYPE_SOA * 100) + 2,\n  /*! SOA Record. Serial, version. Datatype: U32 */\n  ARES_RR_SOA_SERIAL = (ARES_REC_TYPE_SOA * 100) + 3,\n  /*! SOA Record. Refresh, zone refersh interval. Datatype: U32 */\n  ARES_RR_SOA_REFRESH = (ARES_REC_TYPE_SOA * 100) + 4,\n  /*! SOA Record. Retry, failed refresh retry interval. Datatype: U32 */\n  ARES_RR_SOA_RETRY = (ARES_REC_TYPE_SOA * 100) + 5,\n  /*! SOA Record. Expire, upper limit on authority. Datatype: U32 */\n  ARES_RR_SOA_EXPIRE = (ARES_REC_TYPE_SOA * 100) + 6,\n  /*! SOA Record. Minimum, RR TTL. Datatype: U32 */\n  ARES_RR_SOA_MINIMUM = (ARES_REC_TYPE_SOA * 100) + 7,\n  /*! PTR Record. DNAME, pointer domain. Datatype: NAME */\n  ARES_RR_PTR_DNAME = (ARES_REC_TYPE_PTR * 100) + 1,\n  /*! HINFO Record. CPU. Datatype: STR */\n  ARES_RR_HINFO_CPU = (ARES_REC_TYPE_HINFO * 100) + 1,\n  /*! HINFO Record. OS. Datatype: STR */\n  ARES_RR_HINFO_OS = (ARES_REC_TYPE_HINFO * 100) + 2,\n  /*! MX Record. Preference. Datatype: U16 */\n  ARES_RR_MX_PREFERENCE = (ARES_REC_TYPE_MX * 100) + 1,\n  /*! MX Record. Exchange, domain. Datatype: NAME */\n  ARES_RR_MX_EXCHANGE = (ARES_REC_TYPE_MX * 100) + 2,\n  /*! TXT Record. Data. Datatype: BINP */\n  ARES_RR_TXT_DATA = (ARES_REC_TYPE_TXT * 100) + 1,\n  /*! AAAA Record. Address. Datatype: INADDR6 */\n  ARES_RR_AAAA_ADDR = (ARES_REC_TYPE_AAAA * 100) + 1,\n  /*! SRV Record. Priority. Datatype: U16 */\n  ARES_RR_SRV_PRIORITY = (ARES_REC_TYPE_SRV * 100) + 2,\n  /*! SRV Record. Weight. Datatype: U16 */\n  ARES_RR_SRV_WEIGHT = (ARES_REC_TYPE_SRV * 100) + 3,\n  /*! SRV Record. Port. Datatype: U16 */\n  ARES_RR_SRV_PORT = (ARES_REC_TYPE_SRV * 100) + 4,\n  /*! SRV Record. Target domain. Datatype: NAME */\n  ARES_RR_SRV_TARGET = (ARES_REC_TYPE_SRV * 100) + 5,\n  /*! NAPTR Record. Order. Datatype: U16 */\n  ARES_RR_NAPTR_ORDER = (ARES_REC_TYPE_NAPTR * 100) + 1,\n  /*! NAPTR Record. Preference. Datatype: U16 */\n  ARES_RR_NAPTR_PREFERENCE = (ARES_REC_TYPE_NAPTR * 100) + 2,\n  /*! NAPTR Record. Flags. Datatype: STR */\n  ARES_RR_NAPTR_FLAGS = (ARES_REC_TYPE_NAPTR * 100) + 3,\n  /*! NAPTR Record. Services. Datatype: STR */\n  ARES_RR_NAPTR_SERVICES = (ARES_REC_TYPE_NAPTR * 100) + 4,\n  /*! NAPTR Record. Regexp. Datatype: STR */\n  ARES_RR_NAPTR_REGEXP = (ARES_REC_TYPE_NAPTR * 100) + 5,\n  /*! NAPTR Record. Replacement. Datatype: NAME */\n  ARES_RR_NAPTR_REPLACEMENT = (ARES_REC_TYPE_NAPTR * 100) + 6,\n  /*! OPT Record. UDP Size. Datatype: U16 */\n  ARES_RR_OPT_UDP_SIZE = (ARES_REC_TYPE_OPT * 100) + 1,\n  /*! OPT Record. Version. Datatype: U8 */\n  ARES_RR_OPT_VERSION = (ARES_REC_TYPE_OPT * 100) + 3,\n  /*! OPT Record. Flags. Datatype: U16 */\n  ARES_RR_OPT_FLAGS = (ARES_REC_TYPE_OPT * 100) + 4,\n  /*! OPT Record. Options. Datatype: OPT */\n  ARES_RR_OPT_OPTIONS = (ARES_REC_TYPE_OPT * 100) + 5,\n  /*! TLSA Record. Certificate Usage. Datatype: U8 */\n  ARES_RR_TLSA_CERT_USAGE = (ARES_REC_TYPE_TLSA * 100) + 1,\n  /*! TLSA Record. Selector. Datatype: U8 */\n  ARES_RR_TLSA_SELECTOR = (ARES_REC_TYPE_TLSA * 100) + 2,\n  /*! TLSA Record. Matching Type. Datatype: U8 */\n  ARES_RR_TLSA_MATCH = (ARES_REC_TYPE_TLSA * 100) + 3,\n  /*! TLSA Record. Certificate Association Data. Datatype: BIN */\n  ARES_RR_TLSA_DATA = (ARES_REC_TYPE_TLSA * 100) + 4,\n  /*! SVCB Record. SvcPriority. Datatype: U16 */\n  ARES_RR_SVCB_PRIORITY = (ARES_REC_TYPE_SVCB * 100) + 1,\n  /*! SVCB Record. TargetName. Datatype: NAME */\n  ARES_RR_SVCB_TARGET = (ARES_REC_TYPE_SVCB * 100) + 2,\n  /*! SVCB Record. SvcParams. Datatype: OPT */\n  ARES_RR_SVCB_PARAMS = (ARES_REC_TYPE_SVCB * 100) + 3,\n  /*! HTTPS Record. SvcPriority. Datatype: U16 */\n  ARES_RR_HTTPS_PRIORITY = (ARES_REC_TYPE_HTTPS * 100) + 1,\n  /*! HTTPS Record. TargetName. Datatype: NAME */\n  ARES_RR_HTTPS_TARGET = (ARES_REC_TYPE_HTTPS * 100) + 2,\n  /*! HTTPS Record. SvcParams. Datatype: OPT */\n  ARES_RR_HTTPS_PARAMS = (ARES_REC_TYPE_HTTPS * 100) + 3,\n  /*! URI Record. Priority. Datatype: U16 */\n  ARES_RR_URI_PRIORITY = (ARES_REC_TYPE_URI * 100) + 1,\n  /*! URI Record. Weight. Datatype: U16 */\n  ARES_RR_URI_WEIGHT = (ARES_REC_TYPE_URI * 100) + 2,\n  /*! URI Record. Target domain. Datatype: NAME */\n  ARES_RR_URI_TARGET = (ARES_REC_TYPE_URI * 100) + 3,\n  /*! CAA Record. Critical flag. Datatype: U8 */\n  ARES_RR_CAA_CRITICAL = (ARES_REC_TYPE_CAA * 100) + 1,\n  /*! CAA Record. Tag/Property. Datatype: STR */\n  ARES_RR_CAA_TAG = (ARES_REC_TYPE_CAA * 100) + 2,\n  /*! CAA Record. Value. Datatype: BINP */\n  ARES_RR_CAA_VALUE = (ARES_REC_TYPE_CAA * 100) + 3,\n  /*! RAW Record. RR Type. Datatype: U16 */\n  ARES_RR_RAW_RR_TYPE = (ARES_REC_TYPE_RAW_RR * 100) + 1,\n  /*! RAW Record. RR Data. Datatype: BIN */\n  ARES_RR_RAW_RR_DATA = (ARES_REC_TYPE_RAW_RR * 100) + 2,\n} ares_dns_rr_key_t;",
          {
            "ARES_RR_A_ADDR": "",
            "ARES_RR_NS_NSDNAME": "",
            "ARES_RR_CNAME_CNAME": "",
            "ARES_RR_SOA_MNAME": "",
            "ARES_RR_SOA_RNAME": "",
            "ARES_RR_SOA_SERIAL": "",
            "ARES_RR_SOA_REFRESH": "",
            "ARES_RR_SOA_RETRY": "",
            "ARES_RR_SOA_EXPIRE": "",
            "ARES_RR_SOA_MINIMUM": "",
            "ARES_RR_PTR_DNAME": "",
            "ARES_RR_HINFO_CPU": "",
            "ARES_RR_HINFO_OS": "",
            "ARES_RR_MX_PREFERENCE": "",
            "ARES_RR_MX_EXCHANGE": "",
            "ARES_RR_TXT_DATA": "",
            "ARES_RR_AAAA_ADDR": "",
            "ARES_RR_SRV_PRIORITY": "",
            "ARES_RR_SRV_WEIGHT": "",
            "ARES_RR_SRV_PORT": "",
            "ARES_RR_SRV_TARGET": "",
            "ARES_RR_NAPTR_ORDER": "",
            "ARES_RR_NAPTR_PREFERENCE": "",
            "ARES_RR_NAPTR_FLAGS": "",
            "ARES_RR_NAPTR_SERVICES": "",
            "ARES_RR_NAPTR_REGEXP": "",
            "ARES_RR_NAPTR_REPLACEMENT": "",
            "ARES_RR_OPT_UDP_SIZE": "",
            "ARES_RR_OPT_VERSION": "",
            "ARES_RR_OPT_FLAGS": "",
            "ARES_RR_OPT_OPTIONS": "",
            "ARES_RR_TLSA_CERT_USAGE": "",
            "ARES_RR_TLSA_SELECTOR": "",
            "ARES_RR_TLSA_MATCH": "",
            "ARES_RR_TLSA_DATA": "",
            "ARES_RR_SVCB_PRIORITY": "",
            "ARES_RR_SVCB_TARGET": "",
            "ARES_RR_SVCB_PARAMS": "",
            "ARES_RR_HTTPS_PRIORITY": "",
            "ARES_RR_HTTPS_TARGET": "",
            "ARES_RR_HTTPS_PARAMS": "",
            "ARES_RR_URI_PRIORITY": "",
            "ARES_RR_URI_WEIGHT": "",
            "ARES_RR_URI_TARGET": "",
            "ARES_RR_CAA_CRITICAL": "",
            "ARES_RR_CAA_TAG": "",
            "ARES_RR_CAA_VALUE": "",
            "ARES_RR_RAW_RR_TYPE": "",
            "ARES_RR_RAW_RR_DATA": ""
          },
          "ares_dns_rr_key_t",
          [
            177,
            0
          ],
          [
            276,
            20
          ]
        ],
        [
          "typedef enum {\n  /*! Certificate Usage 0. CA Constraint. */\n  ARES_TLSA_USAGE_CA = 0,\n  /*! Certificate Usage 1. Service Certificate Constraint. */\n  ARES_TLSA_USAGE_SERVICE = 1,\n  /*! Certificate Usage 2. Trust Anchor Assertion. */\n  ARES_TLSA_USAGE_TRUSTANCHOR = 2,\n  /*! Certificate Usage 3. Domain-issued certificate. */\n  ARES_TLSA_USAGE_DOMAIN = 3\n} ares_tlsa_usage_t;",
          {
            "ARES_TLSA_USAGE_CA": "",
            "ARES_TLSA_USAGE_SERVICE": "",
            "ARES_TLSA_USAGE_TRUSTANCHOR": "",
            "ARES_TLSA_USAGE_DOMAIN": ""
          },
          "ares_tlsa_usage_t",
          [
            279,
            0
          ],
          [
            288,
            20
          ]
        ],
        [
          "typedef enum {\n  /*! Full Certificate */\n  ARES_TLSA_SELECTOR_FULL = 0,\n  /*! DER-encoded SubjectPublicKeyInfo */\n  ARES_TLSA_SELECTOR_SUBJPUBKEYINFO = 1\n} ares_tlsa_selector_t;",
          {
            "ARES_TLSA_SELECTOR_FULL": "",
            "ARES_TLSA_SELECTOR_SUBJPUBKEYINFO": ""
          },
          "ares_tlsa_selector_t",
          [
            291,
            0
          ],
          [
            296,
            23
          ]
        ],
        [
          "typedef enum {\n  /*! Exact match */\n  ARES_TLSA_MATCH_EXACT = 0,\n  /*! Sha256 match */\n  ARES_TLSA_MATCH_SHA256 = 1,\n  /*! Sha512 match */\n  ARES_TLSA_MATCH_SHA512 = 2\n} ares_tlsa_match_t;",
          {
            "ARES_TLSA_MATCH_EXACT": "",
            "ARES_TLSA_MATCH_SHA256": "",
            "ARES_TLSA_MATCH_SHA512": ""
          },
          "ares_tlsa_match_t",
          [
            299,
            0
          ],
          [
            306,
            20
          ]
        ],
        [
          "typedef enum {\n  /*! Mandatory keys in this RR (RFC 9460 Section 8) */\n  ARES_SVCB_PARAM_MANDATORY = 0,\n  /*! Additional supported protocols (RFC 9460 Section 7.1) */\n  ARES_SVCB_PARAM_ALPN = 1,\n  /*! No support for default protocol (RFC 9460 Section 7.1) */\n  ARES_SVCB_PARAM_NO_DEFAULT_ALPN = 2,\n  /*! Port for alternative endpoint (RFC 9460 Section 7.2) */\n  ARES_SVCB_PARAM_PORT = 3,\n  /*! IPv4 address hints (RFC 9460 Section 7.3) */\n  ARES_SVCB_PARAM_IPV4HINT = 4,\n  /*! RESERVED (held for Encrypted ClientHello) */\n  ARES_SVCB_PARAM_ECH = 5,\n  /*! IPv6 address hints (RFC 9460 Section 7.3) */\n  ARES_SVCB_PARAM_IPV6HINT = 6\n} ares_svcb_param_t;",
          {
            "ARES_SVCB_PARAM_MANDATORY": "",
            "ARES_SVCB_PARAM_ALPN": "",
            "ARES_SVCB_PARAM_NO_DEFAULT_ALPN": "",
            "ARES_SVCB_PARAM_PORT": "",
            "ARES_SVCB_PARAM_IPV4HINT": "",
            "ARES_SVCB_PARAM_ECH": "",
            "ARES_SVCB_PARAM_IPV6HINT": ""
          },
          "ares_svcb_param_t",
          [
            309,
            0
          ],
          [
            324,
            20
          ]
        ],
        [
          "typedef enum {\n  /*! RFC 8764. Apple's DNS Long-Lived Queries Protocol */\n  ARES_OPT_PARAM_LLQ = 1,\n  /*! http://files.dns-sd.org/draft-sekar-dns-ul.txt: Update Lease */\n  ARES_OPT_PARAM_UL = 2,\n  /*! RFC 5001. Name Server Identification */\n  ARES_OPT_PARAM_NSID = 3,\n  /*! RFC 6975. DNSSEC Algorithm Understood */\n  ARES_OPT_PARAM_DAU = 5,\n  /*! RFC 6975. DS Hash Understood */\n  ARES_OPT_PARAM_DHU = 6,\n  /*! RFC 6975. NSEC3 Hash Understood */\n  ARES_OPT_PARAM_N3U = 7,\n  /*! RFC 7871. Client Subnet */\n  ARES_OPT_PARAM_EDNS_CLIENT_SUBNET = 8,\n  /*! RFC 7314. Expire Timer */\n  ARES_OPT_PARAM_EDNS_EXPIRE = 9,\n  /*! RFC 7873. Client and Server Cookies */\n  ARES_OPT_PARAM_COOKIE = 10,\n  /*! RFC 7828. TCP Keepalive timeout */\n  ARES_OPT_PARAM_EDNS_TCP_KEEPALIVE = 11,\n  /*! RFC 7830. Padding */\n  ARES_OPT_PARAM_PADDING = 12,\n  /*! RFC 7901. Chain query requests */\n  ARES_OPT_PARAM_CHAIN = 13,\n  /*! RFC 8145. Signaling Trust Anchor Knowledge in DNSSEC */\n  ARES_OPT_PARAM_EDNS_KEY_TAG = 14,\n  /*! RFC 8914. Extended ERROR code and message */\n  ARES_OPT_PARAM_EXTENDED_DNS_ERROR = 15,\n} ares_opt_param_t;",
          {
            "ARES_OPT_PARAM_LLQ": "",
            "ARES_OPT_PARAM_UL": "",
            "ARES_OPT_PARAM_NSID": "",
            "ARES_OPT_PARAM_DAU": "",
            "ARES_OPT_PARAM_DHU": "",
            "ARES_OPT_PARAM_N3U": "",
            "ARES_OPT_PARAM_EDNS_CLIENT_SUBNET": "",
            "ARES_OPT_PARAM_EDNS_EXPIRE": "",
            "ARES_OPT_PARAM_COOKIE": "",
            "ARES_OPT_PARAM_EDNS_TCP_KEEPALIVE": "",
            "ARES_OPT_PARAM_PADDING": "",
            "ARES_OPT_PARAM_CHAIN": "",
            "ARES_OPT_PARAM_EDNS_KEY_TAG": "",
            "ARES_OPT_PARAM_EXTENDED_DNS_ERROR": ""
          },
          "ares_opt_param_t",
          [
            327,
            0
          ],
          [
            356,
            19
          ]
        ],
        [
          "typedef enum {\n  /*! No value allowed for this option */\n  ARES_OPT_DATATYPE_NONE = 1,\n  /*! List of strings, each prefixed with a single octet representing the length\n   */\n  ARES_OPT_DATATYPE_STR_LIST = 2,\n  /*! List of 8bit integers, concatenated */\n  ARES_OPT_DATATYPE_U8_LIST = 3,\n  /*! 16bit integer in network byte order */\n  ARES_OPT_DATATYPE_U16 = 4,\n  /*! list of 16bit integer in network byte order, concatenated. */\n  ARES_OPT_DATATYPE_U16_LIST = 5,\n  /*! 32bit integer in network byte order */\n  ARES_OPT_DATATYPE_U32 = 6,\n  /*! list 32bit integer in network byte order, concatenated */\n  ARES_OPT_DATATYPE_U32_LIST = 7,\n  /*! List of ipv4 addresses in network byte order, concatenated */\n  ARES_OPT_DATATYPE_INADDR4_LIST = 8,\n  /*! List of ipv6 addresses in network byte order, concatenated */\n  ARES_OPT_DATATYPE_INADDR6_LIST = 9,\n  /*! Binary Data */\n  ARES_OPT_DATATYPE_BIN = 10,\n  /*! DNS Domain Name Format */\n  ARES_OPT_DATATYPE_NAME = 11\n} ares_dns_opt_datatype_t;",
          {
            "ARES_OPT_DATATYPE_NONE": "",
            "ARES_OPT_DATATYPE_STR_LIST": "",
            "ARES_OPT_DATATYPE_U8_LIST": "",
            "ARES_OPT_DATATYPE_U16": "",
            "ARES_OPT_DATATYPE_U16_LIST": "",
            "ARES_OPT_DATATYPE_U32": "",
            "ARES_OPT_DATATYPE_U32_LIST": "",
            "ARES_OPT_DATATYPE_INADDR4_LIST": "",
            "ARES_OPT_DATATYPE_INADDR6_LIST": "",
            "ARES_OPT_DATATYPE_BIN": "",
            "ARES_OPT_DATATYPE_NAME": ""
          },
          "ares_dns_opt_datatype_t",
          [
            360,
            0
          ],
          [
            384,
            26
          ]
        ],
        [
          "typedef enum {\n  /*! Parse Answers from RFC 1035 that allow name compression as RAW */\n  ARES_DNS_PARSE_AN_BASE_RAW = 1 << 0,\n  /*! Parse Authority from RFC 1035 that allow name compression as RAW */\n  ARES_DNS_PARSE_NS_BASE_RAW = 1 << 1,\n  /*! Parse Additional from RFC 1035 that allow name compression as RAW */\n  ARES_DNS_PARSE_AR_BASE_RAW = 1 << 2,\n  /*! Parse Answers from later RFCs (no name compression) RAW */\n  ARES_DNS_PARSE_AN_EXT_RAW = 1 << 3,\n  /*! Parse Authority from later RFCs (no name compression) as RAW */\n  ARES_DNS_PARSE_NS_EXT_RAW = 1 << 4,\n  /*! Parse Additional from later RFCs (no name compression) as RAW */\n  ARES_DNS_PARSE_AR_EXT_RAW = 1 << 5\n} ares_dns_parse_flags_t;",
          {
            "ARES_DNS_PARSE_AN_BASE_RAW": "",
            "ARES_DNS_PARSE_NS_BASE_RAW": "",
            "ARES_DNS_PARSE_AR_BASE_RAW": "",
            "ARES_DNS_PARSE_AN_EXT_RAW": "",
            "ARES_DNS_PARSE_NS_EXT_RAW": "",
            "ARES_DNS_PARSE_AR_EXT_RAW": ""
          },
          "ares_dns_parse_flags_t",
          [
            387,
            0
          ],
          [
            400,
            25
          ]
        ]
      ]
    }
  }
}