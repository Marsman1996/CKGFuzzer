{
  "src": {
    "../docker_shared/source_code/c-ares/test/ares-test-fuzz.c": {
      "fn_def_list": [
        {
          "fn_code": "int LLVMFuzzerTestOneInput(const unsigned char *data, unsigned long size)\n{\n  // Feed the data into each of the ares_parse_*_reply functions.\n  struct hostent          *host = NULL;\n  struct ares_addrttl      info[5];\n  struct ares_addr6ttl     info6[5];\n  unsigned char            addrv4[4] = { 0x10, 0x20, 0x30, 0x40 };\n  struct ares_srv_reply   *srv       = NULL;\n  struct ares_mx_reply    *mx        = NULL;\n  struct ares_txt_reply   *txt       = NULL;\n  struct ares_soa_reply   *soa       = NULL;\n  struct ares_naptr_reply *naptr     = NULL;\n  struct ares_caa_reply   *caa       = NULL;\n  struct ares_uri_reply   *uri       = NULL;\n  int                      count     = 5;\n  ares_parse_a_reply(data, (int)size, &host, info, &count);\n  if (host) {\n    ares_free_hostent(host);\n  }\n\n  host  = NULL;\n  count = 5;\n  ares_parse_aaaa_reply(data, (int)size, &host, info6, &count);\n  if (host) {\n    ares_free_hostent(host);\n  }\n\n  host = NULL;\n  ares_parse_ptr_reply(data, (int)size, addrv4, sizeof(addrv4), AF_INET, &host);\n  if (host) {\n    ares_free_hostent(host);\n  }\n\n  host = NULL;\n  ares_parse_ns_reply(data, (int)size, &host);\n  if (host) {\n    ares_free_hostent(host);\n  }\n\n  ares_parse_srv_reply(data, (int)size, &srv);\n  if (srv) {\n    ares_free_data(srv);\n  }\n\n  ares_parse_mx_reply(data, (int)size, &mx);\n  if (mx) {\n    ares_free_data(mx);\n  }\n\n  ares_parse_txt_reply(data, (int)size, &txt);\n  if (txt) {\n    ares_free_data(txt);\n  }\n\n  ares_parse_soa_reply(data, (int)size, &soa);\n  if (soa) {\n    ares_free_data(soa);\n  }\n\n  ares_parse_naptr_reply(data, (int)size, &naptr);\n  if (naptr) {\n    ares_free_data(naptr);\n  }\n\n  ares_parse_caa_reply(data, (int)size, &caa);\n  if (caa) {\n    ares_free_data(caa);\n  }\n\n  ares_parse_uri_reply(data, (int)size, &uri);\n  if (uri) {\n    ares_free_data(uri);\n  }\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              107,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "data": "unsigned char",
              "size": "unsigned long"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "LLVMFuzzerTestOneInput(const unsigned char *data, unsigned long size)",
          "fn_dec_pos": [
            [
              29,
              4
            ],
            [
              29,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "data": "unsigned char",
              "size": "unsigned long"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            35,
            2
          ],
          [
            35,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            36,
            2
          ],
          [
            36,
            21
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            37,
            2
          ],
          [
            37,
            22
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            39,
            2
          ],
          [
            39,
            23
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            40,
            2
          ],
          [
            40,
            22
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            41,
            2
          ],
          [
            41,
            23
          ]
        ],
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            42,
            2
          ],
          [
            42,
            23
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            43,
            2
          ],
          [
            43,
            25
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            44,
            2
          ],
          [
            44,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            45,
            2
          ],
          [
            45,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stddef.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-fuzz-name.c": {
      "fn_def_list": [
        {
          "fn_code": "int LLVMFuzzerTestOneInput(const unsigned char *data, unsigned long size)\n{\n  // Null terminate the data.\n  char          *name   = malloc(size + 1);\n  unsigned char *buf    = NULL;\n  int            buflen = 0;\n  name[size]            = '\\0';\n  memcpy(name, data, size);\n\n  ares_create_query(name, C_IN, T_AAAA, 1234, 0, &buf, &buflen, 1024);\n  free(buf);\n  free(name);\n  return 0;\n}",
          "fn_code_pos": [
            [
              36,
              0
            ],
            [
              49,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "data": "unsigned char",
              "size": "unsigned long"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "LLVMFuzzerTestOneInput(const unsigned char *data, unsigned long size)",
          "fn_dec_pos": [
            [
              33,
              4
            ],
            [
              33,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "data": "unsigned char",
              "size": "unsigned long"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stddef.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-fuzz.c": {
      "fn_def_list": [
        {
          "fn_code": "static void ProcessFile(int fd)\n{\n  ares_ssize_t count = read(fd, afl_buffer, kMaxAflInputSize);\n  /*\n   * Make a copy of the data so that it's not part of a larger\n   * buffer (where buffer overflows would go unnoticed).\n   */\n  if (count > 0) {\n    unsigned char *copied_data = (unsigned char *)malloc((size_t)count);\n    memcpy(copied_data, afl_buffer, (size_t)count);\n    LLVMFuzzerTestOneInput(copied_data, (size_t)count);\n    free(copied_data);\n  }\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              70,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ProcessFile",
            "parameters": {
              "fd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(int argc, char *argv[])\n{\n  if (argc == 1) {\n    int count = 0;\n    while (KEEP_FUZZING(count)) {\n      ProcessFile(fileno(stdin));\n      count++;\n    }\n  } else {\n    int ii;\n    for (ii = 1; ii < argc; ++ii) {\n      int fd = open(argv[ii], O_RDONLY);\n      if (fd < 0) {\n        fprintf(stderr, \"Failed to open '%s'\\n\", argv[ii]);\n        continue;\n      }\n      ProcessFile(fd);\n      close(fd);\n    }\n  }\n  return 0;\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              93,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "LLVMFuzzerTestOneInput(const unsigned char *data, unsigned long size)",
          "fn_dec_pos": [
            [
              55,
              4
            ],
            [
              55,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "data": "unsigned char",
              "size": "unsigned long"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <sys/types.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <io.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#  include <unistd.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares_timeout.c": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ares__timeval_remaining(struct timeval       *remaining,\n                             const struct timeval *now,\n                             const struct timeval *tout)",
          "fn_dec_pos": [
            [
              36,
              5
            ],
            [
              38,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ares__timeval_remaining",
            "parameters": {
              "remaining": "struct timeval",
              "now": "struct timeval",
              "tout": "struct timeval"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct timeval",
          {},
          "",
          [
            36,
            29
          ],
          [
            36,
            43
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            37,
            35
          ],
          [
            37,
            49
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            38,
            35
          ],
          [
            38,
            49
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <limits.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-parse-ns.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseNsReplyOK) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_NS))\n    .add_answer(new DNSNsRR(\"example.com\", 100, \"ns.example.com\"));\n  std::vector<byte> data = pkt.data();\n\n  struct hostent *host = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_ns_reply(data.data(), (int)data.size(), &host));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'example.com' aliases=[ns.example.com] addrs=[]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              48,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseNsReplyMultiple) {\n  DNSPacket pkt;\n  pkt.set_qid(10501).set_response().set_rd().set_ra()\n    .add_question(new DNSQuestion(\"google.com\", T_NS))\n    .add_answer(new DNSNsRR(\"google.com\", 59, \"ns1.google.com\"))\n    .add_answer(new DNSNsRR(\"google.com\", 59, \"ns2.google.com\"))\n    .add_answer(new DNSNsRR(\"google.com\", 59, \"ns3.google.com\"))\n    .add_answer(new DNSNsRR(\"google.com\", 59, \"ns4.google.com\"))\n    .add_additional(new DNSARR(\"ns4.google.com\", 247, {216,239,38,10}))\n    .add_additional(new DNSARR(\"ns2.google.com\", 247, {216,239,34,10}))\n    .add_additional(new DNSARR(\"ns1.google.com\", 247, {216,239,32,10}))\n    .add_additional(new DNSARR(\"ns3.google.com\", 247, {216,239,36,10}));\n  std::vector<byte> data = pkt.data();\n\n  struct hostent *host = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_ns_reply(data.data(), (int)data.size(), &host));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'google.com' aliases=[ns1.google.com, ns2.google.com, ns3.google.com, ns4.google.com] addrs=[]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              50,
              0
            ],
            [
              71,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseNsReplyErrors) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_NS))\n    .add_answer(new DNSNsRR(\"example.com\", 100, \"ns.example.com\"));\n  std::vector<byte> data;\n  struct hostent *host = nullptr;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_ns_reply(data.data(), (int)data.size(), &host));\n  pkt.add_question(new DNSQuestion(\"example.com\", T_NS));\n\n#ifdef DISABLED\n  // Question != answer\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_NS));\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_ns_reply(data.data(), (int)data.size(), &host));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_NS));\n#endif\n\n  // Two questions.\n  pkt.add_question(new DNSQuestion(\"example.com\", T_NS));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_ns_reply(data.data(), (int)data.size(), &host));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_NS));\n\n  // Wrong sort of answer.\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_ns_reply(data.data(), (int)data.size(), &host));\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSNsRR(\"example.com\", 100, \"ns.example.com\"));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_ns_reply(data.data(), (int)data.size(), &host));\n  pkt.add_answer(new DNSNsRR(\"example.com\", 100, \"ns.example.com\"));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    EXPECT_EQ(ARES_EBADRESP, ares_parse_ns_reply(data.data(), (int)len, &host));\n  }\n}",
          "fn_code_pos": [
            [
              73,
              0
            ],
            [
              123,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseNsReplyAllocFail) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_NS))\n    .add_answer(new DNSCnameRR(\"example.com\", 300, \"c.example.com\"))\n    .add_answer(new DNSNsRR(\"c.example.com\", 100, \"ns.example.com\"));\n  std::vector<byte> data = pkt.data();\n  struct hostent *host = nullptr;\n\n  for (int ii = 1; ii <= 8; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_ns_reply(data.data(), (int)data.size(), &host)) << ii;\n  }\n}",
          "fn_code_pos": [
            [
              125,
              0
            ],
            [
              139,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            41,
            2
          ],
          [
            41,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            64,
            2
          ],
          [
            64,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            79,
            2
          ],
          [
            79,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            132,
            2
          ],
          [
            132,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-parse-uri.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseUriReplyOK) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_URI))\n    .add_answer(new DNSUriRR(\"example.com\", 100, 10, 20, \"uri.example.com\"))\n    .add_answer(new DNSUriRR(\"example.com\", 200, 11, 21, \"uri2.example.com\"));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_uri_reply* uri = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_uri_reply(data.data(), (int)data.size(), &uri));\n  ASSERT_NE(nullptr, uri);\n\n  EXPECT_EQ(\"uri.example.com\", std::string(uri->uri));\n  EXPECT_EQ(10, uri->priority);\n  EXPECT_EQ(20, uri->weight);\n  EXPECT_EQ(100, uri->ttl);\n\n  struct ares_uri_reply* uri2 = uri->next;\n  ASSERT_NE(nullptr, uri2);\n  EXPECT_EQ(\"uri2.example.com\", std::string(uri2->uri));\n  EXPECT_EQ(11, uri2->priority);\n  EXPECT_EQ(21, uri2->weight);\n  EXPECT_EQ(200, uri2->ttl);\n  EXPECT_EQ(nullptr, uri2->next);\n\n  ares_free_data(uri);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseUriReplySingle) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.abc.def.com\", T_URI))\n    .add_answer(new DNSUriRR(\"example.abc.def.com\", 180, 0, 10, \"example.abc.def.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else1.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else2.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else3.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else4.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else5.where.com\"))\n    .add_additional(new DNSARR(\"else2.where.com\", 42, {172,19,0,1}))\n    .add_additional(new DNSARR(\"else5.where.com\", 42, {172,19,0,2}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_uri_reply* uri = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_uri_reply(data.data(), (int)data.size(), &uri));\n  ASSERT_NE(nullptr, uri);\n\n  EXPECT_EQ(\"example.abc.def.com\", std::string(uri->uri));\n  EXPECT_EQ(0, uri->priority);\n  EXPECT_EQ(10, uri->weight);\n  EXPECT_EQ(180, uri->ttl);\n  EXPECT_EQ(nullptr, uri->next);\n\n  ares_free_data(uri);\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseUriReplyMalformed) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x01, 0x00,  // type URI\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x01, 0x00,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x04,  // rdata length -- too short\n    0x02, 0x03, 0x04, 0x05,\n  };\n\n  struct ares_uri_reply* uri = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_uri_reply(data.data(), (int)data.size(), &uri));\n  ASSERT_EQ(nullptr, uri);\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseUriReplyMultiple) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_ra().set_rd()\n    .add_question(new DNSQuestion(\"uri.example.com\", T_URI))\n    .add_answer(new DNSUriRR(\"uri.example.com\", 600, 0, 5, \"a1.uri.example.com\"))\n    .add_answer(new DNSUriRR(\"uri.example.com\", 660, 0, 5, \"a2.uri.example.com\"))\n    .add_answer(new DNSUriRR(\"uri.example.com\", 720, 0, 5, \"a3.uri.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns1.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns2.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns3.example.com\"))\n    .add_additional(new DNSARR(\"a1.uri.example.com\", 300, {172,19,1,1}))\n    .add_additional(new DNSARR(\"a2.uri.example.com\", 300, {172,19,1,2}))\n    .add_additional(new DNSARR(\"a3.uri.example.com\", 300, {172,19,1,3}))\n    .add_additional(new DNSARR(\"n1.example.com\", 300, {172,19,0,1}))\n    .add_additional(new DNSARR(\"n2.example.com\", 300, {172,19,0,2}))\n    .add_additional(new DNSARR(\"n3.example.com\", 300, {172,19,0,3}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_uri_reply* uri0 = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_uri_reply(data.data(), (int)data.size(), &uri0));\n  ASSERT_NE(nullptr, uri0);\n  struct ares_uri_reply* uri = uri0;\n\n  EXPECT_EQ(\"a1.uri.example.com\", std::string(uri->uri));\n  EXPECT_EQ(0, uri->priority);\n  EXPECT_EQ(5, uri->weight);\n  EXPECT_EQ(600, uri->ttl);\n  EXPECT_NE(nullptr, uri->next);\n  uri = uri->next;\n\n  EXPECT_EQ(\"a2.uri.example.com\", std::string(uri->uri));\n  EXPECT_EQ(0, uri->priority);\n  EXPECT_EQ(5, uri->weight);\n  EXPECT_EQ(660, uri->ttl);\n  EXPECT_NE(nullptr, uri->next);\n  uri = uri->next;\n\n  EXPECT_EQ(\"a3.uri.example.com\", std::string(uri->uri));\n  EXPECT_EQ(0, uri->priority);\n  EXPECT_EQ(5, uri->weight);\n  EXPECT_EQ(720, uri->ttl);\n  EXPECT_EQ(nullptr, uri->next);\n\n  ares_free_data(uri0);\n}",
          "fn_code_pos": [
            [
              120,
              0
            ],
            [
              164,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseUriReplyCname) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.abc.def.com\", T_URI))\n    .add_answer(new DNSCnameRR(\"example.abc.def.com\", 300, \"cname.abc.def.com\"))\n    .add_answer(new DNSUriRR(\"cname.abc.def.com\", 600, 0, 10, \"uri.abc.def.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else1.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else2.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else3.where.com\"))\n    .add_additional(new DNSARR(\"example.abc.def.com\", 300, {172,19,0,1}))\n    .add_additional(new DNSARR(\"else1.where.com\", 42, {172,19,0,1}))\n    .add_additional(new DNSARR(\"else2.where.com\", 42, {172,19,0,2}))\n    .add_additional(new DNSARR(\"else3.where.com\", 42, {172,19,0,3}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_uri_reply* uri = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_uri_reply(data.data(), (int)data.size(), &uri));\n  ASSERT_NE(nullptr, uri);\n\n  EXPECT_EQ(\"uri.abc.def.com\", std::string(uri->uri));\n  EXPECT_EQ(0, uri->priority);\n  EXPECT_EQ(10, uri->weight);\n  EXPECT_EQ(600, uri->ttl);\n  EXPECT_EQ(nullptr, uri->next);\n\n  ares_free_data(uri);\n}",
          "fn_code_pos": [
            [
              166,
              0
            ],
            [
              192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseUriReplyCnameMultiple) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_ra().set_rd()\n    .add_question(new DNSQuestion(\"query.example.com\", T_URI))\n    .add_answer(new DNSCnameRR(\"query.example.com\", 300, \"uri.example.com\"))\n    .add_answer(new DNSUriRR(\"uri.example.com\", 600, 0, 5, \"a1.uri.example.com\"))\n    .add_answer(new DNSUriRR(\"uri.example.com\", 660, 0, 5, \"a2.uri.example.com\"))\n    .add_answer(new DNSUriRR(\"uri.example.com\", 720, 0, 5, \"a3.uri.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns1.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns2.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns3.example.com\"))\n    .add_additional(new DNSARR(\"a1.uri.example.com\", 300, {172,19,1,1}))\n    .add_additional(new DNSARR(\"a2.uri.example.com\", 300, {172,19,1,2}))\n    .add_additional(new DNSARR(\"a3.uri.example.com\", 300, {172,19,1,3}))\n    .add_additional(new DNSARR(\"n1.example.com\", 300, {172,19,0,1}))\n    .add_additional(new DNSARR(\"n2.example.com\", 300, {172,19,0,2}))\n    .add_additional(new DNSARR(\"n3.example.com\", 300, {172,19,0,3}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_uri_reply* uri0 = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_uri_reply(data.data(), (int)data.size(), &uri0));\n  ASSERT_NE(nullptr, uri0);\n  struct ares_uri_reply* uri = uri0;\n\n  EXPECT_EQ(\"a1.uri.example.com\", std::string(uri->uri));\n  EXPECT_EQ(0, uri->priority);\n  EXPECT_EQ(5, uri->weight);\n  EXPECT_EQ(600, uri->ttl);\n  EXPECT_NE(nullptr, uri->next);\n  uri = uri->next;\n\n  EXPECT_EQ(\"a2.uri.example.com\", std::string(uri->uri));\n  EXPECT_EQ(0, uri->priority);\n  EXPECT_EQ(5, uri->weight);\n  EXPECT_EQ(660, uri->ttl);\n  EXPECT_NE(nullptr, uri->next);\n  uri = uri->next;\n\n  EXPECT_EQ(\"a3.uri.example.com\", std::string(uri->uri));\n  EXPECT_EQ(0, uri->priority);\n  EXPECT_EQ(5, uri->weight);\n  EXPECT_EQ(720, uri->ttl);\n  EXPECT_EQ(nullptr, uri->next);\n\n  ares_free_data(uri0);\n}",
          "fn_code_pos": [
            [
              194,
              0
            ],
            [
              239,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseUriReplyErrors) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.abc.def.com\", T_URI))\n    .add_answer(new DNSUriRR(\"example.abc.def.com\", 180, 0, 10, \"example.abc.def.com\"));\n  std::vector<byte> data;\n  struct ares_uri_reply* uri = nullptr;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_uri_reply(data.data(), (int)data.size(), &uri));\n  pkt.add_question(new DNSQuestion(\"example.abc.def.com\", T_URI));\n\n#ifdef DISABLED\n  // Question != answer\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_URI));\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_uri_reply(data.data(), (int)data.size(), &uri));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_URI));\n#endif\n\n  // Two questions.\n  pkt.add_question(new DNSQuestion(\"example.abc.def.com\", T_URI));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_uri_reply(data.data(), (int)data.size(), &uri));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR));\n\n  // Wrong sort of answer.\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_uri_reply(data.data(), (int)data.size(), &uri));\n  EXPECT_EQ(nullptr, uri);\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSUriRR(\"example.abc.def.com\", 180, 0, 10, \"example.abc.def.com\"));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_uri_reply(data.data(), (int)data.size(), &uri));\n  pkt.add_answer(new DNSUriRR(\"example.abc.def.com\", 180, 0, 10, \"example.abc.def.com\"));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    int rc = ares_parse_uri_reply(data.data(), (int)len, &uri);\n    EXPECT_TRUE(rc == ARES_EBADRESP || rc == ARES_EBADNAME);\n  }\n}",
          "fn_code_pos": [
            [
              241,
              0
            ],
            [
              293,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseUriReplyAllocFail) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.abc.def.com\", T_URI))\n    .add_answer(new DNSCnameRR(\"example.com\", 300, \"c.example.com\"))\n    .add_answer(new DNSUriRR(\"example.abc.def.com\", 180, 0, 10, \"example.abc.def.com\"));\n  std::vector<byte> data = pkt.data();\n  struct ares_uri_reply* uri = nullptr;\n\n  for (int ii = 1; ii <= 5; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_uri_reply(data.data(), (int)data.size(), &uri)) << ii;\n  }\n}",
          "fn_code_pos": [
            [
              295,
              0
            ],
            [
              309,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            42,
            2
          ],
          [
            42,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            51,
            2
          ],
          [
            51,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            76,
            2
          ],
          [
            76,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            115,
            2
          ],
          [
            115,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            138,
            2
          ],
          [
            138,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            141,
            2
          ],
          [
            141,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            181,
            2
          ],
          [
            181,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            213,
            2
          ],
          [
            213,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            216,
            2
          ],
          [
            216,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            247,
            2
          ],
          [
            247,
            23
          ]
        ],
        [
          "struct ares_uri_reply",
          {},
          "",
          [
            302,
            2
          ],
          [
            302,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-parse-txt.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseTxtReplyOK) {\n  DNSPacket pkt;\n  std::string expected1 = \"txt1.example.com\";\n  std::string expected2a = \"txt2a\";\n  std::string expected2b(\"ABC\\0ABC\", 7);\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_MX))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected1}))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected2a, expected2b}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_txt_reply* txt = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  ASSERT_NE(nullptr, txt);\n  EXPECT_EQ(std::vector<byte>(expected1.data(), expected1.data() + expected1.size()),\n            std::vector<byte>(txt->txt, txt->txt + txt->length));\n\n  struct ares_txt_reply* txt2 = txt->next;\n  ASSERT_NE(nullptr, txt2);\n  std::vector<byte> rsp = std::vector<byte>(expected2a.data(), expected2a.data() + expected2a.size());\n  rsp.insert(rsp.end(), expected2b.data(), expected2b.data() + expected2b.size());\n  EXPECT_EQ(rsp,\n            std::vector<byte>(txt2->txt, txt2->txt + txt2->length));\n\n  ares_free_data(txt);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              59,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseTxtExtReplyOK) {\n  DNSPacket pkt;\n  std::string expected1 = \"txt1.example.com\";\n  std::string expected2a = \"txt2a\";\n  std::string expected2b(\"ABC\\0ABC\", 7);\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_MX))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected1}))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected2a, expected2b}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_txt_ext* txt = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_txt_reply_ext(data.data(), (int)data.size(), &txt));\n  ASSERT_NE(nullptr, txt);\n  EXPECT_EQ(std::vector<byte>(expected1.data(), expected1.data() + expected1.size()),\n            std::vector<byte>(txt->txt, txt->txt + txt->length));\n  EXPECT_EQ(1, txt->record_start);\n\n  struct ares_txt_ext* txt2 = txt->next;\n  ASSERT_NE(nullptr, txt2);\n  std::vector<byte> rsp = std::vector<byte>(expected2a.data(), expected2a.data() + expected2a.size());\n  rsp.insert(rsp.end(), expected2b.data(), expected2b.data() + expected2b.size());\n  EXPECT_EQ(rsp,\n            std::vector<byte>(txt2->txt, txt2->txt + txt2->length));\n  EXPECT_EQ(1, txt2->record_start);\n\n  ares_free_data(txt);\n}",
          "fn_code_pos": [
            [
              61,
              0
            ],
            [
              88,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseTxtMalformedReply1) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // type TXT\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x03,  // rdata length\n    0x12, 'a', 'b',  // invalid length\n  };\n\n  struct ares_txt_reply* txt = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  ASSERT_EQ(nullptr, txt);\n}",
          "fn_code_pos": [
            [
              90,
              0
            ],
            [
              119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseTxtMalformedReply2) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // type TXT\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // RR type\n    // truncated\n  };\n\n  struct ares_txt_reply* txt = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  ASSERT_EQ(nullptr, txt);\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              147,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseTxtMalformedReply3) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // type TXT\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x13,  // rdata length INVALID\n    0x02, 'a', 'b',\n  };\n\n  struct ares_txt_reply* txt = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  ASSERT_EQ(nullptr, txt);\n}",
          "fn_code_pos": [
            [
              149,
              0
            ],
            [
              178,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseTxtMalformedReply4) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x10,  // type TXT\n    0x00, // TRUNCATED\n  };\n\n  struct ares_txt_reply* txt = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  ASSERT_EQ(nullptr, txt);\n}",
          "fn_code_pos": [
            [
              180,
              0
            ],
            [
              200,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseTxtReplyErrors) {\n  DNSPacket pkt;\n  std::string expected1 = \"txt1.example.com\";\n  std::string expected2a = \"txt2a\";\n  std::string expected2b = \"txt2b\";\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_MX))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected1}))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected1}))\n    .add_answer(new DNSTxtRR(\"example.com\", 100, {expected2a, expected2b}));\n  std::vector<byte> data = pkt.data();\n  struct ares_txt_reply* txt = nullptr;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  txt = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  EXPECT_EQ(nullptr, txt);\n  pkt.add_question(new DNSQuestion(\"example.com\", T_MX));\n\n#ifdef DISABLED\n  // Question != answer\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_TXT));\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_TXT));\n#endif\n\n  // Two questions.\n  pkt.add_question(new DNSQuestion(\"example.com\", T_MX));\n  data = pkt.data();\n  txt = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  EXPECT_EQ(nullptr, txt);\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_MX));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  txt = nullptr;\n  EXPECT_EQ(ARES_ENODATA, ares_parse_txt_reply(data.data(), (int)data.size(), &txt));\n  EXPECT_EQ(nullptr, txt);\n  pkt.add_answer(new DNSTxtRR(\"example.com\", 100, {expected1}));\n\n  // Truncated packets.\n  for (size_t len = 1; len < data.size(); len++) {\n    txt = nullptr;\n    EXPECT_NE(ARES_SUCCESS, ares_parse_txt_reply(data.data(), (int)len, &txt));\n    EXPECT_EQ(nullptr, txt);\n  }\n}",
          "fn_code_pos": [
            [
              202,
              0
            ],
            [
              256,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseTxtReplyAllocFail) {\n  DNSPacket pkt;\n  std::string expected1 = \"txt1.example.com\";\n  std::string expected2a = \"txt2a\";\n  std::string expected2b = \"txt2b\";\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_MX))\n    .add_answer(new DNSCnameRR(\"example.com\", 300, \"c.example.com\"))\n    .add_answer(new DNSTxtRR(\"c.example.com\", 100, {expected1}))\n    .add_answer(new DNSTxtRR(\"c.example.com\", 100, {expected1}))\n    .add_answer(new DNSTxtRR(\"c.example.com\", 100, {expected2a, expected2b}));\n  std::vector<byte> data = pkt.data();\n  struct ares_txt_reply* txt = nullptr;\n\n  for (int ii = 1; ii <= 13; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_txt_reply(data.data(), (int)data.size(), &txt)) << ii;\n  }\n}",
          "fn_code_pos": [
            [
              258,
              0
            ],
            [
              277,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            45,
            2
          ],
          [
            45,
            23
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            51,
            2
          ],
          [
            51,
            23
          ]
        ],
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            72,
            2
          ],
          [
            72,
            21
          ]
        ],
        [
          "struct ares_txt_ext",
          {},
          "",
          [
            79,
            2
          ],
          [
            79,
            21
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            116,
            2
          ],
          [
            116,
            23
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            144,
            2
          ],
          [
            144,
            23
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            175,
            2
          ],
          [
            175,
            23
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            197,
            2
          ],
          [
            197,
            23
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            213,
            2
          ],
          [
            213,
            23
          ]
        ],
        [
          "struct ares_txt_reply",
          {},
          "",
          [
            270,
            2
          ],
          [
            270,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-parse-naptr.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseNaptrReplyOK) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_NAPTR))\n    .add_answer(new DNSNaptrRR(\"example.com\", 100,\n                               10, 20, \"SP\", \"service\", \"regexp\", \"replace\"))\n    .add_answer(new DNSNaptrRR(\"example.com\", 0x0010,\n                               11, 21, \"SP\", \"service2\", \"regexp2\", \"replace2\"));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_naptr_reply* naptr = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_naptr_reply(data.data(), (int)data.size(), &naptr));\n  ASSERT_NE(nullptr, naptr);\n  EXPECT_EQ(\"SP\", std::string((char*)naptr->flags));\n  EXPECT_EQ(\"service\", std::string((char*)naptr->service));\n  EXPECT_EQ(\"regexp\", std::string((char*)naptr->regexp));\n  EXPECT_EQ(\"replace\", std::string((char*)naptr->replacement));\n  EXPECT_EQ(10, naptr->order);\n  EXPECT_EQ(20, naptr->preference);\n\n  struct ares_naptr_reply* naptr2 = naptr->next;\n  ASSERT_NE(nullptr, naptr2);\n  EXPECT_EQ(\"SP\", std::string((char*)naptr2->flags));\n  EXPECT_EQ(\"service2\", std::string((char*)naptr2->service));\n  EXPECT_EQ(\"regexp2\", std::string((char*)naptr2->regexp));\n  EXPECT_EQ(\"replace2\", std::string((char*)naptr2->replacement));\n  EXPECT_EQ(11, naptr2->order);\n  EXPECT_EQ(21, naptr2->preference);\n  EXPECT_EQ(nullptr, naptr2->next);\n\n  ares_free_data(naptr);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseNaptrReplyErrors) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_NAPTR))\n    .add_answer(new DNSNaptrRR(\"example.com\", 100,\n                               10, 20, \"SP\", \"service\", \"regexp\", \"replace\"));\n  std::vector<byte> data;\n  struct ares_naptr_reply* naptr = nullptr;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_naptr_reply(data.data(), (int)data.size(), &naptr));\n  pkt.add_question(new DNSQuestion(\"example.com\", T_NAPTR));\n\n#ifdef DISABLED\n  // Question != answer\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_NAPTR));\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_naptr_reply(data.data(), (int)data.size(), &naptr));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_NAPTR));\n#endif\n\n  // Two questions\n  pkt.add_question(new DNSQuestion(\"example.com\", T_NAPTR));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_naptr_reply(data.data(), (int)data.size(), &naptr));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_NAPTR));\n\n  // Wrong sort of answer.\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_naptr_reply(data.data(), (int)data.size(), &naptr));\n  EXPECT_EQ(nullptr, naptr);\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSNaptrRR(\"example.com\", 100,\n                               10, 20, \"SP\", \"service\", \"regexp\", \"replace\"));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_naptr_reply(data.data(), (int)data.size(), &naptr));\n  pkt.add_answer(new DNSNaptrRR(\"example.com\", 100,\n                               10, 20, \"SP\", \"service\", \"regexp\", \"replace\"));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    int rc = ares_parse_naptr_reply(data.data(), (int)len, &naptr);\n    EXPECT_TRUE(rc == ARES_EBADRESP || rc == ARES_EBADNAME);\n  }\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseNaptrReplyTooShort) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x23,  // type NAPTR\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x23,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x01,  // rdata length\n    0x00,  // Too short: expect 2 x int16 and 3 x name (min 1 byte each)\n  };\n  struct ares_naptr_reply* naptr = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_naptr_reply(data.data(), (int)data.size(), &naptr));\n}",
          "fn_code_pos": [
            [
              124,
              0
            ],
            [
              151,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseNaptrReplyAllocFail) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_NAPTR))\n    .add_answer(new DNSNaptrRR(\"example.com\", 100,\n                               10, 20, \"SP\", \"service\", \"regexp\", \"replace\"))\n    .add_answer(new DNSNaptrRR(\"example.com\", 0x0010,\n                               11, 21, \"SP\", \"service2\", \"regexp2\", \"replace2\"));\n  std::vector<byte> data = pkt.data();\n  struct ares_naptr_reply* naptr = nullptr;\n\n  for (int ii = 1; ii <= 13; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_naptr_reply(data.data(), (int)data.size(), &naptr));\n  }\n}",
          "fn_code_pos": [
            [
              153,
              0
            ],
            [
              169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            44,
            2
          ],
          [
            44,
            25
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            54,
            2
          ],
          [
            54,
            25
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            74,
            2
          ],
          [
            74,
            25
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            149,
            2
          ],
          [
            149,
            25
          ]
        ],
        [
          "struct ares_naptr_reply",
          {},
          "",
          [
            162,
            2
          ],
          [
            162,
            25
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-mock.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_P(MockChannelTest, Basic) {\n  std::vector<byte> reply = {\n    0x00, 0x00,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // 1 question\n    0x00, 0x01,  // 1 answer RRs\n    0x00, 0x00,  // 0 authority RRs\n    0x00, 0x00,  // 0 additional RRs\n    // Question\n    0x03, 'w', 'w', 'w',\n    0x06, 'g', 'o', 'o', 'g', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    // Answer\n    0x03, 'w', 'w', 'w',\n    0x06, 'g', 'o', 'o', 'g', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    0x00, 0x00, 0x01, 0x00,  // TTL\n    0x00, 0x04,  // rdata length\n    0x01, 0x02, 0x03, 0x04\n  };\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReplyData(&server_, reply));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              42,
              0
            ],
            [
              80,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, GetHostByNameParallelLookups) {\n  DNSPacket rsp1;\n  rsp1.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp1));\n  DNSPacket rsp2;\n  rsp2.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {1, 2, 3, 4}));\n  ON_CALL(server_, OnRequest(\"www.example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp2));\n\n  HostResult result1;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result1);\n  HostResult result2;\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result2);\n  HostResult result3;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result3);\n  Process();\n  EXPECT_TRUE(result1.done_);\n  EXPECT_TRUE(result2.done_);\n  EXPECT_TRUE(result3.done_);\n  std::stringstream ss1;\n  ss1 << result1.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss1.str());\n  std::stringstream ss2;\n  ss2 << result2.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[1.2.3.4]}\", ss2.str());\n  std::stringstream ss3;\n  ss3 << result3.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss3.str());\n}",
          "fn_code_pos": [
            [
              83,
              0
            ],
            [
              116,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, TruncationRetry) {\n  DNSPacket rsptruncated;\n  rsptruncated.set_response().set_aa().set_tc()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  DNSPacket rspok;\n  rspok.set_response()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {1, 2, 3, 4}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsptruncated))\n    .WillOnce(SetReply(&server_, &rspok));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              119,
              0
            ],
            [
              137,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static int SocketConnectCallback(ares_socket_t fd, int type, void *data) {\n  int rc = *(int*)data;\n  if (verbose) std::cerr << \"SocketConnectCallback(\" << fd << \") invoked\" << std::endl;\n  sock_cb_count++;\n  return rc;\n}",
          "fn_code_pos": [
            [
              140,
              0
            ],
            [
              145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SocketConnectCallback",
            "parameters": {
              "fd": "ares_socket_t",
              "type": "int",
              "data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SockCallback) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n\n  // Get notified of new sockets\n  int rc = ARES_SUCCESS;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n\n  HostResult result;\n  sock_cb_count = 0;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_EQ(1, sock_cb_count);\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              147,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SockFailCallback) {\n  // Notification of new sockets gives an error.\n  int rc = -1;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n\n  HostResult result;\n  sock_cb_count = 0;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_LT(1, sock_cb_count);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECONNREFUSED, result.status_);\n}",
          "fn_code_pos": [
            [
              170,
              0
            ],
            [
              182,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static int SocketConfigureCallback(ares_socket_t fd, int type, void *data) {\n  int rc = *(int*)data;\n  if (verbose) std::cerr << \"SocketConfigureCallback(\" << fd << \") invoked\" << std::endl;\n  sock_config_cb_count++;\n  return rc;\n}",
          "fn_code_pos": [
            [
              185,
              0
            ],
            [
              190,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SocketConfigureCallback",
            "parameters": {
              "fd": "ares_socket_t",
              "type": "int",
              "data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SockConfigureCallback) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n\n  // Get notified of new sockets\n  int rc = ARES_SUCCESS;\n  ares_set_socket_configure_callback(channel_, SocketConfigureCallback, &rc);\n\n  HostResult result;\n  sock_config_cb_count = 0;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_EQ(1, sock_config_cb_count);\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              192,
              0
            ],
            [
              213,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SockConfigureFailCallback) {\n  // Notification of new sockets gives an error.\n  int rc = -1;\n  ares_set_socket_configure_callback(channel_, SocketConfigureCallback, &rc);\n\n  HostResult result;\n  sock_config_cb_count = 0;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_LT(1, sock_config_cb_count);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECONNREFUSED, result.status_);\n}",
          "fn_code_pos": [
            [
              215,
              0
            ],
            [
              227,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static void ServerStateCallback(const char *server_string,\n                                ares_bool_t success, int flags, void *data) {\n  // Increment overall success/failure counts appropriately.\n  if (verbose) std::cerr << \"ServerStateCallback(\"\n                         << server_string << \", \"\n                         << success       << \", \"\n                         << flags         << \") invoked\" << std::endl;\n  if (success == ARES_TRUE) server_state_cb_success_count++;\n  else server_state_cb_failure_count++;\n\n  // Check that the server string is as expected.\n  char *exp_server_string = *(char **)(data);\n  EXPECT_STREQ(exp_server_string, server_string);\n\n  // The callback should be invoked with either the UDP flag or the TCP flag,\n  // but not both.\n  ares_bool_t udp = (flags & ARES_SERV_STATE_UDP) ? ARES_TRUE: ARES_FALSE;\n  ares_bool_t tcp = (flags & ARES_SERV_STATE_TCP) ? ARES_TRUE: ARES_FALSE;\n  EXPECT_NE(udp, tcp);\n}",
          "fn_code_pos": [
            [
              233,
              0
            ],
            [
              252,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ServerStateCallback",
            "parameters": {
              "server_string": "char",
              "success": "ares_bool_t",
              "flags": "int",
              "data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, ServStateCallbackSuccess) {\n  // Set up the server response. The server returns successfully with an answer\n  // to the query.\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n\n  // Set up the server state callback. The channel used for this test has a\n  // single server configured.\n  char *exp_server_string = ares_get_servers_csv(channel_);\n  ares_set_server_state_callback(channel_, ServerStateCallback,\n                                 &exp_server_string);\n\n  // Perform the hostname lookup. Expect 1 successful query to the server.\n  HostResult result;\n  server_state_cb_success_count = 0;\n  server_state_cb_failure_count = 0;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback,\n                     &result);\n  Process();\n  EXPECT_EQ(1, server_state_cb_success_count);\n  EXPECT_EQ(0, server_state_cb_failure_count);\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n\n  ares_free_string(exp_server_string);\n}",
          "fn_code_pos": [
            [
              254,
              0
            ],
            [
              285,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, ServStateCallbackFailure) {\n  // Set up the server response. The server always returns SERVFAIL.\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(SERVFAIL);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  // Set up the server state callback. The channel used for this test has a\n  // single server configured.\n  char *exp_server_string = ares_get_servers_csv(channel_);\n  ares_set_server_state_callback(channel_, ServerStateCallback,\n                                 &exp_server_string);\n\n  // Perform the hostname lookup. Expect 3 failed queries to the server (due to\n  // retries).\n  HostResult result;\n  server_state_cb_success_count = 0;\n  server_state_cb_failure_count = 0;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback,\n                     &result);\n  Process();\n  EXPECT_EQ(0, server_state_cb_success_count);\n  EXPECT_EQ(3, server_state_cb_failure_count);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ESERVFAIL, result.status_);\n\n  ares_free_string(exp_server_string);\n}",
          "fn_code_pos": [
            [
              287,
              0
            ],
            [
              316,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, ServStateCallbackRecover) {\n  // Set up the server response. The server initially times out, but then\n  // returns successfully (with NXDOMAIN) on the first retry.\n  std::vector<byte> nothing;\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(NXDOMAIN);\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReplyData(&server_, nothing))\n    .WillOnce(SetReply(&server_, &rsp));\n\n  // Set up the server state callback. The channel used for this test has a\n  // single server configured.\n  char *exp_server_string = ares_get_servers_csv(channel_);\n  ares_set_server_state_callback(channel_, ServerStateCallback,\n                                 &exp_server_string);\n\n  // Perform the hostname lookup. Expect 1 failed query and 1 successful query\n  // to the server.\n  HostResult result;\n  server_state_cb_success_count = 0;\n  server_state_cb_failure_count = 0;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback,\n                     &result);\n  Process();\n  EXPECT_EQ(1, server_state_cb_success_count);\n  EXPECT_EQ(1, server_state_cb_failure_count);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTFOUND, result.status_);\n\n  ares_free_string(exp_server_string);\n}",
          "fn_code_pos": [
            [
              318,
              0
            ],
            [
              350,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, ReInit) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  EXPECT_EQ(ARES_SUCCESS, ares_reinit(channel_));\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              352,
              0
            ],
            [
              368,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockUDPMaxQueriesTest()\n    : MockChannelOptsTest(1, GetParam(), false,\n                          FillOptions(&opts_),\n                          ARES_OPT_UDP_MAX_QUERIES) {}",
          "fn_code_pos": [
            [
              377,
              2
            ],
            [
              380,
              54
            ]
          ],
          "class_code": "b78f91be9797bc2b3cfe68aac1dc3fb9f35a0bfbc4218065340c3d750d5cc5c2",
          "class_node_pos": [
            [
              373,
              0
            ],
            [
              388,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockUDPMaxQueriesTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->udp_max_queries = MAXUDPQUERIES_LIMIT;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              381,
              2
            ],
            [
              385,
              3
            ]
          ],
          "class_code": "b78f91be9797bc2b3cfe68aac1dc3fb9f35a0bfbc4218065340c3d750d5cc5c2",
          "class_node_pos": [
            [
              373,
              0
            ],
            [
              388,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPMaxQueriesTest, GetHostByNameParallelLookups) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  // Get notified of new sockets so we can validate how many are created\n  int rc = ARES_SUCCESS;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n  sock_cb_count = 0;\n\n  HostResult result[MAXUDPQUERIES_TOTAL];\n  for (size_t i=0; i<MAXUDPQUERIES_TOTAL; i++) {\n    ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result[i]);\n  }\n\n  Process();\n\n  EXPECT_EQ(MAXUDPQUERIES_TOTAL / MAXUDPQUERIES_LIMIT, sock_cb_count);\n\n  for (size_t i=0; i<MAXUDPQUERIES_TOTAL; i++) {\n    std::stringstream ss;\n    EXPECT_TRUE(result[i].done_);\n    ss << result[i].host_;\n    EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }\n}",
          "fn_code_pos": [
            [
              390,
              0
            ],
            [
              418,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CacheQueriesTest()\n    : MockChannelOptsTest(1, GetParam(), false,\n                          FillOptions(&opts_),\n                          ARES_OPT_QUERY_CACHE) {}",
          "fn_code_pos": [
            [
              424,
              2
            ],
            [
              427,
              50
            ]
          ],
          "class_code": "6f0f0e91bdad3c258d86d50bfbe14eb3620f740fac846bde19e5ed11bd981634",
          "class_node_pos": [
            [
              420,
              0
            ],
            [
              435,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CacheQueriesTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->qcache_max_ttl = 3600;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              428,
              2
            ],
            [
              432,
              3
            ]
          ],
          "class_code": "6f0f0e91bdad3c258d86d50bfbe14eb3620f740fac846bde19e5ed11bd981634",
          "class_node_pos": [
            [
              420,
              0
            ],
            [
              435,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(CacheQueriesTest, GetHostByNameCache) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  // Get notified of new sockets so we can validate how many are created\n  int rc = ARES_SUCCESS;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n  sock_cb_count = 0;\n\n  HostResult result1;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result1);\n  Process();\n\n  std::stringstream ss1;\n  EXPECT_TRUE(result1.done_);\n  ss1 << result1.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss1.str());\n\n  /* Run again, should return cached result */\n  HostResult result2;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result2);\n  Process();\n\n  std::stringstream ss2;\n  EXPECT_TRUE(result2.done_);\n  ss2 << result2.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss2.str());\n\n  EXPECT_EQ(1, sock_cb_count);\n}",
          "fn_code_pos": [
            [
              437,
              0
            ],
            [
              470,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTest, GetHostByNameParallelLookups) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  // Get notified of new sockets so we can validate how many are created\n  int rc = ARES_SUCCESS;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n  sock_cb_count = 0;\n\n  HostResult result[TCPPARALLELLOOKUPS];\n  for (size_t i=0; i<TCPPARALLELLOOKUPS; i++) {\n    ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result[i]);\n  }\n\n  Process();\n\n  EXPECT_EQ(1, sock_cb_count);\n\n  for (size_t i=0; i<TCPPARALLELLOOKUPS; i++) {\n    std::stringstream ss;\n    EXPECT_TRUE(result[i].done_);\n    ss << result[i].host_;\n    EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }\n}",
          "fn_code_pos": [
            [
              473,
              0
            ],
            [
              501,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTest, MalformedResponse) {\n  std::vector<byte> one = {0x00};\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReplyData(&server_, one));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ETIMEOUT, result.status_);\n}",
          "fn_code_pos": [
            [
              503,
              0
            ],
            [
              513,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTest, FormErrResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(FORMERR);\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EFORMERR, result.status_);\n}",
          "fn_code_pos": [
            [
              515,
              0
            ],
            [
              527,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTest, ServFailResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(SERVFAIL);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ESERVFAIL, result.status_);\n}",
          "fn_code_pos": [
            [
              529,
              0
            ],
            [
              541,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTest, NotImplResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(NOTIMP);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              543,
              0
            ],
            [
              555,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTest, RefusedResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(REFUSED);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EREFUSED, result.status_);\n}",
          "fn_code_pos": [
            [
              557,
              0
            ],
            [
              569,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTest, YXDomainResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(YXDOMAIN);\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENODATA, result.status_);\n}",
          "fn_code_pos": [
            [
              571,
              0
            ],
            [
              583,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockExtraOptsTest()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second,\n                          FillOptions(&opts_),\n                          ARES_OPT_SOCK_SNDBUF|ARES_OPT_SOCK_RCVBUF) {}",
          "fn_code_pos": [
            [
              589,
              2
            ],
            [
              592,
              71
            ]
          ],
          "class_code": "4d34171b52d6168049818ed794a30c367995314aefe592bad8ac06259f4a2e1b",
          "class_node_pos": [
            [
              585,
              0
            ],
            [
              602,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockExtraOptsTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    // Set a few options that affect socket communications\n    opts->socket_send_buffer_size = 514;\n    opts->socket_receive_buffer_size = 514;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              593,
              2
            ],
            [
              599,
              3
            ]
          ],
          "class_code": "4d34171b52d6168049818ed794a30c367995314aefe592bad8ac06259f4a2e1b",
          "class_node_pos": [
            [
              585,
              0
            ],
            [
              602,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockExtraOptsTest, SimpleQuery) {\n  ares_set_local_ip4(channel_, 0x7F000001);\n  byte addr6[16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};\n  ares_set_local_ip6(channel_, addr6);\n  ares_set_local_dev(channel_, \"dummy\");\n\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              604,
              0
            ],
            [
              625,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockFlagsChannelOptsTest(int flags)\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second,\n                          FillOptions(&opts_, flags), ARES_OPT_FLAGS) {}",
          "fn_code_pos": [
            [
              631,
              2
            ],
            [
              633,
              72
            ]
          ],
          "class_code": "86ff80a0a45ae010a1939687ce5120d66b8de18887e91b7f4a59c9ff5a3d9d79",
          "class_node_pos": [
            [
              627,
              0
            ],
            [
              641,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockFlagsChannelOptsTest",
            "parameters": {
              "flags": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts, int flags) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = flags;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              634,
              2
            ],
            [
              638,
              3
            ]
          ],
          "class_code": "86ff80a0a45ae010a1939687ce5120d66b8de18887e91b7f4a59c9ff5a3d9d79",
          "class_node_pos": [
            [
              627,
              0
            ],
            [
              641,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options",
              "flags": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "MockNoCheckRespChannelTest() : MockFlagsChannelOptsTest(ARES_FLAG_NOCHECKRESP) {}",
          "fn_code_pos": [
            [
              645,
              2
            ],
            [
              645,
              83
            ]
          ],
          "class_code": "e4acaa4e65fb26b4a2f5446e475cd09090d789045f1f025ba5402c4f3efeef4c",
          "class_node_pos": [
            [
              643,
              0
            ],
            [
              646,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockNoCheckRespChannelTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockNoCheckRespChannelTest, ServFailResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(SERVFAIL);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ESERVFAIL, result.status_);\n}",
          "fn_code_pos": [
            [
              648,
              0
            ],
            [
              660,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockNoCheckRespChannelTest, NotImplResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(NOTIMP);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              662,
              0
            ],
            [
              674,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockNoCheckRespChannelTest, RefusedResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(REFUSED);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EREFUSED, result.status_);\n}",
          "fn_code_pos": [
            [
              676,
              0
            ],
            [
              688,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockEDNSChannelTest() : MockFlagsChannelOptsTest(ARES_FLAG_EDNS) {}",
          "fn_code_pos": [
            [
              692,
              2
            ],
            [
              692,
              69
            ]
          ],
          "class_code": "578e1e23b823c1565296c9cb13adf8dabc2015436f4fc8d77a7b2a8e6f151add",
          "class_node_pos": [
            [
              690,
              0
            ],
            [
              693,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockEDNSChannelTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEDNSChannelTest, RetryWithoutEDNS) {\n  DNSPacket rspfail;\n  rspfail.set_response().set_aa().set_rcode(FORMERR)\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  DNSPacket rspok;\n  rspok.set_response()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {1, 2, 3, 4}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rspfail))\n    .WillOnce(SetReply(&server_, &rspok));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              695,
              0
            ],
            [
              713,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SearchDomains) {\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket yesthird;\n  yesthird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A))\n    .add_answer(new DNSARR(\"www.third.gov\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &yesthird));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.third.gov' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              715,
              0
            ],
            [
              740,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, SearchDomainsWithResentReply) {\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  EXPECT_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillOnce(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  EXPECT_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillOnce(SetReply(&server_, &nosecond));\n  DNSPacket yesthird;\n  yesthird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A))\n    .add_answer(new DNSARR(\"www.third.gov\", 0x0200, {2, 3, 4, 5}));\n  // Before sending the real answer, resend an earlier reply\n  EXPECT_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillOnce(DoAll(SetReply(&server_, &nofirst),\n                    SetReplyQID(&server_, 123)))\n    .WillOnce(DoAll(SetReply(&server_, &yesthird),\n                    SetReplyQID(&server_, -1)));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.third.gov' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              743,
              0
            ],
            [
              772,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SearchDomainsBare) {\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket nothird;\n  nothird.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &nothird));\n  DNSPacket yesbare;\n  yesbare.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www\", T_A))\n    .add_answer(new DNSARR(\"www\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www\", T_A))\n    .WillByDefault(SetReply(&server_, &yesbare));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              774,
              0
            ],
            [
              804,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SearchNoDataThenSuccess) {\n  // First two search domains recognize the name but have no A records.\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket yesthird;\n  yesthird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A))\n    .add_answer(new DNSARR(\"www.third.gov\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &yesthird));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.third.gov' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              806,
              0
            ],
            [
              832,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SearchNoDataThenNoDataBare) {\n  // First two search domains recognize the name but have no A records.\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket nothird;\n  nothird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &nothird));\n  DNSPacket nobare;\n  nobare.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www\", T_A));\n  ON_CALL(server_, OnRequest(\"www\", T_A))\n    .WillByDefault(SetReply(&server_, &nobare));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENODATA, result.status_);\n}",
          "fn_code_pos": [
            [
              834,
              0
            ],
            [
              862,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SearchNoDataThenFail) {\n  // First two search domains recognize the name but have no A records.\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket nothird;\n  nothird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &nothird));\n  DNSPacket nobare;\n  nobare.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www\", T_A));\n  ON_CALL(server_, OnRequest(\"www\", T_A))\n    .WillByDefault(SetReply(&server_, &nobare));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENODATA, result.status_);\n}",
          "fn_code_pos": [
            [
              864,
              0
            ],
            [
              892,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SearchAllocFailure) {\n  SearchResult result;\n  SetAllocFail(1);\n  ares_search(channel_, \"fully.qualified.\", C_IN, T_A, SearchCallback, &result);\n  /* Already done */\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOMEM, result.status_);\n}",
          "fn_code_pos": [
            [
              894,
              0
            ],
            [
              901,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SearchHighNdots) {\n  DNSPacket nobare;\n  nobare.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"a.b.c.w.w.w\", T_A));\n  ON_CALL(server_, OnRequest(\"a.b.c.w.w.w\", T_A))\n    .WillByDefault(SetReply(&server_, &nobare));\n  DNSPacket yesfirst;\n  yesfirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"a.b.c.w.w.w.first.com\", T_A))\n    .add_answer(new DNSARR(\"a.b.c.w.w.w.first.com\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"a.b.c.w.w.w.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &yesfirst));\n\n  SearchResult result;\n  ares_search(channel_, \"a.b.c.w.w.w\", C_IN, T_A, SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  std::stringstream ss;\n  ss << PacketToString(result.data_);\n  EXPECT_EQ(\"RSP QRY AA NOERROR Q:{'a.b.c.w.w.w.first.com' IN A} \"\n            \"A:{'a.b.c.w.w.w.first.com' IN A TTL=512 2.3.4.5}\",\n            ss.str());\n}",
          "fn_code_pos": [
            [
              903,
              0
            ],
            [
              926,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEDNSChannelTest, SearchOptVal) {\n  /* Define the OPT RR options code and value to use. */\n  unsigned short opt_opt = 3;\n  unsigned char opt_val[] = { 'c', '-', 'a', 'r', 'e', 's' };\n\n  /* Set up the expected request and reply on the mock server for the first,\n   * second and third domains. The expected requests contain the OPT RR options\n   * value defined above.\n   */\n  std::string nofirst_req = \"REQ QRY RD  Q:{'example.first.com' IN A} \"\n    \"ADD:{'' MAXUDP=1232 OPT RCODE2=0 \"\n    \"0003\"  // opt_opt\n    \"0006\"  // length of opt_val\n    \"632d61726573\"  // opt_val in hex\n    \"}\";\n  DNSPacket nofirst_rep;\n  nofirst_rep.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"example.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"example.first.com\", T_A))\n    .WillByDefault(SetReplyExpRequest(&server_, &nofirst_rep, nofirst_req));\n\n  std::string nosecond_req = \"REQ QRY RD  Q:{'example.second.org' IN A} \"\n    \"ADD:{'' MAXUDP=1232 OPT RCODE2=0 \"\n    \"0003\"  // opt_opt\n    \"0006\"  // length of opt_val\n    \"632d61726573\"  // opt_val in hex\n    \"}\";\n  DNSPacket nosecond_rep;\n  nosecond_rep.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"example.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"example.second.org\", T_A))\n    .WillByDefault(SetReplyExpRequest(&server_, &nosecond_rep, nosecond_req));\n\n  std::string nothird_req = \"REQ QRY RD  Q:{'example.third.gov' IN A} \"\n    \"ADD:{'' MAXUDP=1232 OPT RCODE2=0 \"\n    \"0003\"  // opt_opt\n    \"0006\"  // length of opt_val\n    \"632d61726573\"  // opt_val in hex\n    \"}\";\n  DNSPacket nothird_rep;\n  nothird_rep.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"example.third.gov\", T_A));\n  ON_CALL(server_, OnRequest(\"example.third.gov\", T_A))\n    .WillByDefault(SetReplyExpRequest(&server_, &nothird_rep, nothird_req));\n\n  /* Set up the expected request and reply on the mock server for the bare\n   * domain. The expected request contains the OPT RR options value defined\n   * above.\n   */\n  std::string yesbare_req = \"REQ QRY RD  Q:{'example' IN A} \"\n    \"ADD:{'' MAXUDP=1232 OPT RCODE2=0 \"\n    \"0003\"  // opt_opt\n    \"0006\"  // length of opt_val\n    \"632d61726573\"  // opt_val in hex\n    \"}\";\n  DNSPacket yesbare_rep;\n  yesbare_rep.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example\", T_A))\n    .add_answer(new DNSARR(\"example\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"example\", T_A))\n    .WillByDefault(SetReplyExpRequest(&server_, &yesbare_rep, yesbare_req));\n\n  /* Construct the DNS record to search. */\n  ares_dns_record_t *dnsrec = NULL;\n  ares_dns_rr_t *rr = NULL;\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_create(&dnsrec, 0, ARES_FLAG_RD, ARES_OPCODE_QUERY,\n      ARES_RCODE_NOERROR));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_query_add(dnsrec, \"example\", (ares_dns_rec_type_t)T_A,\n      (ares_dns_class_t)C_IN));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL, \"\",\n      ARES_REC_TYPE_OPT, ARES_CLASS_IN, 0));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_OPT_UDP_SIZE, 1232));\n  EXPECT_EQ(ARES_SUCCESS, ares_dns_rr_set_u8(rr, ARES_RR_OPT_VERSION, 0));\n  EXPECT_EQ(ARES_SUCCESS, ares_dns_rr_set_u16(rr, ARES_RR_OPT_FLAGS, 0));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_opt(rr, ARES_RR_OPT_OPTIONS, opt_opt, opt_val,\n      sizeof(opt_val)));\n\n  /* Perform the search. Check that it succeeds with the expected response. */\n  SearchResult result;\n  ares_search_dnsrec(channel_, dnsrec, SearchCallbackDnsRec, &result);\n  ares_dns_record_destroy(dnsrec);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  std::stringstream ss;\n  ss << PacketToString(result.data_);\n  EXPECT_EQ(\"RSP QRY AA NOERROR Q:{'example' IN A} \"\n            \"A:{'example' IN A TTL=512 2.3.4.5}\",\n            ss.str());\n}",
          "fn_code_pos": [
            [
              930,
              0
            ],
            [
              1024,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, V4WorksV6Timeout) {\n  std::vector<byte> nothing;\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &reply));\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_AAAA))\n    .WillByDefault(SetReplyData(&server_, nothing));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(1, result.timeouts_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1026,
              0
            ],
            [
              1047,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, PartialQueryCancel) {\n  std::vector<byte> nothing;\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &reply));\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_AAAA))\n    .WillByDefault(SetReplyData(&server_, nothing));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_UNSPEC, HostCallback, &result);\n  // After 100ms, issues ares_cancel(), this should be enough time for the A\n  // record reply, but before the timeout on the AAAA record.\n  Process(100);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECANCELLED, result.status_);\n}",
          "fn_code_pos": [
            [
              1051,
              0
            ],
            [
              1071,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, UnspecifiedFamilyV6) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x21, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"example.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  // Default to IPv6 when both are available.\n  EXPECT_EQ(\"{'example.com' aliases=[] addrs=[2121:0000:0000:0000:0000:0000:0000:0303]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1074,
              0
            ],
            [
              1098,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, UnspecifiedFamilyV4) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"example.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1100,
              0
            ],
            [
              1120,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, UnspecifiedFamilyNoData) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSCnameRR(\"example.com\", 100, \"elsewhere.com\"));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"example.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'' aliases=[] addrs=[]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1122,
              0
            ],
            [
              1142,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, UnspecifiedFamilyCname6A4) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSCnameRR(\"example.com\", 100, \"elsewhere.com\"));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {1, 2, 3, 4}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"example.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'example.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1144,
              0
            ],
            [
              1165,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, ExplicitIP) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"1.2.3.4\", AF_INET, HostCallback, &result);\n  EXPECT_TRUE(result.done_);  // Immediate return\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'1.2.3.4' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1167,
              0
            ],
            [
              1175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, ExplicitIPAllocFail) {\n  HostResult result;\n  SetAllocSizeFail(strlen(\"1.2.3.4\") + 1);\n  ares_gethostbyname(channel_, \"1.2.3.4\", AF_INET, HostCallback, &result);\n  EXPECT_TRUE(result.done_);  // Immediate return\n  EXPECT_EQ(ARES_ENOMEM, result.status_);\n}",
          "fn_code_pos": [
            [
              1177,
              0
            ],
            [
              1183,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SortListV4) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {22, 23, 24, 25}))\n    .add_answer(new DNSARR(\"example.com\", 100, {12, 13, 14, 15}))\n    .add_answer(new DNSARR(\"example.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  {\n    EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"12.13.0.0/255.255.0.0 1234::5678\"));\n    HostResult result;\n    ares_gethostbyname(channel_, \"example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'example.com' aliases=[] addrs=[12.13.14.15, 22.23.24.25, 2.3.4.5]}\", ss.str());\n  }\n  {\n    EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"2.3.0.0/16 130.140.150.160/26\"));\n    HostResult result;\n    ares_gethostbyname(channel_, \"example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'example.com' aliases=[] addrs=[2.3.4.5, 22.23.24.25, 12.13.14.15]}\", ss.str());\n  }\n  struct ares_options options;\n  memset(&options, 0, sizeof(options));\n  int optmask = 0;\n  EXPECT_EQ(ARES_SUCCESS, ares_save_options(channel_, &options, &optmask));\n  EXPECT_TRUE((optmask & ARES_OPT_SORTLIST) == ARES_OPT_SORTLIST);\n  ares_destroy_options(&options);\n}",
          "fn_code_pos": [
            [
              1185,
              0
            ],
            [
              1221,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, SortListV6) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02}))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x21, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  {\n    ares_set_sortlist(channel_, \"1111::/16 2.3.0.0/255.255.0.0\");\n    HostResult result;\n    ares_gethostbyname(channel_, \"example.com.\", AF_INET6, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'example.com' aliases=[] addrs=[1111:0000:0000:0000:0000:0000:0000:0202, \"\n              \"2121:0000:0000:0000:0000:0000:0000:0303]}\", ss.str());\n  }\n  {\n    ares_set_sortlist(channel_, \"2121::/8\");\n    HostResult result;\n    ares_gethostbyname(channel_, \"example.com.\", AF_INET6, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'example.com' aliases=[] addrs=[2121:0000:0000:0000:0000:0000:0000:0303, \"\n              \"1111:0000:0000:0000:0000:0000:0000:0202]}\", ss.str());\n  }\n}",
          "fn_code_pos": [
            [
              1223,
              0
            ],
            [
              1258,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, SearchDomainsAllocFail) {\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket yesthird;\n  yesthird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A))\n    .add_answer(new DNSARR(\"www.third.gov\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &yesthird));\n\n  // Fail a variety of different memory allocations, and confirm\n  // that the operation either fails with ENOMEM or succeeds\n  // with the expected result.\n  const int kCount = 34;\n  HostResult results[kCount];\n  for (int ii = 1; ii <= kCount; ii++) {\n    HostResult* result = &(results[ii - 1]);\n    ClearFails();\n    SetAllocFail(ii);\n    ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, result);\n    Process();\n    EXPECT_TRUE(result->done_);\n    if (result->status_ == ARES_SUCCESS) {\n      std::stringstream ss;\n      ss << result->host_;\n      EXPECT_EQ(\"{'www.third.gov' aliases=[] addrs=[2.3.4.5]}\", ss.str()) << \" failed alloc #\" << ii;\n      if (verbose) std::cerr << \"Succeeded despite failure of alloc #\" << ii << std::endl;\n    }\n  }\n\n  // Explicitly destroy the channel now, so that the HostResult objects\n  // are still valid (in case any pending work refers to them).\n  ares_destroy(channel_);\n  channel_ = nullptr;\n}",
          "fn_code_pos": [
            [
              1261,
              0
            ],
            [
              1303,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, Resend) {\n  std::vector<byte> nothing;\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReplyData(&server_, nothing))\n    .WillOnce(SetReplyData(&server_, nothing))\n    .WillOnce(SetReply(&server_, &reply));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(2, result.timeouts_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1306,
              0
            ],
            [
              1326,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, CancelImmediate) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  ares_cancel(channel_);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECANCELLED, result.status_);\n  EXPECT_EQ(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              1328,
              0
            ],
            [
              1335,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, CancelImmediateGetHostByAddr) {\n  HostResult result;\n  struct in_addr addr;\n  addr.s_addr = htonl(0x08080808);\n\n  ares_gethostbyaddr(channel_, &addr, sizeof(addr), AF_INET, HostCallback, &result);\n  ares_cancel(channel_);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECANCELLED, result.status_);\n  EXPECT_EQ(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              1337,
              0
            ],
            [
              1347,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTest, CancelLater) {\n  std::vector<byte> nothing;\n\n  // On second request, cancel the channel.\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReplyData(&server_, nothing))\n    .WillOnce(CancelChannel(&server_, channel_));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECANCELLED, result.status_);\n  EXPECT_EQ(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              1350,
              0
            ],
            [
              1364,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, DisconnectFirstAttempt) {\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  // On second request, cancel the channel.\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(Disconnect(&server_))\n    .WillOnce(SetReply(&server_, &reply));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1366,
              0
            ],
            [
              1384,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, GetHostByNameDestroyAbsolute) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n\n  ares_destroy(channel_);\n  channel_ = nullptr;\n\n  EXPECT_TRUE(result.done_);  // Synchronous\n  EXPECT_EQ(ARES_EDESTRUCTION, result.status_);\n  EXPECT_EQ(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              1386,
              0
            ],
            [
              1396,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, GetHostByNameDestroyRelative) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n\n  ares_destroy(channel_);\n  channel_ = nullptr;\n\n  EXPECT_TRUE(result.done_);  // Synchronous\n  EXPECT_EQ(ARES_EDESTRUCTION, result.status_);\n  EXPECT_EQ(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              1398,
              0
            ],
            [
              1408,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, GetHostByNameCNAMENoData) {\n  DNSPacket response;\n  response.set_response().set_aa()\n    .add_question(new DNSQuestion(\"cname.first.com\", T_A))\n    .add_answer(new DNSCnameRR(\"cname.first.com\", 100, \"a.first.com\"));\n  ON_CALL(server_, OnRequest(\"cname.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &response));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"cname.first.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENODATA, result.status_);\n}",
          "fn_code_pos": [
            [
              1410,
              0
            ],
            [
              1423,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, GetHostByAddrDestroy) {\n  unsigned char gdns_addr4[4] = {0x08, 0x08, 0x08, 0x08};\n  HostResult result;\n  ares_gethostbyaddr(channel_, gdns_addr4, sizeof(gdns_addr4), AF_INET, HostCallback, &result);\n\n  ares_destroy(channel_);\n  channel_ = nullptr;\n\n  EXPECT_TRUE(result.done_);  // Synchronous\n  EXPECT_EQ(ARES_EDESTRUCTION, result.status_);\n  EXPECT_EQ(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              1425,
              0
            ],
            [
              1436,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, HostAlias) {\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &reply));\n\n  TempFile aliases(\"\\n\\n# www commentedout\\nwww www.google.com\\n\");\n  EnvValue with_env(\"HOSTALIASES\", aliases.filename());\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1439,
              0
            ],
            [
              1457,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, HostAliasMissing) {\n  DNSPacket yesfirst;\n  yesfirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A))\n    .add_answer(new DNSARR(\"www.first.com\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &yesfirst));\n\n  TempFile aliases(\"\\n\\n# www commentedout\\nww www.google.com\\n\");\n  EnvValue with_env(\"HOSTALIASES\", aliases.filename());\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.first.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1459,
              0
            ],
            [
              1476,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, HostAliasMissingFile) {\n  DNSPacket yesfirst;\n  yesfirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A))\n    .add_answer(new DNSARR(\"www.first.com\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &yesfirst));\n\n  EnvValue with_env(\"HOSTALIASES\", \"bogus.mcfile\");\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.first.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1478,
              0
            ],
            [
              1494,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTest, HostAliasUnreadable) {\n  TempFile aliases(\"www www.google.com\\n\");\n  EXPECT_EQ(chmod(aliases.filename(), 0), 0);\n\n  /* Perform OS sanity checks.  We are observing on Debian after the chmod(fn, 0)\n   * that we are still able to fopen() the file which is unexpected.  Skip the\n   * test if we observe this behavior */\n  struct stat st;\n  EXPECT_EQ(stat(aliases.filename(), &st), 0);\n  EXPECT_EQ(st.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO), 0);\n  FILE *fp = fopen(aliases.filename(), \"r\");\n  if (fp != NULL) {\n    if (verbose) std::cerr << \"Skipping Test due to OS incompatibility (open file caching)\" << std::endl;\n    fclose(fp);\n    return;\n  }\n\n  EnvValue with_env(\"HOSTALIASES\", aliases.filename());\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EFILE, result.status_);\n  chmod(aliases.filename(), 0777);\n}",
          "fn_code_pos": [
            [
              1496,
              0
            ],
            [
              1521,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockMultiServerChannelTest(ares_options *opts, int optmask)\n    : MockChannelOptsTest(3, GetParam().first, GetParam().second, opts, optmask) {}",
          "fn_code_pos": [
            [
              1528,
              2
            ],
            [
              1529,
              83
            ]
          ],
          "class_code": "b302ecb29ac8a11e8290b79b0e0433e65ab628b64acd919fd0b23040c0b013ae",
          "class_node_pos": [
            [
              1524,
              0
            ],
            [
              1539,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockMultiServerChannelTest",
            "parameters": {
              "opts": "ares_options",
              "optmask": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void CheckExample() {\n    HostResult result;\n    ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }",
          "fn_code_pos": [
            [
              1530,
              2
            ],
            [
              1538,
              3
            ]
          ],
          "class_code": "b302ecb29ac8a11e8290b79b0e0433e65ab628b64acd919fd0b23040c0b013ae",
          "class_node_pos": [
            [
              1524,
              0
            ],
            [
              1539,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckExample",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "NoRotateMultiMockTest() : MockMultiServerChannelTest(nullptr, ARES_OPT_NOROTATE) {}",
          "fn_code_pos": [
            [
              1543,
              2
            ],
            [
              1543,
              85
            ]
          ],
          "class_code": "40284f315f94be019493562b35da1236e82397d3ac755e9b46af08f6f92b851f",
          "class_node_pos": [
            [
              1541,
              0
            ],
            [
              1544,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "NoRotateMultiMockTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ServerFailoverOptsMultiMockTest()\n    : MockMultiServerChannelTest(FillOptions(&opts_),\n                                 ARES_OPT_SERVER_FAILOVER | ARES_OPT_NOROTATE) {}",
          "fn_code_pos": [
            [
              1548,
              2
            ],
            [
              1550,
              81
            ]
          ],
          "class_code": "f850e01d8abb43743d9788dab2d38395fe4556b81ca515a75c0fe7c3f72bd86a",
          "class_node_pos": [
            [
              1546,
              0
            ],
            [
              1559,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ServerFailoverOptsMultiMockTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options *opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->server_failover_opts.retry_chance = 1;\n    opts->server_failover_opts.retry_delay = 250;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              1551,
              2
            ],
            [
              1556,
              3
            ]
          ],
          "class_code": "f850e01d8abb43743d9788dab2d38395fe4556b81ca515a75c0fe7c3f72bd86a",
          "class_node_pos": [
            [
              1546,
              0
            ],
            [
              1559,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(NoRotateMultiMockTest, ThirdServer) {\n  struct ares_options opts;\n  int optmask = 0;\n  memset(&opts, 0, sizeof(opts));\n  EXPECT_EQ(ARES_SUCCESS, ares_save_options(channel_, &opts, &optmask));\n  EXPECT_EQ(ARES_OPT_NOROTATE, (optmask & ARES_OPT_NOROTATE));\n  ares_destroy_options(&opts);\n\n  DNSPacket servfailrsp;\n  servfailrsp.set_response().set_aa().set_rcode(SERVFAIL)\n    .add_question(new DNSQuestion(\"www.example.com\", T_A));\n  DNSPacket notimplrsp;\n  notimplrsp.set_response().set_aa().set_rcode(NOTIMP)\n    .add_question(new DNSQuestion(\"www.example.com\", T_A));\n  DNSPacket okrsp;\n  okrsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {2,3,4,5}));\n\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp));\n  CheckExample();\n\n  // Second time around, still starts from server [2], as [0] and [1] both\n  // recorded failures\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n\n  // Third time around, server order is [1] (f0), [2] (f1), [0] (f2), which\n  // means [1] will get called twice in a row as after the first call\n  // order will be  [1] (f1), [2] (f1), [0] (f2) since sort order is\n  // (failure count, index)\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &servfailrsp))\n    .WillOnce(SetReply(servers_[1].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  CheckExample();\n}",
          "fn_code_pos": [
            [
              1561,
              0
            ],
            [
              1610,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(NoRotateMultiMockTest, ServerNoResponseFailover) {\n  std::vector<byte> nothing;\n  DNSPacket okrsp;\n  okrsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {2,3,4,5}));\n\n  /* Server #1 works fine on first attempt, then acts like its offline on\n   * second, then backonline on the third. */\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp))\n    .WillOnce(SetReplyData(servers_[0].get(), nothing))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n\n  /* Server #2 always acts like its offline */\n  ON_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillByDefault(SetReplyData(servers_[1].get(), nothing));\n\n  /* Server #3 works fine on first and second request, then no reply on 3rd */\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp))\n    .WillOnce(SetReplyData(servers_[2].get(), nothing));\n\n  HostResult result;\n\n  /* 1. First server returns a response on the first request immediately, normal\n   *    operation on channel. */\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(0, result.timeouts_);\n  std::stringstream ss1;\n  ss1 << result.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss1.str());\n\n  /* 2. On the second request, simulate the first and second servers not\n   *    returning a response at all, but the 3rd server works, so should have\n   *    2 timeouts. */\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(2, result.timeouts_);\n  std::stringstream ss2;\n  ss2 << result.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss2.str());\n\n  /* 3. On the third request, the active server should be #3, so should respond\n   *    immediately with no timeouts */\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(0, result.timeouts_);\n  std::stringstream ss3;\n  ss3 << result.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss3.str());\n\n  /* 4. On the fourth request, the active server should be #3, but will timeout,\n   *    and the first server should then respond */\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(1, result.timeouts_);\n  std::stringstream ss4;\n  ss4 << result.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss4.str());\n}",
          "fn_code_pos": [
            [
              1612,
              0
            ],
            [
              1678,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ServerFailoverOptsMultiMockTest, ServerFailoverOpts) {\n  DNSPacket servfailrsp;\n  servfailrsp.set_response().set_aa().set_rcode(SERVFAIL)\n    .add_question(new DNSQuestion(\"www.example.com\", T_A));\n  DNSPacket okrsp;\n  okrsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {2,3,4,5}));\n\n  // 1. If all servers are healthy, then the first server should be selected.\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  CheckExample();\n\n  // 2. Failed servers should be retried after the retry delay.\n  //\n  // Fail server #0 but leave server #1 as healthy.\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n\n  // Sleep for the retry delay (actually a little more than 250ms to account\n  // for unreliable timing, e.g. NTP slew) and send in another query. Server #0\n  // should be retried.\n  std::this_thread::sleep_for(std::chrono::milliseconds(260));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  CheckExample();\n\n  // 3. If there are multiple failed servers, then the servers should be\n  //    retried in sorted order.\n  //\n  // Fail all servers for the first round of tries. On the second round server\n  // #1 responds successfully.\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &servfailrsp))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &servfailrsp));\n  CheckExample();\n\n  // At this point the sorted servers look like [1] (f0) [2] (f1) [0] (f2).\n  // Sleep for the retry delay and send in another query. Server #2 should be\n  // retried first, and then server #0.\n  std::this_thread::sleep_for(std::chrono::milliseconds(260));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  CheckExample();\n\n  // 4. If there are multiple failed servers, then servers which have not yet\n  //    met the retry delay should be skipped.\n  //\n  // The sorted servers currently look like [0] (f0) [1] (f0) [2] (f2) and\n  // server #2 has just been retried.\n  // Sleep for half the retry delay and trigger a failure on server #0.\n  std::this_thread::sleep_for(std::chrono::milliseconds(130));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n\n  // The sorted servers now look like [1] (f0) [0] (f1) [2] (f2). Server #0\n  // has just failed whilst server #2 is halfway through the retry delay.\n  // Sleep for another half the retry delay and check that server #2 is retried\n  // whilst server #0 is not.\n  std::this_thread::sleep_for(std::chrono::milliseconds(130));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n}",
          "fn_code_pos": [
            [
              1682,
              0
            ],
            [
              1761,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "const char *af_tostr(int af)\n{\n  switch (af) {\n    case AF_INET:\n      return \"ipv4\";\n    case AF_INET6:\n      return \"ipv6\";\n  }\n  return \"ipunknown\";\n}",
          "fn_code_pos": [
            [
              1763,
              0
            ],
            [
              1772,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "af_tostr",
            "parameters": {
              "af": "int"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "const char *mode_tostr(bool mode)\n{\n  return mode?\"ForceTCP\":\"DefaultUDP\";\n}",
          "fn_code_pos": [
            [
              1774,
              0
            ],
            [
              1777,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mode_tostr",
            "parameters": {
              "mode": "bool"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "std::string PrintFamilyMode(const testing::TestParamInfo<std::pair<int, bool>> &info)\n{\n  std::string name;\n\n  name += af_tostr(std::get<0>(info.param));\n  name += \"_\";\n  name += mode_tostr(std::get<1>(info.param));\n  return name;\n}",
          "fn_code_pos": [
            [
              1779,
              0
            ],
            [
              1787,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintFamilyMode",
            "parameters": {
              "info": "testing::TestParamInfo<std::pair<int, bool>>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string PrintFamily(const testing::TestParamInfo<int> &info)\n{\n  std::string name;\n\n  name += af_tostr(info.param);\n  return name;\n}",
          "fn_code_pos": [
            [
              1789,
              0
            ],
            [
              1795,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintFamily",
            "parameters": {
              "info": "testing::TestParamInfo<int>"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "FillOptions(struct ares_options * opts)",
          "fn_dec_pos": [
            [
              381,
              30
            ],
            [
              381,
              69
            ]
          ],
          "class_code": "b78f91be9797bc2b3cfe68aac1dc3fb9f35a0bfbc4218065340c3d750d5cc5c2",
          "class_node_pos": [
            [
              373,
              0
            ],
            [
              388,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts)",
          "fn_dec_pos": [
            [
              428,
              30
            ],
            [
              428,
              69
            ]
          ],
          "class_code": "6f0f0e91bdad3c258d86d50bfbe14eb3620f740fac846bde19e5ed11bd981634",
          "class_node_pos": [
            [
              420,
              0
            ],
            [
              435,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts)",
          "fn_dec_pos": [
            [
              593,
              30
            ],
            [
              593,
              69
            ]
          ],
          "class_code": "4d34171b52d6168049818ed794a30c367995314aefe592bad8ac06259f4a2e1b",
          "class_node_pos": [
            [
              585,
              0
            ],
            [
              602,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts, int flags)",
          "fn_dec_pos": [
            [
              634,
              30
            ],
            [
              634,
              80
            ]
          ],
          "class_code": "86ff80a0a45ae010a1939687ce5120d66b8de18887e91b7f4a59c9ff5a3d9d79",
          "class_node_pos": [
            [
              627,
              0
            ],
            [
              641,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options",
              "flags": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options *opts)",
          "fn_dec_pos": [
            [
              1551,
              30
            ],
            [
              1551,
              68
            ]
          ],
          "class_code": "f850e01d8abb43743d9788dab2d38395fe4556b81ca515a75c0fe7c3f72bd86a",
          "class_node_pos": [
            [
              1546,
              0
            ],
            [
              1559,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "af_tostr(int af)",
          "fn_dec_pos": [
            [
              1763,
              12
            ],
            [
              1763,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "af_tostr",
            "parameters": {
              "af": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "mode_tostr(bool mode)",
          "fn_dec_pos": [
            [
              1774,
              12
            ],
            [
              1774,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mode_tostr",
            "parameters": {
              "mode": "bool"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "b78f91be9797bc2b3cfe68aac1dc3fb9f35a0bfbc4218065340c3d750d5cc5c2": {
          "class_code": "class MockUDPMaxQueriesTest\n    : public MockChannelOptsTest,\n      public ::testing::WithParamInterface<int> {\n public:\n  MockUDPMaxQueriesTest()\n    : MockChannelOptsTest(1, GetParam(), false,\n                          FillOptions(&opts_),\n                          ARES_OPT_UDP_MAX_QUERIES) {}\n  static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->udp_max_queries = MAXUDPQUERIES_LIMIT;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockUDPMaxQueriesTest",
          "class_pos": [
            [
              373,
              0
            ],
            [
              388,
              1
            ]
          ]
        },
        "6f0f0e91bdad3c258d86d50bfbe14eb3620f740fac846bde19e5ed11bd981634": {
          "class_code": "class CacheQueriesTest\n    : public MockChannelOptsTest,\n      public ::testing::WithParamInterface<int> {\n public:\n  CacheQueriesTest()\n    : MockChannelOptsTest(1, GetParam(), false,\n                          FillOptions(&opts_),\n                          ARES_OPT_QUERY_CACHE) {}\n  static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->qcache_max_ttl = 3600;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "CacheQueriesTest",
          "class_pos": [
            [
              420,
              0
            ],
            [
              435,
              1
            ]
          ]
        },
        "4d34171b52d6168049818ed794a30c367995314aefe592bad8ac06259f4a2e1b": {
          "class_code": "class MockExtraOptsTest\n    : public MockChannelOptsTest,\n      public ::testing::WithParamInterface< std::pair<int, bool> > {\n public:\n  MockExtraOptsTest()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second,\n                          FillOptions(&opts_),\n                          ARES_OPT_SOCK_SNDBUF|ARES_OPT_SOCK_RCVBUF) {}\n  static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    // Set a few options that affect socket communications\n    opts->socket_send_buffer_size = 514;\n    opts->socket_receive_buffer_size = 514;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockExtraOptsTest",
          "class_pos": [
            [
              585,
              0
            ],
            [
              602,
              1
            ]
          ]
        },
        "86ff80a0a45ae010a1939687ce5120d66b8de18887e91b7f4a59c9ff5a3d9d79": {
          "class_code": "class MockFlagsChannelOptsTest\n    : public MockChannelOptsTest,\n      public ::testing::WithParamInterface< std::pair<int, bool> > {\n public:\n  MockFlagsChannelOptsTest(int flags)\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second,\n                          FillOptions(&opts_, flags), ARES_OPT_FLAGS) {}\n  static struct ares_options* FillOptions(struct ares_options * opts, int flags) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = flags;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockFlagsChannelOptsTest",
          "class_pos": [
            [
              627,
              0
            ],
            [
              641,
              1
            ]
          ]
        },
        "e4acaa4e65fb26b4a2f5446e475cd09090d789045f1f025ba5402c4f3efeef4c": {
          "class_code": "class MockNoCheckRespChannelTest : public MockFlagsChannelOptsTest {\n public:\n  MockNoCheckRespChannelTest() : MockFlagsChannelOptsTest(ARES_FLAG_NOCHECKRESP) {}\n}",
          "class_name": "MockNoCheckRespChannelTest",
          "class_pos": [
            [
              643,
              0
            ],
            [
              646,
              1
            ]
          ]
        },
        "578e1e23b823c1565296c9cb13adf8dabc2015436f4fc8d77a7b2a8e6f151add": {
          "class_code": "class MockEDNSChannelTest : public MockFlagsChannelOptsTest {\n public:\n  MockEDNSChannelTest() : MockFlagsChannelOptsTest(ARES_FLAG_EDNS) {}\n}",
          "class_name": "MockEDNSChannelTest",
          "class_pos": [
            [
              690,
              0
            ],
            [
              693,
              1
            ]
          ]
        },
        "b302ecb29ac8a11e8290b79b0e0433e65ab628b64acd919fd0b23040c0b013ae": {
          "class_code": "class MockMultiServerChannelTest\n  : public MockChannelOptsTest,\n    public ::testing::WithParamInterface< std::pair<int, bool> > {\n public:\n  MockMultiServerChannelTest(ares_options *opts, int optmask)\n    : MockChannelOptsTest(3, GetParam().first, GetParam().second, opts, optmask) {}\n  void CheckExample() {\n    HostResult result;\n    ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }\n}",
          "class_name": "MockMultiServerChannelTest",
          "class_pos": [
            [
              1524,
              0
            ],
            [
              1539,
              1
            ]
          ]
        },
        "40284f315f94be019493562b35da1236e82397d3ac755e9b46af08f6f92b851f": {
          "class_code": "class NoRotateMultiMockTest : public MockMultiServerChannelTest {\n public:\n  NoRotateMultiMockTest() : MockMultiServerChannelTest(nullptr, ARES_OPT_NOROTATE) {}\n}",
          "class_name": "NoRotateMultiMockTest",
          "class_pos": [
            [
              1541,
              0
            ],
            [
              1544,
              1
            ]
          ]
        },
        "f850e01d8abb43743d9788dab2d38395fe4556b81ca515a75c0fe7c3f72bd86a": {
          "class_code": "class ServerFailoverOptsMultiMockTest : public MockMultiServerChannelTest {\n public:\n  ServerFailoverOptsMultiMockTest()\n    : MockMultiServerChannelTest(FillOptions(&opts_),\n                                 ARES_OPT_SERVER_FAILOVER | ARES_OPT_NOROTATE) {}\n  static struct ares_options* FillOptions(struct ares_options *opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->server_failover_opts.retry_chance = 1;\n    opts->server_failover_opts.retry_delay = 250;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "ServerFailoverOptsMultiMockTest",
          "class_pos": [
            [
              1546,
              0
            ],
            [
              1559,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct ares_options",
          {},
          "",
          [
            381,
            9
          ],
          [
            381,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            381,
            42
          ],
          [
            381,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            382,
            27
          ],
          [
            382,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            387,
            2
          ],
          [
            387,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            428,
            9
          ],
          [
            428,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            428,
            42
          ],
          [
            428,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            429,
            27
          ],
          [
            429,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            434,
            2
          ],
          [
            434,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            593,
            9
          ],
          [
            593,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            593,
            42
          ],
          [
            593,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            594,
            27
          ],
          [
            594,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            601,
            2
          ],
          [
            601,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            634,
            9
          ],
          [
            634,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            634,
            42
          ],
          [
            634,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            635,
            27
          ],
          [
            635,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            640,
            2
          ],
          [
            640,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1215,
            2
          ],
          [
            1215,
            21
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            1339,
            2
          ],
          [
            1339,
            16
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            1503,
            2
          ],
          [
            1503,
            13
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1551,
            9
          ],
          [
            1551,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1551,
            42
          ],
          [
            1551,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1552,
            27
          ],
          [
            1552,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1558,
            2
          ],
          [
            1558,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1562,
            2
          ],
          [
            1562,
            21
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <sys/stat.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test.cc": {
      "fn_def_list": [
        {
          "fn_code": "void ProcessWork(ares_channel_t *channel,\n                 std::function<std::set<ares_socket_t>()> get_extrafds,\n                 std::function<void(ares_socket_t)> process_extra,\n                 unsigned int cancel_ms) {\n  int nfds, count;\n  fd_set readers, writers;\n\n#ifndef CARES_SYMBOL_HIDING\n  struct timeval tv_begin  = ares__tvnow();\n  struct timeval tv_cancel = tv_begin;\n\n  if (cancel_ms) {\n    if (verbose) std::cerr << \"ares_cancel will be called after \" << cancel_ms << \"ms\" << std::endl;\n    tv_cancel.tv_sec  += (cancel_ms / 1000);\n    tv_cancel.tv_usec += ((cancel_ms % 1000) * 1000);\n  }\n#else\n  if (cancel_ms) {\n    std::cerr << \"library built with symbol hiding, can't test with cancel support\" << std::endl;\n    return;\n  }\n#endif\n\n  while (true) {\n#ifndef CARES_SYMBOL_HIDING\n    struct timeval  tv_now = ares__tvnow();\n    struct timeval  tv_remaining;\n#endif\n    struct timeval  tv;\n    struct timeval *tv_select;\n\n    // Retrieve the set of file descriptors that the library wants us to monitor.\n    FD_ZERO(&readers);\n    FD_ZERO(&writers);\n    nfds = ares_fds(channel, &readers, &writers);\n    if (nfds == 0)  // no work left to do in the library\n      return;\n\n    // Add in the extra FDs if present.\n    std::set<ares_socket_t> extrafds = get_extrafds();\n    for (ares_socket_t extrafd : extrafds) {\n      FD_SET(extrafd, &readers);\n      if (extrafd >= (ares_socket_t)nfds) {\n        nfds = (int)extrafd + 1;\n      }\n    }\n\n    /* If ares_timeout returns NULL, it means there are no requests in queue,\n     * so we can break out */\n    tv_select = ares_timeout(channel, NULL, &tv);\n    if (tv_select == NULL)\n      return;\n\n#ifndef CARES_SYMBOL_HIDING\n    if (cancel_ms) {\n      unsigned int remaining_ms;\n      ares__timeval_remaining(&tv_remaining,\n                              &tv_now,\n                              &tv_cancel);\n      remaining_ms = (unsigned int)((tv_remaining.tv_sec * 1000) + (tv_remaining.tv_usec / 1000));\n      if (remaining_ms == 0) {\n        if (verbose) std::cerr << \"Issuing ares_cancel()\" << std::endl;\n        ares_cancel(channel);\n        cancel_ms = 0; /* Disable issuing cancel again */\n      } else {\n        /* Recalculate proper timeout since we also have a cancel to wait on */\n        tv_select = ares_timeout(channel, &tv_remaining, &tv);\n      }\n    }\n#endif\n\n    count = select(nfds, &readers, &writers, nullptr, tv_select);\n    if (count < 0) {\n      fprintf(stderr, \"select() failed, errno %d\\n\", errno);\n      return;\n    }\n\n    // Let the library process any activity.\n    ares_process(channel, &readers, &writers);\n\n    // Let the provided callback process any activity on the extra FD.\n    for (ares_socket_t extrafd : extrafds) {\n      if (FD_ISSET(extrafd, &readers)) {\n        process_extra(extrafd);\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              251,
              0
            ],
            [
              338,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ProcessWork",
            "parameters": {
              "channel": "ares_channel_t",
              "get_extrafds": "std::function<std::set<ares_socket_t>()>",
              "process_extra": "std::function<void(ares_socket_t)>",
              "cancel_ms": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void LibraryTest::SetAllocFail(int nth) {\n  lock_.lock();\n  assert(nth > 0);\n  assert(nth <= (int)(8 * sizeof(fails_)));\n  fails_ |= (1LL << (nth - 1));\n  lock_.unlock();\n}",
          "fn_code_pos": [
            [
              342,
              0
            ],
            [
              348,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::SetAllocFail",
            "parameters": {
              "nth": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void LibraryTest::SetAllocSizeFail(size_t size) {\n  lock_.lock();\n  size_fails_[size]++;\n  lock_.unlock();\n}",
          "fn_code_pos": [
            [
              351,
              0
            ],
            [
              355,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::SetAllocSizeFail",
            "parameters": {
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void LibraryTest::ClearFails() {\n  lock_.lock();\n  fails_ = 0;\n  size_fails_.clear();\n  lock_.unlock();\n}",
          "fn_code_pos": [
            [
              358,
              0
            ],
            [
              363,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::ClearFails",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "bool LibraryTest::ShouldAllocFail(size_t size) {\n  lock_.lock();\n  bool fail = (fails_ & 0x01);\n  fails_ >>= 1;\n  if (size_fails_[size] > 0) {\n    size_fails_[size]--;\n    fail = true;\n  }\n  lock_.unlock();\n  return fail;\n}",
          "fn_code_pos": [
            [
              367,
              0
            ],
            [
              377,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::ShouldAllocFail",
            "parameters": {
              "size": "size_t"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "void* LibraryTest::amalloc(size_t size) {\n  if (ShouldAllocFail(size) || size == 0) {\n    if (verbose) std::cerr << \"Failing malloc(\" << size << \") request\" << std::endl;\n    return nullptr;\n  } else {\n    return malloc(size);\n  }\n}",
          "fn_code_pos": [
            [
              380,
              0
            ],
            [
              387,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::amalloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void* LibraryTest::arealloc(void *ptr, size_t size) {\n  if (ShouldAllocFail(size)) {\n    if (verbose) std::cerr << \"Failing realloc(\" << ptr << \", \" << size << \") request\" << std::endl;\n    return nullptr;\n  } else {\n    return realloc(ptr, size);\n  }\n}",
          "fn_code_pos": [
            [
              390,
              0
            ],
            [
              397,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::arealloc",
            "parameters": {
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void LibraryTest::afree(void *ptr) {\n  free(ptr);\n}",
          "fn_code_pos": [
            [
              400,
              0
            ],
            [
              402,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::afree",
            "parameters": {
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "std::set<ares_socket_t> NoExtraFDs() {\n  return std::set<ares_socket_t>();\n}",
          "fn_code_pos": [
            [
              404,
              0
            ],
            [
              406,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NoExtraFDs",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void DefaultChannelTest::Process(unsigned int cancel_ms) {\n  ProcessWork(channel_, NoExtraFDs, nullptr, cancel_ms);\n}",
          "fn_code_pos": [
            [
              408,
              0
            ],
            [
              410,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DefaultChannelTest::Process",
            "parameters": {
              "cancel_ms": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void FileChannelTest::Process(unsigned int cancel_ms) {\n  ProcessWork(channel_, NoExtraFDs, nullptr, cancel_ms);\n}",
          "fn_code_pos": [
            [
              412,
              0
            ],
            [
              414,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FileChannelTest::Process",
            "parameters": {
              "cancel_ms": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void DefaultChannelModeTest::Process(unsigned int cancel_ms) {\n  ProcessWork(channel_, NoExtraFDs, nullptr, cancel_ms);\n}",
          "fn_code_pos": [
            [
              416,
              0
            ],
            [
              418,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DefaultChannelModeTest::Process",
            "parameters": {
              "cancel_ms": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "MockServer::MockServer(int family, unsigned short port)\n  : udpport_(port), tcpport_(port), qid_(-1) {\n  // Create a TCP socket to receive data on.\n  tcp_data_ = NULL;\n  tcp_data_len_ = 0;\n  tcpfd_ = socket(family, SOCK_STREAM, 0);\n  EXPECT_NE(ARES_SOCKET_BAD, tcpfd_);\n  int optval = 1;\n  setsockopt(tcpfd_, SOL_SOCKET, SO_REUSEADDR,\n             BYTE_CAST &optval , sizeof(int));\n  // Send TCP data right away.\n  setsockopt(tcpfd_, IPPROTO_TCP, TCP_NODELAY,\n             BYTE_CAST &optval , sizeof(int));\n\n  // Create a UDP socket to receive data on.\n  udpfd_ = socket(family, SOCK_DGRAM, 0);\n  EXPECT_NE(ARES_SOCKET_BAD, udpfd_);\n\n  // Bind the sockets to the given port.\n  if (family == AF_INET) {\n    struct sockaddr_in addr;\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    addr.sin_port = htons(tcpport_);\n    int tcprc = bind(tcpfd_, (struct sockaddr*)&addr, sizeof(addr));\n    EXPECT_EQ(0, tcprc) << \"Failed to bind AF_INET to TCP port \" << tcpport_;\n    addr.sin_port = htons(udpport_);\n    int udprc = bind(udpfd_, (struct sockaddr*)&addr, sizeof(addr));\n    EXPECT_EQ(0, udprc) << \"Failed to bind AF_INET to UDP port \" << udpport_;\n    // retrieve system-assigned port\n    if (udpport_ == dynamic_port) {\n      ares_socklen_t len = sizeof(addr);\n      auto result = getsockname(udpfd_, (struct sockaddr*)&addr, &len);\n      EXPECT_EQ(0, result);\n      udpport_ = ntohs(addr.sin_port);\n      EXPECT_NE(dynamic_port, udpport_);\n    }\n    if (tcpport_ == dynamic_port) {\n      ares_socklen_t len = sizeof(addr);\n      auto result = getsockname(tcpfd_, (struct sockaddr*)&addr, &len);\n      EXPECT_EQ(0, result);\n      tcpport_ = ntohs(addr.sin_port);\n      EXPECT_NE(dynamic_port, tcpport_);\n    }\n  } else {\n    EXPECT_EQ(AF_INET6, family);\n    struct sockaddr_in6 addr;\n    memset(&addr, 0, sizeof(addr));\n    addr.sin6_family = AF_INET6;\n    memset(&addr.sin6_addr, 0, sizeof(addr.sin6_addr));  // in6addr_any\n    addr.sin6_port = htons(tcpport_);\n    int tcprc = bind(tcpfd_, (struct sockaddr*)&addr, sizeof(addr));\n    EXPECT_EQ(0, tcprc) << \"Failed to bind AF_INET6 to TCP port \" << tcpport_;\n    addr.sin6_port = htons(udpport_);\n    int udprc = bind(udpfd_, (struct sockaddr*)&addr, sizeof(addr));\n    EXPECT_EQ(0, udprc) << \"Failed to bind AF_INET6 to UDP port \" << udpport_;\n    // retrieve system-assigned port\n    if (udpport_ == dynamic_port) {\n      ares_socklen_t len = sizeof(addr);\n      auto result = getsockname(udpfd_, (struct sockaddr*)&addr, &len);\n      EXPECT_EQ(0, result);\n      udpport_ = ntohs(addr.sin6_port);\n      EXPECT_NE(dynamic_port, udpport_);\n    }\n    if (tcpport_ == dynamic_port) {\n      ares_socklen_t len = sizeof(addr);\n      auto result = getsockname(tcpfd_, (struct sockaddr*)&addr, &len);\n      EXPECT_EQ(0, result);\n      tcpport_ = ntohs(addr.sin6_port);\n      EXPECT_NE(dynamic_port, tcpport_);\n    }\n  }\n  if (verbose) std::cerr << \"Configured \"\n                         << (family == AF_INET ? \"IPv4\" : \"IPv6\")\n                         << \" mock server with TCP socket \" << tcpfd_\n                         << \" on port \" << tcpport_\n                         << \" and UDP socket \" << udpfd_\n                         << \" on port \" << udpport_ << std::endl;\n\n  // For TCP, also need to listen for connections.\n  EXPECT_EQ(0, listen(tcpfd_, 5)) << \"Failed to listen for TCP connections\";\n}",
          "fn_code_pos": [
            [
              420,
              0
            ],
            [
              502,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockServer::MockServer",
            "parameters": {
              "family": "int",
              "port": "unsigned short"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "MockServer::~MockServer() {\n  for (ares_socket_t fd : connfds_) {\n    sclose(fd);\n  }\n  sclose(tcpfd_);\n  sclose(udpfd_);\n  free(tcp_data_);\n}",
          "fn_code_pos": [
            [
              504,
              0
            ],
            [
              511,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockServer::~MockServer",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static unsigned short getaddrport(struct sockaddr_storage *addr)\n{\n  if (addr->ss_family == AF_INET)\n    return ntohs(((struct sockaddr_in *)(void *)addr)->sin_port);\n\n  return ntohs(((struct sockaddr_in6 *)(void *)addr)->sin6_port);\n}",
          "fn_code_pos": [
            [
              513,
              0
            ],
            [
              519,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getaddrport",
            "parameters": {
              "addr": "struct sockaddr_storage"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void MockServer::ProcessPacket(ares_socket_t fd, struct sockaddr_storage *addr, ares_socklen_t addrlen,\n                               byte *data, int len) {\n\n  // Assume the packet is a well-formed DNS request and extract the request\n  // details.\n  if (len < NS_HFIXEDSZ) {\n    std::cerr << \"Packet too short (\" << len << \")\" << std::endl;\n    return;\n  }\n  int qid = DNS_HEADER_QID(data);\n  if (DNS_HEADER_QR(data) != 0) {\n    std::cerr << \"Not a request\" << std::endl;\n    return;\n  }\n  if (DNS_HEADER_OPCODE(data) != O_QUERY) {\n    std::cerr << \"Not a query (opcode \" << DNS_HEADER_OPCODE(data)\n              << \")\" << std::endl;\n    return;\n  }\n  if (DNS_HEADER_QDCOUNT(data) != 1) {\n    std::cerr << \"Unexpected question count (\" << DNS_HEADER_QDCOUNT(data)\n              << \")\" << std::endl;\n    return;\n  }\n  byte* question = data + NS_HFIXEDSZ;\n  int qlen = len - NS_HFIXEDSZ;\n\n  char *name = nullptr;\n  long enclen;\n  ares_expand_name(question, data, len, &name, &enclen);\n  if (!name) {\n    std::cerr << \"Failed to retrieve name\" << std::endl;\n    return;\n  }\n  if (enclen > qlen) {\n    std::cerr << \"(error, encoded name len \" << enclen << \"bigger than remaining data \" << qlen << \" bytes)\" << std::endl;\n    return;\n  }\n  qlen -= (int)enclen;\n  question += enclen;\n  std::string namestr(name);\n  ares_free_string(name);\n\n  if (qlen < 4) {\n    std::cerr << \"Unexpected question size (\" << qlen\n              << \" bytes after name)\" << std::endl;\n    return;\n  }\n  if (DNS_QUESTION_CLASS(question) != C_IN) {\n    std::cerr << \"Unexpected question class (\" << DNS_QUESTION_CLASS(question)\n              << \")\" << std::endl;\n    return;\n  }\n  int rrtype = DNS_QUESTION_TYPE(question);\n\n  std::vector<byte> req(data, data + len);\n  std::string reqstr = PacketToString(req);\n  if (verbose) {\n    std::cerr << \"received \" << (fd == udpfd_ ? \"UDP\" : \"TCP\") << \" request \" << reqstr\n              << \" on port \" << (fd == udpfd_ ? udpport_ : tcpport_)\n              << \":\" << getaddrport(addr) << std::endl;\n    std::cerr << \"ProcessRequest(\" << qid << \", '\" << namestr\n              << \"', \" << RRTypeToString(rrtype) << \")\" << std::endl;\n  }\n  ProcessRequest(fd, addr, addrlen, reqstr, qid, namestr, rrtype);\n\n}",
          "fn_code_pos": [
            [
              521,
              0
            ],
            [
              587,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockServer::ProcessPacket",
            "parameters": {
              "fd": "ares_socket_t",
              "addr": "struct sockaddr_storage",
              "addrlen": "ares_socklen_t",
              "data": "byte",
              "len": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void MockServer::ProcessFD(ares_socket_t fd) {\n  if (fd != tcpfd_ && fd != udpfd_ && connfds_.find(fd) == connfds_.end()) {\n    // Not one of our FDs.\n    return;\n  }\n  if (fd == tcpfd_) {\n    ares_socket_t connfd = accept(tcpfd_, NULL, NULL);\n    if (connfd < 0) {\n      std::cerr << \"Error accepting connection on fd \" << fd << std::endl;\n    } else {\n      connfds_.insert(connfd);\n    }\n    return;\n  }\n\n  // Activity on a data-bearing file descriptor.\n  struct sockaddr_storage addr;\n  socklen_t addrlen = sizeof(addr);\n  byte buffer[2048];\n  ares_ssize_t len = (ares_ssize_t)recvfrom(fd, BYTE_CAST buffer, sizeof(buffer), 0,\n                     (struct sockaddr *)&addr, &addrlen);\n\n  if (fd != udpfd_) {\n    if (len <= 0) {\n      connfds_.erase(std::find(connfds_.begin(), connfds_.end(), fd));\n      sclose(fd);\n      free(tcp_data_);\n      tcp_data_ = NULL;\n      tcp_data_len_ = 0;\n      return;\n    }\n    tcp_data_ = (unsigned char *)realloc(tcp_data_, tcp_data_len_ + (size_t)len);\n    memcpy(tcp_data_ + tcp_data_len_, buffer, (size_t)len);\n    tcp_data_len_ += (size_t)len;\n\n    /* TCP might aggregate the various requests into a single packet, so we\n     * need to split */\n    while (tcp_data_len_ > 2) {\n      size_t tcplen = ((size_t)tcp_data_[0] << 8) + (size_t)tcp_data_[1];\n      if (tcp_data_len_ - 2 < tcplen)\n        break;\n\n      ProcessPacket(fd, &addr, addrlen, tcp_data_ + 2, (int)tcplen);\n\n      /* strip off processed data if connection not terminated */\n      if (tcp_data_ != NULL) {\n        memmove(tcp_data_, tcp_data_ + tcplen + 2, tcp_data_len_ - 2 - tcplen);\n        tcp_data_len_ -= 2 + tcplen;\n      }\n    }\n  } else {\n    /* UDP is always a single packet */\n    ProcessPacket(fd, &addr, addrlen, buffer, (int)len);\n  }\n\n}",
          "fn_code_pos": [
            [
              589,
              0
            ],
            [
              644,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockServer::ProcessFD",
            "parameters": {
              "fd": "ares_socket_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "std::set<ares_socket_t> MockServer::fds() const {\n  std::set<ares_socket_t> result = connfds_;\n  result.insert(tcpfd_);\n  result.insert(udpfd_);\n  return result;\n}",
          "fn_code_pos": [
            [
              646,
              0
            ],
            [
              651,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockServer::fds",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void MockServer::ProcessRequest(ares_socket_t fd, struct sockaddr_storage* addr,\n                                ares_socklen_t addrlen, const std::string &reqstr,\n                                int qid, const std::string& name, int rrtype) {\n  // Before processing, let gMock know the request is happening.\n  OnRequest(name, rrtype);\n\n  // If we are expecting a specific request then check it matches here.\n  if (expected_request_.length() > 0) {\n    ASSERT_EQ(expected_request_, reqstr);\n  }\n\n  if (reply_.size() == 0) {\n    return;\n  }\n\n  // Make a local copy of the current pending reply.\n  std::vector<byte> reply = reply_;\n\n  if (qid_ >= 0) {\n    // Use the explicitly specified query ID.\n    qid = qid_;\n  }\n  if (reply.size() >=  2) {\n    // Overwrite the query ID if space to do so.\n    reply[0] = (byte)((qid >> 8) & 0xff);\n    reply[1] = (byte)(qid & 0xff);\n  }\n  if (verbose) {\n    std::cerr << \"sending reply \" << PacketToString(reply)\n              << \" on port \" << ((fd == udpfd_) ? udpport_ : tcpport_)\n              << \":\" << getaddrport(addr) << std::endl;\n  }\n\n  // Prefix with 2-byte length if TCP.\n  if (fd != udpfd_) {\n    int len = (int)reply.size();\n    std::vector<byte> vlen = {(byte)((len & 0xFF00) >> 8), (byte)(len & 0xFF)};\n    reply.insert(reply.begin(), vlen.begin(), vlen.end());\n    // Also, don't bother with the destination address.\n    addr = nullptr;\n    addrlen = 0;\n  }\n\n  ares_ssize_t rc = (ares_ssize_t)sendto(fd, BYTE_CAST reply.data(), (SEND_TYPE_ARG3)reply.size(), 0,\n                  (struct sockaddr *)addr, addrlen);\n  if (rc < static_cast<ares_ssize_t>(reply.size())) {\n    std::cerr << \"Failed to send full reply, rc=\" << rc << std::endl;\n  }\n}",
          "fn_code_pos": [
            [
              654,
              0
            ],
            [
              702,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockServer::ProcessRequest",
            "parameters": {
              "fd": "ares_socket_t",
              "addr": "struct sockaddr_storage",
              "addrlen": "ares_socklen_t",
              "reqstr": "std::string",
              "qid": "int",
              "name": "std::string",
              "rrtype": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "MockChannelOptsTest::NiceMockServers MockChannelOptsTest::BuildServers(int count, int family, unsigned short base_port) {\n  NiceMockServers servers;\n  assert(count > 0);\n  for (unsigned short ii = 0; ii < count; ii++) {\n    unsigned short port = base_port == dynamic_port ? dynamic_port : base_port + ii;\n    std::unique_ptr<NiceMockServer> server(new NiceMockServer(family, port));\n    servers.push_back(std::move(server));\n  }\n  return servers;\n}",
          "fn_code_pos": [
            [
              705,
              0
            ],
            [
              714,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockChannelOptsTest::BuildServers",
            "parameters": {
              "count": "int",
              "family": "int",
              "base_port": "unsigned short"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "MockChannelOptsTest::MockChannelOptsTest(int count,\n                                         int family,\n                                         bool force_tcp,\n                                         struct ares_options* givenopts,\n                                         int optmask)\n  : servers_(BuildServers(count, family, mock_port)),\n    server_(*servers_[0].get()), channel_(nullptr) {\n  // Set up channel options.\n  struct ares_options opts;\n  if (givenopts) {\n    memcpy(&opts, givenopts, sizeof(opts));\n  } else {\n    memset(&opts, 0, sizeof(opts));\n  }\n\n  // Point the library at the first mock server by default (overridden below).\n  opts.udp_port = server_.udpport();\n  optmask |= ARES_OPT_UDP_PORT;\n  opts.tcp_port = server_.tcpport();\n  optmask |= ARES_OPT_TCP_PORT;\n\n  if (!(optmask & (ARES_OPT_TIMEOUTMS|ARES_OPT_TIMEOUT))) {\n    // Reduce timeouts significantly to shorten test times.\n    opts.timeout = 250;\n    optmask |= ARES_OPT_TIMEOUTMS;\n  }\n  // If not already overridden, set 3 retries.\n  if (!(optmask & ARES_OPT_TRIES)) {\n    opts.tries = 3;\n    optmask |= ARES_OPT_TRIES;\n  }\n  // If not already overridden, set search domains.\n  const char *domains[3] = {\"first.com\", \"second.org\", \"third.gov\"};\n  if (!(optmask & ARES_OPT_DOMAINS)) {\n    opts.ndomains = 3;\n    opts.domains = (char**)domains;\n    optmask |= ARES_OPT_DOMAINS;\n  }\n  if (force_tcp) {\n    opts.flags |= ARES_FLAG_USEVC;\n    optmask |= ARES_OPT_FLAGS;\n  }\n\n  EXPECT_EQ(ARES_SUCCESS, ares_init_options(&channel_, &opts, optmask));\n  EXPECT_NE(nullptr, channel_);\n\n  // Set up servers after construction so we can set individual ports\n  struct ares_addr_port_node* prev = nullptr;\n  struct ares_addr_port_node* first = nullptr;\n  for (const auto& server : servers_) {\n    struct ares_addr_port_node* node = (struct ares_addr_port_node*)malloc(sizeof(*node));\n    if (prev) {\n      prev->next = node;\n    } else {\n      first = node;\n    }\n    node->next = nullptr;\n    node->family = family;\n    node->udp_port = server->udpport();\n    node->tcp_port = server->tcpport();\n    if (family == AF_INET) {\n      node->addr.addr4.s_addr = htonl(0x7F000001);\n    } else {\n      memset(&node->addr.addr6, 0, sizeof(node->addr.addr6));\n      node->addr.addr6._S6_un._S6_u8[15] = 1;\n    }\n    prev = node;\n  }\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers_ports(channel_, first));\n\n  while (first) {\n    prev = first;\n    first = first->next;\n    free(prev);\n  }\n  if (verbose) {\n    std::cerr << \"Configured library with servers:\";\n    std::cerr << GetNameServers(channel_);\n    std::cerr << std::endl;\n  }\n}",
          "fn_code_pos": [
            [
              716,
              0
            ],
            [
              796,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockChannelOptsTest::MockChannelOptsTest",
            "parameters": {
              "count": "int",
              "family": "int",
              "force_tcp": "bool",
              "givenopts": "struct ares_options",
              "optmask": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "MockChannelOptsTest::~MockChannelOptsTest() {\n  if (channel_) {\n    ares_destroy(channel_);\n  }\n  channel_ = nullptr;\n}",
          "fn_code_pos": [
            [
              798,
              0
            ],
            [
              803,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockChannelOptsTest::~MockChannelOptsTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::set<ares_socket_t> MockChannelOptsTest::fds() const {\n  std::set<ares_socket_t> fds;\n  for (const auto& server : servers_) {\n    std::set<ares_socket_t> serverfds = server->fds();\n    fds.insert(serverfds.begin(), serverfds.end());\n  }\n  return fds;\n}",
          "fn_code_pos": [
            [
              805,
              0
            ],
            [
              812,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockChannelOptsTest::fds",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void MockChannelOptsTest::ProcessFD(ares_socket_t fd) {\n  for (auto& server : servers_) {\n    server->ProcessFD(fd);\n  }\n}",
          "fn_code_pos": [
            [
              814,
              0
            ],
            [
              818,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockChannelOptsTest::ProcessFD",
            "parameters": {
              "fd": "ares_socket_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void MockChannelOptsTest::Process(unsigned int cancel_ms) {\n  using namespace std::placeholders;\n  ProcessWork(channel_,\n              std::bind(&MockChannelOptsTest::fds, this),\n              std::bind(&MockChannelOptsTest::ProcessFD, this, _1),\n              cancel_ms);\n}",
          "fn_code_pos": [
            [
              820,
              0
            ],
            [
              826,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockChannelOptsTest::Process",
            "parameters": {
              "cancel_ms": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void MockEventThreadOptsTest::ProcessThread() {\n  std::set<ares_socket_t> fds;\n\n#ifndef CARES_SYMBOL_HIDING\n  bool has_cancel_ms = false;\n  struct timeval tv_begin;\n  struct timeval tv_cancel;\n#endif\n\n  mutex.lock();\n\n  while (isup) {\n    int nfds = 0;\n    fd_set readers;\n#ifndef CARES_SYMBOL_HIDING\n    struct timeval  tv_now = ares__tvnow();\n    struct timeval  tv_remaining;\n    if (cancel_ms_ && !has_cancel_ms) {\n      tv_begin  = ares__tvnow();\n      tv_cancel = tv_begin;\n      if (verbose) std::cerr << \"ares_cancel will be called after \" << cancel_ms_ << \"ms\" << std::endl;\n      tv_cancel.tv_sec  += (cancel_ms_ / 1000);\n      tv_cancel.tv_usec += ((cancel_ms_ % 1000) * 1000);\n      has_cancel_ms = true;\n    }\n#else\n    if (cancel_ms_) {\n      std::cerr << \"library built with symbol hiding, can't test with cancel support\" << std::endl;\n      return;\n    }\n#endif\n    struct timeval  tv;\n\n    /* c-ares is using its own event thread, so we only need to monitor the\n     * extrafds passed in */\n    FD_ZERO(&readers);\n    fds = MockEventThreadOptsTest::fds();\n    for (ares_socket_t fd : fds) {\n      FD_SET(fd, &readers);\n      if (fd >= (ares_socket_t)nfds) {\n        nfds = (int)fd + 1;\n      }\n    }\n\n#ifndef CARES_SYMBOL_HIDING\n    if (has_cancel_ms) {\n      unsigned int remaining_ms;\n      ares__timeval_remaining(&tv_remaining,\n                              &tv_now,\n                              &tv_cancel);\n      remaining_ms = (unsigned int)((tv_remaining.tv_sec * 1000) + (tv_remaining.tv_usec / 1000));\n      if (remaining_ms == 0) {\n        if (verbose) std::cerr << \"Issuing ares_cancel()\" << std::endl;\n        ares_cancel(channel_);\n        cancel_ms_ = 0; /* Disable issuing cancel again */\n        has_cancel_ms = false;\n      }\n    }\n#endif\n\n    /* We just always wait 20ms then recheck. Not doing any complex signaling. */\n    tv.tv_sec  = 0;\n    tv.tv_usec = 20000;\n\n    mutex.unlock();\n    if (select(nfds, &readers, nullptr, nullptr, &tv) < 0) {\n      fprintf(stderr, \"select() failed, errno %d\\n\", errno);\n      return;\n    }\n\n    // Let the provided callback process any activity on the extra FD.\n    for (ares_socket_t fd : fds) {\n      if (FD_ISSET(fd, &readers)) {\n        ProcessFD(fd);\n      }\n    }\n    mutex.lock();\n  }\n  mutex.unlock();\n\n}",
          "fn_code_pos": [
            [
              828,
              0
            ],
            [
              908,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MockEventThreadOptsTest::ProcessThread",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "std::ostream& operator<<(std::ostream& os, const HostResult& result) {\n  os << '{';\n  if (result.done_) {\n    os << StatusToString(result.status_);\n    if (result.host_.addrtype_ != -1) {\n      os << \" \" << result.host_;\n    } else {\n      os << \", (no hostent)\";\n    }\n  } else {\n    os << \"(incomplete)\";\n  }\n  os << '}';\n  return os;\n}",
          "fn_code_pos": [
            [
              910,
              0
            ],
            [
              924,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "HostEnt::HostEnt(const struct hostent *hostent) : addrtype_(-1) {\n  if (!hostent)\n    return;\n\n  if (hostent->h_name)\n    name_ = hostent->h_name;\n\n  if (hostent->h_aliases) {\n    char** palias = hostent->h_aliases;\n    while (*palias != nullptr) {\n      aliases_.push_back(*palias);\n      palias++;\n    }\n  }\n\n  addrtype_ = hostent->h_addrtype;\n\n  if (hostent->h_addr_list) {\n    char** paddr = hostent->h_addr_list;\n    while (*paddr != nullptr) {\n      std::string addr = AddressToString(*paddr, hostent->h_length);\n      addrs_.push_back(addr);\n      paddr++;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              926,
              0
            ],
            [
              951,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HostEnt::HostEnt",
            "parameters": {
              "hostent": "struct hostent"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::ostream& operator<<(std::ostream& os, const HostEnt& host) {\n  os << \"{'\";\n  if (host.name_.length() > 0) {\n    os << host.name_;\n  }\n  os << \"' aliases=[\";\n  for (size_t ii = 0; ii < host.aliases_.size(); ii++) {\n    if (ii > 0) os << \", \";\n    os << host.aliases_[ii];\n  }\n  os << \"] \";\n  os << \"addrs=[\";\n  for (size_t ii = 0; ii < host.addrs_.size(); ii++) {\n    if (ii > 0) os << \", \";\n    os << host.addrs_[ii];\n  }\n  os << \"]\";\n  os << '}';\n  return os;\n}",
          "fn_code_pos": [
            [
              953,
              0
            ],
            [
              972,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void HostCallback(void *data, int status, int timeouts,\n                  struct hostent *hostent) {\n  EXPECT_NE(nullptr, data);\n  if (data == nullptr)\n    return;\n\n  HostResult* result = reinterpret_cast<HostResult*>(data);\n  result->done_ = true;\n  result->status_ = status;\n  result->timeouts_ = timeouts;\n  if (hostent)\n    result->host_ = HostEnt(hostent);\n  if (verbose) std::cerr << \"HostCallback(\" << *result << \")\" << std::endl;\n}",
          "fn_code_pos": [
            [
              974,
              0
            ],
            [
              987,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HostCallback",
            "parameters": {
              "data": "void",
              "status": "int",
              "timeouts": "int",
              "hostent": "struct hostent"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "std::ostream& operator<<(std::ostream& os, const AddrInfoResult& result) {\n  os << '{';\n  if (result.done_ && result.ai_) {\n    os << StatusToString(result.status_) << \" \" << result.ai_;\n  } else {\n    os << \"(incomplete)\";\n  }\n  os << '}';\n  return os;\n}",
          "fn_code_pos": [
            [
              989,
              0
            ],
            [
              998,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::ostream& operator<<(std::ostream& os, const AddrInfo& ai) {\n  os << '{';\n  if (ai == nullptr) {\n    os << \"nullptr}\";\n    return os;\n  }\n\n  struct ares_addrinfo_cname *next_cname = ai->cnames;\n  while(next_cname) {\n    if(next_cname->alias) {\n      os << next_cname->alias << \"->\";\n    }\n    if(next_cname->name) {\n      os << next_cname->name;\n    }\n    if((next_cname = next_cname->next))\n      os << \", \";\n    else\n      os << \" \";\n  }\n\n  struct ares_addrinfo_node *next = ai->nodes;\n  while(next) {\n    //if(next->ai_canonname) {\n      //os << \"'\" << next->ai_canonname << \"' \";\n    //}\n    unsigned short port = 0;\n    os << \"addr=[\";\n    if(next->ai_family == AF_INET) {\n      sockaddr_in* sin = (sockaddr_in *)((void *)next->ai_addr);\n      port = ntohs(sin->sin_port);\n      os << AddressToString(&sin->sin_addr, 4);\n    }\n    else if (next->ai_family == AF_INET6) {\n      sockaddr_in6* sin = (sockaddr_in6*)((void *)next->ai_addr);\n      port = ntohs(sin->sin6_port);\n      os << \"[\" << AddressToString(&sin->sin6_addr, 16) << \"]\";\n    }\n    else\n      os << \"unknown family\";\n    if(port) {\n      os << \":\" << port;\n    }\n    os << \"]\";\n    if((next = next->ai_next))\n      os << \", \";\n  }\n  os << '}';\n  return os;\n}",
          "fn_code_pos": [
            [
              1000,
              0
            ],
            [
              1049,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void AddrInfoCallback(void *data, int status, int timeouts,\n                      struct ares_addrinfo *ai) {\n  EXPECT_NE(nullptr, data);\n  AddrInfoResult* result = reinterpret_cast<AddrInfoResult*>(data);\n  result->done_ = true;\n  result->status_ = status;\n  result->timeouts_= timeouts;\n  if (ai)\n    result->ai_ = AddrInfo(ai);\n  if (verbose) std::cerr << \"AddrInfoCallback(\" << *result << \")\" << std::endl;\n}",
          "fn_code_pos": [
            [
              1051,
              0
            ],
            [
              1061,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddrInfoCallback",
            "parameters": {
              "data": "void",
              "status": "int",
              "timeouts": "int",
              "ai": "struct ares_addrinfo"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "std::ostream& operator<<(std::ostream& os, const SearchResult& result) {\n  os << '{';\n  if (result.done_) {\n    os << StatusToString(result.status_) << \" \" << PacketToString(result.data_);\n  } else {\n    os << \"(incomplete)\";\n  }\n  os << '}';\n  return os;\n}",
          "fn_code_pos": [
            [
              1063,
              0
            ],
            [
              1072,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void SearchCallback(void *data, int status, int timeouts,\n                    unsigned char *abuf, int alen) {\n  EXPECT_NE(nullptr, data);\n  SearchResult* result = reinterpret_cast<SearchResult*>(data);\n  result->done_ = true;\n  result->status_ = status;\n  result->timeouts_ = timeouts;\n  result->data_.assign(abuf, abuf + alen);\n  if (verbose) std::cerr << \"SearchCallback(\" << *result << \")\" << std::endl;\n}",
          "fn_code_pos": [
            [
              1074,
              0
            ],
            [
              1083,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SearchCallback",
            "parameters": {
              "data": "void",
              "status": "int",
              "timeouts": "int",
              "abuf": "unsigned char",
              "alen": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SearchCallbackDnsRec(void *data, ares_status_t status, size_t timeouts,\n                          const ares_dns_record_t *dnsrec) {\n  EXPECT_NE(nullptr, data);\n  SearchResult* result = reinterpret_cast<SearchResult*>(data);\n  unsigned char *abuf = NULL;\n  size_t alen = 0;\n  result->done_ = true;\n  result->status_ = (int)status;\n  result->timeouts_ = (int)timeouts;\n  if (dnsrec != NULL) {\n    ares_dns_write(dnsrec, &abuf, &alen);\n  }\n  result->data_.assign(abuf, abuf + alen);\n  ares_free_string(abuf);\n  if (verbose) std::cerr << \"SearchCallbackDnsRec(\" << *result << \")\" << std::endl;\n}",
          "fn_code_pos": [
            [
              1085,
              0
            ],
            [
              1100,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SearchCallbackDnsRec",
            "parameters": {
              "data": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "std::ostream& operator<<(std::ostream& os, const NameInfoResult& result) {\n  os << '{';\n  if (result.done_) {\n    os << StatusToString(result.status_) << \" \" << result.node_ << \" \" << result.service_;\n  } else {\n    os << \"(incomplete)\";\n  }\n  os << '}';\n  return os;\n}",
          "fn_code_pos": [
            [
              1102,
              0
            ],
            [
              1111,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void NameInfoCallback(void *data, int status, int timeouts,\n                      char *node, char *service) {\n  EXPECT_NE(nullptr, data);\n  NameInfoResult* result = reinterpret_cast<NameInfoResult*>(data);\n  result->done_ = true;\n  result->status_ = status;\n  result->timeouts_ = timeouts;\n  result->node_ = std::string(node ? node : \"\");\n  result->service_ = std::string(service ? service : \"\");\n  if (verbose) std::cerr << \"NameInfoCallback(\" << *result << \")\" << std::endl;\n}",
          "fn_code_pos": [
            [
              1113,
              0
            ],
            [
              1123,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NameInfoCallback",
            "parameters": {
              "data": "void",
              "status": "int",
              "timeouts": "int",
              "node": "char",
              "service": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "std::string GetNameServers(ares_channel_t *channel) {\n  char *csv = ares_get_servers_csv(channel);\n  EXPECT_NE((char *)NULL, csv);\n\n  std::string servers(csv);\n\n  ares_free_string(csv);\n  return servers;\n}",
          "fn_code_pos": [
            [
              1125,
              0
            ],
            [
              1133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetNameServers",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TransientDir::TransientDir(const std::string& dirname) : dirname_(dirname) {\n  if (mkdir_(dirname_.c_str(), 0755) != 0) {\n    std::cerr << \"Failed to create subdirectory '\" << dirname_ << \"'\" << std::endl;\n  }\n}",
          "fn_code_pos": [
            [
              1135,
              0
            ],
            [
              1139,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TransientDir::TransientDir",
            "parameters": {
              "dirname": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TransientDir::~TransientDir() {\n  rmdir(dirname_.c_str());\n}",
          "fn_code_pos": [
            [
              1141,
              0
            ],
            [
              1143,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TransientDir::~TransientDir",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TransientFile::TransientFile(const std::string& filename,\n                             const std::string& contents)\n    : filename_(filename) {\n  FILE *f = fopen(filename.c_str(), \"w\");\n  if (f == nullptr) {\n    std::cerr << \"Error: failed to create '\" << filename << \"'\" << std::endl;\n    return;\n  }\n  size_t rc = (size_t)fwrite(contents.data(), 1, contents.size(), f);\n  if (rc != contents.size()) {\n    std::cerr << \"Error: failed to write contents of '\" << filename << \"'\" << std::endl;\n  }\n  fclose(f);\n}",
          "fn_code_pos": [
            [
              1145,
              0
            ],
            [
              1158,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TransientFile::TransientFile",
            "parameters": {
              "filename": "std::string",
              "contents": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TransientFile::~TransientFile() {\n  unlink(filename_.c_str());\n}",
          "fn_code_pos": [
            [
              1160,
              0
            ],
            [
              1162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TransientFile::~TransientFile",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::string TempNam(const char *dir, const char *prefix) {\n  char *p = tempnam(dir, prefix);\n  std::string result(p);\n  free(p);\n  return result;\n}",
          "fn_code_pos": [
            [
              1164,
              0
            ],
            [
              1169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TempNam",
            "parameters": {
              "dir": "char",
              "prefix": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TempFile::TempFile(const std::string& contents)\n  : TransientFile(TempNam(nullptr, \"ares\"), contents) {\n\n}",
          "fn_code_pos": [
            [
              1171,
              0
            ],
            [
              1174,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TempFile::TempFile",
            "parameters": {
              "contents": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "VirtualizeIO::VirtualizeIO(ares_channel_t *c)\n  : channel_(c)\n{\n  ares_set_socket_functions(channel_, &default_functions, 0);\n}",
          "fn_code_pos": [
            [
              1176,
              0
            ],
            [
              1180,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VirtualizeIO::VirtualizeIO",
            "parameters": {
              "c": "ares_channel_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "VirtualizeIO::~VirtualizeIO() {\n  ares_set_socket_functions(channel_, 0, 0);\n}",
          "fn_code_pos": [
            [
              1182,
              0
            ],
            [
              1184,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VirtualizeIO::~VirtualizeIO",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "LibraryTest::amalloc(size_t size)",
          "fn_dec_pos": [
            [
              380,
              6
            ],
            [
              380,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::amalloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "LibraryTest::arealloc(void *ptr, size_t size)",
          "fn_dec_pos": [
            [
              390,
              6
            ],
            [
              390,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LibraryTest::arealloc",
            "parameters": {
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "namestr(name)",
          "fn_dec_pos": [
            [
              561,
              14
            ],
            [
              561,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "namestr",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream& os, const HostResult& result)",
          "fn_dec_pos": [
            [
              910,
              14
            ],
            [
              910,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "HostResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream& os, const HostEnt& host)",
          "fn_dec_pos": [
            [
              953,
              14
            ],
            [
              953,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "host": "HostEnt"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream& os, const AddrInfoResult& result)",
          "fn_dec_pos": [
            [
              989,
              14
            ],
            [
              989,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "AddrInfoResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream& os, const AddrInfo& ai)",
          "fn_dec_pos": [
            [
              1000,
              14
            ],
            [
              1000,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "ai": "AddrInfo"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream& os, const SearchResult& result)",
          "fn_dec_pos": [
            [
              1063,
              14
            ],
            [
              1063,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "SearchResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream& os, const NameInfoResult& result)",
          "fn_dec_pos": [
            [
              1102,
              14
            ],
            [
              1102,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "NameInfoResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "servers(csv)",
          "fn_dec_pos": [
            [
              1129,
              14
            ],
            [
              1129,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "servers",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "result(p)",
          "fn_dec_pos": [
            [
              1166,
              14
            ],
            [
              1166,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "result",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct timeval",
          {},
          "",
          [
            259,
            2
          ],
          [
            259,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            260,
            2
          ],
          [
            260,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            276,
            4
          ],
          [
            276,
            18
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            277,
            4
          ],
          [
            277,
            18
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            279,
            4
          ],
          [
            279,
            18
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            280,
            4
          ],
          [
            280,
            18
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            440,
            4
          ],
          [
            440,
            22
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            445,
            30
          ],
          [
            445,
            45
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            448,
            30
          ],
          [
            448,
            45
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            453,
            41
          ],
          [
            453,
            56
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            460,
            41
          ],
          [
            460,
            56
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            467,
            4
          ],
          [
            467,
            23
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            472,
            30
          ],
          [
            472,
            45
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            475,
            30
          ],
          [
            475,
            45
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            480,
            41
          ],
          [
            480,
            56
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            487,
            41
          ],
          [
            487,
            56
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            513,
            34
          ],
          [
            513,
            57
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            516,
            19
          ],
          [
            516,
            37
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            518,
            17
          ],
          [
            518,
            36
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            521,
            49
          ],
          [
            521,
            72
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            605,
            2
          ],
          [
            605,
            25
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            609,
            22
          ],
          [
            609,
            37
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            654,
            50
          ],
          [
            654,
            73
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            698,
            19
          ],
          [
            698,
            34
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            719,
            41
          ],
          [
            719,
            60
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            724,
            2
          ],
          [
            724,
            21
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            763,
            2
          ],
          [
            763,
            28
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            764,
            2
          ],
          [
            764,
            28
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            766,
            4
          ],
          [
            766,
            30
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            766,
            40
          ],
          [
            766,
            66
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            833,
            2
          ],
          [
            833,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            834,
            2
          ],
          [
            834,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            843,
            4
          ],
          [
            843,
            18
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            844,
            4
          ],
          [
            844,
            18
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            859,
            4
          ],
          [
            859,
            18
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            926,
            23
          ],
          [
            926,
            37
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            975,
            18
          ],
          [
            975,
            32
          ]
        ],
        [
          "struct ares_addrinfo_cname",
          {},
          "",
          [
            1007,
            2
          ],
          [
            1007,
            28
          ]
        ],
        [
          "struct ares_addrinfo_node",
          {},
          "",
          [
            1021,
            2
          ],
          [
            1021,
            27
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            1052,
            22
          ],
          [
            1052,
            42
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares-test.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares-test-ai.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares_dns.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include \"ares_setup.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include \"ares_strsplit.h\"\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <netdb.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <netinet/tcp.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#include <functional>\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-init.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST(LibraryInit, Basic) {\n  EXPECT_EQ(EXPECTED_NONINIT, ares_library_initialized());\n  EXPECT_EQ(ARES_SUCCESS, ares_library_init(ARES_LIB_INIT_ALL));\n  EXPECT_EQ(ARES_SUCCESS, ares_library_initialized());\n  ares_library_cleanup();\n  EXPECT_EQ(EXPECTED_NONINIT, ares_library_initialized());\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              47,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(LibraryInit, UnexpectedCleanup) {\n  EXPECT_EQ(EXPECTED_NONINIT, ares_library_initialized());\n  ares_library_cleanup();\n  EXPECT_EQ(EXPECTED_NONINIT, ares_library_initialized());\n}",
          "fn_code_pos": [
            [
              49,
              0
            ],
            [
              53,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(LibraryInit, Nested) {\n  EXPECT_EQ(EXPECTED_NONINIT, ares_library_initialized());\n  EXPECT_EQ(ARES_SUCCESS, ares_library_init(ARES_LIB_INIT_ALL));\n  EXPECT_EQ(ARES_SUCCESS, ares_library_initialized());\n  EXPECT_EQ(ARES_SUCCESS, ares_library_init(ARES_LIB_INIT_ALL));\n  EXPECT_EQ(ARES_SUCCESS, ares_library_initialized());\n  ares_library_cleanup();\n  EXPECT_EQ(ARES_SUCCESS, ares_library_initialized());\n  ares_library_cleanup();\n  EXPECT_EQ(EXPECTED_NONINIT, ares_library_initialized());\n}",
          "fn_code_pos": [
            [
              55,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(LibraryInit, BasicChannelInit) {\n  EXPECT_EQ(ARES_SUCCESS, ares_library_init(ARES_LIB_INIT_ALL));\n  ares_channel_t *channel = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_init(&channel));\n  EXPECT_NE(nullptr, channel);\n  ares_destroy(channel);\n  ares_library_cleanup();\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              74,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, OptionsChannelInit) {\n  struct ares_options opts;\n  int optmask = 0;\n  memset(&opts, 0, sizeof(opts));\n  opts.flags = ARES_FLAG_USEVC | ARES_FLAG_PRIMARY;\n  optmask |= ARES_OPT_FLAGS;\n  opts.timeout = 2000;\n  optmask |= ARES_OPT_TIMEOUTMS;\n  opts.tries = 2;\n  optmask |= ARES_OPT_TRIES;\n  opts.ndots = 4;\n  optmask |= ARES_OPT_NDOTS;\n  opts.udp_port = 54;\n  optmask |= ARES_OPT_MAXTIMEOUTMS;\n  opts.maxtimeout = 10000;\n  optmask |= ARES_OPT_UDP_PORT;\n  opts.tcp_port = 54;\n  optmask |= ARES_OPT_TCP_PORT;\n  opts.socket_send_buffer_size = 514;\n  optmask |= ARES_OPT_SOCK_SNDBUF;\n  opts.socket_receive_buffer_size = 514;\n  optmask |= ARES_OPT_SOCK_RCVBUF;\n  opts.ednspsz = 1280;\n  optmask |= ARES_OPT_EDNSPSZ;\n  opts.nservers = 2;\n  opts.servers = (struct in_addr *)malloc((size_t)opts.nservers * sizeof(struct in_addr));\n  opts.servers[0].s_addr = htonl(0x01020304);\n  opts.servers[1].s_addr = htonl(0x02030405);\n  optmask |= ARES_OPT_SERVERS;\n  opts.ndomains = 2;\n  opts.domains = (char **)malloc((size_t)opts.ndomains * sizeof(char *));\n  opts.domains[0] = strdup(\"example.com\");\n  opts.domains[1] = strdup(\"example2.com\");\n  optmask |= ARES_OPT_DOMAINS;\n  opts.lookups = strdup(\"b\");\n  optmask |= ARES_OPT_LOOKUPS;\n  optmask |= ARES_OPT_ROTATE;\n  opts.resolvconf_path = strdup(\"/etc/resolv.conf\");\n  optmask |= ARES_OPT_RESOLVCONF;\n  opts.hosts_path = strdup(\"/etc/hosts\");\n  optmask |= ARES_OPT_HOSTS_FILE;\n\n  ares_channel_t *channel = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_init_options(&channel, &opts, optmask));\n  EXPECT_NE(nullptr, channel);\n\n  ares_channel_t *channel2 = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_dup(&channel2, channel));\n  EXPECT_NE(nullptr, channel2);\n\n  struct ares_options opts2;\n  int optmask2 = 0;\n  memset(&opts2, 0, sizeof(opts2));\n  EXPECT_EQ(ARES_SUCCESS, ares_save_options(channel2, &opts2, &optmask2));\n\n  // Note that not all opts-settable fields are saved (e.g.\n  // ednspsz, socket_{send,receive}_buffer_size).\n  EXPECT_EQ(opts.flags, opts2.flags);\n  EXPECT_EQ(opts.timeout, opts2.timeout);\n  EXPECT_EQ(opts.tries, opts2.tries);\n  EXPECT_EQ(opts.ndots, opts2.ndots);\n  EXPECT_EQ(opts.maxtimeout, opts2.maxtimeout);\n  EXPECT_EQ(opts.udp_port, opts2.udp_port);\n  EXPECT_EQ(opts.tcp_port, opts2.tcp_port);\n  EXPECT_EQ(1, opts2.nservers);  // Truncated by ARES_FLAG_PRIMARY\n  EXPECT_EQ(opts.servers[0].s_addr, opts2.servers[0].s_addr);\n  EXPECT_EQ(opts.ndomains, opts2.ndomains);\n  EXPECT_EQ(std::string(opts.domains[0]), std::string(opts2.domains[0]));\n  EXPECT_EQ(std::string(opts.domains[1]), std::string(opts2.domains[1]));\n  EXPECT_EQ(std::string(opts.lookups), std::string(opts2.lookups));\n  EXPECT_EQ(std::string(opts.resolvconf_path), std::string(opts2.resolvconf_path));\n  EXPECT_EQ(std::string(opts.hosts_path), std::string(opts2.hosts_path));\n\n  ares_destroy_options(&opts);\n  ares_destroy_options(&opts2);\n  ares_destroy(channel);\n  ares_destroy(channel2);\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              153,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ChannelAllocFail) {\n  ares_channel_t *channel;\n  for (int ii = 1; ii <= 25; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    channel = nullptr;\n    int rc = ares_init(&channel);\n    // The number of allocations depends on local environment, so don't expect ENOMEM.\n    if (rc == ARES_ENOMEM) {\n      EXPECT_EQ(nullptr, channel);\n    } else {\n      ares_destroy(channel);\n    }\n  }\n}",
          "fn_code_pos": [
            [
              155,
              0
            ],
            [
              169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, OptionsChannelAllocFail) {\n  struct ares_options opts;\n  int optmask = 0;\n  memset(&opts, 0, sizeof(opts));\n  opts.flags = ARES_FLAG_USEVC;\n  optmask |= ARES_OPT_FLAGS;\n  opts.timeout = 2;\n  optmask |= ARES_OPT_TIMEOUT;\n  opts.tries = 2;\n  optmask |= ARES_OPT_TRIES;\n  opts.ndots = 4;\n  optmask |= ARES_OPT_NDOTS;\n  opts.udp_port = 54;\n  optmask |= ARES_OPT_UDP_PORT;\n  opts.tcp_port = 54;\n  optmask |= ARES_OPT_TCP_PORT;\n  opts.socket_send_buffer_size = 514;\n  optmask |= ARES_OPT_SOCK_SNDBUF;\n  opts.socket_receive_buffer_size = 514;\n  optmask |= ARES_OPT_SOCK_RCVBUF;\n  opts.ednspsz = 1280;\n  optmask |= ARES_OPT_EDNSPSZ;\n  opts.nservers = 2;\n  opts.servers = (struct in_addr *)malloc((size_t)opts.nservers * sizeof(struct in_addr));\n  opts.servers[0].s_addr = htonl(0x01020304);\n  opts.servers[1].s_addr = htonl(0x02030405);\n  optmask |= ARES_OPT_SERVERS;\n  opts.ndomains = 2;\n  opts.domains = (char **)malloc((size_t)opts.ndomains * sizeof(char *));\n  opts.domains[0] = strdup(\"example.com\");\n  opts.domains[1] = strdup(\"example2.com\");\n  optmask |= ARES_OPT_DOMAINS;\n  opts.lookups = strdup(\"b\");\n  optmask |= ARES_OPT_LOOKUPS;\n  optmask |= ARES_OPT_ROTATE;\n  opts.resolvconf_path = strdup(\"/etc/resolv.conf\");\n  optmask |= ARES_OPT_RESOLVCONF;\n  opts.hosts_path = strdup(\"/etc/hosts\");\n  optmask |= ARES_OPT_HOSTS_FILE;\n\n  ares_channel_t *channel = nullptr;\n  for (int ii = 1; ii <= 8; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    int rc = ares_init_options(&channel, &opts, optmask);\n    if (rc == ARES_ENOMEM) {\n      EXPECT_EQ(nullptr, channel);\n    } else {\n      EXPECT_EQ(ARES_SUCCESS, rc);\n      ares_destroy(channel);\n      channel = nullptr;\n    }\n  }\n  ClearFails();\n\n  EXPECT_EQ(ARES_SUCCESS, ares_init_options(&channel, &opts, optmask));\n  EXPECT_NE(nullptr, channel);\n\n  // Add some servers and a sortlist for flavour.\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_set_servers_csv(channel, \"1.2.3.4,0102:0304:0506:0708:0910:1112:1314:1516,2.3.4.5\"));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel, \"1.2.3.4 2.3.4.5\"));\n\n  ares_channel_t *channel2 = nullptr;\n  for (int ii = 1; ii <= 18; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_dup(&channel2, channel)) << ii;\n    EXPECT_EQ(nullptr, channel2) << ii;\n  }\n\n  struct ares_options opts2;\n  int optmask2 = 0;\n  for (int ii = 1; ii <= 6; ii++) {\n    memset(&opts2, 0, sizeof(opts2));\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_save_options(channel, &opts2, &optmask2)) << ii;\n    // May still have allocations even after ARES_ENOMEM return code.\n    ares_destroy_options(&opts2);\n  }\n  ares_destroy_options(&opts);\n  ares_destroy(channel);\n}",
          "fn_code_pos": [
            [
              171,
              0
            ],
            [
              254,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, FailChannelInit) {\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_library_init_mem(ARES_LIB_INIT_ALL,\n                                  &LibraryTest::amalloc,\n                                  &LibraryTest::afree,\n                                  &LibraryTest::arealloc));\n  SetAllocFail(1);\n  ares_channel_t *channel = nullptr;\n  EXPECT_EQ(ARES_ENOMEM, ares_init(&channel));\n  EXPECT_EQ(nullptr, channel);\n  ares_library_cleanup();\n}",
          "fn_code_pos": [
            [
              256,
              0
            ],
            [
              267,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, EnvInit) {\n  ares_channel_t *channel = nullptr;\n  EnvValue v1(\"LOCALDOMAIN\", \"this.is.local\");\n  EnvValue v2(\"RES_OPTIONS\", \"options debug ndots:3 retry:3 rotate retrans:2\");\n  EXPECT_EQ(ARES_SUCCESS, ares_init(&channel));\n  ares_destroy(channel);\n}",
          "fn_code_pos": [
            [
              270,
              0
            ],
            [
              276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, EnvInitModernOptions) {\n  ares_channel_t *channel = nullptr;\n  EnvValue v1(\"LOCALDOMAIN\", \"this.is.local\");\n  EnvValue v2(\"RES_OPTIONS\", \"options debug retrans:2 ndots:3 attempts:4 timeout:5 rotate\");\n  EXPECT_EQ(ARES_SUCCESS, ares_init(&channel));\n\n  channel->optmask |= ARES_OPT_TRIES;\n  channel->optmask |= ARES_OPT_TIMEOUTMS;\n\n  struct ares_options opts;\n  memset(&opts, 0, sizeof(opts));\n  int optmask = 0;\n  EXPECT_EQ(ARES_SUCCESS, ares_save_options(channel, &opts, &optmask));\n  EXPECT_EQ(5000, opts.timeout);\n  EXPECT_EQ(4, opts.tries);\n\n  ares_destroy(channel);\n}",
          "fn_code_pos": [
            [
              278,
              0
            ],
            [
              295,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, EnvInitAllocFail) {\n  ares_channel_t *channel;\n  EnvValue v1(\"LOCALDOMAIN\", \"this.is.local\");\n  EnvValue v2(\"RES_OPTIONS\", \"options debug ndots:3 retry:3 rotate retrans:2\");\n  for (int ii = 1; ii <= 10; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    channel = nullptr;\n    int rc = ares_init(&channel);\n    if (rc == ARES_SUCCESS) {\n      ares_destroy(channel);\n    } else {\n      EXPECT_EQ(ARES_ENOMEM, rc);\n    }\n  }\n}",
          "fn_code_pos": [
            [
              297,
              0
            ],
            [
              312,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SetAddresses) {\n  ares_set_local_ip4(channel_, 0x01020304);\n  byte addr6[16] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n                    0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10};\n  ares_set_local_ip6(channel_, addr6);\n  ares_set_local_dev(channel_, \"dummy\");\n}",
          "fn_code_pos": [
            [
              315,
              0
            ],
            [
              321,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SetSortlistFailures) {\n  EXPECT_EQ(ARES_ENODATA, ares_set_sortlist(nullptr, \"1.2.3.4\"));\n  EXPECT_EQ(ARES_EBADSTR, ares_set_sortlist(channel_, \"111.111.111.111*/16\"));\n  EXPECT_EQ(ARES_EBADSTR, ares_set_sortlist(channel_, \"111.111.111.111/255.255.255.240*\"));\n  EXPECT_EQ(ARES_EBADSTR, ares_set_sortlist(channel_, \"1 0123456789012345\"));\n  EXPECT_EQ(ARES_EBADSTR, ares_set_sortlist(channel_, \"1 /01234567890123456789012345678901\"));\n  EXPECT_EQ(ARES_EBADSTR, ares_set_sortlist(channel_, \"xyzzy ; lwk\"));\n  EXPECT_EQ(ARES_EBADSTR, ares_set_sortlist(channel_, \"xyzzy ; 0x123\"));\n}",
          "fn_code_pos": [
            [
              323,
              0
            ],
            [
              331,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SetSortlistVariants) {\n  EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"1.2.3.4\"));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"1.2.3.4 ; 2.3.4.5\"));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"1.2.3.4/26;1234::5678/126;4.5.6.7;5678::1234\"));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \" 1.2.3.4/26 1234::5678/126   4.5.6.7 5678::1234  \"));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"129.1.1.1\"));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"192.1.1.1\"));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"224.1.1.1\"));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"225.1.1.1\"));\n}",
          "fn_code_pos": [
            [
              333,
              0
            ],
            [
              342,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SetSortlistAllocFail) {\n  for (int ii = 1; ii <= 3; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_set_sortlist(channel_, \"12.13.0.0/16 1234::5678/40 1.2.3.4\")) << ii;\n  }\n}",
          "fn_code_pos": [
            [
              344,
              0
            ],
            [
              350,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(Init, NoLibraryInit) {\n  ares_channel_t *channel = nullptr;\n  EXPECT_EQ(ARES_ENOTINITIALIZED, ares_init(&channel));\n}",
          "fn_code_pos": [
            [
              353,
              0
            ],
            [
              356,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "explicit MakeUnreadable(const std::string& filename)\n    : filename_(filename) {\n    chmod(filename_.c_str(), 0000);\n  }",
          "fn_code_pos": [
            [
              539,
              2
            ],
            [
              542,
              3
            ]
          ],
          "class_code": "f77489f9fd42798776383da3aceb4b4cb1b8fe183752b39eada5679181806099",
          "class_node_pos": [
            [
              537,
              0
            ],
            [
              546,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MakeUnreadable",
            "parameters": {
              "filename": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~MakeUnreadable() { chmod(filename_.c_str(), 0644); }",
          "fn_code_pos": [
            [
              543,
              2
            ],
            [
              543,
              55
            ]
          ],
          "class_code": "f77489f9fd42798776383da3aceb4b4cb1b8fe183752b39eada5679181806099",
          "class_node_pos": [
            [
              537,
              0
            ],
            [
              546,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "f77489f9fd42798776383da3aceb4b4cb1b8fe183752b39eada5679181806099": {
          "class_code": "class MakeUnreadable {\n public:\n  explicit MakeUnreadable(const std::string& filename)\n    : filename_(filename) {\n    chmod(filename_.c_str(), 0000);\n  }\n  ~MakeUnreadable() { chmod(filename_.c_str(), 0644); }\n private:\n  std::string filename_;\n}",
          "class_name": "MakeUnreadable",
          "class_pos": [
            [
              537,
              0
            ],
            [
              546,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct ares_options",
          {},
          "",
          [
            77,
            2
          ],
          [
            77,
            21
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            101,
            18
          ],
          [
            101,
            32
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            101,
            73
          ],
          [
            101,
            87
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            126,
            2
          ],
          [
            126,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            172,
            2
          ],
          [
            172,
            21
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            194,
            18
          ],
          [
            194,
            32
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            194,
            73
          ],
          [
            194,
            87
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            242,
            2
          ],
          [
            242,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            287,
            2
          ],
          [
            287,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            419,
            2
          ],
          [
            419,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            463,
            2
          ],
          [
            463,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            489,
            2
          ],
          [
            489,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            597,
            2
          ],
          [
            597,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            689,
            2
          ],
          [
            689,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            702,
            2
          ],
          [
            702,
            21
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            28,
            2
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/dns-proto.cc": {
      "fn_def_list": [
        {
          "fn_code": "std::string HexDump(std::vector<byte> data) {\n  std::stringstream ss;\n  for (size_t ii = 0; ii < data.size();  ii++) {\n    char buffer[2 + 1];\n    snprintf(buffer, sizeof(buffer), \"%02x\", data[ii]);\n    ss << buffer;\n  }\n  return ss.str();\n}",
          "fn_code_pos": [
            [
              39,
              0
            ],
            [
              47,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HexDump",
            "parameters": {
              "data": "std::vector<byte>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string HexDump(const byte *data, int len) {\n  return HexDump(std::vector<byte>(data, data + len));\n}",
          "fn_code_pos": [
            [
              49,
              0
            ],
            [
              51,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HexDump",
            "parameters": {
              "data": "byte",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string HexDump(const char *data, int len) {\n  return HexDump(reinterpret_cast<const byte*>(data), len);\n}",
          "fn_code_pos": [
            [
              53,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HexDump",
            "parameters": {
              "data": "char",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string StatusToString(int status) {\n  switch (status) {\n  case ARES_SUCCESS: return \"ARES_SUCCESS\";\n  case ARES_ENODATA: return \"ARES_ENODATA\";\n  case ARES_EFORMERR: return \"ARES_EFORMERR\";\n  case ARES_ESERVFAIL: return \"ARES_ESERVFAIL\";\n  case ARES_ENOTFOUND: return \"ARES_ENOTFOUND\";\n  case ARES_ENOTIMP: return \"ARES_ENOTIMP\";\n  case ARES_EREFUSED: return \"ARES_EREFUSED\";\n  case ARES_EBADQUERY: return \"ARES_EBADQUERY\";\n  case ARES_EBADNAME: return \"ARES_EBADNAME\";\n  case ARES_EBADFAMILY: return \"ARES_EBADFAMILY\";\n  case ARES_EBADRESP: return \"ARES_EBADRESP\";\n  case ARES_ECONNREFUSED: return \"ARES_ECONNREFUSED\";\n  case ARES_ETIMEOUT: return \"ARES_ETIMEOUT\";\n  case ARES_EOF: return \"ARES_EOF\";\n  case ARES_EFILE: return \"ARES_EFILE\";\n  case ARES_ENOMEM: return \"ARES_ENOMEM\";\n  case ARES_EDESTRUCTION: return \"ARES_EDESTRUCTION\";\n  case ARES_EBADSTR: return \"ARES_EBADSTR\";\n  case ARES_EBADFLAGS: return \"ARES_EBADFLAGS\";\n  case ARES_ENONAME: return \"ARES_ENONAME\";\n  case ARES_EBADHINTS: return \"ARES_EBADHINTS\";\n  case ARES_ENOTINITIALIZED: return \"ARES_ENOTINITIALIZED\";\n  case ARES_ELOADIPHLPAPI: return \"ARES_ELOADIPHLPAPI\";\n  case ARES_EADDRGETNETWORKPARAMS: return \"ARES_EADDRGETNETWORKPARAMS\";\n  case ARES_ECANCELLED: return \"ARES_ECANCELLED\";\n  default: return \"UNKNOWN\";\n  }\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "StatusToString",
            "parameters": {
              "status": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string RcodeToString(int rcode) {\n  switch (rcode) {\n  case NOERROR: return \"NOERROR\";\n  case FORMERR: return \"FORMERR\";\n  case SERVFAIL: return \"SERVFAIL\";\n  case NXDOMAIN: return \"NXDOMAIN\";\n  case NOTIMP: return \"NOTIMP\";\n  case REFUSED: return \"REFUSED\";\n  case YXDOMAIN: return \"YXDOMAIN\";\n  case YXRRSET: return \"YXRRSET\";\n  case NXRRSET: return \"NXRRSET\";\n  case NOTAUTH: return \"NOTAUTH\";\n  case NOTZONE: return \"NOTZONE\";\n  case TSIG_BADSIG: return \"BADSIG\";\n  case TSIG_BADKEY: return \"BADKEY\";\n  case TSIG_BADTIME: return \"BADTIME\";\n  default: return \"UNKNOWN\";\n  }\n}",
          "fn_code_pos": [
            [
              88,
              0
            ],
            [
              106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RcodeToString",
            "parameters": {
              "rcode": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string RRTypeToString(int rrtype) {\n  switch (rrtype) {\n  case T_A: return \"A\";\n  case T_NS: return \"NS\";\n  case T_MD: return \"MD\";\n  case T_MF: return \"MF\";\n  case T_CNAME: return \"CNAME\";\n  case T_SOA: return \"SOA\";\n  case T_MB: return \"MB\";\n  case T_MG: return \"MG\";\n  case T_MR: return \"MR\";\n  case T_NULL: return \"NULL\";\n  case T_WKS: return \"WKS\";\n  case T_PTR: return \"PTR\";\n  case T_HINFO: return \"HINFO\";\n  case T_MINFO: return \"MINFO\";\n  case T_MX: return \"MX\";\n  case T_TXT: return \"TXT\";\n  case T_RP: return \"RP\";\n  case T_AFSDB: return \"AFSDB\";\n  case T_X25: return \"X25\";\n  case T_ISDN: return \"ISDN\";\n  case T_RT: return \"RT\";\n  case T_NSAP: return \"NSAP\";\n  case T_NSAP_PTR: return \"NSAP_PTR\";\n  case T_SIG: return \"SIG\";\n  case T_KEY: return \"KEY\";\n  case T_PX: return \"PX\";\n  case T_GPOS: return \"GPOS\";\n  case T_AAAA: return \"AAAA\";\n  case T_LOC: return \"LOC\";\n  case T_NXT: return \"NXT\";\n  case T_EID: return \"EID\";\n  case T_NIMLOC: return \"NIMLOC\";\n  case T_SRV: return \"SRV\";\n  case T_ATMA: return \"ATMA\";\n  case T_NAPTR: return \"NAPTR\";\n  case T_KX: return \"KX\";\n  case T_CERT: return \"CERT\";\n  case T_A6: return \"A6\";\n  case T_DNAME: return \"DNAME\";\n  case T_SINK: return \"SINK\";\n  case T_OPT: return \"OPT\";\n  case T_APL: return \"APL\";\n  case T_DS: return \"DS\";\n  case T_SSHFP: return \"SSHFP\";\n  case T_RRSIG: return \"RRSIG\";\n  case T_NSEC: return \"NSEC\";\n  case T_DNSKEY: return \"DNSKEY\";\n  case T_TKEY: return \"TKEY\";\n  case T_TSIG: return \"TSIG\";\n  case T_IXFR: return \"IXFR\";\n  case T_AXFR: return \"AXFR\";\n  case T_MAILB: return \"MAILB\";\n  case T_MAILA: return \"MAILA\";\n  case T_ANY: return \"ANY\";\n  case T_URI: return \"URI\";\n  case T_MAX: return \"MAX\";\n  default: return \"UNKNOWN\";\n  }\n}",
          "fn_code_pos": [
            [
              108,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RRTypeToString",
            "parameters": {
              "rrtype": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string ClassToString(int qclass) {\n  switch (qclass) {\n  case C_IN: return \"IN\";\n  case C_CHAOS: return \"CHAOS\";\n  case C_HS: return \"HESIOD\";\n  case C_NONE: return \"NONE\";\n  case C_ANY: return \"ANY\";\n  default: return \"UNKNOWN\";\n  }\n}",
          "fn_code_pos": [
            [
              170,
              0
            ],
            [
              179,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ClassToString",
            "parameters": {
              "qclass": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string AddressToString(const void* vaddr, int len) {\n  const byte* addr = reinterpret_cast<const byte*>(vaddr);\n  std::stringstream ss;\n  if (len == 4) {\n    char buffer[4*4 + 3 + 1];\n    snprintf(buffer, sizeof(buffer), \"%u.%u.%u.%u\",\n             (unsigned char)addr[0],\n             (unsigned char)addr[1],\n             (unsigned char)addr[2],\n             (unsigned char)addr[3]);\n    ss << buffer;\n  } else if (len == 16) {\n    for (int ii = 0; ii < 16;  ii+=2) {\n      if (ii > 0) ss << ':';\n      char buffer[4 + 1];\n      snprintf(buffer, sizeof(buffer), \"%02x%02x\", (unsigned char)addr[ii], (unsigned char)addr[ii+1]);\n      ss << buffer;\n    }\n  } else {\n    ss << \"!\" << HexDump(addr, len) << \"!\";\n  }\n  return ss.str();\n}",
          "fn_code_pos": [
            [
              181,
              0
            ],
            [
              203,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddressToString",
            "parameters": {
              "vaddr": "void",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string PacketToString(const std::vector<byte>& packet) {\n  const byte* data = packet.data();\n  int len = (int)packet.size();\n  std::stringstream ss;\n  if (len < NS_HFIXEDSZ) {\n    ss << \"(too short, len \" << len << \")\";\n    return ss.str();\n  }\n  ss << ((DNS_HEADER_QR(data) == 0) ? \"REQ \" : \"RSP \");\n  switch (DNS_HEADER_OPCODE(data)) {\n  case O_QUERY: ss << \"QRY \"; break;\n  case O_IQUERY: ss << \"IQRY \"; break;\n  case O_STATUS: ss << \"STATUS \"; break;\n  case O_NOTIFY: ss << \"NOTIFY \"; break;\n  case O_UPDATE: ss << \"UPDATE \"; break;\n  default: ss << \"UNKNOWN(\" << DNS_HEADER_OPCODE(data) << \") \"; break;\n  }\n  if (DNS_HEADER_AA(data)) ss << \"AA \";\n  if (DNS_HEADER_TC(data)) ss << \"TC \";\n  if (DNS_HEADER_RD(data)) ss << \"RD \";\n  if (DNS_HEADER_RA(data)) ss << \"RA \";\n  if (DNS_HEADER_Z(data)) ss << \"Z \";\n  if (DNS_HEADER_QR(data) == 1) ss << RcodeToString(DNS_HEADER_RCODE(data));\n\n  int nquestions = DNS_HEADER_QDCOUNT(data);\n  int nanswers = DNS_HEADER_ANCOUNT(data);\n  int nauths = DNS_HEADER_NSCOUNT(data);\n  int nadds = DNS_HEADER_ARCOUNT(data);\n\n  const byte* pq = data + NS_HFIXEDSZ;\n  len -= NS_HFIXEDSZ;\n  for (int ii = 0; ii < nquestions; ii++) {\n    ss << \" Q:\" << QuestionToString(packet, &pq, &len);\n  }\n  const byte* prr = pq;\n  for (int ii = 0; ii < nanswers; ii++) {\n    ss << \" A:\" << RRToString(packet, &prr, &len);\n  }\n  for (int ii = 0; ii < nauths; ii++) {\n    ss << \" AUTH:\" << RRToString(packet, &prr, &len);\n  }\n  for (int ii = 0; ii < nadds; ii++) {\n    ss << \" ADD:\" << RRToString(packet, &prr, &len);\n  }\n  return ss.str();\n}",
          "fn_code_pos": [
            [
              205,
              0
            ],
            [
              250,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PacketToString",
            "parameters": {
              "packet": "std::vector<byte>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string QuestionToString(const std::vector<byte>& packet,\n                             const byte** data, int* len) {\n  std::stringstream ss;\n  ss << \"{\";\n  if (*len < NS_QFIXEDSZ) {\n    ss << \"(too short, len \" << *len << \")\";\n    return ss.str();\n  }\n\n  char *name = nullptr;\n  long enclen;\n  int rc = ares_expand_name(*data, packet.data(), (int)packet.size(), &name, &enclen);\n  if (rc != ARES_SUCCESS) {\n    ss << \"(error from ares_expand_name)\";\n    return ss.str();\n  }\n  if (enclen > *len) {\n    ss << \"(error, encoded name len \" << enclen << \"bigger than remaining data \" << *len << \" bytes)\";\n    return ss.str();\n  }\n  *len -= (int)enclen;\n  *data += enclen;\n  ss << \"'\" << name << \"' \";\n  ares_free_string(name);\n  if (*len < NS_QFIXEDSZ) {\n    ss << \"(too short, len left \" << *len << \")\";\n    return ss.str();\n  }\n  ss << ClassToString(DNS_QUESTION_CLASS(*data)) << \" \";\n  ss << RRTypeToString(DNS_QUESTION_TYPE(*data));\n  *data += NS_QFIXEDSZ;\n  *len -= NS_QFIXEDSZ;\n  ss << \"}\";\n  return ss.str();\n}",
          "fn_code_pos": [
            [
              252,
              0
            ],
            [
              286,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "QuestionToString",
            "parameters": {
              "packet": "std::vector<byte>",
              "data": "byte",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::string RRToString(const std::vector<byte>& packet,\n                       const byte** data, int* len) {\n  std::stringstream ss;\n  ss << \"{\";\n  if (*len < NS_RRFIXEDSZ) {\n    ss << \"too short, len \" << *len << \")\";\n    return ss.str();\n  }\n\n  char *name = nullptr;\n  long enclen;\n  int rc = ares_expand_name(*data, packet.data(), (int)packet.size(), &name, &enclen);\n  if (rc != ARES_SUCCESS) {\n    ss << \"(error from ares_expand_name)\";\n    return ss.str();\n  }\n  if (enclen > *len) {\n    ss << \"(error, encoded name len \" << enclen << \"bigger than remaining data \" << *len << \" bytes)\";\n    return ss.str();\n  }\n  *len -= (int)enclen;\n  *data += enclen;\n  ss << \"'\" << name << \"' \";\n  ares_free_string(name);\n  name = nullptr;\n\n  if (*len < NS_RRFIXEDSZ) {\n    ss << \"(too short, len left \" << *len << \")\";\n    return ss.str();\n  }\n  int rrtype = DNS_RR_TYPE(*data);\n  if (rrtype == T_OPT) {\n    ss << \"MAXUDP=\" << DNS_RR_CLASS(*data) << \" \";\n    ss << RRTypeToString(rrtype) << \" \";\n    ss << \"RCODE2=\" << DNS_RR_TTL(*data);\n  } else {\n    ss << ClassToString(DNS_RR_CLASS(*data)) << \" \";\n    ss << RRTypeToString(rrtype) << \" \";\n    ss << \"TTL=\" << DNS_RR_TTL(*data);\n  }\n  int rdatalen = DNS_RR_LEN(*data);\n\n  *data += NS_RRFIXEDSZ;\n  *len -= NS_RRFIXEDSZ;\n  if (*len < rdatalen) {\n    ss << \"(RR too long at \" << rdatalen << \", len left \" << *len << \")\";\n  } else {\n    switch (rrtype) {\n    case T_A:\n    case T_AAAA:\n      ss << \" \" << AddressToString(*data, rdatalen);\n      break;\n    case T_TXT: {\n      const byte* p = *data;\n      while (p < (*data + rdatalen)) {\n        int len = *p++;\n        if ((p + len) <= (*data + rdatalen)) {\n          std::string txt(p, p + len);\n          ss << \" \" << len << \":'\" << txt << \"'\";\n        } else {\n          ss << \"(string too long)\";\n        }\n        p += len;\n      }\n      break;\n    }\n    case T_CNAME:\n    case T_NS:\n    case T_PTR: {\n      int rc = ares_expand_name(*data, packet.data(), (int)packet.size(), &name, &enclen);\n      if (rc != ARES_SUCCESS) {\n        ss << \"(error from ares_expand_name)\";\n        break;\n      }\n      ss << \" '\" << name << \"'\";\n      ares_free_string(name);\n      break;\n    }\n    case T_MX:\n      if (rdatalen > 2) {\n        int rc = ares_expand_name(*data + 2, packet.data(), (int)packet.size(), &name, &enclen);\n        if (rc != ARES_SUCCESS) {\n          ss << \"(error from ares_expand_name)\";\n          break;\n        }\n        ss << \" \" << DNS__16BIT(*data) << \" '\" << name << \"'\";\n        ares_free_string(name);\n      } else {\n        ss << \"(RR too short)\";\n      }\n      break;\n    case T_SRV: {\n      if (rdatalen > 6) {\n        const byte* p = *data;\n        unsigned long prio = DNS__16BIT(p);\n        unsigned long weight = DNS__16BIT(p + 2);\n        unsigned long port = DNS__16BIT(p + 4);\n        p += 6;\n        int rc = ares_expand_name(p, packet.data(), (int)packet.size(), &name, &enclen);\n        if (rc != ARES_SUCCESS) {\n          ss << \"(error from ares_expand_name)\";\n          break;\n        }\n        ss << prio << \" \" << weight << \" \" << port << \" '\" << name << \"'\";\n        ares_free_string(name);\n      } else {\n        ss << \"(RR too short)\";\n      }\n      break;\n    }\n    case T_URI: {\n      if (rdatalen > 4) {\n        const byte* p = *data;\n        unsigned long prio = DNS__16BIT(p);\n        unsigned long weight = DNS__16BIT(p + 2);\n        p += 4;\n        std::string uri(p, p + (rdatalen - 4));\n        ss << prio << \" \" << weight << \" '\" << uri << \"'\";\n      } else {\n        ss << \"(RR too short)\";\n      }\n      break;\n    }\n    case T_SOA: {\n      const byte* p = *data;\n      int rc = ares_expand_name(p, packet.data(), (int)packet.size(), &name, &enclen);\n      if (rc != ARES_SUCCESS) {\n        ss << \"(error from ares_expand_name)\";\n        break;\n      }\n      ss << \" '\" << name << \"'\";\n      ares_free_string(name);\n      p += enclen;\n      rc = ares_expand_name(p, packet.data(), (int)packet.size(), &name, &enclen);\n      if (rc != ARES_SUCCESS) {\n        ss << \"(error from ares_expand_name)\";\n        break;\n      }\n      ss << \" '\" << name << \"'\";\n      ares_free_string(name);\n      p += enclen;\n      if ((p + 20) <= (*data + rdatalen)) {\n        unsigned long serial = DNS__32BIT(p);\n        unsigned long refresh = DNS__32BIT(p + 4);\n        unsigned long retry = DNS__32BIT(p + 8);\n        unsigned long expire = DNS__32BIT(p + 12);\n        unsigned long minimum = DNS__32BIT(p + 16);\n        ss << \" \" << serial << \" \" << refresh << \" \" << retry << \" \" << expire << \" \" << minimum;\n      } else {\n        ss << \"(RR too short)\";\n      }\n      break;\n    }\n    case T_NAPTR: {\n      if (rdatalen > 7) {\n        const byte* p = *data;\n        unsigned long order = DNS__16BIT(p);\n        unsigned long pref = DNS__16BIT(p + 2);\n        p += 4;\n        ss << order << \" \" << pref;\n\n        int len = *p++;\n        std::string flags(p, p + len);\n        ss << \" \" << flags;\n        p += len;\n\n        len = *p++;\n        std::string service(p, p + len);\n        ss << \" '\" << service << \"'\";\n        p += len;\n\n        len = *p++;\n        std::string regexp(p, p + len);\n        ss << \" '\" << regexp << \"'\";\n        p += len;\n\n        int rc = ares_expand_name(p, packet.data(), (int)packet.size(), &name, &enclen);\n        if (rc != ARES_SUCCESS) {\n          ss << \"(error from ares_expand_name)\";\n          break;\n        }\n        ss << \" '\" << name << \"'\";\n        ares_free_string(name);\n      } else {\n        ss << \"(RR too short)\";\n      }\n      break;\n    }\n    default:\n      ss << \" \" << HexDump(*data, rdatalen);\n      break;\n    }\n  }\n  *data += rdatalen;\n  *len -= rdatalen;\n\n  ss << \"}\";\n  return ss.str();\n}",
          "fn_code_pos": [
            [
              288,
              0
            ],
            [
              486,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RRToString",
            "parameters": {
              "packet": "std::vector<byte>",
              "data": "byte",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void PushInt32(std::vector<byte>* data, int value) {\n  data->push_back((byte)(((unsigned int)value & 0xff000000) >> 24));\n  data->push_back((byte)(((unsigned int)value & 0x00ff0000) >> 16));\n  data->push_back((byte)(((unsigned int)value & 0x0000ff00) >> 8));\n  data->push_back((byte)(value & 0x000000ff));\n}",
          "fn_code_pos": [
            [
              488,
              0
            ],
            [
              493,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PushInt32",
            "parameters": {
              "data": "std::vector<byte>",
              "value": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void PushInt16(std::vector<byte>* data, int value) {\n  data->push_back((byte)((value & 0xff00) >> 8));\n  data->push_back((byte)value & 0x00ff);\n}",
          "fn_code_pos": [
            [
              495,
              0
            ],
            [
              498,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PushInt16",
            "parameters": {
              "data": "std::vector<byte>",
              "value": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "std::vector<byte> EncodeString(const std::string& name) {\n  std::vector<byte> data;\n  std::stringstream ss(name);\n  std::string label;\n  // TODO: cope with escapes\n  while (std::getline(ss, label, '.')) {\n    /* Label length of 0 indicates the end, and we always push an end\n     * terminator, so don't do it twice */\n    if (label.length() == 0)\n      break;\n    data.push_back((byte)label.length());\n    data.insert(data.end(), label.begin(), label.end());\n  }\n  data.push_back(0);\n  return data;\n}",
          "fn_code_pos": [
            [
              500,
              0
            ],
            [
              515,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EncodeString",
            "parameters": {
              "name": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSQuestion::data() const {\n  std::vector<byte> data;\n  std::vector<byte> encname = EncodeString(name_);\n  data.insert(data.end(), encname.begin(), encname.end());\n  PushInt16(&data, rrtype_);\n  PushInt16(&data, qclass_);\n  return data;\n}",
          "fn_code_pos": [
            [
              517,
              0
            ],
            [
              524,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSQuestion::data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSRR::data() const {\n  std::vector<byte> data = DNSQuestion::data();\n  PushInt32(&data, ttl_);\n  return data;\n}",
          "fn_code_pos": [
            [
              526,
              0
            ],
            [
              530,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSRR::data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSSingleNameRR::data() const {\n  std::vector<byte> data = DNSRR::data();\n  std::vector<byte> encname = EncodeString(other_);\n  int len = (int)encname.size();\n  PushInt16(&data, len);\n  data.insert(data.end(), encname.begin(), encname.end());\n  return data;\n}",
          "fn_code_pos": [
            [
              532,
              0
            ],
            [
              539,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSSingleNameRR::data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSTxtRR::data() const {\n  std::vector<byte> data = DNSRR::data();\n  int len = 0;\n  for (const std::string& txt : txt_) {\n    len += (1 + (int)txt.size());\n  }\n  PushInt16(&data, len);\n  for (const std::string& txt : txt_) {\n    data.push_back((byte)txt.size());\n    data.insert(data.end(), txt.begin(), txt.end());\n  }\n  return data;\n}",
          "fn_code_pos": [
            [
              541,
              0
            ],
            [
              553,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSTxtRR::data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSMxRR::data() const {\n  std::vector<byte> data = DNSRR::data();\n  std::vector<byte> encname = EncodeString(other_);\n  int len = 2 + (int)encname.size();\n  PushInt16(&data, len);\n  PushInt16(&data, pref_);\n  data.insert(data.end(), encname.begin(), encname.end());\n  return data;\n}",
          "fn_code_pos": [
            [
              555,
              0
            ],
            [
              563,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSMxRR::data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSSrvRR::data() const {\n  std::vector<byte> data = DNSRR::data();\n  std::vector<byte> encname = EncodeString(target_);\n  int len = 6 + (int)encname.size();\n  PushInt16(&data, len);\n  PushInt16(&data, prio_);\n  PushInt16(&data, weight_);\n  PushInt16(&data, port_);\n  data.insert(data.end(), encname.begin(), encname.end());\n  return data;\n}",
          "fn_code_pos": [
            [
              565,
              0
            ],
            [
              575,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSSrvRR::data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSUriRR::data() const {\n  std::vector<byte> data = DNSRR::data();\n  int len = 4 + (int)target_.size();\n  PushInt16(&data, len);\n  PushInt16(&data, prio_);\n  PushInt16(&data, weight_);\n  data.insert(data.end(), target_.begin(), target_.end());\n  return data;\n}",
          "fn_code_pos": [
            [
              577,
              0
            ],
            [
              585,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSUriRR::data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSAddressRR::data() const {\n  std::vector<byte> data = DNSRR::data();\n  int len = (int)addr_.size();\n  PushInt16(&data, len);\n  data.insert(data.end(), addr_.begin(), addr_.end());\n  return data;\n}",
          "fn_code_pos": [
            [
              587,
              0
            ],
            [
              593,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSAddressRR::data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSSoaRR::data() const {\n  std::vector<byte> data = DNSRR::data();\n  std::vector<byte> encname1 = EncodeString(nsname_);\n  std::vector<byte> encname2 = EncodeString(rname_);\n  int len = (int)encname1.size() + (int)encname2.size() + 5*4;\n  PushInt16(&data, len);\n  data.insert(data.end(), encname1.begin(), encname1.end());\n  data.insert(data.end(), encname2.begin(), encname2.end());\n  PushInt32(&data, serial_);\n  PushInt32(&data, refresh_);\n  PushInt32(&data, retry_);\n  PushInt32(&data, expire_);\n  PushInt32(&data, minimum_);\n  return data;\n}",
          "fn_code_pos": [
            [
              595,
              0
            ],
            [
              609,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSSoaRR::data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSOptRR::data() const {\n  std::vector<byte> data = DNSRR::data();\n  int len = 0;\n  for (const DNSOption& opt : opts_) {\n    len += (4 + (int)opt.data_.size());\n  }\n  PushInt16(&data, len);\n  for (const DNSOption& opt : opts_) {\n    PushInt16(&data, opt.code_);\n    PushInt16(&data, (int)opt.data_.size());\n    data.insert(data.end(), opt.data_.begin(), opt.data_.end());\n  }\n  return data;\n}",
          "fn_code_pos": [
            [
              611,
              0
            ],
            [
              624,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSOptRR::data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSNaptrRR::data() const {\n  std::vector<byte> data = DNSRR::data();\n  std::vector<byte> encname = EncodeString(replacement_);\n  int len = (4 + 1 + (int)flags_.size() + 1 + (int)service_.size() + 1 + (int)regexp_.size() + (int)encname.size());\n  PushInt16(&data, len);\n  PushInt16(&data, order_);\n  PushInt16(&data, pref_);\n  data.push_back((byte)flags_.size());\n  data.insert(data.end(), flags_.begin(), flags_.end());\n  data.push_back((byte)service_.size());\n  data.insert(data.end(), service_.begin(), service_.end());\n  data.push_back((byte)regexp_.size());\n  data.insert(data.end(), regexp_.begin(), regexp_.end());\n  data.insert(data.end(), encname.begin(), encname.end());\n  return data;\n}",
          "fn_code_pos": [
            [
              626,
              0
            ],
            [
              641,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSNaptrRR::data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> DNSPacket::data() const {\n  std::vector<byte> data;\n  PushInt16(&data, qid_);\n  byte b = 0x00;\n  if (response_) b |= 0x80;\n  b |= ((opcode_ & 0x0f) << 3);\n  if (aa_) b |= 0x04;\n  if (tc_) b |= 0x02;\n  if (rd_) b |= 0x01;\n  data.push_back(b);\n  b = 0x00;\n  if (ra_) b |= 0x80;\n  if (z_) b |= 0x40;\n  if (ad_) b |= 0x20;\n  if (cd_) b |= 0x10;\n  b |= (rcode_ & 0x0f);\n  data.push_back(b);\n\n  int count = (int)questions_.size();\n  PushInt16(&data, count);\n  count = (int)answers_.size();\n  PushInt16(&data, count);\n  count = (int)auths_.size();\n  PushInt16(&data, count);\n  count = (int)adds_.size();\n  PushInt16(&data, count);\n\n  for (const std::unique_ptr<DNSQuestion>& question : questions_) {\n    std::vector<byte> qdata = question->data();\n    data.insert(data.end(), qdata.begin(), qdata.end());\n  }\n  for (const std::unique_ptr<DNSRR>& rr : answers_) {\n    std::vector<byte> rrdata = rr->data();\n    data.insert(data.end(), rrdata.begin(), rrdata.end());\n  }\n  for (const std::unique_ptr<DNSRR>& rr : auths_) {\n    std::vector<byte> rrdata = rr->data();\n    data.insert(data.end(), rrdata.begin(), rrdata.end());\n  }\n  for (const std::unique_ptr<DNSRR>& rr : adds_) {\n    std::vector<byte> rrdata = rr->data();\n    data.insert(data.end(), rrdata.begin(), rrdata.end());\n  }\n  return data;\n}",
          "fn_code_pos": [
            [
              643,
              0
            ],
            [
              687,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSPacket::data",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ss(name)",
          "fn_dec_pos": [
            [
              502,
              20
            ],
            [
              502,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ss",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"ares_dns.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-parse-soa.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseSoaReplyOK) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_SOA))\n    .add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_soa_reply* soa = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  ASSERT_NE(nullptr, soa);\n  EXPECT_EQ(\"soa1.example.com\", std::string(soa->nsname));\n  EXPECT_EQ(\"fred.example.com\", std::string(soa->hostmaster));\n  EXPECT_EQ((unsigned int)1, soa->serial);\n  EXPECT_EQ((unsigned int)2, soa->refresh);\n  EXPECT_EQ((unsigned int)3, soa->retry);\n  EXPECT_EQ((unsigned int)4, soa->expire);\n  EXPECT_EQ((unsigned int)5, soa->minttl);\n  ares_free_data(soa);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSoaReplyErrors) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_SOA))\n    .add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n  std::vector<byte> data;\n  struct ares_soa_reply* soa = nullptr;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.add_question(new DNSQuestion(\"example.com\", T_SOA));\n\n#ifdef DISABLED\n  // Question != answer\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_SOA));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_SOA));\n#endif\n\n  // Two questions\n  pkt.add_question(new DNSQuestion(\"example.com\", T_SOA));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_SOA));\n\n  // Wrong sort of answer.\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)len, &soa));\n  }\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSoaReplyAllocFail) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_SOA))\n    .add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n  std::vector<byte> data = pkt.data();\n  struct ares_soa_reply* soa = nullptr;\n\n  for (int ii = 1; ii <= 5; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_soa_reply(data.data(), (int)data.size(), &soa)) << ii;\n  }\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              129,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            43,
            2
          ],
          [
            43,
            23
          ]
        ],
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            64,
            2
          ],
          [
            64,
            23
          ]
        ],
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            122,
            2
          ],
          [
            122,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-parse-a.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseAReplyOK) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 0x01020304, {2,3,4,5}))\n    .add_answer(new DNSAaaaRR(\"example.com\", 0x01020304, {0,0,0,0,0,0,0,0,0,0,0,0,2,3,4,5}));\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x02,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x04,  // rdata length\n    0x02, 0x03, 0x04, 0x05,\n    // Answer 2\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x1c,  //  RR type\n    0x00, 0x01,  //  class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x10,  // rdata length\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x04, 0x05,\n  };\n  EXPECT_EQ(data, pkt.data());\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[5];\n  int count = 5;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(1, count);\n  EXPECT_EQ(0x01020304, info[0].ttl);\n  unsigned long expected_addr = htonl(0x02030405);\n  EXPECT_EQ(expected_addr, info[0].ipaddr.s_addr);\n  EXPECT_EQ(\"2.3.4.5\", AddressToString(&(info[0].ipaddr), 4));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  ares_free_hostent(host);\n\n  // Repeat without providing a hostent\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             nullptr, info, &count));\n  EXPECT_EQ(1, count);\n  EXPECT_EQ(0x01020304, info[0].ttl);\n  EXPECT_EQ(expected_addr, info[0].ipaddr.s_addr);\n  EXPECT_EQ(\"2.3.4.5\", AddressToString(&(info[0].ipaddr), 4));\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseMalformedAReply) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // [0:2) qid\n    0x84, // [2] response + query + AA + not-TC + not-RD\n    0x00, // [3] not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // [4:6) num questions\n    0x00, 0x02,  // [6:8) num answer RRs\n    0x00, 0x00,  // [8:10) num authority RRs\n    0x00, 0x00,  // [10:12) num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e', // [12:20)\n    0x03, 'c', 'o', 'm', // [20,24)\n    0x00, // [24]\n    0x00, 0x01,  // [25:26) type A\n    0x00, 0x01,  // [27:29) class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e', // [29:37)\n    0x03, 'c', 'o', 'm', // [37:41)\n    0x00, // [41]\n    0x00, 0x01,  // [42:44) RR type\n    0x00, 0x01,  // [44:46) class IN\n    0x01, 0x02, 0x03, 0x04, // [46:50) TTL\n    0x00, 0x04,  // [50:52) rdata length\n    0x02, 0x03, 0x04, 0x05, // [52,56)\n  };\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n\n  // Invalid RR-len.\n  std::vector<byte> invalid_rrlen(data);\n  invalid_rrlen[51] = 180;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_a_reply(invalid_rrlen.data(), (int)invalid_rrlen.size(),\n                                              &host, info, &count));\n\n  // Truncate mid-question.\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_a_reply(data.data(), 26,\n                                              &host, info, &count));\n\n  // Truncate mid-answer.\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_a_reply(data.data(), 42,\n                                              &host, info, &count));\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              141,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAReplyNoData) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A));\n  std::vector<byte> data = pkt.data();\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  EXPECT_EQ(ARES_ENODATA, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(0, count);\n  EXPECT_EQ(nullptr, host);\n\n  // Again but with a CNAME.\n  pkt.add_answer(new DNSCnameRR(\"example.com\", 200, \"c.example.com\"));\n  data = pkt.data();\n  // Expect success as per https://github.com/c-ares/c-ares/commit/2c63440127feed70ccefb148b8f938a2df6c15f8\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(0, count);\n  EXPECT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'c.example.com' aliases=[example.com] addrs=[]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              143,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAReplyVariantA) {\n  DNSPacket pkt;\n  pkt.set_qid(6366).set_rd().set_ra()\n    .add_question(new DNSQuestion(\"mit.edu\", T_A))\n    .add_answer(new DNSARR(\"mit.edu\", 52, {18,7,22,69}))\n    .add_auth(new DNSNsRR(\"mit.edu\", 292, \"W20NS.mit.edu\"))\n    .add_auth(new DNSNsRR(\"mit.edu\", 292, \"BITSY.mit.edu\"))\n    .add_auth(new DNSNsRR(\"mit.edu\", 292, \"STRAWB.mit.edu\"))\n    .add_additional(new DNSARR(\"STRAWB.mit.edu\", 292, {18,71,0,151}));\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  std::vector<byte> data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(1, count);\n  EXPECT_EQ(\"18.7.22.69\", AddressToString(&(info[0].ipaddr), 4));\n  EXPECT_EQ(52, info[0].ttl);\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              170,
              0
            ],
            [
              189,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAReplyJustCname) {\n  DNSPacket pkt;\n  pkt.set_qid(6366).set_rd().set_ra()\n    .add_question(new DNSQuestion(\"mit.edu\", T_A))\n    .add_answer(new DNSCnameRR(\"mit.edu\", 52, \"other.mit.edu\"));\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  std::vector<byte> data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(0, count);\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'other.mit.edu' aliases=[mit.edu] addrs=[]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              191,
              0
            ],
            [
              208,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAReplyVariantCname) {\n  DNSPacket pkt;\n  pkt.set_qid(6366).set_rd().set_ra()\n    .add_question(new DNSQuestion(\"query.example.com\", T_A))\n    .add_answer(new DNSCnameRR(\"query.example.com\", 200, \"redirect.query.example.com\"))\n    .add_answer(new DNSARR(\"redirect.query.example.com\", 300, {129,97,123,22}))\n    .add_auth(new DNSNsRR(\"example.com\", 218, \"aa.ns1.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 218, \"ns2.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 218, \"ns3.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 218, \"ns4.example.com\"))\n    .add_additional(new DNSARR(\"aa.ns1.example.com\", 218, {129,97,1,1}))\n    .add_additional(new DNSARR(\"ns2.example.com\", 218, {129,97,1,2}))\n    .add_additional(new DNSARR(\"ns3.example.com\", 218, {129,97,1,3}))\n    .add_additional(new DNSARR(\"ns4.example.com\", 218, {129,97,1,4}));\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  std::vector<byte> data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(1, count);\n  EXPECT_EQ(\"129.97.123.22\", AddressToString(&(info[0].ipaddr), 4));\n  // TTL is reduced to match CNAME's.\n  EXPECT_EQ(200, info[0].ttl);\n  ares_free_hostent(host);\n\n  // Repeat parsing without places to put the results.\n  count = 0;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             nullptr, info, &count));\n}",
          "fn_code_pos": [
            [
              210,
              0
            ],
            [
              240,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAReplyVariantCnameChain) {\n  DNSPacket pkt;\n  pkt.set_qid(6366).set_rd().set_ra()\n    .add_question(new DNSQuestion(\"c1.localhost\", T_A))\n    .add_answer(new DNSCnameRR(\"c1.localhost\", 604800, \"c2.localhost\"))\n    .add_answer(new DNSCnameRR(\"c2.localhost\", 604800, \"c3.localhost\"))\n    .add_answer(new DNSCnameRR(\"c3.localhost\", 604800, \"c4.localhost\"))\n    .add_answer(new DNSARR(\"c4.localhost\", 604800, {8,8,8,8}))\n    .add_auth(new DNSNsRR(\"localhost\", 604800, \"localhost\"))\n    .add_additional(new DNSARR(\"localhost\", 604800, {127,0,0,1}))\n    .add_additional(new DNSAaaaRR(\"localhost\", 604800,\n                              {0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}));\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  std::vector<byte> data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(1, count);\n  EXPECT_EQ(\"8.8.8.8\", AddressToString(&(info[0].ipaddr), 4));\n  EXPECT_EQ(604800, info[0].ttl);\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              242,
              0
            ],
            [
              265,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAReplyErrors) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {0x02, 0x03, 0x04, 0x05}));\n  std::vector<byte> data;\n\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_a_reply(data.data(), (int)data.size(),\n                                              &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.add_question(new DNSQuestion(\"example.com\", T_A));\n\n  // Question != answer, this is ok as of Issue #683\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_A));\n  data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                              &host, info, &count));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'Axample.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  ares_free_hostent(host);\n  host = nullptr;\n\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_A));\n\n#ifdef DISABLED\n  // Not a response.\n  pkt.set_response(false);\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_a_reply(data.data(), (int)data.size(),\n                                              &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.set_response(true);\n\n  // Bad return code.\n  pkt.set_rcode(FORMERR);\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_a_reply(data.data(), (int)data.size(),\n                                              &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.set_rcode(NOERROR);\n#endif\n\n  // Two questions\n  pkt.add_question(new DNSQuestion(\"example.com\", T_A));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_a_reply(data.data(), (int)data.size(),\n                                              &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_A));\n\n  // Wrong sort of answer.\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSARR(\"example.com\", 100, {0x02, 0x03, 0x04, 0x05}));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.add_answer(new DNSARR(\"example.com\", 100, {0x02, 0x03, 0x04, 0x05}));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    EXPECT_EQ(ARES_EBADRESP, ares_parse_a_reply(data.data(), (int)len,\n                                                &host, info, &count));\n    EXPECT_EQ(nullptr, host);\n    EXPECT_EQ(ARES_EBADRESP, ares_parse_a_reply(data.data(), (int)len,\n                                                nullptr, info, &count));\n  }\n}",
          "fn_code_pos": [
            [
              267,
              0
            ],
            [
              356,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAReplyAllocFail) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSCnameRR(\"example.com\", 300, \"c.example.com\"))\n    .add_answer(new DNSARR(\"c.example.com\", 500, {0x02, 0x03, 0x04, 0x05}));\n  std::vector<byte> data = pkt.data();\n\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n\n  for (int ii = 1; ii <= 8; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_a_reply(data.data(), (int)data.size(),\n                                              &host, info, &count)) << ii;\n    EXPECT_EQ(nullptr, host);\n  }\n}",
          "fn_code_pos": [
            [
              358,
              0
            ],
            [
              377,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "invalid_rrlen(data)",
          "fn_dec_pos": [
            [
              129,
              20
            ],
            [
              129,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "invalid_rrlen",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            74,
            2
          ],
          [
            74,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            75,
            2
          ],
          [
            75,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            124,
            2
          ],
          [
            124,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            125,
            2
          ],
          [
            125,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            148,
            2
          ],
          [
            148,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            149,
            2
          ],
          [
            149,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            179,
            2
          ],
          [
            179,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            180,
            2
          ],
          [
            180,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            196,
            2
          ],
          [
            196,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            197,
            2
          ],
          [
            197,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            224,
            2
          ],
          [
            224,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            225,
            2
          ],
          [
            225,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            255,
            2
          ],
          [
            255,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            256,
            2
          ],
          [
            256,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            274,
            2
          ],
          [
            274,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            275,
            2
          ],
          [
            275,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            366,
            2
          ],
          [
            366,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            367,
            2
          ],
          [
            367,
            21
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-misc.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(DefaultChannelTest, GetServers) {\n  std::string servers = GetNameServers(channel_);\n  if (verbose) {\n    std::cerr << \"Nameserver: \" << servers << std::endl;\n  }\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              39,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, GetServersFailures) {\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_set_servers_csv(channel_, \"1.2.3.4,2.3.4.5\"));\n  struct ares_addr_node* servers = nullptr;\n  SetAllocFail(1);\n  EXPECT_EQ(ARES_ENOMEM, ares_get_servers(channel_, &servers));\n  SetAllocFail(2);\n  EXPECT_EQ(ARES_ENOMEM, ares_get_servers(channel_, &servers));\n  EXPECT_EQ(ARES_ENODATA, ares_get_servers(nullptr, &servers));\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              50,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SetServers) {\n  /* NOTE: This test is because we have actual external users doing test case\n   *       simulation and removing all servers to generate various error\n   *       conditions in their own code.  It would make more sense to return\n   *       ARES_ENODATA, but due to historical users, we can't break them.\n   *       See: https://github.com/nodejs/node/pull/50800\n   */\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers(channel_, nullptr));\n  std::string expected_empty = \"\";\n  EXPECT_EQ(expected_empty, GetNameServers(channel_));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOSERVER, result.status_);\n\n\n  struct ares_addr_node server1;\n  struct ares_addr_node server2;\n  server1.next = &server2;\n  server1.family = AF_INET;\n  server1.addr.addr4.s_addr = htonl(0x01020304);\n  server2.next = nullptr;\n  server2.family = AF_INET;\n  server2.addr.addr4.s_addr = htonl(0x02030405);\n  EXPECT_EQ(ARES_ENODATA, ares_set_servers(nullptr, &server1));\n\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers(channel_, &server1));\n  std::string expected = \"1.2.3.4:53,2.3.4.5:53\";\n  EXPECT_EQ(expected, GetNameServers(channel_));\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SetServersPorts) {\n  /* NOTE: This test is because we have actual external users doing test case\n   *       simulation and removing all servers to generate various error\n   *       conditions in their own code.  It would make more sense to return\n   *       ARES_ENODATA, but due to historical users, we can't break them.\n   *       See: https://github.com/nodejs/node/pull/50800\n   */\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers_ports(channel_, nullptr));\n  std::string expected_empty = \"\";\n  EXPECT_EQ(expected_empty, GetNameServers(channel_));\n\n  struct ares_addr_port_node server1;\n  struct ares_addr_port_node server2;\n  server1.next = &server2;\n  server1.family = AF_INET;\n  server1.addr.addr4.s_addr = htonl(0x01020304);\n  server1.udp_port = 111;\n  server1.tcp_port = 111;\n  server2.next = nullptr;\n  server2.family = AF_INET;\n  server2.addr.addr4.s_addr = htonl(0x02030405);\n  server2.udp_port = 0;\n  server2.tcp_port = 0;;\n  EXPECT_EQ(ARES_ENODATA, ares_set_servers_ports(nullptr, &server1));\n\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers_ports(channel_, &server1));\n  std::string expected = \"1.2.3.4:111,2.3.4.5:53\";\n  EXPECT_EQ(expected, GetNameServers(channel_));\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SetServersCSV) {\n  EXPECT_EQ(ARES_ENODATA, ares_set_servers_csv(nullptr, \"1.2.3.4\"));\n  EXPECT_EQ(ARES_ENODATA, ares_set_servers_csv(nullptr, \"xyzzy,plugh\"));\n  EXPECT_EQ(ARES_ENODATA, ares_set_servers_csv(nullptr, \"256.1.2.3\"));\n  EXPECT_EQ(ARES_ENODATA, ares_set_servers_csv(nullptr, \"1.2.3.4.5\"));\n  EXPECT_EQ(ARES_ENODATA, ares_set_servers_csv(nullptr, \"1:2:3:4:5\"));\n\n  /* NOTE: This test is because we have actual external users doing test case\n   *       simulation and removing all servers to generate various error\n   *       conditions in their own code.  It would make more sense to return\n   *       ARES_ENODATA, but due to historical users, we can't break them.\n   *       See: https://github.com/nodejs/node/pull/50800\n   */\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers_csv(channel_, NULL));\n  std::string expected_empty = \"\";\n  EXPECT_EQ(expected_empty, GetNameServers(channel_));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers_csv(channel_, \"\"));\n  EXPECT_EQ(expected_empty, GetNameServers(channel_));\n\n\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_set_servers_csv(channel_, \"1.2.3.4,0102:0304:0506:0708:0910:1112:1314:1516,2.3.4.5\"));\n  std::string expected = \"1.2.3.4:53,[102:304:506:708:910:1112:1314:1516]:53,2.3.4.5:53\";\n  EXPECT_EQ(expected, GetNameServers(channel_));\n\n  // Same, with spaces\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_set_servers_csv(channel_, \"1.2.3.4 , [0102:0304:0506:0708:0910:1112:1314:1516]:53, 2.3.4.5\"));\n  EXPECT_EQ(expected, GetNameServers(channel_));\n\n  // Ignore invalid link-local interface, keep rest.\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_set_servers_csv(channel_, \"1.2.3.4 , [0102:0304:0506:0708:0910:1112:1314:1516]:53, [fe80::1]:53%iface0, 2.3.4.5\"));\n  EXPECT_EQ(expected, GetNameServers(channel_));\n\n  // Same, with ports\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_set_servers_ports_csv(channel_, \"1.2.3.4:54,[0102:0304:0506:0708:0910:1112:1314:1516]:80,2.3.4.5:55\"));\n  std::string expected2 = {\"1.2.3.4:54,[102:304:506:708:910:1112:1314:1516]:80,2.3.4.5:55\"};\n  EXPECT_EQ(expected2, GetNameServers(channel_));\n\n  // Should survive duplication\n  ares_channel_t *channel2;\n  EXPECT_EQ(ARES_SUCCESS, ares_dup(&channel2, channel_));\n  EXPECT_EQ(expected2, GetNameServers(channel2));\n  ares_destroy(channel2);\n\n  // Allocation failure cases\n  for (int fail = 1; fail <= 5; fail++) {\n    SetAllocFail(fail);\n    EXPECT_EQ(ARES_ENOMEM,\n              ares_set_servers_csv(channel_, \"1.2.3.4,0102:0304:0506:0708:0910:1112:1314:1516,2.3.4.5\"));\n  }\n\n  EXPECT_EQ(ARES_EBADSTR, ares_set_servers_csv(channel_, \"2.3.4.5,1.2.3.4:,3.4.5.6\"));\n  EXPECT_EQ(ARES_EBADSTR, ares_set_servers_csv(channel_, \"2.3.4.5,1.2.3.4:Z,3.4.5.6\"));\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              170,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, TimeoutValue) {\n  struct timeval tinfo;\n  tinfo.tv_sec = 0;\n  tinfo.tv_usec = 0;\n  struct timeval tmax;\n  tmax.tv_sec = 0;\n  tmax.tv_usec = 10;\n  struct timeval* pt;\n\n  // No timers => get max back.\n  pt = ares_timeout(channel_, &tmax, &tinfo);\n  EXPECT_EQ(&tmax, pt);\n  EXPECT_EQ(0, pt->tv_sec);\n  EXPECT_EQ(10, pt->tv_usec);\n\n  pt = ares_timeout(channel_, nullptr, &tinfo);\n  EXPECT_EQ(nullptr, pt);\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n\n  // Now there's a timer running.\n  pt = ares_timeout(channel_, &tmax, &tinfo);\n  EXPECT_EQ(&tmax, pt);\n  EXPECT_EQ(0, pt->tv_sec);\n  EXPECT_EQ(10, pt->tv_usec);\n\n  tmax.tv_sec = 100;\n  pt = ares_timeout(channel_, &tmax, &tinfo);\n  EXPECT_EQ(&tinfo, pt);\n\n  pt = ares_timeout(channel_, nullptr, &tinfo);\n  EXPECT_EQ(&tinfo, pt);\n\n  Process();\n}",
          "fn_code_pos": [
            [
              172,
              0
            ],
            [
              207,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, InetNtoP) {\n  struct in_addr addr;\n  addr.s_addr = htonl(0x01020304);\n  char buffer[256];\n  EXPECT_EQ(buffer, ares_inet_ntop(AF_INET, &addr, buffer, sizeof(buffer)));\n  EXPECT_EQ(\"1.2.3.4\", std::string(buffer));\n}",
          "fn_code_pos": [
            [
              209,
              0
            ],
            [
              215,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, Mkquery) {\n  byte* p;\n  int len;\n  ares_mkquery(\"example.com\", C_IN, T_A, 0x1234, 0, &p, &len);\n  std::vector<byte> data(p, p + len);\n  ares_free_string(p);\n\n  std::string actual = PacketToString(data);\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).add_question(new DNSQuestion(\"example.com\", T_A));\n  std::string expected = PacketToString(pkt.data());\n  EXPECT_EQ(expected, actual);\n}",
          "fn_code_pos": [
            [
              217,
              0
            ],
            [
              229,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, CreateQuery) {\n  byte* p;\n  int len;\n  // This is hard to really test with escaping since DNS names don't allow\n  // bad characters.  So we'll escape good characters.\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_create_query(\"ex\\\\097m\\\\ple.com\", C_IN, T_A, 0x1234, 0,\n                              &p, &len, 0));\n  std::vector<byte> data(p, p + len);\n  ares_free_string(p);\n\n  std::string actual = PacketToString(data);\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).add_question(new DNSQuestion(\"example.com\", T_A));\n  std::string expected = PacketToString(pkt.data());\n  EXPECT_EQ(expected, actual);\n}",
          "fn_code_pos": [
            [
              231,
              0
            ],
            [
              247,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, CreateQueryTrailingEscapedDot) {\n  byte* p;\n  int len;\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_create_query(\"example.com\\\\.\", C_IN, T_A, 0x1234, 0,\n                              &p, &len, 0));\n  std::vector<byte> data(p, p + len);\n  ares_free_string(p);\n\n  std::string actual = PacketToString(data);\n  EXPECT_EQ(\"REQ QRY  Q:{'example.com\\\\.' IN A}\", actual);\n}",
          "fn_code_pos": [
            [
              249,
              0
            ],
            [
              260,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, CreateQueryNameTooLong) {\n  byte* p;\n  int len;\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_create_query(\n              \"a1234567890123456789.b1234567890123456789.c1234567890123456789.d1234567890123456789.\"\n              \"a1234567890123456789.b1234567890123456789.c1234567890123456789.d1234567890123456789.\"\n              \"a1234567890123456789.b1234567890123456789.c1234567890123456789.d1234567890123456789.\"\n              \"x1234567890123456789.y1234567890123456789.\",\n              C_IN, T_A, 0x1234, 0, &p, &len, 0));\n}",
          "fn_code_pos": [
            [
              262,
              0
            ],
            [
              272,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, CreateQueryFailures) {\n  byte* p;\n  int len;\n  // RC1035 has a 255 byte limit on names.\n  std::string longname;\n  for (int ii = 0; ii < 17; ii++) {\n    longname += \"fedcba9876543210\";\n  }\n  p = nullptr;\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_create_query(longname.c_str(), C_IN, T_A, 0x1234, 0,\n                    &p, &len, 0));\n  if (p) ares_free_string(p);\n\n  SetAllocFail(1);\n\n  p = nullptr;\n  EXPECT_EQ(ARES_ENOMEM,\n            ares_create_query(\"example.com\", C_IN, T_A, 0x1234, 0,\n                    &p, &len, 0));\n  if (p) ares_free_string(p);\n\n  // 63-char limit on a single label\n  std::string longlabel = \"a.a123456789b123456789c123456789d123456789e123456789f123456789g123456789.org\";\n  p = nullptr;\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_create_query(longlabel.c_str(), C_IN, T_A, 0x1234, 0,\n                    &p, &len, 0));\n  if (p) ares_free_string(p);\n\n  // Empty non-terminal label\n  p = nullptr;\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_create_query(\"example..com\", C_IN, T_A, 0x1234, 0,\n                    &p, &len, 0));\n  if (p) ares_free_string(p);\n}",
          "fn_code_pos": [
            [
              274,
              0
            ],
            [
              310,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, CreateQueryOnionDomain) {\n  byte* p;\n  int len;\n  EXPECT_EQ(ARES_ENOTFOUND,\n            ares_create_query(\"dontleak.onion\", C_IN, T_A, 0x1234, 0,\n                              &p, &len, 0));\n}",
          "fn_code_pos": [
            [
              312,
              0
            ],
            [
              318,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, HostByNameOnionDomain) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"dontleak.onion\", AF_INET, HostCallback, &result);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTFOUND, result.status_);\n}",
          "fn_code_pos": [
            [
              320,
              0
            ],
            [
              325,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, HostByNameFileOnionDomain) {\n  struct hostent *h;\n  EXPECT_EQ(ARES_ENOTFOUND,\n            ares_gethostbyname_file(channel_, \"dontleak.onion\", AF_INET, &h));\n}",
          "fn_code_pos": [
            [
              327,
              0
            ],
            [
              331,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, GetAddrinfoOnionDomain) {\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_UNSPEC;\n  ares_getaddrinfo(channel_, \"dontleak.onion\", NULL, &hints, AddrInfoCallback, &result);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTFOUND, result.status_);\n}",
          "fn_code_pos": [
            [
              333,
              0
            ],
            [
              340,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SearchOnionDomain) {\n  SearchResult result;\n  ares_search(channel_, \"dontleak.onion\", C_IN, T_A,\n              SearchCallback, &result);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTFOUND, result.status_);\n}",
          "fn_code_pos": [
            [
              345,
              0
            ],
            [
              351,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SendFailure) {\n  unsigned char buf[2] = {};\n  SearchResult result;\n  ares_send(channel_, buf, sizeof(buf), SearchCallback, &result);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EBADQUERY, result.status_);\n}",
          "fn_code_pos": [
            [
              353,
              0
            ],
            [
              359,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static std::string ExpandName(const std::vector<byte>& data, int offset,\n                              long *enclen) {\n  char *name = nullptr;\n  int rc = ares_expand_name(data.data() + offset, data.data(), (int)data.size(),\n                            &name, enclen);\n  EXPECT_EQ(ARES_SUCCESS, rc);\n  std::string result;\n  if (rc == ARES_SUCCESS) {\n    result = name;\n  } else {\n    result = \"<error>\";\n  }\n  ares_free_string(name);\n  return result;\n}",
          "fn_code_pos": [
            [
              361,
              0
            ],
            [
              375,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExpandName",
            "parameters": {
              "data": "std::vector<byte>",
              "offset": "int",
              "enclen": "long"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ExpandName) {\n  long enclen;\n  std::vector<byte> data1 = {1, 'a', 2, 'b', 'c', 3, 'd', 'e', 'f', 0};\n  EXPECT_EQ(\"a.bc.def\", ExpandName(data1, 0, &enclen));\n  EXPECT_EQ(data1.size(), (size_t)enclen);\n\n  std::vector<byte> data2 = {0};\n  EXPECT_EQ(\"\", ExpandName(data2, 0, &enclen));\n  EXPECT_EQ(1, enclen);\n\n  // Complete name indirection\n  std::vector<byte> data3 = {0x12, 0x23,\n                             3, 'd', 'e', 'f', 0,\n                             0xC0, 2};\n  EXPECT_EQ(\"def\", ExpandName(data3, 2, &enclen));\n  EXPECT_EQ(5, enclen);\n  EXPECT_EQ(\"def\", ExpandName(data3, 7, &enclen));\n  EXPECT_EQ(2, enclen);\n\n  // One label then indirection\n  std::vector<byte> data4 = {0x12, 0x23,\n                             3, 'd', 'e', 'f', 0,\n                             1, 'a', 0xC0, 2};\n  EXPECT_EQ(\"def\", ExpandName(data4, 2, &enclen));\n  EXPECT_EQ(5, enclen);\n  EXPECT_EQ(\"a.def\", ExpandName(data4, 7, &enclen));\n  EXPECT_EQ(4, enclen);\n\n  // Two labels then indirection\n  std::vector<byte> data5 = {0x12, 0x23,\n                             3, 'd', 'e', 'f', 0,\n                             1, 'a', 1, 'b', 0xC0, 2};\n  EXPECT_EQ(\"def\", ExpandName(data5, 2, &enclen));\n  EXPECT_EQ(5, enclen);\n  EXPECT_EQ(\"a.b.def\", ExpandName(data5, 7, &enclen));\n  EXPECT_EQ(6, enclen);\n\n  // Empty name, indirection to empty name\n  std::vector<byte> data6 = {0x12, 0x23,\n                             0,\n                             0xC0, 2};\n  EXPECT_EQ(\"\", ExpandName(data6, 2, &enclen));\n  EXPECT_EQ(1, enclen);\n  EXPECT_EQ(\"\", ExpandName(data6, 3, &enclen));\n  EXPECT_EQ(2, enclen);\n}",
          "fn_code_pos": [
            [
              377,
              0
            ],
            [
              422,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ExpandNameFailure) {\n  std::vector<byte> data1 = {0x03, 'c', 'o', 'm', 0x00};\n  char *name = nullptr;\n  long enclen;\n  SetAllocFail(1);\n  EXPECT_EQ(ARES_ENOMEM,\n            ares_expand_name(data1.data(), data1.data(), (int)data1.size(),\n                             &name, &enclen));\n\n  // Empty packet\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data1.data(), data1.data(), 0, &name, &enclen));\n\n  // Start beyond enclosing data\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data1.data() + data1.size(), data1.data(), (int)data1.size(),\n                             &name, &enclen));\n\n  // Length beyond size of enclosing data\n  std::vector<byte> data2a = {0x13, 'c', 'o', 'm', 0x00};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data2a.data(), data2a.data(), (int)data2a.size(),\n                             &name, &enclen));\n  std::vector<byte> data2b = {0x1};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data2b.data(), data2b.data(), (int)data2b.size(),\n                             &name, &enclen));\n  std::vector<byte> data2c = {0xC0};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data2c.data(), data2c.data(), (int)data2c.size(),\n                             &name, &enclen));\n\n  // Indirection beyond enclosing data\n  std::vector<byte> data3a = {0xC0, 0x02};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data3a.data(), data3a.data(), (int)data3a.size(),\n                             &name, &enclen));\n  std::vector<byte> data3b = {0xC0, 0x0A, 'c', 'o', 'm', 0x00};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data3b.data(), data3b.data(), (int)data3b.size(),\n                             &name, &enclen));\n\n  // Invalid top bits in label length\n  std::vector<byte> data4 = {0x03, 'c', 'o', 'm', 0x00, 0x80, 0x00};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data4.data() + 5, data4.data(), (int)data4.size(),\n                             &name, &enclen));\n\n  // Label too long: 64-byte label, with invalid top 2 bits of length (01).\n  std::vector<byte> data5 = {0x40,\n                             '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',\n                             '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',\n                             '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',\n                             '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',\n                             0x00};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data5.data(), data5.data(), (int)data5.size(),\n                             &name, &enclen)) << name;\n\n  // Incomplete indirect length\n  std::vector<byte> data6 = {0x03, 'c', 'o', 'm', 0x00, 0xC0};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data6.data() + 5, data6.data(), (int)data6.size(),\n                             &name, &enclen));\n\n  // Indirection loops\n  std::vector<byte> data7 = {0xC0, 0x02, 0xC0, 0x00};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data7.data(), data7.data(), (int)data7.size(),\n                             &name, &enclen));\n  std::vector<byte> data8 = {3, 'd', 'e', 'f', 0xC0, 0x08, 0x00, 0x00,\n                             3, 'a', 'b', 'c', 0xC0, 0x00};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data8.data(), data8.data(), (int)data8.size(),\n                             &name, &enclen));\n  std::vector<byte> data9 = {0x12, 0x23,  // start 2 bytes in\n                             3, 'd', 'e', 'f', 0xC0, 0x02};\n  EXPECT_EQ(ARES_EBADNAME,\n            ares_expand_name(data9.data() + 2, data9.data(), (int)data9.size(),\n                             &name, &enclen));\n}",
          "fn_code_pos": [
            [
              424,
              0
            ],
            [
              504,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, CreateEDNSQuery) {\n  byte* p;\n  int len;\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_create_query(\"example.com\", C_IN, T_A, 0x1234, 0,\n                              &p, &len, 1280));\n  std::vector<byte> data(p, p + len);\n  ares_free_string(p);\n\n  std::string actual = PacketToString(data);\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_additional(new DNSOptRR(0, 1280));\n  std::string expected = PacketToString(pkt.data());\n  EXPECT_EQ(expected, actual);\n}",
          "fn_code_pos": [
            [
              506,
              0
            ],
            [
              521,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, CreateRootQuery) {\n  byte* p;\n  int len;\n  ares_create_query(\".\", C_IN, T_A, 0x1234, 0, &p, &len, 0);\n  std::vector<byte> data(p, p + len);\n  ares_free_string(p);\n\n  std::string actual = PacketToString(data);\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).add_question(new DNSQuestion(\"\", T_A));\n  std::string expected = PacketToString(pkt.data());\n  EXPECT_EQ(expected, actual);\n}",
          "fn_code_pos": [
            [
              523,
              0
            ],
            [
              535,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, Version) {\n  // Assume linked to same version\n  EXPECT_EQ(std::string(ARES_VERSION_STR),\n            std::string(ares_version(nullptr)));\n  int version;\n  ares_version(&version);\n  EXPECT_EQ(ARES_VERSION, version);\n}",
          "fn_code_pos": [
            [
              537,
              0
            ],
            [
              544,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, Strerror) {\n  EXPECT_EQ(\"Successful completion\",\n            std::string(ares_strerror(ARES_SUCCESS)));\n  EXPECT_EQ(\"DNS query cancelled\",\n            std::string(ares_strerror(ARES_ECANCELLED)));\n  EXPECT_EQ(\"unknown\",\n            std::string(ares_strerror(99)));\n}",
          "fn_code_pos": [
            [
              546,
              0
            ],
            [
              553,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ExpandString) {\n  std::vector<byte> s1 = { 3, 'a', 'b', 'c'};\n  char* result = nullptr;\n  long len;\n  EXPECT_EQ(ARES_SUCCESS,\n            ares_expand_string(s1.data(), s1.data(), (int)s1.size(),\n                               (unsigned char**)&result, &len));\n  EXPECT_EQ(\"abc\", std::string(result));\n  EXPECT_EQ(1 + 3, len);  // amount of data consumed includes 1 byte len\n  ares_free_string(result);\n  result = nullptr;\n  EXPECT_EQ(ARES_EBADSTR,\n            ares_expand_string(s1.data() + 1, s1.data(), (int)s1.size(),\n                               (unsigned char**)&result, &len));\n  EXPECT_EQ(ARES_EBADSTR,\n            ares_expand_string(s1.data() + 4, s1.data(), (int)s1.size(),\n                               (unsigned char**)&result, &len));\n  SetAllocFail(1);\n  EXPECT_EQ(ARES_ENOMEM,\n            ares_expand_string(s1.data(), s1.data(), (int)s1.size(),\n                               (unsigned char**)&result, &len));\n}",
          "fn_code_pos": [
            [
              555,
              0
            ],
            [
              576,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_addr_node",
          {},
          "",
          [
            44,
            2
          ],
          [
            44,
            23
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            69,
            2
          ],
          [
            69,
            23
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            70,
            2
          ],
          [
            70,
            23
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            95,
            2
          ],
          [
            95,
            28
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            96,
            2
          ],
          [
            96,
            28
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            173,
            2
          ],
          [
            173,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            176,
            2
          ],
          [
            176,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            179,
            2
          ],
          [
            179,
            16
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            210,
            2
          ],
          [
            210,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            328,
            2
          ],
          [
            328,
            16
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            335,
            2
          ],
          [
            335,
            28
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-parse-srv.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseSrvReplyOK) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_SRV))\n    .add_answer(new DNSSrvRR(\"example.com\", 100, 10, 20, 30, \"srv.example.com\"))\n    .add_answer(new DNSSrvRR(\"example.com\", 100, 11, 21, 31, \"srv2.example.com\"));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_srv_reply* srv = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_srv_reply(data.data(), (int)data.size(), &srv));\n  ASSERT_NE(nullptr, srv);\n\n  EXPECT_EQ(\"srv.example.com\", std::string(srv->host));\n  EXPECT_EQ(10, srv->priority);\n  EXPECT_EQ(20, srv->weight);\n  EXPECT_EQ(30, srv->port);\n\n  struct ares_srv_reply* srv2 = srv->next;\n  ASSERT_NE(nullptr, srv2);\n  EXPECT_EQ(\"srv2.example.com\", std::string(srv2->host));\n  EXPECT_EQ(11, srv2->priority);\n  EXPECT_EQ(21, srv2->weight);\n  EXPECT_EQ(31, srv2->port);\n  EXPECT_EQ(nullptr, srv2->next);\n\n  ares_free_data(srv);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSrvReplySingle) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.abc.def.com\", T_SRV))\n    .add_answer(new DNSSrvRR(\"example.abc.def.com\", 180, 0, 10, 8160, \"example.abc.def.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else1.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else2.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else3.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else4.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else5.where.com\"))\n    .add_additional(new DNSARR(\"else2.where.com\", 42, {172,19,0,1}))\n    .add_additional(new DNSARR(\"else5.where.com\", 42, {172,19,0,2}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_srv_reply* srv = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_srv_reply(data.data(), (int)data.size(), &srv));\n  ASSERT_NE(nullptr, srv);\n\n  EXPECT_EQ(\"example.abc.def.com\", std::string(srv->host));\n  EXPECT_EQ(0, srv->priority);\n  EXPECT_EQ(10, srv->weight);\n  EXPECT_EQ(8160, srv->port);\n  EXPECT_EQ(nullptr, srv->next);\n\n  ares_free_data(srv);\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSrvReplyMalformed) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x21,  // type SRV\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x21,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x04,  // rdata length -- too short\n    0x02, 0x03, 0x04, 0x05,\n  };\n\n  struct ares_srv_reply* srv = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_srv_reply(data.data(), (int)data.size(), &srv));\n  ASSERT_EQ(nullptr, srv);\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSrvReplyMultiple) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_ra().set_rd()\n    .add_question(new DNSQuestion(\"srv.example.com\", T_SRV))\n    .add_answer(new DNSSrvRR(\"srv.example.com\", 300, 0, 5, 6789, \"a1.srv.example.com\"))\n    .add_answer(new DNSSrvRR(\"srv.example.com\", 300, 0, 5, 4567, \"a2.srv.example.com\"))\n    .add_answer(new DNSSrvRR(\"srv.example.com\", 300, 0, 5, 5678, \"a3.srv.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns1.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns2.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns3.example.com\"))\n    .add_additional(new DNSARR(\"a1.srv.example.com\", 300, {172,19,1,1}))\n    .add_additional(new DNSARR(\"a2.srv.example.com\", 300, {172,19,1,2}))\n    .add_additional(new DNSARR(\"a3.srv.example.com\", 300, {172,19,1,3}))\n    .add_additional(new DNSARR(\"n1.example.com\", 300, {172,19,0,1}))\n    .add_additional(new DNSARR(\"n2.example.com\", 300, {172,19,0,2}))\n    .add_additional(new DNSARR(\"n3.example.com\", 300, {172,19,0,3}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_srv_reply* srv0 = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_srv_reply(data.data(), (int)data.size(), &srv0));\n  ASSERT_NE(nullptr, srv0);\n  struct ares_srv_reply* srv = srv0;\n\n  EXPECT_EQ(\"a1.srv.example.com\", std::string(srv->host));\n  EXPECT_EQ(0, srv->priority);\n  EXPECT_EQ(5, srv->weight);\n  EXPECT_EQ(6789, srv->port);\n  EXPECT_NE(nullptr, srv->next);\n  srv = srv->next;\n\n  EXPECT_EQ(\"a2.srv.example.com\", std::string(srv->host));\n  EXPECT_EQ(0, srv->priority);\n  EXPECT_EQ(5, srv->weight);\n  EXPECT_EQ(4567, srv->port);\n  EXPECT_NE(nullptr, srv->next);\n  srv = srv->next;\n\n  EXPECT_EQ(\"a3.srv.example.com\", std::string(srv->host));\n  EXPECT_EQ(0, srv->priority);\n  EXPECT_EQ(5, srv->weight);\n  EXPECT_EQ(5678, srv->port);\n  EXPECT_EQ(nullptr, srv->next);\n\n  ares_free_data(srv0);\n}",
          "fn_code_pos": [
            [
              120,
              0
            ],
            [
              164,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSrvReplyCname) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.abc.def.com\", T_SRV))\n    .add_answer(new DNSCnameRR(\"example.abc.def.com\", 300, \"cname.abc.def.com\"))\n    .add_answer(new DNSSrvRR(\"cname.abc.def.com\", 300, 0, 10, 1234, \"srv.abc.def.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else1.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else2.where.com\"))\n    .add_auth(new DNSNsRR(\"abc.def.com\", 44, \"else3.where.com\"))\n    .add_additional(new DNSARR(\"example.abc.def.com\", 300, {172,19,0,1}))\n    .add_additional(new DNSARR(\"else1.where.com\", 42, {172,19,0,1}))\n    .add_additional(new DNSARR(\"else2.where.com\", 42, {172,19,0,2}))\n    .add_additional(new DNSARR(\"else3.where.com\", 42, {172,19,0,3}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_srv_reply* srv = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_srv_reply(data.data(), (int)data.size(), &srv));\n  ASSERT_NE(nullptr, srv);\n\n  EXPECT_EQ(\"srv.abc.def.com\", std::string(srv->host));\n  EXPECT_EQ(0, srv->priority);\n  EXPECT_EQ(10, srv->weight);\n  EXPECT_EQ(1234, srv->port);\n  EXPECT_EQ(nullptr, srv->next);\n\n  ares_free_data(srv);\n}",
          "fn_code_pos": [
            [
              166,
              0
            ],
            [
              192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSrvReplyCnameMultiple) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_ra().set_rd()\n    .add_question(new DNSQuestion(\"query.example.com\", T_SRV))\n    .add_answer(new DNSCnameRR(\"query.example.com\", 300, \"srv.example.com\"))\n    .add_answer(new DNSSrvRR(\"srv.example.com\", 300, 0, 5, 6789, \"a1.srv.example.com\"))\n    .add_answer(new DNSSrvRR(\"srv.example.com\", 300, 0, 5, 4567, \"a2.srv.example.com\"))\n    .add_answer(new DNSSrvRR(\"srv.example.com\", 300, 0, 5, 5678, \"a3.srv.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns1.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns2.example.com\"))\n    .add_auth(new DNSNsRR(\"example.com\", 300, \"ns3.example.com\"))\n    .add_additional(new DNSARR(\"a1.srv.example.com\", 300, {172,19,1,1}))\n    .add_additional(new DNSARR(\"a2.srv.example.com\", 300, {172,19,1,2}))\n    .add_additional(new DNSARR(\"a3.srv.example.com\", 300, {172,19,1,3}))\n    .add_additional(new DNSARR(\"n1.example.com\", 300, {172,19,0,1}))\n    .add_additional(new DNSARR(\"n2.example.com\", 300, {172,19,0,2}))\n    .add_additional(new DNSARR(\"n3.example.com\", 300, {172,19,0,3}));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_srv_reply* srv0 = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_srv_reply(data.data(), (int)data.size(), &srv0));\n  ASSERT_NE(nullptr, srv0);\n  struct ares_srv_reply* srv = srv0;\n\n  EXPECT_EQ(\"a1.srv.example.com\", std::string(srv->host));\n  EXPECT_EQ(0, srv->priority);\n  EXPECT_EQ(5, srv->weight);\n  EXPECT_EQ(6789, srv->port);\n  EXPECT_NE(nullptr, srv->next);\n  srv = srv->next;\n\n  EXPECT_EQ(\"a2.srv.example.com\", std::string(srv->host));\n  EXPECT_EQ(0, srv->priority);\n  EXPECT_EQ(5, srv->weight);\n  EXPECT_EQ(4567, srv->port);\n  EXPECT_NE(nullptr, srv->next);\n  srv = srv->next;\n\n  EXPECT_EQ(\"a3.srv.example.com\", std::string(srv->host));\n  EXPECT_EQ(0, srv->priority);\n  EXPECT_EQ(5, srv->weight);\n  EXPECT_EQ(5678, srv->port);\n  EXPECT_EQ(nullptr, srv->next);\n\n  ares_free_data(srv0);\n}",
          "fn_code_pos": [
            [
              194,
              0
            ],
            [
              239,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSrvReplyErrors) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.abc.def.com\", T_SRV))\n    .add_answer(new DNSSrvRR(\"example.abc.def.com\", 180, 0, 10, 8160, \"example.abc.def.com\"));\n  std::vector<byte> data;\n  struct ares_srv_reply* srv = nullptr;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_srv_reply(data.data(), (int)data.size(), &srv));\n  pkt.add_question(new DNSQuestion(\"example.abc.def.com\", T_SRV));\n\n#ifdef DISABLED\n  // Question != answer\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_SRV));\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_srv_reply(data.data(), (int)data.size(), &srv));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_SRV));\n#endif\n\n  // Two questions.\n  pkt.add_question(new DNSQuestion(\"example.abc.def.com\", T_SRV));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_srv_reply(data.data(), (int)data.size(), &srv));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR));\n\n  // Wrong sort of answer.\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_srv_reply(data.data(), (int)data.size(), &srv));\n  EXPECT_EQ(nullptr, srv);\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSSrvRR(\"example.abc.def.com\", 180, 0, 10, 8160, \"example.abc.def.com\"));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_srv_reply(data.data(), (int)data.size(), &srv));\n  pkt.add_answer(new DNSSrvRR(\"example.abc.def.com\", 180, 0, 10, 8160, \"example.abc.def.com\"));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    int rc = ares_parse_srv_reply(data.data(), (int)len, &srv);\n    EXPECT_TRUE(rc == ARES_EBADRESP || rc == ARES_EBADNAME);\n  }\n}",
          "fn_code_pos": [
            [
              241,
              0
            ],
            [
              293,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSrvReplyAllocFail) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.abc.def.com\", T_SRV))\n    .add_answer(new DNSCnameRR(\"example.com\", 300, \"c.example.com\"))\n    .add_answer(new DNSSrvRR(\"example.abc.def.com\", 180, 0, 10, 8160, \"example.abc.def.com\"));\n  std::vector<byte> data = pkt.data();\n  struct ares_srv_reply* srv = nullptr;\n\n  for (int ii = 1; ii <= 5; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_srv_reply(data.data(), (int)data.size(), &srv)) << ii;\n  }\n}",
          "fn_code_pos": [
            [
              295,
              0
            ],
            [
              309,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            42,
            2
          ],
          [
            42,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            51,
            2
          ],
          [
            51,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            76,
            2
          ],
          [
            76,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            115,
            2
          ],
          [
            115,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            138,
            2
          ],
          [
            138,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            141,
            2
          ],
          [
            141,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            181,
            2
          ],
          [
            181,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            213,
            2
          ],
          [
            213,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            216,
            2
          ],
          [
            216,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            247,
            2
          ],
          [
            247,
            23
          ]
        ],
        [
          "struct ares_srv_reply",
          {},
          "",
          [
            302,
            2
          ],
          [
            302,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/dns-dump.cc": {
      "fn_def_list": [
        {
          "fn_code": "static void ShowFile(const char* filename) {\n  int fd = open(filename, O_RDONLY);\n  if (fd < 0) {\n    std::cerr << \"Failed to open '\" << filename << \"'\" << std::endl;\n    return;\n  }\n  std::vector<unsigned char> contents;\n  while (true) {\n    unsigned char buffer[1024];\n    ares_ssize_t len = read(fd, buffer, sizeof(buffer));\n    if (len <= 0) break;\n    contents.insert(contents.end(), buffer, buffer + len);\n  }\n  std::cout << PacketToString(contents) << std::endl;\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ShowFile",
            "parameters": {
              "filename": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(int argc, char* argv[]) {\n  for (int ii = 1; ii < argc; ++ii) {\n    ares::ShowFile(argv[ii]);\n  }\n  return 0;\n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <sys/types.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#  include <io.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <unistd.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <iostream>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-parse-aaaa.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseAaaaReplyOK) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,\n                               0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04}))\n    .add_answer(new DNSARR(\"example.com\", 0x01020304, {2,3,4,5}));\n  std::vector<byte> data = pkt.data();\n  struct hostent *host = nullptr;\n  struct ares_addr6ttl info[5];\n  int count = 5;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                &host, info, &count));\n  EXPECT_EQ(1, count);\n  EXPECT_EQ(100, info[0].ttl);\n  EXPECT_EQ(0x01, info[0].ip6addr._S6_un._S6_u8[0]);\n  EXPECT_EQ(0x02, info[0].ip6addr._S6_un._S6_u8[4]);\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'example.com' aliases=[] addrs=[0101:0101:0202:0202:0303:0303:0404:0404]}\", ss.str());\n  ares_free_hostent(host);\n\n  // Repeat without providing places to put the results\n  count = 0;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                nullptr, info, &count));\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              62,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAaaaReplyCname) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSCnameRR(\"example.com\", 50, \"c.example.com\"))\n    .add_answer(new DNSAaaaRR(\"c.example.com\", 100,\n                              {0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,\n                               0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04}));\n  std::vector<byte> data = pkt.data();\n  struct hostent *host = nullptr;\n  struct ares_addr6ttl info[5];\n  int count = 5;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                &host, info, &count));\n  EXPECT_EQ(1, count);\n  // CNAME TTL overrides AAAA TTL.\n  EXPECT_EQ(50, info[0].ttl);\n  EXPECT_EQ(0x01, info[0].ip6addr._S6_un._S6_u8[0]);\n  EXPECT_EQ(0x02, info[0].ip6addr._S6_un._S6_u8[4]);\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'c.example.com' aliases=[example.com] addrs=[0101:0101:0202:0202:0303:0303:0404:0404]}\", ss.str());\n  ares_free_hostent(host);\n\n  // Repeat without providing a hostent\n  count = 5;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                nullptr, info, &count));\n  EXPECT_EQ(1, count);\n  EXPECT_EQ(50, info[0].ttl);\n  EXPECT_EQ(0x01, info[0].ip6addr._S6_un._S6_u8[0]);\n  EXPECT_EQ(0x02, info[0].ip6addr._S6_un._S6_u8[4]);\n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAaaaReplyNoData) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA));\n  std::vector<byte> data = pkt.data();\n  struct hostent *host = nullptr;\n  struct ares_addr6ttl info[2];\n  int count = 2;\n  EXPECT_EQ(ARES_ENODATA, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                &host, info, &count));\n  EXPECT_EQ(0, count);\n  EXPECT_EQ(nullptr, host);\n\n  // Again but with a CNAME.\n  pkt.add_answer(new DNSCnameRR(\"example.com\", 200, \"c.example.com\"));\n  EXPECT_EQ(ARES_ENODATA, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                &host, info, &count));\n  EXPECT_EQ(0, count);\n  EXPECT_EQ(nullptr, host);\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAaaaReplyErrors) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,\n                               0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04}));\n  std::vector<byte> data;\n\n  struct hostent *host = nullptr;\n  struct ares_addr6ttl info[2];\n  int count = 2;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                 &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.add_question(new DNSQuestion(\"example.com\", T_AAAA));\n\n  // Question != answer, this is ok as of Issue #683\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_AAAA));\n  data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                &host, info, &count));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'Axample.com' aliases=[] addrs=[0101:0101:0202:0202:0303:0303:0404:0404]}\", ss.str());\n  ares_free_hostent(host);\n\n  host = nullptr;\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_AAAA));\n\n  // Two questions.\n  pkt.add_question(new DNSQuestion(\"example.com\", T_AAAA));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                 &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_AAAA));\n\n  // Wrong sort of answer.\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,\n                               0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04}));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                &host, info, &count));\n  EXPECT_EQ(nullptr, host);\n  pkt.add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,\n                               0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04}));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    EXPECT_EQ(ARES_EBADRESP, ares_parse_aaaa_reply(data.data(), (int)len,\n                                                   &host, info, &count));\n    EXPECT_EQ(nullptr, host);\n    EXPECT_EQ(ARES_EBADRESP, ares_parse_aaaa_reply(data.data(), (int)len,\n                                                   nullptr, info, &count));\n  }\n}",
          "fn_code_pos": [
            [
              120,
              0
            ],
            [
              197,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseAaaaReplyAllocFail) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSCnameRR(\"example.com\", 300, \"c.example.com\"))\n    .add_answer(new DNSAaaaRR(\"c.example.com\", 100,\n                              {0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,\n                               0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04}));\n  std::vector<byte> data = pkt.data();\n  struct hostent *host = nullptr;\n  struct ares_addr6ttl info[2];\n  int count = 2;\n\n  for (int ii = 1; ii <= 8; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_aaaa_reply(data.data(), (int)data.size(),\n                                                 &host, info, &count)) << ii;\n    EXPECT_EQ(nullptr, host);\n  }\n}",
          "fn_code_pos": [
            [
              199,
              0
            ],
            [
              219,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            43,
            2
          ],
          [
            43,
            16
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            44,
            2
          ],
          [
            44,
            22
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            73,
            2
          ],
          [
            73,
            16
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            74,
            2
          ],
          [
            74,
            22
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            104,
            2
          ],
          [
            104,
            16
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            105,
            2
          ],
          [
            105,
            22
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            129,
            2
          ],
          [
            129,
            16
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            130,
            2
          ],
          [
            130,
            22
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            208,
            2
          ],
          [
            208,
            16
          ]
        ],
        [
          "struct ares_addr6ttl",
          {},
          "",
          [
            209,
            2
          ],
          [
            209,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-mock-ai.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_P(MockUDPChannelTestAI, GetAddrInfoParallelLookups) {\n  DNSPacket rsp1;\n  rsp1.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp1));\n  DNSPacket rsp2;\n  rsp2.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {1, 2, 3, 4}));\n  ON_CALL(server_, OnRequest(\"www.example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp2));\n\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  AddrInfoResult result1;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result1);\n  AddrInfoResult result2;\n  ares_getaddrinfo(channel_, \"www.example.com.\", NULL, &hints, AddrInfoCallback, &result2);\n  AddrInfoResult result3;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result3);\n  Process();\n\n  EXPECT_TRUE(result1.done_);\n  EXPECT_EQ(result1.status_, ARES_SUCCESS);\n  EXPECT_THAT(result1.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result1.ai_, IncludesV4Address(\"2.3.4.5\"));\n\n  EXPECT_TRUE(result2.done_);\n  EXPECT_EQ(result2.status_, ARES_SUCCESS);\n  EXPECT_THAT(result2.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result2.ai_, IncludesV4Address(\"1.2.3.4\"));\n\n  EXPECT_TRUE(result3.done_);\n  EXPECT_EQ(result3.status_, ARES_SUCCESS);\n  EXPECT_THAT(result3.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result3.ai_, IncludesV4Address(\"2.3.4.5\"));\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              128,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPChannelTestAI, TruncationRetry) {\n  DNSPacket rsptruncated;\n  rsptruncated.set_response().set_aa().set_tc()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  DNSPacket rspok;\n  rspok.set_response()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {1, 2, 3, 4}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsptruncated))\n    .WillOnce(SetReply(&server_, &rspok));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(result.status_, ARES_SUCCESS);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"1.2.3.4\"));\n}",
          "fn_code_pos": [
            [
              131,
              0
            ],
            [
              153,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTestAI, MalformedResponse) {\n  std::vector<byte> one = {0x01};\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReplyData(&server_, one));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ETIMEOUT, result.status_);\n}",
          "fn_code_pos": [
            [
              155,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTestAI, FormErrResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(FORMERR);\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EFORMERR, result.status_);\n}",
          "fn_code_pos": [
            [
              170,
              0
            ],
            [
              186,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTestAI, ServFailResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(SERVFAIL);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ESERVFAIL, result.status_);\n}",
          "fn_code_pos": [
            [
              188,
              0
            ],
            [
              204,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTestAI, NotImplResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(NOTIMP);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              206,
              0
            ],
            [
              222,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTestAI, RefusedResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(REFUSED);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EREFUSED, result.status_);\n}",
          "fn_code_pos": [
            [
              224,
              0
            ],
            [
              240,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPChannelTestAI, YXDomainResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(YXDOMAIN);\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENODATA, result.status_);\n}",
          "fn_code_pos": [
            [
              242,
              0
            ],
            [
              258,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockExtraOptsTestAI()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second,\n                          FillOptions(&opts_),\n                          ARES_OPT_SOCK_SNDBUF|ARES_OPT_SOCK_RCVBUF) {}",
          "fn_code_pos": [
            [
              264,
              2
            ],
            [
              267,
              71
            ]
          ],
          "class_code": "c95b595af7352b9b702cef7886a1e35d2c8ec040f08a6f9b59688b57254dec0e",
          "class_node_pos": [
            [
              260,
              0
            ],
            [
              277,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockExtraOptsTestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    // Set a few options that affect socket communications\n    opts->socket_send_buffer_size = 514;\n    opts->socket_receive_buffer_size = 514;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              268,
              2
            ],
            [
              274,
              3
            ]
          ],
          "class_code": "c95b595af7352b9b702cef7886a1e35d2c8ec040f08a6f9b59688b57254dec0e",
          "class_node_pos": [
            [
              260,
              0
            ],
            [
              277,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockExtraOptsTestAI, SimpleQuery) {\n  ares_set_local_ip4(channel_, 0x7F000001);\n  byte addr6[16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};\n  ares_set_local_ip6(channel_, addr6);\n  ares_set_local_dev(channel_, \"dummy\");\n\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"2.3.4.5\"));\n}",
          "fn_code_pos": [
            [
              279,
              0
            ],
            [
              303,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockExtraOptsNDotsTestAI(int ndots)\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second,\n                          FillOptions(&opts_, ndots),\n                          ARES_OPT_SOCK_SNDBUF|ARES_OPT_SOCK_RCVBUF|ARES_OPT_NDOTS) {}",
          "fn_code_pos": [
            [
              309,
              2
            ],
            [
              312,
              86
            ]
          ],
          "class_code": "7e1042e3421fc4fc018ef6de7b3c455f0ccd92d1487578f934ed027a39ab4c40",
          "class_node_pos": [
            [
              305,
              0
            ],
            [
              323,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockExtraOptsNDotsTestAI",
            "parameters": {
              "ndots": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts, int ndots) {\n    memset(opts, 0, sizeof(struct ares_options));\n    // Set a few options that affect socket communications\n    opts->socket_send_buffer_size = 514;\n    opts->socket_receive_buffer_size = 514;\n    opts->ndots = ndots;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              313,
              2
            ],
            [
              320,
              3
            ]
          ],
          "class_code": "7e1042e3421fc4fc018ef6de7b3c455f0ccd92d1487578f934ed027a39ab4c40",
          "class_node_pos": [
            [
              305,
              0
            ],
            [
              323,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options",
              "ndots": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "MockExtraOptsNDots5TestAI() : MockExtraOptsNDotsTestAI(5) {}",
          "fn_code_pos": [
            [
              327,
              2
            ],
            [
              327,
              62
            ]
          ],
          "class_code": "329d50ae96af8d0ff6e553e3b3b64d42479f49c102234b0a78ed8afdf85f80f4",
          "class_node_pos": [
            [
              325,
              0
            ],
            [
              328,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockExtraOptsNDots5TestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockExtraOptsNDots5TestAI, SimpleQuery) {\n  ares_set_local_ip4(channel_, 0x7F000001);\n  byte addr6[16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};\n  ares_set_local_ip6(channel_, addr6);\n  ares_set_local_dev(channel_, \"dummy\");\n\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"dynamodb.us-east-1.amazonaws.com\", T_A))\n    .add_answer(new DNSARR(\"dynamodb.us-east-1.amazonaws.com\", 100, {123, 45, 67, 8}));\n  ON_CALL(server_, OnRequest(\"dynamodb.us-east-1.amazonaws.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"dynamodb.us-east-1.amazonaws.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"123.45.67.8\"));\n}",
          "fn_code_pos": [
            [
              330,
              0
            ],
            [
              354,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockExtraOptsNDots0TestAI() : MockExtraOptsNDotsTestAI(0) {}",
          "fn_code_pos": [
            [
              358,
              2
            ],
            [
              358,
              62
            ]
          ],
          "class_code": "bd4b4d223639770830da614caeb7ed27ab8e79f9e49a86b1648448924144dfdd",
          "class_node_pos": [
            [
              356,
              0
            ],
            [
              359,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockExtraOptsNDots0TestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockExtraOptsNDots0TestAI, SimpleQuery) {\n  DNSPacket rsp_ndots0;\n  rsp_ndots0.set_response().set_aa()\n    .add_question(new DNSQuestion(\"ndots0\", T_A))\n    .add_answer(new DNSARR(\"ndots0\", 100, {1, 2, 3, 4}));\n  ON_CALL(server_, OnRequest(\"ndots0\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp_ndots0));\n\n  DNSPacket rsp_ndots0_first;\n  rsp_ndots0_first.set_response().set_aa()\n    .add_question(new DNSQuestion(\"ndots0.first.com\", T_A))\n    .add_answer(new DNSARR(\"ndots0.first.com\", 100, {99, 99, 99, 99}));\n  ON_CALL(server_, OnRequest(\"ndots0.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp_ndots0_first));\n\n  DNSPacket rsp_ndots0_second;\n  rsp_ndots0_second.set_response().set_aa()\n    .add_question(new DNSQuestion(\"ndots0.second.org\", T_A))\n    .add_answer(new DNSARR(\"ndots0.second.org\", 100, {98, 98, 98, 98}));\n  ON_CALL(server_, OnRequest(\"ndots0.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp_ndots0_second));\n\n  DNSPacket rsp_ndots0_third;\n  rsp_ndots0_third.set_response().set_aa()\n    .add_question(new DNSQuestion(\"ndots0.third.gov\", T_A))\n    .add_answer(new DNSARR(\"ndots0.third.gov\", 100, {97, 97, 97, 97}));\n  ON_CALL(server_, OnRequest(\"ndots0.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp_ndots0_third));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"ndots0\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  std::stringstream ss;\n  ss << result.ai_;\n  EXPECT_EQ(\"{addr=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              361,
              0
            ],
            [
              401,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockFlagsChannelOptsTestAI(int flags)\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second,\n                          FillOptions(&opts_, flags), ARES_OPT_FLAGS) {}",
          "fn_code_pos": [
            [
              407,
              2
            ],
            [
              409,
              72
            ]
          ],
          "class_code": "ac2e43b7f06ca718a2d6759e7697249791b1f9caec47d42d0cab97e841c9afa6",
          "class_node_pos": [
            [
              403,
              0
            ],
            [
              417,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockFlagsChannelOptsTestAI",
            "parameters": {
              "flags": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts, int flags) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = flags;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              410,
              2
            ],
            [
              414,
              3
            ]
          ],
          "class_code": "ac2e43b7f06ca718a2d6759e7697249791b1f9caec47d42d0cab97e841c9afa6",
          "class_node_pos": [
            [
              403,
              0
            ],
            [
              417,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options",
              "flags": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "MockNoCheckRespChannelTestAI() : MockFlagsChannelOptsTestAI(ARES_FLAG_NOCHECKRESP) {}",
          "fn_code_pos": [
            [
              421,
              2
            ],
            [
              421,
              87
            ]
          ],
          "class_code": "2a3d3b9a62c21d8309120421a56dd83b6785e6b9cedb19197b54580ef4c1264f",
          "class_node_pos": [
            [
              419,
              0
            ],
            [
              422,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockNoCheckRespChannelTestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockNoCheckRespChannelTestAI, ServFailResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(SERVFAIL);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ESERVFAIL, result.status_);\n}",
          "fn_code_pos": [
            [
              424,
              0
            ],
            [
              440,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockNoCheckRespChannelTestAI, NotImplResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(NOTIMP);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              442,
              0
            ],
            [
              458,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockNoCheckRespChannelTestAI, RefusedResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(REFUSED);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EREFUSED, result.status_);\n}",
          "fn_code_pos": [
            [
              460,
              0
            ],
            [
              476,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTestAI, FamilyV6) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x21, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET6;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"example.com.\", NULL, &hints,\n                   AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result.ai_, IncludesV6Address(\"2121:0000:0000:0000:0000:0000:0000:0303\"));\n}",
          "fn_code_pos": [
            [
              478,
              0
            ],
            [
              497,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTestAI, PartialQueryCancel) {\n  std::vector<byte> nothing;\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &reply));\n\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReplyData(&server_, nothing));\n\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_UNSPEC;\n  ares_getaddrinfo(channel_, \"example.com.\", NULL, &hints,\n                   AddrInfoCallback, &result);\n\n  // After 100ms, issues ares_cancel(), this should be enough time for the A\n  // record reply, but before the timeout on the AAAA record.\n  Process(100);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECANCELLED, result.status_);\n}",
          "fn_code_pos": [
            [
              501,
              0
            ],
            [
              526,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTestAI, FamilyV4) {\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n  AddrInfoResult result = {};\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"example.com.\", NULL, &hints,\n                   AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"2.3.4.5\"));\n}",
          "fn_code_pos": [
            [
              529,
              0
            ],
            [
              546,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTestAI, FamilyV4_MultipleAddresses) {\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {2, 3, 4, 5}))\n    .add_answer(new DNSARR(\"example.com\", 100, {7, 8, 9, 0}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n  AddrInfoResult result = {};\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"example.com.\", NULL, &hints,\n                   AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.ai_;\n  EXPECT_EQ(\"{addr=[2.3.4.5], addr=[7.8.9.0]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              548,
              0
            ],
            [
              567,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTestAI, FamilyUnspecified) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x21, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"example.com.\", NULL, &hints,\n                   AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(2));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"2.3.4.5\"));\n  EXPECT_THAT(result.ai_, IncludesV6Address(\"2121:0000:0000:0000:0000:0000:0000:0303\"));\n}",
          "fn_code_pos": [
            [
              569,
              0
            ],
            [
              595,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockEDNSChannelTestAI() : MockFlagsChannelOptsTestAI(ARES_FLAG_EDNS) {}",
          "fn_code_pos": [
            [
              599,
              2
            ],
            [
              599,
              73
            ]
          ],
          "class_code": "e78234b88eebc58a8d463346d9514abf0d13557809d28985d5c1a83738b610fe",
          "class_node_pos": [
            [
              597,
              0
            ],
            [
              600,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockEDNSChannelTestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEDNSChannelTestAI, RetryWithoutEDNS) {\n  DNSPacket rspfail;\n  rspfail.set_response().set_aa().set_rcode(FORMERR)\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  DNSPacket rspok;\n  rspok.set_response()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {1, 2, 3, 4}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rspfail))\n    .WillOnce(SetReply(&server_, &rspok));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www.google.com.\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"1.2.3.4\"));\n}",
          "fn_code_pos": [
            [
              602,
              0
            ],
            [
              623,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTestAI, SearchDomains) {\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket yesthird;\n  yesthird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A))\n    .add_answer(new DNSARR(\"www.third.gov\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &yesthird));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"2.3.4.5\"));\n}",
          "fn_code_pos": [
            [
              625,
              0
            ],
            [
              652,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTestAI, SearchDomainsServFailOnAAAA) {\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_AAAA));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nofirst4;\n  nofirst4.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst4));\n\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.second.org\", T_AAAA));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket yessecond4;\n  yessecond4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.second.org\", T_A))\n    .add_answer(new DNSARR(\"www.second.org\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &yessecond4));\n\n  DNSPacket failthird;\n  failthird.set_response().set_aa().set_rcode(SERVFAIL)\n    .add_question(new DNSQuestion(\"www.third.gov\", T_AAAA));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &failthird));\n  DNSPacket failthird4;\n  failthird4.set_response().set_aa().set_rcode(SERVFAIL)\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &failthird4));\n\n  AddrInfoResult result;\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n  EXPECT_THAT(result.ai_, IncludesV4Address(\"2.3.4.5\"));\n}",
          "fn_code_pos": [
            [
              654,
              0
            ],
            [
              698,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockMultiServerChannelTestAI(ares_options *opts, int optmask)\n    : MockChannelOptsTest(3, GetParam().first, GetParam().second, opts, optmask) {}",
          "fn_code_pos": [
            [
              704,
              2
            ],
            [
              705,
              83
            ]
          ],
          "class_code": "9cceb76e76833a602b9b3b731bdf9eb420a147611bc09efc81bb86fb9e1e1fac",
          "class_node_pos": [
            [
              700,
              0
            ],
            [
              718,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockMultiServerChannelTestAI",
            "parameters": {
              "opts": "ares_options",
              "optmask": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void CheckExample() {\n    AddrInfoResult result;\n    struct ares_addrinfo_hints hints = {};\n    hints.ai_family = AF_INET;\n    hints.ai_flags = ARES_AI_NOSORT;\n    ares_getaddrinfo(channel_, \"www.example.com.\", NULL, &hints, AddrInfoCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    EXPECT_EQ(result.status_, ARES_SUCCESS);\n    EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n    EXPECT_THAT(result.ai_, IncludesV4Address(\"2.3.4.5\"));\n  }",
          "fn_code_pos": [
            [
              706,
              2
            ],
            [
              717,
              3
            ]
          ],
          "class_code": "9cceb76e76833a602b9b3b731bdf9eb420a147611bc09efc81bb86fb9e1e1fac",
          "class_node_pos": [
            [
              700,
              0
            ],
            [
              718,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckExample",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "NoRotateMultiMockTestAI() : MockMultiServerChannelTestAI(nullptr, ARES_OPT_NOROTATE) {}",
          "fn_code_pos": [
            [
              722,
              2
            ],
            [
              722,
              89
            ]
          ],
          "class_code": "d5153131571f6de3812b09fdb33ed3c90f1ae53dfaa622f4c8ea423a3edc3e62",
          "class_node_pos": [
            [
              720,
              0
            ],
            [
              723,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "NoRotateMultiMockTestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ServerFailoverOptsMockTestAI()\n    : MockMultiServerChannelTestAI(FillOptions(&opts_),\n                                   ARES_OPT_SERVER_FAILOVER | ARES_OPT_NOROTATE) {}",
          "fn_code_pos": [
            [
              727,
              2
            ],
            [
              729,
              83
            ]
          ],
          "class_code": "bf39e87db18123e4a48f24f14579608bfbb814a31558e8f6fa16444938c4f9c7",
          "class_node_pos": [
            [
              725,
              0
            ],
            [
              738,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ServerFailoverOptsMockTestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options *opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->server_failover_opts.retry_chance = 1;\n    opts->server_failover_opts.retry_delay = 250;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              730,
              2
            ],
            [
              735,
              3
            ]
          ],
          "class_code": "bf39e87db18123e4a48f24f14579608bfbb814a31558e8f6fa16444938c4f9c7",
          "class_node_pos": [
            [
              725,
              0
            ],
            [
              738,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(NoRotateMultiMockTestAI, ThirdServer) {\n  struct ares_options opts;\n  int optmask = 0;\n  memset(&opts, 0, sizeof(opts));\n  EXPECT_EQ(ARES_SUCCESS, ares_save_options(channel_, &opts, &optmask));\n  EXPECT_EQ(ARES_OPT_NOROTATE, (optmask & ARES_OPT_NOROTATE));\n  ares_destroy_options(&opts);\n\n  DNSPacket servfailrsp;\n  servfailrsp.set_response().set_aa().set_rcode(SERVFAIL)\n    .add_question(new DNSQuestion(\"www.example.com\", T_A));\n  DNSPacket notimplrsp;\n  notimplrsp.set_response().set_aa().set_rcode(NOTIMP)\n    .add_question(new DNSQuestion(\"www.example.com\", T_A));\n  DNSPacket okrsp;\n  okrsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {2,3,4,5}));\n\n   EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp));\n  CheckExample();\n\n  // Second time around, still starts from server [2], as [0] and [1] both\n  // recorded failures\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n\n  // Third time around, server order is [1] (f0), [2] (f1), [0] (f2), which\n  // means [1] will get called twice in a row as after the first call\n  // order will be  [1] (f1), [2] (f1), [0] (f2) since sort order is\n  // (failure count, index)\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &servfailrsp))\n    .WillOnce(SetReply(servers_[1].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  CheckExample();\n}",
          "fn_code_pos": [
            [
              740,
              0
            ],
            [
              789,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ServerFailoverOptsMockTestAI, ServerFailoverOpts) {\n  DNSPacket servfailrsp;\n  servfailrsp.set_response().set_aa().set_rcode(SERVFAIL)\n    .add_question(new DNSQuestion(\"www.example.com\", T_A));\n  DNSPacket okrsp;\n  okrsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {2,3,4,5}));\n\n  // 1. If all servers are healthy, then the first server should be selected.\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  CheckExample();\n\n  // 2. Failed servers should be retried after the retry delay.\n  //\n  // Fail server #0 but leave server #1 as healthy.\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n\n  // Sleep for the retry delay (actually a little more than 250ms to account\n  // for unreliable timing, e.g. NTP slew) and send in another query. Server #0\n  // should be retried.\n  std::this_thread::sleep_for(std::chrono::milliseconds(260));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  CheckExample();\n\n  // 3. If there are multiple failed servers, then the servers should be\n  //    retried in sorted order.\n  //\n  // Fail all servers for the first round of tries. On the second round server\n  // #1 responds successfully.\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &servfailrsp))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &servfailrsp));\n  CheckExample();\n\n  // At this point the sorted servers look like [1] (f0) [2] (f1) [0] (f2).\n  // Sleep for the retry delay and send in another query. Server #2 should be\n  // retried first, and then server #0.\n  std::this_thread::sleep_for(std::chrono::milliseconds(260));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  CheckExample();\n\n  // 4. If there are multiple failed servers, then servers which have not yet\n  //    met the retry delay should be skipped.\n  //\n  // The sorted servers currently look like [0] (f0) [1] (f0) [2] (f2) and\n  // server #2 has just been retried.\n  // Sleep for half the retry delay and trigger a failure on server #0.\n  std::this_thread::sleep_for(std::chrono::milliseconds(130));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n\n  // The sorted servers now look like [1] (f0) [0] (f1) [2] (f2). Server #0\n  // has just failed whilst server #2 is halfway through the retry delay.\n  // Sleep for another half the retry delay and check that server #2 is retried\n  // whilst server #0 is not.\n  std::this_thread::sleep_for(std::chrono::milliseconds(130));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n}",
          "fn_code_pos": [
            [
              793,
              0
            ],
            [
              872,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockChannelTestAI, FamilyV4ServiceName) {\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {1, 1, 1, 1}))\n    .add_answer(new DNSARR(\"example.com\", 100, {2, 2, 2, 2}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n  AddrInfoResult result = {};\n  struct ares_addrinfo_hints hints = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"example.com\", \"http\", &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.ai_;\n  EXPECT_EQ(\"{addr=[1.1.1.1:80], addr=[2.2.2.2:80]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              874,
              0
            ],
            [
              892,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "FillOptions(struct ares_options * opts)",
          "fn_dec_pos": [
            [
              268,
              30
            ],
            [
              268,
              69
            ]
          ],
          "class_code": "c95b595af7352b9b702cef7886a1e35d2c8ec040f08a6f9b59688b57254dec0e",
          "class_node_pos": [
            [
              260,
              0
            ],
            [
              277,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts, int ndots)",
          "fn_dec_pos": [
            [
              313,
              30
            ],
            [
              313,
              80
            ]
          ],
          "class_code": "7e1042e3421fc4fc018ef6de7b3c455f0ccd92d1487578f934ed027a39ab4c40",
          "class_node_pos": [
            [
              305,
              0
            ],
            [
              323,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options",
              "ndots": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts, int flags)",
          "fn_dec_pos": [
            [
              410,
              30
            ],
            [
              410,
              80
            ]
          ],
          "class_code": "ac2e43b7f06ca718a2d6759e7697249791b1f9caec47d42d0cab97e841c9afa6",
          "class_node_pos": [
            [
              403,
              0
            ],
            [
              417,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options",
              "flags": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options *opts)",
          "fn_dec_pos": [
            [
              730,
              30
            ],
            [
              730,
              68
            ]
          ],
          "class_code": "bf39e87db18123e4a48f24f14579608bfbb814a31558e8f6fa16444938c4f9c7",
          "class_node_pos": [
            [
              725,
              0
            ],
            [
              738,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "c95b595af7352b9b702cef7886a1e35d2c8ec040f08a6f9b59688b57254dec0e": {
          "class_code": "class MockExtraOptsTestAI\n    : public MockChannelOptsTest,\n      public ::testing::WithParamInterface< std::pair<int, bool> > {\n public:\n  MockExtraOptsTestAI()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second,\n                          FillOptions(&opts_),\n                          ARES_OPT_SOCK_SNDBUF|ARES_OPT_SOCK_RCVBUF) {}\n  static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    // Set a few options that affect socket communications\n    opts->socket_send_buffer_size = 514;\n    opts->socket_receive_buffer_size = 514;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockExtraOptsTestAI",
          "class_pos": [
            [
              260,
              0
            ],
            [
              277,
              1
            ]
          ]
        },
        "7e1042e3421fc4fc018ef6de7b3c455f0ccd92d1487578f934ed027a39ab4c40": {
          "class_code": "class MockExtraOptsNDotsTestAI\n    : public MockChannelOptsTest,\n      public ::testing::WithParamInterface< std::pair<int, bool> > {\n public:\n  MockExtraOptsNDotsTestAI(int ndots)\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second,\n                          FillOptions(&opts_, ndots),\n                          ARES_OPT_SOCK_SNDBUF|ARES_OPT_SOCK_RCVBUF|ARES_OPT_NDOTS) {}\n  static struct ares_options* FillOptions(struct ares_options * opts, int ndots) {\n    memset(opts, 0, sizeof(struct ares_options));\n    // Set a few options that affect socket communications\n    opts->socket_send_buffer_size = 514;\n    opts->socket_receive_buffer_size = 514;\n    opts->ndots = ndots;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockExtraOptsNDotsTestAI",
          "class_pos": [
            [
              305,
              0
            ],
            [
              323,
              1
            ]
          ]
        },
        "329d50ae96af8d0ff6e553e3b3b64d42479f49c102234b0a78ed8afdf85f80f4": {
          "class_code": "class MockExtraOptsNDots5TestAI : public MockExtraOptsNDotsTestAI {\n public:\n  MockExtraOptsNDots5TestAI() : MockExtraOptsNDotsTestAI(5) {}\n}",
          "class_name": "MockExtraOptsNDots5TestAI",
          "class_pos": [
            [
              325,
              0
            ],
            [
              328,
              1
            ]
          ]
        },
        "bd4b4d223639770830da614caeb7ed27ab8e79f9e49a86b1648448924144dfdd": {
          "class_code": "class MockExtraOptsNDots0TestAI : public MockExtraOptsNDotsTestAI {\n public:\n  MockExtraOptsNDots0TestAI() : MockExtraOptsNDotsTestAI(0) {}\n}",
          "class_name": "MockExtraOptsNDots0TestAI",
          "class_pos": [
            [
              356,
              0
            ],
            [
              359,
              1
            ]
          ]
        },
        "ac2e43b7f06ca718a2d6759e7697249791b1f9caec47d42d0cab97e841c9afa6": {
          "class_code": "class MockFlagsChannelOptsTestAI\n    : public MockChannelOptsTest,\n      public ::testing::WithParamInterface< std::pair<int, bool> > {\n public:\n  MockFlagsChannelOptsTestAI(int flags)\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second,\n                          FillOptions(&opts_, flags), ARES_OPT_FLAGS) {}\n  static struct ares_options* FillOptions(struct ares_options * opts, int flags) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = flags;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockFlagsChannelOptsTestAI",
          "class_pos": [
            [
              403,
              0
            ],
            [
              417,
              1
            ]
          ]
        },
        "2a3d3b9a62c21d8309120421a56dd83b6785e6b9cedb19197b54580ef4c1264f": {
          "class_code": "class MockNoCheckRespChannelTestAI : public MockFlagsChannelOptsTestAI {\n public:\n  MockNoCheckRespChannelTestAI() : MockFlagsChannelOptsTestAI(ARES_FLAG_NOCHECKRESP) {}\n}",
          "class_name": "MockNoCheckRespChannelTestAI",
          "class_pos": [
            [
              419,
              0
            ],
            [
              422,
              1
            ]
          ]
        },
        "e78234b88eebc58a8d463346d9514abf0d13557809d28985d5c1a83738b610fe": {
          "class_code": "class MockEDNSChannelTestAI : public MockFlagsChannelOptsTestAI {\n public:\n  MockEDNSChannelTestAI() : MockFlagsChannelOptsTestAI(ARES_FLAG_EDNS) {}\n}",
          "class_name": "MockEDNSChannelTestAI",
          "class_pos": [
            [
              597,
              0
            ],
            [
              600,
              1
            ]
          ]
        },
        "9cceb76e76833a602b9b3b731bdf9eb420a147611bc09efc81bb86fb9e1e1fac": {
          "class_code": "class MockMultiServerChannelTestAI\n  : public MockChannelOptsTest,\n    public ::testing::WithParamInterface< std::pair<int, bool> > {\n public:\n  MockMultiServerChannelTestAI(ares_options *opts, int optmask)\n    : MockChannelOptsTest(3, GetParam().first, GetParam().second, opts, optmask) {}\n  void CheckExample() {\n    AddrInfoResult result;\n    struct ares_addrinfo_hints hints = {};\n    hints.ai_family = AF_INET;\n    hints.ai_flags = ARES_AI_NOSORT;\n    ares_getaddrinfo(channel_, \"www.example.com.\", NULL, &hints, AddrInfoCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    EXPECT_EQ(result.status_, ARES_SUCCESS);\n    EXPECT_THAT(result.ai_, IncludesNumAddresses(1));\n    EXPECT_THAT(result.ai_, IncludesV4Address(\"2.3.4.5\"));\n  }\n}",
          "class_name": "MockMultiServerChannelTestAI",
          "class_pos": [
            [
              700,
              0
            ],
            [
              718,
              1
            ]
          ]
        },
        "d5153131571f6de3812b09fdb33ed3c90f1ae53dfaa622f4c8ea423a3edc3e62": {
          "class_code": "class NoRotateMultiMockTestAI : public MockMultiServerChannelTestAI {\n public:\n  NoRotateMultiMockTestAI() : MockMultiServerChannelTestAI(nullptr, ARES_OPT_NOROTATE) {}\n}",
          "class_name": "NoRotateMultiMockTestAI",
          "class_pos": [
            [
              720,
              0
            ],
            [
              723,
              1
            ]
          ]
        },
        "bf39e87db18123e4a48f24f14579608bfbb814a31558e8f6fa16444938c4f9c7": {
          "class_code": "class ServerFailoverOptsMockTestAI : public MockMultiServerChannelTestAI {\n public:\n  ServerFailoverOptsMockTestAI()\n    : MockMultiServerChannelTestAI(FillOptions(&opts_),\n                                   ARES_OPT_SERVER_FAILOVER | ARES_OPT_NOROTATE) {}\n  static struct ares_options* FillOptions(struct ares_options *opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->server_failover_opts.retry_chance = 1;\n    opts->server_failover_opts.retry_delay = 250;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "ServerFailoverOptsMockTestAI",
          "class_pos": [
            [
              725,
              0
            ],
            [
              738,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct sockaddr_in",
          {},
          "",
          [
            59,
            33
          ],
          [
            59,
            51
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            78,
            33
          ],
          [
            78,
            52
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            103,
            2
          ],
          [
            103,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            144,
            2
          ],
          [
            144,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            161,
            2
          ],
          [
            161,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            179,
            2
          ],
          [
            179,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            197,
            2
          ],
          [
            197,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            215,
            2
          ],
          [
            215,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            233,
            2
          ],
          [
            233,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            251,
            2
          ],
          [
            251,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            268,
            9
          ],
          [
            268,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            268,
            42
          ],
          [
            268,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            269,
            27
          ],
          [
            269,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            276,
            2
          ],
          [
            276,
            21
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            294,
            2
          ],
          [
            294,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            313,
            9
          ],
          [
            313,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            313,
            42
          ],
          [
            313,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            314,
            27
          ],
          [
            314,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            322,
            2
          ],
          [
            322,
            21
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            345,
            2
          ],
          [
            345,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            391,
            2
          ],
          [
            391,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            410,
            9
          ],
          [
            410,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            410,
            42
          ],
          [
            410,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            411,
            27
          ],
          [
            411,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            416,
            2
          ],
          [
            416,
            21
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            433,
            2
          ],
          [
            433,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            451,
            2
          ],
          [
            451,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            469,
            2
          ],
          [
            469,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            488,
            2
          ],
          [
            488,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            516,
            2
          ],
          [
            516,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            537,
            2
          ],
          [
            537,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            557,
            2
          ],
          [
            557,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            585,
            2
          ],
          [
            585,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            615,
            2
          ],
          [
            615,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            644,
            2
          ],
          [
            644,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            690,
            2
          ],
          [
            690,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            708,
            4
          ],
          [
            708,
            30
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            730,
            9
          ],
          [
            730,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            730,
            42
          ],
          [
            730,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            731,
            27
          ],
          [
            731,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            737,
            2
          ],
          [
            737,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            741,
            2
          ],
          [
            741,
            21
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            883,
            2
          ],
          [
            883,
            28
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test-ai.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/class.cc": {
      "fn_def_list": [
        {
          "fn_code": "double calculate_area() {\n        return length * breadth;\n    }",
          "fn_code_pos": [
            [
              14,
              4
            ],
            [
              16,
              5
            ]
          ],
          "class_code": "2b4f165567b3ce2172f7ffab0da3356e81ecf0b9d69ba22575ff4aea305666d1",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              25,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "calculate_area",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "double calculate_volume() {\n        return length * breadth * height;\n    }",
          "fn_code_pos": [
            [
              18,
              4
            ],
            [
              20,
              5
            ]
          ],
          "class_code": "2b4f165567b3ce2172f7ffab0da3356e81ecf0b9d69ba22575ff4aea305666d1",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              25,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "calculate_volume",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "double calculate_volume_11() {\n        return length * breadth * height;\n    }",
          "fn_code_pos": [
            [
              22,
              5
            ],
            [
              24,
              5
            ]
          ],
          "class_code": "2b4f165567b3ce2172f7ffab0da3356e81ecf0b9d69ba22575ff4aea305666d1",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              25,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "calculate_volume_11",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "double ddd() {\n        return length * breadth;\n    }",
          "fn_code_pos": [
            [
              35,
              4
            ],
            [
              37,
              5
            ]
          ],
          "class_code": "5783bc97d77e95cce8966764537b63d218c0f5709b3e3fee61bbe84c30940ec4",
          "class_node_pos": [
            [
              28,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ddd",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "double d2() {\n        return length * breadth * height;\n    }",
          "fn_code_pos": [
            [
              39,
              4
            ],
            [
              41,
              5
            ]
          ],
          "class_code": "5783bc97d77e95cce8966764537b63d218c0f5709b3e3fee61bbe84c30940ec4",
          "class_node_pos": [
            [
              28,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "d2",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "double d3() {\n        return length * breadth * height;\n    }",
          "fn_code_pos": [
            [
              43,
              5
            ],
            [
              45,
              5
            ]
          ],
          "class_code": "5783bc97d77e95cce8966764537b63d218c0f5709b3e3fee61bbe84c30940ec4",
          "class_node_pos": [
            [
              28,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "d3",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "int main() {\n\n    // create object of Room class\n    Room room1;\n\n    // assign values to data members\n    room1.length = 42.5;\n    room1.breadth = 30.8;\n    room1.height = 19.2;\n\n    // calculate and display the area and volume of the room\n    cout << \"Area of Room =  \" << room1.calculate_area() << endl;\n    cout << \"Volume of Room =  \" << room1.calculate_volume() << endl;\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "2b4f165567b3ce2172f7ffab0da3356e81ecf0b9d69ba22575ff4aea305666d1": {
          "class_code": "class Room {\n\n   public:\n    double length;\n    double breadth;\n    double height;\n\n    double calculate_area() {\n        return length * breadth;\n    }\n\n    double calculate_volume() {\n        return length * breadth * height;\n    }\n\n     double calculate_volume_11() {\n        return length * breadth * height;\n    }\n}",
          "class_name": "Room",
          "class_pos": [
            [
              7,
              0
            ],
            [
              25,
              1
            ]
          ]
        },
        "5783bc97d77e95cce8966764537b63d218c0f5709b3e3fee61bbe84c30940ec4": {
          "class_code": "class DDDDD {\n\n   public:\n    double length;\n    double breadth;\n    double height;\n\n    double ddd() {\n        return length * breadth;\n    }\n\n    double d2() {\n        return length * breadth * height;\n    }\n\n     double d3() {\n        return length * breadth * height;\n    }\n}",
          "class_name": "DDDDD",
          "class_pos": [
            [
              28,
              0
            ],
            [
              46,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <iostream>\n",
          [
            3,
            0
          ],
          [
            4,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-parse-caa.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseCaaReplyMultipleOK) {\n  std::vector<byte> data = {\n    0x27, 0x86, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04,  0x00, 0x00, 0x00, 0x00, 0x09, 0x77, 0x69, 0x6B, // '............wik\n    0x69, 0x70, 0x65, 0x64, 0x69, 0x61, 0x03, 0x6F,  0x72, 0x67, 0x00, 0x01, 0x01, 0x00, 0x01, 0xC0, // ipedia.org......\n    0x0C, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x02,  0x23, 0x00, 0x15, 0x00, 0x05, 0x69, 0x73, 0x73, // ........#....iss\n    0x75, 0x65, 0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C,  0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, // ueglobalsign.com\n    0xC0, 0x0C, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00,  0x02, 0x23, 0x00, 0x13, 0x00, 0x05, 0x69, 0x73, // .........#....is\n    0x73, 0x75, 0x65, 0x64, 0x69, 0x67, 0x69, 0x63,  0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0xC0, // suedigicert.com.\n    0x0C, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x02,  0x23, 0x00, 0x16, 0x00, 0x05, 0x69, 0x73, 0x73, // ........#....iss\n    0x75, 0x65, 0x6C, 0x65, 0x74, 0x73, 0x65, 0x6E,  0x63, 0x72, 0x79, 0x70, 0x74, 0x2E, 0x6F, 0x72, // ueletsencrypt.or\n    0x67, 0xC0, 0x0C, 0x01, 0x01, 0x00, 0x01, 0x00,  0x00, 0x02, 0x23, 0x00, 0x25, 0x00, 0x05, 0x69, // g.........#.%..i\n    0x6F, 0x64, 0x65, 0x66, 0x6D, 0x61, 0x69, 0x6C,  0x74, 0x6F, 0x3A, 0x64, 0x6E, 0x73, 0x2D, 0x61, // odefmailto:dns-a\n    0x64, 0x6D, 0x69, 0x6E, 0x40, 0x77, 0x69, 0x6B,  0x69, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x2E, 0x6F, // dmin@wikimedia.o\n    0x72, 0x67                                                                                       // rg\n  };\n\n  struct ares_caa_reply* caa = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_caa_reply(data.data(), (int)data.size(), &caa));\n  ASSERT_NE(nullptr, caa);\n  ASSERT_NE(nullptr, caa->next);\n  ASSERT_NE(nullptr, caa->next->next);\n  ASSERT_NE(nullptr, caa->next->next->next);\n\n  ares_free_data(caa);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              58,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseCaaReplySingleOK) {\n  std::vector<byte> data = {\n    0x27, 0x86, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01,  0x00, 0x00, 0x00, 0x00, 0x06, 0x67, 0x6F, 0x6F,  //  '............goo \n    0x67, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00,  0x01, 0x01, 0x00, 0x01, 0xC0, 0x0C, 0x01, 0x01,  //  gle.com......... \n    0x00, 0x01, 0x00, 0x01, 0x43, 0xBE, 0x00, 0x0F,  0x00, 0x05, 0x69, 0x73, 0x73, 0x75, 0x65, 0x70,  //  ....C.....issuep \n    0x6B, 0x69, 0x2E, 0x67, 0x6F, 0x6F, 0x67                                                          //  ki.goog \n  };\n\n  struct ares_caa_reply* caa = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_caa_reply(data.data(), (int)data.size(), &caa));\n  ASSERT_NE(nullptr, caa);\n\n  EXPECT_EQ(caa->critical, (int)0);\n  EXPECT_EQ(caa->plength, (size_t)5);\n  EXPECT_STREQ((char *)caa->property, \"issue\");\n  EXPECT_EQ(caa->length, (size_t)8);\n  EXPECT_STREQ((char *)caa->value, \"pki.goog\");\n\n  ares_free_data(caa);\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseCaaBogusReply1) {\n  std::vector<byte> data = {\n    0x27, 0x86, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01,  0x00, 0x00, 0x00, 0x00, 0x06, 0x67, 0x6F, 0x6F,  //  '............goo \n    0x67, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00,  0x01, 0x01, 0x00, 0x01, 0xC0, 0x0C, 0x01, 0x01,  //  gle.com......... \n    0x00, 0x01, 0x00, 0x01, 0x43, 0xBE, 0x00, 0x0F,  0x00, 0x00, 0x69, 0x73, 0x73, 0x75, 0x65, 0x70,  //  ....C.....issuep \n    0x6B, 0x69, 0x2E, 0x67, 0x6F, 0x6F, 0x67                                                          //  ki.goog \n  };\n\n  struct ares_caa_reply* caa = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_caa_reply(data.data(), (int)data.size(), &caa));\n  ASSERT_EQ(nullptr, caa);\n}",
          "fn_code_pos": [
            [
              81,
              0
            ],
            [
              92,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseCaaBogusReply2) {\n  std::vector<byte> data = {\n    0x27, 0x86, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01,  0x00, 0x00, 0x00, 0x00, 0x06, 0x67, 0x6F, 0x6F,  //  '............goo \n    0x67, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00,  0x01, 0x01, 0x00, 0x01, 0xC0, 0x0C, 0x01, 0x01,  //  gle.com......... \n    0x00, 0x01, 0x00, 0x01, 0x43, 0xBE, 0x00, 0x0F,  0x00, 0x0e, 0x69, 0x73, 0x73, 0x75, 0x65, 0x70,  //  ....C.....issuep \n    0x6B, 0x69, 0x2E, 0x67, 0x6F, 0x6F, 0x67                                                          //  ki.goog \n  };\n\n  struct ares_caa_reply* caa = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_caa_reply(data.data(), (int)data.size(), &caa));\n  ASSERT_EQ(nullptr, caa);\n}",
          "fn_code_pos": [
            [
              94,
              0
            ],
            [
              105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseCaaBogusReply3) {\n  std::vector<byte> data = {\n    0x27, 0x86, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01,  0x00, 0x00, 0x00, 0x00, 0x06, 0x67, 0x6F, 0x6F,  //  '............goo \n    0x67, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00,  0x01, 0x01, 0x00, 0x01, 0xC0, 0x0C, 0x01, 0x01,  //  gle.com......... \n    0x00, 0x01, 0x00, 0x01, 0x43, 0xBE, 0x00, 0x10,  0x00, 0x05, 0x69, 0x73, 0x73, 0x75, 0x65, 0x70,  //  ....C.....issuep \n    0x6B, 0x69, 0x2E, 0x67, 0x6F, 0x6F, 0x67                                                          //  ki.goog \n  };\n\n  struct ares_caa_reply* caa = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_caa_reply(data.data(), (int)data.size(), &caa));\n  ASSERT_EQ(nullptr, caa);\n}",
          "fn_code_pos": [
            [
              107,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseCaaEmptyReply) {\n  std::vector<byte> data = {\n    0x27, 0x86, 0x81, 0x80, 0x00, 0x01, 0x00, 0x00,  0x00, 0x01, 0x00, 0x00, 0x09, 0x77, 0x69, 0x6B,  //  '............wik \n    0x69, 0x70, 0x65, 0x64, 0x69, 0x61, 0x02, 0x64,  0x65, 0x00, 0x01, 0x01, 0x00, 0x01, 0xC0, 0x0C,  //  ipedia.de....... \n    0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x02, 0x58,  0x00, 0x3B, 0x04, 0x6E, 0x73, 0x38, 0x31, 0x0D,  //  .......X.;.ns81. \n    0x64, 0x6F, 0x6D, 0x61, 0x69, 0x6E, 0x63, 0x6F,  0x6E, 0x74, 0x72, 0x6F, 0x6C, 0x03, 0x63, 0x6F,  //  domaincontrol.co \n    0x6D, 0x00, 0x03, 0x64, 0x6E, 0x73, 0x05, 0x6A,  0x6F, 0x6D, 0x61, 0x78, 0x03, 0x6E, 0x65, 0x74,  //  m..dns.jomax.net \n    0x00, 0x78, 0x67, 0xFE, 0x34, 0x00, 0x00, 0x70,  0x80, 0x00, 0x00, 0x1C, 0x20, 0x00, 0x09, 0x3A,  //  .xg.4..p.... ..: \n    0x80, 0x00, 0x00, 0x02, 0x58                                                                      //  ....X \n  };\n\n  struct ares_caa_reply* caa = nullptr;\n  EXPECT_EQ(ARES_ENODATA, ares_parse_caa_reply(data.data(), (int)data.size(), &caa));\n  ASSERT_EQ(nullptr, caa);\n}",
          "fn_code_pos": [
            [
              120,
              0
            ],
            [
              134,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            50,
            2
          ],
          [
            50,
            23
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            68,
            2
          ],
          [
            68,
            23
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            89,
            2
          ],
          [
            89,
            23
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            102,
            2
          ],
          [
            102,
            23
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            115,
            2
          ],
          [
            115,
            23
          ]
        ],
        [
          "struct ares_caa_reply",
          {},
          "",
          [
            131,
            2
          ],
          [
            131,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-ns.cc": {
      "fn_def_list": [
        {
          "fn_code": "int EnterContainer(void *data) {\n  ContainerInfo *container = (ContainerInfo*)data;\n\n  if (verbose) {\n    std::cerr << \"Running function in container {chroot='\"\n              << container->fs_->root() << \"', hostname='\" << container->hostname_\n              << \"', domainname='\" << container->domainname_ << \"'}\"\n              << std::endl;\n  }\n\n  // Ensure we are apparently root before continuing.\n  int count = 10;\n  while (getuid() != 0 && count > 0) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    count--;\n  }\n  if (getuid() != 0) {\n    std::cerr << \"Child in user namespace has uid \" << getuid() << std::endl;\n    return -1;\n  }\n  if (!container->fs_->mountpt().empty()) {\n    // We want to bind mount this inside the specified directory.\n    std::string innerdir = container->fs_->root() + container->fs_->mountpt();\n    if (verbose) std::cerr << \" mount --bind \" << container->fs_->mountpt()\n                           << \" \" << innerdir << std::endl;\n    int rc = mount(container->fs_->mountpt().c_str(), innerdir.c_str(),\n                   \"none\", MS_BIND, 0);\n    if (rc != 0) {\n      std::cerr << \"Warning: failed to bind mount \" << container->fs_->mountpt() << \" at \"\n                << innerdir << \", errno=\" << errno << std::endl;\n    }\n  }\n\n  // Move into the specified directory.\n  if (chdir(container->fs_->root().c_str()) != 0) {\n    std::cerr << \"Failed to chdir('\" << container->fs_->root()\n              << \"'), errno=\" << errno << std::endl;\n    return -1;\n  }\n  // And make it the new root directory;\n  char buffer[PATH_MAX + 1];\n  if (getcwd(buffer, PATH_MAX) == NULL) {\n    std::cerr << \"failed to retrieve cwd, errno=\" << errno << std::endl;\n    return -1;\n  }\n  buffer[PATH_MAX] = '\\0';\n  if (chroot(buffer) != 0) {\n    std::cerr << \"chroot('\" << buffer << \"') failed, errno=\" << errno << std::endl;\n    return -1;\n  }\n\n  // Set host/domainnames if specified\n  if (!container->hostname_.empty()) {\n    if (sethostname(container->hostname_.c_str(),\n                    container->hostname_.size()) != 0) {\n      std::cerr << \"Failed to sethostname('\" << container->hostname_\n                << \"'), errno=\" << errno << std::endl;\n      return -1;\n    }\n  }\n  if (!container->domainname_.empty()) {\n    if (setdomainname(container->domainname_.c_str(),\n                      container->domainname_.size()) != 0) {\n      std::cerr << \"Failed to setdomainname('\" << container->domainname_\n                << \"'), errno=\" << errno << std::endl;\n      return -1;\n    }\n  }\n\n  return container->fn_();\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EnterContainer",
            "parameters": {
              "data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int RunInContainer(ContainerFilesystem* fs, const std::string& hostname,\n                   const std::string& domainname, VoidToIntFn fn) {\n  const int stack_size = 1024 * 1024;\n  std::vector<byte> stack(stack_size, 0);\n  ContainerInfo container = {fs, hostname, domainname, fn};\n\n  // Start a child process in a new user and UTS namespace\n  pid_t child = clone(EnterContainer, stack.data() + stack_size,\n                      CLONE_VM|CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWUTS|SIGCHLD,\n                      (void *)&container);\n  if (child < 0) {\n    std::cerr << \"Failed to clone(), errno=\" << errno << std::endl;\n    return -1;\n  }\n\n  // Build the UID map that makes us look like root inside the namespace.\n  std::stringstream mapfiless;\n  mapfiless << \"/proc/\" << child << \"/uid_map\";\n  std::string mapfile = mapfiless.str();\n  int fd = open(mapfile.c_str(), O_CREAT|O_WRONLY|O_TRUNC, 0644);\n  if (fd < 0) {\n    std::cerr << \"Failed to create '\" << mapfile << \"'\" << std::endl;\n    return -1;\n  }\n  std::stringstream contentss;\n  contentss << \"0 \" << getuid() << \" 1\" << std::endl;\n  std::string content = contentss.str();\n  int rc = write(fd, content.c_str(), content.size());\n  if (rc != (int)content.size()) {\n    std::cerr << \"Failed to write uid map to '\" << mapfile << \"'\" << std::endl;\n  }\n  close(fd);\n\n  // Wait for the child process and retrieve its status.\n  int status;\n  waitpid(child, &status, 0);\n  if (rc <= 0) {\n    std::cerr << \"Failed to waitpid(\" << child << \")\" << std::endl;\n    return -1;\n  }\n  if (!WIFEXITED(status)) {\n    std::cerr << \"Child \" << child << \" did not exit normally\" << std::endl;\n    return -1;\n  }\n  return status;\n}",
          "fn_code_pos": [
            [
              130,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RunInContainer",
            "parameters": {
              "fs": "ContainerFilesystem",
              "hostname": "std::string",
              "domainname": "std::string",
              "fn": "VoidToIntFn"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ContainerFilesystem::ContainerFilesystem(NameContentList files, const std::string& mountpt) {\n  rootdir_ = TempNam(nullptr, \"ares-chroot\");\n  mkdir(rootdir_.c_str(), 0755);\n  dirs_.push_front(rootdir_);\n  for (const auto& nc : files) {\n    std::string fullpath = rootdir_ + nc.first;\n    int idx = fullpath.rfind('/');\n    std::string dir = fullpath.substr(0, idx);\n    EnsureDirExists(dir);\n    files_.push_back(std::unique_ptr<TransientFile>(\n        new TransientFile(fullpath, nc.second)));\n  }\n  if (!mountpt.empty()) {\n    char buffer[PATH_MAX + 1];\n    if (realpath(mountpt.c_str(), buffer)) {\n      mountpt_ = buffer;\n      std::string fullpath = rootdir_ + mountpt_;\n      EnsureDirExists(fullpath);\n    }\n  }\n}",
          "fn_code_pos": [
            [
              177,
              0
            ],
            [
              197,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ContainerFilesystem::ContainerFilesystem",
            "parameters": {
              "files": "NameContentList",
              "mountpt": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ContainerFilesystem::~ContainerFilesystem() {\n  files_.clear();\n  for (const std::string& dir : dirs_) {\n    rmdir(dir.c_str());\n  }\n}",
          "fn_code_pos": [
            [
              199,
              0
            ],
            [
              204,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ContainerFilesystem::~ContainerFilesystem",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void ContainerFilesystem::EnsureDirExists(const std::string& dir) {\n  if (std::find(dirs_.begin(), dirs_.end(), dir) != dirs_.end()) {\n    return;\n  }\n  size_t idx = dir.rfind('/');\n  if (idx != std::string::npos) {\n    std::string prevdir = dir.substr(0, idx);\n    EnsureDirExists(prevdir);\n  }\n  // Ensure this directory is in the list before its ancestors.\n  mkdir(dir.c_str(), 0755);\n  dirs_.push_front(dir);\n}",
          "fn_code_pos": [
            [
              206,
              0
            ],
            [
              218,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ContainerFilesystem::EnsureDirExists",
            "parameters": {
              "dir": "std::string"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ContainerInfo {\n  ContainerFilesystem* fs_;\n  std::string hostname_;\n  std::string domainname_;\n  VoidToIntFn fn_;\n}",
          {
            "* fs_": "ContainerFilesystem",
            "hostname_": "std::string",
            "domainname_": "std::string",
            "fn_": "VoidToIntFn"
          },
          "ContainerInfo",
          [
            45,
            0
          ],
          [
            50,
            1
          ]
        ],
        [
          "struct ContainerInfo {\n  ContainerFilesystem* fs_;\n  std::string hostname_;\n  std::string domainname_;\n  VoidToIntFn fn_;\n}",
          {
            "* fs_": "ContainerFilesystem",
            "hostname_": "std::string",
            "domainname_": "std::string",
            "fn_": "VoidToIntFn"
          },
          "ContainerInfo",
          [
            45,
            0
          ],
          [
            50,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <sys/mount.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <sys/stat.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <iostream>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <functional>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-parse.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseRootName) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\".\", T_A))\n    .add_answer(new DNSARR(\".\", 100, {0x02, 0x03, 0x04, 0x05}));\n  std::vector<byte> data = pkt.data();\n\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(1, count);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              51,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseIndirectRootName) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0xC0, 0x04,  // weird: pointer to a random zero earlier in the message\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0xC0, 0x04,\n    0x00, 0x01,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x04,  // rdata length\n    0x02, 0x03, 0x04, 0x05,\n  };\n\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(1, count);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              53,
              0
            ],
            [
              85,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseEscapedName) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x05, 'a', '\\\\', 'b', '.', 'c',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x05, 'a', '\\\\', 'b', '.', 'c',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x04,  // rdata length\n    0x02, 0x03, 0x04, 0x05,\n  };\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), data.size(),\n                                             &host, info, &count));\n  EXPECT_EQ(1, count);\n  HostEnt hent(host);\n  std::stringstream ss;\n  ss << hent;\n  // The printable name is expanded with escapes.\n  EXPECT_EQ(11, hent.name_.size());\n  EXPECT_EQ('a', hent.name_[0]);\n  EXPECT_EQ('\\\\', hent.name_[1]);\n  EXPECT_EQ('\\\\', hent.name_[2]);\n  EXPECT_EQ('b', hent.name_[3]);\n  EXPECT_EQ('\\\\', hent.name_[4]);\n  EXPECT_EQ('.', hent.name_[5]);\n  EXPECT_EQ('c', hent.name_[6]);\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParsePartialCompressedName) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x03, 'w', 'w', 'w',\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x03, 'w', 'w', 'w',\n    0xc0, 0x10,  // offset 16\n    0x00, 0x01,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x04,  // rdata length\n    0x02, 0x03, 0x04, 0x05,\n  };\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              136,
              0
            ],
            [
              171,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseFullyCompressedName) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x03, 'w', 'w', 'w',\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0xc0, 0x0c,  // offset 12\n    0x00, 0x01,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x04,  // rdata length\n    0x02, 0x03, 0x04, 0x05,\n  };\n  struct hostent *host = nullptr;\n  struct ares_addrttl info[2];\n  int count = 2;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_a_reply(data.data(), (int)data.size(),\n                                             &host, info, &count));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              173,
              0
            ],
            [
              207,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "hent(host)",
          "fn_dec_pos": [
            [
              120,
              10
            ],
            [
              120,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "hent",
            "parameters": {},
            "return_type": "HostEnt"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            41,
            2
          ],
          [
            41,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            42,
            2
          ],
          [
            42,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            75,
            2
          ],
          [
            75,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            76,
            2
          ],
          [
            76,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            114,
            2
          ],
          [
            114,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            115,
            2
          ],
          [
            115,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            161,
            2
          ],
          [
            161,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            162,
            2
          ],
          [
            162,
            21
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            197,
            2
          ],
          [
            197,
            16
          ]
        ],
        [
          "struct ares_addrttl",
          {},
          "",
          [
            198,
            2
          ],
          [
            198,
            21
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-parse-soa-any.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseSoaAnyReplyOK) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_ANY))\\\n    .add_answer(new DNSARR(\"example.com\", 0x01020304, {2,3,4,5}))\n    .add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"))\n    .add_answer(new DNSMxRR(\"example.com\", 100, 200, \"mx2.example.com\"))\n    .add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_soa_reply* soa = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  ASSERT_NE(nullptr, soa);\n  EXPECT_EQ(\"soa1.example.com\", std::string(soa->nsname));\n  EXPECT_EQ(\"fred.example.com\", std::string(soa->hostmaster));\n  EXPECT_EQ((unsigned int)1, soa->serial);\n  EXPECT_EQ((unsigned int)2, soa->refresh);\n  EXPECT_EQ((unsigned int)3, soa->retry);\n  EXPECT_EQ((unsigned int)4, soa->expire);\n  EXPECT_EQ((unsigned int)5, soa->minttl);\n  ares_free_data(soa);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              57,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSoaAnyReplyErrors) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_ANY))\n    .add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n  std::vector<byte> data;\n  struct ares_soa_reply* soa = nullptr;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.add_question(new DNSQuestion(\"example.com\", T_ANY));\n\n#ifdef DISABLED\n  // Question != answer\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_ANY));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_ANY));\n#endif\n\n  // Two questions\n  pkt.add_question(new DNSQuestion(\"example.com\", T_ANY));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_ANY));\n\n  // Wrong sort of answer.\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)data.size(), &soa));\n  pkt.add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    EXPECT_EQ(ARES_EBADRESP, ares_parse_soa_reply(data.data(), (int)len, &soa));\n  }\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseSoaAnyReplyAllocFail) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_ANY))\n    .add_answer(new DNSSoaRR(\"example.com\", 100,\n                             \"soa1.example.com\", \"fred.example.com\",\n                             1, 2, 3, 4, 5));\n  std::vector<byte> data = pkt.data();\n  struct ares_soa_reply* soa = nullptr;\n\n  for (int ii = 1; ii <= 5; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_soa_reply(data.data(), (int)data.size(), &soa)) << ii;\n  }\n}",
          "fn_code_pos": [
            [
              117,
              0
            ],
            [
              132,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            46,
            2
          ],
          [
            46,
            23
          ]
        ],
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            67,
            2
          ],
          [
            67,
            23
          ]
        ],
        [
          "struct ares_soa_reply",
          {},
          "",
          [
            125,
            2
          ],
          [
            125,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-live.cc": {
      "fn_def_list": [
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetHostByNameV4) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_LT(0, (int)result.host_.addrs_.size());\n  EXPECT_EQ(AF_INET, result.host_.addrtype_);\n}",
          "fn_code_pos": [
            [
              112,
              0
            ],
            [
              120,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetHostByNameV6) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET6, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_LT(0, (int)result.host_.addrs_.size());\n  EXPECT_EQ(AF_INET6, result.host_.addrtype_);\n}",
          "fn_code_pos": [
            [
              122,
              0
            ],
            [
              130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetHostByAddrV4) {\n  HostResult result;\n  ares_gethostbyaddr(channel_, cflare_addr4, sizeof(cflare_addr4), AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_LT(0, (int)result.host_.addrs_.size());\n  EXPECT_EQ(AF_INET, result.host_.addrtype_);\n}",
          "fn_code_pos": [
            [
              132,
              0
            ],
            [
              140,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetHostByAddrV6) {\n  HostResult result;\n  ares_gethostbyaddr(channel_, cflare_addr6, sizeof(cflare_addr6), AF_INET6, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_LT(0, (int)result.host_.addrs_.size());\n  EXPECT_EQ(AF_INET6, result.host_.addrtype_);\n}",
          "fn_code_pos": [
            [
              142,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetHostByNameFile) {\n  struct hostent *host = nullptr;\n\n  // Still need a channel even to query /etc/hosts.\n  EXPECT_EQ(ARES_ENOTFOUND,\n            ares_gethostbyname_file(nullptr, \"localhost\", AF_INET, &host));\n\n  int rc = ares_gethostbyname_file(channel_, \"bogus.mcname\", AF_INET, &host);\n  EXPECT_EQ(nullptr, host);\n  EXPECT_EQ(ARES_ENOTFOUND, rc);\n\n  rc = ares_gethostbyname_file(channel_, \"localhost\", AF_INET, &host);\n  if (rc == ARES_SUCCESS) {\n    EXPECT_NE(nullptr, host);\n    ares_free_hostent(host);\n  }\n}",
          "fn_code_pos": [
            [
              152,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetLocalhostByNameV4) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"localhost\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  if (result.status_ != ARES_ECONNREFUSED) {\n    EXPECT_EQ(ARES_SUCCESS, result.status_);\n    EXPECT_EQ(1, (int)result.host_.addrs_.size());\n    EXPECT_EQ(AF_INET, result.host_.addrtype_);\n    EXPECT_NE(std::string::npos, result.host_.name_.find(\"localhost\"));\n  }\n}",
          "fn_code_pos": [
            [
              170,
              0
            ],
            [
              181,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetLocalhostByNameV6) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"localhost\", AF_INET6, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  if (result.status_ != ARES_ECONNREFUSED) {\n    EXPECT_EQ(ARES_SUCCESS, result.status_);\n    EXPECT_EQ(1, (int)result.host_.addrs_.size());\n    EXPECT_EQ(AF_INET6, result.host_.addrtype_);\n    std::stringstream ss;\n    ss << HostEnt(result.host_);\n    EXPECT_NE(std::string::npos, result.host_.name_.find(\"localhost\"));\n  }\n}",
          "fn_code_pos": [
            [
              183,
              0
            ],
            [
              196,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetNonExistLocalhostByNameV4) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"idonotexist.localhost\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  if (result.status_ != ARES_ECONNREFUSED) {\n    EXPECT_EQ(ARES_SUCCESS, result.status_);\n    EXPECT_EQ(1, (int)result.host_.addrs_.size());\n    EXPECT_EQ(AF_INET, result.host_.addrtype_);\n    EXPECT_NE(std::string::npos, result.host_.name_.find(\"idonotexist.localhost\"));\n  }\n}",
          "fn_code_pos": [
            [
              198,
              0
            ],
            [
              209,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetNonExistLocalhostByNameV6) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"idonotexist.localhost\", AF_INET6, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  if (result.status_ != ARES_ECONNREFUSED) {\n    EXPECT_EQ(ARES_SUCCESS, result.status_);\n    EXPECT_EQ(1, (int)result.host_.addrs_.size());\n    EXPECT_EQ(AF_INET6, result.host_.addrtype_);\n    std::stringstream ss;\n    ss << HostEnt(result.host_);\n    EXPECT_NE(std::string::npos, result.host_.name_.find(\"idonotexist.localhost\"));\n  }\n}",
          "fn_code_pos": [
            [
              211,
              0
            ],
            [
              224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetLocalhostByNameIPV4) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"127.0.0.1\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_EQ(1, (int)result.host_.addrs_.size());\n  EXPECT_EQ(AF_INET, result.host_.addrtype_);\n  std::stringstream ss;\n  ss << HostEnt(result.host_);\n  EXPECT_EQ(\"{'127.0.0.1' aliases=[] addrs=[127.0.0.1]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              226,
              0
            ],
            [
              237,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetLocalhostByNameIPV6) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"::1\", AF_INET6, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  if (result.status_ != ARES_ENOTFOUND) {\n    EXPECT_EQ(ARES_SUCCESS, result.status_);\n    EXPECT_EQ(1, (int)result.host_.addrs_.size());\n    EXPECT_EQ(AF_INET6, result.host_.addrtype_);\n    std::stringstream ss;\n    ss << HostEnt(result.host_);\n    EXPECT_EQ(\"{'::1' aliases=[] addrs=[0000:0000:0000:0000:0000:0000:0000:0001]}\", ss.str());\n  }\n}",
          "fn_code_pos": [
            [
              239,
              0
            ],
            [
              252,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetLocalhostFailFamily) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"127.0.0.1\", AF_INET+AF_INET6, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              254,
              0
            ],
            [
              260,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetLocalhostByAddrV4) {\n  HostResult result;\n  struct in_addr addr;\n  addr.s_addr = htonl(INADDR_LOOPBACK);\n  ares_gethostbyaddr(channel_, &addr, sizeof(addr), AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  if (result.status_ != ARES_ENOTFOUND) {\n    EXPECT_EQ(ARES_SUCCESS, result.status_);\n    EXPECT_LT(0, (int)result.host_.addrs_.size());\n    EXPECT_EQ(AF_INET, result.host_.addrtype_);\n    // oddly, travis does not resolve to localhost, but a random hostname starting with travis-job\n    if (result.host_.name_.find(\"travis-job\") == std::string::npos) {\n        EXPECT_NE(std::string::npos,\n                  result.host_.name_.find(\"localhost\"));\n    }\n  }\n}",
          "fn_code_pos": [
            [
              262,
              0
            ],
            [
              279,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetLocalhostByAddrV6) {\n  HostResult result;\n  struct in6_addr addr;\n  memset(&addr, 0, sizeof(addr));\n  addr.s6_addr[15] = 1;  // in6addr_loopback\n  ares_gethostbyaddr(channel_, &addr, sizeof(addr), AF_INET6, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  if (result.status_ != ARES_ENOTFOUND) {\n    EXPECT_EQ(ARES_SUCCESS, result.status_);\n    EXPECT_LT(0, (int)result.host_.addrs_.size());\n    EXPECT_EQ(AF_INET6, result.host_.addrtype_);\n    const std::string& name = result.host_.name_;\n    EXPECT_TRUE(std::string::npos != name.find(\"localhost\") ||\n                std::string::npos != name.find(\"ip6-loopback\"));\n  }\n}",
          "fn_code_pos": [
            [
              281,
              0
            ],
            [
              297,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetHostByAddrFailFamily) {\n  HostResult result;\n  unsigned char addr[4] = {8, 8, 8, 8};\n  ares_gethostbyaddr(channel_, addr, sizeof(addr), AF_INET6+AF_INET,\n                     HostCallback, &result);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              299,
              0
            ],
            [
              306,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetHostByAddrFailAddrSize) {\n  HostResult result;\n  unsigned char addr[4] = {8, 8, 8, 8};\n  ares_gethostbyaddr(channel_, addr, sizeof(addr) - 1, AF_INET,\n                     HostCallback, &result);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              308,
              0
            ],
            [
              315,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DefaultChannelModeTest, LiveGetHostByAddrFailAlloc) {\n  HostResult result;\n  unsigned char addr[4] = {8, 8, 8, 8};\n  SetAllocFail(1);\n  ares_gethostbyaddr(channel_, addr, sizeof(addr), AF_INET,\n                     HostCallback, &result);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOMEM, result.status_);\n}",
          "fn_code_pos": [
            [
              317,
              0
            ],
            [
              325,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveSearchA) {\n  SearchResult result;\n  ares_search(channel_, \"www.youtube.com.\", C_IN, T_A,\n              SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n}",
          "fn_code_pos": [
            [
              330,
              0
            ],
            [
              337,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveSearchEmptyA) {\n  SearchResult result;\n  ares_search(channel_, \"\", C_IN, T_A,\n              SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_NE(ARES_SUCCESS, result.status_);\n}",
          "fn_code_pos": [
            [
              339,
              0
            ],
            [
              346,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveSearchNS) {\n  SearchResult result;\n  ares_search(channel_, \"google.com.\", C_IN, T_NS,\n              SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n}",
          "fn_code_pos": [
            [
              348,
              0
            ],
            [
              355,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveSearchMX) {\n  SearchResult result;\n  ares_search(channel_, \"google.com.\", C_IN, T_MX,\n              SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n}",
          "fn_code_pos": [
            [
              357,
              0
            ],
            [
              364,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveSearchTXT) {\n  SearchResult result;\n  ares_search(channel_, \"google.com.\", C_IN, T_TXT,\n              SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n}",
          "fn_code_pos": [
            [
              366,
              0
            ],
            [
              373,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveSearchSOA) {\n  SearchResult result;\n  ares_search(channel_, \"google.com.\", C_IN, T_SOA,\n              SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n}",
          "fn_code_pos": [
            [
              375,
              0
            ],
            [
              382,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveSearchSRV) {\n  SearchResult result;\n  ares_search(channel_, \"_imap._tcp.gmail.com.\", C_IN, T_SRV,\n              SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n}",
          "fn_code_pos": [
            [
              384,
              0
            ],
            [
              391,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveSearchANY) {\n  SearchResult result;\n  ares_search(channel_, \"google.com.\", C_IN, T_ANY,\n              SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n}",
          "fn_code_pos": [
            [
              393,
              0
            ],
            [
              400,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV4) {\n  NameInfoResult result;\n  struct sockaddr_in sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin_family = AF_INET;\n  sockaddr.sin_port = htons(53);\n  sockaddr.sin_addr.s_addr = htonl(0x08080808);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_UDP,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  if (verbose) std::cerr << \"8.8.8.8:53 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              402,
              0
            ],
            [
              416,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV4NoPort) {\n  NameInfoResult result;\n  struct sockaddr_in sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin_family = AF_INET;\n  sockaddr.sin_port = htons(0);\n  sockaddr.sin_addr.s_addr = htonl(0x08080808);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_UDP,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  if (verbose) std::cerr << \"8.8.8.8:0 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              418,
              0
            ],
            [
              432,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV4UnassignedPort) {\n  NameInfoResult result;\n  struct sockaddr_in sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin_family = AF_INET;\n  sockaddr.sin_port = htons(4);  // Unassigned at IANA\n  sockaddr.sin_addr.s_addr = htonl(0x08080808);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_UDP,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  if (verbose) std::cerr << \"8.8.8.8:4 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              434,
              0
            ],
            [
              448,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV6Both) {\n  NameInfoResult result;\n  struct sockaddr_in6 sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin6_family = AF_INET6;\n  sockaddr.sin6_port = htons(53);\n  memcpy(sockaddr.sin6_addr.s6_addr, cflare_addr6, 16);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_TCP|ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_NOFQDN,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  if (verbose) std::cerr << \"[2001:4860:4860::8888]:53 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              450,
              0
            ],
            [
              464,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV6Neither) {\n  NameInfoResult result;\n  struct sockaddr_in6 sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin6_family = AF_INET6;\n  sockaddr.sin6_port = htons(53);\n  memcpy(sockaddr.sin6_addr.s6_addr, cflare_addr6, 16);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_TCP|ARES_NI_NOFQDN,  // Neither specified => assume lookup host.\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  if (verbose) std::cerr << \"[2001:4860:4860::8888]:53 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              466,
              0
            ],
            [
              480,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV4Numeric) {\n  NameInfoResult result;\n  struct sockaddr_in sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin_family = AF_INET;\n  sockaddr.sin_port = htons(53);\n  sockaddr.sin_addr.s_addr = htonl(0x08080808);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_TCP|ARES_NI_NUMERICHOST,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_EQ(\"8.8.8.8\", result.node_);\n  if (verbose) std::cerr << \"8.8.8.8:53 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              482,
              0
            ],
            [
              497,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV6Numeric) {\n  NameInfoResult result;\n  struct sockaddr_in6 sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin6_family = AF_INET6;\n  sockaddr.sin6_port = htons(53);\n  memcpy(sockaddr.sin6_addr.s6_addr, cflare_addr6, 16);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_DCCP|ARES_NI_NUMERICHOST,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_EQ(\"2606:4700:4700::1111%0\", result.node_);\n  if (verbose) std::cerr << \"[2606:4700:4700::1111]:53 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              499,
              0
            ],
            [
              514,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV6LinkLocal) {\n  NameInfoResult result;\n  struct sockaddr_in6 sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin6_family = AF_INET6;\n  sockaddr.sin6_port = htons(53);\n  unsigned char addr6[16] = {0xfe, 0x80, 0x01, 0x02, 0x01, 0x02, 0x00, 0x00,\n                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04};\n  memcpy(sockaddr.sin6_addr.s6_addr, addr6, 16);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_DCCP|ARES_NI_NUMERICHOST,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_EQ(\"fe80:102:102::304%0\", result.node_);\n  if (verbose) std::cerr << \"[fe80:102:102::304]:53 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              516,
              0
            ],
            [
              533,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV4NotFound) {\n  NameInfoResult result;\n  struct sockaddr_in sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin_family = AF_INET;\n  sockaddr.sin_port = htons(4);  // Port 4 unassigned at IANA\n  // RFC5737 says 192.0.2.0 should not be used publicly.\n  sockaddr.sin_addr.s_addr = htonl(0xC0000200);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_UDP,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_EQ(\"192.0.2.0\", result.node_);\n  if (verbose) std::cerr << \"192.0.2.0:53 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              535,
              0
            ],
            [
              551,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV4NotFoundFail) {\n  NameInfoResult result;\n  struct sockaddr_in sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin_family = AF_INET;\n  sockaddr.sin_port = htons(53);\n  // RFC5737 says 192.0.2.0 should not be used publicly.\n  sockaddr.sin_addr.s_addr = htonl(0xC0000200);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_UDP|ARES_NI_NAMEREQD,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTFOUND, result.status_);\n}",
          "fn_code_pos": [
            [
              553,
              0
            ],
            [
              567,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoV6NotFound) {\n  NameInfoResult result;\n  struct sockaddr_in6 sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin6_family = AF_INET6;\n  sockaddr.sin6_port = htons(53);\n  // 2001:db8::/32 is only supposed to be used in documentation.\n  unsigned char addr6[16] = {0x20, 0x01, 0x0d, 0xb8, 0x01, 0x02, 0x00, 0x00,\n                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04};\n  memcpy(sockaddr.sin6_addr.s6_addr, addr6, 16);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_UDP,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_EQ(\"2001:db8:102::304%0\", result.node_);\n  if (verbose) std::cerr << \"[2001:db8:102::304]:53 => \" << result.node_ << \"/\" << result.service_ << std::endl;\n}",
          "fn_code_pos": [
            [
              569,
              0
            ],
            [
              587,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInvalidFamily) {\n  NameInfoResult result;\n  struct sockaddr_in6 sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin6_family = AF_INET6 + AF_INET;\n  sockaddr.sin6_port = htons(53);\n  memcpy(sockaddr.sin6_addr.s6_addr, cflare_addr6, 16);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_UDP,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              589,
              0
            ],
            [
              602,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInvalidFlags) {\n  NameInfoResult result;\n  struct sockaddr_in6 sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin6_family = AF_INET6;\n  sockaddr.sin6_port = htons(53);\n  memcpy(sockaddr.sin6_addr.s6_addr, cflare_addr6, 16);\n  // Ask for both a name-required, and a numeric host.\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_UDP|ARES_NI_NUMERICHOST|ARES_NI_NAMEREQD,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EBADFLAGS, result.status_);\n}",
          "fn_code_pos": [
            [
              604,
              0
            ],
            [
              618,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetServiceInfo) {\n  NameInfoResult result;\n  struct sockaddr_in sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin_family = AF_INET;\n  sockaddr.sin_port = htons(53);\n  sockaddr.sin_addr.s_addr = htonl(0x08080808);\n  // Just look up service info\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPSERVICE|ARES_NI_SCTP,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_EQ(\"\", result.node_);\n}",
          "fn_code_pos": [
            [
              620,
              0
            ],
            [
              635,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetServiceInfoNumeric) {\n  NameInfoResult result;\n  struct sockaddr_in sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin_family = AF_INET;\n  sockaddr.sin_port = htons(53);\n  sockaddr.sin_addr.s_addr = htonl(0x08080808);\n  // Just look up service info\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPSERVICE|ARES_NI_SCTP|ARES_NI_NUMERICSERV,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  EXPECT_EQ(\"\", result.node_);\n  EXPECT_EQ(\"53\", result.service_);\n}",
          "fn_code_pos": [
            [
              637,
              0
            ],
            [
              653,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, LiveGetNameInfoAllocFail) {\n  NameInfoResult result;\n  struct sockaddr_in sockaddr;\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  sockaddr.sin_family = AF_INET;\n  sockaddr.sin_port = htons(53);\n  sockaddr.sin_addr.s_addr = htonl(0x08080808);\n  SetAllocFail(1);\n  ares_getnameinfo(channel_, (const struct sockaddr*)&sockaddr, sizeof(sockaddr),\n                   ARES_NI_LOOKUPHOST|ARES_NI_LOOKUPSERVICE|ARES_NI_UDP,\n                   NameInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOMEM, result.status_);\n}",
          "fn_code_pos": [
            [
              655,
              0
            ],
            [
              669,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VIRT_NONVIRT_TEST_F(DefaultChannelTest, GetSock) {\n  ares_socket_t socks[3] = {ARES_SOCKET_BAD, ARES_SOCKET_BAD, ARES_SOCKET_BAD};\n  int bitmask = ares_getsock(channel_, socks, 3);\n  EXPECT_EQ(0, bitmask);\n  bitmask = ares_getsock(channel_, nullptr, 0);\n  EXPECT_EQ(0, bitmask);\n\n  // Ask again with a pending query.\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  bitmask = ares_getsock(channel_, socks, 3);\n  EXPECT_NE(0, bitmask);\n\n  size_t sock_cnt = 0;\n  for (size_t i=0; i<3; i++) {\n    if (ARES_GETSOCK_READABLE(bitmask, i) || ARES_GETSOCK_WRITABLE(bitmask, i)) {\n      EXPECT_NE(ARES_SOCKET_BAD, socks[i]);\n      if (socks[i] != ARES_SOCKET_BAD)\n        sock_cnt++;\n    }\n  }\n  EXPECT_NE((size_t)0, sock_cnt);\n\n  bitmask = ares_getsock(channel_, nullptr, 0);\n  EXPECT_EQ(0, bitmask);\n\n  Process();\n}",
          "fn_code_pos": [
            [
              671,
              0
            ],
            [
              698,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VIRT_NONVIRT_TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, GetTCPSock) {\n  ares_channel_t *channel;\n  struct ares_options opts;\n  memset(&opts, 0, sizeof(opts));\n  opts.tcp_port = 53;\n  opts.flags = ARES_FLAG_USEVC;\n  int optmask = ARES_OPT_TCP_PORT | ARES_OPT_FLAGS;\n  EXPECT_EQ(ARES_SUCCESS, ares_init_options(&channel, &opts, optmask));\n  EXPECT_NE(nullptr, channel);\n\n  ares_socket_t socks[3] = {ARES_SOCKET_BAD, ARES_SOCKET_BAD, ARES_SOCKET_BAD};\n  int bitmask = ares_getsock(channel, socks, 3);\n  EXPECT_EQ(0, bitmask);\n  bitmask = ares_getsock(channel, nullptr, 0);\n  EXPECT_EQ(0, bitmask);\n\n  // Ask again with a pending query.\n  HostResult result;\n  ares_gethostbyname(channel, \"www.google.com.\", AF_INET, HostCallback, &result);\n  bitmask = ares_getsock(channel, socks, 3);\n  EXPECT_NE(0, bitmask);\n\n  size_t sock_cnt = 0;\n  for (size_t i=0; i<3; i++) {\n    if (ARES_GETSOCK_READABLE(bitmask, i) || ARES_GETSOCK_WRITABLE(bitmask, i)) {\n      EXPECT_NE(ARES_SOCKET_BAD, socks[i]);\n      if (socks[i] != ARES_SOCKET_BAD)\n        sock_cnt++;\n    }\n  }\n  EXPECT_NE((size_t)0, sock_cnt);\n\n  bitmask = ares_getsock(channel, nullptr, 0);\n  EXPECT_EQ(0, bitmask);\n\n  ProcessWork(channel, NoExtraFDs, nullptr);\n\n  ares_destroy(channel);\n}",
          "fn_code_pos": [
            [
              700,
              0
            ],
            [
              738,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, VerifySocketFunctionCallback) {\n  VirtualizeIO vio(channel_);\n\n  auto my_functions = VirtualizeIO::default_functions;\n  size_t count = 0;\n\n  my_functions.asocket = [](int af, int type, int protocol, void * p) -> ares_socket_t {\n    EXPECT_NE(nullptr, p);\n    (*reinterpret_cast<size_t *>(p))++;\n    return ::socket(af, type, protocol);\n  };\n\n  ares_set_socket_functions(channel_, &my_functions, &count);\n\n  {\n    count = 0;\n    HostResult result;\n    ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n    Process();\n\n    EXPECT_TRUE(result.done_);\n    EXPECT_NE((size_t)0, count);\n  }\n\n  {\n    count = 0;\n    ares_channel_t *copy;\n    EXPECT_EQ(ARES_SUCCESS, ares_dup(&copy, channel_));\n\n    HostResult result;\n    ares_gethostbyname(copy, \"www.google.com.\", AF_INET, HostCallback, &result);\n\n    ProcessWork(copy, NoExtraFDs, nullptr);\n\n    EXPECT_TRUE(result.done_);\n    ares_destroy(copy);\n    EXPECT_NE((size_t)0, count);\n  }\n\n}",
          "fn_code_pos": [
            [
              740,
              0
            ],
            [
              779,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, LiveSetServers) {\n  struct ares_addr_node server1;\n  struct ares_addr_node server2;\n  server1.next = &server2;\n  server1.family = AF_INET;\n  server1.addr.addr4.s_addr = htonl(0x01020304);\n  server2.next = nullptr;\n  server2.family = AF_INET;\n  server2.addr.addr4.s_addr = htonl(0x02030405);\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers(channel_, &server1));\n  ares_cancel(channel_);\n}",
          "fn_code_pos": [
            [
              781,
              0
            ],
            [
              795,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, LiveSetServersPorts) {\n  struct ares_addr_port_node server1;\n  struct ares_addr_port_node server2;\n  server1.next = &server2;\n  server1.family = AF_INET;\n  server1.addr.addr4.s_addr = htonl(0x01020304);\n  server1.udp_port = 111;\n  server1.tcp_port = 111;\n  server2.next = nullptr;\n  server2.family = AF_INET;\n  server2.addr.addr4.s_addr = htonl(0x02030405);\n  server2.udp_port = 0;\n  server2.tcp_port = 0;;\n  EXPECT_EQ(ARES_ENODATA, ares_set_servers_ports(nullptr, &server1));\n\n  // Change while pending will requeue any requests to new servers\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers_ports(channel_, &server1));\n  ares_cancel(channel_);\n}",
          "fn_code_pos": [
            [
              797,
              0
            ],
            [
              817,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, LiveSetServersCSV) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  // Change while pending will requeue any requests to new servers\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers_csv(channel_, \"1.2.3.4,2.3.4.5\"));\n  EXPECT_EQ(ARES_SUCCESS, ares_set_servers_ports_csv(channel_, \"1.2.3.4:56,2.3.4.5:67\"));\n  ares_cancel(channel_);\n}",
          "fn_code_pos": [
            [
              819,
              0
            ],
            [
              826,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "vio(channel_)",
          "fn_dec_pos": [
            [
              741,
              15
            ],
            [
              741,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "vio",
            "parameters": {},
            "return_type": "VirtualizeIO"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hostent",
          {},
          "",
          [
            153,
            2
          ],
          [
            153,
            16
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            264,
            2
          ],
          [
            264,
            16
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            283,
            2
          ],
          [
            283,
            17
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            404,
            2
          ],
          [
            404,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            409,
            36
          ],
          [
            409,
            51
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            420,
            2
          ],
          [
            420,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            425,
            36
          ],
          [
            425,
            51
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            436,
            2
          ],
          [
            436,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            441,
            36
          ],
          [
            441,
            51
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            452,
            2
          ],
          [
            452,
            21
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            457,
            36
          ],
          [
            457,
            51
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            468,
            2
          ],
          [
            468,
            21
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            473,
            36
          ],
          [
            473,
            51
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            484,
            2
          ],
          [
            484,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            489,
            36
          ],
          [
            489,
            51
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            501,
            2
          ],
          [
            501,
            21
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            506,
            36
          ],
          [
            506,
            51
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            518,
            2
          ],
          [
            518,
            21
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            525,
            36
          ],
          [
            525,
            51
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            537,
            2
          ],
          [
            537,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            543,
            36
          ],
          [
            543,
            51
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            555,
            2
          ],
          [
            555,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            561,
            36
          ],
          [
            561,
            51
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            571,
            2
          ],
          [
            571,
            21
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            579,
            36
          ],
          [
            579,
            51
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            591,
            2
          ],
          [
            591,
            21
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            596,
            36
          ],
          [
            596,
            51
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            606,
            2
          ],
          [
            606,
            21
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            612,
            36
          ],
          [
            612,
            51
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            622,
            2
          ],
          [
            622,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            628,
            36
          ],
          [
            628,
            51
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            639,
            2
          ],
          [
            639,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            645,
            36
          ],
          [
            645,
            51
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            657,
            2
          ],
          [
            657,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            663,
            36
          ],
          [
            663,
            51
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            702,
            2
          ],
          [
            702,
            21
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            782,
            2
          ],
          [
            782,
            23
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            783,
            2
          ],
          [
            783,
            23
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            798,
            2
          ],
          [
            798,
            28
          ]
        ],
        [
          "struct ares_addr_port_node",
          {},
          "",
          [
            799,
            2
          ],
          [
            799,
            28
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <netdb.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/dns-proto-test.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST(DNSProto, EncodeQuestions) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com.\", T_A))\n    .add_question(new DNSQuestion(\"www.example.com\", T_AAAA, C_CHAOS));\n\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x02,  // num questions\n    0x00, 0x00,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    // Question 2\n    0x03, 'w', 'w', 'w',\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x1C,  // type AAAA = 28\n    0x00, 0x03,  // class CHAOS = 3\n  };\n  EXPECT_EQ(data, pkt.data());\n}",
          "fn_code_pos": [
            [
              33,
              0
            ],
            [
              62,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(DNSProto, EncodeSingleNameAnswers) {\n  DNSPacket pkt;\n  pkt.qid_ = 0x1234;\n  pkt.response_ = true;\n  pkt.aa_ = true;\n  pkt.opcode_ = O_QUERY;\n  pkt.add_answer(new DNSCnameRR(\"example.com\", 0x01020304, \"other.com.\"));\n  pkt.add_auth(new DNSPtrRR(\"www.example.com\", 0x01020304, \"www.other.com\"));\n\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x00,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x01,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x05,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x0B,  // rdata length\n    0x05, 'o', 't', 'h', 'e', 'r',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    // Authority 1\n    0x03, 'w', 'w', 'w',\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x0c,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x0F,  // rdata length\n    0x03, 'w', 'w', 'w',\n    0x05, 'o', 't', 'h', 'e', 'r',\n    0x03, 'c', 'o', 'm',\n    0x00,\n  };\n  EXPECT_EQ(data, pkt.data());\n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              107,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(DNSProto, EncodeAddressAnswers) {\n  DNSPacket pkt;\n  pkt.qid_ = 0x1234;\n  pkt.response_ = true;\n  pkt.aa_ = true;\n  pkt.opcode_ = O_QUERY;\n  std::vector<byte> addrv4 = {0x02, 0x03, 0x04, 0x05};\n  pkt.add_answer(new DNSARR(\"example.com\", 0x01020304, addrv4));\n  byte addrv6[16] = {0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,\n                     0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04};\n  pkt.add_additional(new DNSAaaaRR(\"www.example.com\", 0x01020304, addrv6, 16));\n\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x00,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x01,  // num additional RRs\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x04,  // rdata length\n    0x02, 0x03, 0x04, 0x05,\n    // Additional 1\n    0x03, 'w', 'w', 'w',\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x1c,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x10,  // rdata length\n    0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,\n    0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04\n  };\n  EXPECT_EQ(data, pkt.data());\n}",
          "fn_code_pos": [
            [
              109,
              0
            ],
            [
              151,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-internal.cc": {
      "fn_def_list": [
        {
          "fn_code": "void CheckPtoN4(int size, unsigned int value, const char *input) {\n  struct in_addr a4;\n  a4.s_addr = 0;\n  uint32_t expected = htonl(value);\n  EXPECT_EQ(size, ares_inet_net_pton(AF_INET, input, &a4, sizeof(a4)))\n    << \" for input \" << input;\n  EXPECT_EQ(expected, a4.s_addr) << \" for input \" << input;\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              73,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckPtoN4",
            "parameters": {
              "size": "int",
              "value": "unsigned int",
              "input": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, Strsplit) {\n  using std::vector;\n  using std::string;\n  size_t n;\n  struct {\n    vector<string> inputs;\n    vector<string> delimiters;\n    vector<vector<string>> expected;\n  } data = {\n    {\n      \"\",\n      \" \",\n      \"             \",\n      \"example.com, example.co\",\n      \"        a, b, A,c,     d, e,,,D,e,e,E\",\n    },\n    { \", \", \", \", \", \", \", \", \", \" },\n    {\n      {}, {}, {},\n      { \"example.com\", \"example.co\" },\n      { \"a\", \"b\", \"c\", \"d\", \"e\" },\n    },\n  };\n  for(size_t i = 0; i < data.inputs.size(); i++) {\n    char **out = ares__strsplit(data.inputs.at(i).c_str(),\n                               data.delimiters.at(i).c_str(), &n);\n    if(data.expected.at(i).size() == 0) {\n      EXPECT_EQ(out, nullptr);\n    }\n    else {\n      EXPECT_EQ(n, data.expected.at(i).size());\n      for(size_t j = 0; j < n && j < data.expected.at(i).size(); j++) {\n        EXPECT_STREQ(out[j], data.expected.at(i).at(j).c_str());\n      }\n    }\n    ares__strsplit_free(out, n);\n  }\n}",
          "fn_code_pos": [
            [
              77,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, InetPtoN) {\n  struct in_addr a4;\n  struct in6_addr a6;\n\n#ifndef CARES_SYMBOL_HIDING\n  uint32_t expected;\n\n  CheckPtoN4(4 * 8, 0x01020304, \"1.2.3.4\");\n  CheckPtoN4(4 * 8, 0x81010101, \"129.1.1.1\");\n  CheckPtoN4(4 * 8, 0xC0010101, \"192.1.1.1\");\n  CheckPtoN4(4 * 8, 0xE0010101, \"224.1.1.1\");\n  CheckPtoN4(4 * 8, 0xE1010101, \"225.1.1.1\");\n  CheckPtoN4(4, 0xE0000000, \"224\");\n  CheckPtoN4(4 * 8, 0xFD000000, \"253\");\n  CheckPtoN4(4 * 8, 0xF0010101, \"240.1.1.1\");\n  CheckPtoN4(4 * 8, 0x02030405, \"02.3.4.5\");\n  CheckPtoN4(3 * 8, 0x01020304, \"1.2.3.4/24\");\n  CheckPtoN4(3 * 8, 0x01020300, \"1.2.3/24\");\n  CheckPtoN4(2 * 8, 0xa0000000, \"0xa\");\n  CheckPtoN4(0, 0x02030405, \"2.3.4.5/000\");\n  CheckPtoN4(1 * 8, 0x01020000, \"1.2/8\");\n  CheckPtoN4(2 * 8, 0x01020000, \"0x0102/16\");\n  CheckPtoN4(4 * 8, 0x02030405, \"02.3.4.5\");\n\n  EXPECT_EQ(16 * 8, ares_inet_net_pton(AF_INET6, \"::\", &a6, sizeof(a6)));\n  EXPECT_EQ(16 * 8, ares_inet_net_pton(AF_INET6, \"::1\", &a6, sizeof(a6)));\n  EXPECT_EQ(16 * 8, ares_inet_net_pton(AF_INET6, \"1234:5678::\", &a6, sizeof(a6)));\n  EXPECT_EQ(16 * 8, ares_inet_net_pton(AF_INET6, \"12:34::ff\", &a6, sizeof(a6)));\n  EXPECT_EQ(16 * 8, ares_inet_net_pton(AF_INET6, \"12:34::ffff:1.2.3.4\", &a6, sizeof(a6)));\n  EXPECT_EQ(23, ares_inet_net_pton(AF_INET6, \"12:34::ffff:1.2.3.4/23\", &a6, sizeof(a6)));\n  EXPECT_EQ(3 * 8, ares_inet_net_pton(AF_INET6, \"12:34::ff/24\", &a6, sizeof(a6)));\n  EXPECT_EQ(0, ares_inet_net_pton(AF_INET6, \"12:34::ff/0\", &a6, sizeof(a6)));\n  EXPECT_EQ(16 * 8, ares_inet_net_pton(AF_INET6, \"12:34::ffff:0.2\", &a6, sizeof(a6)));\n  EXPECT_EQ(16 * 8, ares_inet_net_pton(AF_INET6, \"1234:1234:1234:1234:1234:1234:1234:1234\", &a6, sizeof(a6)));\n  EXPECT_EQ(2, ares_inet_net_pton(AF_INET6, \"0::00:00:00/2\", &a6, sizeof(a6)));\n\n  // Various malformed versions\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \" \", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"0x\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"0x \", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"x0\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"0xXYZZY\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"xyzzy\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET+AF_INET6, \"1.2.3.4\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"257.2.3.4\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"002.3.4.x\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"00.3.4.x\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"2.3.4.x\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"2.3.4.5.6\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"2.3.4.5.6/12\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"2.3.4:5\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"2.3.4.5/120\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"2.3.4.5/1x\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"2.3.4.5/x\", &a4, sizeof(a4)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ff/240\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ff/02\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ff/2y\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ff/y\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ff/\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \":x\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \":\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \": :1234\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"::12345\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"1234::2345:3456::0011\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"1234:1234:1234:1234:1234:1234:1234:1234:\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"1234:1234:1234:1234:1234:1234:1234:1234::\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"1234:1234:1234:1234:1234:1234:1234:1.2.3.4\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \":1234:1234:1234:1234:1234:1234:1234:1234\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \":1234:1234:1234:1234:1234:1234:1234:1234:\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"1234:1234:1234:1234:1234:1234:1234:1234:5678\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"1234:1234:1234:1234:1234:1234:1234:1234:5678:5678\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"1234:1234:1234:1234:1234:1234:1234:1234:5678:5678:5678\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ffff:257.2.3.4\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ffff:1.2.3.4.5.6\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ffff:1.2.3.4.5\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ffff:1.2.3.z\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ffff:1.2.3001.4\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ffff:1.2.3..4\", &a6, sizeof(a6)));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ffff:1.2.3.\", &a6, sizeof(a6)));\n\n  // Hex constants are allowed.\n  EXPECT_EQ(4 * 8, ares_inet_net_pton(AF_INET, \"0x01020304\", &a4, sizeof(a4)));\n  expected = htonl(0x01020304);\n  EXPECT_EQ(expected, a4.s_addr);\n  EXPECT_EQ(4 * 8, ares_inet_net_pton(AF_INET, \"0x0a0b0c0d\", &a4, sizeof(a4)));\n  expected = htonl(0x0a0b0c0d);\n  EXPECT_EQ(expected, a4.s_addr);\n  EXPECT_EQ(4 * 8, ares_inet_net_pton(AF_INET, \"0x0A0B0C0D\", &a4, sizeof(a4)));\n  expected = htonl(0x0a0b0c0d);\n  EXPECT_EQ(expected, a4.s_addr);\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"0x0xyz\", &a4, sizeof(a4)));\n  EXPECT_EQ(4 * 8, ares_inet_net_pton(AF_INET, \"0x1122334\", &a4, sizeof(a4)));\n  expected = htonl(0x11223340);\n  EXPECT_EQ(expected, a4.s_addr);  // huh?\n\n  // No room, no room.\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"1.2.3.4\", &a4, sizeof(a4) - 1));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET6, \"12:34::ff\", &a6, sizeof(a6) - 1));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"0x01020304\", &a4, 2));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"0x01020304\", &a4, 0));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"0x0a0b0c0d\", &a4, 0));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"0x0xyz\", &a4, 0));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"0x1122334\", &a4, sizeof(a4) - 1));\n  EXPECT_EQ(-1, ares_inet_net_pton(AF_INET, \"253\", &a4, sizeof(a4) - 1));\n#endif\n\n  EXPECT_EQ(1, ares_inet_pton(AF_INET, \"1.2.3.4\", &a4));\n  EXPECT_EQ(1, ares_inet_pton(AF_INET6, \"12:34::ff\", &a6));\n  EXPECT_EQ(1, ares_inet_pton(AF_INET6, \"12:34::ffff:1.2.3.4\", &a6));\n  EXPECT_EQ(0, ares_inet_pton(AF_INET, \"xyzzy\", &a4));\n  EXPECT_EQ(-1, ares_inet_pton(AF_INET+AF_INET6, \"1.2.3.4\", &a4));\n}",
          "fn_code_pos": [
            [
              117,
              0
            ],
            [
              230,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, FreeCorruptData) {\n  // ares_free_data(p) expects that there is a type field and a marker\n  // field in the memory before p.  Feed it incorrect versions of each.\n  struct ares_data *data = (struct ares_data *)malloc(sizeof(struct ares_data));\n  void* p = &(data->data);\n\n  // Invalid type\n  data->type = (ares_datatype)ARES_DATATYPE_LAST;\n  data->mark = ARES_DATATYPE_MARK;\n  ares_free_data(p);\n\n  // Invalid marker\n  data->type = (ares_datatype)ARES_DATATYPE_MX_REPLY;\n  data->mark = ARES_DATATYPE_MARK + 1;\n  ares_free_data(p);\n\n  // Null pointer\n  ares_free_data(nullptr);\n\n  free(data);\n}",
          "fn_code_pos": [
            [
              232,
              0
            ],
            [
              252,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, FreeLongChain) {\n  struct ares_addr_node *data = nullptr;\n  for (int ii = 0; ii < 100000; ii++) {\n    struct ares_addr_node *prev = (struct ares_addr_node*)ares_malloc_data(ARES_DATATYPE_ADDR_NODE);\n    prev->next = data;\n    data = prev;\n  }\n\n  ares_free_data(data);\n}",
          "fn_code_pos": [
            [
              255,
              0
            ],
            [
              264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(LibraryInit, StrdupFailures) {\n  EXPECT_EQ(ARES_SUCCESS, ares_library_init(ARES_LIB_INIT_ALL));\n  char* copy = ares_strdup(\"string\");\n  EXPECT_NE(nullptr, copy);\n  ares_free(copy);\n  ares_library_cleanup();\n}",
          "fn_code_pos": [
            [
              266,
              0
            ],
            [
              272,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, StrdupFailures) {\n  SetAllocFail(1);\n  char* copy = ares_strdup(\"string\");\n  EXPECT_EQ(nullptr, copy);\n}",
          "fn_code_pos": [
            [
              274,
              0
            ],
            [
              278,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, MallocDataFail) {\n  EXPECT_EQ(nullptr, ares_malloc_data((ares_datatype)99));\n  SetAllocSizeFail(sizeof(struct ares_data));\n  EXPECT_EQ(nullptr, ares_malloc_data(ARES_DATATYPE_MX_REPLY));\n}",
          "fn_code_pos": [
            [
              280,
              0
            ],
            [
              284,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(FileChannelTest, GetAddrInfoHostsPositive) {\n  TempFile hostsfile(\"1.2.3.4 example.com  \\n\"\n                     \"  2.3.4.5\\tgoogle.com   www.google.com\\twww2.google.com\\n\"\n                     \"#comment\\n\"\n                     \"4.5.6.7\\n\"\n                     \"1.3.5.7  \\n\"\n                     \"::1    ipv6.com\");\n  EnvValue with_env(\"CARES_HOSTS\", hostsfile.filename());\n  struct ares_addrinfo_hints hints = {};\n  AddrInfoResult result = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_CANONNAME | ARES_AI_ENVHOSTS | ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"example.com\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.ai_;\n  EXPECT_EQ(\"{example.com addr=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              286,
              0
            ],
            [
              304,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(FileChannelTest, GetAddrInfoHostsSpaces) {\n  TempFile hostsfile(\"1.2.3.4 example.com  \\n\"\n                     \"  2.3.4.5\\tgoogle.com   www.google.com\\twww2.google.com\\n\"\n                     \"#comment\\n\"\n                     \"4.5.6.7\\n\"\n                     \"1.3.5.7  \\n\"\n                     \"::1    ipv6.com\");\n  EnvValue with_env(\"CARES_HOSTS\", hostsfile.filename());\n  struct ares_addrinfo_hints hints = {};\n  AddrInfoResult result = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_CANONNAME | ARES_AI_ENVHOSTS | ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"google.com\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.ai_;\n  EXPECT_EQ(\"{www.google.com->google.com, www2.google.com->google.com addr=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              306,
              0
            ],
            [
              324,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(FileChannelTest, GetAddrInfoHostsByALias) {\n  TempFile hostsfile(\"1.2.3.4 example.com  \\n\"\n                     \"  2.3.4.5\\tgoogle.com   www.google.com\\twww2.google.com\\n\"\n                     \"#comment\\n\"\n                     \"4.5.6.7\\n\"\n                     \"1.3.5.7  \\n\"\n                     \"::1    ipv6.com\");\n  EnvValue with_env(\"CARES_HOSTS\", hostsfile.filename());\n  struct ares_addrinfo_hints hints = {};\n  AddrInfoResult result = {};\n  hints.ai_family = AF_INET;\n  hints.ai_flags = ARES_AI_CANONNAME | ARES_AI_ENVHOSTS | ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"www2.google.com\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.ai_;\n  EXPECT_EQ(\"{www.google.com->google.com, www2.google.com->google.com addr=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              326,
              0
            ],
            [
              344,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(FileChannelTest, GetAddrInfoHostsIPV6) {\n  TempFile hostsfile(\"1.2.3.4 example.com  \\n\"\n                     \"  2.3.4.5\\tgoogle.com   www.google.com\\twww2.google.com\\n\"\n                     \"#comment\\n\"\n                     \"4.5.6.7\\n\"\n                     \"1.3.5.7  \\n\"\n                     \"::1    ipv6.com\");\n  EnvValue with_env(\"CARES_HOSTS\", hostsfile.filename());\n  struct ares_addrinfo_hints hints = {};\n  AddrInfoResult result = {};\n  hints.ai_family = AF_INET6;\n  hints.ai_flags = ARES_AI_CANONNAME | ARES_AI_ENVHOSTS | ARES_AI_NOSORT;\n  ares_getaddrinfo(channel_, \"ipv6.com\", NULL, &hints, AddrInfoCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.ai_;\n  EXPECT_EQ(\"{ipv6.com addr=[[0000:0000:0000:0000:0000:0000:0000:0001]]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              346,
              0
            ],
            [
              364,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(FileChannelTest, GetAddrInfoAllocFail) {\n  TempFile hostsfile(\"1.2.3.4 example.com alias1 alias2\\n\");\n  EnvValue with_env(\"CARES_HOSTS\", hostsfile.filename());\n  struct ares_addrinfo_hints hints;\n\n  memset(&hints, 0, sizeof(hints));\n  hints.ai_family = AF_INET;\n\n  // Fail a variety of different memory allocations, and confirm\n  // that the operation either fails with ENOMEM or succeeds\n  // with the expected result.\n  const int kCount = 34;\n  AddrInfoResult results[kCount];\n  for (int ii = 1; ii <= kCount; ii++) {\n    AddrInfoResult* result = &(results[ii - 1]);\n    ClearFails();\n    SetAllocFail(ii);\n    ares_getaddrinfo(channel_, \"example.com\", NULL, &hints, AddrInfoCallback, result);\n    Process();\n    EXPECT_TRUE(result->done_);\n    if (result->status_ == ARES_SUCCESS) {\n      std::stringstream ss;\n      ss << result->ai_;\n      EXPECT_EQ(\"{alias1->example.com, alias2->example.com addr=[1.2.3.4]}\", ss.str()) << \" failed alloc #\" << ii;\n      if (verbose) std::cerr << \"Succeeded despite failure of alloc #\" << ii << std::endl;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              367,
              0
            ],
            [
              394,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(Misc, OnionDomain) {\n  EXPECT_EQ(0, ares__is_onion_domain(\"onion.no\"));\n  EXPECT_EQ(0, ares__is_onion_domain(\".onion.no\"));\n  EXPECT_EQ(1, ares__is_onion_domain(\".onion\"));\n  EXPECT_EQ(1, ares__is_onion_domain(\".onion.\"));\n  EXPECT_EQ(1, ares__is_onion_domain(\"yes.onion\"));\n  EXPECT_EQ(1, ares__is_onion_domain(\"yes.onion.\"));\n  EXPECT_EQ(1, ares__is_onion_domain(\"YES.ONION\"));\n  EXPECT_EQ(1, ares__is_onion_domain(\"YES.ONION.\"));\n}",
          "fn_code_pos": [
            [
              396,
              0
            ],
            [
              405,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, DNSRecord) {\n  ares_dns_record_t   *dnsrec = NULL;\n  ares_dns_rr_t       *rr     = NULL;\n  struct in_addr       addr;\n  struct ares_in6_addr addr6;\n  unsigned char       *msg    = NULL;\n  size_t               msglen = 0;\n  size_t               qdcount = 0;\n  size_t               ancount = 0;\n  size_t               nscount = 0;\n  size_t               arcount = 0;\n\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_create(&dnsrec, 0x1234,\n      ARES_FLAG_QR|ARES_FLAG_AA|ARES_FLAG_RD|ARES_FLAG_RA,\n      ARES_OPCODE_QUERY, ARES_RCODE_NOERROR));\n\n  /* == Question == */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_query_add(dnsrec, \"example.com\",\n      ARES_REC_TYPE_ANY,\n      ARES_CLASS_IN));\n\n  /* == Answer == */\n  /* A */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ANSWER, \"example.com\",\n      ARES_REC_TYPE_A, ARES_CLASS_IN, 300));\n  EXPECT_LT(0, ares_inet_net_pton(AF_INET, \"1.1.1.1\", &addr, sizeof(addr)));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_addr(rr, ARES_RR_A_ADDR, &addr));\n  /* AAAA */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ANSWER, \"example.com\",\n      ARES_REC_TYPE_AAAA, ARES_CLASS_IN, 300));\n  EXPECT_LT(0, ares_inet_net_pton(AF_INET6, \"2600::4\", &addr6, sizeof(addr6)));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_addr6(rr, ARES_RR_AAAA_ADDR, &addr6));\n  /* MX */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ANSWER, \"example.com\",\n      ARES_REC_TYPE_MX, ARES_CLASS_IN, 3600));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_MX_PREFERENCE, 10));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_MX_EXCHANGE, \"mail.example.com\"));\n  /* CNAME */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ANSWER, \"example.com\",\n      ARES_REC_TYPE_CNAME, ARES_CLASS_IN, 3600));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_CNAME_CNAME, \"b.example.com\"));\n  /* TXT */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ANSWER, \"example.com\",\n      ARES_REC_TYPE_TXT, ARES_CLASS_IN, 3600));\n  const char txt[] = \"blah=here blah=there anywhere\";\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_bin(rr, ARES_RR_TXT_DATA, (unsigned char *)txt,\n      sizeof(txt)));\n\n  /* == Authority == */\n  /* NS */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_AUTHORITY, \"example.com\",\n      ARES_REC_TYPE_NS, ARES_CLASS_IN, 38400));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_NS_NSDNAME, \"ns1.example.com\"));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_AUTHORITY, \"example.com\",\n      ARES_REC_TYPE_NS, ARES_CLASS_IN, 38400));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_NS_NSDNAME, \"ns2.example.com\"));\n  /* SOA */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_AUTHORITY, \"example.com\",\n      ARES_REC_TYPE_SOA, ARES_CLASS_IN, 86400));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_SOA_MNAME, \"ns1.example.com\"));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_SOA_RNAME, \"tech\\\\.support.example.com\"));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u32(rr, ARES_RR_SOA_SERIAL, 2023110701));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u32(rr, ARES_RR_SOA_REFRESH, 28800));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u32(rr, ARES_RR_SOA_RETRY, 7200));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u32(rr, ARES_RR_SOA_EXPIRE, 604800));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u32(rr, ARES_RR_SOA_MINIMUM, 86400));\n\n  /* == Additional */\n  /* OPT */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL, \"\",\n      ARES_REC_TYPE_OPT, ARES_CLASS_IN, 0));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_OPT_UDP_SIZE, 1280));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u8(rr, ARES_RR_OPT_VERSION, 0));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_OPT_FLAGS, 0));\n  unsigned char optval[] = { 'c', '-', 'a', 'r', 'e', 's' };\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_opt(rr, ARES_RR_OPT_OPTIONS, 3 /* NSID */, optval, sizeof(optval)));\n  /* PTR -- doesn't make sense, but ok */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL, \"example.com\",\n      ARES_REC_TYPE_PTR, ARES_CLASS_IN, 300));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_PTR_DNAME, \"b.example.com\"));\n  /* HINFO */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL, \"example.com\",\n      ARES_REC_TYPE_HINFO, ARES_CLASS_IN, 300));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_HINFO_CPU, \"Virtual\"));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_HINFO_OS, \"Linux\"));\n  /* SRV */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL,\n      \"_ldap.example.com\", ARES_REC_TYPE_SRV, ARES_CLASS_IN, 300));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_SRV_PRIORITY, 100));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_SRV_WEIGHT, 1));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_SRV_PORT, 389));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_SRV_TARGET, \"ldap.example.com\"));\n  /* TLSA */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL,\n      \"_443._tcp.example.com\", ARES_REC_TYPE_TLSA, ARES_CLASS_IN, 86400));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u8(rr, ARES_RR_TLSA_CERT_USAGE, ARES_TLSA_USAGE_CA));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u8(rr, ARES_RR_TLSA_SELECTOR, ARES_TLSA_SELECTOR_FULL));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u8(rr, ARES_RR_TLSA_MATCH, ARES_TLSA_MATCH_SHA256));\n  const unsigned char tlsa[] = {\n    0xd2, 0xab, 0xde, 0x24, 0x0d, 0x7c, 0xd3, 0xee, 0x6b, 0x4b, 0x28, 0xc5,\n    0x4d, 0xf0, 0x34, 0xb9, 0x79, 0x83, 0xa1, 0xd1, 0x6e, 0x8a, 0x41, 0x0e,\n    0x45, 0x61, 0xcb, 0x10, 0x66, 0x18, 0xe9, 0x71 };\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_bin(rr, ARES_RR_TLSA_DATA, tlsa, sizeof(tlsa)));\n  /* SVCB */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL,\n      \"_1234._bar.example.com\", ARES_REC_TYPE_SVCB, ARES_CLASS_IN, 300));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_SVCB_PRIORITY, 1));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_SVCB_TARGET, \"svc1.example.net\"));\n  /* IPV6 hint is a list of IPV6 addresses in network byte order, concatenated */\n  struct ares_addr svcb_addr;\n  svcb_addr.family = AF_UNSPEC;\n  size_t               svcb_ipv6hint_len = 0;\n  const unsigned char *svcb_ipv6hint = (const unsigned char *)ares_dns_pton(\"2001:db8::1\", &svcb_addr, &svcb_ipv6hint_len);\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_opt(rr, ARES_RR_SVCB_PARAMS, ARES_SVCB_PARAM_IPV6HINT,\n      svcb_ipv6hint, svcb_ipv6hint_len));\n  /* Port is 16bit big endian format */\n  unsigned short svcb_port = htons(1234);\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_opt(rr, ARES_RR_SVCB_PARAMS, ARES_SVCB_PARAM_PORT,\n      (const unsigned char *)&svcb_port, sizeof(svcb_port)));\n  /* HTTPS */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL,\n      \"example.com\", ARES_REC_TYPE_HTTPS, ARES_CLASS_IN, 300));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_HTTPS_PRIORITY, 1));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_HTTPS_TARGET, \"\"));\n\n  /* In DNS string format which is 1 octet length indicator followed by string */\n  const unsigned char https_alpn[] = { 0x02, 'h', '3' };\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_opt(rr, ARES_RR_HTTPS_PARAMS, ARES_SVCB_PARAM_ALPN,\n      https_alpn, sizeof(https_alpn)));\n  /* URI */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL,\n      \"_ftp._tcp.example.com\", ARES_REC_TYPE_URI, ARES_CLASS_IN, 3600));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_URI_PRIORITY, 10));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_URI_WEIGHT, 1));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_URI_TARGET, \"ftp://ftp.example.com/public\"));\n  /* CAA */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL,\n      \"example.com\", ARES_REC_TYPE_CAA, ARES_CLASS_IN, 86400));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u8(rr, ARES_RR_CAA_CRITICAL, 0));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_CAA_TAG, \"issue\"));\n  unsigned char caa[] = \"letsencrypt.org\";\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_bin(rr, ARES_RR_CAA_VALUE, caa, sizeof(caa)));\n  /* NAPTR */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL,\n      \"example.com\", ARES_REC_TYPE_NAPTR, ARES_CLASS_IN, 86400));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_NAPTR_ORDER, 100));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_NAPTR_PREFERENCE, 10));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_NAPTR_FLAGS, \"S\"));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_NAPTR_SERVICES, \"SIP+D2U\"));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_NAPTR_REGEXP,\n      \"!^.*$!sip:customer-service@example.com!\"));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_NAPTR_REPLACEMENT,\n      \"_sip._udp.example.com.\"));\n  /* RAW_RR */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL, \"\",\n      ARES_REC_TYPE_RAW_RR, ARES_CLASS_IN, 0));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u16(rr, ARES_RR_RAW_RR_TYPE, 65432));\n  unsigned char data[] = { 0x00 };\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_bin(rr, ARES_RR_RAW_RR_DATA, data, sizeof(data)));\n\n  qdcount = ares_dns_record_query_cnt(dnsrec);\n  ancount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER);\n  nscount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_AUTHORITY);\n  arcount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ADDITIONAL);\n\n  /* Write */\n  EXPECT_EQ(ARES_SUCCESS, ares_dns_write(dnsrec, &msg, &msglen));\n\n  ares__buf_t *hexdump = ares__buf_create();\n  EXPECT_EQ(ARES_SUCCESS, ares__buf_hexdump(hexdump, msg, msglen));\n  char *hexdata = ares__buf_finish_str(hexdump, NULL);\n  //printf(\"HEXDUMP\\n%s\", hexdata);\n  ares_free(hexdata);\n  ares_dns_record_destroy(dnsrec); dnsrec = NULL;\n\n  /* Parse */\n  EXPECT_EQ(ARES_SUCCESS, ares_dns_parse(msg, msglen, 0, &dnsrec));\n  ares_free(msg); msg = NULL;\n\n  /* Re-write */\n  EXPECT_EQ(ARES_SUCCESS, ares_dns_write(dnsrec, &msg, &msglen));\n\n  EXPECT_EQ(qdcount, ares_dns_record_query_cnt(dnsrec));\n  EXPECT_EQ(ancount, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER));\n  EXPECT_EQ(nscount, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_AUTHORITY));\n  EXPECT_EQ(arcount, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ADDITIONAL));\n\n  /* Iterate and print */\n  ares__buf_t *printmsg = ares__buf_create();\n  ares__buf_append_str(printmsg, \";; ->>HEADER<<- opcode: \");\n  ares__buf_append_str(printmsg, ares_dns_opcode_tostr(ares_dns_record_get_opcode(dnsrec)));\n  ares__buf_append_str(printmsg, \", status: \");\n  ares__buf_append_str(printmsg, ares_dns_rcode_tostr(ares_dns_record_get_rcode(dnsrec)));\n  ares__buf_append_str(printmsg, \", id: \");\n  ares__buf_append_num_dec(printmsg, (size_t)ares_dns_record_get_id(dnsrec), 0);\n  ares__buf_append_str(printmsg, \"\\n;; flags: \");\n  ares__buf_append_num_hex(printmsg, (size_t)ares_dns_record_get_flags(dnsrec), 0);\n  ares__buf_append_str(printmsg, \"; QUERY: \");\n  ares__buf_append_num_dec(printmsg, ares_dns_record_query_cnt(dnsrec), 0);\n  ares__buf_append_str(printmsg, \", ANSWER: \");\n  ares__buf_append_num_dec(printmsg, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER), 0);\n  ares__buf_append_str(printmsg, \", AUTHORITY: \");\n  ares__buf_append_num_dec(printmsg, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_AUTHORITY), 0);\n  ares__buf_append_str(printmsg, \", ADDITIONAL: \");\n  ares__buf_append_num_dec(printmsg, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ADDITIONAL), 0);\n  ares__buf_append_str(printmsg, \"\\n\\n\");\n  ares__buf_append_str(printmsg, \";; QUESTION SECTION:\\n\");\n  for (size_t i = 0; i < ares_dns_record_query_cnt(dnsrec); i++) {\n    const char         *name;\n    ares_dns_rec_type_t qtype;\n    ares_dns_class_t    qclass;\n    ares_dns_record_query_get(dnsrec, i, &name, &qtype, &qclass);\n    ares__buf_append_str(printmsg, \";\");\n    ares__buf_append_str(printmsg, name);\n    ares__buf_append_str(printmsg, \".\\t\\t\\t\");\n    ares__buf_append_str(printmsg, ares_dns_class_tostr(qclass));\n    ares__buf_append_str(printmsg, \"\\t\");\n    ares__buf_append_str(printmsg, ares_dns_rec_type_tostr(qtype));\n    ares__buf_append_str(printmsg, \"\\n\");\n  }\n  ares__buf_append_str(printmsg, \"\\n\");\n  for (size_t i = ARES_SECTION_ANSWER; i < ARES_SECTION_ADDITIONAL + 1; i++) {\n    ares__buf_append_str(printmsg, \";; \");\n    ares__buf_append_str(printmsg, ares_dns_section_tostr((ares_dns_section_t)i));\n    ares__buf_append_str(printmsg, \" SECTION:\\n\");\n    for (size_t j = 0; j < ares_dns_record_rr_cnt(dnsrec, (ares_dns_section_t)i); j++) {\n      const ares_dns_rr_t *rr = ares_dns_record_rr_get(dnsrec, (ares_dns_section_t)i, j);\n      ares__buf_append_str(printmsg, ares_dns_rr_get_name(rr));\n      ares__buf_append_str(printmsg, \".\\t\\t\\t\");\n      ares__buf_append_str(printmsg, ares_dns_class_tostr(ares_dns_rr_get_class(rr)));\n      ares__buf_append_str(printmsg, \"\\t\");\n      ares__buf_append_str(printmsg, ares_dns_rec_type_tostr(ares_dns_rr_get_type(rr)));\n      ares__buf_append_str(printmsg, \"\\t\");\n      ares__buf_append_num_dec(printmsg, ares_dns_rr_get_ttl(rr), 0);\n      ares__buf_append_str(printmsg, \"\\t\");\n\n      size_t keys_cnt;\n      const ares_dns_rr_key_t *keys = ares_dns_rr_get_keys(ares_dns_rr_get_type(rr), &keys_cnt);\n      for (size_t k = 0; k<keys_cnt; k++) {\n        char buf[256] = \"\";\n        ares__buf_append_str(printmsg, ares_dns_rr_key_tostr(keys[k]));\n        ares__buf_append_str(printmsg, \"=\");\n        switch (ares_dns_rr_key_datatype(keys[k])) {\n          case ARES_DATATYPE_INADDR:\n            ares_inet_ntop(AF_INET, ares_dns_rr_get_addr(rr, keys[k]), buf, sizeof(buf));\n            ares__buf_append_str(printmsg, buf);\n            break;\n          case ARES_DATATYPE_INADDR6:\n            ares_inet_ntop(AF_INET6, ares_dns_rr_get_addr6(rr, keys[k]), buf, sizeof(buf));\n            ares__buf_append_str(printmsg, buf);\n            break;\n          case ARES_DATATYPE_U8:\n            ares__buf_append_num_dec(printmsg, ares_dns_rr_get_u8(rr, keys[k]), 0);\n            break;\n          case ARES_DATATYPE_U16:\n            ares__buf_append_num_dec(printmsg, ares_dns_rr_get_u16(rr, keys[k]), 0);\n            break;\n          case ARES_DATATYPE_U32:\n            ares__buf_append_num_dec(printmsg, ares_dns_rr_get_u32(rr, keys[k]), 0);\n            break;\n          case ARES_DATATYPE_NAME:\n          case ARES_DATATYPE_STR:\n            ares__buf_append_byte(printmsg, '\"');\n            ares__buf_append_str(printmsg, ares_dns_rr_get_str(rr, keys[k]));\n            ares__buf_append_byte(printmsg, '\"');\n            break;\n          case ARES_DATATYPE_BIN:\n            /* TODO */\n            break;\n          case ARES_DATATYPE_BINP:\n            ares__buf_append_byte(printmsg, '\"');\n            size_t templen;\n            ares__buf_append_str(printmsg, (const char *)ares_dns_rr_get_bin(rr, keys[k], &templen));\n            ares__buf_append_byte(printmsg, '\"');\n            break;\n          case ARES_DATATYPE_OPT:\n            /* TODO */\n            break;\n        }\n        ares__buf_append_str(printmsg, \" \");\n      }\n      ares__buf_append_str(printmsg, \"\\n\");\n    }\n  }\n  ares__buf_append_str(printmsg, \";; SIZE: \");\n  ares__buf_append_num_dec(printmsg, msglen, 0);\n  ares__buf_append_str(printmsg, \"\\n\\n\");\n\n  char *printdata = ares__buf_finish_str(printmsg, NULL);\n  //printf(\"%s\", printdata);\n  ares_free(printdata);\n\n  ares_dns_record_destroy(dnsrec);\n  ares_free(msg);\n}",
          "fn_code_pos": [
            [
              407,
              0
            ],
            [
              773,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, DNSParseFlags) {\n  ares_dns_record_t   *dnsrec = NULL;\n  ares_dns_rr_t       *rr     = NULL;\n  struct in_addr       addr;\n  unsigned char       *msg    = NULL;\n  size_t               msglen = 0;\n\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_create(&dnsrec, 0x1234,\n      ARES_FLAG_QR|ARES_FLAG_AA|ARES_FLAG_RD|ARES_FLAG_RA,\n      ARES_OPCODE_QUERY, ARES_RCODE_NOERROR));\n\n  /* == Question == */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_query_add(dnsrec, \"example.com\",\n      ARES_REC_TYPE_ANY,\n      ARES_CLASS_IN));\n\n  /* == Answer == */\n  /* A */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ANSWER, \"example.com\",\n      ARES_REC_TYPE_A, ARES_CLASS_IN, 300));\n  EXPECT_LT(0, ares_inet_net_pton(AF_INET, \"1.1.1.1\", &addr, sizeof(addr)));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_addr(rr, ARES_RR_A_ADDR, &addr));\n  /* TLSA */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ANSWER,\n      \"_443._tcp.example.com\", ARES_REC_TYPE_TLSA, ARES_CLASS_IN, 86400));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u8(rr, ARES_RR_TLSA_CERT_USAGE, ARES_TLSA_USAGE_CA));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u8(rr, ARES_RR_TLSA_SELECTOR, ARES_TLSA_SELECTOR_FULL));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_u8(rr, ARES_RR_TLSA_MATCH, ARES_TLSA_MATCH_SHA256));\n  const unsigned char tlsa[] = {\n    0xd2, 0xab, 0xde, 0x24, 0x0d, 0x7c, 0xd3, 0xee, 0x6b, 0x4b, 0x28, 0xc5,\n    0x4d, 0xf0, 0x34, 0xb9, 0x79, 0x83, 0xa1, 0xd1, 0x6e, 0x8a, 0x41, 0x0e,\n    0x45, 0x61, 0xcb, 0x10, 0x66, 0x18, 0xe9, 0x71 };\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_bin(rr, ARES_RR_TLSA_DATA, tlsa, sizeof(tlsa)));\n\n  /* == Authority == */\n  /* NS */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_AUTHORITY, \"example.com\",\n      ARES_REC_TYPE_NS, ARES_CLASS_IN, 38400));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_NS_NSDNAME, \"ns1.example.com\"));\n\n  /* == Additional */\n  /* PTR -- doesn't make sense, but ok */\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_record_rr_add(&rr, dnsrec, ARES_SECTION_ADDITIONAL, \"example.com\",\n      ARES_REC_TYPE_PTR, ARES_CLASS_IN, 300));\n  EXPECT_EQ(ARES_SUCCESS,\n    ares_dns_rr_set_str(rr, ARES_RR_PTR_DNAME, \"b.example.com\"));\n\n  /* Write */\n  EXPECT_EQ(ARES_SUCCESS, ares_dns_write(dnsrec, &msg, &msglen));\n\n  /* Cleanup - before reuse */\n  ares_dns_record_destroy(dnsrec);\n\n  /* Parse \"base\" type records (1035) */\n  EXPECT_EQ(ARES_SUCCESS, ares_dns_parse(msg, msglen, ARES_DNS_PARSE_AN_BASE_RAW |\n    ARES_DNS_PARSE_NS_BASE_RAW | ARES_DNS_PARSE_AR_BASE_RAW, &dnsrec));\n\n  EXPECT_EQ(1, ares_dns_record_query_cnt(dnsrec));\n  EXPECT_EQ(2, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER));\n  EXPECT_EQ(1, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_AUTHORITY));\n  EXPECT_EQ(1, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ADDITIONAL));\n\n  rr = ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, 0);\n  EXPECT_EQ(ARES_REC_TYPE_RAW_RR, ares_dns_rr_get_type(rr));\n\n  rr = ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, 1);\n  EXPECT_EQ(ARES_REC_TYPE_TLSA, ares_dns_rr_get_type(rr));\n\n  rr = ares_dns_record_rr_get(dnsrec, ARES_SECTION_AUTHORITY, 0);\n  EXPECT_EQ(ARES_REC_TYPE_RAW_RR, ares_dns_rr_get_type(rr));\n\n  rr = ares_dns_record_rr_get(dnsrec, ARES_SECTION_ADDITIONAL, 0);\n  EXPECT_EQ(ARES_REC_TYPE_RAW_RR, ares_dns_rr_get_type(rr));\n\n  /* Cleanup - before reuse */\n\n  ares_dns_record_destroy(dnsrec);\n\n  /* Parse later RFCs (no name compression) type records */\n\n  EXPECT_EQ(ARES_SUCCESS, ares_dns_parse(msg, msglen, ARES_DNS_PARSE_AN_EXT_RAW |\n    ARES_DNS_PARSE_NS_EXT_RAW | ARES_DNS_PARSE_AR_EXT_RAW, &dnsrec));\n\n  EXPECT_EQ(1, ares_dns_record_query_cnt(dnsrec));\n  EXPECT_EQ(2, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER));\n  EXPECT_EQ(1, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_AUTHORITY));\n  EXPECT_EQ(1, ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ADDITIONAL));\n\n  rr = ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, 0);\n  EXPECT_EQ(ARES_REC_TYPE_A, ares_dns_rr_get_type(rr));\n\n  rr = ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, 1);\n  EXPECT_EQ(ARES_REC_TYPE_RAW_RR, ares_dns_rr_get_type(rr));\n\n  rr = ares_dns_record_rr_get(dnsrec, ARES_SECTION_AUTHORITY, 0);\n  EXPECT_EQ(ARES_REC_TYPE_NS, ares_dns_rr_get_type(rr));\n\n  rr = ares_dns_record_rr_get(dnsrec, ARES_SECTION_ADDITIONAL, 0);\n  EXPECT_EQ(ARES_REC_TYPE_PTR, ares_dns_rr_get_type(rr));\n\n  ares_dns_record_destroy(dnsrec);\n  ares_free(msg); msg = NULL;\n}",
          "fn_code_pos": [
            [
              775,
              0
            ],
            [
              889,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, CatDomain) {\n  char *s;\n\n  ares__cat_domain(\"foo\", \"example.net\", &s);\n  EXPECT_STREQ(\"foo.example.net\", s);\n  ares_free(s);\n\n  ares__cat_domain(\"foo\", \".\", &s);\n  EXPECT_STREQ(\"foo.\", s);\n  ares_free(s);\n\n  ares__cat_domain(\"foo\", \"example.net.\", &s);\n  EXPECT_STREQ(\"foo.example.net.\", s);\n  ares_free(s);\n}",
          "fn_code_pos": [
            [
              891,
              0
            ],
            [
              905,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, BufMisuse) {\n  EXPECT_EQ(NULL, ares__buf_create_const(NULL, 0));\n  ares__buf_reclaim(NULL);\n  EXPECT_NE(ARES_SUCCESS, ares__buf_append(NULL, NULL, 0));\n  size_t len = 10;\n  EXPECT_EQ(NULL, ares__buf_append_start(NULL, &len));\n  EXPECT_EQ(NULL, ares__buf_append_start(NULL, NULL));\n  ares__buf_append_finish(NULL, 0);\n  EXPECT_EQ(NULL, ares__buf_finish_bin(NULL, NULL));\n  EXPECT_EQ(NULL, ares__buf_finish_str(NULL, NULL));\n  ares__buf_tag(NULL);\n  EXPECT_NE(ARES_SUCCESS, ares__buf_tag_rollback(NULL));\n  EXPECT_NE(ARES_SUCCESS, ares__buf_tag_clear(NULL));\n  EXPECT_EQ(NULL, ares__buf_tag_fetch(NULL, NULL));\n  EXPECT_EQ((size_t)0, ares__buf_tag_length(NULL));\n  EXPECT_NE(ARES_SUCCESS, ares__buf_tag_fetch_bytes(NULL, NULL, NULL));\n  EXPECT_NE(ARES_SUCCESS, ares__buf_tag_fetch_string(NULL, NULL, 0));\n  EXPECT_NE(ARES_SUCCESS, ares__buf_fetch_bytes_dup(NULL, 0, ARES_FALSE, NULL));\n  EXPECT_NE(ARES_SUCCESS, ares__buf_fetch_str_dup(NULL, 0, NULL));\n  EXPECT_EQ((size_t)0, ares__buf_consume_whitespace(NULL, ARES_FALSE));\n  EXPECT_EQ((size_t)0, ares__buf_consume_nonwhitespace(NULL));\n  EXPECT_EQ((size_t)0, ares__buf_consume_line(NULL, ARES_FALSE));\n  EXPECT_EQ(ARES_FALSE, ares__buf_begins_with(NULL, NULL, 0));\n  EXPECT_EQ((size_t)0, ares__buf_get_position(NULL));\n  EXPECT_NE(ARES_SUCCESS, ares__buf_set_position(NULL, 0));\n  EXPECT_NE(ARES_SUCCESS, ares__dns_name_parse(NULL, NULL, ARES_FALSE));\n  EXPECT_NE(ARES_SUCCESS, ares__buf_parse_dns_binstr(NULL, 0, NULL, NULL, ARES_FALSE));\n}",
          "fn_code_pos": [
            [
              907,
              0
            ],
            [
              934,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, HtableMisuse) {\n  EXPECT_EQ(NULL, ares__htable_create(NULL, NULL, NULL, NULL));\n  EXPECT_EQ(ARES_FALSE, ares__htable_insert(NULL, NULL));\n  EXPECT_EQ(NULL, ares__htable_get(NULL, NULL));\n  EXPECT_EQ(ARES_FALSE, ares__htable_remove(NULL, NULL));\n  EXPECT_EQ((size_t)0, ares__htable_num_keys(NULL));\n}",
          "fn_code_pos": [
            [
              936,
              0
            ],
            [
              942,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, HtableAsvpMisuse) {\n  EXPECT_EQ(ARES_FALSE, ares__htable_asvp_insert(NULL, ARES_SOCKET_BAD, NULL));\n  EXPECT_EQ(ARES_FALSE, ares__htable_asvp_get(NULL, ARES_SOCKET_BAD, NULL));\n  EXPECT_EQ(ARES_FALSE, ares__htable_asvp_remove(NULL, ARES_SOCKET_BAD));\n  EXPECT_EQ((size_t)0, ares__htable_asvp_num_keys(NULL));\n}",
          "fn_code_pos": [
            [
              944,
              0
            ],
            [
              949,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, HtableStrvpMisuse) {\n  EXPECT_EQ(ARES_FALSE, ares__htable_strvp_insert(NULL, NULL, NULL));\n  EXPECT_EQ(ARES_FALSE, ares__htable_strvp_get(NULL, NULL, NULL));\n  EXPECT_EQ(ARES_FALSE, ares__htable_strvp_remove(NULL, NULL));\n  EXPECT_EQ((size_t)0, ares__htable_strvp_num_keys(NULL));\n}",
          "fn_code_pos": [
            [
              951,
              0
            ],
            [
              956,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, HtableSzvpMisuse) {\n  EXPECT_EQ(ARES_FALSE, ares__htable_szvp_insert(NULL, 0, NULL));\n  EXPECT_EQ(ARES_FALSE, ares__htable_szvp_get(NULL, 0, NULL));\n  EXPECT_EQ(ARES_FALSE, ares__htable_szvp_remove(NULL, 0));\n  EXPECT_EQ((size_t)0, ares__htable_szvp_num_keys(NULL));\n}",
          "fn_code_pos": [
            [
              958,
              0
            ],
            [
              963,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, LlistMisuse) {\n  ares__llist_replace_destructor(NULL, NULL);\n  EXPECT_EQ(NULL, ares__llist_insert_before(NULL, NULL));\n  EXPECT_EQ(NULL, ares__llist_insert_after(NULL, NULL));\n  EXPECT_EQ(NULL, ares__llist_node_last(NULL));\n  EXPECT_EQ(NULL, ares__llist_node_next(NULL));\n  EXPECT_EQ(NULL, ares__llist_node_prev(NULL));\n  EXPECT_EQ((size_t)0, ares__llist_len(NULL));\n  EXPECT_EQ(NULL, ares__llist_node_parent(NULL));\n  EXPECT_EQ(NULL, ares__llist_node_claim(NULL));\n  ares__llist_node_replace(NULL, NULL);\n}",
          "fn_code_pos": [
            [
              965,
              0
            ],
            [
              976,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, SlistMisuse) {\n  EXPECT_EQ(NULL, ares__slist_create(NULL, NULL, NULL));\n  ares__slist_replace_destructor(NULL, NULL);\n  EXPECT_EQ(NULL, ares__slist_insert(NULL, NULL));\n  EXPECT_EQ(NULL, ares__slist_node_find(NULL, NULL));\n  EXPECT_EQ(NULL, ares__slist_node_first(NULL));\n  EXPECT_EQ(NULL, ares__slist_node_last(NULL));\n  EXPECT_EQ(NULL, ares__slist_node_next(NULL));\n  EXPECT_EQ(NULL, ares__slist_node_prev(NULL));\n  EXPECT_EQ(NULL, ares__slist_node_val(NULL));\n  EXPECT_EQ((size_t)0, ares__slist_len(NULL));\n  EXPECT_EQ(NULL, ares__slist_node_parent(NULL));\n  EXPECT_EQ(NULL, ares__slist_first_val(NULL));\n  EXPECT_EQ(NULL, ares__slist_last_val(NULL));\n  EXPECT_EQ(NULL, ares__slist_node_claim(NULL));\n}",
          "fn_code_pos": [
            [
              978,
              0
            ],
            [
              993,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(DefaultChannelTest, SaveInvalidChannel) {\n  ares__slist_t *saved = channel_->servers;\n  channel_->servers = NULL;\n  struct ares_options opts;\n  int optmask = 0;\n  EXPECT_EQ(ARES_ENODATA, ares_save_options(channel_, &opts, &optmask));\n  channel_->servers = saved;\n}",
          "fn_code_pos": [
            [
              996,
              0
            ],
            [
              1003,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static int configure_socket(ares_socket_t s) {\n  // transposed from ares-process, simplified non-block setter.\n#if defined(USE_BLOCKING_SOCKETS)\n  return 0; /* returns success */\n#elif defined(HAVE_FCNTL_O_NONBLOCK)\n  /* most recent unix versions */\n  int flags;\n  flags = fcntl(s, F_GETFL, 0);\n  return fcntl(s, F_SETFL, flags | O_NONBLOCK);\n#elif defined(HAVE_IOCTL_FIONBIO)\n  /* older unix versions */\n  int flags = 1;\n  return ioctl(s, FIONBIO, &flags);\n#elif defined(HAVE_IOCTLSOCKET_FIONBIO)\n#ifdef WATT32\n  char flags = 1;\n#else\n  /* Windows */\n  unsigned long flags = 1UL;\n#endif\n  return ioctlsocket(s, (long)FIONBIO, &flags);\n#elif defined(HAVE_IOCTLSOCKET_CAMEL_FIONBIO)\n  /* Amiga */\n  long flags = 1L;\n  return IoctlSocket(s, FIONBIO, flags);\n#elif defined(HAVE_SETSOCKOPT_SO_NONBLOCK)\n  /* BeOS */\n  long b = 1L;\n  return setsockopt(s, SOL_SOCKET, SO_NONBLOCK, &b, sizeof(b));\n#else\n#  error \"no non-blocking method was found/used/set\"\n#endif\n}",
          "fn_code_pos": [
            [
              1007,
              0
            ],
            [
              1039,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "configure_socket",
            "parameters": {
              "s": "ares_socket_t"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct {\n    vector<string> inputs;\n    vector<string> delimiters;\n    vector<vector<string>> expected;\n  }",
          {
            "inputs": "vector<string>",
            "delimiters": "vector<string>",
            "expected": "vector<vector<string>>"
          },
          "",
          [
            81,
            2
          ],
          [
            85,
            3
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            67,
            2
          ],
          [
            67,
            16
          ]
        ],
        [
          "struct {\n    vector<string> inputs;\n    vector<string> delimiters;\n    vector<vector<string>> expected;\n  }",
          {
            "inputs": "vector<string>",
            "delimiters": "vector<string>",
            "expected": "vector<vector<string>>"
          },
          "",
          [
            81,
            2
          ],
          [
            85,
            3
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            118,
            2
          ],
          [
            118,
            16
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            119,
            2
          ],
          [
            119,
            17
          ]
        ],
        [
          "struct ares_data",
          {},
          "",
          [
            235,
            2
          ],
          [
            235,
            18
          ]
        ],
        [
          "struct ares_data",
          {},
          "",
          [
            235,
            28
          ],
          [
            235,
            44
          ]
        ],
        [
          "struct ares_data",
          {},
          "",
          [
            235,
            61
          ],
          [
            235,
            77
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            256,
            2
          ],
          [
            256,
            23
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            258,
            4
          ],
          [
            258,
            25
          ]
        ],
        [
          "struct ares_addr_node",
          {},
          "",
          [
            258,
            35
          ],
          [
            258,
            56
          ]
        ],
        [
          "struct ares_data",
          {},
          "",
          [
            282,
            26
          ],
          [
            282,
            42
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            294,
            2
          ],
          [
            294,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            314,
            2
          ],
          [
            314,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            334,
            2
          ],
          [
            334,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            354,
            2
          ],
          [
            354,
            28
          ]
        ],
        [
          "struct ares_addrinfo_hints",
          {},
          "",
          [
            370,
            2
          ],
          [
            370,
            28
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            410,
            2
          ],
          [
            410,
            16
          ]
        ],
        [
          "struct ares_in6_addr",
          {},
          "",
          [
            411,
            2
          ],
          [
            411,
            22
          ]
        ],
        [
          "struct ares_addr",
          {},
          "",
          [
            564,
            2
          ],
          [
            564,
            18
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            778,
            2
          ],
          [
            778,
            16
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            999,
            2
          ],
          [
            999,
            21
          ]
        ],
        [
          "struct ares_socket_functions",
          {},
          "",
          [
            1043,
            6
          ],
          [
            1043,
            34
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <sys/ioctl.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"ares_setup.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"ares_inet_net_pton.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include \"ares_data.h\"\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include \"ares_strsplit.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include \"ares_private.h\"\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include \"ares__htable.h\"\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <arpa/inet.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#  include <sys/uio.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-mock-et.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_P(MockEventThreadTest, Basic) {\n  std::vector<byte> reply = {\n    0x00, 0x00,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // 1 question\n    0x00, 0x01,  // 1 answer RRs\n    0x00, 0x00,  // 0 authority RRs\n    0x00, 0x00,  // 0 additional RRs\n    // Question\n    0x03, 'w', 'w', 'w',\n    0x06, 'g', 'o', 'o', 'g', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    // Answer\n    0x03, 'w', 'w', 'w',\n    0x06, 'g', 'o', 'o', 'g', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x01,  // type A\n    0x00, 0x01,  // class IN\n    0x00, 0x00, 0x01, 0x00,  // TTL\n    0x00, 0x04,  // rdata length\n    0x01, 0x02, 0x03, 0x04\n  };\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReplyData(&server_, reply));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              44,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPEventThreadTest, GetHostByNameParallelLookups) {\n  DNSPacket rsp1;\n  rsp1.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp1));\n  DNSPacket rsp2;\n  rsp2.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {1, 2, 3, 4}));\n  ON_CALL(server_, OnRequest(\"www.example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp2));\n\n  HostResult result1;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result1);\n  HostResult result2;\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result2);\n  HostResult result3;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result3);\n  Process();\n  EXPECT_TRUE(result1.done_);\n  EXPECT_TRUE(result2.done_);\n  EXPECT_TRUE(result3.done_);\n  std::stringstream ss1;\n  ss1 << result1.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss1.str());\n  std::stringstream ss2;\n  ss2 << result2.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[1.2.3.4]}\", ss2.str());\n  std::stringstream ss3;\n  ss3 << result3.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss3.str());\n}",
          "fn_code_pos": [
            [
              85,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPEventThreadTest, TruncationRetry) {\n  DNSPacket rsptruncated;\n  rsptruncated.set_response().set_aa().set_tc()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  DNSPacket rspok;\n  rspok.set_response()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {1, 2, 3, 4}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsptruncated))\n    .WillOnce(SetReply(&server_, &rspok));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              139,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static int SocketConnectCallback(ares_socket_t fd, int type, void *data) {\n  int rc = *(int*)data;\n  if (verbose) std::cerr << \"SocketConnectCallback(\" << fd << \") invoked\" << std::endl;\n  sock_cb_count++;\n  return rc;\n}",
          "fn_code_pos": [
            [
              142,
              0
            ],
            [
              147,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SocketConnectCallback",
            "parameters": {
              "fd": "ares_socket_t",
              "type": "int",
              "data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SockCallback) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n\n  // Get notified of new sockets\n  int rc = ARES_SUCCESS;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n\n  HostResult result;\n  sock_cb_count = 0;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_EQ(1, sock_cb_count);\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              149,
              0
            ],
            [
              170,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SockFailCallback) {\n  // Notification of new sockets gives an error.\n  int rc = -1;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n\n  HostResult result;\n  sock_cb_count = 0;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_LT(1, sock_cb_count);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECONNREFUSED, result.status_);\n}",
          "fn_code_pos": [
            [
              172,
              0
            ],
            [
              184,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, ReInit) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  EXPECT_EQ(ARES_SUCCESS, ares_reinit(channel_));\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              187,
              0
            ],
            [
              203,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockUDPEventThreadMaxQueriesTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), false,\n                          FillOptions(&opts_),\n                          ARES_OPT_UDP_MAX_QUERIES|ARES_OPT_FLAGS) {}",
          "fn_code_pos": [
            [
              212,
              2
            ],
            [
              215,
              69
            ]
          ],
          "class_code": "362d0a4576378f06f2e0f4f63b35aa7eb39d6dda1f57b1f77de87927285ea92b",
          "class_node_pos": [
            [
              208,
              0
            ],
            [
              224,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockUDPEventThreadMaxQueriesTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = ARES_FLAG_STAYOPEN|ARES_FLAG_EDNS;\n    opts->udp_max_queries = MAXUDPQUERIES_LIMIT;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              216,
              2
            ],
            [
              221,
              3
            ]
          ],
          "class_code": "362d0a4576378f06f2e0f4f63b35aa7eb39d6dda1f57b1f77de87927285ea92b",
          "class_node_pos": [
            [
              208,
              0
            ],
            [
              224,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPEventThreadMaxQueriesTest, GetHostByNameParallelLookups) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  // Get notified of new sockets so we can validate how many are created\n  int rc = ARES_SUCCESS;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n  sock_cb_count = 0;\n\n  HostResult result[MAXUDPQUERIES_TOTAL];\n  for (size_t i=0; i<MAXUDPQUERIES_TOTAL; i++) {\n    ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result[i]);\n  }\n\n  Process();\n\n  EXPECT_EQ(MAXUDPQUERIES_TOTAL / MAXUDPQUERIES_LIMIT, sock_cb_count);\n\n  for (size_t i=0; i<MAXUDPQUERIES_TOTAL; i++) {\n    std::stringstream ss;\n    EXPECT_TRUE(result[i].done_);\n    ss << result[i].host_;\n    EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }\n}",
          "fn_code_pos": [
            [
              226,
              0
            ],
            [
              254,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CacheQueriesEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), false,\n                          FillOptions(&opts_),\n                          ARES_OPT_QUERY_CACHE) {}",
          "fn_code_pos": [
            [
              260,
              2
            ],
            [
              263,
              50
            ]
          ],
          "class_code": "d584e1faeb2e94178ee8ee3f66da05be6b4737c49209786eb151b3f6118c45a5",
          "class_node_pos": [
            [
              256,
              0
            ],
            [
              271,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CacheQueriesEventThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->qcache_max_ttl = 3600;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              264,
              2
            ],
            [
              268,
              3
            ]
          ],
          "class_code": "d584e1faeb2e94178ee8ee3f66da05be6b4737c49209786eb151b3f6118c45a5",
          "class_node_pos": [
            [
              256,
              0
            ],
            [
              271,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(CacheQueriesEventThreadTest, GetHostByNameCache) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  // Get notified of new sockets so we can validate how many are created\n  int rc = ARES_SUCCESS;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n  sock_cb_count = 0;\n\n  HostResult result1;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result1);\n  Process();\n\n  std::stringstream ss1;\n  EXPECT_TRUE(result1.done_);\n  ss1 << result1.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss1.str());\n\n  /* Run again, should return cached result */\n  HostResult result2;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result2);\n  Process();\n\n  std::stringstream ss2;\n  EXPECT_TRUE(result2.done_);\n  ss2 << result2.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss2.str());\n\n  EXPECT_EQ(1, sock_cb_count);\n}",
          "fn_code_pos": [
            [
              273,
              0
            ],
            [
              306,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockTCPEventThreadStayOpenTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), true /* tcp */,\n                          FillOptions(&opts_),\n                          ARES_OPT_FLAGS) {}",
          "fn_code_pos": [
            [
              314,
              2
            ],
            [
              317,
              44
            ]
          ],
          "class_code": "22cd971b210e000f2935784af0ae7d48c939af82adaf34d98cfc91d265636dcc",
          "class_node_pos": [
            [
              310,
              0
            ],
            [
              325,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockTCPEventThreadStayOpenTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = ARES_FLAG_STAYOPEN|ARES_FLAG_EDNS;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              318,
              2
            ],
            [
              322,
              3
            ]
          ],
          "class_code": "22cd971b210e000f2935784af0ae7d48c939af82adaf34d98cfc91d265636dcc",
          "class_node_pos": [
            [
              310,
              0
            ],
            [
              325,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPEventThreadStayOpenTest, GetHostByNameParallelLookups) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  // Get notified of new sockets so we can validate how many are created\n  int rc = ARES_SUCCESS;\n  ares_set_socket_callback(channel_, SocketConnectCallback, &rc);\n  sock_cb_count = 0;\n\n  HostResult result[TCPPARALLELLOOKUPS];\n  for (size_t i=0; i<TCPPARALLELLOOKUPS; i++) {\n    ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result[i]);\n  }\n\n  Process();\n\n  EXPECT_EQ(1, sock_cb_count);\n\n  for (size_t i=0; i<TCPPARALLELLOOKUPS; i++) {\n    std::stringstream ss;\n    EXPECT_TRUE(result[i].done_);\n    ss << result[i].host_;\n    EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }\n}",
          "fn_code_pos": [
            [
              327,
              0
            ],
            [
              355,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPEventThreadTest, MalformedResponse) {\n  std::vector<byte> one = {0x00};\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReplyData(&server_, one));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ETIMEOUT, result.status_);\n}",
          "fn_code_pos": [
            [
              357,
              0
            ],
            [
              367,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPEventThreadTest, FormErrResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(FORMERR);\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EFORMERR, result.status_);\n}",
          "fn_code_pos": [
            [
              369,
              0
            ],
            [
              381,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPEventThreadTest, ServFailResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(SERVFAIL);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ESERVFAIL, result.status_);\n}",
          "fn_code_pos": [
            [
              383,
              0
            ],
            [
              395,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPEventThreadTest, NotImplResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(NOTIMP);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              397,
              0
            ],
            [
              409,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPEventThreadTest, RefusedResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(REFUSED);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EREFUSED, result.status_);\n}",
          "fn_code_pos": [
            [
              411,
              0
            ],
            [
              423,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockTCPEventThreadTest, YXDomainResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(YXDOMAIN);\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENODATA, result.status_);\n}",
          "fn_code_pos": [
            [
              425,
              0
            ],
            [
              437,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockExtraOptsEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), std::get<2>(GetParam()),\n                          FillOptions(&opts_),\n                          ARES_OPT_SOCK_SNDBUF|ARES_OPT_SOCK_RCVBUF) {}",
          "fn_code_pos": [
            [
              443,
              2
            ],
            [
              446,
              71
            ]
          ],
          "class_code": "82d949ff484d78b54e755841fbad7438f2563b6f6da9134186b9e648458c4108",
          "class_node_pos": [
            [
              439,
              0
            ],
            [
              456,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockExtraOptsEventThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    // Set a few options that affect socket communications\n    opts->socket_send_buffer_size = 514;\n    opts->socket_receive_buffer_size = 514;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              447,
              2
            ],
            [
              453,
              3
            ]
          ],
          "class_code": "82d949ff484d78b54e755841fbad7438f2563b6f6da9134186b9e648458c4108",
          "class_node_pos": [
            [
              439,
              0
            ],
            [
              456,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockExtraOptsEventThreadTest, SimpleQuery) {\n  ares_set_local_ip4(channel_, 0x7F000001);\n  byte addr6[16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};\n  ares_set_local_ip6(channel_, addr6);\n  ares_set_local_dev(channel_, \"dummy\");\n\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              458,
              0
            ],
            [
              479,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockFlagsEventThreadOptsTest(int flags)\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), std::get<2>(GetParam()),\n                          FillOptions(&opts_, flags), ARES_OPT_FLAGS) {}",
          "fn_code_pos": [
            [
              485,
              2
            ],
            [
              487,
              72
            ]
          ],
          "class_code": "7f5da8b759f299aa797ed06a36afdd64fccd27b74bdec19224cf0261824559b9",
          "class_node_pos": [
            [
              481,
              0
            ],
            [
              495,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockFlagsEventThreadOptsTest",
            "parameters": {
              "flags": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options * opts, int flags) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = flags;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              488,
              2
            ],
            [
              492,
              3
            ]
          ],
          "class_code": "7f5da8b759f299aa797ed06a36afdd64fccd27b74bdec19224cf0261824559b9",
          "class_node_pos": [
            [
              481,
              0
            ],
            [
              495,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options",
              "flags": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "MockNoCheckRespEventThreadTest() : MockFlagsEventThreadOptsTest(ARES_FLAG_NOCHECKRESP) {}",
          "fn_code_pos": [
            [
              499,
              2
            ],
            [
              499,
              91
            ]
          ],
          "class_code": "f92d810b0e4d92cb51a793501dfe4f7aaa0a67cfe1a375b0e29dfbc85591872a",
          "class_node_pos": [
            [
              497,
              0
            ],
            [
              500,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockNoCheckRespEventThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockNoCheckRespEventThreadTest, ServFailResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(SERVFAIL);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ESERVFAIL, result.status_);\n}",
          "fn_code_pos": [
            [
              502,
              0
            ],
            [
              514,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockNoCheckRespEventThreadTest, NotImplResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(NOTIMP);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENOTIMP, result.status_);\n}",
          "fn_code_pos": [
            [
              516,
              0
            ],
            [
              528,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockNoCheckRespEventThreadTest, RefusedResponse) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  rsp.set_rcode(REFUSED);\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EREFUSED, result.status_);\n}",
          "fn_code_pos": [
            [
              530,
              0
            ],
            [
              542,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockEDNSEventThreadTest() : MockFlagsEventThreadOptsTest(ARES_FLAG_EDNS) {}",
          "fn_code_pos": [
            [
              546,
              2
            ],
            [
              546,
              77
            ]
          ],
          "class_code": "f7a0ed1052be25136d0484f67b8f9d332504504fe1f53f54b63a7d4414702ad4",
          "class_node_pos": [
            [
              544,
              0
            ],
            [
              547,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockEDNSEventThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEDNSEventThreadTest, RetryWithoutEDNS) {\n  DNSPacket rspfail;\n  rspfail.set_response().set_aa().set_rcode(FORMERR)\n    .add_question(new DNSQuestion(\"www.google.com\", T_A));\n  DNSPacket rspok;\n  rspok.set_response()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 100, {1, 2, 3, 4}));\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReply(&server_, &rspfail))\n    .WillOnce(SetReply(&server_, &rspok));\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              549,
              0
            ],
            [
              567,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SearchDomains) {\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket yesthird;\n  yesthird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A))\n    .add_answer(new DNSARR(\"www.third.gov\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &yesthird));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.third.gov' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              569,
              0
            ],
            [
              594,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPEventThreadTest, SearchDomainsWithResentReply) {\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  EXPECT_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillOnce(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  EXPECT_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillOnce(SetReply(&server_, &nosecond));\n  DNSPacket yesthird;\n  yesthird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A))\n    .add_answer(new DNSARR(\"www.third.gov\", 0x0200, {2, 3, 4, 5}));\n  // Before sending the real answer, resend an earlier reply\n  EXPECT_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillOnce(DoAll(SetReply(&server_, &nofirst),\n                    SetReplyQID(&server_, 123)))\n    .WillOnce(DoAll(SetReply(&server_, &yesthird),\n                    SetReplyQID(&server_, -1)));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.third.gov' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              597,
              0
            ],
            [
              626,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SearchDomainsBare) {\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket nothird;\n  nothird.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &nothird));\n  DNSPacket yesbare;\n  yesbare.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www\", T_A))\n    .add_answer(new DNSARR(\"www\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www\", T_A))\n    .WillByDefault(SetReply(&server_, &yesbare));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              628,
              0
            ],
            [
              658,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SearchNoDataThenSuccess) {\n  // First two search domains recognize the name but have no A records.\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket yesthird;\n  yesthird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A))\n    .add_answer(new DNSARR(\"www.third.gov\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &yesthird));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.third.gov' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              660,
              0
            ],
            [
              686,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SearchNoDataThenNoDataBare) {\n  // First two search domains recognize the name but have no A records.\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket nothird;\n  nothird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &nothird));\n  DNSPacket nobare;\n  nobare.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www\", T_A));\n  ON_CALL(server_, OnRequest(\"www\", T_A))\n    .WillByDefault(SetReply(&server_, &nobare));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENODATA, result.status_);\n}",
          "fn_code_pos": [
            [
              688,
              0
            ],
            [
              716,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SearchNoDataThenFail) {\n  // First two search domains recognize the name but have no A records.\n  DNSPacket nofirst;\n  nofirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &nofirst));\n  DNSPacket nosecond;\n  nosecond.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.second.org\", T_A));\n  ON_CALL(server_, OnRequest(\"www.second.org\", T_A))\n    .WillByDefault(SetReply(&server_, &nosecond));\n  DNSPacket nothird;\n  nothird.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.third.gov\", T_A));\n  ON_CALL(server_, OnRequest(\"www.third.gov\", T_A))\n    .WillByDefault(SetReply(&server_, &nothird));\n  DNSPacket nobare;\n  nobare.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"www\", T_A));\n  ON_CALL(server_, OnRequest(\"www\", T_A))\n    .WillByDefault(SetReply(&server_, &nobare));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENODATA, result.status_);\n}",
          "fn_code_pos": [
            [
              718,
              0
            ],
            [
              746,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SearchHighNdots) {\n  DNSPacket nobare;\n  nobare.set_response().set_aa().set_rcode(NXDOMAIN)\n    .add_question(new DNSQuestion(\"a.b.c.w.w.w\", T_A));\n  ON_CALL(server_, OnRequest(\"a.b.c.w.w.w\", T_A))\n    .WillByDefault(SetReply(&server_, &nobare));\n  DNSPacket yesfirst;\n  yesfirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"a.b.c.w.w.w.first.com\", T_A))\n    .add_answer(new DNSARR(\"a.b.c.w.w.w.first.com\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"a.b.c.w.w.w.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &yesfirst));\n\n  SearchResult result;\n  ares_search(channel_, \"a.b.c.w.w.w\", C_IN, T_A, SearchCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  std::stringstream ss;\n  ss << PacketToString(result.data_);\n  EXPECT_EQ(\"RSP QRY AA NOERROR Q:{'a.b.c.w.w.w.first.com' IN A} \"\n            \"A:{'a.b.c.w.w.w.first.com' IN A TTL=512 2.3.4.5}\",\n            ss.str());\n}",
          "fn_code_pos": [
            [
              748,
              0
            ],
            [
              771,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, V4WorksV6Timeout) {\n  std::vector<byte> nothing;\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &reply));\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_AAAA))\n    .WillByDefault(SetReplyData(&server_, nothing));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(1, result.timeouts_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              773,
              0
            ],
            [
              794,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, DestroyQuick) {\n  /* We are not looking for any particular result as its possible (but unlikely)\n   * it finished before the destroy completed. We really just want to make sure\n   * cleanup works in this case properly. */\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  ares_destroy(channel_);\n  channel_ = nullptr;\n  EXPECT_TRUE(result.done_);\n}",
          "fn_code_pos": [
            [
              796,
              0
            ],
            [
              805,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, PartialQueryCancel) {\n  std::vector<byte> nothing;\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &reply));\n\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_AAAA))\n    .WillByDefault(SetReplyData(&server_, nothing));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_UNSPEC, HostCallback, &result);\n  // After 100ms, issues ares_cancel(), this should be enough time for the A\n  // record reply, but before the timeout on the AAAA record.\n  Process(100);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECANCELLED, result.status_);\n}",
          "fn_code_pos": [
            [
              809,
              0
            ],
            [
              829,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, UnspecifiedFamilyV6) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x21, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"example.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  // Default to IPv6 when both are available.\n  EXPECT_EQ(\"{'example.com' aliases=[] addrs=[2121:0000:0000:0000:0000:0000:0000:0303]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              832,
              0
            ],
            [
              856,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, UnspecifiedFamilyV4) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"example.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              858,
              0
            ],
            [
              878,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, UnspecifiedFamilyNoData) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSCnameRR(\"example.com\", 100, \"elsewhere.com\"));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"example.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'' aliases=[] addrs=[]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              880,
              0
            ],
            [
              900,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, UnspecifiedFamilyCname6A4) {\n  DNSPacket rsp6;\n  rsp6.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSCnameRR(\"example.com\", 100, \"elsewhere.com\"));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp6));\n  DNSPacket rsp4;\n  rsp4.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {1, 2, 3, 4}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp4));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"example.com.\", AF_UNSPEC, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'example.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              902,
              0
            ],
            [
              923,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, ExplicitIP) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"1.2.3.4\", AF_INET, HostCallback, &result);\n  EXPECT_TRUE(result.done_);  // Immediate return\n  EXPECT_EQ(ARES_SUCCESS, result.status_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'1.2.3.4' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              925,
              0
            ],
            [
              933,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SortListV4) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_A))\n    .add_answer(new DNSARR(\"example.com\", 100, {22, 23, 24, 25}))\n    .add_answer(new DNSARR(\"example.com\", 100, {12, 13, 14, 15}))\n    .add_answer(new DNSARR(\"example.com\", 100, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_A))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  {\n    EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"12.13.0.0/255.255.0.0 1234::5678\"));\n    HostResult result;\n    ares_gethostbyname(channel_, \"example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'example.com' aliases=[] addrs=[12.13.14.15, 22.23.24.25, 2.3.4.5]}\", ss.str());\n  }\n  {\n    EXPECT_EQ(ARES_SUCCESS, ares_set_sortlist(channel_, \"2.3.0.0/16 130.140.150.160/26\"));\n    HostResult result;\n    ares_gethostbyname(channel_, \"example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'example.com' aliases=[] addrs=[2.3.4.5, 22.23.24.25, 12.13.14.15]}\", ss.str());\n  }\n  struct ares_options options;\n  memset(&options, 0, sizeof(options));\n  int optmask = 0;\n  EXPECT_EQ(ARES_SUCCESS, ares_save_options(channel_, &options, &optmask));\n  EXPECT_TRUE((optmask & ARES_OPT_SORTLIST) == ARES_OPT_SORTLIST);\n  ares_destroy_options(&options);\n}",
          "fn_code_pos": [
            [
              935,
              0
            ],
            [
              971,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, SortListV6) {\n  DNSPacket rsp;\n  rsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_AAAA))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02}))\n    .add_answer(new DNSAaaaRR(\"example.com\", 100,\n                              {0x21, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03}));\n  ON_CALL(server_, OnRequest(\"example.com\", T_AAAA))\n    .WillByDefault(SetReply(&server_, &rsp));\n\n  {\n    ares_set_sortlist(channel_, \"1111::/16 2.3.0.0/255.255.0.0\");\n    HostResult result;\n    ares_gethostbyname(channel_, \"example.com.\", AF_INET6, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'example.com' aliases=[] addrs=[1111:0000:0000:0000:0000:0000:0000:0202, \"\n              \"2121:0000:0000:0000:0000:0000:0000:0303]}\", ss.str());\n  }\n  {\n    ares_set_sortlist(channel_, \"2121::/8\");\n    HostResult result;\n    ares_gethostbyname(channel_, \"example.com.\", AF_INET6, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'example.com' aliases=[] addrs=[2121:0000:0000:0000:0000:0000:0000:0303, \"\n              \"1111:0000:0000:0000:0000:0000:0000:0202]}\", ss.str());\n  }\n}",
          "fn_code_pos": [
            [
              973,
              0
            ],
            [
              1008,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPEventThreadTest, Resend) {\n  std::vector<byte> nothing;\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReplyData(&server_, nothing))\n    .WillOnce(SetReplyData(&server_, nothing))\n    .WillOnce(SetReply(&server_, &reply));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(2, result.timeouts_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1011,
              0
            ],
            [
              1031,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, CancelImmediate) {\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  ares_cancel(channel_);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECANCELLED, result.status_);\n  EXPECT_EQ(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              1033,
              0
            ],
            [
              1040,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, CancelImmediateGetHostByAddr) {\n  HostResult result;\n  struct in_addr addr;\n  addr.s_addr = htonl(0x08080808);\n\n  ares_gethostbyaddr(channel_, &addr, sizeof(addr), AF_INET, HostCallback, &result);\n  ares_cancel(channel_);\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECANCELLED, result.status_);\n  EXPECT_EQ(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              1042,
              0
            ],
            [
              1052,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockUDPEventThreadTest, CancelLater) {\n  std::vector<byte> nothing;\n\n  // On second request, cancel the channel.\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(SetReplyData(&server_, nothing))\n    .WillOnce(CancelChannel(&server_, channel_));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ECANCELLED, result.status_);\n  EXPECT_EQ(0, result.timeouts_);\n}",
          "fn_code_pos": [
            [
              1055,
              0
            ],
            [
              1069,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, DisconnectFirstAttempt) {\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n\n  // On second request, cancel the channel.\n  EXPECT_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillOnce(Disconnect(&server_))\n    .WillOnce(SetReply(&server_, &reply));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www.google.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  if (result.done_) {\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n  }\n}",
          "fn_code_pos": [
            [
              1071,
              0
            ],
            [
              1091,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, GetHostByNameCNAMENoData) {\n  DNSPacket response;\n  response.set_response().set_aa()\n    .add_question(new DNSQuestion(\"cname.first.com\", T_A))\n    .add_answer(new DNSCnameRR(\"cname.first.com\", 100, \"a.first.com\"));\n  ON_CALL(server_, OnRequest(\"cname.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &response));\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"cname.first.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_ENODATA, result.status_);\n}",
          "fn_code_pos": [
            [
              1093,
              0
            ],
            [
              1106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, HostAlias) {\n  DNSPacket reply;\n  reply.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.google.com\", T_A))\n    .add_answer(new DNSARR(\"www.google.com\", 0x0100, {0x01, 0x02, 0x03, 0x04}));\n  ON_CALL(server_, OnRequest(\"www.google.com\", T_A))\n    .WillByDefault(SetReply(&server_, &reply));\n\n  TempFile aliases(\"\\n\\n# www commentedout\\nwww www.google.com\\n\");\n  EnvValue with_env(\"HOSTALIASES\", aliases.filename());\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.google.com' aliases=[] addrs=[1.2.3.4]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1109,
              0
            ],
            [
              1127,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, HostAliasMissing) {\n  DNSPacket yesfirst;\n  yesfirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A))\n    .add_answer(new DNSARR(\"www.first.com\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &yesfirst));\n\n  TempFile aliases(\"\\n\\n# www commentedout\\nww www.google.com\\n\");\n  EnvValue with_env(\"HOSTALIASES\", aliases.filename());\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.first.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1129,
              0
            ],
            [
              1146,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, HostAliasMissingFile) {\n  DNSPacket yesfirst;\n  yesfirst.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.first.com\", T_A))\n    .add_answer(new DNSARR(\"www.first.com\", 0x0200, {2, 3, 4, 5}));\n  ON_CALL(server_, OnRequest(\"www.first.com\", T_A))\n    .WillByDefault(SetReply(&server_, &yesfirst));\n\n  EnvValue with_env(\"HOSTALIASES\", \"bogus.mcfile\");\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  std::stringstream ss;\n  ss << result.host_;\n  EXPECT_EQ(\"{'www.first.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n}",
          "fn_code_pos": [
            [
              1148,
              0
            ],
            [
              1164,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MockEventThreadTest, HostAliasUnreadable) {\n  TempFile aliases(\"www www.google.com\\n\");\n  EXPECT_EQ(chmod(aliases.filename(), 0), 0);\n\n  /* Perform OS sanity checks.  We are observing on Debian after the chmod(fn, 0)\n   * that we are still able to fopen() the file which is unexpected.  Skip the\n   * test if we observe this behavior */\n  struct stat st;\n  EXPECT_EQ(stat(aliases.filename(), &st), 0);\n  EXPECT_EQ(st.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO), 0);\n  FILE *fp = fopen(aliases.filename(), \"r\");\n  if (fp != NULL) {\n    if (verbose) std::cerr << \"Skipping Test due to OS incompatibility (open file caching)\" << std::endl;\n    fclose(fp);\n    return;\n  }\n\n  EnvValue with_env(\"HOSTALIASES\", aliases.filename());\n\n  HostResult result;\n  ares_gethostbyname(channel_, \"www\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(ARES_EFILE, result.status_);\n  chmod(aliases.filename(), 0777);\n}",
          "fn_code_pos": [
            [
              1166,
              0
            ],
            [
              1191,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockMultiServerEventThreadTest(ares_options *opts, int optmask)\n    : MockEventThreadOptsTest(3, std::get<0>(GetParam()), std::get<1>(GetParam()), std::get<2>(GetParam()), opts, optmask) {}",
          "fn_code_pos": [
            [
              1198,
              2
            ],
            [
              1199,
              125
            ]
          ],
          "class_code": "66b80291a45115fee770c294a04c21d06437af0d3fcb21fba5025e3884b30a4a",
          "class_node_pos": [
            [
              1194,
              0
            ],
            [
              1209,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockMultiServerEventThreadTest",
            "parameters": {
              "opts": "ares_options",
              "optmask": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void CheckExample() {\n    HostResult result;\n    ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }",
          "fn_code_pos": [
            [
              1200,
              2
            ],
            [
              1208,
              3
            ]
          ],
          "class_code": "66b80291a45115fee770c294a04c21d06437af0d3fcb21fba5025e3884b30a4a",
          "class_node_pos": [
            [
              1194,
              0
            ],
            [
              1209,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckExample",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "NoRotateMultiMockEventThreadTest() : MockMultiServerEventThreadTest(nullptr, ARES_OPT_NOROTATE) {}",
          "fn_code_pos": [
            [
              1213,
              2
            ],
            [
              1213,
              100
            ]
          ],
          "class_code": "1b209ee70953491fadc01349b8b4f3e575c9509a4c61bc8303c8e9c0ed0c5d21",
          "class_node_pos": [
            [
              1211,
              0
            ],
            [
              1214,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "NoRotateMultiMockEventThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ServerFailoverOptsMockEventThreadTest()\n    : MockMultiServerEventThreadTest(FillOptions(&opts_),\n                                     ARES_OPT_SERVER_FAILOVER | ARES_OPT_NOROTATE) {}",
          "fn_code_pos": [
            [
              1218,
              2
            ],
            [
              1220,
              85
            ]
          ],
          "class_code": "bd941c00d6ae59917a952af8818d22c2d9f6a7c1b252170ea06f282894042842",
          "class_node_pos": [
            [
              1216,
              0
            ],
            [
              1229,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ServerFailoverOptsMockEventThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options* FillOptions(struct ares_options *opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->server_failover_opts.retry_chance = 1;\n    opts->server_failover_opts.retry_delay = 250;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              1221,
              2
            ],
            [
              1226,
              3
            ]
          ],
          "class_code": "bd941c00d6ae59917a952af8818d22c2d9f6a7c1b252170ea06f282894042842",
          "class_node_pos": [
            [
              1216,
              0
            ],
            [
              1229,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(NoRotateMultiMockEventThreadTest, ThirdServer) {\n  struct ares_options opts;\n  int optmask = 0;\n  memset(&opts, 0, sizeof(opts));\n  EXPECT_EQ(ARES_SUCCESS, ares_save_options(channel_, &opts, &optmask));\n  EXPECT_EQ(ARES_OPT_NOROTATE, (optmask & ARES_OPT_NOROTATE));\n  ares_destroy_options(&opts);\n\n  DNSPacket servfailrsp;\n  servfailrsp.set_response().set_aa().set_rcode(SERVFAIL)\n    .add_question(new DNSQuestion(\"www.example.com\", T_A));\n  DNSPacket notimplrsp;\n  notimplrsp.set_response().set_aa().set_rcode(NOTIMP)\n    .add_question(new DNSQuestion(\"www.example.com\", T_A));\n  DNSPacket okrsp;\n  okrsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {2,3,4,5}));\n\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp));\n  CheckExample();\n\n  // Second time around, still starts from server [2], as [0] and [1] both\n  // recorded failures\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n\n  // Third time around, server order is [1] (f0), [2] (f1), [0] (f2), which\n  // means [1] will get called twice in a row as after the first call\n  // order will be  [1] (f1), [2] (f1), [0] (f2) since sort order is\n  // (failure count, index)\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &servfailrsp))\n    .WillOnce(SetReply(servers_[1].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &notimplrsp));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  CheckExample();\n}",
          "fn_code_pos": [
            [
              1231,
              0
            ],
            [
              1280,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(NoRotateMultiMockEventThreadTest, ServerNoResponseFailover) {\n  std::vector<byte> nothing;\n  DNSPacket okrsp;\n  okrsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {2,3,4,5}));\n\n  /* Server #1 works fine on first attempt, then acts like its offline on\n   * second, then backonline on the third. */\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp))\n    .WillOnce(SetReplyData(servers_[0].get(), nothing))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n\n  /* Server #2 always acts like its offline */\n  ON_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillByDefault(SetReplyData(servers_[1].get(), nothing));\n\n  /* Server #3 works fine on first and second request, then no reply on 3rd */\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp))\n    .WillOnce(SetReply(servers_[2].get(), &okrsp))\n    .WillOnce(SetReplyData(servers_[2].get(), nothing));\n\n  HostResult result;\n\n  /* 1. First server returns a response on the first request immediately, normal\n   *    operation on channel. */\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(0, result.timeouts_);\n  std::stringstream ss1;\n  ss1 << result.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss1.str());\n\n  /* 2. On the second request, simulate the first and second servers not\n   *    returning a response at all, but the 3rd server works, so should have\n   *    2 timeouts. */\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(2, result.timeouts_);\n  std::stringstream ss2;\n  ss2 << result.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss2.str());\n\n  /* 3. On the third request, the active server should be #3, so should respond\n   *    immediately with no timeouts */\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(0, result.timeouts_);\n  std::stringstream ss3;\n  ss3 << result.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss3.str());\n\n  /* 4. On the fourth request, the active server should be #3, but will timeout,\n   *    and the first server should then respond */\n  ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n  Process();\n  EXPECT_TRUE(result.done_);\n  EXPECT_EQ(1, result.timeouts_);\n  std::stringstream ss4;\n  ss4 << result.host_;\n  EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss4.str());\n}",
          "fn_code_pos": [
            [
              1282,
              0
            ],
            [
              1348,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ServerFailoverOptsMockEventThreadTest, ServerFailoverOpts) {\n  DNSPacket servfailrsp;\n  servfailrsp.set_response().set_aa().set_rcode(SERVFAIL)\n    .add_question(new DNSQuestion(\"www.example.com\", T_A));\n  DNSPacket okrsp;\n  okrsp.set_response().set_aa()\n    .add_question(new DNSQuestion(\"www.example.com\", T_A))\n    .add_answer(new DNSARR(\"www.example.com\", 100, {2,3,4,5}));\n\n  // 1. If all servers are healthy, then the first server should be selected.\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  CheckExample();\n\n  // 2. Failed servers should be retried after the retry delay.\n  //\n  // Fail server #0 but leave server #1 as healthy.\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n\n  // Sleep for the retry delay (actually a little more than 250ms to account\n  // for unreliable timing, e.g. NTP slew) and send in another query. Server #0\n  // should be retried.\n  std::this_thread::sleep_for(std::chrono::milliseconds(260));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  CheckExample();\n\n  // 3. If there are multiple failed servers, then the servers should be\n  //    retried in sorted order.\n  //\n  // Fail all servers for the first round of tries. On the second round server\n  // #1 responds successfully.\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &servfailrsp))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &servfailrsp));\n  CheckExample();\n\n  // At this point the sorted servers look like [1] (f0) [2] (f1) [0] (f2).\n  // Sleep for the retry delay and send in another query. Server #2 should be\n  // retried first, and then server #0.\n  std::this_thread::sleep_for(std::chrono::milliseconds(260));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &okrsp));\n  CheckExample();\n\n  // 4. If there are multiple failed servers, then servers which have not yet\n  //    met the retry delay should be skipped.\n  //\n  // The sorted servers currently look like [0] (f0) [1] (f0) [2] (f2) and\n  // server #2 has just been retried.\n  // Sleep for half the retry delay and trigger a failure on server #0.\n  std::this_thread::sleep_for(std::chrono::milliseconds(130));\n  EXPECT_CALL(*servers_[0], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[0].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n\n  // The sorted servers now look like [1] (f0) [0] (f1) [2] (f2). Server #0\n  // has just failed whilst server #2 is halfway through the retry delay.\n  // Sleep for another half the retry delay and check that server #2 is retried\n  // whilst server #0 is not.\n  std::this_thread::sleep_for(std::chrono::milliseconds(130));\n  EXPECT_CALL(*servers_[2], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[2].get(), &servfailrsp));\n  EXPECT_CALL(*servers_[1], OnRequest(\"www.example.com\", T_A))\n    .WillOnce(SetReply(servers_[1].get(), &okrsp));\n  CheckExample();\n}",
          "fn_code_pos": [
            [
              1352,
              0
            ],
            [
              1431,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static const char *evsys_tostr(ares_evsys_t evsys)\n{\n  switch (evsys) {\n    case ARES_EVSYS_WIN32:\n      return \"WIN32\";\n    case ARES_EVSYS_EPOLL:\n      return \"EPOLL\";\n    case ARES_EVSYS_KQUEUE:\n      return \"KQUEUE\";\n    case ARES_EVSYS_POLL:\n      return \"POLL\";\n    case ARES_EVSYS_SELECT:\n      return \"SELECT\";\n    case ARES_EVSYS_DEFAULT:\n      return \"DEFAULT\";\n  }\n  return \"UNKNOWN\";\n}",
          "fn_code_pos": [
            [
              1433,
              0
            ],
            [
              1450,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "evsys_tostr",
            "parameters": {
              "evsys": "ares_evsys_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static std::string PrintEvsysFamilyMode(const testing::TestParamInfo<std::tuple<ares_evsys_t, int, bool>> &info)\n{\n  std::string name;\n\n  name += evsys_tostr(std::get<0>(info.param));\n  name += \"_\";\n  name += af_tostr(std::get<1>(info.param));\n  name += \"_\";\n  name += mode_tostr(std::get<2>(info.param));\n  return name;\n}",
          "fn_code_pos": [
            [
              1453,
              0
            ],
            [
              1463,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintEvsysFamilyMode",
            "parameters": {
              "info": "testing::TestParamInfo<std::tuple<ares_evsys_t, int, bool>>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static std::string PrintEvsysFamily(const testing::TestParamInfo<std::tuple<ares_evsys_t, int>> &info)\n{\n  std::string name;\n\n  name += evsys_tostr(std::get<0>(info.param));\n  name += \"_\";\n  name += af_tostr(std::get<1>(info.param));\n  return name;\n}",
          "fn_code_pos": [
            [
              1465,
              0
            ],
            [
              1473,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintEvsysFamily",
            "parameters": {
              "info": "testing::TestParamInfo<std::tuple<ares_evsys_t, int>>"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "FillOptions(struct ares_options * opts)",
          "fn_dec_pos": [
            [
              216,
              30
            ],
            [
              216,
              69
            ]
          ],
          "class_code": "362d0a4576378f06f2e0f4f63b35aa7eb39d6dda1f57b1f77de87927285ea92b",
          "class_node_pos": [
            [
              208,
              0
            ],
            [
              224,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts)",
          "fn_dec_pos": [
            [
              264,
              30
            ],
            [
              264,
              69
            ]
          ],
          "class_code": "d584e1faeb2e94178ee8ee3f66da05be6b4737c49209786eb151b3f6118c45a5",
          "class_node_pos": [
            [
              256,
              0
            ],
            [
              271,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts)",
          "fn_dec_pos": [
            [
              318,
              30
            ],
            [
              318,
              69
            ]
          ],
          "class_code": "22cd971b210e000f2935784af0ae7d48c939af82adaf34d98cfc91d265636dcc",
          "class_node_pos": [
            [
              310,
              0
            ],
            [
              325,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts)",
          "fn_dec_pos": [
            [
              447,
              30
            ],
            [
              447,
              69
            ]
          ],
          "class_code": "82d949ff484d78b54e755841fbad7438f2563b6f6da9134186b9e648458c4108",
          "class_node_pos": [
            [
              439,
              0
            ],
            [
              456,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options * opts, int flags)",
          "fn_dec_pos": [
            [
              488,
              30
            ],
            [
              488,
              80
            ]
          ],
          "class_code": "7f5da8b759f299aa797ed06a36afdd64fccd27b74bdec19224cf0261824559b9",
          "class_node_pos": [
            [
              481,
              0
            ],
            [
              495,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options",
              "flags": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "FillOptions(struct ares_options *opts)",
          "fn_dec_pos": [
            [
              1221,
              30
            ],
            [
              1221,
              68
            ]
          ],
          "class_code": "bd941c00d6ae59917a952af8818d22c2d9f6a7c1b252170ea06f282894042842",
          "class_node_pos": [
            [
              1216,
              0
            ],
            [
              1229,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptions",
            "parameters": {
              "opts": "struct ares_options"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "evsys_tostr(ares_evsys_t evsys)",
          "fn_dec_pos": [
            [
              1433,
              19
            ],
            [
              1433,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "evsys_tostr",
            "parameters": {
              "evsys": "ares_evsys_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "362d0a4576378f06f2e0f4f63b35aa7eb39d6dda1f57b1f77de87927285ea92b": {
          "class_code": "class MockUDPEventThreadMaxQueriesTest\n    : public MockEventThreadOptsTest,\n      public ::testing::WithParamInterface<std::tuple<ares_evsys_t,int>> {\n public:\n  MockUDPEventThreadMaxQueriesTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), false,\n                          FillOptions(&opts_),\n                          ARES_OPT_UDP_MAX_QUERIES|ARES_OPT_FLAGS) {}\n  static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = ARES_FLAG_STAYOPEN|ARES_FLAG_EDNS;\n    opts->udp_max_queries = MAXUDPQUERIES_LIMIT;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockUDPEventThreadMaxQueriesTest",
          "class_pos": [
            [
              208,
              0
            ],
            [
              224,
              1
            ]
          ]
        },
        "d584e1faeb2e94178ee8ee3f66da05be6b4737c49209786eb151b3f6118c45a5": {
          "class_code": "class CacheQueriesEventThreadTest\n    : public MockEventThreadOptsTest,\n      public ::testing::WithParamInterface<std::tuple<ares_evsys_t,int>> {\n public:\n  CacheQueriesEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), false,\n                          FillOptions(&opts_),\n                          ARES_OPT_QUERY_CACHE) {}\n  static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->qcache_max_ttl = 3600;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "CacheQueriesEventThreadTest",
          "class_pos": [
            [
              256,
              0
            ],
            [
              271,
              1
            ]
          ]
        },
        "22cd971b210e000f2935784af0ae7d48c939af82adaf34d98cfc91d265636dcc": {
          "class_code": "class MockTCPEventThreadStayOpenTest\n    : public MockEventThreadOptsTest,\n      public ::testing::WithParamInterface<std::tuple<ares_evsys_t,int>> {\n public:\n  MockTCPEventThreadStayOpenTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), true /* tcp */,\n                          FillOptions(&opts_),\n                          ARES_OPT_FLAGS) {}\n  static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = ARES_FLAG_STAYOPEN|ARES_FLAG_EDNS;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockTCPEventThreadStayOpenTest",
          "class_pos": [
            [
              310,
              0
            ],
            [
              325,
              1
            ]
          ]
        },
        "82d949ff484d78b54e755841fbad7438f2563b6f6da9134186b9e648458c4108": {
          "class_code": "class MockExtraOptsEventThreadTest\n    : public MockEventThreadOptsTest,\n      public ::testing::WithParamInterface<std::tuple<ares_evsys_t, int, bool> > {\n public:\n  MockExtraOptsEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), std::get<2>(GetParam()),\n                          FillOptions(&opts_),\n                          ARES_OPT_SOCK_SNDBUF|ARES_OPT_SOCK_RCVBUF) {}\n  static struct ares_options* FillOptions(struct ares_options * opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    // Set a few options that affect socket communications\n    opts->socket_send_buffer_size = 514;\n    opts->socket_receive_buffer_size = 514;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockExtraOptsEventThreadTest",
          "class_pos": [
            [
              439,
              0
            ],
            [
              456,
              1
            ]
          ]
        },
        "7f5da8b759f299aa797ed06a36afdd64fccd27b74bdec19224cf0261824559b9": {
          "class_code": "class MockFlagsEventThreadOptsTest\n    : public MockEventThreadOptsTest,\n      public ::testing::WithParamInterface< std::tuple<ares_evsys_t, int, bool> > {\n public:\n  MockFlagsEventThreadOptsTest(int flags)\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()), std::get<1>(GetParam()), std::get<2>(GetParam()),\n                          FillOptions(&opts_, flags), ARES_OPT_FLAGS) {}\n  static struct ares_options* FillOptions(struct ares_options * opts, int flags) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->flags = flags;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "MockFlagsEventThreadOptsTest",
          "class_pos": [
            [
              481,
              0
            ],
            [
              495,
              1
            ]
          ]
        },
        "f92d810b0e4d92cb51a793501dfe4f7aaa0a67cfe1a375b0e29dfbc85591872a": {
          "class_code": "class MockNoCheckRespEventThreadTest : public MockFlagsEventThreadOptsTest {\n public:\n  MockNoCheckRespEventThreadTest() : MockFlagsEventThreadOptsTest(ARES_FLAG_NOCHECKRESP) {}\n}",
          "class_name": "MockNoCheckRespEventThreadTest",
          "class_pos": [
            [
              497,
              0
            ],
            [
              500,
              1
            ]
          ]
        },
        "f7a0ed1052be25136d0484f67b8f9d332504504fe1f53f54b63a7d4414702ad4": {
          "class_code": "class MockEDNSEventThreadTest : public MockFlagsEventThreadOptsTest {\n public:\n  MockEDNSEventThreadTest() : MockFlagsEventThreadOptsTest(ARES_FLAG_EDNS) {}\n}",
          "class_name": "MockEDNSEventThreadTest",
          "class_pos": [
            [
              544,
              0
            ],
            [
              547,
              1
            ]
          ]
        },
        "66b80291a45115fee770c294a04c21d06437af0d3fcb21fba5025e3884b30a4a": {
          "class_code": "class MockMultiServerEventThreadTest\n  : public MockEventThreadOptsTest,\n    public ::testing::WithParamInterface< std::tuple<ares_evsys_t, int, bool> > {\n public:\n  MockMultiServerEventThreadTest(ares_options *opts, int optmask)\n    : MockEventThreadOptsTest(3, std::get<0>(GetParam()), std::get<1>(GetParam()), std::get<2>(GetParam()), opts, optmask) {}\n  void CheckExample() {\n    HostResult result;\n    ares_gethostbyname(channel_, \"www.example.com.\", AF_INET, HostCallback, &result);\n    Process();\n    EXPECT_TRUE(result.done_);\n    std::stringstream ss;\n    ss << result.host_;\n    EXPECT_EQ(\"{'www.example.com' aliases=[] addrs=[2.3.4.5]}\", ss.str());\n  }\n}",
          "class_name": "MockMultiServerEventThreadTest",
          "class_pos": [
            [
              1194,
              0
            ],
            [
              1209,
              1
            ]
          ]
        },
        "1b209ee70953491fadc01349b8b4f3e575c9509a4c61bc8303c8e9c0ed0c5d21": {
          "class_code": "class NoRotateMultiMockEventThreadTest : public MockMultiServerEventThreadTest {\n public:\n  NoRotateMultiMockEventThreadTest() : MockMultiServerEventThreadTest(nullptr, ARES_OPT_NOROTATE) {}\n}",
          "class_name": "NoRotateMultiMockEventThreadTest",
          "class_pos": [
            [
              1211,
              0
            ],
            [
              1214,
              1
            ]
          ]
        },
        "bd941c00d6ae59917a952af8818d22c2d9f6a7c1b252170ea06f282894042842": {
          "class_code": "class ServerFailoverOptsMockEventThreadTest : public MockMultiServerEventThreadTest {\n public:\n  ServerFailoverOptsMockEventThreadTest()\n    : MockMultiServerEventThreadTest(FillOptions(&opts_),\n                                     ARES_OPT_SERVER_FAILOVER | ARES_OPT_NOROTATE) {}\n  static struct ares_options* FillOptions(struct ares_options *opts) {\n    memset(opts, 0, sizeof(struct ares_options));\n    opts->server_failover_opts.retry_chance = 1;\n    opts->server_failover_opts.retry_delay = 250;\n    return opts;\n  }\n private:\n  struct ares_options opts_;\n}",
          "class_name": "ServerFailoverOptsMockEventThreadTest",
          "class_pos": [
            [
              1216,
              0
            ],
            [
              1229,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct ares_options",
          {},
          "",
          [
            216,
            9
          ],
          [
            216,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            216,
            42
          ],
          [
            216,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            217,
            27
          ],
          [
            217,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            223,
            2
          ],
          [
            223,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            264,
            9
          ],
          [
            264,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            264,
            42
          ],
          [
            264,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            265,
            27
          ],
          [
            265,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            270,
            2
          ],
          [
            270,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            318,
            9
          ],
          [
            318,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            318,
            42
          ],
          [
            318,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            319,
            27
          ],
          [
            319,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            324,
            2
          ],
          [
            324,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            447,
            9
          ],
          [
            447,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            447,
            42
          ],
          [
            447,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            448,
            27
          ],
          [
            448,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            455,
            2
          ],
          [
            455,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            488,
            9
          ],
          [
            488,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            488,
            42
          ],
          [
            488,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            489,
            27
          ],
          [
            489,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            494,
            2
          ],
          [
            494,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            965,
            2
          ],
          [
            965,
            21
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            1044,
            2
          ],
          [
            1044,
            16
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            1173,
            2
          ],
          [
            1173,
            13
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1221,
            9
          ],
          [
            1221,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1221,
            42
          ],
          [
            1221,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1222,
            27
          ],
          [
            1222,
            46
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1228,
            2
          ],
          [
            1228,
            21
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            1232,
            2
          ],
          [
            1232,
            21
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <sys/stat.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-parse-ptr.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParsePtrReplyOK) {\n  byte addrv4[4] = {0x10, 0x20, 0x30, 0x40};\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other.com\"));\n  std::vector<byte> data = pkt.data();\n\n  struct hostent *host = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                               addrv4, sizeof(addrv4), AF_INET, &host));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'other.com' aliases=[other.com] addrs=[16.32.48.64]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              50,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParsePtrReplyCname) {\n  byte addrv4[4] = {0x10, 0x20, 0x30, 0x40};\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR))\n    .add_answer(new DNSCnameRR(\"64.48.32.16.in-addr.arpa\", 50, \"64.48.32.8.in-addr.arpa\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.8.in-addr.arpa\", 100, \"other.com\"));\n  std::vector<byte> data = pkt.data();\n\n  struct hostent *host = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                               addrv4, sizeof(addrv4), AF_INET, &host));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'other.com' aliases=[other.com] addrs=[16.32.48.64]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              69,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNSMalformedCnameRR(const std::string& name, int ttl, const std::string& other)\n    : DNSCnameRR(name, ttl, other) {}",
          "fn_code_pos": [
            [
              73,
              2
            ],
            [
              74,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSMalformedCnameRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "other": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::vector<byte> data() const {\n    std::vector<byte> data = DNSRR::data();\n    std::vector<byte> encname = EncodeString(other_);\n    encname[0] = encname[0] + 63;  // invalid label length\n    int len = (int)encname.size();\n    PushInt16(&data, len);\n    data.insert(data.end(), encname.begin(), encname.end());\n    return data;\n  }",
          "fn_code_pos": [
            [
              75,
              2
            ],
            [
              83,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParsePtrReplyMalformedCname) {\n  byte addrv4[4] = {0x10, 0x20, 0x30, 0x40};\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR))\n    .add_answer(new DNSMalformedCnameRR(\"64.48.32.16.in-addr.arpa\", 50, \"64.48.32.8.in-addr.arpa\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.8.in-addr.arpa\", 100, \"other.com\"));\n  std::vector<byte> data = pkt.data();\n\n  struct hostent *host = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                                addrv4, sizeof(addrv4), AF_INET, &host));\n  ASSERT_EQ(nullptr, host);\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              99,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseManyPtrReply) {\n  byte addrv4[4] = {0x10, 0x20, 0x30, 0x40};\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"main.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other1.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other2.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other3.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other4.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other5.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other6.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other7.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other8.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other9.com\"));\n  std::vector<byte> data = pkt.data();\n\n  struct hostent *host = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                               addrv4, sizeof(addrv4), AF_INET, &host));\n  ASSERT_NE(nullptr, host);\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              101,
              0
            ],
            [
              123,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParsePtrReplyAdditional) {\n  byte addrv4[4] = {0x10, 0x20, 0x30, 0x40};\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 55, \"other.com\"))\n    .add_auth(new DNSNsRR(\"16.in-addr.arpa\", 234, \"ns1.other.com\"))\n    .add_auth(new DNSNsRR(\"16.in-addr.arpa\", 234, \"bb.ns2.other.com\"))\n    .add_auth(new DNSNsRR(\"16.in-addr.arpa\", 234, \"ns3.other.com\"))\n    .add_additional(new DNSARR(\"ns1.other.com\", 229, {10,20,30,41}))\n    .add_additional(new DNSARR(\"bb.ns2.other.com\", 229, {10,20,30,42}))\n    .add_additional(new DNSARR(\"ns3.other.com\", 229, {10,20,30,43}));\n  std::vector<byte> data = pkt.data();\n\n  struct hostent *host = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                               addrv4, sizeof(addrv4), AF_INET, &host));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'other.com' aliases=[other.com] addrs=[16.32.48.64]}\", ss.str());\n  ares_free_hostent(host);\n}",
          "fn_code_pos": [
            [
              125,
              0
            ],
            [
              147,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParsePtrReplyErrors) {\n  byte addrv4[4] = {0x10, 0x20, 0x30, 0x40};\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other.com\"));\n  std::vector<byte> data;\n  struct hostent *host = nullptr;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                                addrv4, sizeof(addrv4), AF_INET, &host));\n  pkt.add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR));\n\n  // Question != answer, ok after #683\n  host = nullptr;\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"99.48.32.16.in-addr.arpa\", T_PTR));\n  data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                               addrv4, sizeof(addrv4), AF_INET, &host));\n  ASSERT_NE(nullptr, host);\n  std::stringstream ss;\n  ss << HostEnt(host);\n  EXPECT_EQ(\"{'other.com' aliases=[other.com] addrs=[16.32.48.64]}\", ss.str());\n  ares_free_hostent(host);\n\n  host = nullptr;\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR));\n\n  // Two questions.\n  pkt.add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                                addrv4, sizeof(addrv4), AF_INET, &host));\n  EXPECT_EQ(nullptr, host);\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR));\n\n  // Wrong sort of answer.\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                               addrv4, sizeof(addrv4), AF_INET, &host));\n  EXPECT_EQ(nullptr, host);\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other.com\"));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                               addrv4, sizeof(addrv4), AF_INET, &host));\n  EXPECT_EQ(nullptr, host);\n  pkt.add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other.com\"));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    EXPECT_EQ(ARES_EBADRESP, ares_parse_ptr_reply(data.data(), (int)len,\n                                                  addrv4, sizeof(addrv4), AF_INET, &host));\n    EXPECT_EQ(nullptr, host);\n  }\n\n  // Truncated packets with CNAME.\n  pkt.add_answer(new DNSCnameRR(\"64.48.32.16.in-addr.arpa\", 50, \"64.48.32.8.in-addr.arpa\"));\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    EXPECT_EQ(ARES_EBADRESP, ares_parse_ptr_reply(data.data(), (int)len,\n                                                  addrv4, sizeof(addrv4), AF_INET, &host));\n    EXPECT_EQ(nullptr, host);\n  }\n}",
          "fn_code_pos": [
            [
              149,
              0
            ],
            [
              225,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParsePtrReplyAllocFailSome) {\n  byte addrv4[4] = {0x10, 0x20, 0x30, 0x40};\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"main.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other1.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other2.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other3.com\"));\n  std::vector<byte> data = pkt.data();\n  struct hostent *host = nullptr;\n\n  for (int ii = 1; ii <= 18; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                                addrv4, sizeof(addrv4), AF_INET, &host)) << ii;\n  }\n}",
          "fn_code_pos": [
            [
              227,
              0
            ],
            [
              245,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParsePtrReplyAllocFailMany) {\n  byte addrv4[4] = {0x10, 0x20, 0x30, 0x40};\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"64.48.32.16.in-addr.arpa\", T_PTR))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"main.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other1.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other2.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other3.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other4.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other5.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other6.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other7.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other8.com\"))\n    .add_answer(new DNSPtrRR(\"64.48.32.16.in-addr.arpa\", 100, \"other9.com\"));\n  std::vector<byte> data = pkt.data();\n  struct hostent *host = nullptr;\n\n  for (int ii = 1; ii <= 63; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    int rc = ares_parse_ptr_reply(data.data(), (int)data.size(),\n                                  addrv4, sizeof(addrv4), AF_INET, &host);\n    if (rc != ARES_ENOMEM) {\n      EXPECT_EQ(ARES_SUCCESS, rc);\n      ares_free_hostent(host);\n      host = nullptr;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              247,
              0
            ],
            [
              276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct DNSMalformedCnameRR : public DNSCnameRR {\n  DNSMalformedCnameRR(const std::string& name, int ttl, const std::string& other)\n    : DNSCnameRR(name, ttl, other) {}\n  std::vector<byte> data() const {\n    std::vector<byte> data = DNSRR::data();\n    std::vector<byte> encname = EncodeString(other_);\n    encname[0] = encname[0] + 63;  // invalid label length\n    int len = (int)encname.size();\n    PushInt16(&data, len);\n    data.insert(data.end(), encname.begin(), encname.end());\n    return data;\n  }\n}",
          {},
          "",
          [
            72,
            0
          ],
          [
            84,
            1
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            42,
            2
          ],
          [
            42,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            61,
            2
          ],
          [
            61,
            16
          ]
        ],
        [
          "struct DNSMalformedCnameRR : public DNSCnameRR {\n  DNSMalformedCnameRR(const std::string& name, int ttl, const std::string& other)\n    : DNSCnameRR(name, ttl, other) {}\n  std::vector<byte> data() const {\n    std::vector<byte> data = DNSRR::data();\n    std::vector<byte> encname = EncodeString(other_);\n    encname[0] = encname[0] + 63;  // invalid label length\n    int len = (int)encname.size();\n    PushInt16(&data, len);\n    data.insert(data.end(), encname.begin(), encname.end());\n    return data;\n  }\n}",
          {},
          "",
          [
            72,
            0
          ],
          [
            84,
            1
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            95,
            2
          ],
          [
            95,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            118,
            2
          ],
          [
            118,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            139,
            2
          ],
          [
            139,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            156,
            2
          ],
          [
            156,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            237,
            2
          ],
          [
            237,
            16
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            263,
            2
          ],
          [
            263,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-main.cc": {
      "fn_def_list": [
        {
          "fn_code": "int main(int argc, char* argv[]) {\n  std::vector<char*> gtest_argv = {argv[0]};\n  for (int ii = 1; ii < argc; ii++) {\n    if (strcmp(argv[ii], \"-v\") == 0) {\n      ares::test::verbose = true;\n    } else if ((strcmp(argv[ii], \"-p\") == 0) && (ii + 1 < argc)) {\n      ii++;\n      ares::test::mock_port = (unsigned short)atoi(argv[ii]);\n    } else if (strcmp(argv[ii], \"-4\") == 0) {\n      ares::test::families = ares::test::ipv4_family;\n      ares::test::families_modes = ares::test::ipv4_family_both_modes;\n      ares::test::evsys_families = ares::test::all_evsys_ipv4_family;\n      ares::test::evsys_families_modes = ares::test::all_evsys_ipv4_family_both_modes;\n    } else if (strcmp(argv[ii], \"-6\") == 0) {\n      ares::test::families = ares::test::ipv6_family;\n      ares::test::families_modes = ares::test::ipv6_family_both_modes;\n      ares::test::evsys_families = ares::test::all_evsys_ipv6_family;\n      ares::test::evsys_families_modes = ares::test::all_evsys_ipv6_family_both_modes;\n    } else {\n      gtest_argv.push_back(argv[ii]);\n    }\n  }\n  int gtest_argc = (int)gtest_argv.size();\n  gtest_argv.push_back(nullptr);\n  ::testing::InitGoogleTest(&gtest_argc, gtest_argv.data());\n\n#ifdef WIN32\n  WORD wVersionRequested = MAKEWORD(2, 2);\n  WSADATA wsaData;\n  WSAStartup(wVersionRequested, &wsaData);\n#else\n  signal(SIGPIPE, SIG_IGN);\n#endif\n\n  int rc = RUN_ALL_TESTS();\n\n#ifdef WIN32\n  WSACleanup();\n#endif\n\n  return rc;\n}",
          "fn_code_pos": [
            [
              30,
              0
            ],
            [
              71,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <signal.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"ares-test.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-parse-mx.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_F(LibraryTest, ParseMxReplyOK) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_MX))\n    .add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"))\n    .add_answer(new DNSMxRR(\"example.com\", 100, 200, \"mx2.example.com\"));\n  std::vector<byte> data = pkt.data();\n\n  struct ares_mx_reply* mx = nullptr;\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_mx_reply(data.data(), (int)data.size(), &mx));\n  ASSERT_NE(nullptr, mx);\n  EXPECT_EQ(\"mx1.example.com\", std::string(mx->host));\n  EXPECT_EQ(100, mx->priority);\n\n  struct ares_mx_reply* mx2 = mx->next;\n  ASSERT_NE(nullptr, mx2);\n  EXPECT_EQ(\"mx2.example.com\", std::string(mx2->host));\n  EXPECT_EQ(200, mx2->priority);\n  EXPECT_EQ(nullptr, mx2->next);\n\n  ares_free_data(mx);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseMxReplyMalformed) {\n  std::vector<byte> data = {\n    0x12, 0x34,  // qid\n    0x84, // response + query + AA + not-TC + not-RD\n    0x00, // not-RA + not-Z + not-AD + not-CD + rc=NoError\n    0x00, 0x01,  // num questions\n    0x00, 0x01,  // num answer RRs\n    0x00, 0x00,  // num authority RRs\n    0x00, 0x00,  // num additional RRs\n    // Question\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x0F,  // type MX\n    0x00, 0x01,  // class IN\n    // Answer 1\n    0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e',\n    0x03, 'c', 'o', 'm',\n    0x00,\n    0x00, 0x0F,  // RR type\n    0x00, 0x01,  // class IN\n    0x01, 0x02, 0x03, 0x04, // TTL\n    0x00, 0x01,  // rdata length -- too short\n    0x02,\n  };\n\n  struct ares_mx_reply* mx = nullptr;\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_mx_reply(data.data(), (int)data.size(), &mx));\n  ASSERT_EQ(nullptr, mx);\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseMxReplyErrors) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_MX))\n    .add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n  std::vector<byte> data;\n  struct ares_mx_reply* mx = nullptr;\n\n  // No question.\n  pkt.questions_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_mx_reply(data.data(), (int)data.size(), &mx));\n  EXPECT_EQ(nullptr, mx);\n  pkt.add_question(new DNSQuestion(\"example.com\", T_MX));\n\n#ifdef DISABLED\n  // Question != answer\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"Axample.com\", T_MX));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_mx_reply(data.data(), (int)data.size(), &mx));\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_MX));\n#endif\n\n  // Two questions.\n  pkt.add_question(new DNSQuestion(\"example.com\", T_MX));\n  data = pkt.data();\n  EXPECT_EQ(ARES_EBADRESP, ares_parse_mx_reply(data.data(), (int)data.size(), &mx));\n  EXPECT_EQ(nullptr, mx);\n  pkt.questions_.clear();\n  pkt.add_question(new DNSQuestion(\"example.com\", T_MX));\n\n  // Wrong sort of answer.\n  // TODO(drysdale): check if this should be ARES_ENODATA?\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSSrvRR(\"example.abc.def.com\", 180, 0, 10, 8160, \"example.abc.def.com\"));\n  data = pkt.data();\n  EXPECT_EQ(ARES_SUCCESS, ares_parse_mx_reply(data.data(), (int)data.size(), &mx));\n  EXPECT_EQ(nullptr, mx);\n  pkt.answers_.clear();\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n\n  // No answer.\n  pkt.answers_.clear();\n  data = pkt.data();\n  EXPECT_EQ(ARES_ENODATA, ares_parse_mx_reply(data.data(), (int)data.size(), &mx));\n  EXPECT_EQ(nullptr, mx);\n  pkt.add_answer(new DNSMxRR(\"example.com\", 100, 100, \"mx1.example.com\"));\n\n  // Truncated packets.\n  data = pkt.data();\n  for (size_t len = 1; len < data.size(); len++) {\n    int rc = ares_parse_mx_reply(data.data(), (int)len, &mx);\n    EXPECT_EQ(nullptr, mx);\n    EXPECT_TRUE(rc == ARES_EBADRESP || rc == ARES_EBADNAME);\n  }\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              146,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(LibraryTest, ParseMxReplyAllocFail) {\n  DNSPacket pkt;\n  pkt.set_qid(0x1234).set_response().set_aa()\n    .add_question(new DNSQuestion(\"example.com\", T_MX))\n    .add_answer(new DNSCnameRR(\"example.com\", 300, \"c.example.com\"))\n    .add_answer(new DNSMxRR(\"c.example.com\", 100, 100, \"mx1.example.com\"));\n  std::vector<byte> data = pkt.data();\n  struct ares_mx_reply* mx = nullptr;\n\n  for (int ii = 1; ii <= 5; ii++) {\n    ClearFails();\n    SetAllocFail(ii);\n    EXPECT_EQ(ARES_ENOMEM, ares_parse_mx_reply(data.data(), (int)data.size(), &mx)) << ii;\n  }\n}",
          "fn_code_pos": [
            [
              148,
              0
            ],
            [
              162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            42,
            2
          ],
          [
            42,
            22
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            48,
            2
          ],
          [
            48,
            22
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            83,
            2
          ],
          [
            83,
            22
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            95,
            2
          ],
          [
            95,
            22
          ]
        ],
        [
          "struct ares_mx_reply",
          {},
          "",
          [
            155,
            2
          ],
          [
            155,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares-test.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    }
  },
  "head": {
    "../docker_shared/source_code/c-ares/test/dns-proto.h": {
      "fn_def_list": [
        {
          "fn_code": "DNSQuestion(const std::string &name, int rrtype, int qclass)\n    : name_(name), rrtype_(rrtype), qclass_(qclass)\n  {\n  }",
          "fn_code_pos": [
            [
              69,
              2
            ],
            [
              72,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSQuestion",
            "parameters": {
              "name": "std::string",
              "rrtype": "int",
              "qclass": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSQuestion(const std::string &name, int rrtype)\n    : name_(name), rrtype_(rrtype), qclass_(C_IN)\n  {\n  }",
          "fn_code_pos": [
            [
              74,
              2
            ],
            [
              77,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSQuestion",
            "parameters": {
              "name": "std::string",
              "rrtype": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DNSQuestion()\n  {\n  }",
          "fn_code_pos": [
            [
              79,
              2
            ],
            [
              81,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNSRR(const std::string &name, int rrtype, int qclass, int ttl)\n    : DNSQuestion(name, rrtype, qclass), ttl_(ttl)\n  {\n  }",
          "fn_code_pos": [
            [
              90,
              2
            ],
            [
              93,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSRR",
            "parameters": {
              "name": "std::string",
              "rrtype": "int",
              "qclass": "int",
              "ttl": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSRR(const std::string &name, int rrtype, int ttl)\n    : DNSQuestion(name, rrtype), ttl_(ttl)\n  {\n  }",
          "fn_code_pos": [
            [
              95,
              2
            ],
            [
              98,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSRR",
            "parameters": {
              "name": "std::string",
              "rrtype": "int",
              "ttl": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DNSRR()\n  {\n  }",
          "fn_code_pos": [
            [
              100,
              2
            ],
            [
              102,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual std::vector<byte> data() const = 0;",
          "fn_code_pos": [
            [
              104,
              2
            ],
            [
              104,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNSAddressRR(const std::string &name, int rrtype, int ttl, const byte *addr,\n               int addrlen)\n    : DNSRR(name, rrtype, ttl), addr_(addr, addr + addrlen)\n  {\n  }",
          "fn_code_pos": [
            [
              109,
              2
            ],
            [
              113,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSAddressRR",
            "parameters": {
              "name": "std::string",
              "rrtype": "int",
              "ttl": "int",
              "addr": "byte",
              "addrlen": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSAddressRR(const std::string &name, int rrtype, int ttl,\n               const std::vector<byte> &addr)\n    : DNSRR(name, rrtype, ttl), addr_(addr)\n  {\n  }",
          "fn_code_pos": [
            [
              115,
              2
            ],
            [
              119,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSAddressRR",
            "parameters": {
              "name": "std::string",
              "rrtype": "int",
              "ttl": "int",
              "addr": "std::vector<byte>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSARR(const std::string &name, int ttl, const byte *addr, int addrlen)\n    : DNSAddressRR(name, T_A, ttl, addr, addrlen)\n  {\n  }",
          "fn_code_pos": [
            [
              126,
              2
            ],
            [
              129,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSARR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "addr": "byte",
              "addrlen": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSARR(const std::string &name, int ttl, const std::vector<byte> &addr)\n    : DNSAddressRR(name, T_A, ttl, addr)\n  {\n  }",
          "fn_code_pos": [
            [
              131,
              2
            ],
            [
              134,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSARR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "addr": "std::vector<byte>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSAaaaRR(const std::string &name, int ttl, const byte *addr, int addrlen)\n    : DNSAddressRR(name, T_AAAA, ttl, addr, addrlen)\n  {\n  }",
          "fn_code_pos": [
            [
              138,
              2
            ],
            [
              141,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSAaaaRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "addr": "byte",
              "addrlen": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSAaaaRR(const std::string &name, int ttl, const std::vector<byte> &addr)\n    : DNSAddressRR(name, T_AAAA, ttl, addr)\n  {\n  }",
          "fn_code_pos": [
            [
              143,
              2
            ],
            [
              146,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSAaaaRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "addr": "std::vector<byte>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSSingleNameRR(const std::string &name, int rrtype, int ttl,\n                  const std::string &other)\n    : DNSRR(name, rrtype, ttl), other_(other)\n  {\n  }",
          "fn_code_pos": [
            [
              150,
              2
            ],
            [
              154,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSSingleNameRR",
            "parameters": {
              "name": "std::string",
              "rrtype": "int",
              "ttl": "int",
              "other": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSCnameRR(const std::string &name, int ttl, const std::string &other)\n    : DNSSingleNameRR(name, T_CNAME, ttl, other)\n  {\n  }",
          "fn_code_pos": [
            [
              161,
              2
            ],
            [
              164,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSCnameRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "other": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSNsRR(const std::string &name, int ttl, const std::string &other)\n    : DNSSingleNameRR(name, T_NS, ttl, other)\n  {\n  }",
          "fn_code_pos": [
            [
              168,
              2
            ],
            [
              171,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSNsRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "other": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSPtrRR(const std::string &name, int ttl, const std::string &other)\n    : DNSSingleNameRR(name, T_PTR, ttl, other)\n  {\n  }",
          "fn_code_pos": [
            [
              175,
              2
            ],
            [
              178,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSPtrRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "other": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSTxtRR(const std::string &name, int ttl,\n           const std::vector<std::string> &txt)\n    : DNSRR(name, T_TXT, ttl), txt_(txt)\n  {\n  }",
          "fn_code_pos": [
            [
              182,
              2
            ],
            [
              186,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSTxtRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "txt": "std::vector<std::string>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSMxRR(const std::string &name, int ttl, int pref, const std::string &other)\n    : DNSRR(name, T_MX, ttl), pref_(pref), other_(other)\n  {\n  }",
          "fn_code_pos": [
            [
              193,
              2
            ],
            [
              196,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSMxRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "pref": "int",
              "other": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSSrvRR(const std::string &name, int ttl, int prio, int weight, int port,\n           const std::string &target)\n    : DNSRR(name, T_SRV, ttl), prio_(prio), weight_(weight), port_(port),\n      target_(target)\n  {\n  }",
          "fn_code_pos": [
            [
              204,
              2
            ],
            [
              209,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSSrvRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "prio": "int",
              "weight": "int",
              "port": "int",
              "target": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSUriRR(const std::string &name, int ttl, int prio, int weight,\n           const std::string &target)\n    : DNSRR(name, T_URI, ttl), prio_(prio), weight_(weight), target_(target)\n  {\n  }",
          "fn_code_pos": [
            [
              219,
              2
            ],
            [
              223,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSUriRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "prio": "int",
              "weight": "int",
              "target": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSSoaRR(const std::string &name, int ttl, const std::string &nsname,\n           const std::string &rname, int serial, int refresh, int retry,\n           int expire, int minimum)\n    : DNSRR(name, T_SOA, ttl), nsname_(nsname), rname_(rname), serial_(serial),\n      refresh_(refresh), retry_(retry), expire_(expire), minimum_(minimum)\n  {\n  }",
          "fn_code_pos": [
            [
              232,
              2
            ],
            [
              238,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSSoaRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "nsname": "std::string",
              "rname": "std::string",
              "serial": "int",
              "refresh": "int",
              "retry": "int",
              "expire": "int",
              "minimum": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSNaptrRR(const std::string &name, int ttl, int order, int pref,\n             const std::string &flags, const std::string &service,\n             const std::string &regexp, const std::string &replacement)\n    : DNSRR(name, T_NAPTR, ttl), order_(order), pref_(pref), flags_(flags),\n      service_(service), regexp_(regexp), replacement_(replacement)\n  {\n  }",
          "fn_code_pos": [
            [
              251,
              2
            ],
            [
              257,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSNaptrRR",
            "parameters": {
              "name": "std::string",
              "ttl": "int",
              "order": "int",
              "pref": "int",
              "flags": "std::string",
              "service": "std::string",
              "regexp": "std::string",
              "replacement": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSOptRR(int extrcode, int udpsize)\n    : DNSRR(\"\", T_OPT, static_cast<int>(udpsize), extrcode)\n  {\n  }",
          "fn_code_pos": [
            [
              274,
              2
            ],
            [
              277,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSOptRR",
            "parameters": {
              "extrcode": "int",
              "udpsize": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DNSPacket()\n    : qid_(0), response_(false), opcode_(O_QUERY), aa_(false), tc_(false),\n      rd_(false), ra_(false), z_(false), ad_(false), cd_(false), rcode_(NOERROR)\n  {\n  }",
          "fn_code_pos": [
            [
              284,
              2
            ],
            [
              288,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DNSPacket",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DNSPacket &add_question(DNSQuestion *q)\n  {\n    questions_.push_back(std::unique_ptr<DNSQuestion>(q));\n    return *this;\n  }",
          "fn_code_pos": [
            [
              291,
              2
            ],
            [
              295,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &add_answer(DNSRR *q)\n  {\n    answers_.push_back(std::unique_ptr<DNSRR>(q));\n    return *this;\n  }",
          "fn_code_pos": [
            [
              297,
              2
            ],
            [
              301,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &add_auth(DNSRR *q)\n  {\n    auths_.push_back(std::unique_ptr<DNSRR>(q));\n    return *this;\n  }",
          "fn_code_pos": [
            [
              303,
              2
            ],
            [
              307,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &add_additional(DNSRR *q)\n  {\n    adds_.push_back(std::unique_ptr<DNSRR>(q));\n    return *this;\n  }",
          "fn_code_pos": [
            [
              309,
              2
            ],
            [
              313,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_qid(int qid)\n  {\n    qid_ = qid;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              316,
              2
            ],
            [
              320,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_response(bool v = true)\n  {\n    response_ = v;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              322,
              2
            ],
            [
              326,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_aa(bool v = true)\n  {\n    aa_ = v;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              328,
              2
            ],
            [
              332,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_tc(bool v = true)\n  {\n    tc_ = v;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              334,
              2
            ],
            [
              338,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_rd(bool v = true)\n  {\n    rd_ = v;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              340,
              2
            ],
            [
              344,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_ra(bool v = true)\n  {\n    ra_ = v;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              346,
              2
            ],
            [
              350,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_z(bool v = true)\n  {\n    z_ = v;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              352,
              2
            ],
            [
              356,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_ad(bool v = true)\n  {\n    ad_ = v;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              358,
              2
            ],
            [
              362,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_cd(bool v = true)\n  {\n    cd_ = v;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              364,
              2
            ],
            [
              368,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        },
        {
          "fn_code": "DNSPacket &set_rcode(int rcode)\n  {\n    rcode_ = rcode;\n    return *this;\n  }",
          "fn_code_pos": [
            [
              370,
              2
            ],
            [
              374,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "DNSPacket"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "HexDump(std::vector<byte> data)",
          "fn_dec_pos": [
            [
              42,
              22
            ],
            [
              42,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HexDump",
            "parameters": {
              "data": "std::vector<byte>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "HexDump(const byte *data, int len)",
          "fn_dec_pos": [
            [
              43,
              22
            ],
            [
              43,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HexDump",
            "parameters": {
              "data": "byte",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "HexDump(const char *data, int len)",
          "fn_dec_pos": [
            [
              44,
              22
            ],
            [
              44,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HexDump",
            "parameters": {
              "data": "char",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "StatusToString(int status)",
          "fn_dec_pos": [
            [
              46,
              22
            ],
            [
              46,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "StatusToString",
            "parameters": {
              "status": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "RcodeToString(int rcode)",
          "fn_dec_pos": [
            [
              47,
              22
            ],
            [
              47,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RcodeToString",
            "parameters": {
              "rcode": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "RRTypeToString(int rrtype)",
          "fn_dec_pos": [
            [
              48,
              22
            ],
            [
              48,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RRTypeToString",
            "parameters": {
              "rrtype": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ClassToString(int qclass)",
          "fn_dec_pos": [
            [
              49,
              22
            ],
            [
              49,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ClassToString",
            "parameters": {
              "qclass": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "AddressToString(const void *addr, int len)",
          "fn_dec_pos": [
            [
              50,
              22
            ],
            [
              50,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddressToString",
            "parameters": {
              "addr": "void",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PacketToString(const std::vector<byte> &packet)",
          "fn_dec_pos": [
            [
              56,
              22
            ],
            [
              56,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PacketToString",
            "parameters": {
              "packet": "std::vector<byte>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "QuestionToString(const std::vector<byte> &packet, const byte **data,\n                             int *len)",
          "fn_dec_pos": [
            [
              57,
              12
            ],
            [
              58,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "QuestionToString",
            "parameters": {
              "packet": "std::vector<byte>",
              "data": "byte",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "RRToString(const std::vector<byte> &packet, const byte **data,\n                       int *len)",
          "fn_dec_pos": [
            [
              59,
              12
            ],
            [
              60,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RRToString",
            "parameters": {
              "packet": "std::vector<byte>",
              "data": "byte",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PushInt32(std::vector<byte> *data, int value)",
          "fn_dec_pos": [
            [
              64,
              12
            ],
            [
              64,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PushInt32",
            "parameters": {
              "data": "std::vector<byte>",
              "value": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "PushInt16(std::vector<byte> *data, int value)",
          "fn_dec_pos": [
            [
              65,
              12
            ],
            [
              65,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PushInt16",
            "parameters": {
              "data": "std::vector<byte>",
              "value": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "EncodeString(const std::string &name)",
          "fn_dec_pos": [
            [
              66,
              18
            ],
            [
              66,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EncodeString",
            "parameters": {
              "name": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "data() const",
          "fn_dec_pos": [
            [
              83,
              28
            ],
            [
              83,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "data() const",
          "fn_dec_pos": [
            [
              121,
              28
            ],
            [
              121,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "data() const",
          "fn_dec_pos": [
            [
              156,
              28
            ],
            [
              156,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "data() const",
          "fn_dec_pos": [
            [
              188,
              28
            ],
            [
              188,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "data() const",
          "fn_dec_pos": [
            [
              198,
              28
            ],
            [
              198,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "data() const",
          "fn_dec_pos": [
            [
              211,
              28
            ],
            [
              211,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "data() const",
          "fn_dec_pos": [
            [
              225,
              28
            ],
            [
              225,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "data() const",
          "fn_dec_pos": [
            [
              240,
              28
            ],
            [
              240,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "data() const",
          "fn_dec_pos": [
            [
              259,
              28
            ],
            [
              259,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "data() const",
          "fn_dec_pos": [
            [
              279,
              28
            ],
            [
              279,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "add_question(DNSQuestion *q)",
          "fn_dec_pos": [
            [
              291,
              13
            ],
            [
              291,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_question",
            "parameters": {
              "q": "DNSQuestion"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "add_answer(DNSRR *q)",
          "fn_dec_pos": [
            [
              297,
              13
            ],
            [
              297,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_answer",
            "parameters": {
              "q": "DNSRR"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "add_auth(DNSRR *q)",
          "fn_dec_pos": [
            [
              303,
              13
            ],
            [
              303,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_auth",
            "parameters": {
              "q": "DNSRR"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "add_additional(DNSRR *q)",
          "fn_dec_pos": [
            [
              309,
              13
            ],
            [
              309,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_additional",
            "parameters": {
              "q": "DNSRR"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "set_qid(int qid)",
          "fn_dec_pos": [
            [
              316,
              13
            ],
            [
              316,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_qid",
            "parameters": {
              "qid": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "set_response(bool v = true)",
          "fn_dec_pos": [
            [
              322,
              13
            ],
            [
              322,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_response",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "set_aa(bool v = true)",
          "fn_dec_pos": [
            [
              328,
              13
            ],
            [
              328,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_aa",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "set_tc(bool v = true)",
          "fn_dec_pos": [
            [
              334,
              13
            ],
            [
              334,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_tc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "set_rd(bool v = true)",
          "fn_dec_pos": [
            [
              340,
              13
            ],
            [
              340,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_rd",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "set_ra(bool v = true)",
          "fn_dec_pos": [
            [
              346,
              13
            ],
            [
              346,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_ra",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "set_z(bool v = true)",
          "fn_dec_pos": [
            [
              352,
              13
            ],
            [
              352,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_z",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "set_ad(bool v = true)",
          "fn_dec_pos": [
            [
              358,
              13
            ],
            [
              358,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_ad",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "set_cd(bool v = true)",
          "fn_dec_pos": [
            [
              364,
              13
            ],
            [
              364,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_cd",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "set_rcode(int rcode)",
          "fn_dec_pos": [
            [
              370,
              13
            ],
            [
              370,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_rcode",
            "parameters": {
              "rcode": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "data() const",
          "fn_dec_pos": [
            [
              377,
              44
            ],
            [
              377,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "data",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct DNSQuestion {\n  DNSQuestion(const std::string &name, int rrtype, int qclass)\n    : name_(name), rrtype_(rrtype), qclass_(qclass)\n  {\n  }\n\n  DNSQuestion(const std::string &name, int rrtype)\n    : name_(name), rrtype_(rrtype), qclass_(C_IN)\n  {\n  }\n\n  virtual ~DNSQuestion()\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  std::string               name_;\n  int                       rrtype_;\n  int                       qclass_;\n}",
          {
            "std::vector<byte>": "virtual",
            "name_": "std::string",
            "rrtype_": "int",
            "qclass_": "int"
          },
          "DNSQuestion",
          [
            68,
            0
          ],
          [
            87,
            1
          ]
        ],
        [
          "struct DNSRR : public DNSQuestion {\n  DNSRR(const std::string &name, int rrtype, int qclass, int ttl)\n    : DNSQuestion(name, rrtype, qclass), ttl_(ttl)\n  {\n  }\n\n  DNSRR(const std::string &name, int rrtype, int ttl)\n    : DNSQuestion(name, rrtype), ttl_(ttl)\n  {\n  }\n\n  virtual ~DNSRR()\n  {\n  }\n\n  virtual std::vector<byte> data() const = 0;\n  int                       ttl_;\n}",
          {
            "ttl_": "int"
          },
          "",
          [
            89,
            0
          ],
          [
            106,
            1
          ]
        ],
        [
          "struct DNSAddressRR : public DNSRR {\n  DNSAddressRR(const std::string &name, int rrtype, int ttl, const byte *addr,\n               int addrlen)\n    : DNSRR(name, rrtype, ttl), addr_(addr, addr + addrlen)\n  {\n  }\n\n  DNSAddressRR(const std::string &name, int rrtype, int ttl,\n               const std::vector<byte> &addr)\n    : DNSRR(name, rrtype, ttl), addr_(addr)\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  std::vector<byte>         addr_;\n}",
          {
            "std::vector<byte>": "virtual",
            "addr_": "std::vector<byte>"
          },
          "",
          [
            108,
            0
          ],
          [
            123,
            1
          ]
        ],
        [
          "struct DNSARR : public DNSAddressRR {\n  DNSARR(const std::string &name, int ttl, const byte *addr, int addrlen)\n    : DNSAddressRR(name, T_A, ttl, addr, addrlen)\n  {\n  }\n\n  DNSARR(const std::string &name, int ttl, const std::vector<byte> &addr)\n    : DNSAddressRR(name, T_A, ttl, addr)\n  {\n  }\n}",
          {},
          "",
          [
            125,
            0
          ],
          [
            135,
            1
          ]
        ],
        [
          "struct DNSAaaaRR : public DNSAddressRR {\n  DNSAaaaRR(const std::string &name, int ttl, const byte *addr, int addrlen)\n    : DNSAddressRR(name, T_AAAA, ttl, addr, addrlen)\n  {\n  }\n\n  DNSAaaaRR(const std::string &name, int ttl, const std::vector<byte> &addr)\n    : DNSAddressRR(name, T_AAAA, ttl, addr)\n  {\n  }\n}",
          {},
          "",
          [
            137,
            0
          ],
          [
            147,
            1
          ]
        ],
        [
          "struct DNSSingleNameRR : public DNSRR {\n  DNSSingleNameRR(const std::string &name, int rrtype, int ttl,\n                  const std::string &other)\n    : DNSRR(name, rrtype, ttl), other_(other)\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  std::string               other_;\n}",
          {
            "std::vector<byte>": "virtual",
            "other_": "std::string"
          },
          "",
          [
            149,
            0
          ],
          [
            158,
            1
          ]
        ],
        [
          "struct DNSCnameRR : public DNSSingleNameRR {\n  DNSCnameRR(const std::string &name, int ttl, const std::string &other)\n    : DNSSingleNameRR(name, T_CNAME, ttl, other)\n  {\n  }\n}",
          {},
          "",
          [
            160,
            0
          ],
          [
            165,
            1
          ]
        ],
        [
          "struct DNSNsRR : public DNSSingleNameRR {\n  DNSNsRR(const std::string &name, int ttl, const std::string &other)\n    : DNSSingleNameRR(name, T_NS, ttl, other)\n  {\n  }\n}",
          {},
          "",
          [
            167,
            0
          ],
          [
            172,
            1
          ]
        ],
        [
          "struct DNSPtrRR : public DNSSingleNameRR {\n  DNSPtrRR(const std::string &name, int ttl, const std::string &other)\n    : DNSSingleNameRR(name, T_PTR, ttl, other)\n  {\n  }\n}",
          {},
          "",
          [
            174,
            0
          ],
          [
            179,
            1
          ]
        ],
        [
          "struct DNSTxtRR : public DNSRR {\n  DNSTxtRR(const std::string &name, int ttl,\n           const std::vector<std::string> &txt)\n    : DNSRR(name, T_TXT, ttl), txt_(txt)\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  std::vector<std::string>  txt_;\n}",
          {
            "std::vector<byte>": "virtual",
            "txt_": "std::vector<std::string>"
          },
          "",
          [
            181,
            0
          ],
          [
            190,
            1
          ]
        ],
        [
          "struct DNSMxRR : public DNSRR {\n  DNSMxRR(const std::string &name, int ttl, int pref, const std::string &other)\n    : DNSRR(name, T_MX, ttl), pref_(pref), other_(other)\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  int                       pref_;\n  std::string               other_;\n}",
          {
            "std::vector<byte>": "virtual",
            "pref_": "int",
            "other_": "std::string"
          },
          "",
          [
            192,
            0
          ],
          [
            201,
            1
          ]
        ],
        [
          "struct DNSSrvRR : public DNSRR {\n  DNSSrvRR(const std::string &name, int ttl, int prio, int weight, int port,\n           const std::string &target)\n    : DNSRR(name, T_SRV, ttl), prio_(prio), weight_(weight), port_(port),\n      target_(target)\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  int                       prio_;\n  int                       weight_;\n  int                       port_;\n  std::string               target_;\n}",
          {
            "std::vector<byte>": "virtual",
            "prio_": "int",
            "weight_": "int",
            "port_": "int",
            "target_": "std::string"
          },
          "",
          [
            203,
            0
          ],
          [
            216,
            1
          ]
        ],
        [
          "struct DNSUriRR : public DNSRR {\n  DNSUriRR(const std::string &name, int ttl, int prio, int weight,\n           const std::string &target)\n    : DNSRR(name, T_URI, ttl), prio_(prio), weight_(weight), target_(target)\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  int                       prio_;\n  int                       weight_;\n  std::string               target_;\n}",
          {
            "std::vector<byte>": "virtual",
            "prio_": "int",
            "weight_": "int",
            "target_": "std::string"
          },
          "",
          [
            218,
            0
          ],
          [
            229,
            1
          ]
        ],
        [
          "struct DNSSoaRR : public DNSRR {\n  DNSSoaRR(const std::string &name, int ttl, const std::string &nsname,\n           const std::string &rname, int serial, int refresh, int retry,\n           int expire, int minimum)\n    : DNSRR(name, T_SOA, ttl), nsname_(nsname), rname_(rname), serial_(serial),\n      refresh_(refresh), retry_(retry), expire_(expire), minimum_(minimum)\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  std::string               nsname_;\n  std::string               rname_;\n  int                       serial_;\n  int                       refresh_;\n  int                       retry_;\n  int                       expire_;\n  int                       minimum_;\n}",
          {
            "std::vector<byte>": "virtual",
            "nsname_": "std::string",
            "rname_": "std::string",
            "serial_": "int",
            "refresh_": "int",
            "retry_": "int",
            "expire_": "int",
            "minimum_": "int"
          },
          "",
          [
            231,
            0
          ],
          [
            248,
            1
          ]
        ],
        [
          "struct DNSNaptrRR : public DNSRR {\n  DNSNaptrRR(const std::string &name, int ttl, int order, int pref,\n             const std::string &flags, const std::string &service,\n             const std::string &regexp, const std::string &replacement)\n    : DNSRR(name, T_NAPTR, ttl), order_(order), pref_(pref), flags_(flags),\n      service_(service), regexp_(regexp), replacement_(replacement)\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  int                       order_;\n  int                       pref_;\n  std::string               flags_;\n  std::string               service_;\n  std::string               regexp_;\n  std::string               replacement_;\n}",
          {
            "std::vector<byte>": "virtual",
            "order_": "int",
            "pref_": "int",
            "flags_": "std::string",
            "service_": "std::string",
            "regexp_": "std::string",
            "replacement_": "std::string"
          },
          "",
          [
            250,
            0
          ],
          [
            266,
            1
          ]
        ],
        [
          "struct DNSOption {\n  int               code_;\n  std::vector<byte> data_;\n}",
          {
            "code_": "int",
            "data_": "std::vector<byte>"
          },
          "DNSOption",
          [
            268,
            0
          ],
          [
            271,
            1
          ]
        ],
        [
          "struct DNSOptRR : public DNSRR {\n  DNSOptRR(int extrcode, int udpsize)\n    : DNSRR(\"\", T_OPT, static_cast<int>(udpsize), extrcode)\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  std::vector<DNSOption>    opts_;\n}",
          {
            "std::vector<byte>": "virtual",
            "opts_": "std::vector<DNSOption>"
          },
          "",
          [
            273,
            0
          ],
          [
            281,
            1
          ]
        ],
        [
          "struct DNSPacket {\n  DNSPacket()\n    : qid_(0), response_(false), opcode_(O_QUERY), aa_(false), tc_(false),\n      rd_(false), ra_(false), z_(false), ad_(false), cd_(false), rcode_(NOERROR)\n  {\n  }\n\n  // Convenience functions that take ownership of given pointers.\n  DNSPacket &add_question(DNSQuestion *q)\n  {\n    questions_.push_back(std::unique_ptr<DNSQuestion>(q));\n    return *this;\n  }\n\n  DNSPacket &add_answer(DNSRR *q)\n  {\n    answers_.push_back(std::unique_ptr<DNSRR>(q));\n    return *this;\n  }\n\n  DNSPacket &add_auth(DNSRR *q)\n  {\n    auths_.push_back(std::unique_ptr<DNSRR>(q));\n    return *this;\n  }\n\n  DNSPacket &add_additional(DNSRR *q)\n  {\n    adds_.push_back(std::unique_ptr<DNSRR>(q));\n    return *this;\n  }\n\n  // Chainable setters.\n  DNSPacket &set_qid(int qid)\n  {\n    qid_ = qid;\n    return *this;\n  }\n\n  DNSPacket &set_response(bool v = true)\n  {\n    response_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_aa(bool v = true)\n  {\n    aa_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_tc(bool v = true)\n  {\n    tc_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_rd(bool v = true)\n  {\n    rd_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_ra(bool v = true)\n  {\n    ra_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_z(bool v = true)\n  {\n    z_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_ad(bool v = true)\n  {\n    ad_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_cd(bool v = true)\n  {\n    cd_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_rcode(int rcode)\n  {\n    rcode_ = rcode;\n    return *this;\n  }\n\n  // Return the encoded packet.\n  std::vector<byte>                         data() const;\n\n  int                                       qid_;\n  bool                                      response_;\n  int                                       opcode_;\n  bool                                      aa_;\n  bool                                      tc_;\n  bool                                      rd_;\n  bool                                      ra_;\n  bool                                      z_;\n  bool                                      ad_;\n  bool                                      cd_;\n  int                                       rcode_;\n  std::vector<std::unique_ptr<DNSQuestion>> questions_;\n  std::vector<std::unique_ptr<DNSRR>>       answers_;\n  std::vector<std::unique_ptr<DNSRR>>       auths_;\n  std::vector<std::unique_ptr<DNSRR>>       adds_;\n}",
          {
            "data() const": "std::vector<byte>",
            "qid_": "int",
            "response_": "bool",
            "opcode_": "int",
            "aa_": "bool",
            "tc_": "bool",
            "rd_": "bool",
            "ra_": "bool",
            "z_": "bool",
            "ad_": "bool",
            "cd_": "bool",
            "rcode_": "int",
            "questions_": "std::vector<std::unique_ptr<DNSQuestion>>",
            "answers_": "std::vector<std::unique_ptr<DNSRR>>",
            "auths_": "std::vector<std::unique_ptr<DNSRR>>",
            "adds_": "std::vector<std::unique_ptr<DNSRR>>"
          },
          "DNSPacket",
          [
            283,
            0
          ],
          [
            394,
            1
          ]
        ],
        [
          "struct DNSQuestion {\n  DNSQuestion(const std::string &name, int rrtype, int qclass)\n    : name_(name), rrtype_(rrtype), qclass_(qclass)\n  {\n  }\n\n  DNSQuestion(const std::string &name, int rrtype)\n    : name_(name), rrtype_(rrtype), qclass_(C_IN)\n  {\n  }\n\n  virtual ~DNSQuestion()\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  std::string               name_;\n  int                       rrtype_;\n  int                       qclass_;\n}",
          {
            "std::vector<byte>": "virtual",
            "name_": "std::string",
            "rrtype_": "int",
            "qclass_": "int"
          },
          "DNSQuestion",
          [
            68,
            0
          ],
          [
            87,
            1
          ]
        ],
        [
          "struct DNSRR : public DNSQuestion {\n  DNSRR(const std::string &name, int rrtype, int qclass, int ttl)\n    : DNSQuestion(name, rrtype, qclass), ttl_(ttl)\n  {\n  }\n\n  DNSRR(const std::string &name, int rrtype, int ttl)\n    : DNSQuestion(name, rrtype), ttl_(ttl)\n  {\n  }\n\n  virtual ~DNSRR()\n  {\n  }\n\n  virtual std::vector<byte> data() const = 0;\n  int                       ttl_;\n}",
          {
            "ttl_": "int"
          },
          "",
          [
            89,
            0
          ],
          [
            106,
            1
          ]
        ],
        [
          "struct DNSAddressRR : public DNSRR {\n  DNSAddressRR(const std::string &name, int rrtype, int ttl, const byte *addr,\n               int addrlen)\n    : DNSRR(name, rrtype, ttl), addr_(addr, addr + addrlen)\n  {\n  }\n\n  DNSAddressRR(const std::string &name, int rrtype, int ttl,\n               const std::vector<byte> &addr)\n    : DNSRR(name, rrtype, ttl), addr_(addr)\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  std::vector<byte>         addr_;\n}",
          {
            "std::vector<byte>": "virtual",
            "addr_": "std::vector<byte>"
          },
          "",
          [
            108,
            0
          ],
          [
            123,
            1
          ]
        ],
        [
          "struct DNSARR : public DNSAddressRR {\n  DNSARR(const std::string &name, int ttl, const byte *addr, int addrlen)\n    : DNSAddressRR(name, T_A, ttl, addr, addrlen)\n  {\n  }\n\n  DNSARR(const std::string &name, int ttl, const std::vector<byte> &addr)\n    : DNSAddressRR(name, T_A, ttl, addr)\n  {\n  }\n}",
          {},
          "",
          [
            125,
            0
          ],
          [
            135,
            1
          ]
        ],
        [
          "struct DNSAaaaRR : public DNSAddressRR {\n  DNSAaaaRR(const std::string &name, int ttl, const byte *addr, int addrlen)\n    : DNSAddressRR(name, T_AAAA, ttl, addr, addrlen)\n  {\n  }\n\n  DNSAaaaRR(const std::string &name, int ttl, const std::vector<byte> &addr)\n    : DNSAddressRR(name, T_AAAA, ttl, addr)\n  {\n  }\n}",
          {},
          "",
          [
            137,
            0
          ],
          [
            147,
            1
          ]
        ],
        [
          "struct DNSSingleNameRR : public DNSRR {\n  DNSSingleNameRR(const std::string &name, int rrtype, int ttl,\n                  const std::string &other)\n    : DNSRR(name, rrtype, ttl), other_(other)\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  std::string               other_;\n}",
          {
            "std::vector<byte>": "virtual",
            "other_": "std::string"
          },
          "",
          [
            149,
            0
          ],
          [
            158,
            1
          ]
        ],
        [
          "struct DNSCnameRR : public DNSSingleNameRR {\n  DNSCnameRR(const std::string &name, int ttl, const std::string &other)\n    : DNSSingleNameRR(name, T_CNAME, ttl, other)\n  {\n  }\n}",
          {},
          "",
          [
            160,
            0
          ],
          [
            165,
            1
          ]
        ],
        [
          "struct DNSNsRR : public DNSSingleNameRR {\n  DNSNsRR(const std::string &name, int ttl, const std::string &other)\n    : DNSSingleNameRR(name, T_NS, ttl, other)\n  {\n  }\n}",
          {},
          "",
          [
            167,
            0
          ],
          [
            172,
            1
          ]
        ],
        [
          "struct DNSPtrRR : public DNSSingleNameRR {\n  DNSPtrRR(const std::string &name, int ttl, const std::string &other)\n    : DNSSingleNameRR(name, T_PTR, ttl, other)\n  {\n  }\n}",
          {},
          "",
          [
            174,
            0
          ],
          [
            179,
            1
          ]
        ],
        [
          "struct DNSTxtRR : public DNSRR {\n  DNSTxtRR(const std::string &name, int ttl,\n           const std::vector<std::string> &txt)\n    : DNSRR(name, T_TXT, ttl), txt_(txt)\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  std::vector<std::string>  txt_;\n}",
          {
            "std::vector<byte>": "virtual",
            "txt_": "std::vector<std::string>"
          },
          "",
          [
            181,
            0
          ],
          [
            190,
            1
          ]
        ],
        [
          "struct DNSMxRR : public DNSRR {\n  DNSMxRR(const std::string &name, int ttl, int pref, const std::string &other)\n    : DNSRR(name, T_MX, ttl), pref_(pref), other_(other)\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  int                       pref_;\n  std::string               other_;\n}",
          {
            "std::vector<byte>": "virtual",
            "pref_": "int",
            "other_": "std::string"
          },
          "",
          [
            192,
            0
          ],
          [
            201,
            1
          ]
        ],
        [
          "struct DNSSrvRR : public DNSRR {\n  DNSSrvRR(const std::string &name, int ttl, int prio, int weight, int port,\n           const std::string &target)\n    : DNSRR(name, T_SRV, ttl), prio_(prio), weight_(weight), port_(port),\n      target_(target)\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  int                       prio_;\n  int                       weight_;\n  int                       port_;\n  std::string               target_;\n}",
          {
            "std::vector<byte>": "virtual",
            "prio_": "int",
            "weight_": "int",
            "port_": "int",
            "target_": "std::string"
          },
          "",
          [
            203,
            0
          ],
          [
            216,
            1
          ]
        ],
        [
          "struct DNSUriRR : public DNSRR {\n  DNSUriRR(const std::string &name, int ttl, int prio, int weight,\n           const std::string &target)\n    : DNSRR(name, T_URI, ttl), prio_(prio), weight_(weight), target_(target)\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  int                       prio_;\n  int                       weight_;\n  std::string               target_;\n}",
          {
            "std::vector<byte>": "virtual",
            "prio_": "int",
            "weight_": "int",
            "target_": "std::string"
          },
          "",
          [
            218,
            0
          ],
          [
            229,
            1
          ]
        ],
        [
          "struct DNSSoaRR : public DNSRR {\n  DNSSoaRR(const std::string &name, int ttl, const std::string &nsname,\n           const std::string &rname, int serial, int refresh, int retry,\n           int expire, int minimum)\n    : DNSRR(name, T_SOA, ttl), nsname_(nsname), rname_(rname), serial_(serial),\n      refresh_(refresh), retry_(retry), expire_(expire), minimum_(minimum)\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  std::string               nsname_;\n  std::string               rname_;\n  int                       serial_;\n  int                       refresh_;\n  int                       retry_;\n  int                       expire_;\n  int                       minimum_;\n}",
          {
            "std::vector<byte>": "virtual",
            "nsname_": "std::string",
            "rname_": "std::string",
            "serial_": "int",
            "refresh_": "int",
            "retry_": "int",
            "expire_": "int",
            "minimum_": "int"
          },
          "",
          [
            231,
            0
          ],
          [
            248,
            1
          ]
        ],
        [
          "struct DNSNaptrRR : public DNSRR {\n  DNSNaptrRR(const std::string &name, int ttl, int order, int pref,\n             const std::string &flags, const std::string &service,\n             const std::string &regexp, const std::string &replacement)\n    : DNSRR(name, T_NAPTR, ttl), order_(order), pref_(pref), flags_(flags),\n      service_(service), regexp_(regexp), replacement_(replacement)\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  int                       order_;\n  int                       pref_;\n  std::string               flags_;\n  std::string               service_;\n  std::string               regexp_;\n  std::string               replacement_;\n}",
          {
            "std::vector<byte>": "virtual",
            "order_": "int",
            "pref_": "int",
            "flags_": "std::string",
            "service_": "std::string",
            "regexp_": "std::string",
            "replacement_": "std::string"
          },
          "",
          [
            250,
            0
          ],
          [
            266,
            1
          ]
        ],
        [
          "struct DNSOption {\n  int               code_;\n  std::vector<byte> data_;\n}",
          {
            "code_": "int",
            "data_": "std::vector<byte>"
          },
          "DNSOption",
          [
            268,
            0
          ],
          [
            271,
            1
          ]
        ],
        [
          "struct DNSOptRR : public DNSRR {\n  DNSOptRR(int extrcode, int udpsize)\n    : DNSRR(\"\", T_OPT, static_cast<int>(udpsize), extrcode)\n  {\n  }\n\n  virtual std::vector<byte> data() const;\n  std::vector<DNSOption>    opts_;\n}",
          {
            "std::vector<byte>": "virtual",
            "opts_": "std::vector<DNSOption>"
          },
          "",
          [
            273,
            0
          ],
          [
            281,
            1
          ]
        ],
        [
          "struct DNSPacket {\n  DNSPacket()\n    : qid_(0), response_(false), opcode_(O_QUERY), aa_(false), tc_(false),\n      rd_(false), ra_(false), z_(false), ad_(false), cd_(false), rcode_(NOERROR)\n  {\n  }\n\n  // Convenience functions that take ownership of given pointers.\n  DNSPacket &add_question(DNSQuestion *q)\n  {\n    questions_.push_back(std::unique_ptr<DNSQuestion>(q));\n    return *this;\n  }\n\n  DNSPacket &add_answer(DNSRR *q)\n  {\n    answers_.push_back(std::unique_ptr<DNSRR>(q));\n    return *this;\n  }\n\n  DNSPacket &add_auth(DNSRR *q)\n  {\n    auths_.push_back(std::unique_ptr<DNSRR>(q));\n    return *this;\n  }\n\n  DNSPacket &add_additional(DNSRR *q)\n  {\n    adds_.push_back(std::unique_ptr<DNSRR>(q));\n    return *this;\n  }\n\n  // Chainable setters.\n  DNSPacket &set_qid(int qid)\n  {\n    qid_ = qid;\n    return *this;\n  }\n\n  DNSPacket &set_response(bool v = true)\n  {\n    response_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_aa(bool v = true)\n  {\n    aa_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_tc(bool v = true)\n  {\n    tc_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_rd(bool v = true)\n  {\n    rd_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_ra(bool v = true)\n  {\n    ra_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_z(bool v = true)\n  {\n    z_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_ad(bool v = true)\n  {\n    ad_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_cd(bool v = true)\n  {\n    cd_ = v;\n    return *this;\n  }\n\n  DNSPacket &set_rcode(int rcode)\n  {\n    rcode_ = rcode;\n    return *this;\n  }\n\n  // Return the encoded packet.\n  std::vector<byte>                         data() const;\n\n  int                                       qid_;\n  bool                                      response_;\n  int                                       opcode_;\n  bool                                      aa_;\n  bool                                      tc_;\n  bool                                      rd_;\n  bool                                      ra_;\n  bool                                      z_;\n  bool                                      ad_;\n  bool                                      cd_;\n  int                                       rcode_;\n  std::vector<std::unique_ptr<DNSQuestion>> questions_;\n  std::vector<std::unique_ptr<DNSRR>>       answers_;\n  std::vector<std::unique_ptr<DNSRR>>       auths_;\n  std::vector<std::unique_ptr<DNSRR>>       adds_;\n}",
          {
            "data() const": "std::vector<byte>",
            "qid_": "int",
            "response_": "bool",
            "opcode_": "int",
            "aa_": "bool",
            "tc_": "bool",
            "rd_": "bool",
            "ra_": "bool",
            "z_": "bool",
            "ad_": "bool",
            "cd_": "bool",
            "rcode_": "int",
            "questions_": "std::vector<std::unique_ptr<DNSQuestion>>",
            "answers_": "std::vector<std::unique_ptr<DNSRR>>",
            "auths_": "std::vector<std::unique_ptr<DNSRR>>",
            "adds_": "std::vector<std::unique_ptr<DNSRR>>"
          },
          "DNSPacket",
          [
            283,
            0
          ],
          [
            394,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"ares.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <memory>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test-ai.h": {
      "fn_def_list": [
        {
          "fn_code": "MockChannelTestAI()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, nullptr, 0)\n  {\n  }",
          "fn_code_pos": [
            [
              40,
              2
            ],
            [
              43,
              3
            ]
          ],
          "class_code": "e999007efa260d1587b4a917049d64a736d0bbb52db44cbccfb49d78fab077f2",
          "class_node_pos": [
            [
              36,
              0
            ],
            [
              44,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockChannelTestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockUDPChannelTestAI() : MockChannelOptsTest(1, GetParam(), false, nullptr, 0)\n  {\n  }",
          "fn_code_pos": [
            [
              49,
              2
            ],
            [
              51,
              3
            ]
          ],
          "class_code": "e9f4484f86829c0a1833e277977c246cdb4a1454b0378f446385ae0635c7e00e",
          "class_node_pos": [
            [
              46,
              0
            ],
            [
              52,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockUDPChannelTestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockTCPChannelTestAI() : MockChannelOptsTest(1, GetParam(), true, nullptr, 0)\n  {\n  }",
          "fn_code_pos": [
            [
              57,
              2
            ],
            [
              59,
              3
            ]
          ],
          "class_code": "93de803d99b35f1a69492949a50792f6c6be0d0a74500f0272b29f6cc9ad7445",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockTCPChannelTestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DefaultChannelTestAI() : channel_(nullptr)\n  {\n    EXPECT_EQ(ARES_SUCCESS, ares_init(&channel_));\n    EXPECT_NE(nullptr, channel_);\n  }",
          "fn_code_pos": [
            [
              65,
              2
            ],
            [
              69,
              3
            ]
          ],
          "class_code": "3a21b7bebada56bd1393eb13e93453ddbc896d49bcaab2a12366c72839572f4b",
          "class_node_pos": [
            [
              63,
              0
            ],
            [
              82,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DefaultChannelTestAI",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~DefaultChannelTestAI()\n  {\n    ares_destroy(channel_);\n    channel_ = nullptr;\n  }",
          "fn_code_pos": [
            [
              71,
              2
            ],
            [
              75,
              3
            ]
          ],
          "class_code": "3a21b7bebada56bd1393eb13e93453ddbc896d49bcaab2a12366c72839572f4b",
          "class_node_pos": [
            [
              63,
              0
            ],
            [
              82,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "Process()",
          "fn_dec_pos": [
            [
              78,
              7
            ],
            [
              78,
              16
            ]
          ],
          "class_code": "3a21b7bebada56bd1393eb13e93453ddbc896d49bcaab2a12366c72839572f4b",
          "class_node_pos": [
            [
              63,
              0
            ],
            [
              82,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Process",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {
        "e999007efa260d1587b4a917049d64a736d0bbb52db44cbccfb49d78fab077f2": {
          "class_code": "class MockChannelTestAI\n  : public MockChannelOptsTest,\n    public ::testing::WithParamInterface<std::pair<int, bool>> {\npublic:\n  MockChannelTestAI()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, nullptr, 0)\n  {\n  }\n}",
          "class_name": "MockChannelTestAI",
          "class_pos": [
            [
              36,
              0
            ],
            [
              44,
              1
            ]
          ]
        },
        "e9f4484f86829c0a1833e277977c246cdb4a1454b0378f446385ae0635c7e00e": {
          "class_code": "class MockUDPChannelTestAI : public MockChannelOptsTest,\n                             public ::testing::WithParamInterface<int> {\npublic:\n  MockUDPChannelTestAI() : MockChannelOptsTest(1, GetParam(), false, nullptr, 0)\n  {\n  }\n}",
          "class_name": "MockUDPChannelTestAI",
          "class_pos": [
            [
              46,
              0
            ],
            [
              52,
              1
            ]
          ]
        },
        "93de803d99b35f1a69492949a50792f6c6be0d0a74500f0272b29f6cc9ad7445": {
          "class_code": "class MockTCPChannelTestAI : public MockChannelOptsTest,\n                             public ::testing::WithParamInterface<int> {\npublic:\n  MockTCPChannelTestAI() : MockChannelOptsTest(1, GetParam(), true, nullptr, 0)\n  {\n  }\n}",
          "class_name": "MockTCPChannelTestAI",
          "class_pos": [
            [
              54,
              0
            ],
            [
              60,
              1
            ]
          ]
        },
        "3a21b7bebada56bd1393eb13e93453ddbc896d49bcaab2a12366c72839572f4b": {
          "class_code": "class DefaultChannelTestAI : public LibraryTest {\npublic:\n  DefaultChannelTestAI() : channel_(nullptr)\n  {\n    EXPECT_EQ(ARES_SUCCESS, ares_init(&channel_));\n    EXPECT_NE(nullptr, channel_);\n  }\n\n  ~DefaultChannelTestAI()\n  {\n    ares_destroy(channel_);\n    channel_ = nullptr;\n  }\n\n  // Process all pending work on ares-owned file descriptors.\n  void Process();\n\nprotected:\n  ares_channel_t *channel_;\n}",
          "class_name": "DefaultChannelTestAI",
          "class_pos": [
            [
              63,
              0
            ],
            [
              82,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <utility>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"gtest/gtest.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"gmock/gmock.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"ares-test.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/ares-test.h": {
      "fn_def_list": [
        {
          "fn_code": "LibraryTest()\n  {\n    EXPECT_EQ(ARES_SUCCESS, ares_library_init_mem(\n                              ARES_LIB_INIT_ALL, &LibraryTest::amalloc,\n                              &LibraryTest::afree, &LibraryTest::arealloc));\n  }",
          "fn_code_pos": [
            [
              109,
              2
            ],
            [
              114,
              3
            ]
          ],
          "class_code": "990616a0074fd048edc43284983d1833a9426ba4b5fb058f3ec1db33559e6fa0",
          "class_node_pos": [
            [
              107,
              0
            ],
            [
              139,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "LibraryTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~LibraryTest()\n  {\n    ares_library_cleanup();\n    ClearFails();\n  }",
          "fn_code_pos": [
            [
              116,
              2
            ],
            [
              120,
              3
            ]
          ],
          "class_code": "990616a0074fd048edc43284983d1833a9426ba4b5fb058f3ec1db33559e6fa0",
          "class_node_pos": [
            [
              107,
              0
            ],
            [
              139,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DefaultChannelTest() : channel_(nullptr)\n  {\n    /* Enable query cache for live tests */\n    struct ares_options opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.qcache_max_ttl = 300;\n    int optmask         = ARES_OPT_QUERY_CACHE;\n    EXPECT_EQ(ARES_SUCCESS, ares_init_options(&channel_, &opts, optmask));\n    EXPECT_NE(nullptr, channel_);\n  }",
          "fn_code_pos": [
            [
              144,
              2
            ],
            [
              153,
              3
            ]
          ],
          "class_code": "4377d3f420d85d9a41440b06b546578a96b47dca69a9447aaed7c5f542523ef7",
          "class_node_pos": [
            [
              142,
              0
            ],
            [
              166,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DefaultChannelTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~DefaultChannelTest()\n  {\n    ares_destroy(channel_);\n    channel_ = nullptr;\n  }",
          "fn_code_pos": [
            [
              155,
              2
            ],
            [
              159,
              3
            ]
          ],
          "class_code": "4377d3f420d85d9a41440b06b546578a96b47dca69a9447aaed7c5f542523ef7",
          "class_node_pos": [
            [
              142,
              0
            ],
            [
              166,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "FileChannelTest() : channel_(nullptr)\n  {\n    struct ares_options opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.lookups = strdup(\"f\");\n    int optmask  = ARES_OPT_LOOKUPS;\n    EXPECT_EQ(ARES_SUCCESS, ares_init_options(&channel_, &opts, optmask));\n    EXPECT_NE(nullptr, channel_);\n    free(opts.lookups);\n  }",
          "fn_code_pos": [
            [
              171,
              2
            ],
            [
              180,
              3
            ]
          ],
          "class_code": "b8dcaef941176e3eff8d31f3d714b93d0bc8364f907ff77894f000f40d7f674f",
          "class_node_pos": [
            [
              169,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FileChannelTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~FileChannelTest()\n  {\n    ares_destroy(channel_);\n    channel_ = nullptr;\n  }",
          "fn_code_pos": [
            [
              182,
              2
            ],
            [
              186,
              3
            ]
          ],
          "class_code": "b8dcaef941176e3eff8d31f3d714b93d0bc8364f907ff77894f000f40d7f674f",
          "class_node_pos": [
            [
              169,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DefaultChannelModeTest() : channel_(nullptr)\n  {\n    struct ares_options opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.lookups = strdup(GetParam().c_str());\n    int optmask  = ARES_OPT_LOOKUPS;\n    EXPECT_EQ(ARES_SUCCESS, ares_init_options(&channel_, &opts, optmask));\n    EXPECT_NE(nullptr, channel_);\n    free(opts.lookups);\n  }",
          "fn_code_pos": [
            [
              200,
              2
            ],
            [
              209,
              3
            ]
          ],
          "class_code": "f1ed14826e6b3f8b7597523acf7a8b20d120521ee2c855a7cf7cb79fe709318b",
          "class_node_pos": [
            [
              196,
              0
            ],
            [
              222,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DefaultChannelModeTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~DefaultChannelModeTest()\n  {\n    ares_destroy(channel_);\n    channel_ = nullptr;\n  }",
          "fn_code_pos": [
            [
              211,
              2
            ],
            [
              215,
              3
            ]
          ],
          "class_code": "f1ed14826e6b3f8b7597523acf7a8b20d120521ee2c855a7cf7cb79fe709318b",
          "class_node_pos": [
            [
              196,
              0
            ],
            [
              222,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void SetReplyData(const std::vector<byte> &reply)\n  {\n    reply_ = reply;\n  }",
          "fn_code_pos": [
            [
              236,
              2
            ],
            [
              239,
              3
            ]
          ],
          "class_code": "969b7740bdd0b6136bc333b418c1da5e2a7726d8ba997912945c4f837e71ca01",
          "class_node_pos": [
            [
              225,
              0
            ],
            [
              304,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetReplyData",
            "parameters": {
              "reply": "std::vector<byte>"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SetReply(const DNSPacket *reply)\n  {\n    SetReplyData(reply->data());\n  }",
          "fn_code_pos": [
            [
              241,
              2
            ],
            [
              244,
              3
            ]
          ],
          "class_code": "969b7740bdd0b6136bc333b418c1da5e2a7726d8ba997912945c4f837e71ca01",
          "class_node_pos": [
            [
              225,
              0
            ],
            [
              304,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetReply",
            "parameters": {
              "reply": "DNSPacket"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SetReplyExpRequest(const DNSPacket *reply, const std::string &request)\n  {\n    expected_request_ = request;\n    SetReply(reply);\n  }",
          "fn_code_pos": [
            [
              249,
              2
            ],
            [
              253,
              3
            ]
          ],
          "class_code": "969b7740bdd0b6136bc333b418c1da5e2a7726d8ba997912945c4f837e71ca01",
          "class_node_pos": [
            [
              225,
              0
            ],
            [
              304,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetReplyExpRequest",
            "parameters": {
              "reply": "DNSPacket",
              "request": "std::string"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SetReplyQID(int qid)\n  {\n    qid_ = qid;\n  }",
          "fn_code_pos": [
            [
              255,
              2
            ],
            [
              258,
              3
            ]
          ],
          "class_code": "969b7740bdd0b6136bc333b418c1da5e2a7726d8ba997912945c4f837e71ca01",
          "class_node_pos": [
            [
              225,
              0
            ],
            [
              304,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetReplyQID",
            "parameters": {
              "qid": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Disconnect()\n  {\n    for (ares_socket_t fd : connfds_) {\n      sclose(fd);\n    }\n    connfds_.clear();\n    free(tcp_data_);\n    tcp_data_     = NULL;\n    tcp_data_len_ = 0;\n  }",
          "fn_code_pos": [
            [
              260,
              2
            ],
            [
              269,
              3
            ]
          ],
          "class_code": "969b7740bdd0b6136bc333b418c1da5e2a7726d8ba997912945c4f837e71ca01",
          "class_node_pos": [
            [
              225,
              0
            ],
            [
              304,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Disconnect",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "unsigned short          udpport() const\n  {\n    return udpport_;\n  }",
          "fn_code_pos": [
            [
              278,
              2
            ],
            [
              281,
              3
            ]
          ],
          "class_code": "969b7740bdd0b6136bc333b418c1da5e2a7726d8ba997912945c4f837e71ca01",
          "class_node_pos": [
            [
              225,
              0
            ],
            [
              304,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "udpport",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned short tcpport() const\n  {\n    return tcpport_;\n  }",
          "fn_code_pos": [
            [
              283,
              2
            ],
            [
              286,
              3
            ]
          ],
          "class_code": "969b7740bdd0b6136bc333b418c1da5e2a7726d8ba997912945c4f837e71ca01",
          "class_node_pos": [
            [
              225,
              0
            ],
            [
              304,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "tcpport",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockChannelTest()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, nullptr, 0)\n  {\n  }",
          "fn_code_pos": [
            [
              338,
              2
            ],
            [
              341,
              3
            ]
          ],
          "class_code": "3a5bee8efe7fef9b7e0e07b4769df21b821da5d44dc2cd7b7d181b115f9fb97d",
          "class_node_pos": [
            [
              334,
              0
            ],
            [
              342,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockChannelTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockUDPChannelTest() : MockChannelOptsTest(1, GetParam(), false, nullptr, 0)\n  {\n  }",
          "fn_code_pos": [
            [
              347,
              2
            ],
            [
              349,
              3
            ]
          ],
          "class_code": "c671a507b0505e2f03e3cab1c3fa810d72f1e0b26f5c97b5fa1e259dbc730262",
          "class_node_pos": [
            [
              344,
              0
            ],
            [
              350,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockUDPChannelTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockTCPChannelTest() : MockChannelOptsTest(1, GetParam(), true, nullptr, 0)\n  {\n  }",
          "fn_code_pos": [
            [
              355,
              2
            ],
            [
              357,
              3
            ]
          ],
          "class_code": "15d3cd11e470f7041c4f77af11719d179fd4d983511f5792e7febfa5260a55be",
          "class_node_pos": [
            [
              352,
              0
            ],
            [
              358,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockTCPChannelTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockEventThreadOptsTest(int count, ares_evsys_t evsys, int family,\n                          bool force_tcp, struct ares_options *givenopts,\n                          int optmask)\n    : MockChannelOptsTest(count, family, force_tcp,\n                          FillOptionsET(&evopts_, givenopts, evsys),\n                          optmask | ARES_OPT_EVENT_THREAD)\n  {\n    cancel_ms_ = 0;\n    isup       = true;\n    thread     = std::thread(&MockEventThreadOptsTest::ProcessThread, this);\n  }",
          "fn_code_pos": [
            [
              362,
              2
            ],
            [
              372,
              3
            ]
          ],
          "class_code": "4a74f8a3065504c1edc5dd3feee461dbad873a78c094b9c7acdc05523429d5b0",
          "class_node_pos": [
            [
              360,
              0
            ],
            [
              410,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockEventThreadOptsTest",
            "parameters": {
              "count": "int",
              "evsys": "ares_evsys_t",
              "family": "int",
              "force_tcp": "bool",
              "givenopts": "struct ares_options",
              "optmask": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~MockEventThreadOptsTest()\n  {\n    mutex.lock();\n    isup = false;\n    mutex.unlock();\n    thread.join();\n  }",
          "fn_code_pos": [
            [
              374,
              2
            ],
            [
              380,
              3
            ]
          ],
          "class_code": "4a74f8a3065504c1edc5dd3feee461dbad873a78c094b9c7acdc05523429d5b0",
          "class_node_pos": [
            [
              360,
              0
            ],
            [
              410,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static struct ares_options *FillOptionsET(struct ares_options *opts,\n                                            struct ares_options *givenopts,\n                                            ares_evsys_t         evsys)\n  {\n    if (givenopts) {\n      memcpy(opts, givenopts, sizeof(*opts));\n    } else {\n      memset(opts, 0, sizeof(*opts));\n    }\n    opts->evsys = evsys;\n    return opts;\n  }",
          "fn_code_pos": [
            [
              382,
              2
            ],
            [
              393,
              3
            ]
          ],
          "class_code": "4a74f8a3065504c1edc5dd3feee461dbad873a78c094b9c7acdc05523429d5b0",
          "class_node_pos": [
            [
              360,
              0
            ],
            [
              410,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptionsET",
            "parameters": {
              "opts": "struct ares_options",
              "givenopts": "struct ares_options",
              "evsys": "ares_evsys_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void Process(unsigned int cancel_ms = 0)\n  {\n    mutex.lock();\n    cancel_ms_ = cancel_ms;\n    mutex.unlock();\n    ares_queue_wait_empty(channel_, -1);\n  }",
          "fn_code_pos": [
            [
              395,
              2
            ],
            [
              401,
              3
            ]
          ],
          "class_code": "4a74f8a3065504c1edc5dd3feee461dbad873a78c094b9c7acdc05523429d5b0",
          "class_node_pos": [
            [
              360,
              0
            ],
            [
              410,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Process",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "MockEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()),\n                              std::get<1>(GetParam()), std::get<2>(GetParam()),\n                              nullptr, 0)\n  {\n  }",
          "fn_code_pos": [
            [
              416,
              2
            ],
            [
              421,
              3
            ]
          ],
          "class_code": "416df76708421d9b1b63f219e598c1d99434e60b86be545c567df10e27f71449",
          "class_node_pos": [
            [
              412,
              0
            ],
            [
              422,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockEventThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockUDPEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()),\n                              std::get<1>(GetParam()), false, nullptr, 0)\n  {\n  }",
          "fn_code_pos": [
            [
              428,
              2
            ],
            [
              432,
              3
            ]
          ],
          "class_code": "ddf7729b016031b17cc0a730a53d015b716a3935fd4cf39b978858f1547bd8b3",
          "class_node_pos": [
            [
              424,
              0
            ],
            [
              433,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockUDPEventThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MockTCPEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()),\n                              std::get<1>(GetParam()), true, nullptr, 0)\n  {\n  }",
          "fn_code_pos": [
            [
              439,
              2
            ],
            [
              443,
              3
            ]
          ],
          "class_code": "a013685d30abc31cef70628484c6c9542dcd713933a40d979c6c516fddd3bd28",
          "class_node_pos": [
            [
              435,
              0
            ],
            [
              444,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockTCPEventThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ACTION_P2(SetReplyData, mockserver, data)\n{\n  mockserver->SetReplyData(data);\n}",
          "fn_code_pos": [
            [
              447,
              0
            ],
            [
              450,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ACTION_P2",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ACTION_P2(SetReply, mockserver, reply)\n{\n  mockserver->SetReply(reply);\n}",
          "fn_code_pos": [
            [
              452,
              0
            ],
            [
              455,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ACTION_P2",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ACTION_P3(SetReplyExpRequest, mockserver, reply, request)\n{\n  mockserver->SetReplyExpRequest(reply, request);\n}",
          "fn_code_pos": [
            [
              459,
              0
            ],
            [
              462,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ACTION_P3",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ACTION_P2(SetReplyQID, mockserver, qid)\n{\n  mockserver->SetReplyQID(qid);\n}",
          "fn_code_pos": [
            [
              464,
              0
            ],
            [
              467,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ACTION_P2",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ACTION_P2(CancelChannel, mockserver, channel)\n{\n  ares_cancel(channel);\n}",
          "fn_code_pos": [
            [
              470,
              0
            ],
            [
              473,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ACTION_P2",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ACTION_P(Disconnect, mockserver)\n{\n  mockserver->Disconnect();\n}",
          "fn_code_pos": [
            [
              476,
              0
            ],
            [
              479,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ACTION_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "HostEnt() : addrtype_(-1)\n  {\n  }",
          "fn_code_pos": [
            [
              483,
              2
            ],
            [
              485,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HostEnt",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "HostResult() : done_(false), status_(0), timeouts_(0)\n  {\n  }",
          "fn_code_pos": [
            [
              498,
              2
            ],
            [
              500,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HostResult",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void operator()(ares_addrinfo *ptr)\n  {\n    if (ptr) {\n      ares_freeaddrinfo(ptr);\n    }\n  }",
          "fn_code_pos": [
            [
              539,
              2
            ],
            [
              544,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ptr": "ares_addrinfo"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "AddrInfoResult() : done_(false), status_(-1), timeouts_(0)\n  {\n  }",
          "fn_code_pos": [
            [
              554,
              2
            ],
            [
              556,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddrInfoResult",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "const char *filename() const\n  {\n    return filename_.c_str();\n  }",
          "fn_code_pos": [
            [
              613,
              2
            ],
            [
              616,
              3
            ]
          ],
          "class_code": "2cc16f98fce1852edef7d3c48f8e921cce4d6c66e0c0d3fee230c5b716b9d89b",
          "class_node_pos": [
            [
              609,
              0
            ],
            [
              617,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "filename",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "static int setenv(const char *name, const char *value, int overwrite)\n{\n  char  *buffer;\n  size_t buf_size;\n\n  if (name == NULL) {\n    return -1;\n  }\n\n  if (value == NULL) {\n    value = \"\"; /* For unset */\n  }\n\n  if (!overwrite && getenv(name) != NULL) {\n    return -1;\n  }\n\n  buf_size = strlen(name) + strlen(value) + 1 /* = */ + 1 /* NULL */;\n  buffer   = (char *)malloc(buf_size);\n  _snprintf(buffer, buf_size, \"%s=%s\", name, value);\n  _putenv(buffer);\n  free(buffer);\n  return 0;\n}",
          "fn_code_pos": [
            [
              622,
              0
            ],
            [
              645,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setenv",
            "parameters": {
              "name": "char",
              "value": "char",
              "overwrite": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int unsetenv(const char *name)\n{\n  return setenv(name, NULL, 1);\n}",
          "fn_code_pos": [
            [
              647,
              0
            ],
            [
              650,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unsetenv",
            "parameters": {
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "EnvValue(const char *name, const char *value) : name_(name), restore_(false)\n  {\n    char *original = getenv(name);\n    if (original) {\n      restore_  = true;\n      original_ = original;\n    }\n    setenv(name_.c_str(), value, 1);\n  }",
          "fn_code_pos": [
            [
              658,
              2
            ],
            [
              666,
              3
            ]
          ],
          "class_code": "aff6eb4bfc699ae6929d60d45c420c9f6484b251bfb6d7759078d873544c79a4",
          "class_node_pos": [
            [
              656,
              0
            ],
            [
              681,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EnvValue",
            "parameters": {
              "name": "char",
              "value": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~EnvValue()\n  {\n    if (restore_) {\n      setenv(name_.c_str(), original_.c_str(), 1);\n    } else {\n      unsetenv(name_.c_str());\n    }\n  }",
          "fn_code_pos": [
            [
              668,
              2
            ],
            [
              675,
              3
            ]
          ],
          "class_code": "aff6eb4bfc699ae6929d60d45c420c9f6484b251bfb6d7759078d873544c79a4",
          "class_node_pos": [
            [
              656,
              0
            ],
            [
              681,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::string root() const\n  {\n    return rootdir_;\n  }",
          "fn_code_pos": [
            [
              695,
              2
            ],
            [
              698,
              3
            ]
          ],
          "class_code": "38a918808dee139aad1e467a522b1f196532e9693c1b2036b5d78a0b118ff283",
          "class_node_pos": [
            [
              690,
              0
            ],
            [
              711,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "root",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "std::string mountpt() const\n  {\n    return mountpt_;\n  }",
          "fn_code_pos": [
            [
              700,
              2
            ],
            [
              703,
              3
            ]
          ],
          "class_code": "38a918808dee139aad1e467a522b1f196532e9693c1b2036b5d78a0b118ff283",
          "class_node_pos": [
            [
              690,
              0
            ],
            [
              711,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "mountpt",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ProcessWork(ares_channel_t                          *channel,\n                                    std::function<std::set<ares_socket_t>()> get_extrafds,\n                                    std::function<void(ares_socket_t)>       process_extra,\n                                    unsigned int                             cancel_ms = 0)",
          "fn_dec_pos": [
            [
              93,
              24
            ],
            [
              96,
              91
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ProcessWork",
            "parameters": {
              "channel": "ares_channel_t",
              "get_extrafds": "std::function<std::set<ares_socket_t>()>",
              "process_extra": "std::function<void(ares_socket_t)>"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "NoExtraFDs()",
          "fn_dec_pos": [
            [
              97,
              24
            ],
            [
              97,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NoExtraFDs",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "af_tostr(int af)",
          "fn_dec_pos": [
            [
              99,
              24
            ],
            [
              99,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "af_tostr",
            "parameters": {
              "af": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "mode_tostr(bool mode)",
          "fn_dec_pos": [
            [
              100,
              24
            ],
            [
              100,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mode_tostr",
            "parameters": {
              "mode": "bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PrintFamilyMode(const testing::TestParamInfo<std::pair<int, bool>> &info)",
          "fn_dec_pos": [
            [
              102,
              2
            ],
            [
              102,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintFamilyMode",
            "parameters": {
              "info": "testing::TestParamInfo<std::pair<int, bool>>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PrintFamily(const testing::TestParamInfo<int> &info)",
          "fn_dec_pos": [
            [
              103,
              12
            ],
            [
              103,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintFamily",
            "parameters": {
              "info": "testing::TestParamInfo<int>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "SetAllocFail(int nth)",
          "fn_dec_pos": [
            [
              124,
              15
            ],
            [
              124,
              36
            ]
          ],
          "class_code": "990616a0074fd048edc43284983d1833a9426ba4b5fb058f3ec1db33559e6fa0",
          "class_node_pos": [
            [
              107,
              0
            ],
            [
              139,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetAllocFail",
            "parameters": {
              "nth": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "SetAllocSizeFail(size_t size)",
          "fn_dec_pos": [
            [
              126,
              15
            ],
            [
              126,
              44
            ]
          ],
          "class_code": "990616a0074fd048edc43284983d1833a9426ba4b5fb058f3ec1db33559e6fa0",
          "class_node_pos": [
            [
              107,
              0
            ],
            [
              139,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetAllocSizeFail",
            "parameters": {
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ClearFails()",
          "fn_dec_pos": [
            [
              128,
              15
            ],
            [
              128,
              27
            ]
          ],
          "class_code": "990616a0074fd048edc43284983d1833a9426ba4b5fb058f3ec1db33559e6fa0",
          "class_node_pos": [
            [
              107,
              0
            ],
            [
              139,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ClearFails",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "amalloc(size_t size)",
          "fn_dec_pos": [
            [
              130,
              15
            ],
            [
              130,
              35
            ]
          ],
          "class_code": "990616a0074fd048edc43284983d1833a9426ba4b5fb058f3ec1db33559e6fa0",
          "class_node_pos": [
            [
              107,
              0
            ],
            [
              139,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "amalloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "arealloc(void *ptr, size_t size)",
          "fn_dec_pos": [
            [
              131,
              15
            ],
            [
              131,
              47
            ]
          ],
          "class_code": "990616a0074fd048edc43284983d1833a9426ba4b5fb058f3ec1db33559e6fa0",
          "class_node_pos": [
            [
              107,
              0
            ],
            [
              139,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "arealloc",
            "parameters": {
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "afree(void *ptr)",
          "fn_dec_pos": [
            [
              132,
              15
            ],
            [
              132,
              31
            ]
          ],
          "class_code": "990616a0074fd048edc43284983d1833a9426ba4b5fb058f3ec1db33559e6fa0",
          "class_node_pos": [
            [
              107,
              0
            ],
            [
              139,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "afree",
            "parameters": {
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ShouldAllocFail(size_t size)",
          "fn_dec_pos": [
            [
              135,
              31
            ],
            [
              135,
              59
            ]
          ],
          "class_code": "990616a0074fd048edc43284983d1833a9426ba4b5fb058f3ec1db33559e6fa0",
          "class_node_pos": [
            [
              107,
              0
            ],
            [
              139,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ShouldAllocFail",
            "parameters": {
              "size": "size_t"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "Process(unsigned int cancel_ms = 0)",
          "fn_dec_pos": [
            [
              162,
              7
            ],
            [
              162,
              42
            ]
          ],
          "class_code": "4377d3f420d85d9a41440b06b546578a96b47dca69a9447aaed7c5f542523ef7",
          "class_node_pos": [
            [
              142,
              0
            ],
            [
              166,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Process",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "Process(unsigned int cancel_ms = 0)",
          "fn_dec_pos": [
            [
              189,
              7
            ],
            [
              189,
              42
            ]
          ],
          "class_code": "b8dcaef941176e3eff8d31f3d714b93d0bc8364f907ff77894f000f40d7f674f",
          "class_node_pos": [
            [
              169,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Process",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "Process(unsigned int cancel_ms = 0)",
          "fn_dec_pos": [
            [
              218,
              7
            ],
            [
              218,
              42
            ]
          ],
          "class_code": "f1ed14826e6b3f8b7597523acf7a8b20d120521ee2c855a7cf7cb79fe709318b",
          "class_node_pos": [
            [
              196,
              0
            ],
            [
              222,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Process",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "MockServer(int family, unsigned short port)",
          "fn_dec_pos": [
            [
              227,
              2
            ],
            [
              227,
              45
            ]
          ],
          "class_code": "969b7740bdd0b6136bc333b418c1da5e2a7726d8ba997912945c4f837e71ca01",
          "class_node_pos": [
            [
              225,
              0
            ],
            [
              304,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockServer",
            "parameters": {
              "family": "int",
              "port": "unsigned short"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~MockServer()",
          "fn_dec_pos": [
            [
              228,
              2
            ],
            [
              228,
              15
            ]
          ],
          "class_code": "969b7740bdd0b6136bc333b418c1da5e2a7726d8ba997912945c4f837e71ca01",
          "class_node_pos": [
            [
              225,
              0
            ],
            [
              304,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "MOCK_METHOD2(OnRequest, void(const std::string &name, int rrtype))",
          "fn_dec_pos": [
            [
              232,
              2
            ],
            [
              232,
              68
            ]
          ],
          "class_code": "969b7740bdd0b6136bc333b418c1da5e2a7726d8ba997912945c4f837e71ca01",
          "class_node_pos": [
            [
              225,
              0
            ],
            [
              304,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MOCK_METHOD2",
            "parameters": {
              "name": "std::string",
              "rrtype": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "fds() const",
          "fn_dec_pos": [
            [
              272,
              26
            ],
            [
              272,
              37
            ]
          ],
          "class_code": "969b7740bdd0b6136bc333b418c1da5e2a7726d8ba997912945c4f837e71ca01",
          "class_node_pos": [
            [
              225,
              0
            ],
            [
              304,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "fds",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ProcessFD(ares_socket_t fd)",
          "fn_dec_pos": [
            [
              275,
              26
            ],
            [
              275,
              53
            ]
          ],
          "class_code": "969b7740bdd0b6136bc333b418c1da5e2a7726d8ba997912945c4f837e71ca01",
          "class_node_pos": [
            [
              225,
              0
            ],
            [
              304,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ProcessFD",
            "parameters": {
              "fd": "ares_socket_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ProcessRequest(ares_socket_t fd, struct sockaddr_storage *addr,\n                                ares_socklen_t addrlen, const std::string &reqstr,\n                                int qid, const std::string &name, int rrtype)",
          "fn_dec_pos": [
            [
              289,
              17
            ],
            [
              291,
              77
            ]
          ],
          "class_code": "969b7740bdd0b6136bc333b418c1da5e2a7726d8ba997912945c4f837e71ca01",
          "class_node_pos": [
            [
              225,
              0
            ],
            [
              304,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ProcessRequest",
            "parameters": {
              "fd": "ares_socket_t",
              "addr": "struct sockaddr_storage",
              "addrlen": "ares_socklen_t",
              "reqstr": "std::string",
              "qid": "int",
              "name": "std::string",
              "rrtype": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ProcessPacket(ares_socket_t fd, struct sockaddr_storage *addr,\n                               ares_socklen_t addrlen, byte *data, int len)",
          "fn_dec_pos": [
            [
              292,
              17
            ],
            [
              293,
              75
            ]
          ],
          "class_code": "969b7740bdd0b6136bc333b418c1da5e2a7726d8ba997912945c4f837e71ca01",
          "class_node_pos": [
            [
              225,
              0
            ],
            [
              304,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ProcessPacket",
            "parameters": {
              "fd": "ares_socket_t",
              "addr": "struct sockaddr_storage",
              "addrlen": "ares_socklen_t",
              "data": "byte",
              "len": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "MockChannelOptsTest(int count, int family, bool force_tcp,\n                      struct ares_options *givenopts, int optmask)",
          "fn_dec_pos": [
            [
              309,
              2
            ],
            [
              310,
              66
            ]
          ],
          "class_code": "7e8c213d1533d08641176852c0d428fe2aa5eb1e6cf2b7b24b246a26f270001e",
          "class_node_pos": [
            [
              307,
              0
            ],
            [
              332,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MockChannelOptsTest",
            "parameters": {
              "count": "int",
              "family": "int",
              "force_tcp": "bool",
              "givenopts": "struct ares_options",
              "optmask": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~MockChannelOptsTest()",
          "fn_dec_pos": [
            [
              311,
              2
            ],
            [
              311,
              24
            ]
          ],
          "class_code": "7e8c213d1533d08641176852c0d428fe2aa5eb1e6cf2b7b24b246a26f270001e",
          "class_node_pos": [
            [
              307,
              0
            ],
            [
              332,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "Process(unsigned int cancel_ms = 0)",
          "fn_dec_pos": [
            [
              315,
              7
            ],
            [
              315,
              42
            ]
          ],
          "class_code": "7e8c213d1533d08641176852c0d428fe2aa5eb1e6cf2b7b24b246a26f270001e",
          "class_node_pos": [
            [
              307,
              0
            ],
            [
              332,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Process",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "fds() const",
          "fn_dec_pos": [
            [
              322,
              55
            ],
            [
              322,
              66
            ]
          ],
          "class_code": "7e8c213d1533d08641176852c0d428fe2aa5eb1e6cf2b7b24b246a26f270001e",
          "class_node_pos": [
            [
              307,
              0
            ],
            [
              332,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "fds",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ProcessFD(ares_socket_t fd)",
          "fn_dec_pos": [
            [
              323,
              25
            ],
            [
              323,
              52
            ]
          ],
          "class_code": "7e8c213d1533d08641176852c0d428fe2aa5eb1e6cf2b7b24b246a26f270001e",
          "class_node_pos": [
            [
              307,
              0
            ],
            [
              332,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ProcessFD",
            "parameters": {
              "fd": "ares_socket_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "BuildServers(int count, int family,\n                                      unsigned short base_port)",
          "fn_dec_pos": [
            [
              325,
              25
            ],
            [
              326,
              63
            ]
          ],
          "class_code": "7e8c213d1533d08641176852c0d428fe2aa5eb1e6cf2b7b24b246a26f270001e",
          "class_node_pos": [
            [
              307,
              0
            ],
            [
              332,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BuildServers",
            "parameters": {
              "count": "int",
              "family": "int",
              "base_port": "unsigned short"
            },
            "return_type": "NiceMockServers"
          }
        },
        {
          "fn_code": "FillOptionsET(struct ares_options *opts,\n                                            struct ares_options *givenopts,\n                                            ares_evsys_t         evsys)",
          "fn_dec_pos": [
            [
              382,
              30
            ],
            [
              384,
              71
            ]
          ],
          "class_code": "4a74f8a3065504c1edc5dd3feee461dbad873a78c094b9c7acdc05523429d5b0",
          "class_node_pos": [
            [
              360,
              0
            ],
            [
              410,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillOptionsET",
            "parameters": {
              "opts": "struct ares_options",
              "givenopts": "struct ares_options",
              "evsys": "ares_evsys_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ProcessThread()",
          "fn_dec_pos": [
            [
              404,
              22
            ],
            [
              404,
              37
            ]
          ],
          "class_code": "4a74f8a3065504c1edc5dd3feee461dbad873a78c094b9c7acdc05523429d5b0",
          "class_node_pos": [
            [
              360,
              0
            ],
            [
              410,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ProcessThread",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "HostEnt(const struct hostent *hostent)",
          "fn_dec_pos": [
            [
              487,
              2
            ],
            [
              487,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HostEnt",
            "parameters": {
              "hostent": "struct hostent"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream &os, const HostEnt &result)",
          "fn_dec_pos": [
            [
              494,
              14
            ],
            [
              494,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "HostEnt"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream &os, const HostResult &result)",
          "fn_dec_pos": [
            [
              511,
              14
            ],
            [
              511,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "HostResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream &os, const SearchResult &result)",
          "fn_dec_pos": [
            [
              523,
              14
            ],
            [
              523,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "SearchResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream &os, const NameInfoResult &result)",
          "fn_dec_pos": [
            [
              536,
              14
            ],
            [
              536,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "NameInfoResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream &os, const AddrInfo &result)",
          "fn_dec_pos": [
            [
              550,
              14
            ],
            [
              550,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "AddrInfo"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream &os, const AddrInfoResult &result)",
          "fn_dec_pos": [
            [
              567,
              14
            ],
            [
              567,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "AddrInfoResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "HostCallback(void *data, int status, int timeouts,\n                           struct hostent *hostent)",
          "fn_dec_pos": [
            [
              571,
              14
            ],
            [
              572,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HostCallback",
            "parameters": {
              "data": "void",
              "status": "int",
              "timeouts": "int",
              "hostent": "struct hostent"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "SearchCallback(void *data, int status, int timeouts, unsigned char *abuf,\n                    int alen)",
          "fn_dec_pos": [
            [
              573,
              5
            ],
            [
              574,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SearchCallback",
            "parameters": {
              "data": "void",
              "status": "int",
              "timeouts": "int",
              "abuf": "unsigned char",
              "alen": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "SearchCallbackDnsRec(void *data, ares_status_t status, size_t timeouts,\n                          const ares_dns_record_t *dnsrec)",
          "fn_dec_pos": [
            [
              575,
              5
            ],
            [
              576,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SearchCallbackDnsRec",
            "parameters": {
              "data": "void",
              "status": "ares_status_t",
              "timeouts": "size_t",
              "dnsrec": "ares_dns_record_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "NameInfoCallback(void *data, int status, int timeouts, char *node,\n                      char *service)",
          "fn_dec_pos": [
            [
              577,
              5
            ],
            [
              578,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NameInfoCallback",
            "parameters": {
              "data": "void",
              "status": "int",
              "timeouts": "int",
              "node": "char",
              "service": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "AddrInfoCallback(void *data, int status, int timeouts,\n                      struct ares_addrinfo *res)",
          "fn_dec_pos": [
            [
              579,
              5
            ],
            [
              580,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AddrInfoCallback",
            "parameters": {
              "data": "void",
              "status": "int",
              "timeouts": "int",
              "res": "struct ares_addrinfo"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "GetNameServers(ares_channel_t *channel)",
          "fn_dec_pos": [
            [
              583,
              12
            ],
            [
              583,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetNameServers",
            "parameters": {
              "channel": "ares_channel_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TransientDir(const std::string &dirname)",
          "fn_dec_pos": [
            [
              588,
              2
            ],
            [
              588,
              42
            ]
          ],
          "class_code": "f4000971275b5ab39b02fc25980d8c6168bd5ff4fc5ad590f06bc43c3d2086cc",
          "class_node_pos": [
            [
              586,
              0
            ],
            [
              593,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TransientDir",
            "parameters": {
              "dirname": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~TransientDir()",
          "fn_dec_pos": [
            [
              589,
              2
            ],
            [
              589,
              17
            ]
          ],
          "class_code": "f4000971275b5ab39b02fc25980d8c6168bd5ff4fc5ad590f06bc43c3d2086cc",
          "class_node_pos": [
            [
              586,
              0
            ],
            [
              593,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TempNam(const char *dir, const char *prefix)",
          "fn_dec_pos": [
            [
              596,
              12
            ],
            [
              596,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TempNam",
            "parameters": {
              "dir": "char",
              "prefix": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TransientFile(const std::string &filename, const std::string &contents)",
          "fn_dec_pos": [
            [
              601,
              2
            ],
            [
              601,
              73
            ]
          ],
          "class_code": "c29cae8889cb2f9c7a834d78235fdbbbf3060e3fddc198058d4f47776778b696",
          "class_node_pos": [
            [
              599,
              0
            ],
            [
              606,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TransientFile",
            "parameters": {
              "filename": "std::string",
              "contents": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~TransientFile()",
          "fn_dec_pos": [
            [
              602,
              2
            ],
            [
              602,
              18
            ]
          ],
          "class_code": "c29cae8889cb2f9c7a834d78235fdbbbf3060e3fddc198058d4f47776778b696",
          "class_node_pos": [
            [
              599,
              0
            ],
            [
              606,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TempFile(const std::string &contents)",
          "fn_dec_pos": [
            [
              611,
              2
            ],
            [
              611,
              39
            ]
          ],
          "class_code": "2cc16f98fce1852edef7d3c48f8e921cce4d6c66e0c0d3fee230c5b716b9d89b",
          "class_node_pos": [
            [
              609,
              0
            ],
            [
              617,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TempFile",
            "parameters": {
              "contents": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "filename() const",
          "fn_dec_pos": [
            [
              613,
              14
            ],
            [
              613,
              30
            ]
          ],
          "class_code": "2cc16f98fce1852edef7d3c48f8e921cce4d6c66e0c0d3fee230c5b716b9d89b",
          "class_node_pos": [
            [
              609,
              0
            ],
            [
              617,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "filename",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ContainerFilesystem(NameContentList files, const std::string &mountpt)",
          "fn_dec_pos": [
            [
              692,
              2
            ],
            [
              692,
              72
            ]
          ],
          "class_code": "38a918808dee139aad1e467a522b1f196532e9693c1b2036b5d78a0b118ff283",
          "class_node_pos": [
            [
              690,
              0
            ],
            [
              711,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ContainerFilesystem",
            "parameters": {
              "files": "NameContentList",
              "mountpt": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~ContainerFilesystem()",
          "fn_dec_pos": [
            [
              693,
              2
            ],
            [
              693,
              24
            ]
          ],
          "class_code": "38a918808dee139aad1e467a522b1f196532e9693c1b2036b5d78a0b118ff283",
          "class_node_pos": [
            [
              690,
              0
            ],
            [
              711,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "EnsureDirExists(const std::string &dir)",
          "fn_dec_pos": [
            [
              706,
              25
            ],
            [
              706,
              64
            ]
          ],
          "class_code": "38a918808dee139aad1e467a522b1f196532e9693c1b2036b5d78a0b118ff283",
          "class_node_pos": [
            [
              690,
              0
            ],
            [
              711,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EnsureDirExists",
            "parameters": {
              "dir": "std::string"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "RunInContainer(ContainerFilesystem *fs, const std::string &hostname,\n                   const std::string &domainname, VoidToIntFn fn)",
          "fn_dec_pos": [
            [
              713,
              4
            ],
            [
              714,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RunInContainer",
            "parameters": {
              "fs": "ContainerFilesystem",
              "hostname": "std::string",
              "domainname": "std::string",
              "fn": "VoidToIntFn"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "VirtualizeIO(ares_channel)",
          "fn_dec_pos": [
            [
              740,
              2
            ],
            [
              740,
              28
            ]
          ],
          "class_code": "e856eee93a2c9edd8becd9b9f3bbd8f02b31a545dcdd4ce2a4f82a54999c8677",
          "class_node_pos": [
            [
              738,
              0
            ],
            [
              747,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VirtualizeIO",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~VirtualizeIO()",
          "fn_dec_pos": [
            [
              741,
              2
            ],
            [
              741,
              17
            ]
          ],
          "class_code": "e856eee93a2c9edd8becd9b9f3bbd8f02b31a545dcdd4ce2a4f82a54999c8677",
          "class_node_pos": [
            [
              738,
              0
            ],
            [
              747,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "990616a0074fd048edc43284983d1833a9426ba4b5fb058f3ec1db33559e6fa0": {
          "class_code": "class LibraryTest : public ::testing::Test {\npublic:\n  LibraryTest()\n  {\n    EXPECT_EQ(ARES_SUCCESS, ares_library_init_mem(\n                              ARES_LIB_INIT_ALL, &LibraryTest::amalloc,\n                              &LibraryTest::afree, &LibraryTest::arealloc));\n  }\n\n  ~LibraryTest()\n  {\n    ares_library_cleanup();\n    ClearFails();\n  }\n\n  // Set the n-th malloc call (of any size) from the library to fail.\n  // (nth == 1 means the next call)\n  static void  SetAllocFail(int nth);\n  // Set the next malloc call for the given size to fail.\n  static void  SetAllocSizeFail(size_t size);\n  // Remove any pending alloc failures.\n  static void  ClearFails();\n\n  static void *amalloc(size_t size);\n  static void *arealloc(void *ptr, size_t size);\n  static void  afree(void *ptr);\n\nprivate:\n  static bool                  ShouldAllocFail(size_t size);\n  static unsigned long long    fails_;\n  static std::map<size_t, int> size_fails_;\n  static std::mutex            lock_;\n}",
          "class_name": "LibraryTest",
          "class_pos": [
            [
              107,
              0
            ],
            [
              139,
              1
            ]
          ]
        },
        "4377d3f420d85d9a41440b06b546578a96b47dca69a9447aaed7c5f542523ef7": {
          "class_code": "class DefaultChannelTest : public LibraryTest {\npublic:\n  DefaultChannelTest() : channel_(nullptr)\n  {\n    /* Enable query cache for live tests */\n    struct ares_options opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.qcache_max_ttl = 300;\n    int optmask         = ARES_OPT_QUERY_CACHE;\n    EXPECT_EQ(ARES_SUCCESS, ares_init_options(&channel_, &opts, optmask));\n    EXPECT_NE(nullptr, channel_);\n  }\n\n  ~DefaultChannelTest()\n  {\n    ares_destroy(channel_);\n    channel_ = nullptr;\n  }\n\n  // Process all pending work on ares-owned file descriptors.\n  void Process(unsigned int cancel_ms = 0);\n\nprotected:\n  ares_channel_t *channel_;\n}",
          "class_name": "DefaultChannelTest",
          "class_pos": [
            [
              142,
              0
            ],
            [
              166,
              1
            ]
          ]
        },
        "b8dcaef941176e3eff8d31f3d714b93d0bc8364f907ff77894f000f40d7f674f": {
          "class_code": "class FileChannelTest : public LibraryTest {\npublic:\n  FileChannelTest() : channel_(nullptr)\n  {\n    struct ares_options opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.lookups = strdup(\"f\");\n    int optmask  = ARES_OPT_LOOKUPS;\n    EXPECT_EQ(ARES_SUCCESS, ares_init_options(&channel_, &opts, optmask));\n    EXPECT_NE(nullptr, channel_);\n    free(opts.lookups);\n  }\n\n  ~FileChannelTest()\n  {\n    ares_destroy(channel_);\n    channel_ = nullptr;\n  }\n\n  // Process all pending work on ares-owned file descriptors.\n  void Process(unsigned int cancel_ms = 0);\n\nprotected:\n  ares_channel_t *channel_;\n}",
          "class_name": "FileChannelTest",
          "class_pos": [
            [
              169,
              0
            ],
            [
              193,
              1
            ]
          ]
        },
        "f1ed14826e6b3f8b7597523acf7a8b20d120521ee2c855a7cf7cb79fe709318b": {
          "class_code": "class DefaultChannelModeTest\n  : public LibraryTest,\n    public ::testing::WithParamInterface<std::string> {\npublic:\n  DefaultChannelModeTest() : channel_(nullptr)\n  {\n    struct ares_options opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.lookups = strdup(GetParam().c_str());\n    int optmask  = ARES_OPT_LOOKUPS;\n    EXPECT_EQ(ARES_SUCCESS, ares_init_options(&channel_, &opts, optmask));\n    EXPECT_NE(nullptr, channel_);\n    free(opts.lookups);\n  }\n\n  ~DefaultChannelModeTest()\n  {\n    ares_destroy(channel_);\n    channel_ = nullptr;\n  }\n\n  // Process all pending work on ares-owned file descriptors.\n  void Process(unsigned int cancel_ms = 0);\n\nprotected:\n  ares_channel_t *channel_;\n}",
          "class_name": "DefaultChannelModeTest",
          "class_pos": [
            [
              196,
              0
            ],
            [
              222,
              1
            ]
          ]
        },
        "969b7740bdd0b6136bc333b418c1da5e2a7726d8ba997912945c4f837e71ca01": {
          "class_code": "class MockServer {\npublic:\n  MockServer(int family, unsigned short port);\n  ~MockServer();\n\n  // Mock method indicating the processing of a particular <name, RRtype>\n  // request.\n  MOCK_METHOD2(OnRequest, void(const std::string &name, int rrtype));\n\n  // Set the reply to be sent next; the query ID field will be overwritten\n  // with the value from the request.\n  void SetReplyData(const std::vector<byte> &reply)\n  {\n    reply_ = reply;\n  }\n\n  void SetReply(const DNSPacket *reply)\n  {\n    SetReplyData(reply->data());\n  }\n\n  // Set the reply to be sent next as well as the request (in string form) that\n  // the server should expect to receive; the query ID field in the reply will\n  // be overwritten with the value from the request.\n  void SetReplyExpRequest(const DNSPacket *reply, const std::string &request)\n  {\n    expected_request_ = request;\n    SetReply(reply);\n  }\n\n  void SetReplyQID(int qid)\n  {\n    qid_ = qid;\n  }\n\n  void Disconnect()\n  {\n    for (ares_socket_t fd : connfds_) {\n      sclose(fd);\n    }\n    connfds_.clear();\n    free(tcp_data_);\n    tcp_data_     = NULL;\n    tcp_data_len_ = 0;\n  }\n\n  // The set of file descriptors that the server handles.\n  std::set<ares_socket_t> fds() const;\n\n  // Process activity on a file descriptor.\n  void                    ProcessFD(ares_socket_t fd);\n\n  // Ports the server is responding to\n  unsigned short          udpport() const\n  {\n    return udpport_;\n  }\n\n  unsigned short tcpport() const\n  {\n    return tcpport_;\n  }\n\nprivate:\n  void           ProcessRequest(ares_socket_t fd, struct sockaddr_storage *addr,\n                                ares_socklen_t addrlen, const std::string &reqstr,\n                                int qid, const std::string &name, int rrtype);\n  void           ProcessPacket(ares_socket_t fd, struct sockaddr_storage *addr,\n                               ares_socklen_t addrlen, byte *data, int len);\n  unsigned short udpport_;\n  unsigned short tcpport_;\n  ares_socket_t  udpfd_;\n  ares_socket_t  tcpfd_;\n  std::set<ares_socket_t> connfds_;\n  std::vector<byte>       reply_;\n  std::string             expected_request_;\n  int                     qid_;\n  unsigned char          *tcp_data_;\n  size_t                  tcp_data_len_;\n}",
          "class_name": "MockServer",
          "class_pos": [
            [
              225,
              0
            ],
            [
              304,
              1
            ]
          ]
        },
        "7e8c213d1533d08641176852c0d428fe2aa5eb1e6cf2b7b24b246a26f270001e": {
          "class_code": "class MockChannelOptsTest : public LibraryTest {\npublic:\n  MockChannelOptsTest(int count, int family, bool force_tcp,\n                      struct ares_options *givenopts, int optmask);\n  ~MockChannelOptsTest();\n\n  // Process all pending work on ares-owned and mock-server-owned file\n  // descriptors.\n  void Process(unsigned int cancel_ms = 0);\n\nprotected:\n  // NiceMockServer doesn't complain about uninteresting calls.\n  typedef testing::NiceMock<MockServer>                NiceMockServer;\n  typedef std::vector<std::unique_ptr<NiceMockServer>> NiceMockServers;\n\n  std::set<ares_socket_t>                              fds() const;\n  void                   ProcessFD(ares_socket_t fd);\n\n  static NiceMockServers BuildServers(int count, int family,\n                                      unsigned short base_port);\n\n  NiceMockServers        servers_;\n  // Convenience reference to first server.\n  NiceMockServer        &server_;\n  ares_channel_t        *channel_;\n}",
          "class_name": "MockChannelOptsTest",
          "class_pos": [
            [
              307,
              0
            ],
            [
              332,
              1
            ]
          ]
        },
        "3a5bee8efe7fef9b7e0e07b4769df21b821da5d44dc2cd7b7d181b115f9fb97d": {
          "class_code": "class MockChannelTest\n  : public MockChannelOptsTest,\n    public ::testing::WithParamInterface<std::pair<int, bool>> {\npublic:\n  MockChannelTest()\n    : MockChannelOptsTest(1, GetParam().first, GetParam().second, nullptr, 0)\n  {\n  }\n}",
          "class_name": "MockChannelTest",
          "class_pos": [
            [
              334,
              0
            ],
            [
              342,
              1
            ]
          ]
        },
        "c671a507b0505e2f03e3cab1c3fa810d72f1e0b26f5c97b5fa1e259dbc730262": {
          "class_code": "class MockUDPChannelTest : public MockChannelOptsTest,\n                           public ::testing::WithParamInterface<int> {\npublic:\n  MockUDPChannelTest() : MockChannelOptsTest(1, GetParam(), false, nullptr, 0)\n  {\n  }\n}",
          "class_name": "MockUDPChannelTest",
          "class_pos": [
            [
              344,
              0
            ],
            [
              350,
              1
            ]
          ]
        },
        "15d3cd11e470f7041c4f77af11719d179fd4d983511f5792e7febfa5260a55be": {
          "class_code": "class MockTCPChannelTest : public MockChannelOptsTest,\n                           public ::testing::WithParamInterface<int> {\npublic:\n  MockTCPChannelTest() : MockChannelOptsTest(1, GetParam(), true, nullptr, 0)\n  {\n  }\n}",
          "class_name": "MockTCPChannelTest",
          "class_pos": [
            [
              352,
              0
            ],
            [
              358,
              1
            ]
          ]
        },
        "4a74f8a3065504c1edc5dd3feee461dbad873a78c094b9c7acdc05523429d5b0": {
          "class_code": "class MockEventThreadOptsTest : public MockChannelOptsTest {\npublic:\n  MockEventThreadOptsTest(int count, ares_evsys_t evsys, int family,\n                          bool force_tcp, struct ares_options *givenopts,\n                          int optmask)\n    : MockChannelOptsTest(count, family, force_tcp,\n                          FillOptionsET(&evopts_, givenopts, evsys),\n                          optmask | ARES_OPT_EVENT_THREAD)\n  {\n    cancel_ms_ = 0;\n    isup       = true;\n    thread     = std::thread(&MockEventThreadOptsTest::ProcessThread, this);\n  }\n\n  ~MockEventThreadOptsTest()\n  {\n    mutex.lock();\n    isup = false;\n    mutex.unlock();\n    thread.join();\n  }\n\n  static struct ares_options *FillOptionsET(struct ares_options *opts,\n                                            struct ares_options *givenopts,\n                                            ares_evsys_t         evsys)\n  {\n    if (givenopts) {\n      memcpy(opts, givenopts, sizeof(*opts));\n    } else {\n      memset(opts, 0, sizeof(*opts));\n    }\n    opts->evsys = evsys;\n    return opts;\n  }\n\n  void Process(unsigned int cancel_ms = 0)\n  {\n    mutex.lock();\n    cancel_ms_ = cancel_ms;\n    mutex.unlock();\n    ares_queue_wait_empty(channel_, -1);\n  }\n\nprivate:\n  void                ProcessThread();\n  struct ares_options evopts_;\n  unsigned int        cancel_ms_;\n  bool                isup;\n  std::mutex          mutex;\n  std::thread         thread;\n}",
          "class_name": "MockEventThreadOptsTest",
          "class_pos": [
            [
              360,
              0
            ],
            [
              410,
              1
            ]
          ]
        },
        "416df76708421d9b1b63f219e598c1d99434e60b86be545c567df10e27f71449": {
          "class_code": "class MockEventThreadTest\n  : public MockEventThreadOptsTest,\n    public ::testing::WithParamInterface<std::tuple<ares_evsys_t, int, bool>> {\npublic:\n  MockEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()),\n                              std::get<1>(GetParam()), std::get<2>(GetParam()),\n                              nullptr, 0)\n  {\n  }\n}",
          "class_name": "MockEventThreadTest",
          "class_pos": [
            [
              412,
              0
            ],
            [
              422,
              1
            ]
          ]
        },
        "ddf7729b016031b17cc0a730a53d015b716a3935fd4cf39b978858f1547bd8b3": {
          "class_code": "class MockUDPEventThreadTest\n  : public MockEventThreadOptsTest,\n    public ::testing::WithParamInterface<std::tuple<ares_evsys_t, int>> {\npublic:\n  MockUDPEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()),\n                              std::get<1>(GetParam()), false, nullptr, 0)\n  {\n  }\n}",
          "class_name": "MockUDPEventThreadTest",
          "class_pos": [
            [
              424,
              0
            ],
            [
              433,
              1
            ]
          ]
        },
        "a013685d30abc31cef70628484c6c9542dcd713933a40d979c6c516fddd3bd28": {
          "class_code": "class MockTCPEventThreadTest\n  : public MockEventThreadOptsTest,\n    public ::testing::WithParamInterface<std::tuple<ares_evsys_t, int>> {\npublic:\n  MockTCPEventThreadTest()\n    : MockEventThreadOptsTest(1, std::get<0>(GetParam()),\n                              std::get<1>(GetParam()), true, nullptr, 0)\n  {\n  }\n}",
          "class_name": "MockTCPEventThreadTest",
          "class_pos": [
            [
              435,
              0
            ],
            [
              444,
              1
            ]
          ]
        },
        "f4000971275b5ab39b02fc25980d8c6168bd5ff4fc5ad590f06bc43c3d2086cc": {
          "class_code": "class TransientDir {\npublic:\n  TransientDir(const std::string &dirname);\n  ~TransientDir();\n\nprivate:\n  std::string dirname_;\n}",
          "class_name": "TransientDir",
          "class_pos": [
            [
              586,
              0
            ],
            [
              593,
              1
            ]
          ]
        },
        "c29cae8889cb2f9c7a834d78235fdbbbf3060e3fddc198058d4f47776778b696": {
          "class_code": "class TransientFile {\npublic:\n  TransientFile(const std::string &filename, const std::string &contents);\n  ~TransientFile();\n\nprotected:\n  std::string filename_;\n}",
          "class_name": "TransientFile",
          "class_pos": [
            [
              599,
              0
            ],
            [
              606,
              1
            ]
          ]
        },
        "2cc16f98fce1852edef7d3c48f8e921cce4d6c66e0c0d3fee230c5b716b9d89b": {
          "class_code": "class TempFile : public TransientFile {\npublic:\n  TempFile(const std::string &contents);\n\n  const char *filename() const\n  {\n    return filename_.c_str();\n  }\n}",
          "class_name": "TempFile",
          "class_pos": [
            [
              609,
              0
            ],
            [
              617,
              1
            ]
          ]
        },
        "aff6eb4bfc699ae6929d60d45c420c9f6484b251bfb6d7759078d873544c79a4": {
          "class_code": "class EnvValue {\npublic:\n  EnvValue(const char *name, const char *value) : name_(name), restore_(false)\n  {\n    char *original = getenv(name);\n    if (original) {\n      restore_  = true;\n      original_ = original;\n    }\n    setenv(name_.c_str(), value, 1);\n  }\n\n  ~EnvValue()\n  {\n    if (restore_) {\n      setenv(name_.c_str(), original_.c_str(), 1);\n    } else {\n      unsetenv(name_.c_str());\n    }\n  }\n\nprivate:\n  std::string name_;\n  bool        restore_;\n  std::string original_;\n}",
          "class_name": "EnvValue",
          "class_pos": [
            [
              656,
              0
            ],
            [
              681,
              1
            ]
          ]
        },
        "38a918808dee139aad1e467a522b1f196532e9693c1b2036b5d78a0b118ff283": {
          "class_code": "class ContainerFilesystem {\npublic:\n  ContainerFilesystem(NameContentList files, const std::string &mountpt);\n  ~ContainerFilesystem();\n\n  std::string root() const\n  {\n    return rootdir_;\n  }\n\n  std::string mountpt() const\n  {\n    return mountpt_;\n  }\n\nprivate:\n  void                   EnsureDirExists(const std::string &dir);\n  std::string            rootdir_;\n  std::string            mountpt_;\n  std::list<std::string> dirs_;\n  std::vector<std::unique_ptr<TransientFile>> files_;\n}",
          "class_name": "ContainerFilesystem",
          "class_pos": [
            [
              690,
              0
            ],
            [
              711,
              1
            ]
          ]
        },
        "e856eee93a2c9edd8becd9b9f3bbd8f02b31a545dcdd4ce2a4f82a54999c8677": {
          "class_code": "class VirtualizeIO {\npublic:\n  VirtualizeIO(ares_channel);\n  ~VirtualizeIO();\n\n  static const ares_socket_functions default_functions;\n\nprivate:\n  ares_channel_t *channel_;\n}",
          "class_name": "VirtualizeIO",
          "class_pos": [
            [
              738,
              0
            ],
            [
              747,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct HostEnt {\n  HostEnt() : addrtype_(-1)\n  {\n  }\n\n  HostEnt(const struct hostent *hostent);\n  std::string              name_;\n  std::vector<std::string> aliases_;\n  int                      addrtype_;  // AF_INET or AF_INET6\n  std::vector<std::string> addrs_;\n}",
          {
            "name_": "std::string",
            "aliases_": "std::vector<std::string>",
            "addrtype_": "int",
            "addrs_": "std::vector<std::string>"
          },
          "HostEnt",
          [
            482,
            0
          ],
          [
            492,
            1
          ]
        ],
        [
          "struct HostResult {\n  HostResult() : done_(false), status_(0), timeouts_(0)\n  {\n  }\n\n  // Whether the callback has been invoked.\n  bool    done_;\n  // Explicitly provided result information.\n  int     status_;\n  int     timeouts_;\n  // Contents of the hostent structure, if provided.\n  HostEnt host_;\n}",
          {
            "done_": "bool",
            "status_": "int",
            "timeouts_": "int",
            "host_": "HostEnt"
          },
          "HostResult",
          [
            497,
            0
          ],
          [
            509,
            1
          ]
        ],
        [
          "struct SearchResult {\n  // Whether the callback has been invoked.\n  bool              done_;\n  // Explicitly provided result information.\n  int               status_;\n  int               timeouts_;\n  std::vector<byte> data_;\n}",
          {
            "done_": "bool",
            "status_": "int",
            "timeouts_": "int",
            "data_": "std::vector<byte>"
          },
          "SearchResult",
          [
            514,
            0
          ],
          [
            521,
            1
          ]
        ],
        [
          "struct NameInfoResult {\n  // Whether the callback has been invoked.\n  bool        done_;\n  // Explicitly provided result information.\n  int         status_;\n  int         timeouts_;\n  std::string node_;\n  std::string service_;\n}",
          {
            "done_": "bool",
            "status_": "int",
            "timeouts_": "int",
            "node_": "std::string",
            "service_": "std::string"
          },
          "NameInfoResult",
          [
            526,
            0
          ],
          [
            534,
            1
          ]
        ],
        [
          "struct AddrInfoDeleter {\n  void operator()(ares_addrinfo *ptr)\n  {\n    if (ptr) {\n      ares_freeaddrinfo(ptr);\n    }\n  }\n}",
          {},
          "AddrInfoDeleter",
          [
            538,
            0
          ],
          [
            545,
            1
          ]
        ],
        [
          "struct AddrInfoResult {\n  AddrInfoResult() : done_(false), status_(-1), timeouts_(0)\n  {\n  }\n\n  // Whether the callback has been invoked.\n  bool     done_;\n  // Explicitly provided result information.\n  int      status_;\n  int      timeouts_;\n  // Contents of the ares_addrinfo structure, if provided.\n  AddrInfo ai_;\n}",
          {
            "done_": "bool",
            "status_": "int",
            "timeouts_": "int",
            "ai_": "AddrInfo"
          },
          "AddrInfoResult",
          [
            553,
            0
          ],
          [
            565,
            1
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            147,
            4
          ],
          [
            147,
            23
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            173,
            4
          ],
          [
            173,
            23
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            202,
            4
          ],
          [
            202,
            23
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            289,
            50
          ],
          [
            289,
            73
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            292,
            49
          ],
          [
            292,
            72
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            310,
            22
          ],
          [
            310,
            41
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            363,
            42
          ],
          [
            363,
            61
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            382,
            9
          ],
          [
            382,
            28
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            382,
            44
          ],
          [
            382,
            63
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            383,
            44
          ],
          [
            383,
            63
          ]
        ],
        [
          "struct ares_options",
          {},
          "",
          [
            405,
            2
          ],
          [
            405,
            21
          ]
        ],
        [
          "struct HostEnt {\n  HostEnt() : addrtype_(-1)\n  {\n  }\n\n  HostEnt(const struct hostent *hostent);\n  std::string              name_;\n  std::vector<std::string> aliases_;\n  int                      addrtype_;  // AF_INET or AF_INET6\n  std::vector<std::string> addrs_;\n}",
          {
            "name_": "std::string",
            "aliases_": "std::vector<std::string>",
            "addrtype_": "int",
            "addrs_": "std::vector<std::string>"
          },
          "HostEnt",
          [
            482,
            0
          ],
          [
            492,
            1
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            487,
            16
          ],
          [
            487,
            30
          ]
        ],
        [
          "struct HostResult {\n  HostResult() : done_(false), status_(0), timeouts_(0)\n  {\n  }\n\n  // Whether the callback has been invoked.\n  bool    done_;\n  // Explicitly provided result information.\n  int     status_;\n  int     timeouts_;\n  // Contents of the hostent structure, if provided.\n  HostEnt host_;\n}",
          {
            "done_": "bool",
            "status_": "int",
            "timeouts_": "int",
            "host_": "HostEnt"
          },
          "HostResult",
          [
            497,
            0
          ],
          [
            509,
            1
          ]
        ],
        [
          "struct SearchResult {\n  // Whether the callback has been invoked.\n  bool              done_;\n  // Explicitly provided result information.\n  int               status_;\n  int               timeouts_;\n  std::vector<byte> data_;\n}",
          {
            "done_": "bool",
            "status_": "int",
            "timeouts_": "int",
            "data_": "std::vector<byte>"
          },
          "SearchResult",
          [
            514,
            0
          ],
          [
            521,
            1
          ]
        ],
        [
          "struct NameInfoResult {\n  // Whether the callback has been invoked.\n  bool        done_;\n  // Explicitly provided result information.\n  int         status_;\n  int         timeouts_;\n  std::string node_;\n  std::string service_;\n}",
          {
            "done_": "bool",
            "status_": "int",
            "timeouts_": "int",
            "node_": "std::string",
            "service_": "std::string"
          },
          "NameInfoResult",
          [
            526,
            0
          ],
          [
            534,
            1
          ]
        ],
        [
          "struct AddrInfoDeleter {\n  void operator()(ares_addrinfo *ptr)\n  {\n    if (ptr) {\n      ares_freeaddrinfo(ptr);\n    }\n  }\n}",
          {},
          "AddrInfoDeleter",
          [
            538,
            0
          ],
          [
            545,
            1
          ]
        ],
        [
          "struct AddrInfoResult {\n  AddrInfoResult() : done_(false), status_(-1), timeouts_(0)\n  {\n  }\n\n  // Whether the callback has been invoked.\n  bool     done_;\n  // Explicitly provided result information.\n  int      status_;\n  int      timeouts_;\n  // Contents of the ares_addrinfo structure, if provided.\n  AddrInfo ai_;\n}",
          {
            "done_": "bool",
            "status_": "int",
            "timeouts_": "int",
            "ai_": "AddrInfo"
          },
          "AddrInfoResult",
          [
            553,
            0
          ],
          [
            565,
            1
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            572,
            27
          ],
          [
            572,
            41
          ]
        ],
        [
          "struct ares_addrinfo",
          {},
          "",
          [
            580,
            22
          ],
          [
            580,
            42
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"ares_setup.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#  include \"ares_config.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include \"dns-proto.h\"\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include \"ares_nameser.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"gtest/gtest.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include \"gmock/gmock.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <functional>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <list>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <map>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <memory>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <set>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include <mutex>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include <thread>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include <utility>\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include <chrono>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "../docker_shared/source_code/c-ares/test/date.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "Date(int year, int month, int day)",
          "fn_dec_pos": [
            [
              11,
              4
            ],
            [
              11,
              38
            ]
          ],
          "class_code": "ced13827b2e9b731b82f1847da07d27b0ab901665ded1bf4c698d15d4aff46f7",
          "class_node_pos": [
            [
              3,
              0
            ],
            [
              18,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Date",
            "parameters": {
              "year": "int",
              "month": "int",
              "day": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "print() const",
          "fn_dec_pos": [
            [
              13,
              9
            ],
            [
              13,
              22
            ]
          ],
          "class_code": "ced13827b2e9b731b82f1847da07d27b0ab901665ded1bf4c698d15d4aff46f7",
          "class_node_pos": [
            [
              3,
              0
            ],
            [
              18,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "print",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "getYear() const",
          "fn_dec_pos": [
            [
              15,
              8
            ],
            [
              15,
              23
            ]
          ],
          "class_code": "ced13827b2e9b731b82f1847da07d27b0ab901665ded1bf4c698d15d4aff46f7",
          "class_node_pos": [
            [
              3,
              0
            ],
            [
              18,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "getYear",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "getMonth() const",
          "fn_dec_pos": [
            [
              16,
              8
            ],
            [
              16,
              24
            ]
          ],
          "class_code": "ced13827b2e9b731b82f1847da07d27b0ab901665ded1bf4c698d15d4aff46f7",
          "class_node_pos": [
            [
              3,
              0
            ],
            [
              18,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "getMonth",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "getDay() const",
          "fn_dec_pos": [
            [
              17,
              8
            ],
            [
              17,
              22
            ]
          ],
          "class_code": "ced13827b2e9b731b82f1847da07d27b0ab901665ded1bf4c698d15d4aff46f7",
          "class_node_pos": [
            [
              3,
              0
            ],
            [
              18,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "getDay",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {
        "ced13827b2e9b731b82f1847da07d27b0ab901665ded1bf4c698d15d4aff46f7": {
          "class_code": "class Date\n{\nprivate:\n    int m_year{};\n    int m_month{};\n    int m_day{};\n\npublic:\n    Date(int year, int month, int day);\n\n    void print() const;\n\n    int getYear() const;\n    int getMonth() const ;\n    int getDay() const ;\n}",
          "class_name": "Date",
          "class_pos": [
            [
              3,
              0
            ],
            [
              18,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    }
  }
}