{
  "src": {
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/third_party/googletest/src/src/gtest-typed-test.cc": {
      "fn_def_list": [
        {
          "fn_code": "static const char* SkipSpaces(const char* str) {\n  while (IsSpace(*str))\n    str++;\n  return str;\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              45,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SkipSpaces",
            "parameters": {
              "str": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static std::vector<std::string> SplitIntoTestNames(const char* src) {\n  std::vector<std::string> name_vec;\n  src = SkipSpaces(src);\n  for (; src != NULL; src = SkipComma(src)) {\n    name_vec.push_back(StripTrailingSpaces(GetPrefixUntilComma(src)));\n  }\n  return name_vec;\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SplitIntoTestNames",
            "parameters": {
              "src": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "const char* TypedTestCasePState::VerifyRegisteredTestNames(\n    const char* file, int line, const char* registered_tests) {\n  typedef RegisteredTestsMap::const_iterator RegisteredTestIter;\n  registered_ = true;\n\n  std::vector<std::string> name_vec = SplitIntoTestNames(registered_tests);\n\n  Message errors;\n\n  std::set<std::string> tests;\n  for (std::vector<std::string>::const_iterator name_it = name_vec.begin();\n       name_it != name_vec.end(); ++name_it) {\n    const std::string& name = *name_it;\n    if (tests.count(name) != 0) {\n      errors << \"Test \" << name << \" is listed more than once.\\n\";\n      continue;\n    }\n\n    bool found = false;\n    for (RegisteredTestIter it = registered_tests_.begin();\n         it != registered_tests_.end();\n         ++it) {\n      if (name == it->first) {\n        found = true;\n        break;\n      }\n    }\n\n    if (found) {\n      tests.insert(name);\n    } else {\n      errors << \"No test named \" << name\n             << \" can be found in this test case.\\n\";\n    }\n  }\n\n  for (RegisteredTestIter it = registered_tests_.begin();\n       it != registered_tests_.end();\n       ++it) {\n    if (tests.count(it->first) == 0) {\n      errors << \"You forgot to list test \" << it->first << \".\\n\";\n    }\n  }\n\n  const std::string& errors_str = errors.GetString();\n  if (errors_str != \"\") {\n    fprintf(stderr, \"%s %s\", FormatFileLocation(file, line).c_str(),\n            errors_str.c_str());\n    fflush(stderr);\n    posix::Abort();\n  }\n\n  return registered_tests;\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TypedTestCasePState::VerifyRegisteredTestNames",
            "parameters": {
              "file": "char",
              "line": "int",
              "registered_tests": "char"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "SkipSpaces(const char* str)",
          "fn_dec_pos": [
            [
              41,
              19
            ],
            [
              41,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SkipSpaces",
            "parameters": {
              "str": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TypedTestCasePState::VerifyRegisteredTestNames(\n    const char* file, int line, const char* registered_tests)",
          "fn_dec_pos": [
            [
              59,
              12
            ],
            [
              60,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TypedTestCasePState::VerifyRegisteredTestNames",
            "parameters": {
              "file": "char",
              "line": "int",
              "registered_tests": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"gtest/gtest-typed-test.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"gtest/gtest.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/third_party/googletest/src/src/gtest-death-test.cc": {
      "fn_def_list": [
        {
          "fn_code": "template <typename Str>\n  void AddArguments(const ::std::vector<Str>& arguments) {\n    for (typename ::std::vector<Str>::const_iterator i = arguments.begin();\n         i != arguments.end();\n         ++i) {\n      args_.insert(args_.end() - 1, posix::StrDup(i->c_str()));\n    }\n  }",
          "fn_code_pos": [
            [
              850,
              2
            ],
            [
              857,
              3
            ]
          ],
          "class_code": "d47e4dfa1fb42e8ca84414b9d0807d7f433ff7c828e114674fb779808a4fa782",
          "class_node_pos": [
            [
              834,
              0
            ],
            [
              868,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename Str>\n  void AddArguments(const ::std::vector<Str>& arguments) {\n    for (typename ::std::vector<Str>::const_iterator i = arguments.begin();\n         i != arguments.end();\n         ++i) {\n      args_.insert(args_.end() - 1, posix::StrDup(i->c_str()));\n    }\n  }",
          "fn_code_pos": [
            [
              1131,
              2
            ],
            [
              1138,
              3
            ]
          ],
          "class_code": "fa06c4ecdbff6b8af176b8f2000cf4977657d6a2db67ab7fca40358d0db2ed86",
          "class_node_pos": [
            [
              1115,
              0
            ],
            [
              1145,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "bool InDeathTestChild() {\n# if GTEST_OS_WINDOWS || GTEST_OS_FUCHSIA\n\n  // On Windows and Fuchsia, death tests are thread-safe regardless of the value\n  // of the death_test_style flag.\n  return !GTEST_FLAG(internal_run_death_test).empty();\n\n# else\n\n  if (GTEST_FLAG(death_test_style) == \"threadsafe\")\n    return !GTEST_FLAG(internal_run_death_test).empty();\n  else\n    return g_in_fast_death_test_child;\n#endif\n}",
          "fn_code_pos": [
            [
              135,
              0
            ],
            [
              149,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "InDeathTestChild",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "ExitedWithCode::ExitedWithCode(int exit_code) : exit_code_(exit_code) {\n}",
          "fn_code_pos": [
            [
              154,
              0
            ],
            [
              155,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExitedWithCode::ExitedWithCode",
            "parameters": {
              "exit_code": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "bool ExitedWithCode::operator()(int exit_status) const {\n# if GTEST_OS_WINDOWS || GTEST_OS_FUCHSIA\n\n  return exit_status == exit_code_;\n\n# else\n\n  return WIFEXITED(exit_status) && WEXITSTATUS(exit_status) == exit_code_;\n\n# endif  // GTEST_OS_WINDOWS || GTEST_OS_FUCHSIA\n}",
          "fn_code_pos": [
            [
              158,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExitedWithCode::operator()",
            "parameters": {
              "exit_status": "int"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "KilledBySignal::KilledBySignal(int signum) : signum_(signum) {\n}",
          "fn_code_pos": [
            [
              172,
              0
            ],
            [
              173,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "KilledBySignal::KilledBySignal",
            "parameters": {
              "signum": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "bool KilledBySignal::operator()(int exit_status) const {\n#  if defined(GTEST_KILLED_BY_SIGNAL_OVERRIDE_)\n  {\n    bool result;\n    if (GTEST_KILLED_BY_SIGNAL_OVERRIDE_(signum_, exit_status, &result)) {\n      return result;\n    }\n  }\n#  endif  // defined(GTEST_KILLED_BY_SIGNAL_OVERRIDE_)\n  return WIFSIGNALED(exit_status) && WTERMSIG(exit_status) == signum_;\n}",
          "fn_code_pos": [
            [
              176,
              0
            ],
            [
              186,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "KilledBySignal::operator()",
            "parameters": {
              "exit_status": "int"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "static std::string ExitSummary(int exit_code) {\n  Message m;\n\n# if GTEST_OS_WINDOWS || GTEST_OS_FUCHSIA\n\n  m << \"Exited with exit status \" << exit_code;\n\n# else\n\n  if (WIFEXITED(exit_code)) {\n    m << \"Exited with exit status \" << WEXITSTATUS(exit_code);\n  } else if (WIFSIGNALED(exit_code)) {\n    m << \"Terminated by signal \" << WTERMSIG(exit_code);\n  }\n#  ifdef WCOREDUMP\n  if (WCOREDUMP(exit_code)) {\n    m << \" (core dumped)\";\n  }\n#  endif\n# endif  // GTEST_OS_WINDOWS || GTEST_OS_FUCHSIA\n\n  return m.GetString();\n}",
          "fn_code_pos": [
            [
              195,
              0
            ],
            [
              217,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExitSummary",
            "parameters": {
              "exit_code": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "bool ExitedUnsuccessfully(int exit_status) {\n  return !ExitedWithCode(0)(exit_status);\n}",
          "fn_code_pos": [
            [
              221,
              0
            ],
            [
              223,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExitedUnsuccessfully",
            "parameters": {
              "exit_status": "int"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "static std::string DeathTestThreadWarning(size_t thread_count) {\n  Message msg;\n  msg << \"Death tests use fork(), which is unsafe particularly\"\n      << \" in a threaded context. For this test, \" << GTEST_NAME_ << \" \";\n  if (thread_count == 0) {\n    msg << \"couldn't detect the number of threads.\";\n  } else {\n    msg << \"detected \" << thread_count << \" threads.\";\n  }\n  msg << \" See \"\n         \"https://github.com/google/googletest/blob/master/googletest/docs/\"\n         \"advanced.md#death-tests-and-threads\"\n      << \" for more explanation and suggested solutions, especially if\"\n      << \" this is the last message you see before your test times out.\";\n  return msg.GetString();\n}",
          "fn_code_pos": [
            [
              230,
              0
            ],
            [
              245,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DeathTestThreadWarning",
            "parameters": {
              "thread_count": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void DeathTestAbort(const std::string& message) {\n  // On a POSIX system, this function may be called from a threadsafe-style\n  // death test child process, which operates on a very small stack.  Use\n  // the heap for any additional non-minuscule memory requirements.\n  const InternalRunDeathTestFlag* const flag =\n      GetUnitTestImpl()->internal_run_death_test_flag();\n  if (flag != NULL) {\n    FILE* parent = posix::FDOpen(flag->write_fd(), \"w\");\n    fputc(kDeathTestInternalError, parent);\n    fprintf(parent, \"%s\", message.c_str());\n    fflush(parent);\n    _exit(1);\n  } else {\n    fprintf(stderr, \"%s\", message.c_str());\n    fflush(stderr);\n    posix::Abort();\n  }\n}",
          "fn_code_pos": [
            [
              277,
              0
            ],
            [
              294,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DeathTestAbort",
            "parameters": {
              "message": "std::string"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "std::string GetLastErrnoDescription() {\n    return errno == 0 ? \"\" : posix::StrError(errno);\n}",
          "fn_code_pos": [
            [
              330,
              0
            ],
            [
              332,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetLastErrnoDescription",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static void FailFromInternalError(int fd) {\n  Message error;\n  char buffer[256];\n  int num_read;\n\n  do {\n    while ((num_read = posix::Read(fd, buffer, 255)) > 0) {\n      buffer[num_read] = '\\0';\n      error << buffer;\n    }\n  } while (num_read == -1 && errno == EINTR);\n\n  if (num_read == 0) {\n    GTEST_LOG_(FATAL) << error.GetString();\n  } else {\n    const int last_error = errno;\n    GTEST_LOG_(FATAL) << \"Error while reading death test internal: \"\n                      << GetLastErrnoDescription() << \" [\" << last_error << \"]\";\n  }\n}",
          "fn_code_pos": [
            [
              338,
              0
            ],
            [
              357,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FailFromInternalError",
            "parameters": {
              "fd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "DeathTest::DeathTest() {\n  TestInfo* const info = GetUnitTestImpl()->current_test_info();\n  if (info == NULL) {\n    DeathTestAbort(\"Cannot run a death test outside of a TEST or \"\n                   \"TEST_F construct\");\n  }\n}",
          "fn_code_pos": [
            [
              361,
              0
            ],
            [
              367,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DeathTest::DeathTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "bool DeathTest::Create(const char* statement, const RE* regex,\n                       const char* file, int line, DeathTest** test) {\n  return GetUnitTestImpl()->death_test_factory()->Create(\n      statement, regex, file, line, test);\n}",
          "fn_code_pos": [
            [
              371,
              0
            ],
            [
              375,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DeathTest::Create",
            "parameters": {
              "statement": "char",
              "regex": "RE",
              "file": "char",
              "line": "int",
              "test": "DeathTest"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "const char* DeathTest::LastMessage() {\n  return last_death_test_message_.c_str();\n}",
          "fn_code_pos": [
            [
              377,
              0
            ],
            [
              379,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DeathTest::LastMessage",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "void DeathTest::set_last_death_test_message(const std::string& message) {\n  last_death_test_message_ = message;\n}",
          "fn_code_pos": [
            [
              381,
              0
            ],
            [
              383,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DeathTest::set_last_death_test_message",
            "parameters": {
              "message": "std::string"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "DeathTestImpl(const char* a_statement, const RE* a_regex)\n      : statement_(a_statement),\n        regex_(a_regex),\n        spawned_(false),\n        status_(-1),\n        outcome_(IN_PROGRESS),\n        read_fd_(-1),\n        write_fd_(-1) {}",
          "fn_code_pos": [
            [
              390,
              2
            ],
            [
              397,
              24
            ]
          ],
          "class_code": "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24",
          "class_node_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DeathTestImpl",
            "parameters": {
              "a_statement": "char",
              "a_regex": "RE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~DeathTestImpl() { GTEST_DEATH_TEST_CHECK_(read_fd_ == -1); }",
          "fn_code_pos": [
            [
              400,
              2
            ],
            [
              400,
              63
            ]
          ],
          "class_code": "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24",
          "class_node_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "const char* statement() const { return statement_; }",
          "fn_code_pos": [
            [
              405,
              2
            ],
            [
              405,
              54
            ]
          ],
          "class_code": "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24",
          "class_node_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "statement",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "const RE* regex() const { return regex_; }",
          "fn_code_pos": [
            [
              406,
              2
            ],
            [
              406,
              44
            ]
          ],
          "class_code": "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24",
          "class_node_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "regex",
            "parameters": {},
            "return_type": "RE"
          }
        },
        {
          "fn_code": "bool spawned() const { return spawned_; }",
          "fn_code_pos": [
            [
              407,
              2
            ],
            [
              407,
              43
            ]
          ],
          "class_code": "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24",
          "class_node_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "spawned",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "void set_spawned(bool is_spawned) { spawned_ = is_spawned; }",
          "fn_code_pos": [
            [
              408,
              2
            ],
            [
              408,
              62
            ]
          ],
          "class_code": "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24",
          "class_node_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "set_spawned",
            "parameters": {
              "is_spawned": "bool"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int status() const { return status_; }",
          "fn_code_pos": [
            [
              409,
              2
            ],
            [
              409,
              40
            ]
          ],
          "class_code": "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24",
          "class_node_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "status",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "void set_status(int a_status) { status_ = a_status; }",
          "fn_code_pos": [
            [
              410,
              2
            ],
            [
              410,
              55
            ]
          ],
          "class_code": "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24",
          "class_node_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "set_status",
            "parameters": {
              "a_status": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "DeathTestOutcome outcome() const { return outcome_; }",
          "fn_code_pos": [
            [
              411,
              2
            ],
            [
              411,
              55
            ]
          ],
          "class_code": "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24",
          "class_node_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "outcome",
            "parameters": {},
            "return_type": "DeathTestOutcome"
          }
        },
        {
          "fn_code": "void set_outcome(DeathTestOutcome an_outcome) { outcome_ = an_outcome; }",
          "fn_code_pos": [
            [
              412,
              2
            ],
            [
              412,
              74
            ]
          ],
          "class_code": "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24",
          "class_node_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "set_outcome",
            "parameters": {
              "an_outcome": "DeathTestOutcome"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int read_fd() const { return read_fd_; }",
          "fn_code_pos": [
            [
              413,
              2
            ],
            [
              413,
              42
            ]
          ],
          "class_code": "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24",
          "class_node_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "read_fd",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "void set_read_fd(int fd) { read_fd_ = fd; }",
          "fn_code_pos": [
            [
              414,
              2
            ],
            [
              414,
              45
            ]
          ],
          "class_code": "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24",
          "class_node_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "set_read_fd",
            "parameters": {
              "fd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int write_fd() const { return write_fd_; }",
          "fn_code_pos": [
            [
              415,
              2
            ],
            [
              415,
              44
            ]
          ],
          "class_code": "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24",
          "class_node_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "write_fd",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "void set_write_fd(int fd) { write_fd_ = fd; }",
          "fn_code_pos": [
            [
              416,
              2
            ],
            [
              416,
              47
            ]
          ],
          "class_code": "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24",
          "class_node_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "set_write_fd",
            "parameters": {
              "fd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void DeathTestImpl::ReadAndInterpretStatusByte() {\n  char flag;\n  int bytes_read;\n\n  // The read() here blocks until data is available (signifying the\n  // failure of the death test) or until the pipe is closed (signifying\n  // its success), so it's okay to call this in the parent before\n  // the child process has exited.\n  do {\n    bytes_read = posix::Read(read_fd(), &flag, 1);\n  } while (bytes_read == -1 && errno == EINTR);\n\n  if (bytes_read == 0) {\n    set_outcome(DIED);\n  } else if (bytes_read == 1) {\n    switch (flag) {\n      case kDeathTestReturned:\n        set_outcome(RETURNED);\n        break;\n      case kDeathTestThrew:\n        set_outcome(THREW);\n        break;\n      case kDeathTestLived:\n        set_outcome(LIVED);\n        break;\n      case kDeathTestInternalError:\n        FailFromInternalError(read_fd());  // Does not return.\n        break;\n      default:\n        GTEST_LOG_(FATAL) << \"Death test child process reported \"\n                          << \"unexpected status byte (\"\n                          << static_cast<unsigned int>(flag) << \")\";\n    }\n  } else {\n    GTEST_LOG_(FATAL) << \"Read from death test child process failed: \"\n                      << GetLastErrnoDescription();\n  }\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(posix::Close(read_fd()));\n  set_read_fd(-1);\n}",
          "fn_code_pos": [
            [
              451,
              0
            ],
            [
              490,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DeathTestImpl::ReadAndInterpretStatusByte",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void DeathTestImpl::Abort(AbortReason reason) {\n  // The parent process considers the death test to be a failure if\n  // it finds any data in our pipe.  So, here we write a single flag byte\n  // to the pipe, then exit.\n  const char status_ch =\n      reason == TEST_DID_NOT_DIE ? kDeathTestLived :\n      reason == TEST_THREW_EXCEPTION ? kDeathTestThrew : kDeathTestReturned;\n\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(posix::Write(write_fd(), &status_ch, 1));\n  // We are leaking the descriptor here because on some platforms (i.e.,\n  // when built as Windows DLL), destructors of global objects will still\n  // run after calling _exit(). On such systems, write_fd_ will be\n  // indirectly closed from the destructor of UnitTestImpl, causing double\n  // close if it is also closed here. On debug configurations, double close\n  // may assert. As there are no in-process buffers to flush here, we are\n  // relying on the OS to close the descriptor after the process terminates\n  // when the destructors are not run.\n  _exit(1);  // Exits w/o any normal exit hooks (we were supposed to crash)\n}",
          "fn_code_pos": [
            [
              496,
              0
            ],
            [
              514,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DeathTestImpl::Abort",
            "parameters": {
              "reason": "AbortReason"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static ::std::string FormatDeathTestOutput(const ::std::string& output) {\n  ::std::string ret;\n  for (size_t at = 0; ; ) {\n    const size_t line_end = output.find('\\n', at);\n    ret += \"[  DEATH   ] \";\n    if (line_end == ::std::string::npos) {\n      ret += output.substr(at);\n      break;\n    }\n    ret += output.substr(at, line_end + 1 - at);\n    at = line_end + 1;\n  }\n  return ret;\n}",
          "fn_code_pos": [
            [
              519,
              0
            ],
            [
              532,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FormatDeathTestOutput",
            "parameters": {
              "output": "::std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "bool DeathTestImpl::Passed(bool status_ok) {\n  if (!spawned())\n    return false;\n\n  const std::string error_message = GetCapturedStderr();\n\n  bool success = false;\n  Message buffer;\n\n  buffer << \"Death test: \" << statement() << \"\\n\";\n  switch (outcome()) {\n    case LIVED:\n      buffer << \"    Result: failed to die.\\n\"\n             << \" Error msg:\\n\" << FormatDeathTestOutput(error_message);\n      break;\n    case THREW:\n      buffer << \"    Result: threw an exception.\\n\"\n             << \" Error msg:\\n\" << FormatDeathTestOutput(error_message);\n      break;\n    case RETURNED:\n      buffer << \"    Result: illegal return in test statement.\\n\"\n             << \" Error msg:\\n\" << FormatDeathTestOutput(error_message);\n      break;\n    case DIED:\n      if (status_ok) {\n# if GTEST_USES_PCRE\n        // PCRE regexes support embedded NULs.\n        const bool matched = RE::PartialMatch(error_message, *regex());\n# else\n        const bool matched = RE::PartialMatch(error_message.c_str(), *regex());\n# endif  // GTEST_USES_PCRE\n        if (matched) {\n          success = true;\n        } else {\n          buffer << \"    Result: died but not with expected error.\\n\"\n                 << \"  Expected: \" << regex()->pattern() << \"\\n\"\n                 << \"Actual msg:\\n\" << FormatDeathTestOutput(error_message);\n        }\n      } else {\n        buffer << \"    Result: died but not with expected exit code:\\n\"\n               << \"            \" << ExitSummary(status()) << \"\\n\"\n               << \"Actual msg:\\n\" << FormatDeathTestOutput(error_message);\n      }\n      break;\n    case IN_PROGRESS:\n    default:\n      GTEST_LOG_(FATAL)\n          << \"DeathTest::Passed somehow called before conclusion of test\";\n  }\n\n  DeathTest::set_last_death_test_message(buffer.GetString());\n  return success;\n}",
          "fn_code_pos": [
            [
              556,
              0
            ],
            [
              608,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DeathTestImpl::Passed",
            "parameters": {
              "status_ok": "bool"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "WindowsDeathTest(const char* a_statement,\n                   const RE* a_regex,\n                   const char* file,\n                   int line)\n      : DeathTestImpl(a_statement, a_regex), file_(file), line_(line) {}",
          "fn_code_pos": [
            [
              641,
              2
            ],
            [
              645,
              72
            ]
          ],
          "class_code": "0db24722bd77fb25e81679adebfd7ad5127164439b20d6488140de1364a75331",
          "class_node_pos": [
            [
              639,
              0
            ],
            [
              665,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "WindowsDeathTest",
            "parameters": {
              "a_statement": "char",
              "a_regex": "RE",
              "file": "char",
              "line": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "int WindowsDeathTest::Wait() {\n  if (!spawned())\n    return 0;\n\n  // Wait until the child either signals that it has acquired the write end\n  // of the pipe or it dies.\n  const HANDLE wait_handles[2] = { child_handle_.Get(), event_handle_.Get() };\n  switch (::WaitForMultipleObjects(2,\n                                   wait_handles,\n                                   FALSE,  // Waits for any of the handles.\n                                   INFINITE)) {\n    case WAIT_OBJECT_0:\n    case WAIT_OBJECT_0 + 1:\n      break;\n    default:\n      GTEST_DEATH_TEST_CHECK_(false);  // Should not get here.\n  }\n\n  // The child has acquired the write end of the pipe or exited.\n  // We release the handle on our side and continue.\n  write_handle_.Reset();\n  event_handle_.Reset();\n\n  ReadAndInterpretStatusByte();\n\n  // Waits for the child process to exit if it haven't already. This\n  // returns immediately if the child has already exited, regardless of\n  // whether previous calls to WaitForMultipleObjects synchronized on this\n  // handle or not.\n  GTEST_DEATH_TEST_CHECK_(\n      WAIT_OBJECT_0 == ::WaitForSingleObject(child_handle_.Get(),\n                                             INFINITE));\n  DWORD status_code;\n  GTEST_DEATH_TEST_CHECK_(\n      ::GetExitCodeProcess(child_handle_.Get(), &status_code) != FALSE);\n  child_handle_.Reset();\n  set_status(static_cast<int>(status_code));\n  return status();\n}",
          "fn_code_pos": [
            [
              670,
              0
            ],
            [
              708,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WindowsDeathTest::Wait",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "DeathTest::TestRole WindowsDeathTest::AssumeRole() {\n  const UnitTestImpl* const impl = GetUnitTestImpl();\n  const InternalRunDeathTestFlag* const flag =\n      impl->internal_run_death_test_flag();\n  const TestInfo* const info = impl->current_test_info();\n  const int death_test_index = info->result()->death_test_count();\n\n  if (flag != NULL) {\n    // ParseInternalRunDeathTestFlag() has performed all the necessary\n    // processing.\n    set_write_fd(flag->write_fd());\n    return EXECUTE_TEST;\n  }\n\n  // WindowsDeathTest uses an anonymous pipe to communicate results of\n  // a death test.\n  SECURITY_ATTRIBUTES handles_are_inheritable = {\n    sizeof(SECURITY_ATTRIBUTES), NULL, TRUE };\n  HANDLE read_handle, write_handle;\n  GTEST_DEATH_TEST_CHECK_(\n      ::CreatePipe(&read_handle, &write_handle, &handles_are_inheritable,\n                   0)  // Default buffer size.\n      != FALSE);\n  set_read_fd(::_open_osfhandle(reinterpret_cast<intptr_t>(read_handle),\n                                O_RDONLY));\n  write_handle_.Reset(write_handle);\n  event_handle_.Reset(::CreateEvent(\n      &handles_are_inheritable,\n      TRUE,    // The event will automatically reset to non-signaled state.\n      FALSE,   // The initial state is non-signalled.\n      NULL));  // The even is unnamed.\n  GTEST_DEATH_TEST_CHECK_(event_handle_.Get() != NULL);\n  const std::string filter_flag =\n      std::string(\"--\") + GTEST_FLAG_PREFIX_ + kFilterFlag + \"=\" +\n      info->test_case_name() + \".\" + info->name();\n  const std::string internal_flag =\n      std::string(\"--\") + GTEST_FLAG_PREFIX_ + kInternalRunDeathTestFlag +\n      \"=\" + file_ + \"|\" + StreamableToString(line_) + \"|\" +\n      StreamableToString(death_test_index) + \"|\" +\n      StreamableToString(static_cast<unsigned int>(::GetCurrentProcessId())) +\n      // size_t has the same width as pointers on both 32-bit and 64-bit\n      // Windows platforms.\n      // See http://msdn.microsoft.com/en-us/library/tcxf1dw6.aspx.\n      \"|\" + StreamableToString(reinterpret_cast<size_t>(write_handle)) +\n      \"|\" + StreamableToString(reinterpret_cast<size_t>(event_handle_.Get()));\n\n  char executable_path[_MAX_PATH + 1];  // NOLINT\n  GTEST_DEATH_TEST_CHECK_(\n      _MAX_PATH + 1 != ::GetModuleFileNameA(NULL,\n                                            executable_path,\n                                            _MAX_PATH));\n\n  std::string command_line =\n      std::string(::GetCommandLineA()) + \" \" + filter_flag + \" \\\"\" +\n      internal_flag + \"\\\"\";\n\n  DeathTest::set_last_death_test_message(\"\");\n\n  CaptureStderr();\n  // Flush the log buffers since the log streams are shared with the child.\n  FlushInfoLog();\n\n  // The child process will share the standard handles with the parent.\n  STARTUPINFOA startup_info;\n  memset(&startup_info, 0, sizeof(STARTUPINFO));\n  startup_info.dwFlags = STARTF_USESTDHANDLES;\n  startup_info.hStdInput = ::GetStdHandle(STD_INPUT_HANDLE);\n  startup_info.hStdOutput = ::GetStdHandle(STD_OUTPUT_HANDLE);\n  startup_info.hStdError = ::GetStdHandle(STD_ERROR_HANDLE);\n\n  PROCESS_INFORMATION process_info;\n  GTEST_DEATH_TEST_CHECK_(::CreateProcessA(\n      executable_path,\n      const_cast<char*>(command_line.c_str()),\n      NULL,   // Retuned process handle is not inheritable.\n      NULL,   // Retuned thread handle is not inheritable.\n      TRUE,   // Child inherits all inheritable handles (for write_handle_).\n      0x0,    // Default creation flags.\n      NULL,   // Inherit the parent's environment.\n      UnitTest::GetInstance()->original_working_dir(),\n      &startup_info,\n      &process_info) != FALSE);\n  child_handle_.Reset(process_info.hProcess);\n  ::CloseHandle(process_info.hThread);\n  set_spawned(true);\n  return OVERSEE_TEST;\n}",
          "fn_code_pos": [
            [
              715,
              0
            ],
            [
              801,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WindowsDeathTest::AssumeRole",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "FuchsiaDeathTest(const char* a_statement,\n                   const RE* a_regex,\n                   const char* file,\n                   int line)\n      : DeathTestImpl(a_statement, a_regex), file_(file), line_(line) {}",
          "fn_code_pos": [
            [
              807,
              2
            ],
            [
              811,
              72
            ]
          ],
          "class_code": "f421bdddf728b79204304fb7c0a0c0e0d03cb11fa13c4af3314c45f3eceeffba",
          "class_node_pos": [
            [
              805,
              0
            ],
            [
              831,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FuchsiaDeathTest",
            "parameters": {
              "a_statement": "char",
              "a_regex": "RE",
              "file": "char",
              "line": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~FuchsiaDeathTest() {\n    zx_status_t status = zx_handle_close(child_process_);\n    GTEST_DEATH_TEST_CHECK_(status == ZX_OK);\n    status = zx_handle_close(port_);\n    GTEST_DEATH_TEST_CHECK_(status == ZX_OK);\n  }",
          "fn_code_pos": [
            [
              812,
              2
            ],
            [
              817,
              3
            ]
          ],
          "class_code": "f421bdddf728b79204304fb7c0a0c0e0d03cb11fa13c4af3314c45f3eceeffba",
          "class_node_pos": [
            [
              805,
              0
            ],
            [
              831,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "Arguments() {\n    args_.push_back(NULL);\n  }",
          "fn_code_pos": [
            [
              836,
              2
            ],
            [
              838,
              3
            ]
          ],
          "class_code": "d47e4dfa1fb42e8ca84414b9d0807d7f433ff7c828e114674fb779808a4fa782",
          "class_node_pos": [
            [
              834,
              0
            ],
            [
              868,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Arguments",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~Arguments() {\n    for (std::vector<char*>::iterator i = args_.begin(); i != args_.end();\n         ++i) {\n      free(*i);\n    }\n  }",
          "fn_code_pos": [
            [
              840,
              2
            ],
            [
              845,
              3
            ]
          ],
          "class_code": "d47e4dfa1fb42e8ca84414b9d0807d7f433ff7c828e114674fb779808a4fa782",
          "class_node_pos": [
            [
              834,
              0
            ],
            [
              868,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void AddArgument(const char* argument) {\n    args_.insert(args_.end() - 1, posix::StrDup(argument));\n  }",
          "fn_code_pos": [
            [
              846,
              2
            ],
            [
              848,
              3
            ]
          ],
          "class_code": "d47e4dfa1fb42e8ca84414b9d0807d7f433ff7c828e114674fb779808a4fa782",
          "class_node_pos": [
            [
              834,
              0
            ],
            [
              868,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "AddArgument",
            "parameters": {
              "argument": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "char* const* Argv() {\n    return &args_[0];\n  }",
          "fn_code_pos": [
            [
              858,
              2
            ],
            [
              860,
              3
            ]
          ],
          "class_code": "d47e4dfa1fb42e8ca84414b9d0807d7f433ff7c828e114674fb779808a4fa782",
          "class_node_pos": [
            [
              834,
              0
            ],
            [
              868,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "int size() {\n    return args_.size() - 1;\n  }",
          "fn_code_pos": [
            [
              862,
              2
            ],
            [
              864,
              3
            ]
          ],
          "class_code": "d47e4dfa1fb42e8ca84414b9d0807d7f433ff7c828e114674fb779808a4fa782",
          "class_node_pos": [
            [
              834,
              0
            ],
            [
              868,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "size",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int FuchsiaDeathTest::Wait() {\n  if (!spawned())\n    return 0;\n\n  // Register to wait for the child process to terminate.\n  zx_status_t status_zx;\n  status_zx = zx_object_wait_async(child_process_,\n                                   port_,\n                                   0 /* key */,\n                                   ZX_PROCESS_TERMINATED,\n                                   ZX_WAIT_ASYNC_ONCE);\n  GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n\n  // Wait for it to terminate, or an exception to be received.\n  zx_port_packet_t packet;\n  status_zx = zx_port_wait(port_, ZX_TIME_INFINITE, &packet);\n  GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n\n  if (ZX_PKT_IS_EXCEPTION(packet.type)) {\n    // Process encountered an exception. Kill it directly rather than letting\n    // other handlers process the event.\n    status_zx = zx_task_kill(child_process_);\n    GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n\n    // Now wait for |child_process_| to terminate.\n    zx_signals_t signals = 0;\n    status_zx = zx_object_wait_one(\n        child_process_, ZX_PROCESS_TERMINATED, ZX_TIME_INFINITE, &signals);\n    GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n    GTEST_DEATH_TEST_CHECK_(signals & ZX_PROCESS_TERMINATED);\n  } else {\n    // Process terminated.\n    GTEST_DEATH_TEST_CHECK_(ZX_PKT_IS_SIGNAL_ONE(packet.type));\n    GTEST_DEATH_TEST_CHECK_(packet.signal.observed & ZX_PROCESS_TERMINATED);\n  }\n\n  ReadAndInterpretStatusByte();\n\n  zx_info_process_t buffer;\n  status_zx = zx_object_get_info(\n      child_process_,\n      ZX_INFO_PROCESS,\n      &buffer,\n      sizeof(buffer),\n      nullptr,\n      nullptr);\n  GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n\n  GTEST_DEATH_TEST_CHECK_(buffer.exited);\n  set_status(buffer.return_code);\n  return status();\n}",
          "fn_code_pos": [
            [
              873,
              0
            ],
            [
              924,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FuchsiaDeathTest::Wait",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "DeathTest::TestRole FuchsiaDeathTest::AssumeRole() {\n  const UnitTestImpl* const impl = GetUnitTestImpl();\n  const InternalRunDeathTestFlag* const flag =\n      impl->internal_run_death_test_flag();\n  const TestInfo* const info = impl->current_test_info();\n  const int death_test_index = info->result()->death_test_count();\n\n  if (flag != NULL) {\n    // ParseInternalRunDeathTestFlag() has performed all the necessary\n    // processing.\n    set_write_fd(kFuchsiaReadPipeFd);\n    return EXECUTE_TEST;\n  }\n\n  CaptureStderr();\n  // Flush the log buffers since the log streams are shared with the child.\n  FlushInfoLog();\n\n  // Build the child process command line.\n  const std::string filter_flag =\n      std::string(\"--\") + GTEST_FLAG_PREFIX_ + kFilterFlag + \"=\"\n      + info->test_case_name() + \".\" + info->name();\n  const std::string internal_flag =\n      std::string(\"--\") + GTEST_FLAG_PREFIX_ + kInternalRunDeathTestFlag + \"=\"\n      + file_ + \"|\"\n      + StreamableToString(line_) + \"|\"\n      + StreamableToString(death_test_index);\n  Arguments args;\n  args.AddArguments(GetInjectableArgvs());\n  args.AddArgument(filter_flag.c_str());\n  args.AddArgument(internal_flag.c_str());\n\n  // Build the pipe for communication with the child.\n  zx_status_t status;\n  zx_handle_t child_pipe_handle;\n  uint32_t type;\n  status = fdio_pipe_half(&child_pipe_handle, &type);\n  GTEST_DEATH_TEST_CHECK_(status >= 0);\n  set_read_fd(status);\n\n  // Set the pipe handle for the child.\n  fdio_spawn_action_t add_handle_action = {};\n  add_handle_action.action = FDIO_SPAWN_ACTION_ADD_HANDLE;\n  add_handle_action.h.id = PA_HND(type, kFuchsiaReadPipeFd);\n  add_handle_action.h.handle = child_pipe_handle;\n\n  // Spawn the child process.\n  status = fdio_spawn_etc(ZX_HANDLE_INVALID, FDIO_SPAWN_CLONE_ALL,\n                          args.Argv()[0], args.Argv(), nullptr, 1,\n                          &add_handle_action, &child_process_, nullptr);\n  GTEST_DEATH_TEST_CHECK_(status == ZX_OK);\n\n  // Create an exception port and attach it to the |child_process_|, to allow\n  // us to suppress the system default exception handler from firing.\n  status = zx_port_create(0, &port_);\n  GTEST_DEATH_TEST_CHECK_(status == ZX_OK);\n  status = zx_task_bind_exception_port(\n      child_process_, port_, 0 /* key */, 0 /*options */);\n  GTEST_DEATH_TEST_CHECK_(status == ZX_OK);\n\n  set_spawned(true);\n  return OVERSEE_TEST;\n}",
          "fn_code_pos": [
            [
              931,
              0
            ],
            [
              993,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FuchsiaDeathTest::AssumeRole",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void set_child_pid(pid_t child_pid) { child_pid_ = child_pid; }",
          "fn_code_pos": [
            [
              1008,
              2
            ],
            [
              1008,
              65
            ]
          ],
          "class_code": "21d341af17cec2f7a47203e558381d1b66f4286e308d2e63f95684551cd293e2",
          "class_node_pos": [
            [
              1000,
              0
            ],
            [
              1013,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "set_child_pid",
            "parameters": {
              "child_pid": "pid_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ForkingDeathTest::ForkingDeathTest(const char* a_statement, const RE* a_regex)\n    : DeathTestImpl(a_statement, a_regex),\n      child_pid_(-1) {}",
          "fn_code_pos": [
            [
              1016,
              0
            ],
            [
              1018,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ForkingDeathTest::ForkingDeathTest",
            "parameters": {
              "a_statement": "char",
              "a_regex": "RE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "int ForkingDeathTest::Wait() {\n  if (!spawned())\n    return 0;\n\n  ReadAndInterpretStatusByte();\n\n  int status_value;\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(waitpid(child_pid_, &status_value, 0));\n  set_status(status_value);\n  return status_value;\n}",
          "fn_code_pos": [
            [
              1023,
              0
            ],
            [
              1033,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ForkingDeathTest::Wait",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "NoExecDeathTest(const char* a_statement, const RE* a_regex) :\n      ForkingDeathTest(a_statement, a_regex) { }",
          "fn_code_pos": [
            [
              1039,
              2
            ],
            [
              1040,
              48
            ]
          ],
          "class_code": "733a08c643ca2cc0ad5982d980a4a3749e4296d2cf013e6c5928470622f63c8a",
          "class_node_pos": [
            [
              1037,
              0
            ],
            [
              1042,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "NoExecDeathTest",
            "parameters": {
              "a_statement": "char",
              "a_regex": "RE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "DeathTest::TestRole NoExecDeathTest::AssumeRole() {\n  const size_t thread_count = GetThreadCount();\n  if (thread_count != 1) {\n    GTEST_LOG_(WARNING) << DeathTestThreadWarning(thread_count);\n  }\n\n  int pipe_fd[2];\n  GTEST_DEATH_TEST_CHECK_(pipe(pipe_fd) != -1);\n\n  DeathTest::set_last_death_test_message(\"\");\n  CaptureStderr();\n  // When we fork the process below, the log file buffers are copied, but the\n  // file descriptors are shared.  We flush all log files here so that closing\n  // the file descriptors in the child process doesn't throw off the\n  // synchronization between descriptors and buffers in the parent process.\n  // This is as close to the fork as possible to avoid a race condition in case\n  // there are multiple threads running before the death test, and another\n  // thread writes to the log file.\n  FlushInfoLog();\n\n  const pid_t child_pid = fork();\n  GTEST_DEATH_TEST_CHECK_(child_pid != -1);\n  set_child_pid(child_pid);\n  if (child_pid == 0) {\n    GTEST_DEATH_TEST_CHECK_SYSCALL_(close(pipe_fd[0]));\n    set_write_fd(pipe_fd[1]);\n    // Redirects all logging to stderr in the child process to prevent\n    // concurrent writes to the log files.  We capture stderr in the parent\n    // process and append the child process' output to a log.\n    LogToStderr();\n    // Event forwarding to the listeners of event listener API mush be shut\n    // down in death test subprocesses.\n    GetUnitTestImpl()->listeners()->SuppressEventForwarding();\n    g_in_fast_death_test_child = true;\n    return EXECUTE_TEST;\n  } else {\n    GTEST_DEATH_TEST_CHECK_SYSCALL_(close(pipe_fd[1]));\n    set_read_fd(pipe_fd[0]);\n    set_spawned(true);\n    return OVERSEE_TEST;\n  }\n}",
          "fn_code_pos": [
            [
              1046,
              0
            ],
            [
              1087,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NoExecDeathTest::AssumeRole",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ExecDeathTest(const char* a_statement, const RE* a_regex,\n                const char* file, int line) :\n      ForkingDeathTest(a_statement, a_regex), file_(file), line_(line) { }",
          "fn_code_pos": [
            [
              1094,
              2
            ],
            [
              1096,
              74
            ]
          ],
          "class_code": "715caa6e94a14abe4ca0faec4ef553c6c2a24514ed6ac7b0c32184a4033c8268",
          "class_node_pos": [
            [
              1092,
              0
            ],
            [
              1112,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ExecDeathTest",
            "parameters": {
              "a_statement": "char",
              "a_regex": "RE",
              "file": "char",
              "line": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static ::std::vector<std::string> GetArgvsForDeathTestChildProcess() {\n    ::std::vector<std::string> args = GetInjectableArgvs();\n#  if defined(GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_)\n    ::std::vector<std::string> extra_args =\n        GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_();\n    args.insert(args.end(), extra_args.begin(), extra_args.end());\n#  endif  // defined(GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_)\n    return args;\n  }",
          "fn_code_pos": [
            [
              1099,
              2
            ],
            [
              1107,
              3
            ]
          ],
          "class_code": "715caa6e94a14abe4ca0faec4ef553c6c2a24514ed6ac7b0c32184a4033c8268",
          "class_node_pos": [
            [
              1092,
              0
            ],
            [
              1112,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetArgvsForDeathTestChildProcess",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "Arguments() {\n    args_.push_back(NULL);\n  }",
          "fn_code_pos": [
            [
              1117,
              2
            ],
            [
              1119,
              3
            ]
          ],
          "class_code": "fa06c4ecdbff6b8af176b8f2000cf4977657d6a2db67ab7fca40358d0db2ed86",
          "class_node_pos": [
            [
              1115,
              0
            ],
            [
              1145,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Arguments",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~Arguments() {\n    for (std::vector<char*>::iterator i = args_.begin(); i != args_.end();\n         ++i) {\n      free(*i);\n    }\n  }",
          "fn_code_pos": [
            [
              1121,
              2
            ],
            [
              1126,
              3
            ]
          ],
          "class_code": "fa06c4ecdbff6b8af176b8f2000cf4977657d6a2db67ab7fca40358d0db2ed86",
          "class_node_pos": [
            [
              1115,
              0
            ],
            [
              1145,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void AddArgument(const char* argument) {\n    args_.insert(args_.end() - 1, posix::StrDup(argument));\n  }",
          "fn_code_pos": [
            [
              1127,
              2
            ],
            [
              1129,
              3
            ]
          ],
          "class_code": "fa06c4ecdbff6b8af176b8f2000cf4977657d6a2db67ab7fca40358d0db2ed86",
          "class_node_pos": [
            [
              1115,
              0
            ],
            [
              1145,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "AddArgument",
            "parameters": {
              "argument": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "char* const* Argv() {\n    return &args_[0];\n  }",
          "fn_code_pos": [
            [
              1139,
              2
            ],
            [
              1141,
              3
            ]
          ],
          "class_code": "fa06c4ecdbff6b8af176b8f2000cf4977657d6a2db67ab7fca40358d0db2ed86",
          "class_node_pos": [
            [
              1115,
              0
            ],
            [
              1145,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "inline char** GetEnviron() {\n  // When Google Test is built as a framework on MacOS X, the environ variable\n  // is unavailable. Apple's documentation (man environ) recommends using\n  // _NSGetEnviron() instead.\n  return *_NSGetEnviron();\n}",
          "fn_code_pos": [
            [
              1155,
              0
            ],
            [
              1160,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "inline char** GetEnviron() { return environ; }",
          "fn_code_pos": [
            [
              1165,
              0
            ],
            [
              1165,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "static int ExecDeathTestChildMain(void* child_arg) {\n  ExecDeathTestArgs* const args = static_cast<ExecDeathTestArgs*>(child_arg);\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(close(args->close_fd));\n\n  // We need to execute the test program in the same environment where\n  // it was originally invoked.  Therefore we change to the original\n  // working directory first.\n  const char* const original_dir =\n      UnitTest::GetInstance()->original_working_dir();\n  // We can safely call chdir() as it's a direct system call.\n  if (chdir(original_dir) != 0) {\n    DeathTestAbort(std::string(\"chdir(\\\"\") + original_dir + \"\\\") failed: \" +\n                   GetLastErrnoDescription());\n    return EXIT_FAILURE;\n  }\n\n  // We can safely call execve() as it's a direct system call.  We\n  // cannot use execvp() as it's a libc function and thus potentially\n  // unsafe.  Since execve() doesn't search the PATH, the user must\n  // invoke the test program via a valid path that contains at least\n  // one path separator.\n  execve(args->argv[0], args->argv, GetEnviron());\n  DeathTestAbort(std::string(\"execve(\") + args->argv[0] + \", ...) in \" +\n                 original_dir + \" failed: \" +\n                 GetLastErrnoDescription());\n  return EXIT_FAILURE;\n}",
          "fn_code_pos": [
            [
              1172,
              0
            ],
            [
              1198,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExecDeathTestChildMain",
            "parameters": {
              "child_arg": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void StackLowerThanAddress(const void* ptr, bool* result) {\n  int dummy;\n  *result = (&dummy < ptr);\n}",
          "fn_code_pos": [
            [
              1213,
              0
            ],
            [
              1216,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "StackLowerThanAddress",
            "parameters": {
              "ptr": "void",
              "result": "bool"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\nstatic bool StackGrowsDown() {\n  int dummy;\n  bool result;\n  StackLowerThanAddress(&dummy, &result);\n  return result;\n}",
          "fn_code_pos": [
            [
              1219,
              0
            ],
            [
              1225,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "StackGrowsDown",
            "parameters": {},
            "return_type": "GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_"
          }
        },
        {
          "fn_code": "static pid_t ExecDeathTestSpawnChild(char* const* argv, int close_fd) {\n  ExecDeathTestArgs args = { argv, close_fd };\n  pid_t child_pid = -1;\n\n#  if GTEST_OS_QNX\n  // Obtains the current directory and sets it to be closed in the child\n  // process.\n  const int cwd_fd = open(\".\", O_RDONLY);\n  GTEST_DEATH_TEST_CHECK_(cwd_fd != -1);\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(fcntl(cwd_fd, F_SETFD, FD_CLOEXEC));\n  // We need to execute the test program in the same environment where\n  // it was originally invoked.  Therefore we change to the original\n  // working directory first.\n  const char* const original_dir =\n      UnitTest::GetInstance()->original_working_dir();\n  // We can safely call chdir() as it's a direct system call.\n  if (chdir(original_dir) != 0) {\n    DeathTestAbort(std::string(\"chdir(\\\"\") + original_dir + \"\\\") failed: \" +\n                   GetLastErrnoDescription());\n    return EXIT_FAILURE;\n  }\n\n  int fd_flags;\n  // Set close_fd to be closed after spawn.\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(fd_flags = fcntl(close_fd, F_GETFD));\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(fcntl(close_fd, F_SETFD,\n                                        fd_flags | FD_CLOEXEC));\n  struct inheritance inherit = {0};\n  // spawn is a system call.\n  child_pid = spawn(args.argv[0], 0, NULL, &inherit, args.argv, GetEnviron());\n  // Restores the current working directory.\n  GTEST_DEATH_TEST_CHECK_(fchdir(cwd_fd) != -1);\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(close(cwd_fd));\n\n#  else   // GTEST_OS_QNX\n#   if GTEST_OS_LINUX\n  // When a SIGPROF signal is received while fork() or clone() are executing,\n  // the process may hang. To avoid this, we ignore SIGPROF here and re-enable\n  // it after the call to fork()/clone() is complete.\n  struct sigaction saved_sigprof_action;\n  struct sigaction ignore_sigprof_action;\n  memset(&ignore_sigprof_action, 0, sizeof(ignore_sigprof_action));\n  sigemptyset(&ignore_sigprof_action.sa_mask);\n  ignore_sigprof_action.sa_handler = SIG_IGN;\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(sigaction(\n      SIGPROF, &ignore_sigprof_action, &saved_sigprof_action));\n#   endif  // GTEST_OS_LINUX\n\n#   if GTEST_HAS_CLONE\n  const bool use_fork = GTEST_FLAG(death_test_use_fork);\n\n  if (!use_fork) {\n    static const bool stack_grows_down = StackGrowsDown();\n    const size_t stack_size = getpagesize();\n    // MMAP_ANONYMOUS is not defined on Mac, so we use MAP_ANON instead.\n    void* const stack = mmap(NULL, stack_size, PROT_READ | PROT_WRITE,\n                             MAP_ANON | MAP_PRIVATE, -1, 0);\n    GTEST_DEATH_TEST_CHECK_(stack != MAP_FAILED);\n\n    // Maximum stack alignment in bytes:  For a downward-growing stack, this\n    // amount is subtracted from size of the stack space to get an address\n    // that is within the stack space and is aligned on all systems we care\n    // about.  As far as I know there is no ABI with stack alignment greater\n    // than 64.  We assume stack and stack_size already have alignment of\n    // kMaxStackAlignment.\n    const size_t kMaxStackAlignment = 64;\n    void* const stack_top =\n        static_cast<char*>(stack) +\n            (stack_grows_down ? stack_size - kMaxStackAlignment : 0);\n    GTEST_DEATH_TEST_CHECK_(stack_size > kMaxStackAlignment &&\n        reinterpret_cast<intptr_t>(stack_top) % kMaxStackAlignment == 0);\n\n    child_pid = clone(&ExecDeathTestChildMain, stack_top, SIGCHLD, &args);\n\n    GTEST_DEATH_TEST_CHECK_(munmap(stack, stack_size) != -1);\n  }\n#   else\n  const bool use_fork = true;\n#   endif  // GTEST_HAS_CLONE\n\n  if (use_fork && (child_pid = fork()) == 0) {\n      ExecDeathTestChildMain(&args);\n      _exit(0);\n  }\n#  endif  // GTEST_OS_QNX\n#  if GTEST_OS_LINUX\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(\n      sigaction(SIGPROF, &saved_sigprof_action, NULL));\n#  endif  // GTEST_OS_LINUX\n\n  GTEST_DEATH_TEST_CHECK_(child_pid != -1);\n  return child_pid;\n}",
          "fn_code_pos": [
            [
              1235,
              0
            ],
            [
              1327,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExecDeathTestSpawnChild",
            "parameters": {
              "argv": "char",
              "close_fd": "int"
            },
            "return_type": "pid_t"
          }
        },
        {
          "fn_code": "DeathTest::TestRole ExecDeathTest::AssumeRole() {\n  const UnitTestImpl* const impl = GetUnitTestImpl();\n  const InternalRunDeathTestFlag* const flag =\n      impl->internal_run_death_test_flag();\n  const TestInfo* const info = impl->current_test_info();\n  const int death_test_index = info->result()->death_test_count();\n\n  if (flag != NULL) {\n    set_write_fd(flag->write_fd());\n    return EXECUTE_TEST;\n  }\n\n  int pipe_fd[2];\n  GTEST_DEATH_TEST_CHECK_(pipe(pipe_fd) != -1);\n  // Clear the close-on-exec flag on the write end of the pipe, lest\n  // it be closed when the child process does an exec:\n  GTEST_DEATH_TEST_CHECK_(fcntl(pipe_fd[1], F_SETFD, 0) != -1);\n\n  const std::string filter_flag =\n      std::string(\"--\") + GTEST_FLAG_PREFIX_ + kFilterFlag + \"=\"\n      + info->test_case_name() + \".\" + info->name();\n  const std::string internal_flag =\n      std::string(\"--\") + GTEST_FLAG_PREFIX_ + kInternalRunDeathTestFlag + \"=\"\n      + file_ + \"|\" + StreamableToString(line_) + \"|\"\n      + StreamableToString(death_test_index) + \"|\"\n      + StreamableToString(pipe_fd[1]);\n  Arguments args;\n  args.AddArguments(GetArgvsForDeathTestChildProcess());\n  args.AddArgument(filter_flag.c_str());\n  args.AddArgument(internal_flag.c_str());\n\n  DeathTest::set_last_death_test_message(\"\");\n\n  CaptureStderr();\n  // See the comment in NoExecDeathTest::AssumeRole for why the next line\n  // is necessary.\n  FlushInfoLog();\n\n  const pid_t child_pid = ExecDeathTestSpawnChild(args.Argv(), pipe_fd[0]);\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(close(pipe_fd[1]));\n  set_child_pid(child_pid);\n  set_read_fd(pipe_fd[0]);\n  set_spawned(true);\n  return OVERSEE_TEST;\n}",
          "fn_code_pos": [
            [
              1333,
              0
            ],
            [
              1377,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExecDeathTest::AssumeRole",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "bool DefaultDeathTestFactory::Create(const char* statement, const RE* regex,\n                                     const char* file, int line,\n                                     DeathTest** test) {\n  UnitTestImpl* const impl = GetUnitTestImpl();\n  const InternalRunDeathTestFlag* const flag =\n      impl->internal_run_death_test_flag();\n  const int death_test_index = impl->current_test_info()\n      ->increment_death_test_count();\n\n  if (flag != NULL) {\n    if (death_test_index > flag->index()) {\n      DeathTest::set_last_death_test_message(\n          \"Death test count (\" + StreamableToString(death_test_index)\n          + \") somehow exceeded expected maximum (\"\n          + StreamableToString(flag->index()) + \")\");\n      return false;\n    }\n\n    if (!(flag->file() == file && flag->line() == line &&\n          flag->index() == death_test_index)) {\n      *test = NULL;\n      return true;\n    }\n  }\n\n# if GTEST_OS_WINDOWS\n\n  if (GTEST_FLAG(death_test_style) == \"threadsafe\" ||\n      GTEST_FLAG(death_test_style) == \"fast\") {\n    *test = new WindowsDeathTest(statement, regex, file, line);\n  }\n\n# elif GTEST_OS_FUCHSIA\n\n  if (GTEST_FLAG(death_test_style) == \"threadsafe\" ||\n      GTEST_FLAG(death_test_style) == \"fast\") {\n    *test = new FuchsiaDeathTest(statement, regex, file, line);\n  }\n\n# else\n\n  if (GTEST_FLAG(death_test_style) == \"threadsafe\") {\n    *test = new ExecDeathTest(statement, regex, file, line);\n  } else if (GTEST_FLAG(death_test_style) == \"fast\") {\n    *test = new NoExecDeathTest(statement, regex);\n  }\n\n# endif  // GTEST_OS_WINDOWS\n\n  else {  // NOLINT - this is more readable than unbalanced brackets inside #if.\n    DeathTest::set_last_death_test_message(\n        \"Unknown death test style \\\"\" + GTEST_FLAG(death_test_style)\n        + \"\\\" encountered\");\n    return false;\n  }",
          "fn_code_pos": [
            [
              1386,
              0
            ],
            [
              1440,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DefaultDeathTestFactory::Create",
            "parameters": {
              "statement": "char",
              "regex": "RE",
              "file": "char",
              "line": "int",
              "test": "DeathTest"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "static int GetStatusFileDescriptor(unsigned int parent_process_id,\n                            size_t write_handle_as_size_t,\n                            size_t event_handle_as_size_t) {\n  AutoHandle parent_process_handle(::OpenProcess(PROCESS_DUP_HANDLE,\n                                                   FALSE,  // Non-inheritable.\n                                                   parent_process_id));\n  if (parent_process_handle.Get() == INVALID_HANDLE_VALUE) {\n    DeathTestAbort(\"Unable to open parent process \" +\n                   StreamableToString(parent_process_id));\n  }\n\n  // FIXME: Replace the following check with a\n  // compile-time assertion when available.\n  GTEST_CHECK_(sizeof(HANDLE) <= sizeof(size_t));\n\n  const HANDLE write_handle =\n      reinterpret_cast<HANDLE>(write_handle_as_size_t);\n  HANDLE dup_write_handle;\n\n  // The newly initialized handle is accessible only in the parent\n  // process. To obtain one accessible within the child, we need to use\n  // DuplicateHandle.\n  if (!::DuplicateHandle(parent_process_handle.Get(), write_handle,\n                         ::GetCurrentProcess(), &dup_write_handle,\n                         0x0,    // Requested privileges ignored since\n                                 // DUPLICATE_SAME_ACCESS is used.\n                         FALSE,  // Request non-inheritable handler.\n                         DUPLICATE_SAME_ACCESS)) {\n    DeathTestAbort(\"Unable to duplicate the pipe handle \" +\n                   StreamableToString(write_handle_as_size_t) +\n                   \" from the parent process \" +\n                   StreamableToString(parent_process_id));\n  }\n\n  const HANDLE event_handle = reinterpret_cast<HANDLE>(event_handle_as_size_t);\n  HANDLE dup_event_handle;\n\n  if (!::DuplicateHandle(parent_process_handle.Get(), event_handle,\n                         ::GetCurrentProcess(), &dup_event_handle,\n                         0x0,\n                         FALSE,\n                         DUPLICATE_SAME_ACCESS)) {\n    DeathTestAbort(\"Unable to duplicate the event handle \" +\n                   StreamableToString(event_handle_as_size_t) +\n                   \" from the parent process \" +\n                   StreamableToString(parent_process_id));\n  }\n\n  const int write_fd =\n      ::_open_osfhandle(reinterpret_cast<intptr_t>(dup_write_handle), O_APPEND);\n  if (write_fd == -1) {\n    DeathTestAbort(\"Unable to convert pipe handle \" +\n                   StreamableToString(write_handle_as_size_t) +\n                   \" to a file descriptor\");\n  }\n\n  // Signals the parent that the write end of the pipe has been acquired\n  // so the parent can release its own write end.\n  ::SetEvent(dup_event_handle);\n\n  return write_fd;\n}",
          "fn_code_pos": [
            [
              1449,
              0
            ],
            [
              1510,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetStatusFileDescriptor",
            "parameters": {
              "parent_process_id": "unsigned int",
              "write_handle_as_size_t": "size_t",
              "event_handle_as_size_t": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "InternalRunDeathTestFlag* ParseInternalRunDeathTestFlag() {\n  if (GTEST_FLAG(internal_run_death_test) == \"\") return NULL;\n\n  // GTEST_HAS_DEATH_TEST implies that we have ::std::string, so we\n  // can use it here.\n  int line = -1;\n  int index = -1;\n  ::std::vector< ::std::string> fields;\n  SplitString(GTEST_FLAG(internal_run_death_test).c_str(), '|', &fields);\n  int write_fd = -1;\n\n# if GTEST_OS_WINDOWS\n\n  unsigned int parent_process_id = 0;\n  size_t write_handle_as_size_t = 0;\n  size_t event_handle_as_size_t = 0;\n\n  if (fields.size() != 6\n      || !ParseNaturalNumber(fields[1], &line)\n      || !ParseNaturalNumber(fields[2], &index)\n      || !ParseNaturalNumber(fields[3], &parent_process_id)\n      || !ParseNaturalNumber(fields[4], &write_handle_as_size_t)\n      || !ParseNaturalNumber(fields[5], &event_handle_as_size_t)) {\n    DeathTestAbort(\"Bad --gtest_internal_run_death_test flag: \" +\n                   GTEST_FLAG(internal_run_death_test));\n  }\n  write_fd = GetStatusFileDescriptor(parent_process_id,\n                                     write_handle_as_size_t,\n                                     event_handle_as_size_t);\n\n# elif GTEST_OS_FUCHSIA\n\n  if (fields.size() != 3\n      || !ParseNaturalNumber(fields[1], &line)\n      || !ParseNaturalNumber(fields[2], &index)) {\n    DeathTestAbort(\"Bad --gtest_internal_run_death_test flag: \"\n        + GTEST_FLAG(internal_run_death_test));\n  }\n\n# else\n\n  if (fields.size() != 4\n      || !ParseNaturalNumber(fields[1], &line)\n      || !ParseNaturalNumber(fields[2], &index)\n      || !ParseNaturalNumber(fields[3], &write_fd)) {\n    DeathTestAbort(\"Bad --gtest_internal_run_death_test flag: \"\n        + GTEST_FLAG(internal_run_death_test));\n  }\n\n# endif  // GTEST_OS_WINDOWS\n\n  return new InternalRunDeathTestFlag(fields[0], line, index, write_fd);\n}",
          "fn_code_pos": [
            [
              1516,
              0
            ],
            [
              1568,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ParseInternalRunDeathTestFlag",
            "parameters": {},
            "return_type": "InternalRunDeathTestFlag"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "DeathTest::LastMessage()",
          "fn_dec_pos": [
            [
              377,
              12
            ],
            [
              377,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DeathTest::LastMessage",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "Abort(AbortReason reason)",
          "fn_dec_pos": [
            [
              402,
              7
            ],
            [
              402,
              32
            ]
          ],
          "class_code": "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24",
          "class_node_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Abort",
            "parameters": {
              "reason": "AbortReason"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "Passed(bool status_ok)",
          "fn_dec_pos": [
            [
              403,
              15
            ],
            [
              403,
              37
            ]
          ],
          "class_code": "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24",
          "class_node_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Passed",
            "parameters": {
              "status_ok": "bool"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "statement() const",
          "fn_dec_pos": [
            [
              405,
              14
            ],
            [
              405,
              31
            ]
          ],
          "class_code": "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24",
          "class_node_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "statement",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "regex() const",
          "fn_dec_pos": [
            [
              406,
              12
            ],
            [
              406,
              25
            ]
          ],
          "class_code": "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24",
          "class_node_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "regex",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ReadAndInterpretStatusByte()",
          "fn_dec_pos": [
            [
              422,
              7
            ],
            [
              422,
              35
            ]
          ],
          "class_code": "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24",
          "class_node_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ReadAndInterpretStatusByte",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "Wait()",
          "fn_dec_pos": [
            [
              648,
              14
            ],
            [
              648,
              20
            ]
          ],
          "class_code": "0db24722bd77fb25e81679adebfd7ad5127164439b20d6488140de1364a75331",
          "class_node_pos": [
            [
              639,
              0
            ],
            [
              665,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Wait",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "AssumeRole()",
          "fn_dec_pos": [
            [
              649,
              19
            ],
            [
              649,
              31
            ]
          ],
          "class_code": "0db24722bd77fb25e81679adebfd7ad5127164439b20d6488140de1364a75331",
          "class_node_pos": [
            [
              639,
              0
            ],
            [
              665,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "AssumeRole",
            "parameters": {},
            "return_type": "TestRole"
          }
        },
        {
          "fn_code": "Wait()",
          "fn_dec_pos": [
            [
              820,
              14
            ],
            [
              820,
              20
            ]
          ],
          "class_code": "f421bdddf728b79204304fb7c0a0c0e0d03cb11fa13c4af3314c45f3eceeffba",
          "class_node_pos": [
            [
              805,
              0
            ],
            [
              831,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Wait",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "AssumeRole()",
          "fn_dec_pos": [
            [
              821,
              19
            ],
            [
              821,
              31
            ]
          ],
          "class_code": "f421bdddf728b79204304fb7c0a0c0e0d03cb11fa13c4af3314c45f3eceeffba",
          "class_node_pos": [
            [
              805,
              0
            ],
            [
              831,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "AssumeRole",
            "parameters": {},
            "return_type": "TestRole"
          }
        },
        {
          "fn_code": "Argv()",
          "fn_dec_pos": [
            [
              858,
              15
            ],
            [
              858,
              21
            ]
          ],
          "class_code": "d47e4dfa1fb42e8ca84414b9d0807d7f433ff7c828e114674fb779808a4fa782",
          "class_node_pos": [
            [
              834,
              0
            ],
            [
              868,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Argv",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ForkingDeathTest(const char* statement, const RE* regex)",
          "fn_dec_pos": [
            [
              1002,
              2
            ],
            [
              1002,
              58
            ]
          ],
          "class_code": "21d341af17cec2f7a47203e558381d1b66f4286e308d2e63f95684551cd293e2",
          "class_node_pos": [
            [
              1000,
              0
            ],
            [
              1013,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ForkingDeathTest",
            "parameters": {
              "statement": "char",
              "regex": "RE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Wait()",
          "fn_dec_pos": [
            [
              1005,
              14
            ],
            [
              1005,
              20
            ]
          ],
          "class_code": "21d341af17cec2f7a47203e558381d1b66f4286e308d2e63f95684551cd293e2",
          "class_node_pos": [
            [
              1000,
              0
            ],
            [
              1013,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Wait",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "AssumeRole()",
          "fn_dec_pos": [
            [
              1041,
              19
            ],
            [
              1041,
              31
            ]
          ],
          "class_code": "733a08c643ca2cc0ad5982d980a4a3749e4296d2cf013e6c5928470622f63c8a",
          "class_node_pos": [
            [
              1037,
              0
            ],
            [
              1042,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "AssumeRole",
            "parameters": {},
            "return_type": "TestRole"
          }
        },
        {
          "fn_code": "AssumeRole()",
          "fn_dec_pos": [
            [
              1097,
              19
            ],
            [
              1097,
              31
            ]
          ],
          "class_code": "715caa6e94a14abe4ca0faec4ef553c6c2a24514ed6ac7b0c32184a4033c8268",
          "class_node_pos": [
            [
              1092,
              0
            ],
            [
              1112,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "AssumeRole",
            "parameters": {},
            "return_type": "TestRole"
          }
        },
        {
          "fn_code": "Argv()",
          "fn_dec_pos": [
            [
              1139,
              15
            ],
            [
              1139,
              21
            ]
          ],
          "class_code": "fa06c4ecdbff6b8af176b8f2000cf4977657d6a2db67ab7fca40358d0db2ed86",
          "class_node_pos": [
            [
              1115,
              0
            ],
            [
              1145,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Argv",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "GetEnviron()",
          "fn_dec_pos": [
            [
              1155,
              14
            ],
            [
              1155,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetEnviron",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "GetEnviron()",
          "fn_dec_pos": [
            [
              1165,
              14
            ],
            [
              1165,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetEnviron",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "StackLowerThanAddress(const void* ptr,\n                                  bool* result)",
          "fn_dec_pos": [
            [
              1211,
              12
            ],
            [
              1212,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "StackLowerThanAddress",
            "parameters": {
              "ptr": "void",
              "result": "bool"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "parent_process_handle(::OpenProcess(PROCESS_DUP_HANDLE,\n                                                   FALSE,  // Non-inheritable.\n                                                   parent_process_id))",
          "fn_dec_pos": [
            [
              1452,
              13
            ],
            [
              1454,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parent_process_handle",
            "parameters": {},
            "return_type": "AutoHandle"
          }
        },
        {
          "fn_code": "ParseInternalRunDeathTestFlag()",
          "fn_dec_pos": [
            [
              1516,
              26
            ],
            [
              1516,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ParseInternalRunDeathTestFlag",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "ec14ab85f733a77243d438ecaf71959e1cf0409bac5ad12bcd0b2c46a3abbd24": {
          "class_code": "class DeathTestImpl : public DeathTest {\n protected:\n  DeathTestImpl(const char* a_statement, const RE* a_regex)\n      : statement_(a_statement),\n        regex_(a_regex),\n        spawned_(false),\n        status_(-1),\n        outcome_(IN_PROGRESS),\n        read_fd_(-1),\n        write_fd_(-1) {}\n\n  // read_fd_ is expected to be closed and cleared by a derived class.\n  ~DeathTestImpl() { GTEST_DEATH_TEST_CHECK_(read_fd_ == -1); }\n\n  void Abort(AbortReason reason);\n  virtual bool Passed(bool status_ok);\n\n  const char* statement() const { return statement_; }\n  const RE* regex() const { return regex_; }\n  bool spawned() const { return spawned_; }\n  void set_spawned(bool is_spawned) { spawned_ = is_spawned; }\n  int status() const { return status_; }\n  void set_status(int a_status) { status_ = a_status; }\n  DeathTestOutcome outcome() const { return outcome_; }\n  void set_outcome(DeathTestOutcome an_outcome) { outcome_ = an_outcome; }\n  int read_fd() const { return read_fd_; }\n  void set_read_fd(int fd) { read_fd_ = fd; }\n  int write_fd() const { return write_fd_; }\n  void set_write_fd(int fd) { write_fd_ = fd; }\n\n  // Called in the parent process only. Reads the result code of the death\n  // test child process via a pipe, interprets it to set the outcome_\n  // member, and closes read_fd_.  Outputs diagnostics and terminates in\n  // case of unexpected codes.\n  void ReadAndInterpretStatusByte();\n\n private:\n  // The textual content of the code this object is testing.  This class\n  // doesn't own this string and should not attempt to delete it.\n  const char* const statement_;\n  // The regular expression which test output must match.  DeathTestImpl\n  // doesn't own this object and should not attempt to delete it.\n  const RE* const regex_;\n  // True if the death test child process has been successfully spawned.\n  bool spawned_;\n  // The exit status of the child process.\n  int status_;\n  // How the death test concluded.\n  DeathTestOutcome outcome_;\n  // Descriptor to the read end of the pipe to the child process.  It is\n  // always -1 in the child process.  The child keeps its write end of the\n  // pipe in write_fd_.\n  int read_fd_;\n  // Descriptor to the child's write end of the pipe to the parent process.\n  // It is always -1 in the parent process.  The parent keeps its end of the\n  // pipe in read_fd_.\n  int write_fd_;\n}",
          "class_name": "DeathTestImpl",
          "class_pos": [
            [
              388,
              0
            ],
            [
              445,
              1
            ]
          ]
        },
        "0db24722bd77fb25e81679adebfd7ad5127164439b20d6488140de1364a75331": {
          "class_code": "class WindowsDeathTest : public DeathTestImpl {\n public:\n  WindowsDeathTest(const char* a_statement,\n                   const RE* a_regex,\n                   const char* file,\n                   int line)\n      : DeathTestImpl(a_statement, a_regex), file_(file), line_(line) {}\n\n  // All of these virtual functions are inherited from DeathTest.\n  virtual int Wait();\n  virtual TestRole AssumeRole();\n\n private:\n  // The name of the file in which the death test is located.\n  const char* const file_;\n  // The line number on which the death test is located.\n  const int line_;\n  // Handle to the write end of the pipe to the child process.\n  AutoHandle write_handle_;\n  // Child process handle.\n  AutoHandle child_handle_;\n  // Event the child process uses to signal the parent that it has\n  // acquired the handle to the write end of the pipe. After seeing this\n  // event the parent can release its own handles to make sure its\n  // ReadFile() calls return when the child terminates.\n  AutoHandle event_handle_;\n}",
          "class_name": "WindowsDeathTest",
          "class_pos": [
            [
              639,
              0
            ],
            [
              665,
              1
            ]
          ]
        },
        "f421bdddf728b79204304fb7c0a0c0e0d03cb11fa13c4af3314c45f3eceeffba": {
          "class_code": "class FuchsiaDeathTest : public DeathTestImpl {\n public:\n  FuchsiaDeathTest(const char* a_statement,\n                   const RE* a_regex,\n                   const char* file,\n                   int line)\n      : DeathTestImpl(a_statement, a_regex), file_(file), line_(line) {}\n  virtual ~FuchsiaDeathTest() {\n    zx_status_t status = zx_handle_close(child_process_);\n    GTEST_DEATH_TEST_CHECK_(status == ZX_OK);\n    status = zx_handle_close(port_);\n    GTEST_DEATH_TEST_CHECK_(status == ZX_OK);\n  }\n\n  // All of these virtual functions are inherited from DeathTest.\n  virtual int Wait();\n  virtual TestRole AssumeRole();\n\n private:\n  // The name of the file in which the death test is located.\n  const char* const file_;\n  // The line number on which the death test is located.\n  const int line_;\n\n  zx_handle_t child_process_ = ZX_HANDLE_INVALID;\n  zx_handle_t port_ = ZX_HANDLE_INVALID;\n}",
          "class_name": "FuchsiaDeathTest",
          "class_pos": [
            [
              805,
              0
            ],
            [
              831,
              1
            ]
          ]
        },
        "d47e4dfa1fb42e8ca84414b9d0807d7f433ff7c828e114674fb779808a4fa782": {
          "class_code": "class Arguments {\n public:\n  Arguments() {\n    args_.push_back(NULL);\n  }\n\n  ~Arguments() {\n    for (std::vector<char*>::iterator i = args_.begin(); i != args_.end();\n         ++i) {\n      free(*i);\n    }\n  }\n  void AddArgument(const char* argument) {\n    args_.insert(args_.end() - 1, posix::StrDup(argument));\n  }\n\n  template <typename Str>\n  void AddArguments(const ::std::vector<Str>& arguments) {\n    for (typename ::std::vector<Str>::const_iterator i = arguments.begin();\n         i != arguments.end();\n         ++i) {\n      args_.insert(args_.end() - 1, posix::StrDup(i->c_str()));\n    }\n  }\n  char* const* Argv() {\n    return &args_[0];\n  }\n\n  int size() {\n    return args_.size() - 1;\n  }\n\n private:\n  std::vector<char*> args_;\n}",
          "class_name": "Arguments",
          "class_pos": [
            [
              834,
              0
            ],
            [
              868,
              1
            ]
          ]
        },
        "21d341af17cec2f7a47203e558381d1b66f4286e308d2e63f95684551cd293e2": {
          "class_code": "class ForkingDeathTest : public DeathTestImpl {\n public:\n  ForkingDeathTest(const char* statement, const RE* regex);\n\n  // All of these virtual functions are inherited from DeathTest.\n  virtual int Wait();\n\n protected:\n  void set_child_pid(pid_t child_pid) { child_pid_ = child_pid; }\n\n private:\n  // PID of child process during death test; 0 in the child process itself.\n  pid_t child_pid_;\n}",
          "class_name": "ForkingDeathTest",
          "class_pos": [
            [
              1000,
              0
            ],
            [
              1013,
              1
            ]
          ]
        },
        "733a08c643ca2cc0ad5982d980a4a3749e4296d2cf013e6c5928470622f63c8a": {
          "class_code": "class NoExecDeathTest : public ForkingDeathTest {\n public:\n  NoExecDeathTest(const char* a_statement, const RE* a_regex) :\n      ForkingDeathTest(a_statement, a_regex) { }\n  virtual TestRole AssumeRole();\n}",
          "class_name": "NoExecDeathTest",
          "class_pos": [
            [
              1037,
              0
            ],
            [
              1042,
              1
            ]
          ]
        },
        "715caa6e94a14abe4ca0faec4ef553c6c2a24514ed6ac7b0c32184a4033c8268": {
          "class_code": "class ExecDeathTest : public ForkingDeathTest {\n public:\n  ExecDeathTest(const char* a_statement, const RE* a_regex,\n                const char* file, int line) :\n      ForkingDeathTest(a_statement, a_regex), file_(file), line_(line) { }\n  virtual TestRole AssumeRole();\n private:\n  static ::std::vector<std::string> GetArgvsForDeathTestChildProcess() {\n    ::std::vector<std::string> args = GetInjectableArgvs();\n#  if defined(GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_)\n    ::std::vector<std::string> extra_args =\n        GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_();\n    args.insert(args.end(), extra_args.begin(), extra_args.end());\n#  endif  // defined(GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_)\n    return args;\n  }\n  // The name of the file in which the death test is located.\n  const char* const file_;\n  // The line number on which the death test is located.\n  const int line_;\n}",
          "class_name": "ExecDeathTest",
          "class_pos": [
            [
              1092,
              0
            ],
            [
              1112,
              1
            ]
          ]
        },
        "fa06c4ecdbff6b8af176b8f2000cf4977657d6a2db67ab7fca40358d0db2ed86": {
          "class_code": "class Arguments {\n public:\n  Arguments() {\n    args_.push_back(NULL);\n  }\n\n  ~Arguments() {\n    for (std::vector<char*>::iterator i = args_.begin(); i != args_.end();\n         ++i) {\n      free(*i);\n    }\n  }\n  void AddArgument(const char* argument) {\n    args_.insert(args_.end() - 1, posix::StrDup(argument));\n  }\n\n  template <typename Str>\n  void AddArguments(const ::std::vector<Str>& arguments) {\n    for (typename ::std::vector<Str>::const_iterator i = arguments.begin();\n         i != arguments.end();\n         ++i) {\n      args_.insert(args_.end() - 1, posix::StrDup(i->c_str()));\n    }\n  }\n  char* const* Argv() {\n    return &args_[0];\n  }\n\n private:\n  std::vector<char*> args_;\n}",
          "class_name": "Arguments",
          "class_pos": [
            [
              1115,
              0
            ],
            [
              1145,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct ExecDeathTestArgs {\n  char* const* argv;  // Command-line arguments for the child's call to exec\n  int close_fd;       // File descriptor to close; the read end of a pipe\n}",
          {
            "* const* argv": "char",
            "close_fd": "int"
          },
          "ExecDeathTestArgs",
          [
            1149,
            0
          ],
          [
            1152,
            1
          ]
        ],
        [
          "struct ExecDeathTestArgs {\n  char* const* argv;  // Command-line arguments for the child's call to exec\n  int close_fd;       // File descriptor to close; the read end of a pipe\n}",
          {
            "* const* argv": "char",
            "close_fd": "int"
          },
          "ExecDeathTestArgs",
          [
            1149,
            0
          ],
          [
            1152,
            1
          ]
        ],
        [
          "struct inheritance",
          {},
          "",
          [
            1262,
            2
          ],
          [
            1262,
            20
          ]
        ],
        [
          "struct sigaction",
          {},
          "",
          [
            1274,
            2
          ],
          [
            1274,
            18
          ]
        ],
        [
          "struct sigaction",
          {},
          "",
          [
            1275,
            2
          ],
          [
            1275,
            18
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"gtest/gtest-death-test.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include \"gtest/internal/gtest-port.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"gtest/internal/custom/gtest.h\"\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <crt_externs.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "# include <errno.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "# include <fcntl.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "# include <limits.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#  include <signal.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "# include <stdarg.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#  include <windows.h>\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#  include <sys/mman.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#  include <sys/wait.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#  include <spawn.h>\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#  include <lib/fdio/io.h>\n",
          [
            64,
            0
          ],
          [
            65,
            0
          ]
        ],
        [
          "#  include <lib/fdio/spawn.h>\n",
          [
            65,
            0
          ],
          [
            66,
            0
          ]
        ],
        [
          "#  include <zircon/processargs.h>\n",
          [
            66,
            0
          ],
          [
            67,
            0
          ]
        ],
        [
          "#  include <zircon/syscalls.h>\n",
          [
            67,
            0
          ],
          [
            68,
            0
          ]
        ],
        [
          "#  include <zircon/syscalls/port.h>\n",
          [
            68,
            0
          ],
          [
            69,
            0
          ]
        ],
        [
          "#include \"gtest/gtest-message.h\"\n",
          [
            73,
            0
          ],
          [
            74,
            0
          ]
        ],
        [
          "#include \"gtest/internal/gtest-string.h\"\n",
          [
            74,
            0
          ],
          [
            75,
            0
          ]
        ],
        [
          "#include \"src/gtest-internal-inl.h\"\n",
          [
            75,
            0
          ],
          [
            76,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "enum DeathTestOutcome { IN_PROGRESS, DIED, LIVED, RETURNED, THREW }",
          {
            "IN_PROGRESS": "",
            "DIED": "",
            "LIVED": "",
            "RETURNED": "",
            "THREW": ""
          },
          "DeathTestOutcome",
          [
            270,
            0
          ],
          [
            270,
            67
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/third_party/googletest/src/src/gtest_main.cc": {
      "fn_def_list": [
        {
          "fn_code": "GTEST_API_ int main(int argc, char **argv) {\n  printf(\"Running main() from %s\\n\", __FILE__);\n  testing::InitGoogleTest(&argc, argv);\n  return RUN_ALL_TESTS();\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              36,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "GTEST_API_"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"gtest/gtest.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/third_party/googletest/src/src/gtest-test-part.cc": {
      "fn_def_list": [
        {
          "fn_code": "std::string TestPartResult::ExtractSummary(const char* message) {\n  const char* const stack_trace = strstr(message, internal::kStackTraceMarker);\n  return stack_trace == NULL ? message :\n      std::string(message, stack_trace);\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              45,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestPartResult::ExtractSummary",
            "parameters": {
              "message": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::ostream& operator<<(std::ostream& os, const TestPartResult& result) {\n  return os\n      << result.file_name() << \":\" << result.line_number() << \": \"\n      << (result.type() == TestPartResult::kSuccess ? \"Success\" :\n          result.type() == TestPartResult::kFatalFailure ? \"Fatal failure\" :\n          \"Non-fatal failure\") << \":\\n\"\n      << result.message() << std::endl;\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void TestPartResultArray::Append(const TestPartResult& result) {\n  array_.push_back(result);\n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestPartResultArray::Append",
            "parameters": {
              "result": "TestPartResult"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "const TestPartResult& TestPartResultArray::GetTestPartResult(int index) const {\n  if (index < 0 || index >= size()) {\n    printf(\"\\nInvalid index (%d) into TestPartResultArray.\\n\", index);\n    internal::posix::Abort();\n  }\n\n  return array_[index];\n}",
          "fn_code_pos": [
            [
              63,
              0
            ],
            [
              70,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "TestPartResult"
          }
        },
        {
          "fn_code": "int TestPartResultArray::size() const {\n  return static_cast<int>(array_.size());\n}",
          "fn_code_pos": [
            [
              73,
              0
            ],
            [
              75,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestPartResultArray::size",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "HasNewFatalFailureHelper::HasNewFatalFailureHelper()\n    : has_new_fatal_failure_(false),\n      original_reporter_(GetUnitTestImpl()->\n                         GetTestPartResultReporterForCurrentThread()) {\n  GetUnitTestImpl()->SetTestPartResultReporterForCurrentThread(this);\n}",
          "fn_code_pos": [
            [
              79,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HasNewFatalFailureHelper::HasNewFatalFailureHelper",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "HasNewFatalFailureHelper::~HasNewFatalFailureHelper() {\n  GetUnitTestImpl()->SetTestPartResultReporterForCurrentThread(\n      original_reporter_);\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              89,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HasNewFatalFailureHelper::~HasNewFatalFailureHelper",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void HasNewFatalFailureHelper::ReportTestPartResult(\n    const TestPartResult& result) {\n  if (result.fatally_failed())\n    has_new_fatal_failure_ = true;\n  original_reporter_->ReportTestPartResult(result);\n}",
          "fn_code_pos": [
            [
              91,
              0
            ],
            [
              96,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HasNewFatalFailureHelper::ReportTestPartResult",
            "parameters": {
              "result": "TestPartResult"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "operator<<(std::ostream& os, const TestPartResult& result)",
          "fn_dec_pos": [
            [
              48,
              14
            ],
            [
              48,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "TestPartResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TestPartResultArray::GetTestPartResult(int index) const",
          "fn_dec_pos": [
            [
              63,
              22
            ],
            [
              63,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestPartResultArray::GetTestPartResult",
            "parameters": {
              "index": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"gtest/gtest-test-part.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include \"src/gtest-internal-inl.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/active_map_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "ActiveMapTest() : EncoderTest(GET_PARAM(0)) {}",
          "fn_code_pos": [
            [
              26,
              2
            ],
            [
              26,
              48
            ]
          ],
          "class_code": "47ec33e9daaae7eb9a3355b1e2d8b965803a920bfe3ff93f084ecf2c3713158a",
          "class_node_pos": [
            [
              19,
              0
            ],
            [
              70,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ActiveMapTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~ActiveMapTest() {}",
          "fn_code_pos": [
            [
              27,
              2
            ],
            [
              27,
              29
            ]
          ],
          "class_code": "47ec33e9daaae7eb9a3355b1e2d8b965803a920bfe3ff93f084ecf2c3713158a",
          "class_node_pos": [
            [
              19,
              0
            ],
            [
              70,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n    cpu_used_ = GET_PARAM(2);\n  }",
          "fn_code_pos": [
            [
              29,
              2
            ],
            [
              33,
              3
            ]
          ],
          "class_code": "47ec33e9daaae7eb9a3355b1e2d8b965803a920bfe3ff93f084ecf2c3713158a",
          "class_node_pos": [
            [
              19,
              0
            ],
            [
              70,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, cpu_used_);\n    } else if (video->frame() == 3) {\n      vpx_active_map_t map = vpx_active_map_t();\n      /* clang-format off */\n      uint8_t active_map[9 * 13] = {\n        1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,\n        1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,\n        1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,\n        1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,\n        0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1,\n        0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1,\n        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1,\n        0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1,\n        1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0,\n      };\n      /* clang-format on */\n      map.cols = (kWidth + 15) / 16;\n      map.rows = (kHeight + 15) / 16;\n      ASSERT_EQ(map.cols, 13u);\n      ASSERT_EQ(map.rows, 9u);\n      map.active_map = active_map;\n      encoder->Control(VP8E_SET_ACTIVEMAP, &map);\n    } else if (video->frame() == 15) {\n      vpx_active_map_t map = vpx_active_map_t();\n      map.cols = (kWidth + 15) / 16;\n      map.rows = (kHeight + 15) / 16;\n      map.active_map = NULL;\n      encoder->Control(VP8E_SET_ACTIVEMAP, &map);\n    }\n  }",
          "fn_code_pos": [
            [
              35,
              2
            ],
            [
              67,
              3
            ]
          ],
          "class_code": "47ec33e9daaae7eb9a3355b1e2d8b965803a920bfe3ff93f084ecf2c3713158a",
          "class_node_pos": [
            [
              19,
              0
            ],
            [
              70,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(ActiveMapTest, Test) {\n  // Validate that this non multiple of 64 wide clip encodes\n  cfg_.g_lag_in_frames = 0;\n  cfg_.rc_target_bitrate = 400;\n  cfg_.rc_resize_allowed = 0;\n  cfg_.g_pass = VPX_RC_ONE_PASS;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.kf_max_dist = 90000;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_odd.yuv\", kWidth, kHeight, 30, 1,\n                                       0, 20);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              85,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "47ec33e9daaae7eb9a3355b1e2d8b965803a920bfe3ff93f084ecf2c3713158a": {
          "class_code": "class ActiveMapTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWith2Params<libvpx_test::TestMode, int> {\n protected:\n  static const int kWidth = 208;\n  static const int kHeight = 144;\n\n  ActiveMapTest() : EncoderTest(GET_PARAM(0)) {}\n  virtual ~ActiveMapTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n    cpu_used_ = GET_PARAM(2);\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, cpu_used_);\n    } else if (video->frame() == 3) {\n      vpx_active_map_t map = vpx_active_map_t();\n      /* clang-format off */\n      uint8_t active_map[9 * 13] = {\n        1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,\n        1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,\n        1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,\n        1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,\n        0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1,\n        0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1,\n        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1,\n        0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1,\n        1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0,\n      };\n      /* clang-format on */\n      map.cols = (kWidth + 15) / 16;\n      map.rows = (kHeight + 15) / 16;\n      ASSERT_EQ(map.cols, 13u);\n      ASSERT_EQ(map.rows, 9u);\n      map.active_map = active_map;\n      encoder->Control(VP8E_SET_ACTIVEMAP, &map);\n    } else if (video->frame() == 15) {\n      vpx_active_map_t map = vpx_active_map_t();\n      map.cols = (kWidth + 15) / 16;\n      map.rows = (kHeight + 15) / 16;\n      map.active_map = NULL;\n      encoder->Control(VP8E_SET_ACTIVEMAP, &map);\n    }\n  }\n\n  int cpu_used_;\n}",
          "class_name": "ActiveMapTest",
          "class_pos": [
            [
              19,
              0
            ],
            [
              70,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <climits>\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/convolve_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "ConvolveFunctions(ConvolveFunc copy, ConvolveFunc avg, ConvolveFunc h8,\n                    ConvolveFunc h8_avg, ConvolveFunc v8, ConvolveFunc v8_avg,\n                    ConvolveFunc hv8, ConvolveFunc hv8_avg, ConvolveFunc sh8,\n                    ConvolveFunc sh8_avg, ConvolveFunc sv8,\n                    ConvolveFunc sv8_avg, ConvolveFunc shv8,\n                    ConvolveFunc shv8_avg, int bd)\n      : use_highbd_(bd) {\n    copy_[0] = copy;\n    copy_[1] = avg;\n    h8_[0] = h8;\n    h8_[1] = h8_avg;\n    v8_[0] = v8;\n    v8_[1] = v8_avg;\n    hv8_[0] = hv8;\n    hv8_[1] = hv8_avg;\n    sh8_[0] = sh8;\n    sh8_[1] = sh8_avg;\n    sv8_[0] = sv8;\n    sv8_[1] = sv8_avg;\n    shv8_[0] = shv8;\n    shv8_[1] = shv8_avg;\n  }",
          "fn_code_pos": [
            [
              47,
              2
            ],
            [
              68,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ConvolveFunctions",
            "parameters": {
              "copy": "ConvolveFunc",
              "avg": "ConvolveFunc",
              "h8": "ConvolveFunc",
              "h8_avg": "ConvolveFunc",
              "v8": "ConvolveFunc",
              "v8_avg": "ConvolveFunc",
              "hv8": "ConvolveFunc",
              "hv8_avg": "ConvolveFunc",
              "sh8": "ConvolveFunc",
              "sh8_avg": "ConvolveFunc",
              "sv8": "ConvolveFunc",
              "sv8_avg": "ConvolveFunc",
              "shv8": "ConvolveFunc",
              "shv8_avg": "ConvolveFunc",
              "bd": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "uint8_t clip_pixel(int x) { return x < 0 ? 0 : x > 255 ? 255 : x; }",
          "fn_code_pos": [
            [
              94,
              0
            ],
            [
              94,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "clip_pixel",
            "parameters": {
              "x": "int"
            },
            "return_type": "uint8_t"
          }
        },
        {
          "fn_code": "void filter_block2d_8_c(const uint8_t *src_ptr, const unsigned int src_stride,\n                        const int16_t *hfilter, const int16_t *vfilter,\n                        uint8_t *dst_ptr, unsigned int dst_stride,\n                        unsigned int output_width, unsigned int output_height) {\n  // Between passes, we use an intermediate buffer whose height is extended to\n  // have enough horizontally filtered values as input for the vertical pass.\n  // This buffer is allocated to be big enough for the largest block type we\n  // support.\n  const int kInterp_Extend = 4;\n  const unsigned int intermediate_height =\n      (kInterp_Extend - 1) + output_height + kInterp_Extend;\n  unsigned int i, j;\n\n  // Size of intermediate_buffer is max_intermediate_height * filter_max_width,\n  // where max_intermediate_height = (kInterp_Extend - 1) + filter_max_height\n  //                                 + kInterp_Extend\n  //                               = 3 + 16 + 4\n  //                               = 23\n  // and filter_max_width          = 16\n  //\n  uint8_t intermediate_buffer[71 * kMaxDimension];\n  vp9_zero(intermediate_buffer);\n  const int intermediate_next_stride =\n      1 - static_cast<int>(intermediate_height * output_width);\n\n  // Horizontal pass (src -> transposed intermediate).\n  uint8_t *output_ptr = intermediate_buffer;\n  const int src_next_row_stride = src_stride - output_width;\n  src_ptr -= (kInterp_Extend - 1) * src_stride + (kInterp_Extend - 1);\n  for (i = 0; i < intermediate_height; ++i) {\n    for (j = 0; j < output_width; ++j) {\n      // Apply filter...\n      const int temp = (src_ptr[0] * hfilter[0]) + (src_ptr[1] * hfilter[1]) +\n                       (src_ptr[2] * hfilter[2]) + (src_ptr[3] * hfilter[3]) +\n                       (src_ptr[4] * hfilter[4]) + (src_ptr[5] * hfilter[5]) +\n                       (src_ptr[6] * hfilter[6]) + (src_ptr[7] * hfilter[7]) +\n                       (VP9_FILTER_WEIGHT >> 1);  // Rounding\n\n      // Normalize back to 0-255...\n      *output_ptr = clip_pixel(temp >> VP9_FILTER_SHIFT);\n      ++src_ptr;\n      output_ptr += intermediate_height;\n    }\n    src_ptr += src_next_row_stride;\n    output_ptr += intermediate_next_stride;\n  }\n\n  // Vertical pass (transposed intermediate -> dst).\n  src_ptr = intermediate_buffer;\n  const int dst_next_row_stride = dst_stride - output_width;\n  for (i = 0; i < output_height; ++i) {\n    for (j = 0; j < output_width; ++j) {\n      // Apply filter...\n      const int temp = (src_ptr[0] * vfilter[0]) + (src_ptr[1] * vfilter[1]) +\n                       (src_ptr[2] * vfilter[2]) + (src_ptr[3] * vfilter[3]) +\n                       (src_ptr[4] * vfilter[4]) + (src_ptr[5] * vfilter[5]) +\n                       (src_ptr[6] * vfilter[6]) + (src_ptr[7] * vfilter[7]) +\n                       (VP9_FILTER_WEIGHT >> 1);  // Rounding\n\n      // Normalize back to 0-255...\n      *dst_ptr++ = clip_pixel(temp >> VP9_FILTER_SHIFT);\n      src_ptr += intermediate_height;\n    }\n    src_ptr += intermediate_next_stride;\n    dst_ptr += dst_next_row_stride;\n  }\n}",
          "fn_code_pos": [
            [
              96,
              0
            ],
            [
              162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "filter_block2d_8_c",
            "parameters": {
              "src_ptr": "uint8_t",
              "src_stride": "unsigned int",
              "hfilter": "int16_t",
              "vfilter": "int16_t",
              "dst_ptr": "uint8_t",
              "dst_stride": "unsigned int",
              "output_width": "unsigned int",
              "output_height": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void block2d_average_c(uint8_t *src, unsigned int src_stride,\n                       uint8_t *output_ptr, unsigned int output_stride,\n                       unsigned int output_width, unsigned int output_height) {\n  unsigned int i, j;\n  for (i = 0; i < output_height; ++i) {\n    for (j = 0; j < output_width; ++j) {\n      output_ptr[j] = (output_ptr[j] + src[i * src_stride + j] + 1) >> 1;\n    }\n    output_ptr += output_stride;\n  }\n}",
          "fn_code_pos": [
            [
              164,
              0
            ],
            [
              174,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block2d_average_c",
            "parameters": {
              "src": "uint8_t",
              "src_stride": "unsigned int",
              "output_ptr": "uint8_t",
              "output_stride": "unsigned int",
              "output_width": "unsigned int",
              "output_height": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void filter_average_block2d_8_c(const uint8_t *src_ptr,\n                                const unsigned int src_stride,\n                                const int16_t *hfilter, const int16_t *vfilter,\n                                uint8_t *dst_ptr, unsigned int dst_stride,\n                                unsigned int output_width,\n                                unsigned int output_height) {\n  uint8_t tmp[kMaxDimension * kMaxDimension];\n\n  assert(output_width <= kMaxDimension);\n  assert(output_height <= kMaxDimension);\n  filter_block2d_8_c(src_ptr, src_stride, hfilter, vfilter, tmp, 64,\n                     output_width, output_height);\n  block2d_average_c(tmp, 64, dst_ptr, dst_stride, output_width, output_height);\n}",
          "fn_code_pos": [
            [
              176,
              0
            ],
            [
              189,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "filter_average_block2d_8_c",
            "parameters": {
              "src_ptr": "uint8_t",
              "src_stride": "unsigned int",
              "hfilter": "int16_t",
              "vfilter": "int16_t",
              "dst_ptr": "uint8_t",
              "dst_stride": "unsigned int",
              "output_width": "unsigned int",
              "output_height": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void highbd_filter_block2d_8_c(const uint16_t *src_ptr,\n                               const unsigned int src_stride,\n                               const int16_t *hfilter, const int16_t *vfilter,\n                               uint16_t *dst_ptr, unsigned int dst_stride,\n                               unsigned int output_width,\n                               unsigned int output_height, int bd) {\n  // Between passes, we use an intermediate buffer whose height is extended to\n  // have enough horizontally filtered values as input for the vertical pass.\n  // This buffer is allocated to be big enough for the largest block type we\n  // support.\n  const int kInterp_Extend = 4;\n  const unsigned int intermediate_height =\n      (kInterp_Extend - 1) + output_height + kInterp_Extend;\n\n  /* Size of intermediate_buffer is max_intermediate_height * filter_max_width,\n   * where max_intermediate_height = (kInterp_Extend - 1) + filter_max_height\n   *                                 + kInterp_Extend\n   *                               = 3 + 16 + 4\n   *                               = 23\n   * and filter_max_width = 16\n   */\n  uint16_t intermediate_buffer[71 * kMaxDimension];\n  const int intermediate_next_stride =\n      1 - static_cast<int>(intermediate_height * output_width);\n\n  vp9_zero(intermediate_buffer);\n\n  // Horizontal pass (src -> transposed intermediate).\n  {\n    uint16_t *output_ptr = intermediate_buffer;\n    const int src_next_row_stride = src_stride - output_width;\n    unsigned int i, j;\n    src_ptr -= (kInterp_Extend - 1) * src_stride + (kInterp_Extend - 1);\n    for (i = 0; i < intermediate_height; ++i) {\n      for (j = 0; j < output_width; ++j) {\n        // Apply filter...\n        const int temp = (src_ptr[0] * hfilter[0]) + (src_ptr[1] * hfilter[1]) +\n                         (src_ptr[2] * hfilter[2]) + (src_ptr[3] * hfilter[3]) +\n                         (src_ptr[4] * hfilter[4]) + (src_ptr[5] * hfilter[5]) +\n                         (src_ptr[6] * hfilter[6]) + (src_ptr[7] * hfilter[7]) +\n                         (VP9_FILTER_WEIGHT >> 1);  // Rounding\n\n        // Normalize back to 0-255...\n        *output_ptr = clip_pixel_highbd(temp >> VP9_FILTER_SHIFT, bd);\n        ++src_ptr;\n        output_ptr += intermediate_height;\n      }\n      src_ptr += src_next_row_stride;\n      output_ptr += intermediate_next_stride;\n    }\n  }\n\n  // Vertical pass (transposed intermediate -> dst).\n  {\n    uint16_t *src_ptr = intermediate_buffer;\n    const int dst_next_row_stride = dst_stride - output_width;\n    unsigned int i, j;\n    for (i = 0; i < output_height; ++i) {\n      for (j = 0; j < output_width; ++j) {\n        // Apply filter...\n        const int temp = (src_ptr[0] * vfilter[0]) + (src_ptr[1] * vfilter[1]) +\n                         (src_ptr[2] * vfilter[2]) + (src_ptr[3] * vfilter[3]) +\n                         (src_ptr[4] * vfilter[4]) + (src_ptr[5] * vfilter[5]) +\n                         (src_ptr[6] * vfilter[6]) + (src_ptr[7] * vfilter[7]) +\n                         (VP9_FILTER_WEIGHT >> 1);  // Rounding\n\n        // Normalize back to 0-255...\n        *dst_ptr++ = clip_pixel_highbd(temp >> VP9_FILTER_SHIFT, bd);\n        src_ptr += intermediate_height;\n      }\n      src_ptr += intermediate_next_stride;\n      dst_ptr += dst_next_row_stride;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              192,
              0
            ],
            [
              266,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "highbd_filter_block2d_8_c",
            "parameters": {
              "src_ptr": "uint16_t",
              "src_stride": "unsigned int",
              "hfilter": "int16_t",
              "vfilter": "int16_t",
              "dst_ptr": "uint16_t",
              "dst_stride": "unsigned int",
              "output_width": "unsigned int",
              "output_height": "unsigned int",
              "bd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void highbd_block2d_average_c(uint16_t *src, unsigned int src_stride,\n                              uint16_t *output_ptr, unsigned int output_stride,\n                              unsigned int output_width,\n                              unsigned int output_height) {\n  unsigned int i, j;\n  for (i = 0; i < output_height; ++i) {\n    for (j = 0; j < output_width; ++j) {\n      output_ptr[j] = (output_ptr[j] + src[i * src_stride + j] + 1) >> 1;\n    }\n    output_ptr += output_stride;\n  }\n}",
          "fn_code_pos": [
            [
              268,
              0
            ],
            [
              279,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "highbd_block2d_average_c",
            "parameters": {
              "src": "uint16_t",
              "src_stride": "unsigned int",
              "output_ptr": "uint16_t",
              "output_stride": "unsigned int",
              "output_width": "unsigned int",
              "output_height": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void highbd_filter_average_block2d_8_c(\n    const uint16_t *src_ptr, const unsigned int src_stride,\n    const int16_t *hfilter, const int16_t *vfilter, uint16_t *dst_ptr,\n    unsigned int dst_stride, unsigned int output_width,\n    unsigned int output_height, int bd) {\n  uint16_t tmp[kMaxDimension * kMaxDimension];\n\n  assert(output_width <= kMaxDimension);\n  assert(output_height <= kMaxDimension);\n  highbd_filter_block2d_8_c(src_ptr, src_stride, hfilter, vfilter, tmp, 64,\n                            output_width, output_height, bd);\n  highbd_block2d_average_c(tmp, 64, dst_ptr, dst_stride, output_width,\n                           output_height);\n}",
          "fn_code_pos": [
            [
              281,
              0
            ],
            [
              294,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "highbd_filter_average_block2d_8_c",
            "parameters": {
              "src_ptr": "uint16_t",
              "src_stride": "unsigned int",
              "hfilter": "int16_t",
              "vfilter": "int16_t",
              "dst_ptr": "uint16_t",
              "dst_stride": "unsigned int",
              "output_width": "unsigned int",
              "output_height": "unsigned int",
              "bd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void wrapper_filter_average_block2d_8_c(\n    const uint8_t *src_ptr, const unsigned int src_stride,\n    const int16_t *hfilter, const int16_t *vfilter, uint8_t *dst_ptr,\n    unsigned int dst_stride, unsigned int output_width,\n    unsigned int output_height, int use_highbd) {\n#if CONFIG_VP9_HIGHBITDEPTH\n  if (use_highbd == 0) {\n    filter_average_block2d_8_c(src_ptr, src_stride, hfilter, vfilter, dst_ptr,\n                               dst_stride, output_width, output_height);\n  } else {\n    highbd_filter_average_block2d_8_c(CAST_TO_SHORTPTR(src_ptr), src_stride,\n                                      hfilter, vfilter,\n                                      CAST_TO_SHORTPTR(dst_ptr), dst_stride,\n                                      output_width, output_height, use_highbd);\n  }\n#else\n  ASSERT_EQ(0, use_highbd);\n  filter_average_block2d_8_c(src_ptr, src_stride, hfilter, vfilter, dst_ptr,\n                             dst_stride, output_width, output_height);\n#endif\n}",
          "fn_code_pos": [
            [
              297,
              0
            ],
            [
              317,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "wrapper_filter_average_block2d_8_c",
            "parameters": {
              "src_ptr": "uint8_t",
              "src_stride": "unsigned int",
              "hfilter": "int16_t",
              "vfilter": "int16_t",
              "dst_ptr": "uint8_t",
              "dst_stride": "unsigned int",
              "output_width": "unsigned int",
              "output_height": "unsigned int",
              "use_highbd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void wrapper_filter_block2d_8_c(const uint8_t *src_ptr,\n                                const unsigned int src_stride,\n                                const int16_t *hfilter, const int16_t *vfilter,\n                                uint8_t *dst_ptr, unsigned int dst_stride,\n                                unsigned int output_width,\n                                unsigned int output_height, int use_highbd) {\n#if CONFIG_VP9_HIGHBITDEPTH\n  if (use_highbd == 0) {\n    filter_block2d_8_c(src_ptr, src_stride, hfilter, vfilter, dst_ptr,\n                       dst_stride, output_width, output_height);\n  } else {\n    highbd_filter_block2d_8_c(CAST_TO_SHORTPTR(src_ptr), src_stride, hfilter,\n                              vfilter, CAST_TO_SHORTPTR(dst_ptr), dst_stride,\n                              output_width, output_height, use_highbd);\n  }\n#else\n  ASSERT_EQ(0, use_highbd);\n  filter_block2d_8_c(src_ptr, src_stride, hfilter, vfilter, dst_ptr, dst_stride,\n                     output_width, output_height);\n#endif\n}",
          "fn_code_pos": [
            [
              319,
              0
            ],
            [
              339,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "wrapper_filter_block2d_8_c",
            "parameters": {
              "src_ptr": "uint8_t",
              "src_stride": "unsigned int",
              "hfilter": "int16_t",
              "vfilter": "int16_t",
              "dst_ptr": "uint8_t",
              "dst_stride": "unsigned int",
              "output_width": "unsigned int",
              "output_height": "unsigned int",
              "use_highbd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void SetUpTestCase() {\n    // Force input_ to be unaligned, output to be 16 byte aligned.\n    input_ = reinterpret_cast<uint8_t *>(\n                 vpx_memalign(kDataAlignment, kInputBufferSize + 1)) +\n             1;\n    output_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kOutputBufferSize));\n    output_ref_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kOutputBufferSize));\n#if CONFIG_VP9_HIGHBITDEPTH\n    input16_ = reinterpret_cast<uint16_t *>(vpx_memalign(\n                   kDataAlignment, (kInputBufferSize + 1) * sizeof(uint16_t))) +\n               1;\n    output16_ = reinterpret_cast<uint16_t *>(\n        vpx_memalign(kDataAlignment, (kOutputBufferSize) * sizeof(uint16_t)));\n    output16_ref_ = reinterpret_cast<uint16_t *>(\n        vpx_memalign(kDataAlignment, (kOutputBufferSize) * sizeof(uint16_t)));\n#endif\n  }",
          "fn_code_pos": [
            [
              343,
              2
            ],
            [
              361,
              3
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUpTestCase",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              363,
              2
            ],
            [
              363,
              62
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void TearDownTestCase() {\n    vpx_free(input_ - 1);\n    input_ = NULL;\n    vpx_free(output_);\n    output_ = NULL;\n    vpx_free(output_ref_);\n    output_ref_ = NULL;\n#if CONFIG_VP9_HIGHBITDEPTH\n    vpx_free(input16_ - 1);\n    input16_ = NULL;\n    vpx_free(output16_);\n    output16_ = NULL;\n    vpx_free(output16_ref_);\n    output16_ref_ = NULL;\n#endif\n  }",
          "fn_code_pos": [
            [
              365,
              2
            ],
            [
              380,
              3
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDownTestCase",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int Width() const { return GET_PARAM(0); }",
          "fn_code_pos": [
            [
              390,
              2
            ],
            [
              390,
              44
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Width",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int Height() const { return GET_PARAM(1); }",
          "fn_code_pos": [
            [
              391,
              2
            ],
            [
              391,
              45
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Height",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int BorderLeft() const {\n    const int center = (kOuterBlockSize - Width()) / 2;\n    return (center + (kDataAlignment - 1)) & ~(kDataAlignment - 1);\n  }",
          "fn_code_pos": [
            [
              392,
              2
            ],
            [
              395,
              3
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BorderLeft",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int BorderTop() const { return (kOuterBlockSize - Height()) / 2; }",
          "fn_code_pos": [
            [
              396,
              2
            ],
            [
              396,
              68
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BorderTop",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "bool IsIndexInBorder(int i) {\n    return (i < BorderTop() * kOuterBlockSize ||\n            i >= (BorderTop() + Height()) * kOuterBlockSize ||\n            i % kOuterBlockSize < BorderLeft() ||\n            i % kOuterBlockSize >= (BorderLeft() + Width()));\n  }",
          "fn_code_pos": [
            [
              398,
              2
            ],
            [
              403,
              3
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "IsIndexInBorder",
            "parameters": {
              "i": "int"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    UUT_ = GET_PARAM(2);\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (UUT_->use_highbd_ != 0) {\n      mask_ = (1 << UUT_->use_highbd_) - 1;\n    } else {\n      mask_ = 255;\n    }\n#endif\n    /* Set up guard blocks for an inner block centered in the outer block */\n    for (int i = 0; i < kOutputBufferSize; ++i) {\n      if (IsIndexInBorder(i)) {\n        output_[i] = 255;\n#if CONFIG_VP9_HIGHBITDEPTH\n        output16_[i] = mask_;\n#endif\n      } else {\n        output_[i] = 0;\n#if CONFIG_VP9_HIGHBITDEPTH\n        output16_[i] = 0;\n#endif\n      }\n    }\n\n    ::libvpx_test::ACMRandom prng;\n    for (int i = 0; i < kInputBufferSize; ++i) {\n      if (i & 1) {\n        input_[i] = 255;\n#if CONFIG_VP9_HIGHBITDEPTH\n        input16_[i] = mask_;\n#endif\n      } else {\n        input_[i] = prng.Rand8Extremes();\n#if CONFIG_VP9_HIGHBITDEPTH\n        input16_[i] = prng.Rand16() & mask_;\n#endif\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              405,
              2
            ],
            [
              443,
              3
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SetConstantInput(int value) {\n    memset(input_, value, kInputBufferSize);\n#if CONFIG_VP9_HIGHBITDEPTH\n    vpx_memset16(input16_, value, kInputBufferSize);\n#endif\n  }",
          "fn_code_pos": [
            [
              445,
              2
            ],
            [
              450,
              3
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetConstantInput",
            "parameters": {
              "value": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CopyOutputToRef() {\n    memcpy(output_ref_, output_, kOutputBufferSize);\n#if CONFIG_VP9_HIGHBITDEPTH\n    memcpy(output16_ref_, output16_,\n           kOutputBufferSize * sizeof(output16_ref_[0]));\n#endif\n  }",
          "fn_code_pos": [
            [
              452,
              2
            ],
            [
              458,
              3
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CopyOutputToRef",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CheckGuardBlocks() {\n    for (int i = 0; i < kOutputBufferSize; ++i) {\n      if (IsIndexInBorder(i)) {\n        EXPECT_EQ(255, output_[i]);\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              460,
              2
            ],
            [
              466,
              3
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckGuardBlocks",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "uint8_t *input() const {\n    const int offset = BorderTop() * kOuterBlockSize + BorderLeft();\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (UUT_->use_highbd_ == 0) {\n      return input_ + offset;\n    } else {\n      return CAST_TO_BYTEPTR(input16_ + offset);\n    }\n#else\n    return input_ + offset;\n#endif\n  }",
          "fn_code_pos": [
            [
              468,
              2
            ],
            [
              479,
              3
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "input",
            "parameters": {},
            "return_type": "uint8_t"
          }
        },
        {
          "fn_code": "uint8_t *output() const {\n    const int offset = BorderTop() * kOuterBlockSize + BorderLeft();\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (UUT_->use_highbd_ == 0) {\n      return output_ + offset;\n    } else {\n      return CAST_TO_BYTEPTR(output16_ + offset);\n    }\n#else\n    return output_ + offset;\n#endif\n  }",
          "fn_code_pos": [
            [
              481,
              2
            ],
            [
              492,
              3
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "output",
            "parameters": {},
            "return_type": "uint8_t"
          }
        },
        {
          "fn_code": "uint8_t *output_ref() const {\n    const int offset = BorderTop() * kOuterBlockSize + BorderLeft();\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (UUT_->use_highbd_ == 0) {\n      return output_ref_ + offset;\n    } else {\n      return CAST_TO_BYTEPTR(output16_ref_ + offset);\n    }\n#else\n    return output_ref_ + offset;\n#endif\n  }",
          "fn_code_pos": [
            [
              494,
              2
            ],
            [
              505,
              3
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "output_ref",
            "parameters": {},
            "return_type": "uint8_t"
          }
        },
        {
          "fn_code": "uint16_t lookup(uint8_t *list, int index) const {\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (UUT_->use_highbd_ == 0) {\n      return list[index];\n    } else {\n      return CAST_TO_SHORTPTR(list)[index];\n    }\n#else\n    return list[index];\n#endif\n  }",
          "fn_code_pos": [
            [
              507,
              2
            ],
            [
              517,
              3
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "lookup",
            "parameters": {
              "list": "uint8_t",
              "index": "int"
            },
            "return_type": "uint16_t"
          }
        },
        {
          "fn_code": "void assign_val(uint8_t *list, int index, uint16_t val) const {\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (UUT_->use_highbd_ == 0) {\n      list[index] = (uint8_t)val;\n    } else {\n      CAST_TO_SHORTPTR(list)[index] = val;\n    }\n#else\n    list[index] = (uint8_t)val;\n#endif\n  }",
          "fn_code_pos": [
            [
              519,
              2
            ],
            [
              529,
              3
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "assign_val",
            "parameters": {
              "list": "uint8_t",
              "index": "int",
              "val": "uint16_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(ConvolveTest, GuardBlocks) { CheckGuardBlocks(); }",
          "fn_code_pos": [
            [
              552,
              0
            ],
            [
              552,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ConvolveTest, DISABLED_Copy_Speed) {\n  const uint8_t *const in = input();\n  uint8_t *const out = output();\n  const int kNumTests = 5000000;\n  const int width = Width();\n  const int height = Height();\n  vpx_usec_timer timer;\n\n  vpx_usec_timer_start(&timer);\n  for (int n = 0; n < kNumTests; ++n) {\n    UUT_->copy_[0](in, kInputStride, out, kOutputStride, NULL, 0, 0, 0, 0,\n                   width, height);\n  }\n  vpx_usec_timer_mark(&timer);\n\n  const int elapsed_time = static_cast<int>(vpx_usec_timer_elapsed(&timer));\n  printf(\"convolve_copy_%dx%d_%d: %d us\\n\", width, height,\n         UUT_->use_highbd_ ? UUT_->use_highbd_ : 8, elapsed_time);\n}",
          "fn_code_pos": [
            [
              554,
              0
            ],
            [
              572,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ConvolveTest, DISABLED_Avg_Speed) {\n  const uint8_t *const in = input();\n  uint8_t *const out = output();\n  const int kNumTests = 5000000;\n  const int width = Width();\n  const int height = Height();\n  vpx_usec_timer timer;\n\n  vpx_usec_timer_start(&timer);\n  for (int n = 0; n < kNumTests; ++n) {\n    UUT_->copy_[1](in, kInputStride, out, kOutputStride, NULL, 0, 0, 0, 0,\n                   width, height);\n  }\n  vpx_usec_timer_mark(&timer);\n\n  const int elapsed_time = static_cast<int>(vpx_usec_timer_elapsed(&timer));\n  printf(\"convolve_avg_%dx%d_%d: %d us\\n\", width, height,\n         UUT_->use_highbd_ ? UUT_->use_highbd_ : 8, elapsed_time);\n}",
          "fn_code_pos": [
            [
              574,
              0
            ],
            [
              592,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ConvolveTest, DISABLED_Scale_Speed) {\n  const uint8_t *const in = input();\n  uint8_t *const out = output();\n  const InterpKernel *const eighttap = vp9_filter_kernels[EIGHTTAP];\n  const int kNumTests = 5000000;\n  const int width = Width();\n  const int height = Height();\n  vpx_usec_timer timer;\n\n  SetConstantInput(127);\n\n  vpx_usec_timer_start(&timer);\n  for (int n = 0; n < kNumTests; ++n) {\n    UUT_->shv8_[0](in, kInputStride, out, kOutputStride, eighttap, 8, 16, 8, 16,\n                   width, height);\n  }\n  vpx_usec_timer_mark(&timer);\n\n  const int elapsed_time = static_cast<int>(vpx_usec_timer_elapsed(&timer));\n  printf(\"convolve_scale_%dx%d_%d: %d us\\n\", width, height,\n         UUT_->use_highbd_ ? UUT_->use_highbd_ : 8, elapsed_time);\n}",
          "fn_code_pos": [
            [
              594,
              0
            ],
            [
              615,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ConvolveTest, DISABLED_8Tap_Speed) {\n  const uint8_t *const in = input();\n  uint8_t *const out = output();\n  const InterpKernel *const eighttap = vp9_filter_kernels[EIGHTTAP_SHARP];\n  const int kNumTests = 5000000;\n  const int width = Width();\n  const int height = Height();\n  vpx_usec_timer timer;\n\n  SetConstantInput(127);\n\n  vpx_usec_timer_start(&timer);\n  for (int n = 0; n < kNumTests; ++n) {\n    UUT_->hv8_[0](in, kInputStride, out, kOutputStride, eighttap, 8, 16, 8, 16,\n                  width, height);\n  }\n  vpx_usec_timer_mark(&timer);\n\n  const int elapsed_time = static_cast<int>(vpx_usec_timer_elapsed(&timer));\n  printf(\"convolve8_%dx%d_%d: %d us\\n\", width, height,\n         UUT_->use_highbd_ ? UUT_->use_highbd_ : 8, elapsed_time);\n}",
          "fn_code_pos": [
            [
              617,
              0
            ],
            [
              638,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ConvolveTest, DISABLED_8Tap_Horiz_Speed) {\n  const uint8_t *const in = input();\n  uint8_t *const out = output();\n  const InterpKernel *const eighttap = vp9_filter_kernels[EIGHTTAP_SHARP];\n  const int kNumTests = 5000000;\n  const int width = Width();\n  const int height = Height();\n  vpx_usec_timer timer;\n\n  SetConstantInput(127);\n\n  vpx_usec_timer_start(&timer);\n  for (int n = 0; n < kNumTests; ++n) {\n    UUT_->h8_[0](in, kInputStride, out, kOutputStride, eighttap, 8, 16, 8, 16,\n                 width, height);\n  }\n  vpx_usec_timer_mark(&timer);\n\n  const int elapsed_time = static_cast<int>(vpx_usec_timer_elapsed(&timer));\n  printf(\"convolve8_horiz_%dx%d_%d: %d us\\n\", width, height,\n         UUT_->use_highbd_ ? UUT_->use_highbd_ : 8, elapsed_time);\n}",
          "fn_code_pos": [
            [
              640,
              0
            ],
            [
              661,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ConvolveTest, DISABLED_8Tap_Vert_Speed) {\n  const uint8_t *const in = input();\n  uint8_t *const out = output();\n  const InterpKernel *const eighttap = vp9_filter_kernels[EIGHTTAP_SHARP];\n  const int kNumTests = 5000000;\n  const int width = Width();\n  const int height = Height();\n  vpx_usec_timer timer;\n\n  SetConstantInput(127);\n\n  vpx_usec_timer_start(&timer);\n  for (int n = 0; n < kNumTests; ++n) {\n    UUT_->v8_[0](in, kInputStride, out, kOutputStride, eighttap, 8, 16, 8, 16,\n                 width, height);\n  }\n  vpx_usec_timer_mark(&timer);\n\n  const int elapsed_time = static_cast<int>(vpx_usec_timer_elapsed(&timer));\n  printf(\"convolve8_vert_%dx%d_%d: %d us\\n\", width, height,\n         UUT_->use_highbd_ ? UUT_->use_highbd_ : 8, elapsed_time);\n}",
          "fn_code_pos": [
            [
              663,
              0
            ],
            [
              684,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ConvolveTest, DISABLED_4Tap_Speed) {\n  const uint8_t *const in = input();\n  uint8_t *const out = output();\n  const InterpKernel *const fourtap = vp9_filter_kernels[FOURTAP];\n  const int kNumTests = 5000000;\n  const int width = Width();\n  const int height = Height();\n  vpx_usec_timer timer;\n\n  SetConstantInput(127);\n\n  vpx_usec_timer_start(&timer);\n  for (int n = 0; n < kNumTests; ++n) {\n    UUT_->hv8_[0](in, kInputStride, out, kOutputStride, fourtap, 8, 16, 8, 16,\n                  width, height);\n  }\n  vpx_usec_timer_mark(&timer);\n\n  const int elapsed_time = static_cast<int>(vpx_usec_timer_elapsed(&timer));\n  printf(\"convolve4_%dx%d_%d: %d us\\n\", width, height,\n         UUT_->use_highbd_ ? UUT_->use_highbd_ : 8, elapsed_time);\n}",
          "fn_code_pos": [
            [
              686,
              0
            ],
            [
              707,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ConvolveTest, DISABLED_4Tap_Horiz_Speed) {\n  const uint8_t *const in = input();\n  uint8_t *const out = output();\n  const InterpKernel *const fourtap = vp9_filter_kernels[FOURTAP];\n  const int kNumTests = 5000000;\n  const int width = Width();\n  const int height = Height();\n  vpx_usec_timer timer;\n\n  SetConstantInput(127);\n\n  vpx_usec_timer_start(&timer);\n  for (int n = 0; n < kNumTests; ++n) {\n    UUT_->h8_[0](in, kInputStride, out, kOutputStride, fourtap, 8, 16, 8, 16,\n                 width, height);\n  }\n  vpx_usec_timer_mark(&timer);\n\n  const int elapsed_time = static_cast<int>(vpx_usec_timer_elapsed(&timer));\n  printf(\"convolve4_horiz_%dx%d_%d: %d us\\n\", width, height,\n         UUT_->use_highbd_ ? UUT_->use_highbd_ : 8, elapsed_time);\n}",
          "fn_code_pos": [
            [
              709,
              0
            ],
            [
              730,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ConvolveTest, DISABLED_4Tap_Vert_Speed) {\n  const uint8_t *const in = input();\n  uint8_t *const out = output();\n  const InterpKernel *const fourtap = vp9_filter_kernels[FOURTAP];\n  const int kNumTests = 5000000;\n  const int width = Width();\n  const int height = Height();\n  vpx_usec_timer timer;\n\n  SetConstantInput(127);\n\n  vpx_usec_timer_start(&timer);\n  for (int n = 0; n < kNumTests; ++n) {\n    UUT_->v8_[0](in, kInputStride, out, kOutputStride, fourtap, 8, 16, 8, 16,\n                 width, height);\n  }\n  vpx_usec_timer_mark(&timer);\n\n  const int elapsed_time = static_cast<int>(vpx_usec_timer_elapsed(&timer));\n  printf(\"convolve4_vert_%dx%d_%d: %d us\\n\", width, height,\n         UUT_->use_highbd_ ? UUT_->use_highbd_ : 8, elapsed_time);\n}",
          "fn_code_pos": [
            [
              732,
              0
            ],
            [
              753,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ConvolveTest, DISABLED_8Tap_Avg_Speed) {\n  const uint8_t *const in = input();\n  uint8_t *const out = output();\n  const InterpKernel *const eighttap = vp9_filter_kernels[EIGHTTAP_SHARP];\n  const int kNumTests = 5000000;\n  const int width = Width();\n  const int height = Height();\n  vpx_usec_timer timer;\n\n  SetConstantInput(127);\n\n  vpx_usec_timer_start(&timer);\n  for (int n = 0; n < kNumTests; ++n) {\n    UUT_->hv8_[1](in, kInputStride, out, kOutputStride, eighttap, 8, 16, 8, 16,\n                  width, height);\n  }\n  vpx_usec_timer_mark(&timer);\n\n  const int elapsed_time = static_cast<int>(vpx_usec_timer_elapsed(&timer));\n  printf(\"convolve8_avg_%dx%d_%d: %d us\\n\", width, height,\n         UUT_->use_highbd_ ? UUT_->use_highbd_ : 8, elapsed_time);\n}",
          "fn_code_pos": [
            [
              754,
              0
            ],
            [
              775,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ConvolveTest, Copy) {\n  uint8_t *const in = input();\n  uint8_t *const out = output();\n\n  ASM_REGISTER_STATE_CHECK(UUT_->copy_[0](in, kInputStride, out, kOutputStride,\n                                          NULL, 0, 0, 0, 0, Width(), Height()));\n\n  CheckGuardBlocks();\n\n  for (int y = 0; y < Height(); ++y) {\n    for (int x = 0; x < Width(); ++x)\n      ASSERT_EQ(lookup(out, y * kOutputStride + x),\n                lookup(in, y * kInputStride + x))\n          << \"(\" << x << \",\" << y << \")\";\n  }\n}",
          "fn_code_pos": [
            [
              777,
              0
            ],
            [
              792,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ConvolveTest, Avg) {\n  uint8_t *const in = input();\n  uint8_t *const out = output();\n  uint8_t *const out_ref = output_ref();\n  CopyOutputToRef();\n\n  ASM_REGISTER_STATE_CHECK(UUT_->copy_[1](in, kInputStride, out, kOutputStride,\n                                          NULL, 0, 0, 0, 0, Width(), Height()));\n\n  CheckGuardBlocks();\n\n  for (int y = 0; y < Height(); ++y) {\n    for (int x = 0; x < Width(); ++x)\n      ASSERT_EQ(lookup(out, y * kOutputStride + x),\n                ROUND_POWER_OF_TWO(lookup(in, y * kInputStride + x) +\n                                       lookup(out_ref, y * kOutputStride + x),\n                                   1))\n          << \"(\" << x << \",\" << y << \")\";\n  }\n}",
          "fn_code_pos": [
            [
              794,
              0
            ],
            [
              813,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ConvolveTest, CopyHoriz) {\n  uint8_t *const in = input();\n  uint8_t *const out = output();\n\n  ASM_REGISTER_STATE_CHECK(UUT_->sh8_[0](in, kInputStride, out, kOutputStride,\n                                         vp9_filter_kernels[0], 0, 16, 0, 16,\n                                         Width(), Height()));\n\n  CheckGuardBlocks();\n\n  for (int y = 0; y < Height(); ++y) {\n    for (int x = 0; x < Width(); ++x)\n      ASSERT_EQ(lookup(out, y * kOutputStride + x),\n                lookup(in, y * kInputStride + x))\n          << \"(\" << x << \",\" << y << \")\";\n  }\n}",
          "fn_code_pos": [
            [
              815,
              0
            ],
            [
              831,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ConvolveTest, CopyVert) {\n  uint8_t *const in = input();\n  uint8_t *const out = output();\n\n  ASM_REGISTER_STATE_CHECK(UUT_->sv8_[0](in, kInputStride, out, kOutputStride,\n                                         vp9_filter_kernels[0], 0, 16, 0, 16,\n                                         Width(), Height()));\n\n  CheckGuardBlocks();\n\n  for (int y = 0; y < Height(); ++y) {\n    for (int x = 0; x < Width(); ++x)\n      ASSERT_EQ(lookup(out, y * kOutputStride + x),\n                lookup(in, y * kInputStride + x))\n          << \"(\" << x << \",\" << y << \")\";\n  }\n}",
          "fn_code_pos": [
            [
              833,
              0
            ],
            [
              849,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ConvolveTest, Copy2D) {\n  uint8_t *const in = input();\n  uint8_t *const out = output();\n\n  ASM_REGISTER_STATE_CHECK(UUT_->shv8_[0](in, kInputStride, out, kOutputStride,\n                                          vp9_filter_kernels[0], 0, 16, 0, 16,\n                                          Width(), Height()));\n\n  CheckGuardBlocks();\n\n  for (int y = 0; y < Height(); ++y) {\n    for (int x = 0; x < Width(); ++x)\n      ASSERT_EQ(lookup(out, y * kOutputStride + x),\n                lookup(in, y * kInputStride + x))\n          << \"(\" << x << \",\" << y << \")\";\n  }\n}",
          "fn_code_pos": [
            [
              851,
              0
            ],
            [
              867,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(ConvolveTest, FiltersWontSaturateWhenAddedPairwise) {\n  for (int filter_bank = 0; filter_bank < kNumFilterBanks; ++filter_bank) {\n    const InterpKernel *filters =\n        vp9_filter_kernels[static_cast<INTERP_FILTER>(filter_bank)];\n    for (int i = 0; i < kNumFilters; i++) {\n      const int p0 = filters[i][0] + filters[i][1];\n      const int p1 = filters[i][2] + filters[i][3];\n      const int p2 = filters[i][4] + filters[i][5];\n      const int p3 = filters[i][6] + filters[i][7];\n      EXPECT_LE(p0, 128);\n      EXPECT_LE(p1, 128);\n      EXPECT_LE(p2, 128);\n      EXPECT_LE(p3, 128);\n      EXPECT_LE(p0 + p3, 128);\n      EXPECT_LE(p0 + p3 + p1, 128);\n      EXPECT_LE(p0 + p3 + p1 + p2, 128);\n      EXPECT_EQ(p0 + p1 + p2 + p3, 128);\n    }\n  }\n}",
          "fn_code_pos": [
            [
              872,
              0
            ],
            [
              891,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ConvolveTest, MatchesReferenceSubpixelFilter) {\n  for (int i = 0; i < 2; ++i) {\n    uint8_t *const in = input();\n    uint8_t *const out = output();\n#if CONFIG_VP9_HIGHBITDEPTH\n    uint8_t ref8[kOutputStride * kMaxDimension];\n    uint16_t ref16[kOutputStride * kMaxDimension];\n    uint8_t *ref;\n    if (UUT_->use_highbd_ == 0) {\n      ref = ref8;\n    } else {\n      ref = CAST_TO_BYTEPTR(ref16);\n    }\n#else\n    uint8_t ref[kOutputStride * kMaxDimension];\n#endif\n\n    // Populate ref and out with some random data\n    ::libvpx_test::ACMRandom prng;\n    for (int y = 0; y < Height(); ++y) {\n      for (int x = 0; x < Width(); ++x) {\n        uint16_t r;\n#if CONFIG_VP9_HIGHBITDEPTH\n        if (UUT_->use_highbd_ == 0 || UUT_->use_highbd_ == 8) {\n          r = prng.Rand8Extremes();\n        } else {\n          r = prng.Rand16() & mask_;\n        }\n#else\n        r = prng.Rand8Extremes();\n#endif\n\n        assign_val(out, y * kOutputStride + x, r);\n        assign_val(ref, y * kOutputStride + x, r);\n      }\n    }\n\n    for (int filter_bank = 0; filter_bank < kNumFilterBanks; ++filter_bank) {\n      const InterpKernel *filters =\n          vp9_filter_kernels[static_cast<INTERP_FILTER>(filter_bank)];\n\n      for (int filter_x = 0; filter_x < kNumFilters; ++filter_x) {\n        for (int filter_y = 0; filter_y < kNumFilters; ++filter_y) {\n          wrapper_filter_block2d_8[i](in, kInputStride, filters[filter_x],\n                                      filters[filter_y], ref, kOutputStride,\n                                      Width(), Height(), UUT_->use_highbd_);\n\n          if (filter_x && filter_y)\n            ASM_REGISTER_STATE_CHECK(\n                UUT_->hv8_[i](in, kInputStride, out, kOutputStride, filters,\n                              filter_x, 16, filter_y, 16, Width(), Height()));\n          else if (filter_y)\n            ASM_REGISTER_STATE_CHECK(\n                UUT_->v8_[i](in, kInputStride, out, kOutputStride, filters, 0,\n                             16, filter_y, 16, Width(), Height()));\n          else if (filter_x)\n            ASM_REGISTER_STATE_CHECK(\n                UUT_->h8_[i](in, kInputStride, out, kOutputStride, filters,\n                             filter_x, 16, 0, 16, Width(), Height()));\n          else\n            ASM_REGISTER_STATE_CHECK(UUT_->copy_[i](in, kInputStride, out,\n                                                    kOutputStride, NULL, 0, 0,\n                                                    0, 0, Width(), Height()));\n\n          CheckGuardBlocks();\n\n          for (int y = 0; y < Height(); ++y) {\n            for (int x = 0; x < Width(); ++x)\n              ASSERT_EQ(lookup(ref, y * kOutputStride + x),\n                        lookup(out, y * kOutputStride + x))\n                  << \"mismatch at (\" << x << \",\" << y << \"), \"\n                  << \"filters (\" << filter_bank << \",\" << filter_x << \",\"\n                  << filter_y << \")\";\n          }\n        }\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              897,
              0
            ],
            [
              975,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ConvolveTest, FilterExtremes) {\n  uint8_t *const in = input();\n  uint8_t *const out = output();\n#if CONFIG_VP9_HIGHBITDEPTH\n  uint8_t ref8[kOutputStride * kMaxDimension];\n  uint16_t ref16[kOutputStride * kMaxDimension];\n  uint8_t *ref;\n  if (UUT_->use_highbd_ == 0) {\n    ref = ref8;\n  } else {\n    ref = CAST_TO_BYTEPTR(ref16);\n  }\n#else\n  uint8_t ref[kOutputStride * kMaxDimension];\n#endif\n\n  // Populate ref and out with some random data\n  ::libvpx_test::ACMRandom prng;\n  for (int y = 0; y < Height(); ++y) {\n    for (int x = 0; x < Width(); ++x) {\n      uint16_t r;\n#if CONFIG_VP9_HIGHBITDEPTH\n      if (UUT_->use_highbd_ == 0 || UUT_->use_highbd_ == 8) {\n        r = prng.Rand8Extremes();\n      } else {\n        r = prng.Rand16() & mask_;\n      }\n#else\n      r = prng.Rand8Extremes();\n#endif\n      assign_val(out, y * kOutputStride + x, r);\n      assign_val(ref, y * kOutputStride + x, r);\n    }\n  }\n\n  for (int axis = 0; axis < 2; axis++) {\n    int seed_val = 0;\n    while (seed_val < 256) {\n      for (int y = 0; y < 8; ++y) {\n        for (int x = 0; x < 8; ++x) {\n#if CONFIG_VP9_HIGHBITDEPTH\n          assign_val(in, y * kOutputStride + x - SUBPEL_TAPS / 2 + 1,\n                     ((seed_val >> (axis ? y : x)) & 1) * mask_);\n#else\n          assign_val(in, y * kOutputStride + x - SUBPEL_TAPS / 2 + 1,\n                     ((seed_val >> (axis ? y : x)) & 1) * 255);\n#endif\n          if (axis) seed_val++;\n        }\n        if (axis) {\n          seed_val -= 8;\n        } else {\n          seed_val++;\n        }\n      }\n      if (axis) seed_val += 8;\n\n      for (int filter_bank = 0; filter_bank < kNumFilterBanks; ++filter_bank) {\n        const InterpKernel *filters =\n            vp9_filter_kernels[static_cast<INTERP_FILTER>(filter_bank)];\n        for (int filter_x = 0; filter_x < kNumFilters; ++filter_x) {\n          for (int filter_y = 0; filter_y < kNumFilters; ++filter_y) {\n            wrapper_filter_block2d_8_c(in, kInputStride, filters[filter_x],\n                                       filters[filter_y], ref, kOutputStride,\n                                       Width(), Height(), UUT_->use_highbd_);\n            if (filter_x && filter_y)\n              ASM_REGISTER_STATE_CHECK(\n                  UUT_->hv8_[0](in, kInputStride, out, kOutputStride, filters,\n                                filter_x, 16, filter_y, 16, Width(), Height()));\n            else if (filter_y)\n              ASM_REGISTER_STATE_CHECK(\n                  UUT_->v8_[0](in, kInputStride, out, kOutputStride, filters, 0,\n                               16, filter_y, 16, Width(), Height()));\n            else if (filter_x)\n              ASM_REGISTER_STATE_CHECK(\n                  UUT_->h8_[0](in, kInputStride, out, kOutputStride, filters,\n                               filter_x, 16, 0, 16, Width(), Height()));\n            else\n              ASM_REGISTER_STATE_CHECK(UUT_->copy_[0](in, kInputStride, out,\n                                                      kOutputStride, NULL, 0, 0,\n                                                      0, 0, Width(), Height()));\n\n            for (int y = 0; y < Height(); ++y) {\n              for (int x = 0; x < Width(); ++x)\n                ASSERT_EQ(lookup(ref, y * kOutputStride + x),\n                          lookup(out, y * kOutputStride + x))\n                    << \"mismatch at (\" << x << \",\" << y << \"), \"\n                    << \"filters (\" << filter_bank << \",\" << filter_x << \",\"\n                    << filter_y << \")\";\n            }\n          }\n        }\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              977,
              0
            ],
            [
              1072,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ConvolveTest, CheckScalingFiltering) {\n  uint8_t *const in = input();\n  uint8_t *const out = output();\n  uint8_t ref[kOutputStride * kMaxDimension];\n\n  ::libvpx_test::ACMRandom prng;\n  for (int y = 0; y < Height(); ++y) {\n    for (int x = 0; x < Width(); ++x) {\n      const uint16_t r = prng.Rand8Extremes();\n      assign_val(in, y * kInputStride + x, r);\n    }\n  }\n\n  for (int i = 0; i < 2; ++i) {\n    for (INTERP_FILTER filter_type = 0; filter_type < 4; ++filter_type) {\n      const InterpKernel *const eighttap = vp9_filter_kernels[filter_type];\n      for (int frac = 0; frac < 16; ++frac) {\n        for (int step = 1; step <= 32; ++step) {\n          /* Test the horizontal and vertical filters in combination. */\n          scaled_2d_c_funcs[i](in, kInputStride, ref, kOutputStride, eighttap,\n                               frac, step, frac, step, Width(), Height());\n          ASM_REGISTER_STATE_CHECK(\n              UUT_->shv8_[i](in, kInputStride, out, kOutputStride, eighttap,\n                             frac, step, frac, step, Width(), Height()));\n\n          CheckGuardBlocks();\n\n          for (int y = 0; y < Height(); ++y) {\n            for (int x = 0; x < Width(); ++x) {\n              ASSERT_EQ(lookup(ref, y * kOutputStride + x),\n                        lookup(out, y * kOutputStride + x))\n                  << \"x == \" << x << \", y == \" << y << \", frac == \" << frac\n                  << \", step == \" << step;\n            }\n          }\n        }\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              1080,
              0
            ],
            [
              1119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*ConvolveFunc)(const uint8_t *src, ptrdiff_t src_stride,\n                             uint8_t *dst, ptrdiff_t dst_stride,\n                             const InterpKernel *filter, int x0_q4,\n                             int x_step_q4, int y0_q4, int y_step_q4, int w,\n                             int h)",
          "fn_dec_pos": [
            [
              34,
              13
            ],
            [
              38,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "src": "uint8_t",
              "src_stride": "ptrdiff_t",
              "dst": "uint8_t",
              "dst_stride": "ptrdiff_t",
              "filter": "InterpKernel",
              "x0_q4": "int",
              "x_step_q4": "int",
              "y0_q4": "int",
              "y_step_q4": "int",
              "w": "int",
              "h": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*WrapperFilterBlock2d8Func)(\n    const uint8_t *src_ptr, const unsigned int src_stride,\n    const int16_t *hfilter, const int16_t *vfilter, uint8_t *dst_ptr,\n    unsigned int dst_stride, unsigned int output_width,\n    unsigned int output_height, int use_highbd)",
          "fn_dec_pos": [
            [
              40,
              13
            ],
            [
              44,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "src_ptr": "uint8_t",
              "src_stride": "unsigned int",
              "hfilter": "int16_t",
              "vfilter": "int16_t",
              "dst_ptr": "uint8_t",
              "dst_stride": "unsigned int",
              "output_width": "unsigned int",
              "output_height": "unsigned int",
              "use_highbd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "input() const",
          "fn_dec_pos": [
            [
              468,
              11
            ],
            [
              468,
              24
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "input",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "output() const",
          "fn_dec_pos": [
            [
              481,
              11
            ],
            [
              481,
              25
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "output",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "output_ref() const",
          "fn_dec_pos": [
            [
              494,
              11
            ],
            [
              494,
              29
            ]
          ],
          "class_code": "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012",
          "class_node_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "output_ref",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "[i](in, kInputStride, ref, kOutputStride, eighttap,\n                               frac, step, frac, step, Width(), Height())",
          "fn_dec_pos": [
            [
              1099,
              27
            ],
            [
              1100,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "scaled_2d_c_funcs"
          }
        }
      ],
      "class_node_list": {
        "5b46d65dae84092c421a3bc8cca27a66dc95e74d34143026c5be262c4feb6012": {
          "class_code": "class ConvolveTest : public ::testing::TestWithParam<ConvolveParam> {\n public:\n  static void SetUpTestCase() {\n    // Force input_ to be unaligned, output to be 16 byte aligned.\n    input_ = reinterpret_cast<uint8_t *>(\n                 vpx_memalign(kDataAlignment, kInputBufferSize + 1)) +\n             1;\n    output_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kOutputBufferSize));\n    output_ref_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kOutputBufferSize));\n#if CONFIG_VP9_HIGHBITDEPTH\n    input16_ = reinterpret_cast<uint16_t *>(vpx_memalign(\n                   kDataAlignment, (kInputBufferSize + 1) * sizeof(uint16_t))) +\n               1;\n    output16_ = reinterpret_cast<uint16_t *>(\n        vpx_memalign(kDataAlignment, (kOutputBufferSize) * sizeof(uint16_t)));\n    output16_ref_ = reinterpret_cast<uint16_t *>(\n        vpx_memalign(kDataAlignment, (kOutputBufferSize) * sizeof(uint16_t)));\n#endif\n  }\n\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n  static void TearDownTestCase() {\n    vpx_free(input_ - 1);\n    input_ = NULL;\n    vpx_free(output_);\n    output_ = NULL;\n    vpx_free(output_ref_);\n    output_ref_ = NULL;\n#if CONFIG_VP9_HIGHBITDEPTH\n    vpx_free(input16_ - 1);\n    input16_ = NULL;\n    vpx_free(output16_);\n    output16_ = NULL;\n    vpx_free(output16_ref_);\n    output16_ref_ = NULL;\n#endif\n  }\n\n protected:\n  static const int kDataAlignment = 16;\n  static const int kOuterBlockSize = 256;\n  static const int kInputStride = kOuterBlockSize;\n  static const int kOutputStride = kOuterBlockSize;\n  static const int kInputBufferSize = kOuterBlockSize * kOuterBlockSize;\n  static const int kOutputBufferSize = kOuterBlockSize * kOuterBlockSize;\n\n  int Width() const { return GET_PARAM(0); }\n  int Height() const { return GET_PARAM(1); }\n  int BorderLeft() const {\n    const int center = (kOuterBlockSize - Width()) / 2;\n    return (center + (kDataAlignment - 1)) & ~(kDataAlignment - 1);\n  }\n  int BorderTop() const { return (kOuterBlockSize - Height()) / 2; }\n\n  bool IsIndexInBorder(int i) {\n    return (i < BorderTop() * kOuterBlockSize ||\n            i >= (BorderTop() + Height()) * kOuterBlockSize ||\n            i % kOuterBlockSize < BorderLeft() ||\n            i % kOuterBlockSize >= (BorderLeft() + Width()));\n  }\n\n  virtual void SetUp() {\n    UUT_ = GET_PARAM(2);\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (UUT_->use_highbd_ != 0) {\n      mask_ = (1 << UUT_->use_highbd_) - 1;\n    } else {\n      mask_ = 255;\n    }\n#endif\n    /* Set up guard blocks for an inner block centered in the outer block */\n    for (int i = 0; i < kOutputBufferSize; ++i) {\n      if (IsIndexInBorder(i)) {\n        output_[i] = 255;\n#if CONFIG_VP9_HIGHBITDEPTH\n        output16_[i] = mask_;\n#endif\n      } else {\n        output_[i] = 0;\n#if CONFIG_VP9_HIGHBITDEPTH\n        output16_[i] = 0;\n#endif\n      }\n    }\n\n    ::libvpx_test::ACMRandom prng;\n    for (int i = 0; i < kInputBufferSize; ++i) {\n      if (i & 1) {\n        input_[i] = 255;\n#if CONFIG_VP9_HIGHBITDEPTH\n        input16_[i] = mask_;\n#endif\n      } else {\n        input_[i] = prng.Rand8Extremes();\n#if CONFIG_VP9_HIGHBITDEPTH\n        input16_[i] = prng.Rand16() & mask_;\n#endif\n      }\n    }\n  }\n\n  void SetConstantInput(int value) {\n    memset(input_, value, kInputBufferSize);\n#if CONFIG_VP9_HIGHBITDEPTH\n    vpx_memset16(input16_, value, kInputBufferSize);\n#endif\n  }\n\n  void CopyOutputToRef() {\n    memcpy(output_ref_, output_, kOutputBufferSize);\n#if CONFIG_VP9_HIGHBITDEPTH\n    memcpy(output16_ref_, output16_,\n           kOutputBufferSize * sizeof(output16_ref_[0]));\n#endif\n  }\n\n  void CheckGuardBlocks() {\n    for (int i = 0; i < kOutputBufferSize; ++i) {\n      if (IsIndexInBorder(i)) {\n        EXPECT_EQ(255, output_[i]);\n      }\n    }\n  }\n\n  uint8_t *input() const {\n    const int offset = BorderTop() * kOuterBlockSize + BorderLeft();\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (UUT_->use_highbd_ == 0) {\n      return input_ + offset;\n    } else {\n      return CAST_TO_BYTEPTR(input16_ + offset);\n    }\n#else\n    return input_ + offset;\n#endif\n  }\n\n  uint8_t *output() const {\n    const int offset = BorderTop() * kOuterBlockSize + BorderLeft();\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (UUT_->use_highbd_ == 0) {\n      return output_ + offset;\n    } else {\n      return CAST_TO_BYTEPTR(output16_ + offset);\n    }\n#else\n    return output_ + offset;\n#endif\n  }\n\n  uint8_t *output_ref() const {\n    const int offset = BorderTop() * kOuterBlockSize + BorderLeft();\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (UUT_->use_highbd_ == 0) {\n      return output_ref_ + offset;\n    } else {\n      return CAST_TO_BYTEPTR(output16_ref_ + offset);\n    }\n#else\n    return output_ref_ + offset;\n#endif\n  }\n\n  uint16_t lookup(uint8_t *list, int index) const {\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (UUT_->use_highbd_ == 0) {\n      return list[index];\n    } else {\n      return CAST_TO_SHORTPTR(list)[index];\n    }\n#else\n    return list[index];\n#endif\n  }\n\n  void assign_val(uint8_t *list, int index, uint16_t val) const {\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (UUT_->use_highbd_ == 0) {\n      list[index] = (uint8_t)val;\n    } else {\n      CAST_TO_SHORTPTR(list)[index] = val;\n    }\n#else\n    list[index] = (uint8_t)val;\n#endif\n  }\n\n  const ConvolveFunctions *UUT_;\n  static uint8_t *input_;\n  static uint8_t *output_;\n  static uint8_t *output_ref_;\n#if CONFIG_VP9_HIGHBITDEPTH\n  static uint16_t *input16_;\n  static uint16_t *output16_;\n  static uint16_t *output16_ref_;\n  int mask_;\n#endif\n}",
          "class_name": "ConvolveTest",
          "class_pos": [
            [
              341,
              0
            ],
            [
              541,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct ConvolveFunctions {\n  ConvolveFunctions(ConvolveFunc copy, ConvolveFunc avg, ConvolveFunc h8,\n                    ConvolveFunc h8_avg, ConvolveFunc v8, ConvolveFunc v8_avg,\n                    ConvolveFunc hv8, ConvolveFunc hv8_avg, ConvolveFunc sh8,\n                    ConvolveFunc sh8_avg, ConvolveFunc sv8,\n                    ConvolveFunc sv8_avg, ConvolveFunc shv8,\n                    ConvolveFunc shv8_avg, int bd)\n      : use_highbd_(bd) {\n    copy_[0] = copy;\n    copy_[1] = avg;\n    h8_[0] = h8;\n    h8_[1] = h8_avg;\n    v8_[0] = v8;\n    v8_[1] = v8_avg;\n    hv8_[0] = hv8;\n    hv8_[1] = hv8_avg;\n    sh8_[0] = sh8;\n    sh8_[1] = sh8_avg;\n    sv8_[0] = sv8;\n    sv8_[1] = sv8_avg;\n    shv8_[0] = shv8;\n    shv8_[1] = shv8_avg;\n  }\n\n  ConvolveFunc copy_[2];\n  ConvolveFunc h8_[2];\n  ConvolveFunc v8_[2];\n  ConvolveFunc hv8_[2];\n  ConvolveFunc sh8_[2];   // scaled horiz\n  ConvolveFunc sv8_[2];   // scaled vert\n  ConvolveFunc shv8_[2];  // scaled horiz/vert\n  int use_highbd_;  // 0 if high bitdepth not used, else the actual bit depth.\n}",
          {
            "copy_[2]": "ConvolveFunc",
            "h8_[2]": "ConvolveFunc",
            "v8_[2]": "ConvolveFunc",
            "hv8_[2]": "ConvolveFunc",
            "sh8_[2]": "ConvolveFunc",
            "sv8_[2]": "ConvolveFunc",
            "shv8_[2]": "ConvolveFunc",
            "use_highbd_": "int"
          },
          "ConvolveFunctions",
          [
            46,
            0
          ],
          [
            78,
            1
          ]
        ],
        [
          "struct ConvolveFunctions {\n  ConvolveFunctions(ConvolveFunc copy, ConvolveFunc avg, ConvolveFunc h8,\n                    ConvolveFunc h8_avg, ConvolveFunc v8, ConvolveFunc v8_avg,\n                    ConvolveFunc hv8, ConvolveFunc hv8_avg, ConvolveFunc sh8,\n                    ConvolveFunc sh8_avg, ConvolveFunc sv8,\n                    ConvolveFunc sv8_avg, ConvolveFunc shv8,\n                    ConvolveFunc shv8_avg, int bd)\n      : use_highbd_(bd) {\n    copy_[0] = copy;\n    copy_[1] = avg;\n    h8_[0] = h8;\n    h8_[1] = h8_avg;\n    v8_[0] = v8;\n    v8_[1] = v8_avg;\n    hv8_[0] = hv8;\n    hv8_[1] = hv8_avg;\n    sh8_[0] = sh8;\n    sh8_[1] = sh8_avg;\n    sv8_[0] = sv8;\n    sv8_[1] = sv8_avg;\n    shv8_[0] = shv8;\n    shv8_[1] = shv8_avg;\n  }\n\n  ConvolveFunc copy_[2];\n  ConvolveFunc h8_[2];\n  ConvolveFunc v8_[2];\n  ConvolveFunc hv8_[2];\n  ConvolveFunc sh8_[2];   // scaled horiz\n  ConvolveFunc sv8_[2];   // scaled vert\n  ConvolveFunc shv8_[2];  // scaled horiz/vert\n  int use_highbd_;  // 0 if high bitdepth not used, else the actual bit depth.\n}",
          {
            "copy_[2]": "ConvolveFunc",
            "h8_[2]": "ConvolveFunc",
            "v8_[2]": "ConvolveFunc",
            "hv8_[2]": "ConvolveFunc",
            "sh8_[2]": "ConvolveFunc",
            "sv8_[2]": "ConvolveFunc",
            "shv8_[2]": "ConvolveFunc",
            "use_highbd_": "int"
          },
          "ConvolveFunctions",
          [
            46,
            0
          ],
          [
            78,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include <string.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"./vp9_rtcd.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_common.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_filter.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"vpx_dsp/vpx_dsp_common.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"vpx_dsp/vpx_filter.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"vpx_ports/mem.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"vpx_ports/vpx_timer.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/user_priv_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "void CheckUserPrivateData(void *user_priv, int *target) {\n  // actual pointer value should be the same as expected.\n  EXPECT_EQ(reinterpret_cast<void *>(target), user_priv)\n      << \"user_priv pointer value does not match.\";\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              38,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckUserPrivateData",
            "parameters": {
              "user_priv": "void",
              "target": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "string DecodeFile(const string &filename) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  libvpx_test::WebMVideoSource video(filename);\n  video.Init();\n\n  vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n  libvpx_test::VP9Decoder decoder(cfg, 0);\n\n  libvpx_test::MD5 md5;\n  int frame_num = 0;\n  for (video.Begin(); !::testing::Test::HasFailure() && video.cxdata();\n       video.Next()) {\n    void *user_priv = reinterpret_cast<void *>(&frame_num);\n    const vpx_codec_err_t res =\n        decoder.DecodeFrame(video.cxdata(), video.frame_size(),\n                            (frame_num == 0) ? NULL : user_priv);\n    if (res != VPX_CODEC_OK) {\n      EXPECT_EQ(VPX_CODEC_OK, res) << decoder.DecodeError();\n      break;\n    }\n    libvpx_test::DxDataIterator dec_iter = decoder.GetDxData();\n    const vpx_image_t *img = NULL;\n\n    // Get decompressed data.\n    while ((img = dec_iter.Next())) {\n      if (frame_num == 0) {\n        CheckUserPrivateData(img->user_priv, NULL);\n      } else {\n        CheckUserPrivateData(img->user_priv, &frame_num);\n\n        // Also test ctrl_get_reference api.\n        struct vp9_ref_frame ref = vp9_ref_frame();\n        // Randomly fetch a reference frame.\n        ref.idx = rnd.Rand8() % 3;\n        decoder.Control(VP9_GET_REFERENCE, &ref);\n\n        CheckUserPrivateData(ref.img.user_priv, NULL);\n      }\n      md5.Add(img);\n    }\n\n    frame_num++;\n  }\n  return string(md5.Get());\n}",
          "fn_code_pos": [
            [
              44,
              0
            ],
            [
              88,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DecodeFile",
            "parameters": {
              "filename": "string"
            },
            "return_type": "string"
          }
        },
        {
          "fn_code": "TEST(UserPrivTest, VideoDecode) {\n  // no tiles or frame parallel; this exercises the decoding to test the\n  // user_priv.\n  EXPECT_STREQ(\"b35a1b707b28e82be025d960aba039bc\",\n               DecodeFile(\"vp90-2-03-size-226x226.webm\").c_str());\n}",
          "fn_code_pos": [
            [
              90,
              0
            ],
            [
              95,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              45,
              12
            ],
            [
              45,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "video(filename)",
          "fn_dec_pos": [
            [
              46,
              31
            ],
            [
              46,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "video",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct vp9_ref_frame",
          {},
          "",
          [
            75,
            8
          ],
          [
            75,
            28
          ]
        ]
      ],
      "include_list": [
        [
          "#include <cstdio>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <cstdlib>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/decode_test_driver.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/ivf_video_source.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/md5_helper.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"test/webm_video_source.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"vpx/vp8.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp9_subtract_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              33,
              2
            ],
            [
              33,
              62
            ]
          ],
          "class_code": "0e5849466238e9b90b97eac856dbb27fb2b1f98e4c4a1d886a1dd0497cc59af8",
          "class_node_pos": [
            [
              30,
              0
            ],
            [
              57,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void Run() {\n    GetParam()(block_height_, block_width_, diff_, block_width_, src_,\n               block_width_, pred_, block_width_);\n  }",
          "fn_code_pos": [
            [
              36,
              2
            ],
            [
              39,
              3
            ]
          ],
          "class_code": "0e5849466238e9b90b97eac856dbb27fb2b1f98e4c4a1d886a1dd0497cc59af8",
          "class_node_pos": [
            [
              30,
              0
            ],
            [
              57,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Run",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SetupBlocks(BLOCK_SIZE bsize) {\n    block_width_ = 4 * num_4x4_blocks_wide_lookup[bsize];\n    block_height_ = 4 * num_4x4_blocks_high_lookup[bsize];\n    diff_ = reinterpret_cast<int16_t *>(\n        vpx_memalign(16, sizeof(*diff_) * block_width_ * block_height_ * 2));\n    pred_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(16, block_width_ * block_height_ * 2));\n    src_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(16, block_width_ * block_height_ * 2));\n  }",
          "fn_code_pos": [
            [
              41,
              2
            ],
            [
              50,
              3
            ]
          ],
          "class_code": "0e5849466238e9b90b97eac856dbb27fb2b1f98e4c4a1d886a1dd0497cc59af8",
          "class_node_pos": [
            [
              30,
              0
            ],
            [
              57,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetupBlocks",
            "parameters": {
              "bsize": "BLOCK_SIZE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(VP9SubtractBlockTest, DISABLED_Speed) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n\n  for (BLOCK_SIZE bsize = BLOCK_4X4; bsize < BLOCK_SIZES;\n       bsize = static_cast<BLOCK_SIZE>(static_cast<int>(bsize) + 1)) {\n    SetupBlocks(bsize);\n\n    RunNTimes(100000000 / (block_height_ * block_width_));\n    char block_size[16];\n    snprintf(block_size, sizeof(block_size), \"%dx%d\", block_height_,\n             block_width_);\n    char title[100];\n    snprintf(title, sizeof(title), \"%8s \", block_size);\n    PrintMedian(title);\n\n    vpx_free(diff_);\n    vpx_free(pred_);\n    vpx_free(src_);\n  }\n}",
          "fn_code_pos": [
            [
              61,
              0
            ],
            [
              80,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VP9SubtractBlockTest, SimpleSubtract) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n\n  for (BLOCK_SIZE bsize = BLOCK_4X4; bsize < BLOCK_SIZES;\n       bsize = static_cast<BLOCK_SIZE>(static_cast<int>(bsize) + 1)) {\n    SetupBlocks(bsize);\n\n    for (int n = 0; n < 100; n++) {\n      for (int r = 0; r < block_height_; ++r) {\n        for (int c = 0; c < block_width_ * 2; ++c) {\n          src_[r * block_width_ * 2 + c] = rnd.Rand8();\n          pred_[r * block_width_ * 2 + c] = rnd.Rand8();\n        }\n      }\n\n      GetParam()(block_height_, block_width_, diff_, block_width_, src_,\n                 block_width_, pred_, block_width_);\n\n      for (int r = 0; r < block_height_; ++r) {\n        for (int c = 0; c < block_width_; ++c) {\n          EXPECT_EQ(diff_[r * block_width_ + c],\n                    (src_[r * block_width_ + c] - pred_[r * block_width_ + c]))\n              << \"r = \" << r << \", c = \" << c\n              << \", bs = \" << static_cast<int>(bsize);\n        }\n      }\n\n      GetParam()(block_height_, block_width_, diff_, block_width_ * 2, src_,\n                 block_width_ * 2, pred_, block_width_ * 2);\n\n      for (int r = 0; r < block_height_; ++r) {\n        for (int c = 0; c < block_width_; ++c) {\n          EXPECT_EQ(diff_[r * block_width_ * 2 + c],\n                    (src_[r * block_width_ * 2 + c] -\n                     pred_[r * block_width_ * 2 + c]))\n              << \"r = \" << r << \", c = \" << c\n              << \", bs = \" << static_cast<int>(bsize);\n        }\n      }\n    }\n    vpx_free(diff_);\n    vpx_free(pred_);\n    vpx_free(src_);\n  }\n}",
          "fn_code_pos": [
            [
              82,
              0
            ],
            [
              126,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*SubtractFunc)(int rows, int cols, int16_t *diff_ptr,\n                             ptrdiff_t diff_stride, const uint8_t *src_ptr,\n                             ptrdiff_t src_stride, const uint8_t *pred_ptr,\n                             ptrdiff_t pred_stride)",
          "fn_dec_pos": [
            [
              23,
              13
            ],
            [
              26,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "rows": "int",
              "cols": "int",
              "diff_ptr": "int16_t",
              "diff_stride": "ptrdiff_t",
              "src_ptr": "uint8_t",
              "src_stride": "ptrdiff_t",
              "pred_ptr": "uint8_t",
              "pred_stride": "ptrdiff_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              62,
              12
            ],
            [
              62,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              83,
              12
            ],
            [
              83,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        }
      ],
      "class_node_list": {
        "0e5849466238e9b90b97eac856dbb27fb2b1f98e4c4a1d886a1dd0497cc59af8": {
          "class_code": "class VP9SubtractBlockTest : public AbstractBench,\n                             public ::testing::TestWithParam<SubtractFunc> {\n public:\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  virtual void Run() {\n    GetParam()(block_height_, block_width_, diff_, block_width_, src_,\n               block_width_, pred_, block_width_);\n  }\n\n  void SetupBlocks(BLOCK_SIZE bsize) {\n    block_width_ = 4 * num_4x4_blocks_wide_lookup[bsize];\n    block_height_ = 4 * num_4x4_blocks_high_lookup[bsize];\n    diff_ = reinterpret_cast<int16_t *>(\n        vpx_memalign(16, sizeof(*diff_) * block_width_ * block_height_ * 2));\n    pred_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(16, block_width_ * block_height_ * 2));\n    src_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(16, block_width_ * block_height_ * 2));\n  }\n\n  int block_width_;\n  int block_height_;\n  int16_t *diff_;\n  uint8_t *pred_;\n  uint8_t *src_;\n}",
          "class_name": "VP9SubtractBlockTest",
          "class_pos": [
            [
              30,
              0
            ],
            [
              57,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"./vp9_rtcd.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/bench.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_blockd.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"vpx_ports/msvc.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/level_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "LevelTest()\n      : EncoderTest(GET_PARAM(0)), encoding_mode_(GET_PARAM(1)),\n        cpu_used_(GET_PARAM(2)), min_gf_internal_(24), target_level_(0),\n        level_(0) {}",
          "fn_code_pos": [
            [
              20,
              2
            ],
            [
              23,
              20
            ]
          ],
          "class_code": "d1867e6cd65bcdd40aeceb06a7611d3936d50a32f40c0417efde27d627a43743",
          "class_node_pos": [
            [
              16,
              0
            ],
            [
              66,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "LevelTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~LevelTest() {}",
          "fn_code_pos": [
            [
              24,
              2
            ],
            [
              24,
              25
            ]
          ],
          "class_code": "d1867e6cd65bcdd40aeceb06a7611d3936d50a32f40c0417efde27d627a43743",
          "class_node_pos": [
            [
              16,
              0
            ],
            [
              66,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n    if (encoding_mode_ != ::libvpx_test::kRealTime) {\n      cfg_.g_lag_in_frames = 25;\n      cfg_.rc_end_usage = VPX_VBR;\n    } else {\n      cfg_.g_lag_in_frames = 0;\n      cfg_.rc_end_usage = VPX_CBR;\n    }\n    cfg_.rc_2pass_vbr_minsection_pct = 5;\n    cfg_.rc_2pass_vbr_maxsection_pct = 2000;\n    cfg_.rc_target_bitrate = 400;\n    cfg_.rc_max_quantizer = 63;\n    cfg_.rc_min_quantizer = 0;\n  }",
          "fn_code_pos": [
            [
              26,
              2
            ],
            [
              41,
              3
            ]
          ],
          "class_code": "d1867e6cd65bcdd40aeceb06a7611d3936d50a32f40c0417efde27d627a43743",
          "class_node_pos": [
            [
              16,
              0
            ],
            [
              66,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, cpu_used_);\n      encoder->Control(VP9E_SET_TARGET_LEVEL, target_level_);\n      encoder->Control(VP9E_SET_MIN_GF_INTERVAL, min_gf_internal_);\n      if (encoding_mode_ != ::libvpx_test::kRealTime) {\n        encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n        encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n        encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n        encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n      }\n    }\n    encoder->Control(VP9E_GET_LEVEL, &level_);\n    ASSERT_LE(level_, 51);\n    ASSERT_GE(level_, 0);\n  }",
          "fn_code_pos": [
            [
              43,
              2
            ],
            [
              59,
              3
            ]
          ],
          "class_code": "d1867e6cd65bcdd40aeceb06a7611d3936d50a32f40c0417efde27d627a43743",
          "class_node_pos": [
            [
              16,
              0
            ],
            [
              66,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(LevelTest, TestTargetLevel11Large) {\n  ASSERT_NE(encoding_mode_, ::libvpx_test::kRealTime);\n  ::libvpx_test::I420VideoSource video(\"hantro_odd.yuv\", 208, 144, 30, 1, 0,\n                                       60);\n  target_level_ = 11;\n  cfg_.rc_target_bitrate = 150;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(target_level_, level_);\n}",
          "fn_code_pos": [
            [
              68,
              0
            ],
            [
              76,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(LevelTest, TestTargetLevel20Large) {\n  ASSERT_NE(encoding_mode_, ::libvpx_test::kRealTime);\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 60);\n  target_level_ = 20;\n  cfg_.rc_target_bitrate = 1200;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(target_level_, level_);\n}",
          "fn_code_pos": [
            [
              78,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(LevelTest, TestTargetLevel31Large) {\n  ASSERT_NE(encoding_mode_, ::libvpx_test::kRealTime);\n  ::libvpx_test::I420VideoSource video(\"niklas_1280_720_30.y4m\", 1280, 720, 30,\n                                       1, 0, 60);\n  target_level_ = 31;\n  cfg_.rc_target_bitrate = 8000;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(target_level_, level_);\n}",
          "fn_code_pos": [
            [
              88,
              0
            ],
            [
              96,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(LevelTest, TestTargetLevel0) {\n  ::libvpx_test::I420VideoSource video(\"hantro_odd.yuv\", 208, 144, 30, 1, 0,\n                                       40);\n  target_level_ = 0;\n  min_gf_internal_ = 4;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(11, level_);\n\n  cfg_.rc_target_bitrate = 1600;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(20, level_);\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              110,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(LevelTest, TestTargetLevel255) {\n  ::libvpx_test::I420VideoSource video(\"hantro_odd.yuv\", 208, 144, 30, 1, 0,\n                                       30);\n  target_level_ = 255;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              113,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(LevelTest, TestTargetLevelApi) {\n  ::libvpx_test::I420VideoSource video(\"hantro_odd.yuv\", 208, 144, 30, 1, 0, 1);\n  static const vpx_codec_iface_t *codec = &vpx_codec_vp9_cx_algo;\n  vpx_codec_ctx_t enc;\n  vpx_codec_enc_cfg_t cfg;\n  EXPECT_EQ(VPX_CODEC_OK, vpx_codec_enc_config_default(codec, &cfg, 0));\n  cfg.rc_target_bitrate = 100;\n  EXPECT_EQ(VPX_CODEC_OK, vpx_codec_enc_init(&enc, codec, &cfg, 0));\n  for (int level = 0; level <= 256; ++level) {\n    if (level == 10 || level == 11 || level == 20 || level == 21 ||\n        level == 30 || level == 31 || level == 40 || level == 41 ||\n        level == 50 || level == 51 || level == 52 || level == 60 ||\n        level == 61 || level == 62 || level == 0 || level == 1 || level == 255)\n      EXPECT_EQ(VPX_CODEC_OK,\n                vpx_codec_control(&enc, VP9E_SET_TARGET_LEVEL, level));\n    else\n      EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n                vpx_codec_control(&enc, VP9E_SET_TARGET_LEVEL, level));\n  }\n  EXPECT_EQ(VPX_CODEC_OK, vpx_codec_destroy(&enc));\n}",
          "fn_code_pos": [
            [
              120,
              0
            ],
            [
              140,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "d1867e6cd65bcdd40aeceb06a7611d3936d50a32f40c0417efde27d627a43743": {
          "class_code": "class LevelTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWith2Params<libvpx_test::TestMode, int> {\n protected:\n  LevelTest()\n      : EncoderTest(GET_PARAM(0)), encoding_mode_(GET_PARAM(1)),\n        cpu_used_(GET_PARAM(2)), min_gf_internal_(24), target_level_(0),\n        level_(0) {}\n  virtual ~LevelTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n    if (encoding_mode_ != ::libvpx_test::kRealTime) {\n      cfg_.g_lag_in_frames = 25;\n      cfg_.rc_end_usage = VPX_VBR;\n    } else {\n      cfg_.g_lag_in_frames = 0;\n      cfg_.rc_end_usage = VPX_CBR;\n    }\n    cfg_.rc_2pass_vbr_minsection_pct = 5;\n    cfg_.rc_2pass_vbr_maxsection_pct = 2000;\n    cfg_.rc_target_bitrate = 400;\n    cfg_.rc_max_quantizer = 63;\n    cfg_.rc_min_quantizer = 0;\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, cpu_used_);\n      encoder->Control(VP9E_SET_TARGET_LEVEL, target_level_);\n      encoder->Control(VP9E_SET_MIN_GF_INTERVAL, min_gf_internal_);\n      if (encoding_mode_ != ::libvpx_test::kRealTime) {\n        encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n        encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n        encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n        encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n      }\n    }\n    encoder->Control(VP9E_GET_LEVEL, &level_);\n    ASSERT_LE(level_, 51);\n    ASSERT_GE(level_, 0);\n  }\n\n  ::libvpx_test::TestMode encoding_mode_;\n  int cpu_used_;\n  int min_gf_internal_;\n  int target_level_;\n  int level_;\n}",
          "class_name": "LevelTest",
          "class_pos": [
            [
              16,
              0
            ],
            [
              66,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/add_noise_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              35,
              2
            ],
            [
              35,
              62
            ]
          ],
          "class_code": "75fd1587ff8f829d5ad8e3e731af66a4538c01511b62850616a45309fb498ed5",
          "class_node_pos": [
            [
              32,
              0
            ],
            [
              37,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual ~AddNoiseTest() {}",
          "fn_code_pos": [
            [
              36,
              2
            ],
            [
              36,
              28
            ]
          ],
          "class_code": "75fd1587ff8f829d5ad8e3e731af66a4538c01511b62850616a45309fb498ed5",
          "class_node_pos": [
            [
              32,
              0
            ],
            [
              37,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "double stddev6(char a, char b, char c, char d, char e, char f) {\n  const double n = (a + b + c + d + e + f) / 6.0;\n  const double v = ((a - n) * (a - n) + (b - n) * (b - n) + (c - n) * (c - n) +\n                    (d - n) * (d - n) + (e - n) * (e - n) + (f - n) * (f - n)) /\n                   6.0;\n  return sqrt(v);\n}",
          "fn_code_pos": [
            [
              39,
              0
            ],
            [
              45,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "stddev6",
            "parameters": {
              "a": "char",
              "b": "char",
              "c": "char",
              "d": "char",
              "e": "char",
              "f": "char"
            },
            "return_type": "double"
          }
        },
        {
          "fn_code": "TEST_P(AddNoiseTest, CheckNoiseAdded) {\n  const int width = 64;\n  const int height = 64;\n  const int image_size = width * height;\n  int8_t noise[kNoiseSize];\n  const int clamp = vpx_setup_noise(GET_PARAM(0), noise, kNoiseSize);\n  uint8_t *const s =\n      reinterpret_cast<uint8_t *>(vpx_calloc(image_size, sizeof(*s)));\n  ASSERT_TRUE(s != NULL);\n  memset(s, 99, image_size * sizeof(*s));\n\n  ASM_REGISTER_STATE_CHECK(\n      GET_PARAM(1)(s, noise, clamp, clamp, width, height, width));\n\n  // Check to make sure we don't end up having either the same or no added\n  // noise either vertically or horizontally.\n  for (int i = 0; i < image_size - 6 * width - 6; ++i) {\n    const double hd = stddev6(s[i] - 99, s[i + 1] - 99, s[i + 2] - 99,\n                              s[i + 3] - 99, s[i + 4] - 99, s[i + 5] - 99);\n    const double vd = stddev6(s[i] - 99, s[i + width] - 99,\n                              s[i + 2 * width] - 99, s[i + 3 * width] - 99,\n                              s[i + 4 * width] - 99, s[i + 5 * width] - 99);\n\n    EXPECT_NE(hd, 0);\n    EXPECT_NE(vd, 0);\n  }\n\n  // Initialize pixels in the image to 255 and check for roll over.\n  memset(s, 255, image_size);\n\n  ASM_REGISTER_STATE_CHECK(\n      GET_PARAM(1)(s, noise, clamp, clamp, width, height, width));\n\n  // Check to make sure don't roll over.\n  for (int i = 0; i < image_size; ++i) {\n    EXPECT_GT(static_cast<int>(s[i]), clamp) << \"i = \" << i;\n  }\n\n  // Initialize pixels in the image to 0 and check for roll under.\n  memset(s, 0, image_size);\n\n  ASM_REGISTER_STATE_CHECK(\n      GET_PARAM(1)(s, noise, clamp, clamp, width, height, width));\n\n  // Check to make sure don't roll under.\n  for (int i = 0; i < image_size; ++i) {\n    EXPECT_LT(static_cast<int>(s[i]), 255 - clamp) << \"i = \" << i;\n  }\n\n  vpx_free(s);\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(AddNoiseTest, CheckCvsAssembly) {\n  const int width = 64;\n  const int height = 64;\n  const int image_size = width * height;\n  int8_t noise[kNoiseSize];\n  const int clamp = vpx_setup_noise(4.4, noise, kNoiseSize);\n\n  uint8_t *const s = reinterpret_cast<uint8_t *>(vpx_calloc(image_size, 1));\n  uint8_t *const d = reinterpret_cast<uint8_t *>(vpx_calloc(image_size, 1));\n  ASSERT_TRUE(s != NULL);\n  ASSERT_TRUE(d != NULL);\n\n  memset(s, 99, image_size);\n  memset(d, 99, image_size);\n\n  srand(0);\n  ASM_REGISTER_STATE_CHECK(\n      GET_PARAM(1)(s, noise, clamp, clamp, width, height, width));\n  srand(0);\n  ASM_REGISTER_STATE_CHECK(\n      vpx_plane_add_noise_c(d, noise, clamp, clamp, width, height, width));\n\n  for (int i = 0; i < image_size; ++i) {\n    EXPECT_EQ(static_cast<int>(s[i]), static_cast<int>(d[i])) << \"i = \" << i;\n  }\n\n  vpx_free(d);\n  vpx_free(s);\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              127,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*AddNoiseFunc)(uint8_t *start, const int8_t *noise,\n                             int blackclamp, int whiteclamp, int width,\n                             int height, int pitch)",
          "fn_dec_pos": [
            [
              26,
              13
            ],
            [
              28,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "start": "uint8_t",
              "noise": "int8_t",
              "blackclamp": "int",
              "whiteclamp": "int",
              "width": "int",
              "height": "int",
              "pitch": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {
        "75fd1587ff8f829d5ad8e3e731af66a4538c01511b62850616a45309fb498ed5": {
          "class_code": "class AddNoiseTest : public ::testing::Test,\n                     public ::testing::WithParamInterface<AddNoiseTestFPParam> {\n public:\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n  virtual ~AddNoiseTest() {}\n}",
          "class_name": "AddNoiseTest",
          "class_pos": [
            [
              32,
              0
            ],
            [
              37,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <math.h>\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"vpx_dsp/postproc.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/test_vectors.cc": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"test/test_vectors.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/alt_ref_aq_segment_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "AltRefAqSegmentTest() : EncoderTest(GET_PARAM(0)) {}",
          "fn_code_pos": [
            [
              21,
              2
            ],
            [
              21,
              54
            ]
          ],
          "class_code": "6fb39a50f9c935e1819847fc228b35e07fe76f59a7ffcbe687feceed8da43260",
          "class_node_pos": [
            [
              17,
              0
            ],
            [
              45,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "AltRefAqSegmentTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~AltRefAqSegmentTest() {}",
          "fn_code_pos": [
            [
              22,
              2
            ],
            [
              22,
              35
            ]
          ],
          "class_code": "6fb39a50f9c935e1819847fc228b35e07fe76f59a7ffcbe687feceed8da43260",
          "class_node_pos": [
            [
              17,
              0
            ],
            [
              45,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n    set_cpu_used_ = GET_PARAM(2);\n    aq_mode_ = 0;\n    alt_ref_aq_mode_ = 0;\n  }",
          "fn_code_pos": [
            [
              24,
              2
            ],
            [
              30,
              3
            ]
          ],
          "class_code": "6fb39a50f9c935e1819847fc228b35e07fe76f59a7ffcbe687feceed8da43260",
          "class_node_pos": [
            [
              17,
              0
            ],
            [
              45,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n      encoder->Control(VP9E_SET_ALT_REF_AQ, alt_ref_aq_mode_);\n      encoder->Control(VP9E_SET_AQ_MODE, aq_mode_);\n      encoder->Control(VP8E_SET_MAX_INTRA_BITRATE_PCT, 100);\n    }\n  }",
          "fn_code_pos": [
            [
              32,
              2
            ],
            [
              40,
              3
            ]
          ],
          "class_code": "6fb39a50f9c935e1819847fc228b35e07fe76f59a7ffcbe687feceed8da43260",
          "class_node_pos": [
            [
              17,
              0
            ],
            [
              45,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(AltRefAqSegmentTest, TestNoMisMatchAltRefAQ0) {\n  cfg_.rc_min_quantizer = 8;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_VBR;\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_target_bitrate = 300;\n\n  aq_mode_ = 0;\n  alt_ref_aq_mode_ = 1;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 100);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              50,
              0
            ],
            [
              66,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(AltRefAqSegmentTest, TestNoMisMatchAltRefAQ1) {\n  cfg_.rc_min_quantizer = 8;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_VBR;\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_target_bitrate = 300;\n\n  aq_mode_ = 1;\n  alt_ref_aq_mode_ = 1;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 100);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              71,
              0
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(AltRefAqSegmentTest, TestNoMisMatchAltRefAQ2) {\n  cfg_.rc_min_quantizer = 8;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_VBR;\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_target_bitrate = 300;\n\n  aq_mode_ = 2;\n  alt_ref_aq_mode_ = 1;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 100);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              92,
              0
            ],
            [
              108,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(AltRefAqSegmentTest, TestNoMisMatchAltRefAQ3) {\n  cfg_.rc_min_quantizer = 8;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_VBR;\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_target_bitrate = 300;\n\n  aq_mode_ = 3;\n  alt_ref_aq_mode_ = 1;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 100);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              113,
              0
            ],
            [
              129,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(AltRefAqSegmentTest, TestNoMisMatchAltRefAQ4) {\n  cfg_.rc_min_quantizer = 8;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_VBR;\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_target_bitrate = 300;\n\n  aq_mode_ = 4;\n  alt_ref_aq_mode_ = 1;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 100);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              134,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "6fb39a50f9c935e1819847fc228b35e07fe76f59a7ffcbe687feceed8da43260": {
          "class_code": "class AltRefAqSegmentTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWith2Params<libvpx_test::TestMode, int> {\n protected:\n  AltRefAqSegmentTest() : EncoderTest(GET_PARAM(0)) {}\n  virtual ~AltRefAqSegmentTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n    set_cpu_used_ = GET_PARAM(2);\n    aq_mode_ = 0;\n    alt_ref_aq_mode_ = 0;\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n      encoder->Control(VP9E_SET_ALT_REF_AQ, alt_ref_aq_mode_);\n      encoder->Control(VP9E_SET_AQ_MODE, aq_mode_);\n      encoder->Control(VP8E_SET_MAX_INTRA_BITRATE_PCT, 100);\n    }\n  }\n\n  int set_cpu_used_;\n  int aq_mode_;\n  int alt_ref_aq_mode_;\n}",
          "class_name": "AltRefAqSegmentTest",
          "class_pos": [
            [
              17,
              0
            ],
            [
              45,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/bench.cc": {
      "fn_def_list": [
        {
          "fn_code": "void AbstractBench::RunNTimes(int n) {\n  for (int r = 0; r < VPX_BENCH_ROBUST_ITER; r++) {\n    vpx_usec_timer timer;\n    vpx_usec_timer_start(&timer);\n    for (int j = 0; j < n; ++j) {\n      Run();\n    }\n    vpx_usec_timer_mark(&timer);\n    times_[r] = static_cast<int>(vpx_usec_timer_elapsed(&timer));\n  }\n}",
          "fn_code_pos": [
            [
              16,
              0
            ],
            [
              26,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AbstractBench::RunNTimes",
            "parameters": {
              "n": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void AbstractBench::PrintMedian(const char *title) {\n  std::sort(times_, times_ + VPX_BENCH_ROBUST_ITER);\n  const int med = times_[VPX_BENCH_ROBUST_ITER >> 1];\n  int sad = 0;\n  for (int t = 0; t < VPX_BENCH_ROBUST_ITER; t++) {\n    sad += abs(times_[t] - med);\n  }\n  printf(\"[%10s] %s %.1f ms ( \u00b1%.1f ms )\\n\", \"BENCH \", title, med / 1000.0,\n         sad / (VPX_BENCH_ROBUST_ITER * 1000.0));\n}",
          "fn_code_pos": [
            [
              28,
              0
            ],
            [
              37,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AbstractBench::PrintMedian",
            "parameters": {
              "title": "char"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <algorithm>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/bench.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"vpx_ports/vpx_timer.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/encode_perf_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "EncodePerfTestVideo(const char *name_, uint32_t width_, uint32_t height_,\n                      uint32_t bitrate_, int frames_)\n      : name(name_), width(width_), height(height_), bitrate(bitrate_),\n        frames(frames_) {}",
          "fn_code_pos": [
            [
              26,
              2
            ],
            [
              29,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EncodePerfTestVideo",
            "parameters": {
              "name_": "char",
              "width_": "uint32_t",
              "height_": "uint32_t",
              "bitrate_": "uint32_t",
              "frames_": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "VP9EncodePerfTest()\n      : EncoderTest(GET_PARAM(0)), min_psnr_(kMaxPsnr), nframes_(0),\n        encoding_mode_(GET_PARAM(1)), speed_(0), threads_(1) {}",
          "fn_code_pos": [
            [
              59,
              2
            ],
            [
              61,
              63
            ]
          ],
          "class_code": "3158acf44dd1a83c0d41d1bd07f86a814131e5b0c54e63efa4db6476df81c128",
          "class_node_pos": [
            [
              55,
              0
            ],
            [
              121,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VP9EncodePerfTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~VP9EncodePerfTest() {}",
          "fn_code_pos": [
            [
              63,
              2
            ],
            [
              63,
              33
            ]
          ],
          "class_code": "3158acf44dd1a83c0d41d1bd07f86a814131e5b0c54e63efa4db6476df81c128",
          "class_node_pos": [
            [
              55,
              0
            ],
            [
              121,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n\n    cfg_.g_lag_in_frames = 0;\n    cfg_.rc_min_quantizer = 2;\n    cfg_.rc_max_quantizer = 56;\n    cfg_.rc_dropframe_thresh = 0;\n    cfg_.rc_undershoot_pct = 50;\n    cfg_.rc_overshoot_pct = 50;\n    cfg_.rc_buf_sz = 1000;\n    cfg_.rc_buf_initial_sz = 500;\n    cfg_.rc_buf_optimal_sz = 600;\n    cfg_.rc_resize_allowed = 0;\n    cfg_.rc_end_usage = VPX_CBR;\n    cfg_.g_error_resilient = 1;\n    cfg_.g_threads = threads_;\n  }",
          "fn_code_pos": [
            [
              65,
              2
            ],
            [
              82,
              3
            ]
          ],
          "class_code": "3158acf44dd1a83c0d41d1bd07f86a814131e5b0c54e63efa4db6476df81c128",
          "class_node_pos": [
            [
              55,
              0
            ],
            [
              121,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      const int log2_tile_columns = 3;\n      encoder->Control(VP8E_SET_CPUUSED, speed_);\n      encoder->Control(VP9E_SET_TILE_COLUMNS, log2_tile_columns);\n      encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING, 1);\n      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 0);\n    }\n  }",
          "fn_code_pos": [
            [
              84,
              2
            ],
            [
              93,
              3
            ]
          ],
          "class_code": "3158acf44dd1a83c0d41d1bd07f86a814131e5b0c54e63efa4db6476df81c128",
          "class_node_pos": [
            [
              55,
              0
            ],
            [
              121,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void BeginPassHook(unsigned int /*pass*/) {\n    min_psnr_ = kMaxPsnr;\n    nframes_ = 0;\n  }",
          "fn_code_pos": [
            [
              95,
              2
            ],
            [
              98,
              3
            ]
          ],
          "class_code": "3158acf44dd1a83c0d41d1bd07f86a814131e5b0c54e63efa4db6476df81c128",
          "class_node_pos": [
            [
              55,
              0
            ],
            [
              121,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BeginPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (pkt->data.psnr.psnr[0] < min_psnr_) {\n      min_psnr_ = pkt->data.psnr.psnr[0];\n    }\n  }",
          "fn_code_pos": [
            [
              100,
              2
            ],
            [
              104,
              3
            ]
          ],
          "class_code": "3158acf44dd1a83c0d41d1bd07f86a814131e5b0c54e63efa4db6476df81c128",
          "class_node_pos": [
            [
              55,
              0
            ],
            [
              121,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PSNRPktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual bool DoDecode() const { return false; }",
          "fn_code_pos": [
            [
              107,
              2
            ],
            [
              107,
              49
            ]
          ],
          "class_code": "3158acf44dd1a83c0d41d1bd07f86a814131e5b0c54e63efa4db6476df81c128",
          "class_node_pos": [
            [
              55,
              0
            ],
            [
              121,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DoDecode",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "double min_psnr() const { return min_psnr_; }",
          "fn_code_pos": [
            [
              109,
              2
            ],
            [
              109,
              47
            ]
          ],
          "class_code": "3158acf44dd1a83c0d41d1bd07f86a814131e5b0c54e63efa4db6476df81c128",
          "class_node_pos": [
            [
              55,
              0
            ],
            [
              121,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "min_psnr",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "void set_speed(unsigned int speed) { speed_ = speed; }",
          "fn_code_pos": [
            [
              111,
              2
            ],
            [
              111,
              56
            ]
          ],
          "class_code": "3158acf44dd1a83c0d41d1bd07f86a814131e5b0c54e63efa4db6476df81c128",
          "class_node_pos": [
            [
              55,
              0
            ],
            [
              121,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "set_speed",
            "parameters": {
              "speed": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void set_threads(unsigned int threads) { threads_ = threads; }",
          "fn_code_pos": [
            [
              113,
              2
            ],
            [
              113,
              64
            ]
          ],
          "class_code": "3158acf44dd1a83c0d41d1bd07f86a814131e5b0c54e63efa4db6476df81c128",
          "class_node_pos": [
            [
              55,
              0
            ],
            [
              121,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "set_threads",
            "parameters": {
              "threads": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(VP9EncodePerfTest, PerfTest) {\n  for (size_t i = 0; i < NELEMENTS(kVP9EncodePerfTestVectors); ++i) {\n    for (size_t j = 0; j < NELEMENTS(kEncodePerfTestSpeeds); ++j) {\n      for (size_t k = 0; k < NELEMENTS(kEncodePerfTestThreads); ++k) {\n        if (kVP9EncodePerfTestVectors[i].width < 512 &&\n            kEncodePerfTestThreads[k] > 1) {\n          continue;\n        } else if (kVP9EncodePerfTestVectors[i].width < 1024 &&\n                   kEncodePerfTestThreads[k] > 2) {\n          continue;\n        }\n\n        set_threads(kEncodePerfTestThreads[k]);\n        SetUp();\n\n        const vpx_rational timebase = { 33333333, 1000000000 };\n        cfg_.g_timebase = timebase;\n        cfg_.rc_target_bitrate = kVP9EncodePerfTestVectors[i].bitrate;\n\n        init_flags_ = VPX_CODEC_USE_PSNR;\n\n        const unsigned frames = kVP9EncodePerfTestVectors[i].frames;\n        const char *video_name = kVP9EncodePerfTestVectors[i].name;\n        libvpx_test::I420VideoSource video(\n            video_name, kVP9EncodePerfTestVectors[i].width,\n            kVP9EncodePerfTestVectors[i].height, timebase.den, timebase.num, 0,\n            kVP9EncodePerfTestVectors[i].frames);\n        set_speed(kEncodePerfTestSpeeds[j]);\n\n        vpx_usec_timer t;\n        vpx_usec_timer_start(&t);\n\n        ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n        vpx_usec_timer_mark(&t);\n        const double elapsed_secs = vpx_usec_timer_elapsed(&t) / kUsecsInSec;\n        const double fps = frames / elapsed_secs;\n        const double minimum_psnr = min_psnr();\n        std::string display_name(video_name);\n        if (kEncodePerfTestThreads[k] > 1) {\n          char thread_count[32];\n          snprintf(thread_count, sizeof(thread_count), \"_t-%d\",\n                   kEncodePerfTestThreads[k]);\n          display_name += thread_count;\n        }\n\n        printf(\"{\\n\");\n        printf(\"\\t\\\"type\\\" : \\\"encode_perf_test\\\",\\n\");\n        printf(\"\\t\\\"version\\\" : \\\"%s\\\",\\n\", VERSION_STRING_NOSP);\n        printf(\"\\t\\\"videoName\\\" : \\\"%s\\\",\\n\", display_name.c_str());\n        printf(\"\\t\\\"encodeTimeSecs\\\" : %f,\\n\", elapsed_secs);\n        printf(\"\\t\\\"totalFrames\\\" : %u,\\n\", frames);\n        printf(\"\\t\\\"framesPerSecond\\\" : %f,\\n\", fps);\n        printf(\"\\t\\\"minPsnr\\\" : %f,\\n\", minimum_psnr);\n        printf(\"\\t\\\"speed\\\" : %d,\\n\", kEncodePerfTestSpeeds[j]);\n        printf(\"\\t\\\"threads\\\" : %d\\n\", kEncodePerfTestThreads[k]);\n        printf(\"}\\n\");\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              123,
              0
            ],
            [
              183,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "display_name(video_name)",
          "fn_dec_pos": [
            [
              161,
              20
            ],
            [
              161,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "display_name",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "3158acf44dd1a83c0d41d1bd07f86a814131e5b0c54e63efa4db6476df81c128": {
          "class_code": "class VP9EncodePerfTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWithParam<libvpx_test::TestMode> {\n protected:\n  VP9EncodePerfTest()\n      : EncoderTest(GET_PARAM(0)), min_psnr_(kMaxPsnr), nframes_(0),\n        encoding_mode_(GET_PARAM(1)), speed_(0), threads_(1) {}\n\n  virtual ~VP9EncodePerfTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n\n    cfg_.g_lag_in_frames = 0;\n    cfg_.rc_min_quantizer = 2;\n    cfg_.rc_max_quantizer = 56;\n    cfg_.rc_dropframe_thresh = 0;\n    cfg_.rc_undershoot_pct = 50;\n    cfg_.rc_overshoot_pct = 50;\n    cfg_.rc_buf_sz = 1000;\n    cfg_.rc_buf_initial_sz = 500;\n    cfg_.rc_buf_optimal_sz = 600;\n    cfg_.rc_resize_allowed = 0;\n    cfg_.rc_end_usage = VPX_CBR;\n    cfg_.g_error_resilient = 1;\n    cfg_.g_threads = threads_;\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      const int log2_tile_columns = 3;\n      encoder->Control(VP8E_SET_CPUUSED, speed_);\n      encoder->Control(VP9E_SET_TILE_COLUMNS, log2_tile_columns);\n      encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING, 1);\n      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 0);\n    }\n  }\n\n  virtual void BeginPassHook(unsigned int /*pass*/) {\n    min_psnr_ = kMaxPsnr;\n    nframes_ = 0;\n  }\n\n  virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (pkt->data.psnr.psnr[0] < min_psnr_) {\n      min_psnr_ = pkt->data.psnr.psnr[0];\n    }\n  }\n\n  // for performance reasons don't decode\n  virtual bool DoDecode() const { return false; }\n\n  double min_psnr() const { return min_psnr_; }\n\n  void set_speed(unsigned int speed) { speed_ = speed; }\n\n  void set_threads(unsigned int threads) { threads_ = threads; }\n\n private:\n  double min_psnr_;\n  unsigned int nframes_;\n  libvpx_test::TestMode encoding_mode_;\n  unsigned speed_;\n  unsigned int threads_;\n}",
          "class_name": "VP9EncodePerfTest",
          "class_pos": [
            [
              55,
              0
            ],
            [
              121,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct EncodePerfTestVideo {\n  EncodePerfTestVideo(const char *name_, uint32_t width_, uint32_t height_,\n                      uint32_t bitrate_, int frames_)\n      : name(name_), width(width_), height(height_), bitrate(bitrate_),\n        frames(frames_) {}\n  const char *name;\n  uint32_t width;\n  uint32_t height;\n  uint32_t bitrate;\n  int frames;\n}",
          {
            "char": "const",
            "width": "uint32_t",
            "height": "uint32_t",
            "bitrate": "uint32_t",
            "frames": "int"
          },
          "EncodePerfTestVideo",
          [
            25,
            0
          ],
          [
            35,
            1
          ]
        ],
        [
          "struct EncodePerfTestVideo {\n  EncodePerfTestVideo(const char *name_, uint32_t width_, uint32_t height_,\n                      uint32_t bitrate_, int frames_)\n      : name(name_), width(width_), height(height_), bitrate(bitrate_),\n        frames(frames_) {}\n  const char *name;\n  uint32_t width;\n  uint32_t height;\n  uint32_t bitrate;\n  int frames;\n}",
          {
            "char": "const",
            "width": "uint32_t",
            "height": "uint32_t",
            "bitrate": "uint32_t",
            "frames": "int"
          },
          "EncodePerfTestVideo",
          [
            25,
            0
          ],
          [
            35,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include <string>\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"./vpx_version.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/y4m_video_source.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"vpx_ports/vpx_timer.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/dct16x16_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "void butterfly_16x16_dct_1d(double input[16], double output[16]) {\n  double step[16];\n  double intermediate[16];\n  double temp1, temp2;\n\n  // step 1\n  step[0] = input[0] + input[15];\n  step[1] = input[1] + input[14];\n  step[2] = input[2] + input[13];\n  step[3] = input[3] + input[12];\n  step[4] = input[4] + input[11];\n  step[5] = input[5] + input[10];\n  step[6] = input[6] + input[9];\n  step[7] = input[7] + input[8];\n  step[8] = input[7] - input[8];\n  step[9] = input[6] - input[9];\n  step[10] = input[5] - input[10];\n  step[11] = input[4] - input[11];\n  step[12] = input[3] - input[12];\n  step[13] = input[2] - input[13];\n  step[14] = input[1] - input[14];\n  step[15] = input[0] - input[15];\n\n  // step 2\n  output[0] = step[0] + step[7];\n  output[1] = step[1] + step[6];\n  output[2] = step[2] + step[5];\n  output[3] = step[3] + step[4];\n  output[4] = step[3] - step[4];\n  output[5] = step[2] - step[5];\n  output[6] = step[1] - step[6];\n  output[7] = step[0] - step[7];\n\n  temp1 = step[8] * C7;\n  temp2 = step[15] * C9;\n  output[8] = temp1 + temp2;\n\n  temp1 = step[9] * C11;\n  temp2 = step[14] * C5;\n  output[9] = temp1 - temp2;\n\n  temp1 = step[10] * C3;\n  temp2 = step[13] * C13;\n  output[10] = temp1 + temp2;\n\n  temp1 = step[11] * C15;\n  temp2 = step[12] * C1;\n  output[11] = temp1 - temp2;\n\n  temp1 = step[11] * C1;\n  temp2 = step[12] * C15;\n  output[12] = temp2 + temp1;\n\n  temp1 = step[10] * C13;\n  temp2 = step[13] * C3;\n  output[13] = temp2 - temp1;\n\n  temp1 = step[9] * C5;\n  temp2 = step[14] * C11;\n  output[14] = temp2 + temp1;\n\n  temp1 = step[8] * C9;\n  temp2 = step[15] * C7;\n  output[15] = temp2 - temp1;\n\n  // step 3\n  step[0] = output[0] + output[3];\n  step[1] = output[1] + output[2];\n  step[2] = output[1] - output[2];\n  step[3] = output[0] - output[3];\n\n  temp1 = output[4] * C14;\n  temp2 = output[7] * C2;\n  step[4] = temp1 + temp2;\n\n  temp1 = output[5] * C10;\n  temp2 = output[6] * C6;\n  step[5] = temp1 + temp2;\n\n  temp1 = output[5] * C6;\n  temp2 = output[6] * C10;\n  step[6] = temp2 - temp1;\n\n  temp1 = output[4] * C2;\n  temp2 = output[7] * C14;\n  step[7] = temp2 - temp1;\n\n  step[8] = output[8] + output[11];\n  step[9] = output[9] + output[10];\n  step[10] = output[9] - output[10];\n  step[11] = output[8] - output[11];\n\n  step[12] = output[12] + output[15];\n  step[13] = output[13] + output[14];\n  step[14] = output[13] - output[14];\n  step[15] = output[12] - output[15];\n\n  // step 4\n  output[0] = (step[0] + step[1]);\n  output[8] = (step[0] - step[1]);\n\n  temp1 = step[2] * C12;\n  temp2 = step[3] * C4;\n  temp1 = temp1 + temp2;\n  output[4] = 2 * (temp1 * C8);\n\n  temp1 = step[2] * C4;\n  temp2 = step[3] * C12;\n  temp1 = temp2 - temp1;\n  output[12] = 2 * (temp1 * C8);\n\n  output[2] = 2 * ((step[4] + step[5]) * C8);\n  output[14] = 2 * ((step[7] - step[6]) * C8);\n\n  temp1 = step[4] - step[5];\n  temp2 = step[6] + step[7];\n  output[6] = (temp1 + temp2);\n  output[10] = (temp1 - temp2);\n\n  intermediate[8] = step[8] + step[14];\n  intermediate[9] = step[9] + step[15];\n\n  temp1 = intermediate[8] * C12;\n  temp2 = intermediate[9] * C4;\n  temp1 = temp1 - temp2;\n  output[3] = 2 * (temp1 * C8);\n\n  temp1 = intermediate[8] * C4;\n  temp2 = intermediate[9] * C12;\n  temp1 = temp2 + temp1;\n  output[13] = 2 * (temp1 * C8);\n\n  output[9] = 2 * ((step[10] + step[11]) * C8);\n\n  intermediate[11] = step[10] - step[11];\n  intermediate[12] = step[12] + step[13];\n  intermediate[13] = step[12] - step[13];\n  intermediate[14] = step[8] - step[14];\n  intermediate[15] = step[9] - step[15];\n\n  output[15] = (intermediate[11] + intermediate[12]);\n  output[1] = -(intermediate[11] - intermediate[12]);\n\n  output[7] = 2 * (intermediate[13] * C8);\n\n  temp1 = intermediate[14] * C12;\n  temp2 = intermediate[15] * C4;\n  temp1 = temp1 - temp2;\n  output[11] = -2 * (temp1 * C8);\n\n  temp1 = intermediate[14] * C4;\n  temp2 = intermediate[15] * C12;\n  temp1 = temp2 + temp1;\n  output[5] = 2 * (temp1 * C8);\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "butterfly_16x16_dct_1d",
            "parameters": {
              "input": "double",
              "output": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void reference_16x16_dct_2d(int16_t input[256], double output[256]) {\n  // First transform columns\n  for (int i = 0; i < 16; ++i) {\n    double temp_in[16], temp_out[16];\n    for (int j = 0; j < 16; ++j) temp_in[j] = input[j * 16 + i];\n    butterfly_16x16_dct_1d(temp_in, temp_out);\n    for (int j = 0; j < 16; ++j) output[j * 16 + i] = temp_out[j];\n  }\n  // Then transform rows\n  for (int i = 0; i < 16; ++i) {\n    double temp_in[16], temp_out[16];\n    for (int j = 0; j < 16; ++j) temp_in[j] = output[j + i * 16];\n    butterfly_16x16_dct_1d(temp_in, temp_out);\n    // Scale by some magic number\n    for (int j = 0; j < 16; ++j) output[j + i * 16] = temp_out[j] / 2;\n  }\n}",
          "fn_code_pos": [
            [
              207,
              0
            ],
            [
              223,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reference_16x16_dct_2d",
            "parameters": {
              "input": "int16_t",
              "output": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void fdct16x16_ref(const int16_t *in, tran_low_t *out, int stride,\n                   int /*tx_type*/) {\n  vpx_fdct16x16_c(in, out, stride);\n}",
          "fn_code_pos": [
            [
              236,
              0
            ],
            [
              239,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fdct16x16_ref",
            "parameters": {
              "in": "int16_t",
              "out": "tran_low_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct16x16_ref(const tran_low_t *in, uint8_t *dest, int stride,\n                   int /*tx_type*/) {\n  vpx_idct16x16_256_add_c(in, dest, stride);\n}",
          "fn_code_pos": [
            [
              241,
              0
            ],
            [
              244,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct16x16_ref",
            "parameters": {
              "in": "tran_low_t",
              "dest": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void fht16x16_ref(const int16_t *in, tran_low_t *out, int stride, int tx_type) {\n  vp9_fht16x16_c(in, out, stride, tx_type);\n}",
          "fn_code_pos": [
            [
              246,
              0
            ],
            [
              248,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fht16x16_ref",
            "parameters": {
              "in": "int16_t",
              "out": "tran_low_t",
              "stride": "int",
              "tx_type": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void iht16x16_ref(const tran_low_t *in, uint8_t *dest, int stride,\n                  int tx_type) {\n  vp9_iht16x16_256_add_c(in, dest, stride, tx_type);\n}",
          "fn_code_pos": [
            [
              250,
              0
            ],
            [
              253,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iht16x16_ref",
            "parameters": {
              "in": "tran_low_t",
              "dest": "uint8_t",
              "stride": "int",
              "tx_type": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct16x16_10(const tran_low_t *in, uint8_t *out, int stride) {\n  vpx_highbd_idct16x16_256_add_c(in, CAST_TO_SHORTPTR(out), stride, 10);\n}",
          "fn_code_pos": [
            [
              256,
              0
            ],
            [
              258,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct16x16_10",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct16x16_12(const tran_low_t *in, uint8_t *out, int stride) {\n  vpx_highbd_idct16x16_256_add_c(in, CAST_TO_SHORTPTR(out), stride, 12);\n}",
          "fn_code_pos": [
            [
              260,
              0
            ],
            [
              262,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct16x16_12",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct16x16_10_ref(const tran_low_t *in, uint8_t *out, int stride,\n                      int /*tx_type*/) {\n  idct16x16_10(in, out, stride);\n}",
          "fn_code_pos": [
            [
              264,
              0
            ],
            [
              267,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct16x16_10_ref",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct16x16_12_ref(const tran_low_t *in, uint8_t *out, int stride,\n                      int /*tx_type*/) {\n  idct16x16_12(in, out, stride);\n}",
          "fn_code_pos": [
            [
              269,
              0
            ],
            [
              272,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct16x16_12_ref",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void iht16x16_10(const tran_low_t *in, uint8_t *out, int stride, int tx_type) {\n  vp9_highbd_iht16x16_256_add_c(in, CAST_TO_SHORTPTR(out), stride, tx_type, 10);\n}",
          "fn_code_pos": [
            [
              274,
              0
            ],
            [
              276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iht16x16_10",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int",
              "tx_type": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void iht16x16_12(const tran_low_t *in, uint8_t *out, int stride, int tx_type) {\n  vp9_highbd_iht16x16_256_add_c(in, CAST_TO_SHORTPTR(out), stride, tx_type, 12);\n}",
          "fn_code_pos": [
            [
              278,
              0
            ],
            [
              280,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iht16x16_12",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int",
              "tx_type": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct16x16_10_add_10_c(const tran_low_t *in, uint8_t *out, int stride) {\n  vpx_highbd_idct16x16_10_add_c(in, CAST_TO_SHORTPTR(out), stride, 10);\n}",
          "fn_code_pos": [
            [
              283,
              0
            ],
            [
              285,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct16x16_10_add_10_c",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct16x16_10_add_12_c(const tran_low_t *in, uint8_t *out, int stride) {\n  vpx_highbd_idct16x16_10_add_c(in, CAST_TO_SHORTPTR(out), stride, 12);\n}",
          "fn_code_pos": [
            [
              287,
              0
            ],
            [
              289,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct16x16_10_add_12_c",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct16x16_256_add_10_sse2(const tran_low_t *in, uint8_t *out, int stride) {\n  vpx_highbd_idct16x16_256_add_sse2(in, CAST_TO_SHORTPTR(out), stride, 10);\n}",
          "fn_code_pos": [
            [
              291,
              0
            ],
            [
              293,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct16x16_256_add_10_sse2",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct16x16_256_add_12_sse2(const tran_low_t *in, uint8_t *out, int stride) {\n  vpx_highbd_idct16x16_256_add_sse2(in, CAST_TO_SHORTPTR(out), stride, 12);\n}",
          "fn_code_pos": [
            [
              295,
              0
            ],
            [
              297,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct16x16_256_add_12_sse2",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct16x16_10_add_10_sse2(const tran_low_t *in, uint8_t *out, int stride) {\n  vpx_highbd_idct16x16_10_add_sse2(in, CAST_TO_SHORTPTR(out), stride, 10);\n}",
          "fn_code_pos": [
            [
              299,
              0
            ],
            [
              301,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct16x16_10_add_10_sse2",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct16x16_10_add_12_sse2(const tran_low_t *in, uint8_t *out, int stride) {\n  vpx_highbd_idct16x16_10_add_sse2(in, CAST_TO_SHORTPTR(out), stride, 12);\n}",
          "fn_code_pos": [
            [
              303,
              0
            ],
            [
              305,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct16x16_10_add_12_sse2",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual ~Trans16x16TestBase() {}",
          "fn_code_pos": [
            [
              311,
              2
            ],
            [
              311,
              34
            ]
          ],
          "class_code": "0f6dd2811cdcbebdbd122f8b96733ab1cb790adcaaf7ab82287855372310a1cd",
          "class_node_pos": [
            [
              309,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) = 0;",
          "fn_code_pos": [
            [
              314,
              2
            ],
            [
              314,
              72
            ]
          ],
          "class_code": "0f6dd2811cdcbebdbd122f8b96733ab1cb790adcaaf7ab82287855372310a1cd",
          "class_node_pos": [
            [
              309,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunFwdTxfm",
            "parameters": {
              "in": "int16_t",
              "out": "tran_low_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) = 0;",
          "fn_code_pos": [
            [
              316,
              2
            ],
            [
              316,
              73
            ]
          ],
          "class_code": "0f6dd2811cdcbebdbd122f8b96733ab1cb790adcaaf7ab82287855372310a1cd",
          "class_node_pos": [
            [
              309,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunInvTxfm",
            "parameters": {
              "out": "tran_low_t",
              "dst": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunAccuracyCheck() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    uint32_t max_error = 0;\n    int64_t total_error = 0;\n    const int count_test_block = 10000;\n    for (int i = 0; i < count_test_block; ++i) {\n      DECLARE_ALIGNED(16, int16_t, test_input_block[kNumCoeffs]);\n      DECLARE_ALIGNED(16, tran_low_t, test_temp_block[kNumCoeffs]);\n      DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n      DECLARE_ALIGNED(16, uint8_t, src[kNumCoeffs]);\n#if CONFIG_VP9_HIGHBITDEPTH\n      DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n      DECLARE_ALIGNED(16, uint16_t, src16[kNumCoeffs]);\n#endif\n\n      // Initialize a test block with input range [-mask_, mask_].\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        if (bit_depth_ == VPX_BITS_8) {\n          src[j] = rnd.Rand8();\n          dst[j] = rnd.Rand8();\n          test_input_block[j] = src[j] - dst[j];\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          src16[j] = rnd.Rand16() & mask_;\n          dst16[j] = rnd.Rand16() & mask_;\n          test_input_block[j] = src16[j] - dst16[j];\n#endif\n        }\n      }\n\n      ASM_REGISTER_STATE_CHECK(\n          RunFwdTxfm(test_input_block, test_temp_block, pitch_));\n      if (bit_depth_ == VPX_BITS_8) {\n        ASM_REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        ASM_REGISTER_STATE_CHECK(\n            RunInvTxfm(test_temp_block, CAST_TO_BYTEPTR(dst16), pitch_));\n#endif\n      }\n\n      for (int j = 0; j < kNumCoeffs; ++j) {\n#if CONFIG_VP9_HIGHBITDEPTH\n        const int32_t diff =\n            bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n#else\n        const int32_t diff = dst[j] - src[j];\n#endif\n        const uint32_t error = diff * diff;\n        if (max_error < error) max_error = error;\n        total_error += error;\n      }\n    }\n\n    EXPECT_GE(1u << 2 * (bit_depth_ - 8), max_error)\n        << \"Error: 16x16 FHT/IHT has an individual round trip error > 1\";\n\n    EXPECT_GE(count_test_block << 2 * (bit_depth_ - 8), total_error)\n        << \"Error: 16x16 FHT/IHT has average round trip error > 1 per block\";\n  }",
          "fn_code_pos": [
            [
              318,
              2
            ],
            [
              377,
              3
            ]
          ],
          "class_code": "0f6dd2811cdcbebdbd122f8b96733ab1cb790adcaaf7ab82287855372310a1cd",
          "class_node_pos": [
            [
              309,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunAccuracyCheck",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunCoeffCheck() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 1000;\n    DECLARE_ALIGNED(16, int16_t, input_block[kNumCoeffs]);\n    DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);\n    DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);\n\n    for (int i = 0; i < count_test_block; ++i) {\n      // Initialize a test block with input range [-mask_, mask_].\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        input_block[j] = (rnd.Rand16() & mask_) - (rnd.Rand16() & mask_);\n      }\n\n      fwd_txfm_ref(input_block, output_ref_block, pitch_, tx_type_);\n      ASM_REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_));\n\n      // The minimum quant value is 4.\n      for (int j = 0; j < kNumCoeffs; ++j)\n        EXPECT_EQ(output_block[j], output_ref_block[j]);\n    }\n  }",
          "fn_code_pos": [
            [
              379,
              2
            ],
            [
              399,
              3
            ]
          ],
          "class_code": "0f6dd2811cdcbebdbd122f8b96733ab1cb790adcaaf7ab82287855372310a1cd",
          "class_node_pos": [
            [
              309,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunCoeffCheck",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunMemCheck() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 1000;\n    DECLARE_ALIGNED(16, int16_t, input_extreme_block[kNumCoeffs]);\n    DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);\n    DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);\n\n    for (int i = 0; i < count_test_block; ++i) {\n      // Initialize a test block with input range [-mask_, mask_].\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        input_extreme_block[j] = rnd.Rand8() % 2 ? mask_ : -mask_;\n      }\n      if (i == 0) {\n        for (int j = 0; j < kNumCoeffs; ++j) input_extreme_block[j] = mask_;\n      } else if (i == 1) {\n        for (int j = 0; j < kNumCoeffs; ++j) input_extreme_block[j] = -mask_;\n      }\n\n      fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);\n      ASM_REGISTER_STATE_CHECK(\n          RunFwdTxfm(input_extreme_block, output_block, pitch_));\n\n      // The minimum quant value is 4.\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        EXPECT_EQ(output_block[j], output_ref_block[j]);\n        EXPECT_GE(4 * DCT_MAX_VALUE << (bit_depth_ - 8), abs(output_block[j]))\n            << \"Error: 16x16 FDCT has coefficient larger than 4*DCT_MAX_VALUE\";\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              401,
              2
            ],
            [
              430,
              3
            ]
          ],
          "class_code": "0f6dd2811cdcbebdbd122f8b96733ab1cb790adcaaf7ab82287855372310a1cd",
          "class_node_pos": [
            [
              309,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunMemCheck",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunQuantCheck(int dc_thred, int ac_thred) {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 100000;\n    DECLARE_ALIGNED(16, int16_t, input_extreme_block[kNumCoeffs]);\n    DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);\n\n    DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint8_t, ref[kNumCoeffs]);\n#if CONFIG_VP9_HIGHBITDEPTH\n    DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint16_t, ref16[kNumCoeffs]);\n#endif\n\n    for (int i = 0; i < count_test_block; ++i) {\n      // Initialize a test block with input range [-mask_, mask_].\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        input_extreme_block[j] = rnd.Rand8() % 2 ? mask_ : -mask_;\n      }\n      if (i == 0) {\n        for (int j = 0; j < kNumCoeffs; ++j) input_extreme_block[j] = mask_;\n      }\n      if (i == 1) {\n        for (int j = 0; j < kNumCoeffs; ++j) input_extreme_block[j] = -mask_;\n      }\n\n      fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);\n\n      // clear reconstructed pixel buffers\n      memset(dst, 0, kNumCoeffs * sizeof(uint8_t));\n      memset(ref, 0, kNumCoeffs * sizeof(uint8_t));\n#if CONFIG_VP9_HIGHBITDEPTH\n      memset(dst16, 0, kNumCoeffs * sizeof(uint16_t));\n      memset(ref16, 0, kNumCoeffs * sizeof(uint16_t));\n#endif\n\n      // quantization with maximum allowed step sizes\n      output_ref_block[0] = (output_ref_block[0] / dc_thred) * dc_thred;\n      for (int j = 1; j < kNumCoeffs; ++j) {\n        output_ref_block[j] = (output_ref_block[j] / ac_thred) * ac_thred;\n      }\n      if (bit_depth_ == VPX_BITS_8) {\n        inv_txfm_ref(output_ref_block, ref, pitch_, tx_type_);\n        ASM_REGISTER_STATE_CHECK(RunInvTxfm(output_ref_block, dst, pitch_));\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        inv_txfm_ref(output_ref_block, CAST_TO_BYTEPTR(ref16), pitch_,\n                     tx_type_);\n        ASM_REGISTER_STATE_CHECK(\n            RunInvTxfm(output_ref_block, CAST_TO_BYTEPTR(dst16), pitch_));\n#endif\n      }\n      if (bit_depth_ == VPX_BITS_8) {\n        for (int j = 0; j < kNumCoeffs; ++j) EXPECT_EQ(ref[j], dst[j]);\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        for (int j = 0; j < kNumCoeffs; ++j) EXPECT_EQ(ref16[j], dst16[j]);\n#endif\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              432,
              2
            ],
            [
              491,
              3
            ]
          ],
          "class_code": "0f6dd2811cdcbebdbd122f8b96733ab1cb790adcaaf7ab82287855372310a1cd",
          "class_node_pos": [
            [
              309,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunQuantCheck",
            "parameters": {
              "dc_thred": "int",
              "ac_thred": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunInvAccuracyCheck() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 1000;\n    DECLARE_ALIGNED(16, int16_t, in[kNumCoeffs]);\n    DECLARE_ALIGNED(16, tran_low_t, coeff[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint8_t, src[kNumCoeffs]);\n#if CONFIG_VP9_HIGHBITDEPTH\n    DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint16_t, src16[kNumCoeffs]);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n    for (int i = 0; i < count_test_block; ++i) {\n      double out_r[kNumCoeffs];\n\n      // Initialize a test block with input range [-255, 255].\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        if (bit_depth_ == VPX_BITS_8) {\n          src[j] = rnd.Rand8();\n          dst[j] = rnd.Rand8();\n          in[j] = src[j] - dst[j];\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          src16[j] = rnd.Rand16() & mask_;\n          dst16[j] = rnd.Rand16() & mask_;\n          in[j] = src16[j] - dst16[j];\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n        }\n      }\n\n      reference_16x16_dct_2d(in, out_r);\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        coeff[j] = static_cast<tran_low_t>(round(out_r[j]));\n      }\n\n      if (bit_depth_ == VPX_BITS_8) {\n        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, 16));\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, CAST_TO_BYTEPTR(dst16), 16));\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n      }\n\n      for (int j = 0; j < kNumCoeffs; ++j) {\n#if CONFIG_VP9_HIGHBITDEPTH\n        const uint32_t diff =\n            bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n#else\n        const uint32_t diff = dst[j] - src[j];\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n        const uint32_t error = diff * diff;\n        EXPECT_GE(1u, error)\n            << \"Error: 16x16 IDCT has error \" << error << \" at index \" << j;\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              493,
              2
            ],
            [
              548,
              3
            ]
          ],
          "class_code": "0f6dd2811cdcbebdbd122f8b96733ab1cb790adcaaf7ab82287855372310a1cd",
          "class_node_pos": [
            [
              309,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunInvAccuracyCheck",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CompareInvReference(IdctFunc ref_txfm, int thresh) {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 10000;\n    const int eob = 10;\n    const int16_t *scan = vp9_default_scan_orders[TX_16X16].scan;\n    DECLARE_ALIGNED(16, tran_low_t, coeff[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint8_t, ref[kNumCoeffs]);\n#if CONFIG_VP9_HIGHBITDEPTH\n    DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint16_t, ref16[kNumCoeffs]);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n    for (int i = 0; i < count_test_block; ++i) {\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        if (j < eob) {\n          // Random values less than the threshold, either positive or negative\n          coeff[scan[j]] = rnd(thresh) * (1 - 2 * (i % 2));\n        } else {\n          coeff[scan[j]] = 0;\n        }\n        if (bit_depth_ == VPX_BITS_8) {\n          dst[j] = 0;\n          ref[j] = 0;\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          dst16[j] = 0;\n          ref16[j] = 0;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n        }\n      }\n      if (bit_depth_ == VPX_BITS_8) {\n        ref_txfm(coeff, ref, pitch_);\n        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, pitch_));\n      } else {\n#if CONFIG_VP9_HIGHBITDEPTH\n        ref_txfm(coeff, CAST_TO_BYTEPTR(ref16), pitch_);\n        ASM_REGISTER_STATE_CHECK(\n            RunInvTxfm(coeff, CAST_TO_BYTEPTR(dst16), pitch_));\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n      }\n\n      for (int j = 0; j < kNumCoeffs; ++j) {\n#if CONFIG_VP9_HIGHBITDEPTH\n        const uint32_t diff =\n            bit_depth_ == VPX_BITS_8 ? dst[j] - ref[j] : dst16[j] - ref16[j];\n#else\n        const uint32_t diff = dst[j] - ref[j];\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n        const uint32_t error = diff * diff;\n        EXPECT_EQ(0u, error) << \"Error: 16x16 IDCT Comparison has error \"\n                             << error << \" at index \" << j;\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              550,
              2
            ],
            [
              604,
              3
            ]
          ],
          "class_code": "0f6dd2811cdcbebdbd122f8b96733ab1cb790adcaaf7ab82287855372310a1cd",
          "class_node_pos": [
            [
              309,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CompareInvReference",
            "parameters": {
              "ref_txfm": "IdctFunc",
              "thresh": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual ~Trans16x16DCT() {}",
          "fn_code_pos": [
            [
              617,
              2
            ],
            [
              617,
              29
            ]
          ],
          "class_code": "829c6e69422d902d724c929f3c627ae46d55f4f87aa0bf2bbf443d28c58079d6",
          "class_node_pos": [
            [
              614,
              0
            ],
            [
              650,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n    tx_type_ = GET_PARAM(2);\n    bit_depth_ = GET_PARAM(3);\n    pitch_ = 16;\n    fwd_txfm_ref = fdct16x16_ref;\n    inv_txfm_ref = idct16x16_ref;\n    mask_ = (1 << bit_depth_) - 1;\n#if CONFIG_VP9_HIGHBITDEPTH\n    switch (bit_depth_) {\n      case VPX_BITS_10: inv_txfm_ref = idct16x16_10_ref; break;\n      case VPX_BITS_12: inv_txfm_ref = idct16x16_12_ref; break;\n      default: inv_txfm_ref = idct16x16_ref; break;\n    }\n#else\n    inv_txfm_ref = idct16x16_ref;\n#endif\n  }",
          "fn_code_pos": [
            [
              619,
              2
            ],
            [
              637,
              3
            ]
          ],
          "class_code": "829c6e69422d902d724c929f3c627ae46d55f4f87aa0bf2bbf443d28c58079d6",
          "class_node_pos": [
            [
              614,
              0
            ],
            [
              650,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              638,
              2
            ],
            [
              638,
              62
            ]
          ],
          "class_code": "829c6e69422d902d724c929f3c627ae46d55f4f87aa0bf2bbf443d28c58079d6",
          "class_node_pos": [
            [
              614,
              0
            ],
            [
              650,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) {\n    fwd_txfm_(in, out, stride);\n  }",
          "fn_code_pos": [
            [
              641,
              2
            ],
            [
              643,
              3
            ]
          ],
          "class_code": "829c6e69422d902d724c929f3c627ae46d55f4f87aa0bf2bbf443d28c58079d6",
          "class_node_pos": [
            [
              614,
              0
            ],
            [
              650,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunFwdTxfm",
            "parameters": {
              "in": "int16_t",
              "out": "tran_low_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) {\n    inv_txfm_(out, dst, stride);\n  }",
          "fn_code_pos": [
            [
              644,
              2
            ],
            [
              646,
              3
            ]
          ],
          "class_code": "829c6e69422d902d724c929f3c627ae46d55f4f87aa0bf2bbf443d28c58079d6",
          "class_node_pos": [
            [
              614,
              0
            ],
            [
              650,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunInvTxfm",
            "parameters": {
              "out": "tran_low_t",
              "dst": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(Trans16x16DCT, AccuracyCheck) { RunAccuracyCheck(); }",
          "fn_code_pos": [
            [
              652,
              0
            ],
            [
              652,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(Trans16x16DCT, CoeffCheck) { RunCoeffCheck(); }",
          "fn_code_pos": [
            [
              654,
              0
            ],
            [
              654,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(Trans16x16DCT, MemCheck) { RunMemCheck(); }",
          "fn_code_pos": [
            [
              656,
              0
            ],
            [
              656,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(Trans16x16DCT, QuantCheck) {\n  // Use maximally allowed quantization step sizes for DC and AC\n  // coefficients respectively.\n  RunQuantCheck(1336, 1828);\n}",
          "fn_code_pos": [
            [
              658,
              0
            ],
            [
              662,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(Trans16x16DCT, InvAccuracyCheck) { RunInvAccuracyCheck(); }",
          "fn_code_pos": [
            [
              664,
              0
            ],
            [
              664,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~Trans16x16HT() {}",
          "fn_code_pos": [
            [
              669,
              2
            ],
            [
              669,
              28
            ]
          ],
          "class_code": "a65b9b2d502045753f5147d7314a5c74f39eb0471456b48d1bf014405685c82a",
          "class_node_pos": [
            [
              666,
              0
            ],
            [
              702,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n    tx_type_ = GET_PARAM(2);\n    bit_depth_ = GET_PARAM(3);\n    pitch_ = 16;\n    fwd_txfm_ref = fht16x16_ref;\n    inv_txfm_ref = iht16x16_ref;\n    mask_ = (1 << bit_depth_) - 1;\n#if CONFIG_VP9_HIGHBITDEPTH\n    switch (bit_depth_) {\n      case VPX_BITS_10: inv_txfm_ref = iht16x16_10; break;\n      case VPX_BITS_12: inv_txfm_ref = iht16x16_12; break;\n      default: inv_txfm_ref = iht16x16_ref; break;\n    }\n#else\n    inv_txfm_ref = iht16x16_ref;\n#endif\n  }",
          "fn_code_pos": [
            [
              671,
              2
            ],
            [
              689,
              3
            ]
          ],
          "class_code": "a65b9b2d502045753f5147d7314a5c74f39eb0471456b48d1bf014405685c82a",
          "class_node_pos": [
            [
              666,
              0
            ],
            [
              702,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              690,
              2
            ],
            [
              690,
              62
            ]
          ],
          "class_code": "a65b9b2d502045753f5147d7314a5c74f39eb0471456b48d1bf014405685c82a",
          "class_node_pos": [
            [
              666,
              0
            ],
            [
              702,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) {\n    fwd_txfm_(in, out, stride, tx_type_);\n  }",
          "fn_code_pos": [
            [
              693,
              2
            ],
            [
              695,
              3
            ]
          ],
          "class_code": "a65b9b2d502045753f5147d7314a5c74f39eb0471456b48d1bf014405685c82a",
          "class_node_pos": [
            [
              666,
              0
            ],
            [
              702,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunFwdTxfm",
            "parameters": {
              "in": "int16_t",
              "out": "tran_low_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) {\n    inv_txfm_(out, dst, stride, tx_type_);\n  }",
          "fn_code_pos": [
            [
              696,
              2
            ],
            [
              698,
              3
            ]
          ],
          "class_code": "a65b9b2d502045753f5147d7314a5c74f39eb0471456b48d1bf014405685c82a",
          "class_node_pos": [
            [
              666,
              0
            ],
            [
              702,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunInvTxfm",
            "parameters": {
              "out": "tran_low_t",
              "dst": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(Trans16x16HT, AccuracyCheck) { RunAccuracyCheck(); }",
          "fn_code_pos": [
            [
              704,
              0
            ],
            [
              704,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(Trans16x16HT, CoeffCheck) { RunCoeffCheck(); }",
          "fn_code_pos": [
            [
              706,
              0
            ],
            [
              706,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(Trans16x16HT, MemCheck) { RunMemCheck(); }",
          "fn_code_pos": [
            [
              708,
              0
            ],
            [
              708,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(Trans16x16HT, QuantCheck) {\n  // The encoder skips any non-DC intra prediction modes,\n  // when the quantization step size goes beyond 988.\n  RunQuantCheck(429, 729);\n}",
          "fn_code_pos": [
            [
              710,
              0
            ],
            [
              714,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~InvTrans16x16DCT() {}",
          "fn_code_pos": [
            [
              719,
              2
            ],
            [
              719,
              32
            ]
          ],
          "class_code": "87a1340c06b1d06099ec982e6d1b1de5ba5172577c6260d1afec575dfc5b9ac8",
          "class_node_pos": [
            [
              716,
              0
            ],
            [
              740,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    ref_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n    thresh_ = GET_PARAM(2);\n    bit_depth_ = GET_PARAM(3);\n    pitch_ = 16;\n    mask_ = (1 << bit_depth_) - 1;\n  }",
          "fn_code_pos": [
            [
              721,
              2
            ],
            [
              728,
              3
            ]
          ],
          "class_code": "87a1340c06b1d06099ec982e6d1b1de5ba5172577c6260d1afec575dfc5b9ac8",
          "class_node_pos": [
            [
              716,
              0
            ],
            [
              740,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              729,
              2
            ],
            [
              729,
              62
            ]
          ],
          "class_code": "87a1340c06b1d06099ec982e6d1b1de5ba5172577c6260d1afec575dfc5b9ac8",
          "class_node_pos": [
            [
              716,
              0
            ],
            [
              740,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunFwdTxfm(int16_t * /*in*/, tran_low_t * /*out*/, int /*stride*/) {}",
          "fn_code_pos": [
            [
              732,
              2
            ],
            [
              732,
              76
            ]
          ],
          "class_code": "87a1340c06b1d06099ec982e6d1b1de5ba5172577c6260d1afec575dfc5b9ac8",
          "class_node_pos": [
            [
              716,
              0
            ],
            [
              740,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunFwdTxfm",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) {\n    inv_txfm_(out, dst, stride);\n  }",
          "fn_code_pos": [
            [
              733,
              2
            ],
            [
              735,
              3
            ]
          ],
          "class_code": "87a1340c06b1d06099ec982e6d1b1de5ba5172577c6260d1afec575dfc5b9ac8",
          "class_node_pos": [
            [
              716,
              0
            ],
            [
              740,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunInvTxfm",
            "parameters": {
              "out": "tran_low_t",
              "dst": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(InvTrans16x16DCT, CompareReference) {\n  CompareInvReference(ref_txfm_, thresh_);\n}",
          "fn_code_pos": [
            [
              742,
              0
            ],
            [
              744,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*FdctFunc)(const int16_t *in, tran_low_t *out, int stride)",
          "fn_dec_pos": [
            [
              225,
              13
            ],
            [
              225,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "int16_t",
              "out": "tran_low_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*IdctFunc)(const tran_low_t *in, uint8_t *out, int stride)",
          "fn_dec_pos": [
            [
              226,
              13
            ],
            [
              226,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*FhtFunc)(const int16_t *in, tran_low_t *out, int stride,\n                        int tx_type)",
          "fn_dec_pos": [
            [
              227,
              13
            ],
            [
              228,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "int16_t",
              "out": "tran_low_t",
              "stride": "int",
              "tx_type": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*IhtFunc)(const tran_low_t *in, uint8_t *out, int stride,\n                        int tx_type)",
          "fn_dec_pos": [
            [
              229,
              13
            ],
            [
              230,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int",
              "tx_type": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              319,
              14
            ],
            [
              319,
              49
            ]
          ],
          "class_code": "0f6dd2811cdcbebdbd122f8b96733ab1cb790adcaaf7ab82287855372310a1cd",
          "class_node_pos": [
            [
              309,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              380,
              14
            ],
            [
              380,
              49
            ]
          ],
          "class_code": "0f6dd2811cdcbebdbd122f8b96733ab1cb790adcaaf7ab82287855372310a1cd",
          "class_node_pos": [
            [
              309,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              402,
              14
            ],
            [
              402,
              49
            ]
          ],
          "class_code": "0f6dd2811cdcbebdbd122f8b96733ab1cb790adcaaf7ab82287855372310a1cd",
          "class_node_pos": [
            [
              309,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              433,
              14
            ],
            [
              433,
              49
            ]
          ],
          "class_code": "0f6dd2811cdcbebdbd122f8b96733ab1cb790adcaaf7ab82287855372310a1cd",
          "class_node_pos": [
            [
              309,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              494,
              14
            ],
            [
              494,
              49
            ]
          ],
          "class_code": "0f6dd2811cdcbebdbd122f8b96733ab1cb790adcaaf7ab82287855372310a1cd",
          "class_node_pos": [
            [
              309,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              551,
              14
            ],
            [
              551,
              49
            ]
          ],
          "class_code": "0f6dd2811cdcbebdbd122f8b96733ab1cb790adcaaf7ab82287855372310a1cd",
          "class_node_pos": [
            [
              309,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        }
      ],
      "class_node_list": {
        "0f6dd2811cdcbebdbd122f8b96733ab1cb790adcaaf7ab82287855372310a1cd": {
          "class_code": "class Trans16x16TestBase {\n public:\n  virtual ~Trans16x16TestBase() {}\n\n protected:\n  virtual void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) = 0;\n\n  virtual void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) = 0;\n\n  void RunAccuracyCheck() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    uint32_t max_error = 0;\n    int64_t total_error = 0;\n    const int count_test_block = 10000;\n    for (int i = 0; i < count_test_block; ++i) {\n      DECLARE_ALIGNED(16, int16_t, test_input_block[kNumCoeffs]);\n      DECLARE_ALIGNED(16, tran_low_t, test_temp_block[kNumCoeffs]);\n      DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n      DECLARE_ALIGNED(16, uint8_t, src[kNumCoeffs]);\n#if CONFIG_VP9_HIGHBITDEPTH\n      DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n      DECLARE_ALIGNED(16, uint16_t, src16[kNumCoeffs]);\n#endif\n\n      // Initialize a test block with input range [-mask_, mask_].\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        if (bit_depth_ == VPX_BITS_8) {\n          src[j] = rnd.Rand8();\n          dst[j] = rnd.Rand8();\n          test_input_block[j] = src[j] - dst[j];\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          src16[j] = rnd.Rand16() & mask_;\n          dst16[j] = rnd.Rand16() & mask_;\n          test_input_block[j] = src16[j] - dst16[j];\n#endif\n        }\n      }\n\n      ASM_REGISTER_STATE_CHECK(\n          RunFwdTxfm(test_input_block, test_temp_block, pitch_));\n      if (bit_depth_ == VPX_BITS_8) {\n        ASM_REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        ASM_REGISTER_STATE_CHECK(\n            RunInvTxfm(test_temp_block, CAST_TO_BYTEPTR(dst16), pitch_));\n#endif\n      }\n\n      for (int j = 0; j < kNumCoeffs; ++j) {\n#if CONFIG_VP9_HIGHBITDEPTH\n        const int32_t diff =\n            bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n#else\n        const int32_t diff = dst[j] - src[j];\n#endif\n        const uint32_t error = diff * diff;\n        if (max_error < error) max_error = error;\n        total_error += error;\n      }\n    }\n\n    EXPECT_GE(1u << 2 * (bit_depth_ - 8), max_error)\n        << \"Error: 16x16 FHT/IHT has an individual round trip error > 1\";\n\n    EXPECT_GE(count_test_block << 2 * (bit_depth_ - 8), total_error)\n        << \"Error: 16x16 FHT/IHT has average round trip error > 1 per block\";\n  }\n\n  void RunCoeffCheck() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 1000;\n    DECLARE_ALIGNED(16, int16_t, input_block[kNumCoeffs]);\n    DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);\n    DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);\n\n    for (int i = 0; i < count_test_block; ++i) {\n      // Initialize a test block with input range [-mask_, mask_].\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        input_block[j] = (rnd.Rand16() & mask_) - (rnd.Rand16() & mask_);\n      }\n\n      fwd_txfm_ref(input_block, output_ref_block, pitch_, tx_type_);\n      ASM_REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_));\n\n      // The minimum quant value is 4.\n      for (int j = 0; j < kNumCoeffs; ++j)\n        EXPECT_EQ(output_block[j], output_ref_block[j]);\n    }\n  }\n\n  void RunMemCheck() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 1000;\n    DECLARE_ALIGNED(16, int16_t, input_extreme_block[kNumCoeffs]);\n    DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);\n    DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);\n\n    for (int i = 0; i < count_test_block; ++i) {\n      // Initialize a test block with input range [-mask_, mask_].\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        input_extreme_block[j] = rnd.Rand8() % 2 ? mask_ : -mask_;\n      }\n      if (i == 0) {\n        for (int j = 0; j < kNumCoeffs; ++j) input_extreme_block[j] = mask_;\n      } else if (i == 1) {\n        for (int j = 0; j < kNumCoeffs; ++j) input_extreme_block[j] = -mask_;\n      }\n\n      fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);\n      ASM_REGISTER_STATE_CHECK(\n          RunFwdTxfm(input_extreme_block, output_block, pitch_));\n\n      // The minimum quant value is 4.\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        EXPECT_EQ(output_block[j], output_ref_block[j]);\n        EXPECT_GE(4 * DCT_MAX_VALUE << (bit_depth_ - 8), abs(output_block[j]))\n            << \"Error: 16x16 FDCT has coefficient larger than 4*DCT_MAX_VALUE\";\n      }\n    }\n  }\n\n  void RunQuantCheck(int dc_thred, int ac_thred) {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 100000;\n    DECLARE_ALIGNED(16, int16_t, input_extreme_block[kNumCoeffs]);\n    DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);\n\n    DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint8_t, ref[kNumCoeffs]);\n#if CONFIG_VP9_HIGHBITDEPTH\n    DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint16_t, ref16[kNumCoeffs]);\n#endif\n\n    for (int i = 0; i < count_test_block; ++i) {\n      // Initialize a test block with input range [-mask_, mask_].\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        input_extreme_block[j] = rnd.Rand8() % 2 ? mask_ : -mask_;\n      }\n      if (i == 0) {\n        for (int j = 0; j < kNumCoeffs; ++j) input_extreme_block[j] = mask_;\n      }\n      if (i == 1) {\n        for (int j = 0; j < kNumCoeffs; ++j) input_extreme_block[j] = -mask_;\n      }\n\n      fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);\n\n      // clear reconstructed pixel buffers\n      memset(dst, 0, kNumCoeffs * sizeof(uint8_t));\n      memset(ref, 0, kNumCoeffs * sizeof(uint8_t));\n#if CONFIG_VP9_HIGHBITDEPTH\n      memset(dst16, 0, kNumCoeffs * sizeof(uint16_t));\n      memset(ref16, 0, kNumCoeffs * sizeof(uint16_t));\n#endif\n\n      // quantization with maximum allowed step sizes\n      output_ref_block[0] = (output_ref_block[0] / dc_thred) * dc_thred;\n      for (int j = 1; j < kNumCoeffs; ++j) {\n        output_ref_block[j] = (output_ref_block[j] / ac_thred) * ac_thred;\n      }\n      if (bit_depth_ == VPX_BITS_8) {\n        inv_txfm_ref(output_ref_block, ref, pitch_, tx_type_);\n        ASM_REGISTER_STATE_CHECK(RunInvTxfm(output_ref_block, dst, pitch_));\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        inv_txfm_ref(output_ref_block, CAST_TO_BYTEPTR(ref16), pitch_,\n                     tx_type_);\n        ASM_REGISTER_STATE_CHECK(\n            RunInvTxfm(output_ref_block, CAST_TO_BYTEPTR(dst16), pitch_));\n#endif\n      }\n      if (bit_depth_ == VPX_BITS_8) {\n        for (int j = 0; j < kNumCoeffs; ++j) EXPECT_EQ(ref[j], dst[j]);\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        for (int j = 0; j < kNumCoeffs; ++j) EXPECT_EQ(ref16[j], dst16[j]);\n#endif\n      }\n    }\n  }\n\n  void RunInvAccuracyCheck() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 1000;\n    DECLARE_ALIGNED(16, int16_t, in[kNumCoeffs]);\n    DECLARE_ALIGNED(16, tran_low_t, coeff[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint8_t, src[kNumCoeffs]);\n#if CONFIG_VP9_HIGHBITDEPTH\n    DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint16_t, src16[kNumCoeffs]);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n    for (int i = 0; i < count_test_block; ++i) {\n      double out_r[kNumCoeffs];\n\n      // Initialize a test block with input range [-255, 255].\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        if (bit_depth_ == VPX_BITS_8) {\n          src[j] = rnd.Rand8();\n          dst[j] = rnd.Rand8();\n          in[j] = src[j] - dst[j];\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          src16[j] = rnd.Rand16() & mask_;\n          dst16[j] = rnd.Rand16() & mask_;\n          in[j] = src16[j] - dst16[j];\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n        }\n      }\n\n      reference_16x16_dct_2d(in, out_r);\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        coeff[j] = static_cast<tran_low_t>(round(out_r[j]));\n      }\n\n      if (bit_depth_ == VPX_BITS_8) {\n        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, 16));\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, CAST_TO_BYTEPTR(dst16), 16));\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n      }\n\n      for (int j = 0; j < kNumCoeffs; ++j) {\n#if CONFIG_VP9_HIGHBITDEPTH\n        const uint32_t diff =\n            bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n#else\n        const uint32_t diff = dst[j] - src[j];\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n        const uint32_t error = diff * diff;\n        EXPECT_GE(1u, error)\n            << \"Error: 16x16 IDCT has error \" << error << \" at index \" << j;\n      }\n    }\n  }\n\n  void CompareInvReference(IdctFunc ref_txfm, int thresh) {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 10000;\n    const int eob = 10;\n    const int16_t *scan = vp9_default_scan_orders[TX_16X16].scan;\n    DECLARE_ALIGNED(16, tran_low_t, coeff[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint8_t, ref[kNumCoeffs]);\n#if CONFIG_VP9_HIGHBITDEPTH\n    DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint16_t, ref16[kNumCoeffs]);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n    for (int i = 0; i < count_test_block; ++i) {\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        if (j < eob) {\n          // Random values less than the threshold, either positive or negative\n          coeff[scan[j]] = rnd(thresh) * (1 - 2 * (i % 2));\n        } else {\n          coeff[scan[j]] = 0;\n        }\n        if (bit_depth_ == VPX_BITS_8) {\n          dst[j] = 0;\n          ref[j] = 0;\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          dst16[j] = 0;\n          ref16[j] = 0;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n        }\n      }\n      if (bit_depth_ == VPX_BITS_8) {\n        ref_txfm(coeff, ref, pitch_);\n        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, pitch_));\n      } else {\n#if CONFIG_VP9_HIGHBITDEPTH\n        ref_txfm(coeff, CAST_TO_BYTEPTR(ref16), pitch_);\n        ASM_REGISTER_STATE_CHECK(\n            RunInvTxfm(coeff, CAST_TO_BYTEPTR(dst16), pitch_));\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n      }\n\n      for (int j = 0; j < kNumCoeffs; ++j) {\n#if CONFIG_VP9_HIGHBITDEPTH\n        const uint32_t diff =\n            bit_depth_ == VPX_BITS_8 ? dst[j] - ref[j] : dst16[j] - ref16[j];\n#else\n        const uint32_t diff = dst[j] - ref[j];\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n        const uint32_t error = diff * diff;\n        EXPECT_EQ(0u, error) << \"Error: 16x16 IDCT Comparison has error \"\n                             << error << \" at index \" << j;\n      }\n    }\n  }\n\n  int pitch_;\n  int tx_type_;\n  vpx_bit_depth_t bit_depth_;\n  int mask_;\n  FhtFunc fwd_txfm_ref;\n  IhtFunc inv_txfm_ref;\n}",
          "class_name": "Trans16x16TestBase",
          "class_pos": [
            [
              309,
              0
            ],
            [
              612,
              1
            ]
          ]
        },
        "829c6e69422d902d724c929f3c627ae46d55f4f87aa0bf2bbf443d28c58079d6": {
          "class_code": "class Trans16x16DCT : public Trans16x16TestBase,\n                      public ::testing::TestWithParam<Dct16x16Param> {\n public:\n  virtual ~Trans16x16DCT() {}\n\n  virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n    tx_type_ = GET_PARAM(2);\n    bit_depth_ = GET_PARAM(3);\n    pitch_ = 16;\n    fwd_txfm_ref = fdct16x16_ref;\n    inv_txfm_ref = idct16x16_ref;\n    mask_ = (1 << bit_depth_) - 1;\n#if CONFIG_VP9_HIGHBITDEPTH\n    switch (bit_depth_) {\n      case VPX_BITS_10: inv_txfm_ref = idct16x16_10_ref; break;\n      case VPX_BITS_12: inv_txfm_ref = idct16x16_12_ref; break;\n      default: inv_txfm_ref = idct16x16_ref; break;\n    }\n#else\n    inv_txfm_ref = idct16x16_ref;\n#endif\n  }\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) {\n    fwd_txfm_(in, out, stride);\n  }\n  void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) {\n    inv_txfm_(out, dst, stride);\n  }\n\n  FdctFunc fwd_txfm_;\n  IdctFunc inv_txfm_;\n}",
          "class_name": "Trans16x16DCT",
          "class_pos": [
            [
              614,
              0
            ],
            [
              650,
              1
            ]
          ]
        },
        "a65b9b2d502045753f5147d7314a5c74f39eb0471456b48d1bf014405685c82a": {
          "class_code": "class Trans16x16HT : public Trans16x16TestBase,\n                     public ::testing::TestWithParam<Ht16x16Param> {\n public:\n  virtual ~Trans16x16HT() {}\n\n  virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n    tx_type_ = GET_PARAM(2);\n    bit_depth_ = GET_PARAM(3);\n    pitch_ = 16;\n    fwd_txfm_ref = fht16x16_ref;\n    inv_txfm_ref = iht16x16_ref;\n    mask_ = (1 << bit_depth_) - 1;\n#if CONFIG_VP9_HIGHBITDEPTH\n    switch (bit_depth_) {\n      case VPX_BITS_10: inv_txfm_ref = iht16x16_10; break;\n      case VPX_BITS_12: inv_txfm_ref = iht16x16_12; break;\n      default: inv_txfm_ref = iht16x16_ref; break;\n    }\n#else\n    inv_txfm_ref = iht16x16_ref;\n#endif\n  }\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) {\n    fwd_txfm_(in, out, stride, tx_type_);\n  }\n  void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) {\n    inv_txfm_(out, dst, stride, tx_type_);\n  }\n\n  FhtFunc fwd_txfm_;\n  IhtFunc inv_txfm_;\n}",
          "class_name": "Trans16x16HT",
          "class_pos": [
            [
              666,
              0
            ],
            [
              702,
              1
            ]
          ]
        },
        "87a1340c06b1d06099ec982e6d1b1de5ba5172577c6260d1afec575dfc5b9ac8": {
          "class_code": "class InvTrans16x16DCT : public Trans16x16TestBase,\n                         public ::testing::TestWithParam<Idct16x16Param> {\n public:\n  virtual ~InvTrans16x16DCT() {}\n\n  virtual void SetUp() {\n    ref_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n    thresh_ = GET_PARAM(2);\n    bit_depth_ = GET_PARAM(3);\n    pitch_ = 16;\n    mask_ = (1 << bit_depth_) - 1;\n  }\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  void RunFwdTxfm(int16_t * /*in*/, tran_low_t * /*out*/, int /*stride*/) {}\n  void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) {\n    inv_txfm_(out, dst, stride);\n  }\n\n  IdctFunc ref_txfm_;\n  IdctFunc inv_txfm_;\n  int thresh_;\n}",
          "class_name": "InvTrans16x16DCT",
          "class_pos": [
            [
              716,
              0
            ],
            [
              740,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <math.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./vp9_rtcd.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_entropy.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_scan.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_codec.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"vpx_ports/mem.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"vpx_ports/msvc.h\"  // for round()\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/active_map_refresh_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "int CheckMb(const vpx_image_t &current, const vpx_image_t &previous, int mb_r,\n            int mb_c) {\n  for (int plane = 0; plane < 3; plane++) {\n    int r = 16 * mb_r;\n    int c0 = 16 * mb_c;\n    int r_top = std::min(r + 16, static_cast<int>(current.d_h));\n    int c_top = std::min(c0 + 16, static_cast<int>(current.d_w));\n    r = std::max(r, 0);\n    c0 = std::max(c0, 0);\n    if (plane > 0 && current.x_chroma_shift) {\n      c_top = (c_top + 1) >> 1;\n      c0 >>= 1;\n    }\n    if (plane > 0 && current.y_chroma_shift) {\n      r_top = (r_top + 1) >> 1;\n      r >>= 1;\n    }\n    for (; r < r_top; ++r) {\n      for (int c = c0; c < c_top; ++c) {\n        if (current.planes[plane][current.stride[plane] * r + c] !=\n            previous.planes[plane][previous.stride[plane] * r + c]) {\n          return 1;\n        }\n      }\n    }\n  }\n  return 0;\n}",
          "fn_code_pos": [
            [
              19,
              0
            ],
            [
              46,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMb",
            "parameters": {
              "current": "vpx_image_t",
              "previous": "vpx_image_t",
              "mb_r": "int",
              "mb_c": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void GenerateMap(int mb_rows, int mb_cols, const vpx_image_t &current,\n                 const vpx_image_t &previous, uint8_t *map) {\n  for (int mb_r = 0; mb_r < mb_rows; ++mb_r) {\n    for (int mb_c = 0; mb_c < mb_cols; ++mb_c) {\n      map[mb_r * mb_cols + mb_c] = CheckMb(current, previous, mb_r, mb_c);\n    }\n  }\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GenerateMap",
            "parameters": {
              "mb_rows": "int",
              "mb_cols": "int",
              "current": "vpx_image_t",
              "previous": "vpx_image_t",
              "map": "uint8_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ActiveMapRefreshTest() : EncoderTest(GET_PARAM(0)) {}",
          "fn_code_pos": [
            [
              63,
              2
            ],
            [
              63,
              55
            ]
          ],
          "class_code": "0b1164ef43de48fef5b009eb90ed4bdc741ec5d07aa87b83537f7949e9ce47dd",
          "class_node_pos": [
            [
              59,
              0
            ],
            [
              103,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ActiveMapRefreshTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~ActiveMapRefreshTest() {}",
          "fn_code_pos": [
            [
              64,
              2
            ],
            [
              64,
              36
            ]
          ],
          "class_code": "0b1164ef43de48fef5b009eb90ed4bdc741ec5d07aa87b83537f7949e9ce47dd",
          "class_node_pos": [
            [
              59,
              0
            ],
            [
              103,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n    cpu_used_ = GET_PARAM(2);\n  }",
          "fn_code_pos": [
            [
              66,
              2
            ],
            [
              70,
              3
            ]
          ],
          "class_code": "0b1164ef43de48fef5b009eb90ed4bdc741ec5d07aa87b83537f7949e9ce47dd",
          "class_node_pos": [
            [
              59,
              0
            ],
            [
              103,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    ::libvpx_test::Y4mVideoSource *y4m_video =\n        static_cast<libvpx_test::Y4mVideoSource *>(video);\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, cpu_used_);\n      encoder->Control(VP9E_SET_AQ_MODE, kAqModeCyclicRefresh);\n    } else if (video->frame() >= 2 && video->img()) {\n      vpx_image_t *current = video->img();\n      vpx_image_t *previous = y4m_holder_->img();\n      ASSERT_TRUE(previous != NULL);\n      vpx_active_map_t map = vpx_active_map_t();\n      const int width = static_cast<int>(current->d_w);\n      const int height = static_cast<int>(current->d_h);\n      const int mb_width = (width + 15) / 16;\n      const int mb_height = (height + 15) / 16;\n      uint8_t *active_map = new uint8_t[mb_width * mb_height];\n      GenerateMap(mb_height, mb_width, *current, *previous, active_map);\n      map.cols = mb_width;\n      map.rows = mb_height;\n      map.active_map = active_map;\n      encoder->Control(VP8E_SET_ACTIVEMAP, &map);\n      delete[] active_map;\n    }\n    if (video->img()) {\n      y4m_video->SwapBuffers(y4m_holder_);\n    }\n  }",
          "fn_code_pos": [
            [
              72,
              2
            ],
            [
              99,
              3
            ]
          ],
          "class_code": "0b1164ef43de48fef5b009eb90ed4bdc741ec5d07aa87b83537f7949e9ce47dd",
          "class_node_pos": [
            [
              59,
              0
            ],
            [
              103,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(ActiveMapRefreshTest, Test) {\n  cfg_.g_lag_in_frames = 0;\n  cfg_.g_profile = 1;\n  cfg_.rc_target_bitrate = 600;\n  cfg_.rc_resize_allowed = 0;\n  cfg_.rc_min_quantizer = 8;\n  cfg_.rc_max_quantizer = 30;\n  cfg_.g_pass = VPX_RC_ONE_PASS;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.kf_max_dist = 90000;\n\n  ::libvpx_test::Y4mVideoSource video(\"desktop_credits.y4m\", 0, 30);\n  ::libvpx_test::Y4mVideoSource video_holder(\"desktop_credits.y4m\", 0, 30);\n  video_holder.Begin();\n  y4m_holder_ = &video_holder;\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              105,
              0
            ],
            [
              122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "0b1164ef43de48fef5b009eb90ed4bdc741ec5d07aa87b83537f7949e9ce47dd": {
          "class_code": "class ActiveMapRefreshTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWith2Params<libvpx_test::TestMode, int> {\n protected:\n  ActiveMapRefreshTest() : EncoderTest(GET_PARAM(0)) {}\n  virtual ~ActiveMapRefreshTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n    cpu_used_ = GET_PARAM(2);\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    ::libvpx_test::Y4mVideoSource *y4m_video =\n        static_cast<libvpx_test::Y4mVideoSource *>(video);\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, cpu_used_);\n      encoder->Control(VP9E_SET_AQ_MODE, kAqModeCyclicRefresh);\n    } else if (video->frame() >= 2 && video->img()) {\n      vpx_image_t *current = video->img();\n      vpx_image_t *previous = y4m_holder_->img();\n      ASSERT_TRUE(previous != NULL);\n      vpx_active_map_t map = vpx_active_map_t();\n      const int width = static_cast<int>(current->d_w);\n      const int height = static_cast<int>(current->d_h);\n      const int mb_width = (width + 15) / 16;\n      const int mb_height = (height + 15) / 16;\n      uint8_t *active_map = new uint8_t[mb_width * mb_height];\n      GenerateMap(mb_height, mb_width, *current, *previous, active_map);\n      map.cols = mb_width;\n      map.rows = mb_height;\n      map.active_map = active_map;\n      encoder->Control(VP8E_SET_ACTIVEMAP, &map);\n      delete[] active_map;\n    }\n    if (video->img()) {\n      y4m_video->SwapBuffers(y4m_holder_);\n    }\n  }\n\n  int cpu_used_;\n  ::libvpx_test::Y4mVideoSource *y4m_holder_;\n}",
          "class_name": "ActiveMapRefreshTest",
          "class_pos": [
            [
              59,
              0
            ],
            [
              103,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <algorithm>\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/y4m_video_source.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp9_intrapred_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "template <>\nvoid IntraPredTest<uint8_t, IntraPredParam>::Predict() {\n  params_.ref_fn(ref_dst_, stride_, above_row_, left_col_);\n  ASM_REGISTER_STATE_CHECK(\n      params_.pred_fn(dst_, stride_, above_row_, left_col_));\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <>\nvoid IntraPredTest<uint16_t, HighbdIntraPredParam>::Predict() {\n  const int bit_depth = params_.bit_depth;\n  params_.ref_fn(ref_dst_, stride_, above_row_, left_col_, bit_depth);\n  ASM_REGISTER_STATE_CHECK(\n      params_.pred_fn(dst_, stride_, above_row_, left_col_, bit_depth));\n}",
          "fn_code_pos": [
            [
              456,
              0
            ],
            [
              462,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "IntraPredParam(IntraPredFunc pred = NULL, IntraPredFunc ref = NULL,\n                 int block_size_value = 0, int bit_depth_value = 0)\n      : pred_fn(pred), ref_fn(ref), block_size(block_size_value),\n        bit_depth(bit_depth_value) {}",
          "fn_code_pos": [
            [
              34,
              2
            ],
            [
              37,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IntraPredParam",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void RunTest(Pixel *left_col, Pixel *above_data, Pixel *dst, Pixel *ref_dst) {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int block_size = params_.block_size;\n    above_row_ = above_data + 16;\n    left_col_ = left_col;\n    dst_ = dst;\n    ref_dst_ = ref_dst;\n    int error_count = 0;\n    for (int i = 0; i < count_test_block; ++i) {\n      // Fill edges with random data, try first with saturated values.\n      for (int x = -1; x < block_size; x++) {\n        if (i == 0) {\n          above_row_[x] = mask_;\n        } else {\n          above_row_[x] = rnd.Rand16() & mask_;\n        }\n      }\n      for (int x = block_size; x < 2 * block_size; x++) {\n        above_row_[x] = above_row_[block_size - 1];\n      }\n      for (int y = 0; y < block_size; y++) {\n        if (i == 0) {\n          left_col_[y] = mask_;\n        } else {\n          left_col_[y] = rnd.Rand16() & mask_;\n        }\n      }\n      Predict();\n      CheckPrediction(i, &error_count);\n    }\n    ASSERT_EQ(0, error_count);\n  }",
          "fn_code_pos": [
            [
              48,
              2
            ],
            [
              79,
              3
            ]
          ],
          "class_code": "32151e89d063d3f5ade120e37d5f147f572f292de54fc8b3cbbb46c7adbaa84e",
          "class_node_pos": [
            [
              46,
              0
            ],
            [
              112,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunTest",
            "parameters": {
              "left_col": "Pixel",
              "above_data": "Pixel",
              "dst": "Pixel",
              "ref_dst": "Pixel"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    params_ = this->GetParam();\n    stride_ = params_.block_size * 3;\n    mask_ = (1 << params_.bit_depth) - 1;\n  }",
          "fn_code_pos": [
            [
              82,
              2
            ],
            [
              86,
              3
            ]
          ],
          "class_code": "32151e89d063d3f5ade120e37d5f147f572f292de54fc8b3cbbb46c7adbaa84e",
          "class_node_pos": [
            [
              46,
              0
            ],
            [
              112,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CheckPrediction(int test_case_number, int *error_count) const {\n    // For each pixel ensure that the calculated value is the same as reference.\n    const int block_size = params_.block_size;\n    for (int y = 0; y < block_size; y++) {\n      for (int x = 0; x < block_size; x++) {\n        *error_count += ref_dst_[x + y * stride_] != dst_[x + y * stride_];\n        if (*error_count == 1) {\n          ASSERT_EQ(ref_dst_[x + y * stride_], dst_[x + y * stride_])\n              << \" Failed on Test Case Number \" << test_case_number;\n        }\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              90,
              2
            ],
            [
              102,
              3
            ]
          ],
          "class_code": "32151e89d063d3f5ade120e37d5f147f572f292de54fc8b3cbbb46c7adbaa84e",
          "class_node_pos": [
            [
              46,
              0
            ],
            [
              112,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckPrediction",
            "parameters": {
              "test_case_number": "int",
              "error_count": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(VP9IntraPredTest, IntraPredTests) {\n  // max block size is 32\n  DECLARE_ALIGNED(16, uint8_t, left_col[2 * 32]);\n  DECLARE_ALIGNED(16, uint8_t, above_data[2 * 32 + 32]);\n  DECLARE_ALIGNED(16, uint8_t, dst[3 * 32 * 32]);\n  DECLARE_ALIGNED(16, uint8_t, ref_dst[3 * 32 * 32]);\n  RunTest(left_col, above_data, dst, ref_dst);\n}",
          "fn_code_pos": [
            [
              123,
              0
            ],
            [
              130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "HighbdIntraPredParam(HighbdIntraPred pred = NULL, HighbdIntraPred ref = NULL,\n                       int block_size_value = 0, int bit_depth_value = 0)\n      : pred_fn(pred), ref_fn(ref), block_size(block_size_value),\n        bit_depth(bit_depth_value) {}",
          "fn_code_pos": [
            [
              445,
              2
            ],
            [
              448,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HighbdIntraPredParam",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VP9HighbdIntraPredTest, HighbdIntraPredTests) {\n  // max block size is 32\n  DECLARE_ALIGNED(16, uint16_t, left_col[2 * 32]);\n  DECLARE_ALIGNED(16, uint16_t, above_data[2 * 32 + 32]);\n  DECLARE_ALIGNED(16, uint16_t, dst[3 * 32 * 32]);\n  DECLARE_ALIGNED(16, uint16_t, ref_dst[3 * 32 * 32]);\n  RunTest(left_col, above_data, dst, ref_dst);\n}",
          "fn_code_pos": [
            [
              466,
              0
            ],
            [
              473,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*IntraPredFunc)(uint8_t *dst, ptrdiff_t stride,\n                              const uint8_t *above, const uint8_t *left)",
          "fn_dec_pos": [
            [
              30,
              13
            ],
            [
              31,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "dst": "uint8_t",
              "stride": "ptrdiff_t",
              "above": "uint8_t",
              "left": "uint8_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              49,
              14
            ],
            [
              49,
              49
            ]
          ],
          "class_code": "32151e89d063d3f5ade120e37d5f147f572f292de54fc8b3cbbb46c7adbaa84e",
          "class_node_pos": [
            [
              46,
              0
            ],
            [
              112,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "Predict()",
          "fn_dec_pos": [
            [
              88,
              7
            ],
            [
              88,
              16
            ]
          ],
          "class_code": "32151e89d063d3f5ade120e37d5f147f572f292de54fc8b3cbbb46c7adbaa84e",
          "class_node_pos": [
            [
              46,
              0
            ],
            [
              112,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Predict",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*HighbdIntraPred)(uint16_t *dst, ptrdiff_t stride,\n                                const uint16_t *above, const uint16_t *left,\n                                int bps)",
          "fn_dec_pos": [
            [
              441,
              13
            ],
            [
              443,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "dst": "uint16_t",
              "stride": "ptrdiff_t",
              "above": "uint16_t",
              "left": "uint16_t",
              "bps": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {
        "1b9b7df08f95583cedd834e90bb314f97cb9a5e1f5ecca7e11a3f3fc528b63e5": {
          "class_code": "template <typename Pixel, typename PredParam>\nclass IntraPredTest : public ::testing::TestWithParam<PredParam> {\n public:\n  void RunTest(Pixel *left_col, Pixel *above_data, Pixel *dst, Pixel *ref_dst) {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int block_size = params_.block_size;\n    above_row_ = above_data + 16;\n    left_col_ = left_col;\n    dst_ = dst;\n    ref_dst_ = ref_dst;\n    int error_count = 0;\n    for (int i = 0; i < count_test_block; ++i) {\n      // Fill edges with random data, try first with saturated values.\n      for (int x = -1; x < block_size; x++) {\n        if (i == 0) {\n          above_row_[x] = mask_;\n        } else {\n          above_row_[x] = rnd.Rand16() & mask_;\n        }\n      }\n      for (int x = block_size; x < 2 * block_size; x++) {\n        above_row_[x] = above_row_[block_size - 1];\n      }\n      for (int y = 0; y < block_size; y++) {\n        if (i == 0) {\n          left_col_[y] = mask_;\n        } else {\n          left_col_[y] = rnd.Rand16() & mask_;\n        }\n      }\n      Predict();\n      CheckPrediction(i, &error_count);\n    }\n    ASSERT_EQ(0, error_count);\n  }\n\n protected:\n  virtual void SetUp() {\n    params_ = this->GetParam();\n    stride_ = params_.block_size * 3;\n    mask_ = (1 << params_.bit_depth) - 1;\n  }\n\n  void Predict();\n\n  void CheckPrediction(int test_case_number, int *error_count) const {\n    // For each pixel ensure that the calculated value is the same as reference.\n    const int block_size = params_.block_size;\n    for (int y = 0; y < block_size; y++) {\n      for (int x = 0; x < block_size; x++) {\n        *error_count += ref_dst_[x + y * stride_] != dst_[x + y * stride_];\n        if (*error_count == 1) {\n          ASSERT_EQ(ref_dst_[x + y * stride_], dst_[x + y * stride_])\n              << \" Failed on Test Case Number \" << test_case_number;\n        }\n      }\n    }\n  }\n\n  Pixel *above_row_;\n  Pixel *left_col_;\n  Pixel *dst_;\n  Pixel *ref_dst_;\n  ptrdiff_t stride_;\n  int mask_;\n\n  PredParam params_;\n};",
          "class_name": "IntraPredTest",
          "class_pos": [
            [
              45,
              0
            ],
            [
              112,
              2
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct IntraPredParam {\n  IntraPredParam(IntraPredFunc pred = NULL, IntraPredFunc ref = NULL,\n                 int block_size_value = 0, int bit_depth_value = 0)\n      : pred_fn(pred), ref_fn(ref), block_size(block_size_value),\n        bit_depth(bit_depth_value) {}\n\n  IntraPredFunc pred_fn;\n  IntraPredFunc ref_fn;\n  int block_size;\n  int bit_depth;\n}",
          {
            "pred_fn": "IntraPredFunc",
            "ref_fn": "IntraPredFunc",
            "block_size": "int",
            "bit_depth": "int"
          },
          "IntraPredParam",
          [
            33,
            0
          ],
          [
            43,
            1
          ]
        ],
        [
          "struct HighbdIntraPredParam {\n  HighbdIntraPredParam(HighbdIntraPred pred = NULL, HighbdIntraPred ref = NULL,\n                       int block_size_value = 0, int bit_depth_value = 0)\n      : pred_fn(pred), ref_fn(ref), block_size(block_size_value),\n        bit_depth(bit_depth_value) {}\n\n  HighbdIntraPred pred_fn;\n  HighbdIntraPred ref_fn;\n  int block_size;\n  int bit_depth;\n}",
          {
            "pred_fn": "HighbdIntraPred",
            "ref_fn": "HighbdIntraPred",
            "block_size": "int",
            "bit_depth": "int"
          },
          "HighbdIntraPredParam",
          [
            444,
            0
          ],
          [
            454,
            1
          ]
        ],
        [
          "struct IntraPredParam {\n  IntraPredParam(IntraPredFunc pred = NULL, IntraPredFunc ref = NULL,\n                 int block_size_value = 0, int bit_depth_value = 0)\n      : pred_fn(pred), ref_fn(ref), block_size(block_size_value),\n        bit_depth(bit_depth_value) {}\n\n  IntraPredFunc pred_fn;\n  IntraPredFunc ref_fn;\n  int block_size;\n  int bit_depth;\n}",
          {
            "pred_fn": "IntraPredFunc",
            "ref_fn": "IntraPredFunc",
            "block_size": "int",
            "bit_depth": "int"
          },
          "IntraPredParam",
          [
            33,
            0
          ],
          [
            43,
            1
          ]
        ],
        [
          "struct HighbdIntraPredParam {\n  HighbdIntraPredParam(HighbdIntraPred pred = NULL, HighbdIntraPred ref = NULL,\n                       int block_size_value = 0, int bit_depth_value = 0)\n      : pred_fn(pred), ref_fn(ref), block_size(block_size_value),\n        bit_depth(bit_depth_value) {}\n\n  HighbdIntraPred pred_fn;\n  HighbdIntraPred ref_fn;\n  int block_size;\n  int bit_depth;\n}",
          {
            "pred_fn": "HighbdIntraPred",
            "ref_fn": "HighbdIntraPred",
            "block_size": "int",
            "bit_depth": "int"
          },
          "HighbdIntraPredParam",
          [
            444,
            0
          ],
          [
            454,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include <string>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_blockd.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_pred_common.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp9_motion_vector_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "MotionVectorTestLarge()\n      : EncoderTest(GET_PARAM(0)), encoding_mode_(GET_PARAM(1)),\n        cpu_used_(GET_PARAM(2)), mv_test_mode_(GET_PARAM(3)) {}",
          "fn_code_pos": [
            [
              40,
              2
            ],
            [
              42,
              63
            ]
          ],
          "class_code": "5e5714e53621f1b79fad8028df90aa684145e6149ef5dc3749610492a2b94c3f",
          "class_node_pos": [
            [
              35,
              0
            ],
            [
              78,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MotionVectorTestLarge",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~MotionVectorTestLarge() {}",
          "fn_code_pos": [
            [
              44,
              2
            ],
            [
              44,
              37
            ]
          ],
          "class_code": "5e5714e53621f1b79fad8028df90aa684145e6149ef5dc3749610492a2b94c3f",
          "class_node_pos": [
            [
              35,
              0
            ],
            [
              78,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n    if (encoding_mode_ != ::libvpx_test::kRealTime) {\n      cfg_.g_lag_in_frames = 3;\n      cfg_.rc_end_usage = VPX_VBR;\n    } else {\n      cfg_.g_lag_in_frames = 0;\n      cfg_.rc_end_usage = VPX_CBR;\n      cfg_.rc_buf_sz = 1000;\n      cfg_.rc_buf_initial_sz = 500;\n      cfg_.rc_buf_optimal_sz = 600;\n    }\n  }",
          "fn_code_pos": [
            [
              46,
              2
            ],
            [
              59,
              3
            ]
          ],
          "class_code": "5e5714e53621f1b79fad8028df90aa684145e6149ef5dc3749610492a2b94c3f",
          "class_node_pos": [
            [
              35,
              0
            ],
            [
              78,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, cpu_used_);\n      encoder->Control(VP9E_ENABLE_MOTION_VECTOR_UNIT_TEST, mv_test_mode_);\n      if (encoding_mode_ != ::libvpx_test::kRealTime) {\n        encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n        encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n        encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n        encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              61,
              2
            ],
            [
              73,
              3
            ]
          ],
          "class_code": "5e5714e53621f1b79fad8028df90aa684145e6149ef5dc3749610492a2b94c3f",
          "class_node_pos": [
            [
              35,
              0
            ],
            [
              78,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(MotionVectorTestLarge, OverallTest) {\n  cfg_.rc_target_bitrate = 24000;\n  cfg_.g_profile = 0;\n  init_flags_ = VPX_CODEC_USE_PSNR;\n\n  std::unique_ptr<libvpx_test::VideoSource> video;\n  video.reset(new libvpx_test::YUVVideoSource(\n      \"niklas_640_480_30.yuv\", VPX_IMG_FMT_I420, 3840, 2160,  // 2048, 1080,\n      30, 1, 0, 5));\n\n  ASSERT_TRUE(video.get() != NULL);\n  ASSERT_NO_FATAL_FAILURE(RunLoop(video.get()));\n}",
          "fn_code_pos": [
            [
              80,
              0
            ],
            [
              92,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "5e5714e53621f1b79fad8028df90aa684145e6149ef5dc3749610492a2b94c3f": {
          "class_code": "class MotionVectorTestLarge\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWith3Params<libvpx_test::TestMode, int,\n                                                 int> {\n protected:\n  MotionVectorTestLarge()\n      : EncoderTest(GET_PARAM(0)), encoding_mode_(GET_PARAM(1)),\n        cpu_used_(GET_PARAM(2)), mv_test_mode_(GET_PARAM(3)) {}\n\n  virtual ~MotionVectorTestLarge() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n    if (encoding_mode_ != ::libvpx_test::kRealTime) {\n      cfg_.g_lag_in_frames = 3;\n      cfg_.rc_end_usage = VPX_VBR;\n    } else {\n      cfg_.g_lag_in_frames = 0;\n      cfg_.rc_end_usage = VPX_CBR;\n      cfg_.rc_buf_sz = 1000;\n      cfg_.rc_buf_initial_sz = 500;\n      cfg_.rc_buf_optimal_sz = 600;\n    }\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, cpu_used_);\n      encoder->Control(VP9E_ENABLE_MOTION_VECTOR_UNIT_TEST, mv_test_mode_);\n      if (encoding_mode_ != ::libvpx_test::kRealTime) {\n        encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n        encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n        encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n        encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n      }\n    }\n  }\n\n  libvpx_test::TestMode encoding_mode_;\n  int cpu_used_;\n  int mv_test_mode_;\n}",
          "class_name": "MotionVectorTestLarge",
          "class_pos": [
            [
              35,
              0
            ],
            [
              78,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <memory>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/yuv_video_source.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp8_boolcoder_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "void encrypt_buffer(uint8_t *buffer, size_t size) {\n  for (size_t i = 0; i < size; ++i) {\n    buffer[i] ^= secret_key[i & 15];\n  }\n}",
          "fn_code_pos": [
            [
              36,
              0
            ],
            [
              40,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "encrypt_buffer",
            "parameters": {
              "buffer": "uint8_t",
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void test_decrypt_cb(void *decrypt_state, const uint8_t *input, uint8_t *output,\n                     int count) {\n  const size_t offset = input - reinterpret_cast<uint8_t *>(decrypt_state);\n  for (int i = 0; i < count; i++) {\n    output[i] = input[i] ^ secret_key[(offset + i) & 15];\n  }\n}",
          "fn_code_pos": [
            [
              42,
              0
            ],
            [
              48,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "test_decrypt_cb",
            "parameters": {
              "decrypt_state": "void",
              "input": "uint8_t",
              "output": "uint8_t",
              "count": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST(VP8, TestBitIO) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  for (int n = 0; n < num_tests; ++n) {\n    for (int method = 0; method <= 7; ++method) {  // we generate various proba\n      const int kBitsToTest = 1000;\n      uint8_t probas[kBitsToTest];\n\n      for (int i = 0; i < kBitsToTest; ++i) {\n        const int parity = i & 1;\n        /* clang-format off */\n        probas[i] =\n            (method == 0) ? 0 : (method == 1) ? 255 :\n            (method == 2) ? 128 :\n            (method == 3) ? rnd.Rand8() :\n            (method == 4) ? (parity ? 0 : 255) :\n            // alternate between low and high proba:\n            (method == 5) ? (parity ? rnd(128) : 255 - rnd(128)) :\n            (method == 6) ?\n                (parity ? rnd(64) : 255 - rnd(64)) :\n                (parity ? rnd(32) : 255 - rnd(32));\n        /* clang-format on */\n      }\n      for (int bit_method = 0; bit_method <= 3; ++bit_method) {\n        const int random_seed = 6432;\n        const int kBufferSize = 10000;\n        ACMRandom bit_rnd(random_seed);\n        BOOL_CODER bw;\n        uint8_t bw_buffer[kBufferSize];\n        vp8_start_encode(&bw, bw_buffer, bw_buffer + kBufferSize);\n\n        int bit = (bit_method == 0) ? 0 : (bit_method == 1) ? 1 : 0;\n        for (int i = 0; i < kBitsToTest; ++i) {\n          if (bit_method == 2) {\n            bit = (i & 1);\n          } else if (bit_method == 3) {\n            bit = bit_rnd(2);\n          }\n          vp8_encode_bool(&bw, bit, static_cast<int>(probas[i]));\n        }\n\n        vp8_stop_encode(&bw);\n\n        BOOL_DECODER br;\n        encrypt_buffer(bw_buffer, kBufferSize);\n        vp8dx_start_decode(&br, bw_buffer, kBufferSize, test_decrypt_cb,\n                           reinterpret_cast<void *>(bw_buffer));\n        bit_rnd.Reset(random_seed);\n        for (int i = 0; i < kBitsToTest; ++i) {\n          if (bit_method == 2) {\n            bit = (i & 1);\n          } else if (bit_method == 3) {\n            bit = bit_rnd(2);\n          }\n          GTEST_ASSERT_EQ(vp8dx_decode_bool(&br, probas[i]), bit)\n              << \"pos: \" << i << \" / \" << kBitsToTest\n              << \" bit_method: \" << bit_method << \" method: \" << method;\n        }\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              54,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              55,
              12
            ],
            [
              55,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "bit_rnd(random_seed)",
          "fn_dec_pos": [
            [
              79,
              18
            ],
            [
              79,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bit_rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <math.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stddef.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"vp8/decoder/dboolhuff.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"vp8/encoder/boolhuff.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp9_arf_freq_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "int is_extension_y4m(const char *filename) {\n  const char *dot = strrchr(filename, '.');\n  if (!dot || dot == filename) {\n    return 0;\n  } else {\n    return !strcmp(dot, \".y4m\");\n  }\n}",
          "fn_code_pos": [
            [
              70,
              0
            ],
            [
              77,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "is_extension_y4m",
            "parameters": {
              "filename": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ArfFreqTest()\n      : EncoderTest(GET_PARAM(0)), test_video_param_(GET_PARAM(1)),\n        test_encode_param_(GET_PARAM(2)), min_arf_requested_(GET_PARAM(3)) {}",
          "fn_code_pos": [
            [
              84,
              2
            ],
            [
              86,
              77
            ]
          ],
          "class_code": "e196a7cb3ebe27b8c7e82b41fb9b2faed3173a7c5b8cd9e759d7d6dfb96e9b11",
          "class_node_pos": [
            [
              79,
              0
            ],
            [
              183,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ArfFreqTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~ArfFreqTest() {}",
          "fn_code_pos": [
            [
              88,
              2
            ],
            [
              88,
              27
            ]
          ],
          "class_code": "e196a7cb3ebe27b8c7e82b41fb9b2faed3173a7c5b8cd9e759d7d6dfb96e9b11",
          "class_node_pos": [
            [
              79,
              0
            ],
            [
              183,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(test_encode_param_.mode);\n    if (test_encode_param_.mode != ::libvpx_test::kRealTime) {\n      cfg_.g_lag_in_frames = 25;\n      cfg_.rc_end_usage = VPX_VBR;\n    } else {\n      cfg_.g_lag_in_frames = 0;\n      cfg_.rc_end_usage = VPX_CBR;\n      cfg_.rc_buf_sz = 1000;\n      cfg_.rc_buf_initial_sz = 500;\n      cfg_.rc_buf_optimal_sz = 600;\n    }\n    dec_cfg_.threads = 4;\n  }",
          "fn_code_pos": [
            [
              90,
              2
            ],
            [
              104,
              3
            ]
          ],
          "class_code": "e196a7cb3ebe27b8c7e82b41fb9b2faed3173a7c5b8cd9e759d7d6dfb96e9b11",
          "class_node_pos": [
            [
              79,
              0
            ],
            [
              183,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void BeginPassHook(unsigned int) {\n    min_run_ = ARF_NOT_SEEN;\n    run_of_visible_frames_ = 0;\n  }",
          "fn_code_pos": [
            [
              106,
              2
            ],
            [
              109,
              3
            ]
          ],
          "class_code": "e196a7cb3ebe27b8c7e82b41fb9b2faed3173a7c5b8cd9e759d7d6dfb96e9b11",
          "class_node_pos": [
            [
              79,
              0
            ],
            [
              183,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BeginPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int GetNumFramesInPkt(const vpx_codec_cx_pkt_t *pkt) {\n    const uint8_t *buffer = reinterpret_cast<uint8_t *>(pkt->data.frame.buf);\n    const uint8_t marker = buffer[pkt->data.frame.sz - 1];\n    const int mag = ((marker >> 3) & 3) + 1;\n    int frames = (marker & 0x7) + 1;\n    const unsigned int index_sz = 2 + mag * frames;\n    // Check for superframe or not.\n    // Assume superframe has only one visible frame, the rest being\n    // invisible. If superframe index is not found, then there is only\n    // one frame.\n    if (!((marker & 0xe0) == 0xc0 && pkt->data.frame.sz >= index_sz &&\n          buffer[pkt->data.frame.sz - index_sz] == marker)) {\n      frames = 1;\n    }\n    return frames;\n  }",
          "fn_code_pos": [
            [
              111,
              2
            ],
            [
              126,
              3
            ]
          ],
          "class_code": "e196a7cb3ebe27b8c7e82b41fb9b2faed3173a7c5b8cd9e759d7d6dfb96e9b11",
          "class_node_pos": [
            [
              79,
              0
            ],
            [
              183,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetNumFramesInPkt",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (pkt->kind != VPX_CODEC_CX_FRAME_PKT) return;\n    const int frames = GetNumFramesInPkt(pkt);\n    if (frames == 1) {\n      run_of_visible_frames_++;\n    } else if (frames == 2) {\n      if (min_run_ == ARF_NOT_SEEN) {\n        min_run_ = ARF_SEEN_ONCE;\n      } else if (min_run_ == ARF_SEEN_ONCE ||\n                 run_of_visible_frames_ < min_run_) {\n        min_run_ = run_of_visible_frames_;\n      }\n      run_of_visible_frames_ = 1;\n    } else {\n      min_run_ = 0;\n      run_of_visible_frames_ = 1;\n    }\n  }",
          "fn_code_pos": [
            [
              128,
              2
            ],
            [
              145,
              3
            ]
          ],
          "class_code": "e196a7cb3ebe27b8c7e82b41fb9b2faed3173a7c5b8cd9e759d7d6dfb96e9b11",
          "class_node_pos": [
            [
              79,
              0
            ],
            [
              183,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING, 1);\n      encoder->Control(VP9E_SET_TILE_COLUMNS, 4);\n      encoder->Control(VP8E_SET_CPUUSED, test_encode_param_.cpu_used);\n      encoder->Control(VP9E_SET_MIN_GF_INTERVAL, min_arf_requested_);\n      if (test_encode_param_.mode != ::libvpx_test::kRealTime) {\n        encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n        encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n        encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n        encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              147,
              2
            ],
            [
              161,
              3
            ]
          ],
          "class_code": "e196a7cb3ebe27b8c7e82b41fb9b2faed3173a7c5b8cd9e759d7d6dfb96e9b11",
          "class_node_pos": [
            [
              79,
              0
            ],
            [
              183,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int GetMinVisibleRun() const { return min_run_; }",
          "fn_code_pos": [
            [
              163,
              2
            ],
            [
              163,
              51
            ]
          ],
          "class_code": "e196a7cb3ebe27b8c7e82b41fb9b2faed3173a7c5b8cd9e759d7d6dfb96e9b11",
          "class_node_pos": [
            [
              79,
              0
            ],
            [
              183,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetMinVisibleRun",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int GetMinArfDistanceRequested() const {\n    if (min_arf_requested_) {\n      return min_arf_requested_;\n    } else {\n      return vp9_rc_get_default_min_gf_interval(\n          test_video_param_.width, test_video_param_.height,\n          (double)test_video_param_.framerate_num /\n              test_video_param_.framerate_den);\n    }\n  }",
          "fn_code_pos": [
            [
              165,
              2
            ],
            [
              174,
              3
            ]
          ],
          "class_code": "e196a7cb3ebe27b8c7e82b41fb9b2faed3173a7c5b8cd9e759d7d6dfb96e9b11",
          "class_node_pos": [
            [
              79,
              0
            ],
            [
              183,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetMinArfDistanceRequested",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TEST_P(ArfFreqTest, MinArfFreqTest) {\n  cfg_.rc_target_bitrate = kBitrate;\n  cfg_.g_error_resilient = 0;\n  cfg_.g_profile = test_video_param_.profile;\n  cfg_.g_input_bit_depth = test_video_param_.input_bit_depth;\n  cfg_.g_bit_depth = test_video_param_.bit_depth;\n  init_flags_ = VPX_CODEC_USE_PSNR;\n  if (cfg_.g_bit_depth > 8) init_flags_ |= VPX_CODEC_USE_HIGHBITDEPTH;\n\n  std::unique_ptr<libvpx_test::VideoSource> video;\n  if (is_extension_y4m(test_video_param_.filename)) {\n    video.reset(new libvpx_test::Y4mVideoSource(test_video_param_.filename, 0,\n                                                kFrames));\n  } else {\n    video.reset(new libvpx_test::YUVVideoSource(\n        test_video_param_.filename, test_video_param_.fmt,\n        test_video_param_.width, test_video_param_.height,\n        test_video_param_.framerate_num, test_video_param_.framerate_den, 0,\n        kFrames));\n  }\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(video.get()));\n  const int min_run = GetMinVisibleRun();\n  const int min_arf_dist_requested = GetMinArfDistanceRequested();\n  if (min_run != ARF_NOT_SEEN && min_run != ARF_SEEN_ONCE) {\n    const int min_arf_dist = min_run + 1;\n    EXPECT_GE(min_arf_dist, min_arf_dist_requested);\n  }\n}",
          "fn_code_pos": [
            [
              185,
              0
            ],
            [
              213,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "e196a7cb3ebe27b8c7e82b41fb9b2faed3173a7c5b8cd9e759d7d6dfb96e9b11": {
          "class_code": "class ArfFreqTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWith3Params<TestVideoParam,\n                                                 TestEncodeParam, int> {\n protected:\n  ArfFreqTest()\n      : EncoderTest(GET_PARAM(0)), test_video_param_(GET_PARAM(1)),\n        test_encode_param_(GET_PARAM(2)), min_arf_requested_(GET_PARAM(3)) {}\n\n  virtual ~ArfFreqTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(test_encode_param_.mode);\n    if (test_encode_param_.mode != ::libvpx_test::kRealTime) {\n      cfg_.g_lag_in_frames = 25;\n      cfg_.rc_end_usage = VPX_VBR;\n    } else {\n      cfg_.g_lag_in_frames = 0;\n      cfg_.rc_end_usage = VPX_CBR;\n      cfg_.rc_buf_sz = 1000;\n      cfg_.rc_buf_initial_sz = 500;\n      cfg_.rc_buf_optimal_sz = 600;\n    }\n    dec_cfg_.threads = 4;\n  }\n\n  virtual void BeginPassHook(unsigned int) {\n    min_run_ = ARF_NOT_SEEN;\n    run_of_visible_frames_ = 0;\n  }\n\n  int GetNumFramesInPkt(const vpx_codec_cx_pkt_t *pkt) {\n    const uint8_t *buffer = reinterpret_cast<uint8_t *>(pkt->data.frame.buf);\n    const uint8_t marker = buffer[pkt->data.frame.sz - 1];\n    const int mag = ((marker >> 3) & 3) + 1;\n    int frames = (marker & 0x7) + 1;\n    const unsigned int index_sz = 2 + mag * frames;\n    // Check for superframe or not.\n    // Assume superframe has only one visible frame, the rest being\n    // invisible. If superframe index is not found, then there is only\n    // one frame.\n    if (!((marker & 0xe0) == 0xc0 && pkt->data.frame.sz >= index_sz &&\n          buffer[pkt->data.frame.sz - index_sz] == marker)) {\n      frames = 1;\n    }\n    return frames;\n  }\n\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (pkt->kind != VPX_CODEC_CX_FRAME_PKT) return;\n    const int frames = GetNumFramesInPkt(pkt);\n    if (frames == 1) {\n      run_of_visible_frames_++;\n    } else if (frames == 2) {\n      if (min_run_ == ARF_NOT_SEEN) {\n        min_run_ = ARF_SEEN_ONCE;\n      } else if (min_run_ == ARF_SEEN_ONCE ||\n                 run_of_visible_frames_ < min_run_) {\n        min_run_ = run_of_visible_frames_;\n      }\n      run_of_visible_frames_ = 1;\n    } else {\n      min_run_ = 0;\n      run_of_visible_frames_ = 1;\n    }\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING, 1);\n      encoder->Control(VP9E_SET_TILE_COLUMNS, 4);\n      encoder->Control(VP8E_SET_CPUUSED, test_encode_param_.cpu_used);\n      encoder->Control(VP9E_SET_MIN_GF_INTERVAL, min_arf_requested_);\n      if (test_encode_param_.mode != ::libvpx_test::kRealTime) {\n        encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n        encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n        encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n        encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n      }\n    }\n  }\n\n  int GetMinVisibleRun() const { return min_run_; }\n\n  int GetMinArfDistanceRequested() const {\n    if (min_arf_requested_) {\n      return min_arf_requested_;\n    } else {\n      return vp9_rc_get_default_min_gf_interval(\n          test_video_param_.width, test_video_param_.height,\n          (double)test_video_param_.framerate_num /\n              test_video_param_.framerate_den);\n    }\n  }\n\n  TestVideoParam test_video_param_;\n  TestEncodeParam test_encode_param_;\n\n private:\n  int min_arf_requested_;\n  int min_run_;\n  int run_of_visible_frames_;\n}",
          "class_name": "ArfFreqTest",
          "class_pos": [
            [
              79,
              0
            ],
            [
              183,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "typedef struct {\n  const char *filename;\n  unsigned int width;\n  unsigned int height;\n  unsigned int framerate_num;\n  unsigned int framerate_den;\n  unsigned int input_bit_depth;\n  vpx_img_fmt fmt;\n  vpx_bit_depth_t bit_depth;\n  unsigned int profile;\n} TestVideoParam;",
          {
            "char": "const",
            "width": "unsigned int",
            "height": "unsigned int",
            "framerate_num": "unsigned int",
            "framerate_den": "unsigned int",
            "input_bit_depth": "unsigned int",
            "fmt": "vpx_img_fmt",
            "bit_depth": "vpx_bit_depth_t",
            "profile": "unsigned int"
          },
          "TestVideoParam",
          [
            29,
            0
          ],
          [
            39,
            17
          ]
        ],
        [
          "typedef struct {\n  libvpx_test::TestMode mode;\n  int cpu_used;\n} TestEncodeParam;",
          {
            "mode": "libvpx_test::TestMode",
            "cpu_used": "int"
          },
          "TestEncodeParam",
          [
            41,
            0
          ],
          [
            44,
            18
          ]
        ],
        [
          "typedef struct {\n  const char *filename;\n  unsigned int width;\n  unsigned int height;\n  unsigned int framerate_num;\n  unsigned int framerate_den;\n  unsigned int input_bit_depth;\n  vpx_img_fmt fmt;\n  vpx_bit_depth_t bit_depth;\n  unsigned int profile;\n} TestVideoParam;",
          {
            "char": "const",
            "width": "unsigned int",
            "height": "unsigned int",
            "framerate_num": "unsigned int",
            "framerate_den": "unsigned int",
            "input_bit_depth": "unsigned int",
            "fmt": "vpx_img_fmt",
            "bit_depth": "vpx_bit_depth_t",
            "profile": "unsigned int"
          },
          "TestVideoParam",
          [
            29,
            0
          ],
          [
            39,
            17
          ]
        ],
        [
          "typedef struct {\n  libvpx_test::TestMode mode;\n  int cpu_used;\n} TestEncodeParam;",
          {
            "mode": "libvpx_test::TestMode",
            "cpu_used": "int"
          },
          "TestEncodeParam",
          [
            41,
            0
          ],
          [
            44,
            18
          ]
        ]
      ],
      "include_list": [
        [
          "#include <memory>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/y4m_video_source.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/yuv_video_source.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"vp9/encoder/vp9_ratectrl.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/set_roi.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST(VP8RoiMapTest, ParameterCheck) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  int delta_q[MAX_MB_SEGMENTS] = { -2, -25, 0, 31 };\n  int delta_lf[MAX_MB_SEGMENTS] = { -2, -25, 0, 31 };\n  unsigned int threshold[MAX_MB_SEGMENTS] = { 0, 100, 200, 300 };\n\n  const int internalq_trans[] = {\n    0,  1,  2,  3,  4,  5,  7,   8,   9,   10,  12,  13,  15,  17,  18,  19,\n    20, 21, 23, 24, 25, 26, 27,  28,  29,  30,  31,  33,  35,  37,  39,  41,\n    43, 45, 47, 49, 51, 53, 55,  57,  59,  61,  64,  67,  70,  73,  76,  79,\n    82, 85, 88, 91, 94, 97, 100, 103, 106, 109, 112, 115, 118, 121, 124, 127,\n  };\n\n  // Initialize elements of cpi with valid defaults.\n  VP8_COMP cpi;\n  cpi.mb.e_mbd.mb_segement_abs_delta = SEGMENT_DELTADATA;\n  cpi.cyclic_refresh_mode_enabled = 0;\n  cpi.mb.e_mbd.segmentation_enabled = 0;\n  cpi.mb.e_mbd.update_mb_segmentation_map = 0;\n  cpi.mb.e_mbd.update_mb_segmentation_data = 0;\n  cpi.common.mb_rows = 240 >> 4;\n  cpi.common.mb_cols = 320 >> 4;\n  const int mbs = (cpi.common.mb_rows * cpi.common.mb_cols);\n  memset(cpi.segment_feature_data, 0, sizeof(cpi.segment_feature_data));\n\n  // Segment map\n  cpi.segmentation_map = reinterpret_cast<unsigned char *>(vpx_calloc(mbs, 1));\n\n  // Allocate memory for the source memory map.\n  unsigned char *roi_map =\n      reinterpret_cast<unsigned char *>(vpx_calloc(mbs, 1));\n  memset(&roi_map[mbs >> 2], 1, (mbs >> 2));\n  memset(&roi_map[mbs >> 1], 2, (mbs >> 2));\n  memset(&roi_map[mbs - (mbs >> 2)], 3, (mbs >> 2));\n\n  // Do a test call with valid parameters.\n  int roi_retval =\n      vp8_set_roimap(&cpi, roi_map, cpi.common.mb_rows, cpi.common.mb_cols,\n                     delta_q, delta_lf, threshold);\n  EXPECT_EQ(0, roi_retval)\n      << \"vp8_set_roimap roi failed with default test parameters\";\n\n  // Check that the values in the cpi structure get set as expected.\n  if (roi_retval == 0) {\n    // Check that the segment map got set.\n    const int mapcompare = memcmp(roi_map, cpi.segmentation_map, mbs);\n    EXPECT_EQ(0, mapcompare) << \"segment map error\";\n\n    // Check the q deltas (note the need to translate into\n    // the interanl range of 0-127.\n    for (int i = 0; i < MAX_MB_SEGMENTS; ++i) {\n      const int transq = internalq_trans[abs(delta_q[i])];\n      if (abs(cpi.segment_feature_data[MB_LVL_ALT_Q][i]) != transq) {\n        EXPECT_EQ(transq, cpi.segment_feature_data[MB_LVL_ALT_Q][i])\n            << \"segment delta_q  error\";\n        break;\n      }\n    }\n\n    // Check the loop filter deltas\n    for (int i = 0; i < MAX_MB_SEGMENTS; ++i) {\n      if (cpi.segment_feature_data[MB_LVL_ALT_LF][i] != delta_lf[i]) {\n        EXPECT_EQ(delta_lf[i], cpi.segment_feature_data[MB_LVL_ALT_LF][i])\n            << \"segment delta_lf error\";\n        break;\n      }\n    }\n\n    // Check the breakout thresholds\n    for (int i = 0; i < MAX_MB_SEGMENTS; ++i) {\n      unsigned int breakout =\n          static_cast<unsigned int>(cpi.segment_encode_breakout[i]);\n\n      if (threshold[i] != breakout) {\n        EXPECT_EQ(threshold[i], breakout) << \"breakout threshold error\";\n        break;\n      }\n    }\n\n    // Segmentation, and segmentation update flages should be set.\n    EXPECT_EQ(1, cpi.mb.e_mbd.segmentation_enabled)\n        << \"segmentation_enabled error\";\n    EXPECT_EQ(1, cpi.mb.e_mbd.update_mb_segmentation_map)\n        << \"update_mb_segmentation_map error\";\n    EXPECT_EQ(1, cpi.mb.e_mbd.update_mb_segmentation_data)\n        << \"update_mb_segmentation_data error\";\n\n    // Try a range of delta q and lf parameters (some legal, some not)\n    for (int i = 0; i < 1000; ++i) {\n      int rand_deltas[4];\n      int deltas_valid;\n      rand_deltas[0] = rnd(160) - 80;\n      rand_deltas[1] = rnd(160) - 80;\n      rand_deltas[2] = rnd(160) - 80;\n      rand_deltas[3] = rnd(160) - 80;\n\n      deltas_valid =\n          ((abs(rand_deltas[0]) <= 63) && (abs(rand_deltas[1]) <= 63) &&\n           (abs(rand_deltas[2]) <= 63) && (abs(rand_deltas[3]) <= 63))\n              ? 0\n              : -1;\n\n      // Test with random delta q values.\n      roi_retval =\n          vp8_set_roimap(&cpi, roi_map, cpi.common.mb_rows, cpi.common.mb_cols,\n                         rand_deltas, delta_lf, threshold);\n      EXPECT_EQ(deltas_valid, roi_retval) << \"dq range check error\";\n\n      // One delta_q error shown at a time\n      if (deltas_valid != roi_retval) break;\n\n      // Test with random loop filter values.\n      roi_retval =\n          vp8_set_roimap(&cpi, roi_map, cpi.common.mb_rows, cpi.common.mb_cols,\n                         delta_q, rand_deltas, threshold);\n      EXPECT_EQ(deltas_valid, roi_retval) << \"dlf range check error\";\n\n      // One delta loop filter error shown at a time\n      if (deltas_valid != roi_retval) break;\n    }\n\n    // Test invalid number of rows or colums.\n    roi_retval =\n        vp8_set_roimap(&cpi, roi_map, cpi.common.mb_rows + 1,\n                       cpi.common.mb_cols, delta_q, delta_lf, threshold);\n    EXPECT_EQ(-1, roi_retval) << \"MB rows bounds check error\";\n\n    roi_retval =\n        vp8_set_roimap(&cpi, roi_map, cpi.common.mb_rows,\n                       cpi.common.mb_cols - 1, delta_q, delta_lf, threshold);\n    EXPECT_EQ(-1, roi_retval) << \"MB cols bounds check error\";\n  }\n\n  // Free allocated memory\n  if (cpi.segmentation_map) vpx_free(cpi.segmentation_map);\n  if (roi_map) vpx_free(roi_map);\n}",
          "fn_code_pos": [
            [
              27,
              0
            ],
            [
              163,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              28,
              12
            ],
            [
              28,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <math.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stddef.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"vp8/encoder/onyx_int.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp9_boolcoder_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST(VP9, TestBitIO) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  for (int n = 0; n < num_tests; ++n) {\n    for (int method = 0; method <= 7; ++method) {  // we generate various proba\n      const int kBitsToTest = 1000;\n      uint8_t probas[kBitsToTest];\n\n      for (int i = 0; i < kBitsToTest; ++i) {\n        const int parity = i & 1;\n        /* clang-format off */\n        probas[i] =\n          (method == 0) ? 0 : (method == 1) ? 255 :\n          (method == 2) ? 128 :\n          (method == 3) ? rnd.Rand8() :\n          (method == 4) ? (parity ? 0 : 255) :\n            // alternate between low and high proba:\n            (method == 5) ? (parity ? rnd(128) : 255 - rnd(128)) :\n            (method == 6) ?\n            (parity ? rnd(64) : 255 - rnd(64)) :\n            (parity ? rnd(32) : 255 - rnd(32));\n        /* clang-format on */\n      }\n      for (int bit_method = 0; bit_method <= 3; ++bit_method) {\n        const int random_seed = 6432;\n        const int kBufferSize = 10000;\n        ACMRandom bit_rnd(random_seed);\n        vpx_writer bw;\n        uint8_t bw_buffer[kBufferSize];\n        vpx_start_encode(&bw, bw_buffer);\n\n        int bit = (bit_method == 0) ? 0 : (bit_method == 1) ? 1 : 0;\n        for (int i = 0; i < kBitsToTest; ++i) {\n          if (bit_method == 2) {\n            bit = (i & 1);\n          } else if (bit_method == 3) {\n            bit = bit_rnd(2);\n          }\n          vpx_write(&bw, bit, static_cast<int>(probas[i]));\n        }\n\n        vpx_stop_encode(&bw);\n\n        // First bit should be zero\n        GTEST_ASSERT_EQ(bw_buffer[0] & 0x80, 0);\n\n        vpx_reader br;\n        vpx_reader_init(&br, bw_buffer, kBufferSize, NULL, NULL);\n        bit_rnd.Reset(random_seed);\n        for (int i = 0; i < kBitsToTest; ++i) {\n          if (bit_method == 2) {\n            bit = (i & 1);\n          } else if (bit_method == 3) {\n            bit = bit_rnd(2);\n          }\n          GTEST_ASSERT_EQ(vpx_read(&br, probas[i]), bit)\n              << \"pos: \" << i << \" / \" << kBitsToTest\n              << \" bit_method: \" << bit_method << \" method: \" << method;\n        }\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              27,
              0
            ],
            [
              88,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              28,
              12
            ],
            [
              28,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "bit_rnd(random_seed)",
          "fn_dec_pos": [
            [
              52,
              18
            ],
            [
              52,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bit_rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <math.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"vpx_dsp/bitreader.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"vpx_dsp/bitwriter.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/decode_svc_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "DecodeSvcTest() : DecoderTest(GET_PARAM(::libvpx_test::kCodecFactoryParam)) {}",
          "fn_code_pos": [
            [
              26,
              2
            ],
            [
              26,
              80
            ]
          ],
          "class_code": "f4e5e2c02b27eeea7299d322b1de288b4b4007ec8ad39075392020759d170eb5",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              47,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecodeSvcTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DecodeSvcTest() {}",
          "fn_code_pos": [
            [
              27,
              2
            ],
            [
              27,
              29
            ]
          ],
          "class_code": "f4e5e2c02b27eeea7299d322b1de288b4b4007ec8ad39075392020759d170eb5",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              47,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void PreDecodeFrameHook(\n      const libvpx_test::CompressedVideoSource &video,\n      libvpx_test::Decoder *decoder) {\n    if (video.frame_number() == 0)\n      decoder->Control(VP9_DECODE_SVC_SPATIAL_LAYER, spatial_layer_);\n  }",
          "fn_code_pos": [
            [
              29,
              2
            ],
            [
              34,
              3
            ]
          ],
          "class_code": "f4e5e2c02b27eeea7299d322b1de288b4b4007ec8ad39075392020759d170eb5",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              47,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreDecodeFrameHook",
            "parameters": {
              "video": "libvpx_test::CompressedVideoSource",
              "decoder": "libvpx_test::Decoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void DecompressedFrameHook(const vpx_image_t &img,\n                                     const unsigned int frame_number) {\n    ASSERT_EQ(img.d_w, width_);\n    ASSERT_EQ(img.d_h, height_);\n    total_frames_ = frame_number;\n  }",
          "fn_code_pos": [
            [
              36,
              2
            ],
            [
              41,
              3
            ]
          ],
          "class_code": "f4e5e2c02b27eeea7299d322b1de288b4b4007ec8ad39075392020759d170eb5",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              47,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecompressedFrameHook",
            "parameters": {
              "img": "vpx_image_t",
              "frame_number": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(DecodeSvcTest, DecodeSvcTestUpToSpatialLayer0) {\n  const std::string filename = GET_PARAM(1);\n  std::unique_ptr<libvpx_test::CompressedVideoSource> video;\n  video.reset(new libvpx_test::IVFVideoSource(filename));\n  ASSERT_TRUE(video.get() != NULL);\n  video->Init();\n  total_frames_ = 0;\n  spatial_layer_ = 0;\n  width_ = 320;\n  height_ = 180;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(video.get()));\n  ASSERT_EQ(total_frames_, kNumFrames);\n}",
          "fn_code_pos": [
            [
              54,
              0
            ],
            [
              66,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DecodeSvcTest, DecodeSvcTestUpToSpatialLayer1) {\n  const std::string filename = GET_PARAM(1);\n  std::unique_ptr<libvpx_test::CompressedVideoSource> video;\n  video.reset(new libvpx_test::IVFVideoSource(filename));\n  ASSERT_TRUE(video.get() != NULL);\n  video->Init();\n  total_frames_ = 0;\n  spatial_layer_ = 1;\n  width_ = 640;\n  height_ = 360;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(video.get()));\n  ASSERT_EQ(total_frames_, kNumFrames);\n}",
          "fn_code_pos": [
            [
              71,
              0
            ],
            [
              83,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DecodeSvcTest, DecodeSvcTestUpToSpatialLayer2) {\n  const std::string filename = GET_PARAM(1);\n  std::unique_ptr<libvpx_test::CompressedVideoSource> video;\n  video.reset(new libvpx_test::IVFVideoSource(filename));\n  ASSERT_TRUE(video.get() != NULL);\n  video->Init();\n  total_frames_ = 0;\n  spatial_layer_ = 2;\n  width_ = 1280;\n  height_ = 720;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(video.get()));\n  ASSERT_EQ(total_frames_, kNumFrames);\n}",
          "fn_code_pos": [
            [
              88,
              0
            ],
            [
              100,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DecodeSvcTest, DecodeSvcTestUpToSpatialLayer10) {\n  const std::string filename = GET_PARAM(1);\n  std::unique_ptr<libvpx_test::CompressedVideoSource> video;\n  video.reset(new libvpx_test::IVFVideoSource(filename));\n  ASSERT_TRUE(video.get() != NULL);\n  video->Init();\n  total_frames_ = 0;\n  spatial_layer_ = 10;\n  width_ = 1280;\n  height_ = 720;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(video.get()));\n  ASSERT_EQ(total_frames_, kNumFrames);\n}",
          "fn_code_pos": [
            [
              106,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "f4e5e2c02b27eeea7299d322b1de288b4b4007ec8ad39075392020759d170eb5": {
          "class_code": "class DecodeSvcTest : public ::libvpx_test::DecoderTest,\n                      public ::libvpx_test::CodecTestWithParam<const char *> {\n protected:\n  DecodeSvcTest() : DecoderTest(GET_PARAM(::libvpx_test::kCodecFactoryParam)) {}\n  virtual ~DecodeSvcTest() {}\n\n  virtual void PreDecodeFrameHook(\n      const libvpx_test::CompressedVideoSource &video,\n      libvpx_test::Decoder *decoder) {\n    if (video.frame_number() == 0)\n      decoder->Control(VP9_DECODE_SVC_SPATIAL_LAYER, spatial_layer_);\n  }\n\n  virtual void DecompressedFrameHook(const vpx_image_t &img,\n                                     const unsigned int frame_number) {\n    ASSERT_EQ(img.d_w, width_);\n    ASSERT_EQ(img.d_h, height_);\n    total_frames_ = frame_number;\n  }\n\n  int spatial_layer_;\n  unsigned int width_;\n  unsigned int height_;\n  unsigned int total_frames_;\n}",
          "class_name": "DecodeSvcTest",
          "class_pos": [
            [
              23,
              0
            ],
            [
              47,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <memory>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/decode_test_driver.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/ivf_video_source.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/test_vectors.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/keyframe_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "KeyframeTest() : EncoderTest(GET_PARAM(0)) {}",
          "fn_code_pos": [
            [
              23,
              2
            ],
            [
              23,
              47
            ]
          ],
          "class_code": "9f5911886c6c7897d8f061f1a5792b1a1a0e5c0f4a647869a6a882edbf6e82de",
          "class_node_pos": [
            [
              19,
              0
            ],
            [
              58,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "KeyframeTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~KeyframeTest() {}",
          "fn_code_pos": [
            [
              24,
              2
            ],
            [
              24,
              28
            ]
          ],
          "class_code": "9f5911886c6c7897d8f061f1a5792b1a1a0e5c0f4a647869a6a882edbf6e82de",
          "class_node_pos": [
            [
              19,
              0
            ],
            [
              58,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n    kf_count_ = 0;\n    kf_count_max_ = INT_MAX;\n    kf_do_force_kf_ = false;\n    set_cpu_used_ = 0;\n  }",
          "fn_code_pos": [
            [
              26,
              2
            ],
            [
              33,
              3
            ]
          ],
          "class_code": "9f5911886c6c7897d8f061f1a5792b1a1a0e5c0f4a647869a6a882edbf6e82de",
          "class_node_pos": [
            [
              19,
              0
            ],
            [
              58,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (kf_do_force_kf_) {\n      frame_flags_ = (video->frame() % 3) ? 0 : VPX_EFLAG_FORCE_KF;\n    }\n    if (set_cpu_used_ && video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n    }\n  }",
          "fn_code_pos": [
            [
              35,
              2
            ],
            [
              43,
              3
            ]
          ],
          "class_code": "9f5911886c6c7897d8f061f1a5792b1a1a0e5c0f4a647869a6a882edbf6e82de",
          "class_node_pos": [
            [
              19,
              0
            ],
            [
              58,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (pkt->data.frame.flags & VPX_FRAME_IS_KEY) {\n      kf_pts_list_.push_back(pkt->data.frame.pts);\n      kf_count_++;\n      abort_ |= kf_count_ > kf_count_max_;\n    }\n  }",
          "fn_code_pos": [
            [
              45,
              2
            ],
            [
              51,
              3
            ]
          ],
          "class_code": "9f5911886c6c7897d8f061f1a5792b1a1a0e5c0f4a647869a6a882edbf6e82de",
          "class_node_pos": [
            [
              19,
              0
            ],
            [
              58,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(KeyframeTest, TestRandomVideoSource) {\n  // Validate that encoding the RandomVideoSource produces multiple keyframes.\n  // This validates the results of the TestDisableKeyframes test.\n  kf_count_max_ = 2;  // early exit successful tests.\n\n  ::libvpx_test::RandomVideoSource video;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  // In realtime mode - auto placed keyframes are exceedingly rare,  don't\n  // bother with this check   if(GetParam() > 0)\n  if (GET_PARAM(1) > 0) {\n    EXPECT_GT(kf_count_, 1);\n  }\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              73,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(KeyframeTest, TestDisableKeyframes) {\n  cfg_.kf_mode = VPX_KF_DISABLED;\n  kf_count_max_ = 1;  // early exit failed tests.\n\n  ::libvpx_test::RandomVideoSource video;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  EXPECT_EQ(1, kf_count_);\n}",
          "fn_code_pos": [
            [
              75,
              0
            ],
            [
              83,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(KeyframeTest, TestForceKeyframe) {\n  cfg_.kf_mode = VPX_KF_DISABLED;\n  kf_do_force_kf_ = true;\n\n  ::libvpx_test::DummyVideoSource video;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  // verify that every third frame is a keyframe.\n  for (std::vector<vpx_codec_pts_t>::const_iterator iter = kf_pts_list_.begin();\n       iter != kf_pts_list_.end(); ++iter) {\n    ASSERT_EQ(0, *iter % 3) << \"Unexpected keyframe at frame \" << *iter;\n  }\n}",
          "fn_code_pos": [
            [
              85,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(KeyframeTest, TestKeyframeMaxDistance) {\n  cfg_.kf_max_dist = 25;\n\n  ::libvpx_test::DummyVideoSource video;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  // verify that keyframe interval matches kf_max_dist\n  for (std::vector<vpx_codec_pts_t>::const_iterator iter = kf_pts_list_.begin();\n       iter != kf_pts_list_.end(); ++iter) {\n    ASSERT_EQ(0, *iter % 25) << \"Unexpected keyframe at frame \" << *iter;\n  }\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              110,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(KeyframeTest, TestAutoKeyframe) {\n  cfg_.kf_mode = VPX_KF_AUTO;\n  kf_do_force_kf_ = false;\n\n  // Force a deterministic speed step in Real Time mode, as the faster modes\n  // may not produce a keyframe like we expect. This is necessary when running\n  // on very slow environments (like Valgrind). The step -11 was determined\n  // experimentally as the fastest mode that still throws the keyframe.\n  if (deadline_ == VPX_DL_REALTIME) set_cpu_used_ = -11;\n\n  // This clip has a cut scene every 30 frames -> Frame 0, 30, 60, 90, 120.\n  // I check only the first 40 frames to make sure there's a keyframe at frame\n  // 0 and 30.\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 40);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  // In realtime mode - auto placed keyframes are exceedingly rare,  don't\n  // bother with this check\n  if (GET_PARAM(1) > 0) {\n    EXPECT_EQ(2u, kf_pts_list_.size()) << \" Not the right number of keyframes \";\n  }\n\n  // Verify that keyframes match the file keyframes in the file.\n  for (std::vector<vpx_codec_pts_t>::const_iterator iter = kf_pts_list_.begin();\n       iter != kf_pts_list_.end(); ++iter) {\n    if (deadline_ == VPX_DL_REALTIME && *iter > 0)\n      EXPECT_EQ(0, (*iter - 1) % 30)\n          << \"Unexpected keyframe at frame \" << *iter;\n    else\n      EXPECT_EQ(0, *iter % 30) << \"Unexpected keyframe at frame \" << *iter;\n  }\n}",
          "fn_code_pos": [
            [
              112,
              0
            ],
            [
              145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "9f5911886c6c7897d8f061f1a5792b1a1a0e5c0f4a647869a6a882edbf6e82de": {
          "class_code": "class KeyframeTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWithParam<libvpx_test::TestMode> {\n protected:\n  KeyframeTest() : EncoderTest(GET_PARAM(0)) {}\n  virtual ~KeyframeTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n    kf_count_ = 0;\n    kf_count_max_ = INT_MAX;\n    kf_do_force_kf_ = false;\n    set_cpu_used_ = 0;\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (kf_do_force_kf_) {\n      frame_flags_ = (video->frame() % 3) ? 0 : VPX_EFLAG_FORCE_KF;\n    }\n    if (set_cpu_used_ && video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n    }\n  }\n\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (pkt->data.frame.flags & VPX_FRAME_IS_KEY) {\n      kf_pts_list_.push_back(pkt->data.frame.pts);\n      kf_count_++;\n      abort_ |= kf_count_ > kf_count_max_;\n    }\n  }\n\n  bool kf_do_force_kf_;\n  int kf_count_;\n  int kf_count_max_;\n  std::vector<vpx_codec_pts_t> kf_pts_list_;\n  int set_cpu_used_;\n}",
          "class_name": "KeyframeTest",
          "class_pos": [
            [
              19,
              0
            ],
            [
              58,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <climits>\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/fdct8x8_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "void reference_8x8_dct_1d(const double in[8], double out[8]) {\n  const double kInvSqrt2 = 0.707106781186547524400844362104;\n  for (int k = 0; k < 8; k++) {\n    out[k] = 0.0;\n    for (int n = 0; n < 8; n++) {\n      out[k] += in[n] * cos(kPi * (2 * n + 1) * k / 16.0);\n    }\n    if (k == 0) out[k] = out[k] * kInvSqrt2;\n  }\n}",
          "fn_code_pos": [
            [
              50,
              0
            ],
            [
              59,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reference_8x8_dct_1d",
            "parameters": {
              "in": "double",
              "out": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void reference_8x8_dct_2d(const int16_t input[kNumCoeffs],\n                          double output[kNumCoeffs]) {\n  // First transform columns\n  for (int i = 0; i < 8; ++i) {\n    double temp_in[8], temp_out[8];\n    for (int j = 0; j < 8; ++j) temp_in[j] = input[j * 8 + i];\n    reference_8x8_dct_1d(temp_in, temp_out);\n    for (int j = 0; j < 8; ++j) output[j * 8 + i] = temp_out[j];\n  }\n  // Then transform rows\n  for (int i = 0; i < 8; ++i) {\n    double temp_in[8], temp_out[8];\n    for (int j = 0; j < 8; ++j) temp_in[j] = output[j + i * 8];\n    reference_8x8_dct_1d(temp_in, temp_out);\n    // Scale by some magic number\n    for (int j = 0; j < 8; ++j) output[j + i * 8] = temp_out[j] * 2;\n  }\n}",
          "fn_code_pos": [
            [
              61,
              0
            ],
            [
              78,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reference_8x8_dct_2d",
            "parameters": {
              "input": "int16_t",
              "output": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void fdct8x8_ref(const int16_t *in, tran_low_t *out, int stride,\n                 int /*tx_type*/) {\n  vpx_fdct8x8_c(in, out, stride);\n}",
          "fn_code_pos": [
            [
              80,
              0
            ],
            [
              83,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fdct8x8_ref",
            "parameters": {
              "in": "int16_t",
              "out": "tran_low_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void fht8x8_ref(const int16_t *in, tran_low_t *out, int stride, int tx_type) {\n  vp9_fht8x8_c(in, out, stride, tx_type);\n}",
          "fn_code_pos": [
            [
              85,
              0
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fht8x8_ref",
            "parameters": {
              "in": "int16_t",
              "out": "tran_low_t",
              "stride": "int",
              "tx_type": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct8x8_10(const tran_low_t *in, uint8_t *out, int stride) {\n  vpx_highbd_idct8x8_64_add_c(in, CAST_TO_SHORTPTR(out), stride, 10);\n}",
          "fn_code_pos": [
            [
              90,
              0
            ],
            [
              92,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct8x8_10",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct8x8_12(const tran_low_t *in, uint8_t *out, int stride) {\n  vpx_highbd_idct8x8_64_add_c(in, CAST_TO_SHORTPTR(out), stride, 12);\n}",
          "fn_code_pos": [
            [
              94,
              0
            ],
            [
              96,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct8x8_12",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void iht8x8_10(const tran_low_t *in, uint8_t *out, int stride, int tx_type) {\n  vp9_highbd_iht8x8_64_add_c(in, CAST_TO_SHORTPTR(out), stride, tx_type, 10);\n}",
          "fn_code_pos": [
            [
              98,
              0
            ],
            [
              100,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iht8x8_10",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int",
              "tx_type": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void iht8x8_12(const tran_low_t *in, uint8_t *out, int stride, int tx_type) {\n  vp9_highbd_iht8x8_64_add_c(in, CAST_TO_SHORTPTR(out), stride, tx_type, 12);\n}",
          "fn_code_pos": [
            [
              102,
              0
            ],
            [
              104,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iht8x8_12",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int",
              "tx_type": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct8x8_12_add_10_c(const tran_low_t *in, uint8_t *out, int stride) {\n  vpx_highbd_idct8x8_12_add_c(in, CAST_TO_SHORTPTR(out), stride, 10);\n}",
          "fn_code_pos": [
            [
              108,
              0
            ],
            [
              110,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct8x8_12_add_10_c",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct8x8_12_add_12_c(const tran_low_t *in, uint8_t *out, int stride) {\n  vpx_highbd_idct8x8_12_add_c(in, CAST_TO_SHORTPTR(out), stride, 12);\n}",
          "fn_code_pos": [
            [
              112,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct8x8_12_add_12_c",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct8x8_12_add_10_sse2(const tran_low_t *in, uint8_t *out, int stride) {\n  vpx_highbd_idct8x8_12_add_sse2(in, CAST_TO_SHORTPTR(out), stride, 10);\n}",
          "fn_code_pos": [
            [
              116,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct8x8_12_add_10_sse2",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct8x8_12_add_12_sse2(const tran_low_t *in, uint8_t *out, int stride) {\n  vpx_highbd_idct8x8_12_add_sse2(in, CAST_TO_SHORTPTR(out), stride, 12);\n}",
          "fn_code_pos": [
            [
              120,
              0
            ],
            [
              122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct8x8_12_add_12_sse2",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct8x8_64_add_10_sse2(const tran_low_t *in, uint8_t *out, int stride) {\n  vpx_highbd_idct8x8_64_add_sse2(in, CAST_TO_SHORTPTR(out), stride, 10);\n}",
          "fn_code_pos": [
            [
              124,
              0
            ],
            [
              126,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct8x8_64_add_10_sse2",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct8x8_64_add_12_sse2(const tran_low_t *in, uint8_t *out, int stride) {\n  vpx_highbd_idct8x8_64_add_sse2(in, CAST_TO_SHORTPTR(out), stride, 12);\n}",
          "fn_code_pos": [
            [
              128,
              0
            ],
            [
              130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct8x8_64_add_12_sse2",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual ~FwdTrans8x8TestBase() {}",
          "fn_code_pos": [
            [
              136,
              2
            ],
            [
              136,
              35
            ]
          ],
          "class_code": "22d673cabd6003c79007a9b5198758d3b5e2dd0d5e69805bdedbb68a23003ccc",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              524,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) = 0;",
          "fn_code_pos": [
            [
              139,
              2
            ],
            [
              139,
              72
            ]
          ],
          "class_code": "22d673cabd6003c79007a9b5198758d3b5e2dd0d5e69805bdedbb68a23003ccc",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              524,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunFwdTxfm",
            "parameters": {
              "in": "int16_t",
              "out": "tran_low_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) = 0;",
          "fn_code_pos": [
            [
              140,
              2
            ],
            [
              140,
              73
            ]
          ],
          "class_code": "22d673cabd6003c79007a9b5198758d3b5e2dd0d5e69805bdedbb68a23003ccc",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              524,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunInvTxfm",
            "parameters": {
              "out": "tran_low_t",
              "dst": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunSignBiasCheck() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    DECLARE_ALIGNED(16, int16_t, test_input_block[64]);\n    DECLARE_ALIGNED(16, tran_low_t, test_output_block[64]);\n    int count_sign_block[64][2];\n    const int count_test_block = 100000;\n\n    memset(count_sign_block, 0, sizeof(count_sign_block));\n\n    for (int i = 0; i < count_test_block; ++i) {\n      // Initialize a test block with input range [-255, 255].\n      for (int j = 0; j < 64; ++j) {\n        test_input_block[j] = ((rnd.Rand16() >> (16 - bit_depth_)) & mask_) -\n                              ((rnd.Rand16() >> (16 - bit_depth_)) & mask_);\n      }\n      ASM_REGISTER_STATE_CHECK(\n          RunFwdTxfm(test_input_block, test_output_block, pitch_));\n\n      for (int j = 0; j < 64; ++j) {\n        if (test_output_block[j] < 0) {\n          ++count_sign_block[j][0];\n        } else if (test_output_block[j] > 0) {\n          ++count_sign_block[j][1];\n        }\n      }\n    }\n\n    for (int j = 0; j < 64; ++j) {\n      const int diff = abs(count_sign_block[j][0] - count_sign_block[j][1]);\n      const int max_diff = kSignBiasMaxDiff255;\n      EXPECT_LT(diff, max_diff << (bit_depth_ - 8))\n          << \"Error: 8x8 FDCT/FHT has a sign bias > \"\n          << 1. * max_diff / count_test_block * 100 << \"%\"\n          << \" for input range [-255, 255] at index \" << j\n          << \" count0: \" << count_sign_block[j][0]\n          << \" count1: \" << count_sign_block[j][1] << \" diff: \" << diff;\n    }\n\n    memset(count_sign_block, 0, sizeof(count_sign_block));\n\n    for (int i = 0; i < count_test_block; ++i) {\n      // Initialize a test block with input range [-mask_ / 16, mask_ / 16].\n      for (int j = 0; j < 64; ++j) {\n        test_input_block[j] =\n            ((rnd.Rand16() & mask_) >> 4) - ((rnd.Rand16() & mask_) >> 4);\n      }\n      ASM_REGISTER_STATE_CHECK(\n          RunFwdTxfm(test_input_block, test_output_block, pitch_));\n\n      for (int j = 0; j < 64; ++j) {\n        if (test_output_block[j] < 0) {\n          ++count_sign_block[j][0];\n        } else if (test_output_block[j] > 0) {\n          ++count_sign_block[j][1];\n        }\n      }\n    }\n\n    for (int j = 0; j < 64; ++j) {\n      const int diff = abs(count_sign_block[j][0] - count_sign_block[j][1]);\n      const int max_diff = kSignBiasMaxDiff15;\n      EXPECT_LT(diff, max_diff << (bit_depth_ - 8))\n          << \"Error: 8x8 FDCT/FHT has a sign bias > \"\n          << 1. * max_diff / count_test_block * 100 << \"%\"\n          << \" for input range [-15, 15] at index \" << j\n          << \" count0: \" << count_sign_block[j][0]\n          << \" count1: \" << count_sign_block[j][1] << \" diff: \" << diff;\n    }\n  }",
          "fn_code_pos": [
            [
              142,
              2
            ],
            [
              210,
              3
            ]
          ],
          "class_code": "22d673cabd6003c79007a9b5198758d3b5e2dd0d5e69805bdedbb68a23003ccc",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              524,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunSignBiasCheck",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunRoundTripErrorCheck() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    int max_error = 0;\n    int total_error = 0;\n    const int count_test_block = 100000;\n    DECLARE_ALIGNED(16, int16_t, test_input_block[64]);\n    DECLARE_ALIGNED(16, tran_low_t, test_temp_block[64]);\n    DECLARE_ALIGNED(16, uint8_t, dst[64]);\n    DECLARE_ALIGNED(16, uint8_t, src[64]);\n#if CONFIG_VP9_HIGHBITDEPTH\n    DECLARE_ALIGNED(16, uint16_t, dst16[64]);\n    DECLARE_ALIGNED(16, uint16_t, src16[64]);\n#endif\n\n    for (int i = 0; i < count_test_block; ++i) {\n      // Initialize a test block with input range [-mask_, mask_].\n      for (int j = 0; j < 64; ++j) {\n        if (bit_depth_ == VPX_BITS_8) {\n          src[j] = rnd.Rand8();\n          dst[j] = rnd.Rand8();\n          test_input_block[j] = src[j] - dst[j];\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          src16[j] = rnd.Rand16() & mask_;\n          dst16[j] = rnd.Rand16() & mask_;\n          test_input_block[j] = src16[j] - dst16[j];\n#endif\n        }\n      }\n\n      ASM_REGISTER_STATE_CHECK(\n          RunFwdTxfm(test_input_block, test_temp_block, pitch_));\n      for (int j = 0; j < 64; ++j) {\n        if (test_temp_block[j] > 0) {\n          test_temp_block[j] += 2;\n          test_temp_block[j] /= 4;\n          test_temp_block[j] *= 4;\n        } else {\n          test_temp_block[j] -= 2;\n          test_temp_block[j] /= 4;\n          test_temp_block[j] *= 4;\n        }\n      }\n      if (bit_depth_ == VPX_BITS_8) {\n        ASM_REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        ASM_REGISTER_STATE_CHECK(\n            RunInvTxfm(test_temp_block, CAST_TO_BYTEPTR(dst16), pitch_));\n#endif\n      }\n\n      for (int j = 0; j < 64; ++j) {\n#if CONFIG_VP9_HIGHBITDEPTH\n        const int diff =\n            bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n#else\n        const int diff = dst[j] - src[j];\n#endif\n        const int error = diff * diff;\n        if (max_error < error) max_error = error;\n        total_error += error;\n      }\n    }\n\n    EXPECT_GE(1 << 2 * (bit_depth_ - 8), max_error)\n        << \"Error: 8x8 FDCT/IDCT or FHT/IHT has an individual\"\n        << \" roundtrip error > 1\";\n\n    EXPECT_GE((count_test_block << 2 * (bit_depth_ - 8)) / 5, total_error)\n        << \"Error: 8x8 FDCT/IDCT or FHT/IHT has average roundtrip \"\n        << \"error > 1/5 per block\";\n  }",
          "fn_code_pos": [
            [
              212,
              2
            ],
            [
              284,
              3
            ]
          ],
          "class_code": "22d673cabd6003c79007a9b5198758d3b5e2dd0d5e69805bdedbb68a23003ccc",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              524,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunRoundTripErrorCheck",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunExtremalCheck() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    int max_error = 0;\n    int total_error = 0;\n    int total_coeff_error = 0;\n    const int count_test_block = 100000;\n    DECLARE_ALIGNED(16, int16_t, test_input_block[64]);\n    DECLARE_ALIGNED(16, tran_low_t, test_temp_block[64]);\n    DECLARE_ALIGNED(16, tran_low_t, ref_temp_block[64]);\n    DECLARE_ALIGNED(16, uint8_t, dst[64]);\n    DECLARE_ALIGNED(16, uint8_t, src[64]);\n#if CONFIG_VP9_HIGHBITDEPTH\n    DECLARE_ALIGNED(16, uint16_t, dst16[64]);\n    DECLARE_ALIGNED(16, uint16_t, src16[64]);\n#endif\n\n    for (int i = 0; i < count_test_block; ++i) {\n      // Initialize a test block with input range [-mask_, mask_].\n      for (int j = 0; j < 64; ++j) {\n        if (bit_depth_ == VPX_BITS_8) {\n          if (i == 0) {\n            src[j] = 255;\n            dst[j] = 0;\n          } else if (i == 1) {\n            src[j] = 0;\n            dst[j] = 255;\n          } else {\n            src[j] = rnd.Rand8() % 2 ? 255 : 0;\n            dst[j] = rnd.Rand8() % 2 ? 255 : 0;\n          }\n          test_input_block[j] = src[j] - dst[j];\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          if (i == 0) {\n            src16[j] = mask_;\n            dst16[j] = 0;\n          } else if (i == 1) {\n            src16[j] = 0;\n            dst16[j] = mask_;\n          } else {\n            src16[j] = rnd.Rand8() % 2 ? mask_ : 0;\n            dst16[j] = rnd.Rand8() % 2 ? mask_ : 0;\n          }\n          test_input_block[j] = src16[j] - dst16[j];\n#endif\n        }\n      }\n\n      ASM_REGISTER_STATE_CHECK(\n          RunFwdTxfm(test_input_block, test_temp_block, pitch_));\n      ASM_REGISTER_STATE_CHECK(\n          fwd_txfm_ref(test_input_block, ref_temp_block, pitch_, tx_type_));\n      if (bit_depth_ == VPX_BITS_8) {\n        ASM_REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        ASM_REGISTER_STATE_CHECK(\n            RunInvTxfm(test_temp_block, CAST_TO_BYTEPTR(dst16), pitch_));\n#endif\n      }\n\n      for (int j = 0; j < 64; ++j) {\n#if CONFIG_VP9_HIGHBITDEPTH\n        const int diff =\n            bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n#else\n        const int diff = dst[j] - src[j];\n#endif\n        const int error = diff * diff;\n        if (max_error < error) max_error = error;\n        total_error += error;\n\n        const int coeff_diff = test_temp_block[j] - ref_temp_block[j];\n        total_coeff_error += abs(coeff_diff);\n      }\n\n      EXPECT_GE(1 << 2 * (bit_depth_ - 8), max_error)\n          << \"Error: Extremal 8x8 FDCT/IDCT or FHT/IHT has\"\n          << \"an individual roundtrip error > 1\";\n\n      EXPECT_GE((count_test_block << 2 * (bit_depth_ - 8)) / 5, total_error)\n          << \"Error: Extremal 8x8 FDCT/IDCT or FHT/IHT has average\"\n          << \" roundtrip error > 1/5 per block\";\n\n      EXPECT_EQ(0, total_coeff_error)\n          << \"Error: Extremal 8x8 FDCT/FHT has\"\n          << \"overflow issues in the intermediate steps > 1\";\n    }\n  }",
          "fn_code_pos": [
            [
              286,
              2
            ],
            [
              374,
              3
            ]
          ],
          "class_code": "22d673cabd6003c79007a9b5198758d3b5e2dd0d5e69805bdedbb68a23003ccc",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              524,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunExtremalCheck",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunInvAccuracyCheck() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 1000;\n    DECLARE_ALIGNED(16, int16_t, in[kNumCoeffs]);\n    DECLARE_ALIGNED(16, tran_low_t, coeff[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint8_t, src[kNumCoeffs]);\n#if CONFIG_VP9_HIGHBITDEPTH\n    DECLARE_ALIGNED(16, uint16_t, src16[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n#endif\n\n    for (int i = 0; i < count_test_block; ++i) {\n      double out_r[kNumCoeffs];\n\n      // Initialize a test block with input range [-255, 255].\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        if (bit_depth_ == VPX_BITS_8) {\n          src[j] = rnd.Rand8() % 2 ? 255 : 0;\n          dst[j] = src[j] > 0 ? 0 : 255;\n          in[j] = src[j] - dst[j];\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          src16[j] = rnd.Rand8() % 2 ? mask_ : 0;\n          dst16[j] = src16[j] > 0 ? 0 : mask_;\n          in[j] = src16[j] - dst16[j];\n#endif\n        }\n      }\n\n      reference_8x8_dct_2d(in, out_r);\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        coeff[j] = static_cast<tran_low_t>(round(out_r[j]));\n      }\n\n      if (bit_depth_ == VPX_BITS_8) {\n        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, pitch_));\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        ASM_REGISTER_STATE_CHECK(\n            RunInvTxfm(coeff, CAST_TO_BYTEPTR(dst16), pitch_));\n#endif\n      }\n\n      for (int j = 0; j < kNumCoeffs; ++j) {\n#if CONFIG_VP9_HIGHBITDEPTH\n        const int diff =\n            bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n#else\n        const int diff = dst[j] - src[j];\n#endif\n        const uint32_t error = diff * diff;\n        EXPECT_GE(1u << 2 * (bit_depth_ - 8), error)\n            << \"Error: 8x8 IDCT has error \" << error << \" at index \" << j;\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              376,
              2
            ],
            [
              432,
              3
            ]
          ],
          "class_code": "22d673cabd6003c79007a9b5198758d3b5e2dd0d5e69805bdedbb68a23003ccc",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              524,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunInvAccuracyCheck",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunFwdAccuracyCheck() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 1000;\n    DECLARE_ALIGNED(16, int16_t, in[kNumCoeffs]);\n    DECLARE_ALIGNED(16, tran_low_t, coeff_r[kNumCoeffs]);\n    DECLARE_ALIGNED(16, tran_low_t, coeff[kNumCoeffs]);\n\n    for (int i = 0; i < count_test_block; ++i) {\n      double out_r[kNumCoeffs];\n\n      // Initialize a test block with input range [-mask_, mask_].\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        in[j] = rnd.Rand8() % 2 == 0 ? mask_ : -mask_;\n      }\n\n      RunFwdTxfm(in, coeff, pitch_);\n      reference_8x8_dct_2d(in, out_r);\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        coeff_r[j] = static_cast<tran_low_t>(round(out_r[j]));\n      }\n\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        const int32_t diff = coeff[j] - coeff_r[j];\n        const uint32_t error = diff * diff;\n        EXPECT_GE(9u << 2 * (bit_depth_ - 8), error)\n            << \"Error: 8x8 DCT has error \" << error << \" at index \" << j;\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              434,
              2
            ],
            [
              462,
              3
            ]
          ],
          "class_code": "22d673cabd6003c79007a9b5198758d3b5e2dd0d5e69805bdedbb68a23003ccc",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              524,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunFwdAccuracyCheck",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CompareInvReference(IdctFunc ref_txfm, int thresh) {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 10000;\n    const int eob = 12;\n    DECLARE_ALIGNED(16, tran_low_t, coeff[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint8_t, ref[kNumCoeffs]);\n#if CONFIG_VP9_HIGHBITDEPTH\n    DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint16_t, ref16[kNumCoeffs]);\n#endif\n    const int16_t *scan = vp9_default_scan_orders[TX_8X8].scan;\n\n    for (int i = 0; i < count_test_block; ++i) {\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        if (j < eob) {\n          // Random values less than the threshold, either positive or negative\n          coeff[scan[j]] = rnd(thresh) * (1 - 2 * (i % 2));\n        } else {\n          coeff[scan[j]] = 0;\n        }\n        if (bit_depth_ == VPX_BITS_8) {\n          dst[j] = 0;\n          ref[j] = 0;\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          dst16[j] = 0;\n          ref16[j] = 0;\n#endif\n        }\n      }\n      if (bit_depth_ == VPX_BITS_8) {\n        ref_txfm(coeff, ref, pitch_);\n        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, pitch_));\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        ref_txfm(coeff, CAST_TO_BYTEPTR(ref16), pitch_);\n        ASM_REGISTER_STATE_CHECK(\n            RunInvTxfm(coeff, CAST_TO_BYTEPTR(dst16), pitch_));\n#endif\n      }\n\n      for (int j = 0; j < kNumCoeffs; ++j) {\n#if CONFIG_VP9_HIGHBITDEPTH\n        const int diff =\n            bit_depth_ == VPX_BITS_8 ? dst[j] - ref[j] : dst16[j] - ref16[j];\n#else\n        const int diff = dst[j] - ref[j];\n#endif\n        const uint32_t error = diff * diff;\n        EXPECT_EQ(0u, error)\n            << \"Error: 8x8 IDCT has error \" << error << \" at index \" << j;\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              464,
              2
            ],
            [
              518,
              3
            ]
          ],
          "class_code": "22d673cabd6003c79007a9b5198758d3b5e2dd0d5e69805bdedbb68a23003ccc",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              524,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CompareInvReference",
            "parameters": {
              "ref_txfm": "IdctFunc",
              "thresh": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual ~FwdTrans8x8DCT() {}",
          "fn_code_pos": [
            [
              529,
              2
            ],
            [
              529,
              30
            ]
          ],
          "class_code": "4f80cca04428f4a2c6c80bfee38193dd98782f0c35be4e5faadac4a9755b92c8",
          "class_node_pos": [
            [
              526,
              0
            ],
            [
              553,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n    tx_type_ = GET_PARAM(2);\n    pitch_ = 8;\n    fwd_txfm_ref = fdct8x8_ref;\n    bit_depth_ = GET_PARAM(3);\n    mask_ = (1 << bit_depth_) - 1;\n  }",
          "fn_code_pos": [
            [
              531,
              2
            ],
            [
              539,
              3
            ]
          ],
          "class_code": "4f80cca04428f4a2c6c80bfee38193dd98782f0c35be4e5faadac4a9755b92c8",
          "class_node_pos": [
            [
              526,
              0
            ],
            [
              553,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              541,
              2
            ],
            [
              541,
              62
            ]
          ],
          "class_code": "4f80cca04428f4a2c6c80bfee38193dd98782f0c35be4e5faadac4a9755b92c8",
          "class_node_pos": [
            [
              526,
              0
            ],
            [
              553,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) {\n    fwd_txfm_(in, out, stride);\n  }",
          "fn_code_pos": [
            [
              544,
              2
            ],
            [
              546,
              3
            ]
          ],
          "class_code": "4f80cca04428f4a2c6c80bfee38193dd98782f0c35be4e5faadac4a9755b92c8",
          "class_node_pos": [
            [
              526,
              0
            ],
            [
              553,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunFwdTxfm",
            "parameters": {
              "in": "int16_t",
              "out": "tran_low_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) {\n    inv_txfm_(out, dst, stride);\n  }",
          "fn_code_pos": [
            [
              547,
              2
            ],
            [
              549,
              3
            ]
          ],
          "class_code": "4f80cca04428f4a2c6c80bfee38193dd98782f0c35be4e5faadac4a9755b92c8",
          "class_node_pos": [
            [
              526,
              0
            ],
            [
              553,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunInvTxfm",
            "parameters": {
              "out": "tran_low_t",
              "dst": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(FwdTrans8x8DCT, SignBiasCheck) { RunSignBiasCheck(); }",
          "fn_code_pos": [
            [
              555,
              0
            ],
            [
              555,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(FwdTrans8x8DCT, RoundTripErrorCheck) { RunRoundTripErrorCheck(); }",
          "fn_code_pos": [
            [
              557,
              0
            ],
            [
              557,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(FwdTrans8x8DCT, ExtremalCheck) { RunExtremalCheck(); }",
          "fn_code_pos": [
            [
              559,
              0
            ],
            [
              559,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(FwdTrans8x8DCT, FwdAccuracyCheck) { RunFwdAccuracyCheck(); }",
          "fn_code_pos": [
            [
              561,
              0
            ],
            [
              561,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(FwdTrans8x8DCT, InvAccuracyCheck) { RunInvAccuracyCheck(); }",
          "fn_code_pos": [
            [
              563,
              0
            ],
            [
              563,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~FwdTrans8x8HT() {}",
          "fn_code_pos": [
            [
              568,
              2
            ],
            [
              568,
              29
            ]
          ],
          "class_code": "067a707ade37265c258090bc1ce8400518180c75448aa8aaa67d477bf0a3bccb",
          "class_node_pos": [
            [
              565,
              0
            ],
            [
              592,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n    tx_type_ = GET_PARAM(2);\n    pitch_ = 8;\n    fwd_txfm_ref = fht8x8_ref;\n    bit_depth_ = GET_PARAM(3);\n    mask_ = (1 << bit_depth_) - 1;\n  }",
          "fn_code_pos": [
            [
              570,
              2
            ],
            [
              578,
              3
            ]
          ],
          "class_code": "067a707ade37265c258090bc1ce8400518180c75448aa8aaa67d477bf0a3bccb",
          "class_node_pos": [
            [
              565,
              0
            ],
            [
              592,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              580,
              2
            ],
            [
              580,
              62
            ]
          ],
          "class_code": "067a707ade37265c258090bc1ce8400518180c75448aa8aaa67d477bf0a3bccb",
          "class_node_pos": [
            [
              565,
              0
            ],
            [
              592,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) {\n    fwd_txfm_(in, out, stride, tx_type_);\n  }",
          "fn_code_pos": [
            [
              583,
              2
            ],
            [
              585,
              3
            ]
          ],
          "class_code": "067a707ade37265c258090bc1ce8400518180c75448aa8aaa67d477bf0a3bccb",
          "class_node_pos": [
            [
              565,
              0
            ],
            [
              592,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunFwdTxfm",
            "parameters": {
              "in": "int16_t",
              "out": "tran_low_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) {\n    inv_txfm_(out, dst, stride, tx_type_);\n  }",
          "fn_code_pos": [
            [
              586,
              2
            ],
            [
              588,
              3
            ]
          ],
          "class_code": "067a707ade37265c258090bc1ce8400518180c75448aa8aaa67d477bf0a3bccb",
          "class_node_pos": [
            [
              565,
              0
            ],
            [
              592,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunInvTxfm",
            "parameters": {
              "out": "tran_low_t",
              "dst": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(FwdTrans8x8HT, SignBiasCheck) { RunSignBiasCheck(); }",
          "fn_code_pos": [
            [
              594,
              0
            ],
            [
              594,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(FwdTrans8x8HT, RoundTripErrorCheck) { RunRoundTripErrorCheck(); }",
          "fn_code_pos": [
            [
              596,
              0
            ],
            [
              596,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(FwdTrans8x8HT, ExtremalCheck) { RunExtremalCheck(); }",
          "fn_code_pos": [
            [
              598,
              0
            ],
            [
              598,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~InvTrans8x8DCT() {}",
          "fn_code_pos": [
            [
              603,
              2
            ],
            [
              603,
              30
            ]
          ],
          "class_code": "5aa7325ffd9e3f65a65f75ce0272a916be7b9b685ba4a76a7b4d0da731266efa",
          "class_node_pos": [
            [
              600,
              0
            ],
            [
              625,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    ref_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n    thresh_ = GET_PARAM(2);\n    pitch_ = 8;\n    bit_depth_ = GET_PARAM(3);\n    mask_ = (1 << bit_depth_) - 1;\n  }",
          "fn_code_pos": [
            [
              605,
              2
            ],
            [
              612,
              3
            ]
          ],
          "class_code": "5aa7325ffd9e3f65a65f75ce0272a916be7b9b685ba4a76a7b4d0da731266efa",
          "class_node_pos": [
            [
              600,
              0
            ],
            [
              625,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              614,
              2
            ],
            [
              614,
              62
            ]
          ],
          "class_code": "5aa7325ffd9e3f65a65f75ce0272a916be7b9b685ba4a76a7b4d0da731266efa",
          "class_node_pos": [
            [
              600,
              0
            ],
            [
              625,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) {\n    inv_txfm_(out, dst, stride);\n  }",
          "fn_code_pos": [
            [
              617,
              2
            ],
            [
              619,
              3
            ]
          ],
          "class_code": "5aa7325ffd9e3f65a65f75ce0272a916be7b9b685ba4a76a7b4d0da731266efa",
          "class_node_pos": [
            [
              600,
              0
            ],
            [
              625,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunInvTxfm",
            "parameters": {
              "out": "tran_low_t",
              "dst": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunFwdTxfm(int16_t * /*out*/, tran_low_t * /*dst*/, int /*stride*/) {}",
          "fn_code_pos": [
            [
              620,
              2
            ],
            [
              620,
              77
            ]
          ],
          "class_code": "5aa7325ffd9e3f65a65f75ce0272a916be7b9b685ba4a76a7b4d0da731266efa",
          "class_node_pos": [
            [
              600,
              0
            ],
            [
              625,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunFwdTxfm",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(InvTrans8x8DCT, CompareReference) {\n  CompareInvReference(ref_txfm_, thresh_);\n}",
          "fn_code_pos": [
            [
              627,
              0
            ],
            [
              629,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*FdctFunc)(const int16_t *in, tran_low_t *out, int stride)",
          "fn_dec_pos": [
            [
              39,
              13
            ],
            [
              39,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "int16_t",
              "out": "tran_low_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*IdctFunc)(const tran_low_t *in, uint8_t *out, int stride)",
          "fn_dec_pos": [
            [
              40,
              13
            ],
            [
              40,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*FhtFunc)(const int16_t *in, tran_low_t *out, int stride,\n                        int tx_type)",
          "fn_dec_pos": [
            [
              41,
              13
            ],
            [
              42,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "int16_t",
              "out": "tran_low_t",
              "stride": "int",
              "tx_type": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*IhtFunc)(const tran_low_t *in, uint8_t *out, int stride,\n                        int tx_type)",
          "fn_dec_pos": [
            [
              43,
              13
            ],
            [
              44,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int",
              "tx_type": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              143,
              14
            ],
            [
              143,
              49
            ]
          ],
          "class_code": "22d673cabd6003c79007a9b5198758d3b5e2dd0d5e69805bdedbb68a23003ccc",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              524,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              213,
              14
            ],
            [
              213,
              49
            ]
          ],
          "class_code": "22d673cabd6003c79007a9b5198758d3b5e2dd0d5e69805bdedbb68a23003ccc",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              524,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              287,
              14
            ],
            [
              287,
              49
            ]
          ],
          "class_code": "22d673cabd6003c79007a9b5198758d3b5e2dd0d5e69805bdedbb68a23003ccc",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              524,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              377,
              14
            ],
            [
              377,
              49
            ]
          ],
          "class_code": "22d673cabd6003c79007a9b5198758d3b5e2dd0d5e69805bdedbb68a23003ccc",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              524,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              435,
              14
            ],
            [
              435,
              49
            ]
          ],
          "class_code": "22d673cabd6003c79007a9b5198758d3b5e2dd0d5e69805bdedbb68a23003ccc",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              524,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              465,
              14
            ],
            [
              465,
              49
            ]
          ],
          "class_code": "22d673cabd6003c79007a9b5198758d3b5e2dd0d5e69805bdedbb68a23003ccc",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              524,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        }
      ],
      "class_node_list": {
        "22d673cabd6003c79007a9b5198758d3b5e2dd0d5e69805bdedbb68a23003ccc": {
          "class_code": "class FwdTrans8x8TestBase {\n public:\n  virtual ~FwdTrans8x8TestBase() {}\n\n protected:\n  virtual void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) = 0;\n  virtual void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) = 0;\n\n  void RunSignBiasCheck() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    DECLARE_ALIGNED(16, int16_t, test_input_block[64]);\n    DECLARE_ALIGNED(16, tran_low_t, test_output_block[64]);\n    int count_sign_block[64][2];\n    const int count_test_block = 100000;\n\n    memset(count_sign_block, 0, sizeof(count_sign_block));\n\n    for (int i = 0; i < count_test_block; ++i) {\n      // Initialize a test block with input range [-255, 255].\n      for (int j = 0; j < 64; ++j) {\n        test_input_block[j] = ((rnd.Rand16() >> (16 - bit_depth_)) & mask_) -\n                              ((rnd.Rand16() >> (16 - bit_depth_)) & mask_);\n      }\n      ASM_REGISTER_STATE_CHECK(\n          RunFwdTxfm(test_input_block, test_output_block, pitch_));\n\n      for (int j = 0; j < 64; ++j) {\n        if (test_output_block[j] < 0) {\n          ++count_sign_block[j][0];\n        } else if (test_output_block[j] > 0) {\n          ++count_sign_block[j][1];\n        }\n      }\n    }\n\n    for (int j = 0; j < 64; ++j) {\n      const int diff = abs(count_sign_block[j][0] - count_sign_block[j][1]);\n      const int max_diff = kSignBiasMaxDiff255;\n      EXPECT_LT(diff, max_diff << (bit_depth_ - 8))\n          << \"Error: 8x8 FDCT/FHT has a sign bias > \"\n          << 1. * max_diff / count_test_block * 100 << \"%\"\n          << \" for input range [-255, 255] at index \" << j\n          << \" count0: \" << count_sign_block[j][0]\n          << \" count1: \" << count_sign_block[j][1] << \" diff: \" << diff;\n    }\n\n    memset(count_sign_block, 0, sizeof(count_sign_block));\n\n    for (int i = 0; i < count_test_block; ++i) {\n      // Initialize a test block with input range [-mask_ / 16, mask_ / 16].\n      for (int j = 0; j < 64; ++j) {\n        test_input_block[j] =\n            ((rnd.Rand16() & mask_) >> 4) - ((rnd.Rand16() & mask_) >> 4);\n      }\n      ASM_REGISTER_STATE_CHECK(\n          RunFwdTxfm(test_input_block, test_output_block, pitch_));\n\n      for (int j = 0; j < 64; ++j) {\n        if (test_output_block[j] < 0) {\n          ++count_sign_block[j][0];\n        } else if (test_output_block[j] > 0) {\n          ++count_sign_block[j][1];\n        }\n      }\n    }\n\n    for (int j = 0; j < 64; ++j) {\n      const int diff = abs(count_sign_block[j][0] - count_sign_block[j][1]);\n      const int max_diff = kSignBiasMaxDiff15;\n      EXPECT_LT(diff, max_diff << (bit_depth_ - 8))\n          << \"Error: 8x8 FDCT/FHT has a sign bias > \"\n          << 1. * max_diff / count_test_block * 100 << \"%\"\n          << \" for input range [-15, 15] at index \" << j\n          << \" count0: \" << count_sign_block[j][0]\n          << \" count1: \" << count_sign_block[j][1] << \" diff: \" << diff;\n    }\n  }\n\n  void RunRoundTripErrorCheck() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    int max_error = 0;\n    int total_error = 0;\n    const int count_test_block = 100000;\n    DECLARE_ALIGNED(16, int16_t, test_input_block[64]);\n    DECLARE_ALIGNED(16, tran_low_t, test_temp_block[64]);\n    DECLARE_ALIGNED(16, uint8_t, dst[64]);\n    DECLARE_ALIGNED(16, uint8_t, src[64]);\n#if CONFIG_VP9_HIGHBITDEPTH\n    DECLARE_ALIGNED(16, uint16_t, dst16[64]);\n    DECLARE_ALIGNED(16, uint16_t, src16[64]);\n#endif\n\n    for (int i = 0; i < count_test_block; ++i) {\n      // Initialize a test block with input range [-mask_, mask_].\n      for (int j = 0; j < 64; ++j) {\n        if (bit_depth_ == VPX_BITS_8) {\n          src[j] = rnd.Rand8();\n          dst[j] = rnd.Rand8();\n          test_input_block[j] = src[j] - dst[j];\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          src16[j] = rnd.Rand16() & mask_;\n          dst16[j] = rnd.Rand16() & mask_;\n          test_input_block[j] = src16[j] - dst16[j];\n#endif\n        }\n      }\n\n      ASM_REGISTER_STATE_CHECK(\n          RunFwdTxfm(test_input_block, test_temp_block, pitch_));\n      for (int j = 0; j < 64; ++j) {\n        if (test_temp_block[j] > 0) {\n          test_temp_block[j] += 2;\n          test_temp_block[j] /= 4;\n          test_temp_block[j] *= 4;\n        } else {\n          test_temp_block[j] -= 2;\n          test_temp_block[j] /= 4;\n          test_temp_block[j] *= 4;\n        }\n      }\n      if (bit_depth_ == VPX_BITS_8) {\n        ASM_REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        ASM_REGISTER_STATE_CHECK(\n            RunInvTxfm(test_temp_block, CAST_TO_BYTEPTR(dst16), pitch_));\n#endif\n      }\n\n      for (int j = 0; j < 64; ++j) {\n#if CONFIG_VP9_HIGHBITDEPTH\n        const int diff =\n            bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n#else\n        const int diff = dst[j] - src[j];\n#endif\n        const int error = diff * diff;\n        if (max_error < error) max_error = error;\n        total_error += error;\n      }\n    }\n\n    EXPECT_GE(1 << 2 * (bit_depth_ - 8), max_error)\n        << \"Error: 8x8 FDCT/IDCT or FHT/IHT has an individual\"\n        << \" roundtrip error > 1\";\n\n    EXPECT_GE((count_test_block << 2 * (bit_depth_ - 8)) / 5, total_error)\n        << \"Error: 8x8 FDCT/IDCT or FHT/IHT has average roundtrip \"\n        << \"error > 1/5 per block\";\n  }\n\n  void RunExtremalCheck() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    int max_error = 0;\n    int total_error = 0;\n    int total_coeff_error = 0;\n    const int count_test_block = 100000;\n    DECLARE_ALIGNED(16, int16_t, test_input_block[64]);\n    DECLARE_ALIGNED(16, tran_low_t, test_temp_block[64]);\n    DECLARE_ALIGNED(16, tran_low_t, ref_temp_block[64]);\n    DECLARE_ALIGNED(16, uint8_t, dst[64]);\n    DECLARE_ALIGNED(16, uint8_t, src[64]);\n#if CONFIG_VP9_HIGHBITDEPTH\n    DECLARE_ALIGNED(16, uint16_t, dst16[64]);\n    DECLARE_ALIGNED(16, uint16_t, src16[64]);\n#endif\n\n    for (int i = 0; i < count_test_block; ++i) {\n      // Initialize a test block with input range [-mask_, mask_].\n      for (int j = 0; j < 64; ++j) {\n        if (bit_depth_ == VPX_BITS_8) {\n          if (i == 0) {\n            src[j] = 255;\n            dst[j] = 0;\n          } else if (i == 1) {\n            src[j] = 0;\n            dst[j] = 255;\n          } else {\n            src[j] = rnd.Rand8() % 2 ? 255 : 0;\n            dst[j] = rnd.Rand8() % 2 ? 255 : 0;\n          }\n          test_input_block[j] = src[j] - dst[j];\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          if (i == 0) {\n            src16[j] = mask_;\n            dst16[j] = 0;\n          } else if (i == 1) {\n            src16[j] = 0;\n            dst16[j] = mask_;\n          } else {\n            src16[j] = rnd.Rand8() % 2 ? mask_ : 0;\n            dst16[j] = rnd.Rand8() % 2 ? mask_ : 0;\n          }\n          test_input_block[j] = src16[j] - dst16[j];\n#endif\n        }\n      }\n\n      ASM_REGISTER_STATE_CHECK(\n          RunFwdTxfm(test_input_block, test_temp_block, pitch_));\n      ASM_REGISTER_STATE_CHECK(\n          fwd_txfm_ref(test_input_block, ref_temp_block, pitch_, tx_type_));\n      if (bit_depth_ == VPX_BITS_8) {\n        ASM_REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        ASM_REGISTER_STATE_CHECK(\n            RunInvTxfm(test_temp_block, CAST_TO_BYTEPTR(dst16), pitch_));\n#endif\n      }\n\n      for (int j = 0; j < 64; ++j) {\n#if CONFIG_VP9_HIGHBITDEPTH\n        const int diff =\n            bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n#else\n        const int diff = dst[j] - src[j];\n#endif\n        const int error = diff * diff;\n        if (max_error < error) max_error = error;\n        total_error += error;\n\n        const int coeff_diff = test_temp_block[j] - ref_temp_block[j];\n        total_coeff_error += abs(coeff_diff);\n      }\n\n      EXPECT_GE(1 << 2 * (bit_depth_ - 8), max_error)\n          << \"Error: Extremal 8x8 FDCT/IDCT or FHT/IHT has\"\n          << \"an individual roundtrip error > 1\";\n\n      EXPECT_GE((count_test_block << 2 * (bit_depth_ - 8)) / 5, total_error)\n          << \"Error: Extremal 8x8 FDCT/IDCT or FHT/IHT has average\"\n          << \" roundtrip error > 1/5 per block\";\n\n      EXPECT_EQ(0, total_coeff_error)\n          << \"Error: Extremal 8x8 FDCT/FHT has\"\n          << \"overflow issues in the intermediate steps > 1\";\n    }\n  }\n\n  void RunInvAccuracyCheck() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 1000;\n    DECLARE_ALIGNED(16, int16_t, in[kNumCoeffs]);\n    DECLARE_ALIGNED(16, tran_low_t, coeff[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint8_t, src[kNumCoeffs]);\n#if CONFIG_VP9_HIGHBITDEPTH\n    DECLARE_ALIGNED(16, uint16_t, src16[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n#endif\n\n    for (int i = 0; i < count_test_block; ++i) {\n      double out_r[kNumCoeffs];\n\n      // Initialize a test block with input range [-255, 255].\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        if (bit_depth_ == VPX_BITS_8) {\n          src[j] = rnd.Rand8() % 2 ? 255 : 0;\n          dst[j] = src[j] > 0 ? 0 : 255;\n          in[j] = src[j] - dst[j];\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          src16[j] = rnd.Rand8() % 2 ? mask_ : 0;\n          dst16[j] = src16[j] > 0 ? 0 : mask_;\n          in[j] = src16[j] - dst16[j];\n#endif\n        }\n      }\n\n      reference_8x8_dct_2d(in, out_r);\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        coeff[j] = static_cast<tran_low_t>(round(out_r[j]));\n      }\n\n      if (bit_depth_ == VPX_BITS_8) {\n        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, pitch_));\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        ASM_REGISTER_STATE_CHECK(\n            RunInvTxfm(coeff, CAST_TO_BYTEPTR(dst16), pitch_));\n#endif\n      }\n\n      for (int j = 0; j < kNumCoeffs; ++j) {\n#if CONFIG_VP9_HIGHBITDEPTH\n        const int diff =\n            bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n#else\n        const int diff = dst[j] - src[j];\n#endif\n        const uint32_t error = diff * diff;\n        EXPECT_GE(1u << 2 * (bit_depth_ - 8), error)\n            << \"Error: 8x8 IDCT has error \" << error << \" at index \" << j;\n      }\n    }\n  }\n\n  void RunFwdAccuracyCheck() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 1000;\n    DECLARE_ALIGNED(16, int16_t, in[kNumCoeffs]);\n    DECLARE_ALIGNED(16, tran_low_t, coeff_r[kNumCoeffs]);\n    DECLARE_ALIGNED(16, tran_low_t, coeff[kNumCoeffs]);\n\n    for (int i = 0; i < count_test_block; ++i) {\n      double out_r[kNumCoeffs];\n\n      // Initialize a test block with input range [-mask_, mask_].\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        in[j] = rnd.Rand8() % 2 == 0 ? mask_ : -mask_;\n      }\n\n      RunFwdTxfm(in, coeff, pitch_);\n      reference_8x8_dct_2d(in, out_r);\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        coeff_r[j] = static_cast<tran_low_t>(round(out_r[j]));\n      }\n\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        const int32_t diff = coeff[j] - coeff_r[j];\n        const uint32_t error = diff * diff;\n        EXPECT_GE(9u << 2 * (bit_depth_ - 8), error)\n            << \"Error: 8x8 DCT has error \" << error << \" at index \" << j;\n      }\n    }\n  }\n\n  void CompareInvReference(IdctFunc ref_txfm, int thresh) {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 10000;\n    const int eob = 12;\n    DECLARE_ALIGNED(16, tran_low_t, coeff[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint8_t, ref[kNumCoeffs]);\n#if CONFIG_VP9_HIGHBITDEPTH\n    DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n    DECLARE_ALIGNED(16, uint16_t, ref16[kNumCoeffs]);\n#endif\n    const int16_t *scan = vp9_default_scan_orders[TX_8X8].scan;\n\n    for (int i = 0; i < count_test_block; ++i) {\n      for (int j = 0; j < kNumCoeffs; ++j) {\n        if (j < eob) {\n          // Random values less than the threshold, either positive or negative\n          coeff[scan[j]] = rnd(thresh) * (1 - 2 * (i % 2));\n        } else {\n          coeff[scan[j]] = 0;\n        }\n        if (bit_depth_ == VPX_BITS_8) {\n          dst[j] = 0;\n          ref[j] = 0;\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          dst16[j] = 0;\n          ref16[j] = 0;\n#endif\n        }\n      }\n      if (bit_depth_ == VPX_BITS_8) {\n        ref_txfm(coeff, ref, pitch_);\n        ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, pitch_));\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        ref_txfm(coeff, CAST_TO_BYTEPTR(ref16), pitch_);\n        ASM_REGISTER_STATE_CHECK(\n            RunInvTxfm(coeff, CAST_TO_BYTEPTR(dst16), pitch_));\n#endif\n      }\n\n      for (int j = 0; j < kNumCoeffs; ++j) {\n#if CONFIG_VP9_HIGHBITDEPTH\n        const int diff =\n            bit_depth_ == VPX_BITS_8 ? dst[j] - ref[j] : dst16[j] - ref16[j];\n#else\n        const int diff = dst[j] - ref[j];\n#endif\n        const uint32_t error = diff * diff;\n        EXPECT_EQ(0u, error)\n            << \"Error: 8x8 IDCT has error \" << error << \" at index \" << j;\n      }\n    }\n  }\n  int pitch_;\n  int tx_type_;\n  FhtFunc fwd_txfm_ref;\n  vpx_bit_depth_t bit_depth_;\n  int mask_;\n}",
          "class_name": "FwdTrans8x8TestBase",
          "class_pos": [
            [
              134,
              0
            ],
            [
              524,
              1
            ]
          ]
        },
        "4f80cca04428f4a2c6c80bfee38193dd98782f0c35be4e5faadac4a9755b92c8": {
          "class_code": "class FwdTrans8x8DCT : public FwdTrans8x8TestBase,\n                       public ::testing::TestWithParam<Dct8x8Param> {\n public:\n  virtual ~FwdTrans8x8DCT() {}\n\n  virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n    tx_type_ = GET_PARAM(2);\n    pitch_ = 8;\n    fwd_txfm_ref = fdct8x8_ref;\n    bit_depth_ = GET_PARAM(3);\n    mask_ = (1 << bit_depth_) - 1;\n  }\n\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) {\n    fwd_txfm_(in, out, stride);\n  }\n  void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) {\n    inv_txfm_(out, dst, stride);\n  }\n\n  FdctFunc fwd_txfm_;\n  IdctFunc inv_txfm_;\n}",
          "class_name": "FwdTrans8x8DCT",
          "class_pos": [
            [
              526,
              0
            ],
            [
              553,
              1
            ]
          ]
        },
        "067a707ade37265c258090bc1ce8400518180c75448aa8aaa67d477bf0a3bccb": {
          "class_code": "class FwdTrans8x8HT : public FwdTrans8x8TestBase,\n                      public ::testing::TestWithParam<Ht8x8Param> {\n public:\n  virtual ~FwdTrans8x8HT() {}\n\n  virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n    tx_type_ = GET_PARAM(2);\n    pitch_ = 8;\n    fwd_txfm_ref = fht8x8_ref;\n    bit_depth_ = GET_PARAM(3);\n    mask_ = (1 << bit_depth_) - 1;\n  }\n\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  void RunFwdTxfm(int16_t *in, tran_low_t *out, int stride) {\n    fwd_txfm_(in, out, stride, tx_type_);\n  }\n  void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) {\n    inv_txfm_(out, dst, stride, tx_type_);\n  }\n\n  FhtFunc fwd_txfm_;\n  IhtFunc inv_txfm_;\n}",
          "class_name": "FwdTrans8x8HT",
          "class_pos": [
            [
              565,
              0
            ],
            [
              592,
              1
            ]
          ]
        },
        "5aa7325ffd9e3f65a65f75ce0272a916be7b9b685ba4a76a7b4d0da731266efa": {
          "class_code": "class InvTrans8x8DCT : public FwdTrans8x8TestBase,\n                       public ::testing::TestWithParam<Idct8x8Param> {\n public:\n  virtual ~InvTrans8x8DCT() {}\n\n  virtual void SetUp() {\n    ref_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n    thresh_ = GET_PARAM(2);\n    pitch_ = 8;\n    bit_depth_ = GET_PARAM(3);\n    mask_ = (1 << bit_depth_) - 1;\n  }\n\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  void RunInvTxfm(tran_low_t *out, uint8_t *dst, int stride) {\n    inv_txfm_(out, dst, stride);\n  }\n  void RunFwdTxfm(int16_t * /*out*/, tran_low_t * /*dst*/, int /*stride*/) {}\n\n  IdctFunc ref_txfm_;\n  IdctFunc inv_txfm_;\n  int thresh_;\n}",
          "class_name": "InvTrans8x8DCT",
          "class_pos": [
            [
              600,
              0
            ],
            [
              625,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <math.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./vp9_rtcd.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_entropy.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_scan.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_codec.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"vpx_ports/mem.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/borders_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "BordersTest() : EncoderTest(GET_PARAM(0)) {}",
          "fn_code_pos": [
            [
              23,
              2
            ],
            [
              23,
              46
            ]
          ],
          "class_code": "f69fc5cdc48469e53915972284dd7c9d6502ce14e49bb681b4da61dec7904e28",
          "class_node_pos": [
            [
              19,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BordersTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~BordersTest() {}",
          "fn_code_pos": [
            [
              24,
              2
            ],
            [
              24,
              27
            ]
          ],
          "class_code": "f69fc5cdc48469e53915972284dd7c9d6502ce14e49bb681b4da61dec7904e28",
          "class_node_pos": [
            [
              19,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n  }",
          "fn_code_pos": [
            [
              26,
              2
            ],
            [
              29,
              3
            ]
          ],
          "class_code": "f69fc5cdc48469e53915972284dd7c9d6502ce14e49bb681b4da61dec7904e28",
          "class_node_pos": [
            [
              19,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, 1);\n      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n      encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n      encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n      encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n    }\n  }",
          "fn_code_pos": [
            [
              31,
              2
            ],
            [
              40,
              3
            ]
          ],
          "class_code": "f69fc5cdc48469e53915972284dd7c9d6502ce14e49bb681b4da61dec7904e28",
          "class_node_pos": [
            [
              19,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (pkt->data.frame.flags & VPX_FRAME_IS_KEY) {\n    }\n  }",
          "fn_code_pos": [
            [
              42,
              2
            ],
            [
              45,
              3
            ]
          ],
          "class_code": "f69fc5cdc48469e53915972284dd7c9d6502ce14e49bb681b4da61dec7904e28",
          "class_node_pos": [
            [
              19,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(BordersTest, TestEncodeHighBitrate) {\n  // Validate that this non multiple of 64 wide clip encodes and decodes\n  // without a mismatch when passing in a very low max q.  This pushes\n  // the encoder to producing lots of big partitions which will likely\n  // extend into the border and test the border condition.\n  cfg_.g_lag_in_frames = 25;\n  cfg_.rc_2pass_vbr_minsection_pct = 5;\n  cfg_.rc_2pass_vbr_maxsection_pct = 2000;\n  cfg_.rc_target_bitrate = 2000;\n  cfg_.rc_max_quantizer = 10;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_odd.yuv\", 208, 144, 30, 1, 0,\n                                       40);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(BordersTest, TestLowBitrate) {\n  // Validate that this clip encodes and decodes without a mismatch\n  // when passing in a very high min q.  This pushes the encoder to producing\n  // lots of small partitions which might will test the other condition.\n\n  cfg_.g_lag_in_frames = 25;\n  cfg_.rc_2pass_vbr_minsection_pct = 5;\n  cfg_.rc_2pass_vbr_maxsection_pct = 2000;\n  cfg_.rc_target_bitrate = 200;\n  cfg_.rc_min_quantizer = 40;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_odd.yuv\", 208, 144, 30, 1, 0,\n                                       40);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "f69fc5cdc48469e53915972284dd7c9d6502ce14e49bb681b4da61dec7904e28": {
          "class_code": "class BordersTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWithParam<libvpx_test::TestMode> {\n protected:\n  BordersTest() : EncoderTest(GET_PARAM(0)) {}\n  virtual ~BordersTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, 1);\n      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n      encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n      encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n      encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n    }\n  }\n\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (pkt->data.frame.flags & VPX_FRAME_IS_KEY) {\n    }\n  }\n}",
          "class_name": "BordersTest",
          "class_pos": [
            [
              19,
              0
            ],
            [
              46,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <climits>\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/decode_api_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST(DecodeAPI, InvalidParams) {\n  static const vpx_codec_iface_t *kCodecs[] = {\n#if CONFIG_VP8_DECODER\n    &vpx_codec_vp8_dx_algo,\n#endif\n#if CONFIG_VP9_DECODER\n    &vpx_codec_vp9_dx_algo,\n#endif\n  };\n  uint8_t buf[1] = { 0 };\n  vpx_codec_ctx_t dec;\n\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, vpx_codec_dec_init(NULL, NULL, NULL, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, vpx_codec_dec_init(&dec, NULL, NULL, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, vpx_codec_decode(NULL, NULL, 0, NULL, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, vpx_codec_decode(NULL, buf, 0, NULL, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n            vpx_codec_decode(NULL, buf, NELEMENTS(buf), NULL, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n            vpx_codec_decode(NULL, NULL, NELEMENTS(buf), NULL, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, vpx_codec_destroy(NULL));\n  EXPECT_TRUE(vpx_codec_error(NULL) != NULL);\n\n  for (int i = 0; i < NELEMENTS(kCodecs); ++i) {\n    EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n              vpx_codec_dec_init(NULL, kCodecs[i], NULL, 0));\n\n    EXPECT_EQ(VPX_CODEC_OK, vpx_codec_dec_init(&dec, kCodecs[i], NULL, 0));\n    EXPECT_EQ(VPX_CODEC_UNSUP_BITSTREAM,\n              vpx_codec_decode(&dec, buf, NELEMENTS(buf), NULL, 0));\n    EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n              vpx_codec_decode(&dec, NULL, NELEMENTS(buf), NULL, 0));\n    EXPECT_EQ(VPX_CODEC_INVALID_PARAM, vpx_codec_decode(&dec, buf, 0, NULL, 0));\n\n    EXPECT_EQ(VPX_CODEC_OK, vpx_codec_destroy(&dec));\n  }\n}",
          "fn_code_pos": [
            [
              21,
              0
            ],
            [
              57,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(DecodeAPI, OptionalParams) {\n  vpx_codec_ctx_t dec;\n\n#if CONFIG_ERROR_CONCEALMENT\n  EXPECT_EQ(VPX_CODEC_OK, vpx_codec_dec_init(&dec, &vpx_codec_vp8_dx_algo, NULL,\n                                             VPX_CODEC_USE_ERROR_CONCEALMENT));\n#else\n  EXPECT_EQ(VPX_CODEC_INCAPABLE,\n            vpx_codec_dec_init(&dec, &vpx_codec_vp8_dx_algo, NULL,\n                               VPX_CODEC_USE_ERROR_CONCEALMENT));\n#endif  // CONFIG_ERROR_CONCEALMENT\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              71,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void TestVp9Controls(vpx_codec_ctx_t *dec) {\n  static const int kControls[] = { VP8D_GET_LAST_REF_UPDATES,\n                                   VP8D_GET_FRAME_CORRUPTED,\n                                   VP9D_GET_DISPLAY_SIZE, VP9D_GET_FRAME_SIZE };\n  int val[2];\n\n  for (int i = 0; i < NELEMENTS(kControls); ++i) {\n    const vpx_codec_err_t res = vpx_codec_control_(dec, kControls[i], val);\n    switch (kControls[i]) {\n      case VP8D_GET_FRAME_CORRUPTED:\n        EXPECT_EQ(VPX_CODEC_ERROR, res) << kControls[i];\n        break;\n      default: EXPECT_EQ(VPX_CODEC_OK, res) << kControls[i]; break;\n    }\n    EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n              vpx_codec_control_(dec, kControls[i], NULL));\n  }\n\n  vp9_ref_frame_t ref;\n  ref.idx = 0;\n  EXPECT_EQ(VPX_CODEC_ERROR, vpx_codec_control(dec, VP9_GET_REFERENCE, &ref));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n            vpx_codec_control(dec, VP9_GET_REFERENCE, NULL));\n\n  vpx_ref_frame_t ref_copy;\n  const int width = 352;\n  const int height = 288;\n  ASSERT_TRUE(\n      vpx_img_alloc(&ref_copy.img, VPX_IMG_FMT_I420, width, height, 1) != NULL);\n  ref_copy.frame_type = VP8_LAST_FRAME;\n  EXPECT_EQ(VPX_CODEC_ERROR,\n            vpx_codec_control(dec, VP8_COPY_REFERENCE, &ref_copy));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n            vpx_codec_control(dec, VP8_COPY_REFERENCE, NULL));\n  vpx_img_free(&ref_copy.img);\n}",
          "fn_code_pos": [
            [
              77,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestVp9Controls",
            "parameters": {
              "dec": "vpx_codec_ctx_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST(DecodeAPI, Vp9InvalidDecode) {\n  const vpx_codec_iface_t *const codec = &vpx_codec_vp9_dx_algo;\n  const char filename[] =\n      \"invalid-vp90-2-00-quantizer-00.webm.ivf.s5861_r01-05_b6-.v2.ivf\";\n  libvpx_test::IVFVideoSource video(filename);\n  video.Init();\n  video.Begin();\n  ASSERT_TRUE(!HasFailure());\n\n  vpx_codec_ctx_t dec;\n  EXPECT_EQ(VPX_CODEC_OK, vpx_codec_dec_init(&dec, codec, NULL, 0));\n  const uint32_t frame_size = static_cast<uint32_t>(video.frame_size());\n#if CONFIG_VP9_HIGHBITDEPTH\n  EXPECT_EQ(VPX_CODEC_MEM_ERROR,\n            vpx_codec_decode(&dec, video.cxdata(), frame_size, NULL, 0));\n#else\n  EXPECT_EQ(VPX_CODEC_UNSUP_BITSTREAM,\n            vpx_codec_decode(&dec, video.cxdata(), frame_size, NULL, 0));\n#endif\n  vpx_codec_iter_t iter = NULL;\n  EXPECT_EQ(NULL, vpx_codec_get_frame(&dec, &iter));\n\n  TestVp9Controls(&dec);\n  EXPECT_EQ(VPX_CODEC_OK, vpx_codec_destroy(&dec));\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void TestPeekInfo(const uint8_t *const data, uint32_t data_sz,\n                  uint32_t peek_size) {\n  const vpx_codec_iface_t *const codec = &vpx_codec_vp9_dx_algo;\n  // Verify behavior of vpx_codec_decode. vpx_codec_decode doesn't even get\n  // to decoder_peek_si_internal on frames of size < 8.\n  if (data_sz >= 8) {\n    vpx_codec_ctx_t dec;\n    EXPECT_EQ(VPX_CODEC_OK, vpx_codec_dec_init(&dec, codec, NULL, 0));\n    EXPECT_EQ((data_sz < peek_size) ? VPX_CODEC_UNSUP_BITSTREAM\n                                    : VPX_CODEC_CORRUPT_FRAME,\n              vpx_codec_decode(&dec, data, data_sz, NULL, 0));\n    vpx_codec_iter_t iter = NULL;\n    EXPECT_EQ(NULL, vpx_codec_get_frame(&dec, &iter));\n    EXPECT_EQ(VPX_CODEC_OK, vpx_codec_destroy(&dec));\n  }\n\n  // Verify behavior of vpx_codec_peek_stream_info.\n  vpx_codec_stream_info_t si;\n  si.sz = sizeof(si);\n  EXPECT_EQ((data_sz < peek_size) ? VPX_CODEC_UNSUP_BITSTREAM : VPX_CODEC_OK,\n            vpx_codec_peek_stream_info(codec, data, data_sz, &si));\n}",
          "fn_code_pos": [
            [
              140,
              0
            ],
            [
              161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestPeekInfo",
            "parameters": {
              "data": "uint8_t",
              "data_sz": "uint32_t",
              "peek_size": "uint32_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST(DecodeAPI, Vp9PeekStreamInfo) {\n  // The first 9 bytes are valid and the rest of the bytes are made up. Until\n  // size 10, this should return VPX_CODEC_UNSUP_BITSTREAM and after that it\n  // should return VPX_CODEC_CORRUPT_FRAME.\n  const uint8_t data[32] = {\n    0x85, 0xa4, 0xc1, 0xa1, 0x38, 0x81, 0xa3, 0x49, 0x83, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  };\n\n  for (uint32_t data_sz = 1; data_sz <= 32; ++data_sz) {\n    TestPeekInfo(data, data_sz, 10);\n  }\n}",
          "fn_code_pos": [
            [
              163,
              0
            ],
            [
              176,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(DecodeAPI, Vp9PeekStreamInfoTruncated) {\n  // This profile 1 header requires 10.25 bytes, ensure\n  // vpx_codec_peek_stream_info doesn't over read.\n  const uint8_t profile1_data[10] = { 0xa4, 0xe9, 0x30, 0x68, 0x53,\n                                      0xe9, 0x30, 0x68, 0x53, 0x04 };\n\n  for (uint32_t data_sz = 1; data_sz <= 10; ++data_sz) {\n    TestPeekInfo(profile1_data, data_sz, 11);\n  }\n}",
          "fn_code_pos": [
            [
              178,
              0
            ],
            [
              187,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(DecodeAPI, HighBitDepthCapability) {\n// VP8 should not claim VP9 HBD as a capability.\n#if CONFIG_VP8_DECODER\n  const vpx_codec_caps_t vp8_caps = vpx_codec_get_caps(&vpx_codec_vp8_dx_algo);\n  EXPECT_EQ(vp8_caps & VPX_CODEC_CAP_HIGHBITDEPTH, 0);\n#endif\n\n#if CONFIG_VP9_DECODER\n  const vpx_codec_caps_t vp9_caps = vpx_codec_get_caps(&vpx_codec_vp9_dx_algo);\n#if CONFIG_VP9_HIGHBITDEPTH\n  EXPECT_EQ(vp9_caps & VPX_CODEC_CAP_HIGHBITDEPTH, VPX_CODEC_CAP_HIGHBITDEPTH);\n#else\n  EXPECT_EQ(vp9_caps & VPX_CODEC_CAP_HIGHBITDEPTH, 0);\n#endif\n#endif\n}",
          "fn_code_pos": [
            [
              190,
              0
            ],
            [
              205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "video(filename)",
          "fn_dec_pos": [
            [
              118,
              30
            ],
            [
              118,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "video",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/ivf_video_source.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"vpx/vp8dx.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_decoder.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/encode_test_driver.cc": {
      "fn_def_list": [
        {
          "fn_code": "void Encoder::InitEncoder(VideoSource *video) {\n  vpx_codec_err_t res;\n  const vpx_image_t *img = video->img();\n\n  if (video->img() && !encoder_.priv) {\n    cfg_.g_w = img->d_w;\n    cfg_.g_h = img->d_h;\n    cfg_.g_timebase = video->timebase();\n    cfg_.rc_twopass_stats_in = stats_->buf();\n\n    res = vpx_codec_enc_init(&encoder_, CodecInterface(), &cfg_, init_flags_);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n\n#if CONFIG_VP9_ENCODER\n    if (CodecInterface() == &vpx_codec_vp9_cx_algo) {\n      // Default to 1 tile column for VP9.\n      const int log2_tile_columns = 0;\n      res = vpx_codec_control_(&encoder_, VP9E_SET_TILE_COLUMNS,\n                               log2_tile_columns);\n      ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n    } else\n#endif\n    {\n#if CONFIG_VP8_ENCODER\n      ASSERT_EQ(&vpx_codec_vp8_cx_algo, CodecInterface())\n          << \"Unknown Codec Interface\";\n#endif\n    }\n  }\n}",
          "fn_code_pos": [
            [
              23,
              0
            ],
            [
              52,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Encoder::InitEncoder",
            "parameters": {
              "video": "VideoSource"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Encoder::EncodeFrame(VideoSource *video, const unsigned long frame_flags) {\n  if (video->img()) {\n    EncodeFrameInternal(*video, frame_flags);\n  } else {\n    Flush();\n  }\n\n  // Handle twopass stats\n  CxDataIterator iter = GetCxData();\n\n  while (const vpx_codec_cx_pkt_t *pkt = iter.Next()) {\n    if (pkt->kind != VPX_CODEC_STATS_PKT) continue;\n\n    stats_->Append(*pkt);\n  }\n}",
          "fn_code_pos": [
            [
              54,
              0
            ],
            [
              69,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Encoder::EncodeFrame",
            "parameters": {
              "video": "VideoSource",
              "frame_flags": "unsigned long"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Encoder::EncodeFrameInternal(const VideoSource &video,\n                                  const unsigned long frame_flags) {\n  vpx_codec_err_t res;\n  const vpx_image_t *img = video.img();\n\n  // Handle frame resizing\n  if (cfg_.g_w != img->d_w || cfg_.g_h != img->d_h) {\n    cfg_.g_w = img->d_w;\n    cfg_.g_h = img->d_h;\n    res = vpx_codec_enc_config_set(&encoder_, &cfg_);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }\n\n  // Encode the frame\n  API_REGISTER_STATE_CHECK(res = vpx_codec_encode(&encoder_, img, video.pts(),\n                                                  video.duration(), frame_flags,\n                                                  deadline_));\n  ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n}",
          "fn_code_pos": [
            [
              71,
              0
            ],
            [
              89,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Encoder::EncodeFrameInternal",
            "parameters": {
              "video": "VideoSource",
              "frame_flags": "unsigned long"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Encoder::Flush() {\n  const vpx_codec_err_t res =\n      vpx_codec_encode(&encoder_, NULL, 0, 0, 0, deadline_);\n  if (!encoder_.priv)\n    ASSERT_EQ(VPX_CODEC_ERROR, res) << EncoderError();\n  else\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n}",
          "fn_code_pos": [
            [
              91,
              0
            ],
            [
              98,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Encoder::Flush",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void EncoderTest::InitializeConfig() {\n  const vpx_codec_err_t res = codec_->DefaultEncoderConfig(&cfg_, 0);\n  dec_cfg_ = vpx_codec_dec_cfg_t();\n  ASSERT_EQ(VPX_CODEC_OK, res);\n}",
          "fn_code_pos": [
            [
              100,
              0
            ],
            [
              104,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EncoderTest::InitializeConfig",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void EncoderTest::SetMode(TestMode mode) {\n  switch (mode) {\n    case kRealTime: deadline_ = VPX_DL_REALTIME; break;\n\n    case kOnePassGood:\n    case kTwoPassGood: deadline_ = VPX_DL_GOOD_QUALITY; break;\n\n    case kOnePassBest:\n    case kTwoPassBest: deadline_ = VPX_DL_BEST_QUALITY; break;\n\n    default: ASSERT_TRUE(false) << \"Unexpected mode \" << mode;\n  }\n\n  if (mode == kTwoPassGood || mode == kTwoPassBest) {\n    passes_ = 2;\n  } else {\n    passes_ = 1;\n  }\n}",
          "fn_code_pos": [
            [
              106,
              0
            ],
            [
              124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EncoderTest::SetMode",
            "parameters": {
              "mode": "TestMode"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static bool compare_img(const vpx_image_t *img1, const vpx_image_t *img2) {\n  bool match = (img1->fmt == img2->fmt) && (img1->cs == img2->cs) &&\n               (img1->d_w == img2->d_w) && (img1->d_h == img2->d_h);\n\n  if (!match) return false;\n\n  const unsigned int width_y = img1->d_w;\n  const unsigned int height_y = img1->d_h;\n  unsigned int i;\n  for (i = 0; i < height_y; ++i) {\n    match = (memcmp(img1->planes[VPX_PLANE_Y] + i * img1->stride[VPX_PLANE_Y],\n                    img2->planes[VPX_PLANE_Y] + i * img2->stride[VPX_PLANE_Y],\n                    width_y) == 0) &&\n            match;\n  }\n  const unsigned int width_uv = (img1->d_w + 1) >> 1;\n  const unsigned int height_uv = (img1->d_h + 1) >> 1;\n  for (i = 0; i < height_uv; ++i) {\n    match = (memcmp(img1->planes[VPX_PLANE_U] + i * img1->stride[VPX_PLANE_U],\n                    img2->planes[VPX_PLANE_U] + i * img2->stride[VPX_PLANE_U],\n                    width_uv) == 0) &&\n            match;\n  }\n  for (i = 0; i < height_uv; ++i) {\n    match = (memcmp(img1->planes[VPX_PLANE_V] + i * img1->stride[VPX_PLANE_V],\n                    img2->planes[VPX_PLANE_V] + i * img2->stride[VPX_PLANE_V],\n                    width_uv) == 0) &&\n            match;\n  }\n  return match;\n}",
          "fn_code_pos": [
            [
              127,
              0
            ],
            [
              157,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compare_img",
            "parameters": {
              "img1": "vpx_image_t",
              "img2": "vpx_image_t"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "void EncoderTest::MismatchHook(const vpx_image_t * /*img1*/,\n                               const vpx_image_t * /*img2*/) {\n  ASSERT_TRUE(0) << \"Encode/Decode mismatch found\";\n}",
          "fn_code_pos": [
            [
              159,
              0
            ],
            [
              162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EncoderTest::MismatchHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void EncoderTest::RunLoop(VideoSource *video) {\n  vpx_codec_dec_cfg_t dec_cfg = vpx_codec_dec_cfg_t();\n\n  stats_.Reset();\n\n  ASSERT_TRUE(passes_ == 1 || passes_ == 2);\n  for (unsigned int pass = 0; pass < passes_; pass++) {\n    last_pts_ = 0;\n\n    if (passes_ == 1) {\n      cfg_.g_pass = VPX_RC_ONE_PASS;\n    } else if (pass == 0) {\n      cfg_.g_pass = VPX_RC_FIRST_PASS;\n    } else {\n      cfg_.g_pass = VPX_RC_LAST_PASS;\n    }\n\n    BeginPassHook(pass);\n    std::unique_ptr<Encoder> encoder(\n        codec_->CreateEncoder(cfg_, deadline_, init_flags_, &stats_));\n    ASSERT_TRUE(encoder.get() != NULL);\n\n    ASSERT_NO_FATAL_FAILURE(video->Begin());\n    encoder->InitEncoder(video);\n    ASSERT_FALSE(::testing::Test::HasFatalFailure());\n\n    unsigned long dec_init_flags = 0;  // NOLINT\n    // Use fragment decoder if encoder outputs partitions.\n    // NOTE: fragment decoder and partition encoder are only supported by VP8.\n    if (init_flags_ & VPX_CODEC_USE_OUTPUT_PARTITION) {\n      dec_init_flags |= VPX_CODEC_USE_INPUT_FRAGMENTS;\n    }\n    std::unique_ptr<Decoder> decoder(\n        codec_->CreateDecoder(dec_cfg, dec_init_flags));\n    bool again;\n    for (again = true; again; video->Next()) {\n      again = (video->img() != NULL);\n\n      PreEncodeFrameHook(video);\n      PreEncodeFrameHook(video, encoder.get());\n      encoder->EncodeFrame(video, frame_flags_);\n\n      PostEncodeFrameHook(encoder.get());\n\n      CxDataIterator iter = encoder->GetCxData();\n\n      bool has_cxdata = false;\n      bool has_dxdata = false;\n      while (const vpx_codec_cx_pkt_t *pkt = iter.Next()) {\n        pkt = MutateEncoderOutputHook(pkt);\n        again = true;\n        switch (pkt->kind) {\n          case VPX_CODEC_CX_FRAME_PKT:\n            has_cxdata = true;\n            if (decoder.get() != NULL && DoDecode()) {\n              PreDecodeFrameHook(video, decoder.get());\n              vpx_codec_err_t res_dec = decoder->DecodeFrame(\n                  (const uint8_t *)pkt->data.frame.buf, pkt->data.frame.sz);\n\n              if (!HandleDecodeResult(res_dec, *video, decoder.get())) break;\n\n              has_dxdata = true;\n            }\n            ASSERT_GE(pkt->data.frame.pts, last_pts_);\n            last_pts_ = pkt->data.frame.pts;\n            FramePktHook(pkt);\n            break;\n\n          case VPX_CODEC_PSNR_PKT: PSNRPktHook(pkt); break;\n\n          case VPX_CODEC_STATS_PKT: StatsPktHook(pkt); break;\n\n          default: break;\n        }\n      }\n\n      // Flush the decoder when there are no more fragments.\n      if ((init_flags_ & VPX_CODEC_USE_OUTPUT_PARTITION) && has_dxdata) {\n        const vpx_codec_err_t res_dec = decoder->DecodeFrame(NULL, 0);\n        if (!HandleDecodeResult(res_dec, *video, decoder.get())) break;\n      }\n\n      if (has_dxdata && has_cxdata) {\n        const vpx_image_t *img_enc = encoder->GetPreviewFrame();\n        DxDataIterator dec_iter = decoder->GetDxData();\n        const vpx_image_t *img_dec = dec_iter.Next();\n        if (img_enc && img_dec) {\n          const bool res = compare_img(img_enc, img_dec);\n          if (!res) {  // Mismatch\n            MismatchHook(img_enc, img_dec);\n          }\n        }\n        if (img_dec) DecompressedFrameHook(*img_dec, video->pts());\n      }\n      if (!Continue()) break;\n    }\n\n    EndPassHook();\n\n    if (!Continue()) break;\n  }\n}",
          "fn_code_pos": [
            [
              164,
              0
            ],
            [
              265,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EncoderTest::RunLoop",
            "parameters": {
              "video": "VideoSource"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <memory>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/decode_test_driver.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/video_source.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/idct_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "virtual void SetUp() {\n    UUT = GetParam();\n\n    input = new Buffer<int16_t>(4, 4, 0);\n    ASSERT_TRUE(input != NULL);\n    ASSERT_TRUE(input->Init());\n    predict = new Buffer<uint8_t>(4, 4, 3);\n    ASSERT_TRUE(predict != NULL);\n    ASSERT_TRUE(predict->Init());\n    output = new Buffer<uint8_t>(4, 4, 3);\n    ASSERT_TRUE(output != NULL);\n    ASSERT_TRUE(output->Init());\n  }",
          "fn_code_pos": [
            [
              29,
              2
            ],
            [
              41,
              3
            ]
          ],
          "class_code": "75ed57906ed32c87e677378f0b7b1fe1d6b63d780a99d44da0d18b4e940e5881",
          "class_node_pos": [
            [
              27,
              0
            ],
            [
              54,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() {\n    delete input;\n    delete predict;\n    delete output;\n    libvpx_test::ClearSystemState();\n  }",
          "fn_code_pos": [
            [
              43,
              2
            ],
            [
              48,
              3
            ]
          ],
          "class_code": "75ed57906ed32c87e677378f0b7b1fe1d6b63d780a99d44da0d18b4e940e5881",
          "class_node_pos": [
            [
              27,
              0
            ],
            [
              54,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(IDCTTest, TestAllZeros) {\n  // When the input is '0' the output will be '0'.\n  input->Set(0);\n  predict->Set(0);\n  output->Set(0);\n\n  ASM_REGISTER_STATE_CHECK(UUT(input->TopLeftPixel(), predict->TopLeftPixel(),\n                               predict->stride(), output->TopLeftPixel(),\n                               output->stride()));\n\n  ASSERT_TRUE(input->CheckValues(0));\n  ASSERT_TRUE(input->CheckPadding());\n  ASSERT_TRUE(output->CheckValues(0));\n  ASSERT_TRUE(output->CheckPadding());\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              70,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(IDCTTest, TestAllOnes) {\n  input->Set(0);\n  ASSERT_TRUE(input->TopLeftPixel() != NULL);\n  // When the first element is '4' it will fill the output buffer with '1'.\n  input->TopLeftPixel()[0] = 4;\n  predict->Set(0);\n  output->Set(0);\n\n  ASM_REGISTER_STATE_CHECK(UUT(input->TopLeftPixel(), predict->TopLeftPixel(),\n                               predict->stride(), output->TopLeftPixel(),\n                               output->stride()));\n\n  ASSERT_TRUE(output->CheckValues(1));\n  ASSERT_TRUE(output->CheckPadding());\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(IDCTTest, TestAddOne) {\n  // Set the transform output to '1' and make sure it gets added to the\n  // prediction buffer.\n  input->Set(0);\n  ASSERT_TRUE(input->TopLeftPixel() != NULL);\n  input->TopLeftPixel()[0] = 4;\n  output->Set(0);\n\n  uint8_t *pred = predict->TopLeftPixel();\n  for (int y = 0; y < 4; ++y) {\n    for (int x = 0; x < 4; ++x) {\n      pred[y * predict->stride() + x] = y * 4 + x;\n    }\n  }\n\n  ASM_REGISTER_STATE_CHECK(UUT(input->TopLeftPixel(), predict->TopLeftPixel(),\n                               predict->stride(), output->TopLeftPixel(),\n                               output->stride()));\n\n  uint8_t const *out = output->TopLeftPixel();\n  for (int y = 0; y < 4; ++y) {\n    for (int x = 0; x < 4; ++x) {\n      EXPECT_EQ(1 + y * 4 + x, out[y * output->stride() + x]);\n    }\n  }\n\n  if (HasFailure()) {\n    output->DumpBuffer();\n  }\n\n  ASSERT_TRUE(output->CheckPadding());\n}",
          "fn_code_pos": [
            [
              88,
              0
            ],
            [
              119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(IDCTTest, TestWithData) {\n  // Test a single known input.\n  predict->Set(0);\n\n  int16_t *in = input->TopLeftPixel();\n  for (int y = 0; y < 4; ++y) {\n    for (int x = 0; x < 4; ++x) {\n      in[y * input->stride() + x] = y * 4 + x;\n    }\n  }\n\n  ASM_REGISTER_STATE_CHECK(UUT(input->TopLeftPixel(), predict->TopLeftPixel(),\n                               predict->stride(), output->TopLeftPixel(),\n                               output->stride()));\n\n  uint8_t *out = output->TopLeftPixel();\n  for (int y = 0; y < 4; ++y) {\n    for (int x = 0; x < 4; ++x) {\n      switch (y * 4 + x) {\n        case 0: EXPECT_EQ(11, out[y * output->stride() + x]); break;\n        case 2:\n        case 5:\n        case 8: EXPECT_EQ(3, out[y * output->stride() + x]); break;\n        case 10: EXPECT_EQ(1, out[y * output->stride() + x]); break;\n        default: EXPECT_EQ(0, out[y * output->stride() + x]);\n      }\n    }\n  }\n\n  if (HasFailure()) {\n    output->DumpBuffer();\n  }\n\n  ASSERT_TRUE(output->CheckPadding());\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              155,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*IdctFunc)(int16_t *input, unsigned char *pred_ptr,\n                         int pred_stride, unsigned char *dst_ptr,\n                         int dst_stride)",
          "fn_dec_pos": [
            [
              20,
              13
            ],
            [
              22,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "input": "int16_t",
              "pred_ptr": "unsigned char",
              "pred_stride": "int",
              "dst_ptr": "unsigned char",
              "dst_stride": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {
        "75ed57906ed32c87e677378f0b7b1fe1d6b63d780a99d44da0d18b4e940e5881": {
          "class_code": "class IDCTTest : public ::testing::TestWithParam<IdctFunc> {\n protected:\n  virtual void SetUp() {\n    UUT = GetParam();\n\n    input = new Buffer<int16_t>(4, 4, 0);\n    ASSERT_TRUE(input != NULL);\n    ASSERT_TRUE(input->Init());\n    predict = new Buffer<uint8_t>(4, 4, 3);\n    ASSERT_TRUE(predict != NULL);\n    ASSERT_TRUE(predict->Init());\n    output = new Buffer<uint8_t>(4, 4, 3);\n    ASSERT_TRUE(output != NULL);\n    ASSERT_TRUE(output->Init());\n  }\n\n  virtual void TearDown() {\n    delete input;\n    delete predict;\n    delete output;\n    libvpx_test::ClearSystemState();\n  }\n\n  IdctFunc UUT;\n  Buffer<int16_t> *input;\n  Buffer<uint8_t> *predict;\n  Buffer<uint8_t> *output;\n}",
          "class_name": "IDCTTest",
          "class_pos": [
            [
              27,
              0
            ],
            [
              54,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"./vpx_config.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"./vp8_rtcd.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/buffer.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp8_datarate_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "DatarateTestLarge() : EncoderTest(GET_PARAM(0)) {}",
          "fn_code_pos": [
            [
              24,
              2
            ],
            [
              24,
              52
            ]
          ],
          "class_code": "dc8982e080f3ff159979340594bb280d6def3dac25bacee92b92b4a56531fdb2",
          "class_node_pos": [
            [
              20,
              0
            ],
            [
              154,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DatarateTestLarge",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DatarateTestLarge() {}",
          "fn_code_pos": [
            [
              26,
              2
            ],
            [
              26,
              33
            ]
          ],
          "class_code": "dc8982e080f3ff159979340594bb280d6def3dac25bacee92b92b4a56531fdb2",
          "class_node_pos": [
            [
              20,
              0
            ],
            [
              154,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n    set_cpu_used_ = GET_PARAM(2);\n    ResetModel();\n  }",
          "fn_code_pos": [
            [
              29,
              2
            ],
            [
              34,
              3
            ]
          ],
          "class_code": "dc8982e080f3ff159979340594bb280d6def3dac25bacee92b92b4a56531fdb2",
          "class_node_pos": [
            [
              20,
              0
            ],
            [
              154,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void ResetModel() {\n    last_pts_ = 0;\n    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;\n    frame_number_ = 0;\n    first_drop_ = 0;\n    bits_total_ = 0;\n    duration_ = 0.0;\n    denoiser_offon_test_ = 0;\n    denoiser_offon_period_ = -1;\n    gf_boost_ = 0;\n    use_roi_ = false;\n  }",
          "fn_code_pos": [
            [
              36,
              2
            ],
            [
              47,
              3
            ]
          ],
          "class_code": "dc8982e080f3ff159979340594bb280d6def3dac25bacee92b92b4a56531fdb2",
          "class_node_pos": [
            [
              20,
              0
            ],
            [
              154,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ResetModel",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_NOISE_SENSITIVITY, denoiser_on_);\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n      encoder->Control(VP8E_SET_GF_CBR_BOOST_PCT, gf_boost_);\n    }\n\n    if (use_roi_) {\n      encoder->Control(VP8E_SET_ROI_MAP, &roi_);\n    }\n\n    if (denoiser_offon_test_) {\n      ASSERT_GT(denoiser_offon_period_, 0)\n          << \"denoiser_offon_period_ is not positive.\";\n      if ((video->frame() + 1) % denoiser_offon_period_ == 0) {\n        // Flip denoiser_on_ periodically\n        denoiser_on_ ^= 1;\n      }\n      encoder->Control(VP8E_SET_NOISE_SENSITIVITY, denoiser_on_);\n    }\n\n    const vpx_rational_t tb = video->timebase();\n    timebase_ = static_cast<double>(tb.num) / tb.den;\n    duration_ = 0;\n  }",
          "fn_code_pos": [
            [
              49,
              2
            ],
            [
              74,
              3
            ]
          ],
          "class_code": "dc8982e080f3ff159979340594bb280d6def3dac25bacee92b92b4a56531fdb2",
          "class_node_pos": [
            [
              20,
              0
            ],
            [
              154,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    // Time since last timestamp = duration.\n    vpx_codec_pts_t duration = pkt->data.frame.pts - last_pts_;\n\n    // TODO(jimbankoski): Remove these lines when the issue:\n    // http://code.google.com/p/webm/issues/detail?id=496 is fixed.\n    // For now the codec assumes buffer starts at starting buffer rate\n    // plus one frame's time.\n    if (last_pts_ == 0) duration = 1;\n\n    // Add to the buffer the bits we'd expect from a constant bitrate server.\n    bits_in_buffer_model_ += static_cast<int64_t>(\n        duration * timebase_ * cfg_.rc_target_bitrate * 1000);\n\n    /* Test the buffer model here before subtracting the frame. Do so because\n     * the way the leaky bucket model works in libvpx is to allow the buffer to\n     * empty - and then stop showing frames until we've got enough bits to\n     * show one. As noted in comment below (issue 495), this does not currently\n     * apply to key frames. For now exclude key frames in condition below. */\n    const bool key_frame =\n        (pkt->data.frame.flags & VPX_FRAME_IS_KEY) ? true : false;\n    if (!key_frame) {\n      ASSERT_GE(bits_in_buffer_model_, 0)\n          << \"Buffer Underrun at frame \" << pkt->data.frame.pts;\n    }\n\n    const int64_t frame_size_in_bits = pkt->data.frame.sz * 8;\n\n    // Subtract from the buffer the bits associated with a played back frame.\n    bits_in_buffer_model_ -= frame_size_in_bits;\n\n    // Update the running total of bits for end of test datarate checks.\n    bits_total_ += frame_size_in_bits;\n\n    // If first drop not set and we have a drop set it to this time.\n    if (!first_drop_ && duration > 1) first_drop_ = last_pts_ + 1;\n\n    // Update the most recent pts.\n    last_pts_ = pkt->data.frame.pts;\n\n    // We update this so that we can calculate the datarate minus the last\n    // frame encoded in the file.\n    bits_in_last_frame_ = frame_size_in_bits;\n\n    ++frame_number_;\n  }",
          "fn_code_pos": [
            [
              76,
              2
            ],
            [
              121,
              3
            ]
          ],
          "class_code": "dc8982e080f3ff159979340594bb280d6def3dac25bacee92b92b4a56531fdb2",
          "class_node_pos": [
            [
              20,
              0
            ],
            [
              154,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void EndPassHook(void) {\n    if (bits_total_) {\n      const double file_size_in_kb = bits_total_ / 1000.;  // bits per kilobit\n\n      duration_ = (last_pts_ + 1) * timebase_;\n\n      // Effective file datarate includes the time spent prebuffering.\n      effective_datarate_ = (bits_total_ - bits_in_last_frame_) / 1000.0 /\n                            (cfg_.rc_buf_initial_sz / 1000.0 + duration_);\n\n      file_datarate_ = file_size_in_kb / duration_;\n    }\n  }",
          "fn_code_pos": [
            [
              123,
              2
            ],
            [
              135,
              3
            ]
          ],
          "class_code": "dc8982e080f3ff159979340594bb280d6def3dac25bacee92b92b4a56531fdb2",
          "class_node_pos": [
            [
              20,
              0
            ],
            [
              154,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EndPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestLarge, DenoiserLevels) {\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_dropframe_thresh = 1;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_CBR;\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 140);\n  for (int j = 1; j < 5; ++j) {\n    // Run over the denoiser levels.\n    // For the temporal denoiser (#if CONFIG_TEMPORAL_DENOISING) the level j\n    // refers to the 4 denoiser modes: denoiserYonly, denoiserOnYUV,\n    // denoiserOnAggressive, and denoiserOnAdaptive.\n    denoiser_on_ = j;\n    cfg_.rc_target_bitrate = 300;\n    ResetModel();\n    ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n    ASSERT_GE(cfg_.rc_target_bitrate, effective_datarate_ * 0.95)\n        << \" The datarate for the file exceeds the target!\";\n\n    ASSERT_LE(cfg_.rc_target_bitrate, file_datarate_ * 1.4)\n        << \" The datarate for the file missed the target!\";\n  }\n}",
          "fn_code_pos": [
            [
              159,
              0
            ],
            [
              181,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestLarge, DenoiserOffOn) {\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_dropframe_thresh = 1;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_CBR;\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 299);\n  cfg_.rc_target_bitrate = 300;\n  ResetModel();\n  // The denoiser is off by default.\n  denoiser_on_ = 0;\n  // Set the offon test flag.\n  denoiser_offon_test_ = 1;\n  denoiser_offon_period_ = 100;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(cfg_.rc_target_bitrate, effective_datarate_ * 0.95)\n      << \" The datarate for the file exceeds the target!\";\n  ASSERT_LE(cfg_.rc_target_bitrate, file_datarate_ * 1.4)\n      << \" The datarate for the file missed the target!\";\n}",
          "fn_code_pos": [
            [
              185,
              0
            ],
            [
              204,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestLarge, BasicBufferModel) {\n  denoiser_on_ = 0;\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_dropframe_thresh = 1;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_CBR;\n  // 2 pass cbr datarate control has a bug hidden by the small # of\n  // frames selected in this encode. The problem is that even if the buffer is\n  // negative we produce a keyframe on a cutscene. Ignoring datarate\n  // constraints\n  // TODO(jimbankoski): ( Fix when issue\n  // http://code.google.com/p/webm/issues/detail?id=495 is addressed. )\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 140);\n\n  // There is an issue for low bitrates in real-time mode, where the\n  // effective_datarate slightly overshoots the target bitrate.\n  // This is same the issue as noted about (#495).\n  // TODO(jimbankoski/marpan): Update test to run for lower bitrates (< 100),\n  // when the issue is resolved.\n  for (int i = 100; i < 800; i += 200) {\n    cfg_.rc_target_bitrate = i;\n    ResetModel();\n    ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n    ASSERT_GE(cfg_.rc_target_bitrate, effective_datarate_ * 0.95)\n        << \" The datarate for the file exceeds the target!\";\n    ASSERT_LE(cfg_.rc_target_bitrate, file_datarate_ * 1.4)\n        << \" The datarate for the file missed the target!\";\n  }\n}",
          "fn_code_pos": [
            [
              207,
              0
            ],
            [
              236,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestLarge, ChangingDropFrameThresh) {\n  denoiser_on_ = 0;\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_max_quantizer = 36;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.rc_target_bitrate = 200;\n  cfg_.kf_mode = VPX_KF_DISABLED;\n\n  const int frame_count = 40;\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, frame_count);\n\n  // Here we check that the first dropped frame gets earlier and earlier\n  // as the drop frame threshold is increased.\n\n  const int kDropFrameThreshTestStep = 30;\n  vpx_codec_pts_t last_drop = frame_count;\n  for (int i = 1; i < 91; i += kDropFrameThreshTestStep) {\n    cfg_.rc_dropframe_thresh = i;\n    ResetModel();\n    ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n    ASSERT_LE(first_drop_, last_drop)\n        << \" The first dropped frame for drop_thresh \" << i\n        << \" > first dropped frame for drop_thresh \"\n        << i - kDropFrameThreshTestStep;\n    last_drop = first_drop_;\n  }\n}",
          "fn_code_pos": [
            [
              238,
              0
            ],
            [
              265,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestLarge, DropFramesMultiThreads) {\n  denoiser_on_ = 0;\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_dropframe_thresh = 30;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_threads = 2;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 140);\n  cfg_.rc_target_bitrate = 200;\n  ResetModel();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(cfg_.rc_target_bitrate, effective_datarate_ * 0.95)\n      << \" The datarate for the file exceeds the target!\";\n\n  ASSERT_LE(cfg_.rc_target_bitrate, file_datarate_ * 1.4)\n      << \" The datarate for the file missed the target!\";\n}",
          "fn_code_pos": [
            [
              267,
              0
            ],
            [
              285,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DatarateTestRealTime() {}",
          "fn_code_pos": [
            [
              289,
              2
            ],
            [
              289,
              36
            ]
          ],
          "class_code": "10189d9cf2448abb2be1cdf48876d0a64620ec18a7519e9f4f37c362fcdf5bd5",
          "class_node_pos": [
            [
              287,
              0
            ],
            [
              290,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestRealTime, DenoiserLevels) {\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_dropframe_thresh = 1;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_CBR;\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 140);\n  for (int j = 1; j < 5; ++j) {\n    // Run over the denoiser levels.\n    // For the temporal denoiser (#if CONFIG_TEMPORAL_DENOISING) the level j\n    // refers to the 4 denoiser modes: denoiserYonly, denoiserOnYUV,\n    // denoiserOnAggressive, and denoiserOnAdaptive.\n    denoiser_on_ = j;\n    cfg_.rc_target_bitrate = 300;\n    ResetModel();\n    ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n    ASSERT_GE(cfg_.rc_target_bitrate, effective_datarate_ * 0.95)\n        << \" The datarate for the file exceeds the target!\";\n    ASSERT_LE(cfg_.rc_target_bitrate, file_datarate_ * 1.4)\n        << \" The datarate for the file missed the target!\";\n  }\n}",
          "fn_code_pos": [
            [
              295,
              0
            ],
            [
              316,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestRealTime, DenoiserOffOn) {\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_dropframe_thresh = 1;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_CBR;\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 299);\n  cfg_.rc_target_bitrate = 300;\n  ResetModel();\n  // The denoiser is off by default.\n  denoiser_on_ = 0;\n  // Set the offon test flag.\n  denoiser_offon_test_ = 1;\n  denoiser_offon_period_ = 100;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(cfg_.rc_target_bitrate, effective_datarate_ * 0.95)\n      << \" The datarate for the file exceeds the target!\";\n  ASSERT_LE(cfg_.rc_target_bitrate, file_datarate_ * 1.4)\n      << \" The datarate for the file missed the target!\";\n}",
          "fn_code_pos": [
            [
              320,
              0
            ],
            [
              339,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestRealTime, BasicBufferModel) {\n  denoiser_on_ = 0;\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_dropframe_thresh = 1;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_CBR;\n  // 2 pass cbr datarate control has a bug hidden by the small # of\n  // frames selected in this encode. The problem is that even if the buffer is\n  // negative we produce a keyframe on a cutscene, ignoring datarate\n  // constraints\n  // TODO(jimbankoski): Fix when issue\n  // http://bugs.chromium.org/p/webm/issues/detail?id=495 is addressed.\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 140);\n\n  // There is an issue for low bitrates in real-time mode, where the\n  // effective_datarate slightly overshoots the target bitrate.\n  // This is same the issue as noted above (#495).\n  // TODO(jimbankoski/marpan): Update test to run for lower bitrates (< 100),\n  // when the issue is resolved.\n  for (int i = 100; i <= 700; i += 200) {\n    cfg_.rc_target_bitrate = i;\n    ResetModel();\n    ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n    ASSERT_GE(cfg_.rc_target_bitrate, effective_datarate_ * 0.95)\n        << \" The datarate for the file exceeds the target!\";\n    ASSERT_LE(cfg_.rc_target_bitrate, file_datarate_ * 1.4)\n        << \" The datarate for the file missed the target!\";\n  }\n}",
          "fn_code_pos": [
            [
              342,
              0
            ],
            [
              371,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestRealTime, ChangingDropFrameThresh) {\n  denoiser_on_ = 0;\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_max_quantizer = 36;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.rc_target_bitrate = 200;\n  cfg_.kf_mode = VPX_KF_DISABLED;\n\n  const int frame_count = 40;\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, frame_count);\n\n  // Check that the first dropped frame gets earlier and earlier\n  // as the drop frame threshold is increased.\n\n  const int kDropFrameThreshTestStep = 30;\n  vpx_codec_pts_t last_drop = frame_count;\n  for (int i = 1; i < 91; i += kDropFrameThreshTestStep) {\n    cfg_.rc_dropframe_thresh = i;\n    ResetModel();\n    ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n    ASSERT_LE(first_drop_, last_drop)\n        << \" The first dropped frame for drop_thresh \" << i\n        << \" > first dropped frame for drop_thresh \"\n        << i - kDropFrameThreshTestStep;\n    last_drop = first_drop_;\n  }\n}",
          "fn_code_pos": [
            [
              373,
              0
            ],
            [
              400,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestRealTime, DropFramesMultiThreads) {\n  denoiser_on_ = 0;\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_dropframe_thresh = 30;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_CBR;\n  // Encode using multiple threads.\n  cfg_.g_threads = 2;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 140);\n  cfg_.rc_target_bitrate = 200;\n  ResetModel();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(cfg_.rc_target_bitrate, effective_datarate_ * 0.95)\n      << \" The datarate for the file exceeds the target!\";\n\n  ASSERT_LE(cfg_.rc_target_bitrate, file_datarate_ * 1.4)\n      << \" The datarate for the file missed the target!\";\n}",
          "fn_code_pos": [
            [
              402,
              0
            ],
            [
              421,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestRealTime, RegionOfInterest) {\n  denoiser_on_ = 0;\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_dropframe_thresh = 0;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_CBR;\n  // Encode using multiple threads.\n  cfg_.g_threads = 2;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 300);\n  cfg_.rc_target_bitrate = 450;\n  cfg_.g_w = 352;\n  cfg_.g_h = 288;\n\n  ResetModel();\n\n  // Set ROI parameters\n  use_roi_ = true;\n  memset(&roi_, 0, sizeof(roi_));\n\n  roi_.rows = (cfg_.g_h + 15) / 16;\n  roi_.cols = (cfg_.g_w + 15) / 16;\n\n  roi_.delta_q[0] = 0;\n  roi_.delta_q[1] = -20;\n  roi_.delta_q[2] = 0;\n  roi_.delta_q[3] = 0;\n\n  roi_.delta_lf[0] = 0;\n  roi_.delta_lf[1] = -20;\n  roi_.delta_lf[2] = 0;\n  roi_.delta_lf[3] = 0;\n\n  roi_.static_threshold[0] = 0;\n  roi_.static_threshold[1] = 1000;\n  roi_.static_threshold[2] = 0;\n  roi_.static_threshold[3] = 0;\n\n  // Use 2 states: 1 is center square, 0 is the rest.\n  roi_.roi_map =\n      (uint8_t *)calloc(roi_.rows * roi_.cols, sizeof(*roi_.roi_map));\n  for (unsigned int i = 0; i < roi_.rows; ++i) {\n    for (unsigned int j = 0; j < roi_.cols; ++j) {\n      if (i > (roi_.rows >> 2) && i < ((roi_.rows * 3) >> 2) &&\n          j > (roi_.cols >> 2) && j < ((roi_.cols * 3) >> 2)) {\n        roi_.roi_map[i * roi_.cols + j] = 1;\n      }\n    }\n  }\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(cfg_.rc_target_bitrate, effective_datarate_ * 0.95)\n      << \" The datarate for the file exceeds the target!\";\n\n  ASSERT_LE(cfg_.rc_target_bitrate, file_datarate_ * 1.4)\n      << \" The datarate for the file missed the target!\";\n\n  free(roi_.roi_map);\n}",
          "fn_code_pos": [
            [
              423,
              0
            ],
            [
              482,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestRealTime, GFBoost) {\n  denoiser_on_ = 0;\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_dropframe_thresh = 0;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_error_resilient = 0;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 300);\n  cfg_.rc_target_bitrate = 300;\n  ResetModel();\n  // Apply a gf boost.\n  gf_boost_ = 50;\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(cfg_.rc_target_bitrate, effective_datarate_ * 0.95)\n      << \" The datarate for the file exceeds the target!\";\n\n  ASSERT_LE(cfg_.rc_target_bitrate, file_datarate_ * 1.4)\n      << \" The datarate for the file missed the target!\";\n}",
          "fn_code_pos": [
            [
              484,
              0
            ],
            [
              505,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "dc8982e080f3ff159979340594bb280d6def3dac25bacee92b92b4a56531fdb2": {
          "class_code": "class DatarateTestLarge\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWith2Params<libvpx_test::TestMode, int> {\n public:\n  DatarateTestLarge() : EncoderTest(GET_PARAM(0)) {}\n\n  virtual ~DatarateTestLarge() {}\n\n protected:\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n    set_cpu_used_ = GET_PARAM(2);\n    ResetModel();\n  }\n\n  virtual void ResetModel() {\n    last_pts_ = 0;\n    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;\n    frame_number_ = 0;\n    first_drop_ = 0;\n    bits_total_ = 0;\n    duration_ = 0.0;\n    denoiser_offon_test_ = 0;\n    denoiser_offon_period_ = -1;\n    gf_boost_ = 0;\n    use_roi_ = false;\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_NOISE_SENSITIVITY, denoiser_on_);\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n      encoder->Control(VP8E_SET_GF_CBR_BOOST_PCT, gf_boost_);\n    }\n\n    if (use_roi_) {\n      encoder->Control(VP8E_SET_ROI_MAP, &roi_);\n    }\n\n    if (denoiser_offon_test_) {\n      ASSERT_GT(denoiser_offon_period_, 0)\n          << \"denoiser_offon_period_ is not positive.\";\n      if ((video->frame() + 1) % denoiser_offon_period_ == 0) {\n        // Flip denoiser_on_ periodically\n        denoiser_on_ ^= 1;\n      }\n      encoder->Control(VP8E_SET_NOISE_SENSITIVITY, denoiser_on_);\n    }\n\n    const vpx_rational_t tb = video->timebase();\n    timebase_ = static_cast<double>(tb.num) / tb.den;\n    duration_ = 0;\n  }\n\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    // Time since last timestamp = duration.\n    vpx_codec_pts_t duration = pkt->data.frame.pts - last_pts_;\n\n    // TODO(jimbankoski): Remove these lines when the issue:\n    // http://code.google.com/p/webm/issues/detail?id=496 is fixed.\n    // For now the codec assumes buffer starts at starting buffer rate\n    // plus one frame's time.\n    if (last_pts_ == 0) duration = 1;\n\n    // Add to the buffer the bits we'd expect from a constant bitrate server.\n    bits_in_buffer_model_ += static_cast<int64_t>(\n        duration * timebase_ * cfg_.rc_target_bitrate * 1000);\n\n    /* Test the buffer model here before subtracting the frame. Do so because\n     * the way the leaky bucket model works in libvpx is to allow the buffer to\n     * empty - and then stop showing frames until we've got enough bits to\n     * show one. As noted in comment below (issue 495), this does not currently\n     * apply to key frames. For now exclude key frames in condition below. */\n    const bool key_frame =\n        (pkt->data.frame.flags & VPX_FRAME_IS_KEY) ? true : false;\n    if (!key_frame) {\n      ASSERT_GE(bits_in_buffer_model_, 0)\n          << \"Buffer Underrun at frame \" << pkt->data.frame.pts;\n    }\n\n    const int64_t frame_size_in_bits = pkt->data.frame.sz * 8;\n\n    // Subtract from the buffer the bits associated with a played back frame.\n    bits_in_buffer_model_ -= frame_size_in_bits;\n\n    // Update the running total of bits for end of test datarate checks.\n    bits_total_ += frame_size_in_bits;\n\n    // If first drop not set and we have a drop set it to this time.\n    if (!first_drop_ && duration > 1) first_drop_ = last_pts_ + 1;\n\n    // Update the most recent pts.\n    last_pts_ = pkt->data.frame.pts;\n\n    // We update this so that we can calculate the datarate minus the last\n    // frame encoded in the file.\n    bits_in_last_frame_ = frame_size_in_bits;\n\n    ++frame_number_;\n  }\n\n  virtual void EndPassHook(void) {\n    if (bits_total_) {\n      const double file_size_in_kb = bits_total_ / 1000.;  // bits per kilobit\n\n      duration_ = (last_pts_ + 1) * timebase_;\n\n      // Effective file datarate includes the time spent prebuffering.\n      effective_datarate_ = (bits_total_ - bits_in_last_frame_) / 1000.0 /\n                            (cfg_.rc_buf_initial_sz / 1000.0 + duration_);\n\n      file_datarate_ = file_size_in_kb / duration_;\n    }\n  }\n\n  vpx_codec_pts_t last_pts_;\n  int64_t bits_in_buffer_model_;\n  double timebase_;\n  int frame_number_;\n  vpx_codec_pts_t first_drop_;\n  int64_t bits_total_;\n  double duration_;\n  double file_datarate_;\n  double effective_datarate_;\n  int64_t bits_in_last_frame_;\n  int denoiser_on_;\n  int denoiser_offon_test_;\n  int denoiser_offon_period_;\n  int set_cpu_used_;\n  int gf_boost_;\n  bool use_roi_;\n  vpx_roi_map_t roi_;\n}",
          "class_name": "DatarateTestLarge",
          "class_pos": [
            [
              20,
              0
            ],
            [
              154,
              1
            ]
          ]
        },
        "10189d9cf2448abb2be1cdf48876d0a64620ec18a7519e9f4f37c362fcdf5bd5": {
          "class_code": "class DatarateTestRealTime : public DatarateTestLarge {\n public:\n  virtual ~DatarateTestRealTime() {}\n}",
          "class_name": "DatarateTestRealTime",
          "class_pos": [
            [
              287,
              0
            ],
            [
              290,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"./vpx_config.h\"\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/y4m_video_source.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_codec.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp8_fdct4x4_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "void reference_idct4x4(const int16_t *input, int16_t *output) {\n  const int16_t *ip = input;\n  int16_t *op = output;\n\n  for (int i = 0; i < 4; ++i) {\n    const int a1 = ip[0] + ip[8];\n    const int b1 = ip[0] - ip[8];\n    const int temp1 = (ip[4] * sinpi8sqrt2) >> 16;\n    const int temp2 = ip[12] + ((ip[12] * cospi8sqrt2minus1) >> 16);\n    const int c1 = temp1 - temp2;\n    const int temp3 = ip[4] + ((ip[4] * cospi8sqrt2minus1) >> 16);\n    const int temp4 = (ip[12] * sinpi8sqrt2) >> 16;\n    const int d1 = temp3 + temp4;\n    op[0] = a1 + d1;\n    op[12] = a1 - d1;\n    op[4] = b1 + c1;\n    op[8] = b1 - c1;\n    ++ip;\n    ++op;\n  }\n  ip = output;\n  op = output;\n  for (int i = 0; i < 4; ++i) {\n    const int a1 = ip[0] + ip[2];\n    const int b1 = ip[0] - ip[2];\n    const int temp1 = (ip[1] * sinpi8sqrt2) >> 16;\n    const int temp2 = ip[3] + ((ip[3] * cospi8sqrt2minus1) >> 16);\n    const int c1 = temp1 - temp2;\n    const int temp3 = ip[1] + ((ip[1] * cospi8sqrt2minus1) >> 16);\n    const int temp4 = (ip[3] * sinpi8sqrt2) >> 16;\n    const int d1 = temp3 + temp4;\n    op[0] = (a1 + d1 + 4) >> 3;\n    op[3] = (a1 - d1 + 4) >> 3;\n    op[1] = (b1 + c1 + 4) >> 3;\n    op[2] = (b1 - c1 + 4) >> 3;\n    ip += 4;\n    op += 4;\n  }\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              70,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reference_idct4x4",
            "parameters": {
              "input": "int16_t",
              "output": "int16_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    fdct_func_ = GetParam();\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n  }",
          "fn_code_pos": [
            [
              76,
              2
            ],
            [
              79,
              3
            ]
          ],
          "class_code": "ffd2a5d0a4d1eaaaae92f1a988499a0f96cb977a3db6d795f33bcb410621d39e",
          "class_node_pos": [
            [
              74,
              0
            ],
            [
              84,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(FdctTest, SignBiasCheck) {\n  int16_t test_input_block[16];\n  DECLARE_ALIGNED(16, int16_t, test_output_block[16]);\n  const int pitch = 8;\n  int count_sign_block[16][2];\n  const int count_test_block = 1000000;\n\n  memset(count_sign_block, 0, sizeof(count_sign_block));\n\n  for (int i = 0; i < count_test_block; ++i) {\n    // Initialize a test block with input range [-255, 255].\n    for (int j = 0; j < 16; ++j) {\n      test_input_block[j] = rnd_.Rand8() - rnd_.Rand8();\n    }\n\n    fdct_func_(test_input_block, test_output_block, pitch);\n\n    for (int j = 0; j < 16; ++j) {\n      if (test_output_block[j] < 0) {\n        ++count_sign_block[j][0];\n      } else if (test_output_block[j] > 0) {\n        ++count_sign_block[j][1];\n      }\n    }\n  }\n\n  bool bias_acceptable = true;\n  for (int j = 0; j < 16; ++j) {\n    bias_acceptable =\n        bias_acceptable &&\n        (abs(count_sign_block[j][0] - count_sign_block[j][1]) < 10000);\n  }\n\n  EXPECT_EQ(true, bias_acceptable)\n      << \"Error: 4x4 FDCT has a sign bias > 1% for input range [-255, 255]\";\n\n  memset(count_sign_block, 0, sizeof(count_sign_block));\n\n  for (int i = 0; i < count_test_block; ++i) {\n    // Initialize a test block with input range [-15, 15].\n    for (int j = 0; j < 16; ++j) {\n      test_input_block[j] = (rnd_.Rand8() >> 4) - (rnd_.Rand8() >> 4);\n    }\n\n    fdct_func_(test_input_block, test_output_block, pitch);\n\n    for (int j = 0; j < 16; ++j) {\n      if (test_output_block[j] < 0) {\n        ++count_sign_block[j][0];\n      } else if (test_output_block[j] > 0) {\n        ++count_sign_block[j][1];\n      }\n    }\n  }\n\n  bias_acceptable = true;\n  for (int j = 0; j < 16; ++j) {\n    bias_acceptable =\n        bias_acceptable &&\n        (abs(count_sign_block[j][0] - count_sign_block[j][1]) < 100000);\n  }\n\n  EXPECT_EQ(true, bias_acceptable)\n      << \"Error: 4x4 FDCT has a sign bias > 10% for input range [-15, 15]\";\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(FdctTest, RoundTripErrorCheck) {\n  int max_error = 0;\n  double total_error = 0;\n  const int count_test_block = 1000000;\n  for (int i = 0; i < count_test_block; ++i) {\n    int16_t test_input_block[16];\n    int16_t test_output_block[16];\n    DECLARE_ALIGNED(16, int16_t, test_temp_block[16]);\n\n    // Initialize a test block with input range [-255, 255].\n    for (int j = 0; j < 16; ++j) {\n      test_input_block[j] = rnd_.Rand8() - rnd_.Rand8();\n    }\n\n    const int pitch = 8;\n    fdct_func_(test_input_block, test_temp_block, pitch);\n    reference_idct4x4(test_temp_block, test_output_block);\n\n    for (int j = 0; j < 16; ++j) {\n      const int diff = test_input_block[j] - test_output_block[j];\n      const int error = diff * diff;\n      if (max_error < error) max_error = error;\n      total_error += error;\n    }\n  }\n\n  EXPECT_GE(1, max_error)\n      << \"Error: FDCT/IDCT has an individual roundtrip error > 1\";\n\n  EXPECT_GE(count_test_block, total_error)\n      << \"Error: FDCT/IDCT has average roundtrip error > 1 per block\";\n}",
          "fn_code_pos": [
            [
              152,
              0
            ],
            [
              183,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*FdctFunc)(int16_t *a, int16_t *b, int a_stride)",
          "fn_dec_pos": [
            [
              27,
              13
            ],
            [
              27,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "a": "int16_t",
              "b": "int16_t",
              "a_stride": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {
        "ffd2a5d0a4d1eaaaae92f1a988499a0f96cb977a3db6d795f33bcb410621d39e": {
          "class_code": "class FdctTest : public ::testing::TestWithParam<FdctFunc> {\n public:\n  virtual void SetUp() {\n    fdct_func_ = GetParam();\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n  }\n\n protected:\n  FdctFunc fdct_func_;\n  ACMRandom rnd_;\n}",
          "class_name": "FdctTest",
          "class_pos": [
            [
              74,
              0
            ],
            [
              84,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <math.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stddef.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"./vp8_rtcd.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"vpx_ports/mem.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/svc_end_to_end_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "ScalePartitionOnePassCbrSvc()\n      : OnePassCbrSvc(GetParam()), mismatch_nframes_(0), num_nonref_frames_(0) {\n    SetMode(::libvpx_test::kRealTime);\n  }",
          "fn_code_pos": [
            [
              40,
              2
            ],
            [
              43,
              3
            ]
          ],
          "class_code": "7dd1ff6ea819652b9bee55ea97310dd56a65575c9b1e74d3c2c09959ddebfb55",
          "class_node_pos": [
            [
              36,
              0
            ],
            [
              81,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ScalePartitionOnePassCbrSvc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~ScalePartitionOnePassCbrSvc() {}",
          "fn_code_pos": [
            [
              46,
              2
            ],
            [
              46,
              43
            ]
          ],
          "class_code": "7dd1ff6ea819652b9bee55ea97310dd56a65575c9b1e74d3c2c09959ddebfb55",
          "class_node_pos": [
            [
              36,
              0
            ],
            [
              81,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    speed_setting_ = 7;\n  }",
          "fn_code_pos": [
            [
              48,
              2
            ],
            [
              51,
              3
            ]
          ],
          "class_code": "7dd1ff6ea819652b9bee55ea97310dd56a65575c9b1e74d3c2c09959ddebfb55",
          "class_node_pos": [
            [
              36,
              0
            ],
            [
              81,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    PreEncodeFrameHookSetup(video, encoder);\n  }",
          "fn_code_pos": [
            [
              53,
              2
            ],
            [
              56,
              3
            ]
          ],
          "class_code": "7dd1ff6ea819652b9bee55ea97310dd56a65575c9b1e74d3c2c09959ddebfb55",
          "class_node_pos": [
            [
              36,
              0
            ],
            [
              81,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    // Keep track of number of non-reference frames, needed for mismatch check.\n    // Non-reference frames are top spatial and temporal layer frames,\n    // for TL > 0.\n    if (temporal_layer_id_ == number_temporal_layers_ - 1 &&\n        temporal_layer_id_ > 0 &&\n        pkt->data.frame.spatial_layer_encoded[number_spatial_layers_ - 1])\n      num_nonref_frames_++;\n  }",
          "fn_code_pos": [
            [
              58,
              2
            ],
            [
              66,
              3
            ]
          ],
          "class_code": "7dd1ff6ea819652b9bee55ea97310dd56a65575c9b1e74d3c2c09959ddebfb55",
          "class_node_pos": [
            [
              36,
              0
            ],
            [
              81,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void MismatchHook(const vpx_image_t * /*img1*/,\n                            const vpx_image_t * /*img2*/) {\n    ++mismatch_nframes_;\n  }",
          "fn_code_pos": [
            [
              68,
              2
            ],
            [
              71,
              3
            ]
          ],
          "class_code": "7dd1ff6ea819652b9bee55ea97310dd56a65575c9b1e74d3c2c09959ddebfb55",
          "class_node_pos": [
            [
              36,
              0
            ],
            [
              81,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MismatchHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void SetConfig(const int /*num_temporal_layer*/) {}",
          "fn_code_pos": [
            [
              73,
              2
            ],
            [
              73,
              61
            ]
          ],
          "class_code": "7dd1ff6ea819652b9bee55ea97310dd56a65575c9b1e74d3c2c09959ddebfb55",
          "class_node_pos": [
            [
              36,
              0
            ],
            [
              81,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetConfig",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "unsigned int GetMismatchFrames() const { return mismatch_nframes_; }",
          "fn_code_pos": [
            [
              75,
              2
            ],
            [
              75,
              70
            ]
          ],
          "class_code": "7dd1ff6ea819652b9bee55ea97310dd56a65575c9b1e74d3c2c09959ddebfb55",
          "class_node_pos": [
            [
              36,
              0
            ],
            [
              81,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetMismatchFrames",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned int GetNonRefFrames() const { return num_nonref_frames_; }",
          "fn_code_pos": [
            [
              76,
              2
            ],
            [
              76,
              69
            ]
          ],
          "class_code": "7dd1ff6ea819652b9bee55ea97310dd56a65575c9b1e74d3c2c09959ddebfb55",
          "class_node_pos": [
            [
              36,
              0
            ],
            [
              81,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetNonRefFrames",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ScalePartitionOnePassCbrSvc, OnePassCbrSvc3SL3TL1080P) {\n  SetSvcConfig(3, 3);\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_threads = 1;\n  cfg_.rc_dropframe_thresh = 10;\n  cfg_.rc_target_bitrate = 800;\n  cfg_.kf_max_dist = 9999;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_lag_in_frames = 0;\n  cfg_.g_error_resilient = 1;\n  cfg_.ts_rate_decimator[0] = 4;\n  cfg_.ts_rate_decimator[1] = 2;\n  cfg_.ts_rate_decimator[2] = 1;\n  cfg_.temporal_layering_mode = 3;\n  ::libvpx_test::I420VideoSource video(\n      \"slides_code_term_web_plot.1920_1080.yuv\", 1920, 1080, 30, 1, 0, 100);\n  // For this 3 temporal layer case, pattern repeats every 4 frames, so choose\n  // 4 key neighboring key frame periods (so key frame will land on 0-2-1-2).\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              83,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "SyncFrameOnePassCbrSvc()\n      : OnePassCbrSvc(GET_PARAM(0)), current_video_frame_(0),\n        frame_to_start_decode_(0), frame_to_sync_(0),\n        inter_layer_pred_mode_(GET_PARAM(1)), decode_to_layer_before_sync_(-1),\n        decode_to_layer_after_sync_(-1), denoiser_on_(0),\n        intra_only_test_(false), mismatch_nframes_(0), num_nonref_frames_(0) {\n    SetMode(::libvpx_test::kRealTime);\n    memset(&svc_layer_sync_, 0, sizeof(svc_layer_sync_));\n  }",
          "fn_code_pos": [
            [
              118,
              2
            ],
            [
              126,
              3
            ]
          ],
          "class_code": "680f3f95cdfa65326d872ddbb560de55d0f39325e507544621c70e14133af165",
          "class_node_pos": [
            [
              115,
              0
            ],
            [
              248,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SyncFrameOnePassCbrSvc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~SyncFrameOnePassCbrSvc() {}",
          "fn_code_pos": [
            [
              129,
              2
            ],
            [
              129,
              38
            ]
          ],
          "class_code": "680f3f95cdfa65326d872ddbb560de55d0f39325e507544621c70e14133af165",
          "class_node_pos": [
            [
              115,
              0
            ],
            [
              248,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    speed_setting_ = 7;\n  }",
          "fn_code_pos": [
            [
              131,
              2
            ],
            [
              134,
              3
            ]
          ],
          "class_code": "680f3f95cdfa65326d872ddbb560de55d0f39325e507544621c70e14133af165",
          "class_node_pos": [
            [
              115,
              0
            ],
            [
              248,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual bool DoDecode() const {\n    return current_video_frame_ >= frame_to_start_decode_;\n  }",
          "fn_code_pos": [
            [
              136,
              2
            ],
            [
              138,
              3
            ]
          ],
          "class_code": "680f3f95cdfa65326d872ddbb560de55d0f39325e507544621c70e14133af165",
          "class_node_pos": [
            [
              115,
              0
            ],
            [
              248,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DoDecode",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    current_video_frame_ = video->frame();\n    PreEncodeFrameHookSetup(video, encoder);\n    if (video->frame() == 0) {\n      // Do not turn off inter-layer pred completely because simulcast mode\n      // fails.\n      if (inter_layer_pred_mode_ != INTER_LAYER_PRED_OFF)\n        encoder->Control(VP9E_SET_SVC_INTER_LAYER_PRED, inter_layer_pred_mode_);\n      encoder->Control(VP9E_SET_NOISE_SENSITIVITY, denoiser_on_);\n      if (intra_only_test_)\n        // Decoder sets the color_space for Intra-only frames\n        // to BT_601 (see line 1810 in vp9_decodeframe.c).\n        // So set it here in these tess to avoid encoder-decoder\n        // mismatch check on color space setting.\n        encoder->Control(VP9E_SET_COLOR_SPACE, VPX_CS_BT_601);\n    }\n    if (video->frame() == frame_to_sync_) {\n      encoder->Control(VP9E_SET_SVC_SPATIAL_LAYER_SYNC, &svc_layer_sync_);\n    }\n  }",
          "fn_code_pos": [
            [
              140,
              2
            ],
            [
              160,
              3
            ]
          ],
          "class_code": "680f3f95cdfa65326d872ddbb560de55d0f39325e507544621c70e14133af165",
          "class_node_pos": [
            [
              115,
              0
            ],
            [
              248,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreDecodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Decoder *decoder) {\n    if (video->frame() < frame_to_sync_) {\n      if (decode_to_layer_before_sync_ >= 0)\n        decoder->Control(VP9_DECODE_SVC_SPATIAL_LAYER,\n                         decode_to_layer_before_sync_);\n    } else {\n      if (decode_to_layer_after_sync_ >= 0)\n        decoder->Control(VP9_DECODE_SVC_SPATIAL_LAYER,\n                         decode_to_layer_after_sync_);\n    }\n  }",
          "fn_code_pos": [
            [
              163,
              2
            ],
            [
              174,
              3
            ]
          ],
          "class_code": "680f3f95cdfa65326d872ddbb560de55d0f39325e507544621c70e14133af165",
          "class_node_pos": [
            [
              115,
              0
            ],
            [
              248,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreDecodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "decoder": "::libvpx_test::Decoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    // Keep track of number of non-reference frames, needed for mismatch check.\n    // Non-reference frames are top spatial and temporal layer frames,\n    // for TL > 0.\n    if (temporal_layer_id_ == number_temporal_layers_ - 1 &&\n        temporal_layer_id_ > 0 &&\n        pkt->data.frame.spatial_layer_encoded[number_spatial_layers_ - 1] &&\n        current_video_frame_ >= frame_to_sync_)\n      num_nonref_frames_++;\n\n    if (intra_only_test_ && current_video_frame_ == frame_to_sync_) {\n      // Intra-only frame is only generated for spatial layers > 1 and <= 3,\n      // among other conditions (see constraint in set_intra_only_frame(). If\n      // intra-only is no allowed then encoder will insert key frame instead.\n      const bool key_frame =\n          (pkt->data.frame.flags & VPX_FRAME_IS_KEY) ? true : false;\n      if (number_spatial_layers_ == 1 || number_spatial_layers_ > 3)\n        ASSERT_TRUE(key_frame);\n      else\n        ASSERT_FALSE(key_frame);\n    }\n  }",
          "fn_code_pos": [
            [
              177,
              2
            ],
            [
              198,
              3
            ]
          ],
          "class_code": "680f3f95cdfa65326d872ddbb560de55d0f39325e507544621c70e14133af165",
          "class_node_pos": [
            [
              115,
              0
            ],
            [
              248,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void MismatchHook(const vpx_image_t * /*img1*/,\n                            const vpx_image_t * /*img2*/) {\n    if (current_video_frame_ >= frame_to_sync_) ++mismatch_nframes_;\n  }",
          "fn_code_pos": [
            [
              200,
              2
            ],
            [
              203,
              3
            ]
          ],
          "class_code": "680f3f95cdfa65326d872ddbb560de55d0f39325e507544621c70e14133af165",
          "class_node_pos": [
            [
              115,
              0
            ],
            [
              248,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MismatchHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "unsigned int GetMismatchFrames() const { return mismatch_nframes_; }",
          "fn_code_pos": [
            [
              205,
              2
            ],
            [
              205,
              70
            ]
          ],
          "class_code": "680f3f95cdfa65326d872ddbb560de55d0f39325e507544621c70e14133af165",
          "class_node_pos": [
            [
              115,
              0
            ],
            [
              248,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetMismatchFrames",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned int GetNonRefFrames() const { return num_nonref_frames_; }",
          "fn_code_pos": [
            [
              206,
              2
            ],
            [
              206,
              69
            ]
          ],
          "class_code": "680f3f95cdfa65326d872ddbb560de55d0f39325e507544621c70e14133af165",
          "class_node_pos": [
            [
              115,
              0
            ],
            [
              248,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetNonRefFrames",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetConfig(const int num_temporal_layer) {\n    cfg_.rc_buf_initial_sz = 500;\n    cfg_.rc_buf_optimal_sz = 500;\n    cfg_.rc_buf_sz = 1000;\n    cfg_.rc_min_quantizer = 0;\n    cfg_.rc_max_quantizer = 63;\n    cfg_.rc_end_usage = VPX_CBR;\n    cfg_.g_lag_in_frames = 0;\n    cfg_.g_error_resilient = 1;\n    cfg_.g_threads = 1;\n    cfg_.rc_dropframe_thresh = 30;\n    cfg_.kf_max_dist = 9999;\n    if (num_temporal_layer == 3) {\n      cfg_.ts_rate_decimator[0] = 4;\n      cfg_.ts_rate_decimator[1] = 2;\n      cfg_.ts_rate_decimator[2] = 1;\n      cfg_.temporal_layering_mode = 3;\n    } else if (num_temporal_layer == 2) {\n      cfg_.ts_rate_decimator[0] = 2;\n      cfg_.ts_rate_decimator[1] = 1;\n      cfg_.temporal_layering_mode = 2;\n    } else if (num_temporal_layer == 1) {\n      cfg_.ts_rate_decimator[0] = 1;\n      cfg_.temporal_layering_mode = 1;\n    }\n  }",
          "fn_code_pos": [
            [
              219,
              2
            ],
            [
              244,
              3
            ]
          ],
          "class_code": "680f3f95cdfa65326d872ddbb560de55d0f39325e507544621c70e14133af165",
          "class_node_pos": [
            [
              115,
              0
            ],
            [
              248,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetConfig",
            "parameters": {
              "num_temporal_layer": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(SyncFrameOnePassCbrSvc, OnePassCbrSvc3SL3TLFullSync) {\n  SetSvcConfig(3, 3);\n  // Sync is on base layer so the frame to sync and the frame to start decoding\n  // is the same.\n  frame_to_start_decode_ = 20;\n  frame_to_sync_ = 20;\n  decode_to_layer_before_sync_ = -1;\n  decode_to_layer_after_sync_ = 2;\n\n  // Set up svc layer sync structure.\n  svc_layer_sync_.base_layer_intra_only = 0;\n  svc_layer_sync_.spatial_layer_sync[0] = 1;\n\n  ::libvpx_test::Y4mVideoSource video(\"niklas_1280_720_30.y4m\", 0, 60);\n\n  cfg_.rc_target_bitrate = 600;\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              253,
              0
            ],
            [
              276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SyncFrameOnePassCbrSvc, OnePassCbrSvc2SL3TLSyncToVGA) {\n  SetSvcConfig(2, 3);\n  frame_to_start_decode_ = 0;\n  frame_to_sync_ = 100;\n  decode_to_layer_before_sync_ = 0;\n  decode_to_layer_after_sync_ = 1;\n\n  // Set up svc layer sync structure.\n  svc_layer_sync_.base_layer_intra_only = 0;\n  svc_layer_sync_.spatial_layer_sync[0] = 0;\n  svc_layer_sync_.spatial_layer_sync[1] = 1;\n\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  cfg_.rc_target_bitrate = 400;\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              281,
              0
            ],
            [
              303,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SyncFrameOnePassCbrSvc, OnePassCbrSvc3SL3TLSyncToHD) {\n  SetSvcConfig(3, 3);\n  frame_to_start_decode_ = 0;\n  frame_to_sync_ = 20;\n  decode_to_layer_before_sync_ = 1;\n  decode_to_layer_after_sync_ = 2;\n\n  // Set up svc layer sync structure.\n  svc_layer_sync_.base_layer_intra_only = 0;\n  svc_layer_sync_.spatial_layer_sync[0] = 0;\n  svc_layer_sync_.spatial_layer_sync[1] = 0;\n  svc_layer_sync_.spatial_layer_sync[2] = 1;\n\n  ::libvpx_test::Y4mVideoSource video(\"niklas_1280_720_30.y4m\", 0, 60);\n  cfg_.rc_target_bitrate = 600;\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              308,
              0
            ],
            [
              330,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SyncFrameOnePassCbrSvc, OnePassCbrSvc3SL3TLSyncToVGAHD) {\n  SetSvcConfig(3, 3);\n  frame_to_start_decode_ = 0;\n  frame_to_sync_ = 20;\n  decode_to_layer_before_sync_ = 0;\n  decode_to_layer_after_sync_ = 2;\n\n  // Set up svc layer sync structure.\n  svc_layer_sync_.base_layer_intra_only = 0;\n  svc_layer_sync_.spatial_layer_sync[0] = 0;\n  svc_layer_sync_.spatial_layer_sync[1] = 1;\n  svc_layer_sync_.spatial_layer_sync[2] = 1;\n\n  ::libvpx_test::Y4mVideoSource video(\"niklas_1280_720_30.y4m\", 0, 60);\n  cfg_.rc_target_bitrate = 600;\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              335,
              0
            ],
            [
              357,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SyncFrameOnePassCbrSvc, OnePassCbrSvc2SL3TLSyncFrameVGADenoise) {\n  SetSvcConfig(2, 3);\n  frame_to_start_decode_ = 0;\n  frame_to_sync_ = 100;\n  decode_to_layer_before_sync_ = 0;\n  decode_to_layer_after_sync_ = 1;\n\n  denoiser_on_ = 1;\n  // Set up svc layer sync structure.\n  svc_layer_sync_.base_layer_intra_only = 0;\n  svc_layer_sync_.spatial_layer_sync[0] = 0;\n  svc_layer_sync_.spatial_layer_sync[1] = 1;\n\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  cfg_.rc_target_bitrate = 400;\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              363,
              0
            ],
            [
              386,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SyncFrameOnePassCbrSvc, OnePassCbrSvc3SL3TLSyncFrameIntraOnlyQVGA) {\n  SetSvcConfig(3, 3);\n  frame_to_start_decode_ = 0;\n  frame_to_sync_ = 20;\n  decode_to_layer_before_sync_ = 2;\n  // The superframe containing intra-only layer will have 4 frames. Thus set the\n  // layer to decode after sync frame to 3.\n  decode_to_layer_after_sync_ = 3;\n  intra_only_test_ = true;\n\n  // Set up svc layer sync structure.\n  svc_layer_sync_.base_layer_intra_only = 1;\n  svc_layer_sync_.spatial_layer_sync[0] = 1;\n  svc_layer_sync_.spatial_layer_sync[1] = 0;\n  svc_layer_sync_.spatial_layer_sync[2] = 0;\n\n  ::libvpx_test::Y4mVideoSource video(\"niklas_1280_720_30.y4m\", 0, 60);\n  cfg_.rc_target_bitrate = 600;\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              391,
              0
            ],
            [
              416,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SyncFrameOnePassCbrSvc, OnePassCbrSvc3SL3TLSyncFrameIntraOnlyVGA) {\n  SetSvcConfig(3, 3);\n  frame_to_start_decode_ = 0;\n  frame_to_sync_ = 20;\n  decode_to_layer_before_sync_ = 2;\n  // The superframe containing intra-only layer will have 4 frames. Thus set the\n  // layer to decode after sync frame to 3.\n  decode_to_layer_after_sync_ = 3;\n  intra_only_test_ = true;\n\n  // Set up svc layer sync structure.\n  svc_layer_sync_.base_layer_intra_only = 1;\n  svc_layer_sync_.spatial_layer_sync[0] = 1;\n  svc_layer_sync_.spatial_layer_sync[1] = 1;\n  svc_layer_sync_.spatial_layer_sync[2] = 0;\n\n  ::libvpx_test::Y4mVideoSource video(\"niklas_1280_720_30.y4m\", 0, 60);\n  cfg_.rc_target_bitrate = 600;\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              420,
              0
            ],
            [
              445,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SyncFrameOnePassCbrSvc, OnePassCbrSvc1SL3TLSyncFrameIntraOnlyQVGA) {\n  SetSvcConfig(1, 3);\n  frame_to_start_decode_ = 20;\n  frame_to_sync_ = 20;\n  decode_to_layer_before_sync_ = 0;\n  decode_to_layer_after_sync_ = 0;\n  intra_only_test_ = true;\n\n  // Set up svc layer sync structure.\n  svc_layer_sync_.base_layer_intra_only = 1;\n  svc_layer_sync_.spatial_layer_sync[0] = 1;\n\n  ::libvpx_test::Y4mVideoSource video(\"niklas_1280_720_30.y4m\", 0, 60);\n  cfg_.rc_target_bitrate = 600;\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              449,
              0
            ],
            [
              470,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "7dd1ff6ea819652b9bee55ea97310dd56a65575c9b1e74d3c2c09959ddebfb55": {
          "class_code": "class ScalePartitionOnePassCbrSvc\n    : public OnePassCbrSvc,\n      public ::testing::TestWithParam<const ::libvpx_test::CodecFactory *> {\n public:\n  ScalePartitionOnePassCbrSvc()\n      : OnePassCbrSvc(GetParam()), mismatch_nframes_(0), num_nonref_frames_(0) {\n    SetMode(::libvpx_test::kRealTime);\n  }\n\n protected:\n  virtual ~ScalePartitionOnePassCbrSvc() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    speed_setting_ = 7;\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    PreEncodeFrameHookSetup(video, encoder);\n  }\n\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    // Keep track of number of non-reference frames, needed for mismatch check.\n    // Non-reference frames are top spatial and temporal layer frames,\n    // for TL > 0.\n    if (temporal_layer_id_ == number_temporal_layers_ - 1 &&\n        temporal_layer_id_ > 0 &&\n        pkt->data.frame.spatial_layer_encoded[number_spatial_layers_ - 1])\n      num_nonref_frames_++;\n  }\n\n  virtual void MismatchHook(const vpx_image_t * /*img1*/,\n                            const vpx_image_t * /*img2*/) {\n    ++mismatch_nframes_;\n  }\n\n  virtual void SetConfig(const int /*num_temporal_layer*/) {}\n\n  unsigned int GetMismatchFrames() const { return mismatch_nframes_; }\n  unsigned int GetNonRefFrames() const { return num_nonref_frames_; }\n\n private:\n  unsigned int mismatch_nframes_;\n  unsigned int num_nonref_frames_;\n}",
          "class_name": "ScalePartitionOnePassCbrSvc",
          "class_pos": [
            [
              36,
              0
            ],
            [
              81,
              1
            ]
          ]
        },
        "680f3f95cdfa65326d872ddbb560de55d0f39325e507544621c70e14133af165": {
          "class_code": "class SyncFrameOnePassCbrSvc : public OnePassCbrSvc,\n                               public ::libvpx_test::CodecTestWithParam<int> {\n public:\n  SyncFrameOnePassCbrSvc()\n      : OnePassCbrSvc(GET_PARAM(0)), current_video_frame_(0),\n        frame_to_start_decode_(0), frame_to_sync_(0),\n        inter_layer_pred_mode_(GET_PARAM(1)), decode_to_layer_before_sync_(-1),\n        decode_to_layer_after_sync_(-1), denoiser_on_(0),\n        intra_only_test_(false), mismatch_nframes_(0), num_nonref_frames_(0) {\n    SetMode(::libvpx_test::kRealTime);\n    memset(&svc_layer_sync_, 0, sizeof(svc_layer_sync_));\n  }\n\n protected:\n  virtual ~SyncFrameOnePassCbrSvc() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    speed_setting_ = 7;\n  }\n\n  virtual bool DoDecode() const {\n    return current_video_frame_ >= frame_to_start_decode_;\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    current_video_frame_ = video->frame();\n    PreEncodeFrameHookSetup(video, encoder);\n    if (video->frame() == 0) {\n      // Do not turn off inter-layer pred completely because simulcast mode\n      // fails.\n      if (inter_layer_pred_mode_ != INTER_LAYER_PRED_OFF)\n        encoder->Control(VP9E_SET_SVC_INTER_LAYER_PRED, inter_layer_pred_mode_);\n      encoder->Control(VP9E_SET_NOISE_SENSITIVITY, denoiser_on_);\n      if (intra_only_test_)\n        // Decoder sets the color_space for Intra-only frames\n        // to BT_601 (see line 1810 in vp9_decodeframe.c).\n        // So set it here in these tess to avoid encoder-decoder\n        // mismatch check on color space setting.\n        encoder->Control(VP9E_SET_COLOR_SPACE, VPX_CS_BT_601);\n    }\n    if (video->frame() == frame_to_sync_) {\n      encoder->Control(VP9E_SET_SVC_SPATIAL_LAYER_SYNC, &svc_layer_sync_);\n    }\n  }\n\n#if CONFIG_VP9_DECODER\n  virtual void PreDecodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Decoder *decoder) {\n    if (video->frame() < frame_to_sync_) {\n      if (decode_to_layer_before_sync_ >= 0)\n        decoder->Control(VP9_DECODE_SVC_SPATIAL_LAYER,\n                         decode_to_layer_before_sync_);\n    } else {\n      if (decode_to_layer_after_sync_ >= 0)\n        decoder->Control(VP9_DECODE_SVC_SPATIAL_LAYER,\n                         decode_to_layer_after_sync_);\n    }\n  }\n#endif\n\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    // Keep track of number of non-reference frames, needed for mismatch check.\n    // Non-reference frames are top spatial and temporal layer frames,\n    // for TL > 0.\n    if (temporal_layer_id_ == number_temporal_layers_ - 1 &&\n        temporal_layer_id_ > 0 &&\n        pkt->data.frame.spatial_layer_encoded[number_spatial_layers_ - 1] &&\n        current_video_frame_ >= frame_to_sync_)\n      num_nonref_frames_++;\n\n    if (intra_only_test_ && current_video_frame_ == frame_to_sync_) {\n      // Intra-only frame is only generated for spatial layers > 1 and <= 3,\n      // among other conditions (see constraint in set_intra_only_frame(). If\n      // intra-only is no allowed then encoder will insert key frame instead.\n      const bool key_frame =\n          (pkt->data.frame.flags & VPX_FRAME_IS_KEY) ? true : false;\n      if (number_spatial_layers_ == 1 || number_spatial_layers_ > 3)\n        ASSERT_TRUE(key_frame);\n      else\n        ASSERT_FALSE(key_frame);\n    }\n  }\n\n  virtual void MismatchHook(const vpx_image_t * /*img1*/,\n                            const vpx_image_t * /*img2*/) {\n    if (current_video_frame_ >= frame_to_sync_) ++mismatch_nframes_;\n  }\n\n  unsigned int GetMismatchFrames() const { return mismatch_nframes_; }\n  unsigned int GetNonRefFrames() const { return num_nonref_frames_; }\n\n  unsigned int current_video_frame_;\n  unsigned int frame_to_start_decode_;\n  unsigned int frame_to_sync_;\n  int inter_layer_pred_mode_;\n  int decode_to_layer_before_sync_;\n  int decode_to_layer_after_sync_;\n  int denoiser_on_;\n  bool intra_only_test_;\n  vpx_svc_spatial_layer_sync_t svc_layer_sync_;\n\n private:\n  virtual void SetConfig(const int num_temporal_layer) {\n    cfg_.rc_buf_initial_sz = 500;\n    cfg_.rc_buf_optimal_sz = 500;\n    cfg_.rc_buf_sz = 1000;\n    cfg_.rc_min_quantizer = 0;\n    cfg_.rc_max_quantizer = 63;\n    cfg_.rc_end_usage = VPX_CBR;\n    cfg_.g_lag_in_frames = 0;\n    cfg_.g_error_resilient = 1;\n    cfg_.g_threads = 1;\n    cfg_.rc_dropframe_thresh = 30;\n    cfg_.kf_max_dist = 9999;\n    if (num_temporal_layer == 3) {\n      cfg_.ts_rate_decimator[0] = 4;\n      cfg_.ts_rate_decimator[1] = 2;\n      cfg_.ts_rate_decimator[2] = 1;\n      cfg_.temporal_layering_mode = 3;\n    } else if (num_temporal_layer == 2) {\n      cfg_.ts_rate_decimator[0] = 2;\n      cfg_.ts_rate_decimator[1] = 1;\n      cfg_.temporal_layering_mode = 2;\n    } else if (num_temporal_layer == 1) {\n      cfg_.ts_rate_decimator[0] = 1;\n      cfg_.temporal_layering_mode = 1;\n    }\n  }\n\n  unsigned int mismatch_nframes_;\n  unsigned int num_nonref_frames_;\n}",
          "class_name": "SyncFrameOnePassCbrSvc",
          "class_pos": [
            [
              115,
              0
            ],
            [
              248,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"./vpx_config.h\"\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/svc_test.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/y4m_video_source.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_codec.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"vpx_ports/bitops.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  // Inter-layer prediction is on on all frames.\n  INTER_LAYER_PRED_ON,\n  // Inter-layer prediction is off on all frames.\n  INTER_LAYER_PRED_OFF,\n  // Inter-layer prediction is off on non-key frames and non-sync frames.\n  INTER_LAYER_PRED_OFF_NONKEY,\n  // Inter-layer prediction is on on all frames, but constrained such\n  // that any layer S (> 0) can only predict from previous spatial\n  // layer S-1, from the same superframe.\n  INTER_LAYER_PRED_ON_CONSTRAINED\n} INTER_LAYER_PRED;",
          {
            "INTER_LAYER_PRED_ON": "",
            "INTER_LAYER_PRED_OFF": "",
            "INTER_LAYER_PRED_OFF_NONKEY": "",
            "INTER_LAYER_PRED_ON_CONSTRAINED": ""
          },
          "INTER_LAYER_PRED",
          [
            23,
            0
          ],
          [
            34,
            19
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/avg_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "AverageTestBase(int width, int height)\n      : width_(width), height_(height), source_data_(NULL), source_stride_(0),\n        bit_depth_(8) {}",
          "fn_code_pos": [
            [
              36,
              2
            ],
            [
              38,
              24
            ]
          ],
          "class_code": "61eb48442730955d73686c475ae9724730cd52d3ec7059252eb5a2e327ae7998",
          "class_node_pos": [
            [
              34,
              0
            ],
            [
              95,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "AverageTestBase",
            "parameters": {
              "width": "int",
              "height": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void TearDown() {\n    vpx_free(source_data_);\n    source_data_ = NULL;\n    libvpx_test::ClearSystemState();\n  }",
          "fn_code_pos": [
            [
              40,
              2
            ],
            [
              44,
              3
            ]
          ],
          "class_code": "61eb48442730955d73686c475ae9724730cd52d3ec7059252eb5a2e327ae7998",
          "class_node_pos": [
            [
              34,
              0
            ],
            [
              95,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    source_data_ = reinterpret_cast<Pixel *>(\n        vpx_memalign(kDataAlignment, kDataBlockSize * sizeof(source_data_[0])));\n    ASSERT_TRUE(source_data_ != NULL);\n    source_stride_ = (width_ + 31) & ~31;\n    bit_depth_ = 8;\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n  }",
          "fn_code_pos": [
            [
              51,
              2
            ],
            [
              58,
              3
            ]
          ],
          "class_code": "61eb48442730955d73686c475ae9724730cd52d3ec7059252eb5a2e327ae7998",
          "class_node_pos": [
            [
              34,
              0
            ],
            [
              95,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static unsigned int ReferenceAverage8x8(const Pixel *source, int pitch) {\n    unsigned int average = 0;\n    for (int h = 0; h < 8; ++h) {\n      for (int w = 0; w < 8; ++w) average += source[h * pitch + w];\n    }\n    return ((average + 32) >> 6);\n  }",
          "fn_code_pos": [
            [
              61,
              2
            ],
            [
              67,
              3
            ]
          ],
          "class_code": "61eb48442730955d73686c475ae9724730cd52d3ec7059252eb5a2e327ae7998",
          "class_node_pos": [
            [
              34,
              0
            ],
            [
              95,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ReferenceAverage8x8",
            "parameters": {
              "source": "Pixel",
              "pitch": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static unsigned int ReferenceAverage4x4(const Pixel *source, int pitch) {\n    unsigned int average = 0;\n    for (int h = 0; h < 4; ++h) {\n      for (int w = 0; w < 4; ++w) average += source[h * pitch + w];\n    }\n    return ((average + 8) >> 4);\n  }",
          "fn_code_pos": [
            [
              69,
              2
            ],
            [
              75,
              3
            ]
          ],
          "class_code": "61eb48442730955d73686c475ae9724730cd52d3ec7059252eb5a2e327ae7998",
          "class_node_pos": [
            [
              34,
              0
            ],
            [
              95,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ReferenceAverage4x4",
            "parameters": {
              "source": "Pixel",
              "pitch": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void FillConstant(Pixel fill_constant) {\n    for (int i = 0; i < width_ * height_; ++i) {\n      source_data_[i] = fill_constant;\n    }\n  }",
          "fn_code_pos": [
            [
              77,
              2
            ],
            [
              81,
              3
            ]
          ],
          "class_code": "61eb48442730955d73686c475ae9724730cd52d3ec7059252eb5a2e327ae7998",
          "class_node_pos": [
            [
              34,
              0
            ],
            [
              95,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillConstant",
            "parameters": {
              "fill_constant": "Pixel"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void FillRandom() {\n    for (int i = 0; i < width_ * height_; ++i) {\n      source_data_[i] = rnd_.Rand16() & ((1 << bit_depth_) - 1);\n    }\n  }",
          "fn_code_pos": [
            [
              83,
              2
            ],
            [
              87,
              3
            ]
          ],
          "class_code": "61eb48442730955d73686c475ae9724730cd52d3ec7059252eb5a2e327ae7998",
          "class_node_pos": [
            [
              34,
              0
            ],
            [
              95,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillRandom",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "AverageTest() : AverageTestBase(GET_PARAM(0), GET_PARAM(1)) {}",
          "fn_code_pos": [
            [
              103,
              2
            ],
            [
              103,
              64
            ]
          ],
          "class_code": "d72fd37b55743bd80b4de8fd73f72f6da0a350a8d08d9f1227a566626a119d5b",
          "class_node_pos": [
            [
              100,
              0
            ],
            [
              124,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "AverageTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void CheckAverages() {\n    const int block_size = GET_PARAM(3);\n    unsigned int expected = 0;\n    if (block_size == 8) {\n      expected =\n          ReferenceAverage8x8(source_data_ + GET_PARAM(2), source_stride_);\n    } else if (block_size == 4) {\n      expected =\n          ReferenceAverage4x4(source_data_ + GET_PARAM(2), source_stride_);\n    }\n\n    ASM_REGISTER_STATE_CHECK(\n        GET_PARAM(4)(source_data_ + GET_PARAM(2), source_stride_));\n    unsigned int actual =\n        GET_PARAM(4)(source_data_ + GET_PARAM(2), source_stride_);\n\n    EXPECT_EQ(expected, actual);\n  }",
          "fn_code_pos": [
            [
              106,
              2
            ],
            [
              123,
              3
            ]
          ],
          "class_code": "d72fd37b55743bd80b4de8fd73f72f6da0a350a8d08d9f1227a566626a119d5b",
          "class_node_pos": [
            [
              100,
              0
            ],
            [
              124,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckAverages",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "AverageTestHBD() : AverageTestBase(GET_PARAM(0), GET_PARAM(1)) {}",
          "fn_code_pos": [
            [
              130,
              2
            ],
            [
              130,
              67
            ]
          ],
          "class_code": "99c0d87c7c6c98e27a02fe44dbfafe5a8bb11c823daa73c6efe176ba5db35adb",
          "class_node_pos": [
            [
              127,
              0
            ],
            [
              151,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "AverageTestHBD",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void CheckAverages() {\n    const int block_size = GET_PARAM(3);\n    unsigned int expected = 0;\n    if (block_size == 8) {\n      expected =\n          ReferenceAverage8x8(source_data_ + GET_PARAM(2), source_stride_);\n    } else if (block_size == 4) {\n      expected =\n          ReferenceAverage4x4(source_data_ + GET_PARAM(2), source_stride_);\n    }\n\n    ASM_REGISTER_STATE_CHECK(GET_PARAM(4)(\n        CONVERT_TO_BYTEPTR(source_data_ + GET_PARAM(2)), source_stride_));\n    unsigned int actual = GET_PARAM(4)(\n        CONVERT_TO_BYTEPTR(source_data_ + GET_PARAM(2)), source_stride_);\n\n    EXPECT_EQ(expected, actual);\n  }",
          "fn_code_pos": [
            [
              133,
              2
            ],
            [
              150,
              3
            ]
          ],
          "class_code": "99c0d87c7c6c98e27a02fe44dbfafe5a8bb11c823daa73c6efe176ba5db35adb",
          "class_node_pos": [
            [
              127,
              0
            ],
            [
              151,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckAverages",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "IntProRowTest()\n      : AverageTestBase(16, GET_PARAM(0)), hbuf_asm_(NULL), hbuf_c_(NULL) {\n    asm_func_ = GET_PARAM(1);\n    c_func_ = GET_PARAM(2);\n  }",
          "fn_code_pos": [
            [
              162,
              2
            ],
            [
              166,
              3
            ]
          ],
          "class_code": "c18163d3986246f44dee51d28d70f56d4cc7c179c006471a0c08c72b91f71275",
          "class_node_pos": [
            [
              159,
              0
            ],
            [
              201,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "IntProRowTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    source_data_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kDataBlockSize * sizeof(source_data_[0])));\n    ASSERT_TRUE(source_data_ != NULL);\n\n    hbuf_asm_ = reinterpret_cast<int16_t *>(\n        vpx_memalign(kDataAlignment, sizeof(*hbuf_asm_) * 16));\n    hbuf_c_ = reinterpret_cast<int16_t *>(\n        vpx_memalign(kDataAlignment, sizeof(*hbuf_c_) * 16));\n  }",
          "fn_code_pos": [
            [
              169,
              2
            ],
            [
              178,
              3
            ]
          ],
          "class_code": "c18163d3986246f44dee51d28d70f56d4cc7c179c006471a0c08c72b91f71275",
          "class_node_pos": [
            [
              159,
              0
            ],
            [
              201,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() {\n    vpx_free(source_data_);\n    source_data_ = NULL;\n    vpx_free(hbuf_c_);\n    hbuf_c_ = NULL;\n    vpx_free(hbuf_asm_);\n    hbuf_asm_ = NULL;\n  }",
          "fn_code_pos": [
            [
              180,
              2
            ],
            [
              187,
              3
            ]
          ],
          "class_code": "c18163d3986246f44dee51d28d70f56d4cc7c179c006471a0c08c72b91f71275",
          "class_node_pos": [
            [
              159,
              0
            ],
            [
              201,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunComparison() {\n    ASM_REGISTER_STATE_CHECK(c_func_(hbuf_c_, source_data_, 0, height_));\n    ASM_REGISTER_STATE_CHECK(asm_func_(hbuf_asm_, source_data_, 0, height_));\n    EXPECT_EQ(0, memcmp(hbuf_c_, hbuf_asm_, sizeof(*hbuf_c_) * 16))\n        << \"Output mismatch\";\n  }",
          "fn_code_pos": [
            [
              189,
              2
            ],
            [
              194,
              3
            ]
          ],
          "class_code": "c18163d3986246f44dee51d28d70f56d4cc7c179c006471a0c08c72b91f71275",
          "class_node_pos": [
            [
              159,
              0
            ],
            [
              201,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunComparison",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "IntProColTest() : AverageTestBase(GET_PARAM(0), 1), sum_asm_(0), sum_c_(0) {\n    asm_func_ = GET_PARAM(1);\n    c_func_ = GET_PARAM(2);\n  }",
          "fn_code_pos": [
            [
              210,
              2
            ],
            [
              213,
              3
            ]
          ],
          "class_code": "56157a62a90f2a49d5f5762f86ff8c521fa74467beeec79ca72dd662181982d8",
          "class_node_pos": [
            [
              207,
              0
            ],
            [
              227,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "IntProColTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void RunComparison() {\n    ASM_REGISTER_STATE_CHECK(sum_c_ = c_func_(source_data_, width_));\n    ASM_REGISTER_STATE_CHECK(sum_asm_ = asm_func_(source_data_, width_));\n    EXPECT_EQ(sum_c_, sum_asm_) << \"Output mismatch\";\n  }",
          "fn_code_pos": [
            [
              216,
              2
            ],
            [
              220,
              3
            ]
          ],
          "class_code": "56157a62a90f2a49d5f5762f86ff8c521fa74467beeec79ca72dd662181982d8",
          "class_node_pos": [
            [
              207,
              0
            ],
            [
              227,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunComparison",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    satd_size_ = GET_PARAM(0);\n    satd_func_ = GET_PARAM(1);\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n    src_ = reinterpret_cast<tran_low_t *>(\n        vpx_memalign(16, sizeof(*src_) * satd_size_));\n    ASSERT_TRUE(src_ != NULL);\n  }",
          "fn_code_pos": [
            [
              235,
              2
            ],
            [
              242,
              3
            ]
          ],
          "class_code": "fda35c2ebd04d9fb0cc7824ba169a937f30ef481da0e8e397a10e6d80c091244",
          "class_node_pos": [
            [
              232,
              0
            ],
            [
              269,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() {\n    libvpx_test::ClearSystemState();\n    vpx_free(src_);\n  }",
          "fn_code_pos": [
            [
              244,
              2
            ],
            [
              247,
              3
            ]
          ],
          "class_code": "fda35c2ebd04d9fb0cc7824ba169a937f30ef481da0e8e397a10e6d80c091244",
          "class_node_pos": [
            [
              232,
              0
            ],
            [
              269,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void FillConstant(const tran_low_t val) {\n    for (int i = 0; i < satd_size_; ++i) src_[i] = val;\n  }",
          "fn_code_pos": [
            [
              249,
              2
            ],
            [
              251,
              3
            ]
          ],
          "class_code": "fda35c2ebd04d9fb0cc7824ba169a937f30ef481da0e8e397a10e6d80c091244",
          "class_node_pos": [
            [
              232,
              0
            ],
            [
              269,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillConstant",
            "parameters": {
              "val": "tran_low_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FillRandom() = 0;",
          "fn_code_pos": [
            [
              253,
              2
            ],
            [
              253,
              32
            ]
          ],
          "class_code": "fda35c2ebd04d9fb0cc7824ba169a937f30ef481da0e8e397a10e6d80c091244",
          "class_node_pos": [
            [
              232,
              0
            ],
            [
              269,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillRandom",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Check(const int expected) {\n    int total;\n    ASM_REGISTER_STATE_CHECK(total = satd_func_(src_, satd_size_));\n    EXPECT_EQ(expected, total);\n  }",
          "fn_code_pos": [
            [
              255,
              2
            ],
            [
              259,
              3
            ]
          ],
          "class_code": "fda35c2ebd04d9fb0cc7824ba169a937f30ef481da0e8e397a10e6d80c091244",
          "class_node_pos": [
            [
              232,
              0
            ],
            [
              269,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Check",
            "parameters": {
              "expected": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "tran_low_t *GetCoeff() const { return src_; }",
          "fn_code_pos": [
            [
              261,
              2
            ],
            [
              261,
              47
            ]
          ],
          "class_code": "fda35c2ebd04d9fb0cc7824ba169a937f30ef481da0e8e397a10e6d80c091244",
          "class_node_pos": [
            [
              232,
              0
            ],
            [
              269,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetCoeff",
            "parameters": {},
            "return_type": "tran_low_t"
          }
        },
        {
          "fn_code": "virtual void FillRandom() {\n    for (int i = 0; i < satd_size_; ++i) {\n      const int16_t tmp = rnd_.Rand16Signed();\n      src_[i] = (tran_low_t)tmp;\n    }\n  }",
          "fn_code_pos": [
            [
              273,
              2
            ],
            [
              278,
              3
            ]
          ],
          "class_code": "6ea48944a2c9df2d728936986286a2f7ea4a4f42811a2d0512a112aafbbd40c8",
          "class_node_pos": [
            [
              271,
              0
            ],
            [
              279,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillRandom",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    txfm_size_ = GET_PARAM(0);\n    block_error_func_ = GET_PARAM(1);\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n    coeff_ = reinterpret_cast<tran_low_t *>(\n        vpx_memalign(16, sizeof(*coeff_) * txfm_size_));\n    dqcoeff_ = reinterpret_cast<tran_low_t *>(\n        vpx_memalign(16, sizeof(*dqcoeff_) * txfm_size_));\n    ASSERT_TRUE(coeff_ != NULL);\n    ASSERT_TRUE(dqcoeff_ != NULL);\n  }",
          "fn_code_pos": [
            [
              289,
              2
            ],
            [
              299,
              3
            ]
          ],
          "class_code": "74e3420cf328d2d8b20399c23ea77af5d7b52dec8de67956728f68e71a41b1f1",
          "class_node_pos": [
            [
              285,
              0
            ],
            [
              338,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() {\n    libvpx_test::ClearSystemState();\n    vpx_free(coeff_);\n    vpx_free(dqcoeff_);\n  }",
          "fn_code_pos": [
            [
              301,
              2
            ],
            [
              305,
              3
            ]
          ],
          "class_code": "74e3420cf328d2d8b20399c23ea77af5d7b52dec8de67956728f68e71a41b1f1",
          "class_node_pos": [
            [
              285,
              0
            ],
            [
              338,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void FillConstant(const tran_low_t coeff_val, const tran_low_t dqcoeff_val) {\n    for (int i = 0; i < txfm_size_; ++i) coeff_[i] = coeff_val;\n    for (int i = 0; i < txfm_size_; ++i) dqcoeff_[i] = dqcoeff_val;\n  }",
          "fn_code_pos": [
            [
              307,
              2
            ],
            [
              310,
              3
            ]
          ],
          "class_code": "74e3420cf328d2d8b20399c23ea77af5d7b52dec8de67956728f68e71a41b1f1",
          "class_node_pos": [
            [
              285,
              0
            ],
            [
              338,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillConstant",
            "parameters": {
              "coeff_val": "tran_low_t",
              "dqcoeff_val": "tran_low_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void FillRandom() {\n    // Just two fixed seeds\n    rnd_.Reset(0xb0b9);\n    for (int i = 0; i < txfm_size_; ++i) coeff_[i] = rnd_.Rand16() >> 1;\n    rnd_.Reset(0xb0c8);\n    for (int i = 0; i < txfm_size_; ++i) dqcoeff_[i] = rnd_.Rand16() >> 1;\n  }",
          "fn_code_pos": [
            [
              312,
              2
            ],
            [
              318,
              3
            ]
          ],
          "class_code": "74e3420cf328d2d8b20399c23ea77af5d7b52dec8de67956728f68e71a41b1f1",
          "class_node_pos": [
            [
              285,
              0
            ],
            [
              338,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillRandom",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Check(const int64_t expected) {\n    int64_t total;\n    ASM_REGISTER_STATE_CHECK(\n        total = block_error_func_(coeff_, dqcoeff_, txfm_size_));\n    EXPECT_EQ(expected, total);\n  }",
          "fn_code_pos": [
            [
              320,
              2
            ],
            [
              325,
              3
            ]
          ],
          "class_code": "74e3420cf328d2d8b20399c23ea77af5d7b52dec8de67956728f68e71a41b1f1",
          "class_node_pos": [
            [
              285,
              0
            ],
            [
              338,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Check",
            "parameters": {
              "expected": "int64_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "tran_low_t *GetCoeff() const { return coeff_; }",
          "fn_code_pos": [
            [
              327,
              2
            ],
            [
              327,
              49
            ]
          ],
          "class_code": "74e3420cf328d2d8b20399c23ea77af5d7b52dec8de67956728f68e71a41b1f1",
          "class_node_pos": [
            [
              285,
              0
            ],
            [
              338,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetCoeff",
            "parameters": {},
            "return_type": "tran_low_t"
          }
        },
        {
          "fn_code": "tran_low_t *GetDQCoeff() const { return dqcoeff_; }",
          "fn_code_pos": [
            [
              329,
              2
            ],
            [
              329,
              53
            ]
          ],
          "class_code": "74e3420cf328d2d8b20399c23ea77af5d7b52dec8de67956728f68e71a41b1f1",
          "class_node_pos": [
            [
              285,
              0
            ],
            [
              338,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetDQCoeff",
            "parameters": {},
            "return_type": "tran_low_t"
          }
        },
        {
          "fn_code": "TEST_P(AverageTest, MinValue) {\n  FillConstant(0);\n  CheckAverages();\n}",
          "fn_code_pos": [
            [
              340,
              0
            ],
            [
              343,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(AverageTest, MaxValue) {\n  FillConstant(255);\n  CheckAverages();\n}",
          "fn_code_pos": [
            [
              345,
              0
            ],
            [
              348,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(AverageTest, Random) {\n  // The reference frame, but not the source frame, may be unaligned for\n  // certain types of searches.\n  for (int i = 0; i < 1000; i++) {\n    FillRandom();\n    CheckAverages();\n  }\n}",
          "fn_code_pos": [
            [
              350,
              0
            ],
            [
              357,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(AverageTestHBD, MinValue) {\n  FillConstant(0);\n  CheckAverages();\n}",
          "fn_code_pos": [
            [
              359,
              0
            ],
            [
              362,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(AverageTestHBD, MaxValue) {\n  FillConstant((1 << VPX_BITS_12) - 1);\n  CheckAverages();\n}",
          "fn_code_pos": [
            [
              364,
              0
            ],
            [
              367,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(AverageTestHBD, Random) {\n  bit_depth_ = VPX_BITS_12;\n  // The reference frame, but not the source frame, may be unaligned for\n  // certain types of searches.\n  for (int i = 0; i < 1000; i++) {\n    FillRandom();\n    CheckAverages();\n  }\n}",
          "fn_code_pos": [
            [
              369,
              0
            ],
            [
              377,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(IntProRowTest, MinValue) {\n  FillConstant(0);\n  RunComparison();\n}",
          "fn_code_pos": [
            [
              380,
              0
            ],
            [
              383,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(IntProRowTest, MaxValue) {\n  FillConstant(255);\n  RunComparison();\n}",
          "fn_code_pos": [
            [
              385,
              0
            ],
            [
              388,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(IntProRowTest, Random) {\n  FillRandom();\n  RunComparison();\n}",
          "fn_code_pos": [
            [
              390,
              0
            ],
            [
              393,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(IntProColTest, MinValue) {\n  FillConstant(0);\n  RunComparison();\n}",
          "fn_code_pos": [
            [
              395,
              0
            ],
            [
              398,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(IntProColTest, MaxValue) {\n  FillConstant(255);\n  RunComparison();\n}",
          "fn_code_pos": [
            [
              400,
              0
            ],
            [
              403,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(IntProColTest, Random) {\n  FillRandom();\n  RunComparison();\n}",
          "fn_code_pos": [
            [
              405,
              0
            ],
            [
              408,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SatdLowbdTest, MinValue) {\n  const int kMin = -32640;\n  const int expected = -kMin * satd_size_;\n  FillConstant(kMin);\n  Check(expected);\n}",
          "fn_code_pos": [
            [
              410,
              0
            ],
            [
              415,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SatdLowbdTest, MaxValue) {\n  const int kMax = 32640;\n  const int expected = kMax * satd_size_;\n  FillConstant(kMax);\n  Check(expected);\n}",
          "fn_code_pos": [
            [
              417,
              0
            ],
            [
              422,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SatdLowbdTest, Random) {\n  int expected;\n  switch (satd_size_) {\n    case 16: expected = 263252; break;\n    case 64: expected = 1105420; break;\n    case 256: expected = 4252250; break;\n    case 1024: expected = 16876840; break;\n    default:\n      FAIL() << \"Invalid satd size (\" << satd_size_\n             << \") valid: 16/64/256/1024\";\n  }\n  FillRandom();\n  Check(expected);\n}",
          "fn_code_pos": [
            [
              424,
              0
            ],
            [
              437,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SatdLowbdTest, DISABLED_Speed) {\n  const int kCountSpeedTestBlock = 20000;\n  vpx_usec_timer timer;\n  const int blocksize = GET_PARAM(0);\n  FillRandom();\n  tran_low_t *coeff = GetCoeff();\n\n  vpx_usec_timer_start(&timer);\n  for (int i = 0; i < kCountSpeedTestBlock; ++i) {\n    GET_PARAM(1)(coeff, blocksize);\n  }\n  vpx_usec_timer_mark(&timer);\n  const int elapsed_time = static_cast<int>(vpx_usec_timer_elapsed(&timer));\n  printf(\"blocksize: %4d time: %4d us\\n\", blocksize, elapsed_time);\n}",
          "fn_code_pos": [
            [
              439,
              0
            ],
            [
              453,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void FillRandom() {\n    for (int i = 0; i < satd_size_; ++i) {\n      src_[i] = rnd_.Rand20Signed();\n    }\n  }",
          "fn_code_pos": [
            [
              458,
              2
            ],
            [
              462,
              3
            ]
          ],
          "class_code": "77470ab9d05ff46566a453602a4d62021dd3269f3a1c18122796d06d483a823f",
          "class_node_pos": [
            [
              456,
              0
            ],
            [
              463,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillRandom",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(SatdHighbdTest, MinValue) {\n  const int kMin = -524280;\n  const int expected = -kMin * satd_size_;\n  FillConstant(kMin);\n  Check(expected);\n}",
          "fn_code_pos": [
            [
              465,
              0
            ],
            [
              470,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SatdHighbdTest, MaxValue) {\n  const int kMax = 524280;\n  const int expected = kMax * satd_size_;\n  FillConstant(kMax);\n  Check(expected);\n}",
          "fn_code_pos": [
            [
              472,
              0
            ],
            [
              477,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SatdHighbdTest, Random) {\n  int expected;\n  switch (satd_size_) {\n    case 16: expected = 5249712; break;\n    case 64: expected = 18362120; break;\n    case 256: expected = 66100520; break;\n    case 1024: expected = 266094734; break;\n    default:\n      FAIL() << \"Invalid satd size (\" << satd_size_\n             << \") valid: 16/64/256/1024\";\n  }\n  FillRandom();\n  Check(expected);\n}",
          "fn_code_pos": [
            [
              479,
              0
            ],
            [
              492,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SatdHighbdTest, DISABLED_Speed) {\n  const int kCountSpeedTestBlock = 20000;\n  vpx_usec_timer timer;\n  const int blocksize = GET_PARAM(0);\n  FillRandom();\n  tran_low_t *coeff = GetCoeff();\n\n  vpx_usec_timer_start(&timer);\n  for (int i = 0; i < kCountSpeedTestBlock; ++i) {\n    GET_PARAM(1)(coeff, blocksize);\n  }\n  vpx_usec_timer_mark(&timer);\n  const int elapsed_time = static_cast<int>(vpx_usec_timer_elapsed(&timer));\n  printf(\"blocksize: %4d time: %4d us\\n\", blocksize, elapsed_time);\n}",
          "fn_code_pos": [
            [
              494,
              0
            ],
            [
              508,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(BlockErrorTestFP, MinValue) {\n  const int64_t kMin = -32640;\n  const int64_t expected = kMin * kMin * txfm_size_;\n  FillConstant(kMin, 0);\n  Check(expected);\n}",
          "fn_code_pos": [
            [
              511,
              0
            ],
            [
              516,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(BlockErrorTestFP, MaxValue) {\n  const int64_t kMax = 32640;\n  const int64_t expected = kMax * kMax * txfm_size_;\n  FillConstant(kMax, 0);\n  Check(expected);\n}",
          "fn_code_pos": [
            [
              518,
              0
            ],
            [
              523,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(BlockErrorTestFP, Random) {\n  int64_t expected;\n  switch (txfm_size_) {\n    case 16: expected = 2051681432; break;\n    case 64: expected = 11075114379; break;\n    case 256: expected = 44386271116; break;\n    case 1024: expected = 184774996089; break;\n    default:\n      FAIL() << \"Invalid satd size (\" << txfm_size_\n             << \") valid: 16/64/256/1024\";\n  }\n  FillRandom();\n  Check(expected);\n}",
          "fn_code_pos": [
            [
              525,
              0
            ],
            [
              538,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(BlockErrorTestFP, DISABLED_Speed) {\n  const int kCountSpeedTestBlock = 20000;\n  vpx_usec_timer timer;\n  const int blocksize = GET_PARAM(0);\n  FillRandom();\n  tran_low_t *coeff = GetCoeff();\n  tran_low_t *dqcoeff = GetDQCoeff();\n\n  vpx_usec_timer_start(&timer);\n  for (int i = 0; i < kCountSpeedTestBlock; ++i) {\n    GET_PARAM(1)(coeff, dqcoeff, blocksize);\n  }\n  vpx_usec_timer_mark(&timer);\n  const int elapsed_time = static_cast<int>(vpx_usec_timer_elapsed(&timer));\n  printf(\"blocksize: %4d time: %4d us\\n\", blocksize, elapsed_time);\n}",
          "fn_code_pos": [
            [
              540,
              0
            ],
            [
              555,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*AverageFunction)(const uint8_t *s, int pitch)",
          "fn_dec_pos": [
            [
              96,
              21
            ],
            [
              96,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "s": "uint8_t",
              "pitch": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*IntProRowFunc)(int16_t hbuf[16], uint8_t const *ref,\n                              const int ref_stride, const int height)",
          "fn_dec_pos": [
            [
              154,
              13
            ],
            [
              155,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "hbuf": "int16_t",
              "ref": "uint8_t",
              "ref_stride": "int",
              "height": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*IntProColFunc)(uint8_t const *ref, const int width)",
          "fn_dec_pos": [
            [
              203,
              16
            ],
            [
              203,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ref": "uint8_t",
              "width": "int"
            },
            "return_type": "int16_t"
          }
        },
        {
          "fn_code": "(*SatdFunc)(const tran_low_t *coeffs, int length)",
          "fn_dec_pos": [
            [
              229,
              12
            ],
            [
              229,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "coeffs": "tran_low_t",
              "length": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "GetCoeff() const",
          "fn_dec_pos": [
            [
              261,
              14
            ],
            [
              261,
              30
            ]
          ],
          "class_code": "fda35c2ebd04d9fb0cc7824ba169a937f30ef481da0e8e397a10e6d80c091244",
          "class_node_pos": [
            [
              232,
              0
            ],
            [
              269,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetCoeff",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "(*BlockErrorFunc)(const tran_low_t *coeff,\n                                  const tran_low_t *dqcoeff, int block_size)",
          "fn_dec_pos": [
            [
              281,
              16
            ],
            [
              282,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "coeff": "tran_low_t",
              "dqcoeff": "tran_low_t",
              "block_size": "int"
            },
            "return_type": "int64_t"
          }
        },
        {
          "fn_code": "GetCoeff() const",
          "fn_dec_pos": [
            [
              327,
              14
            ],
            [
              327,
              30
            ]
          ],
          "class_code": "74e3420cf328d2d8b20399c23ea77af5d7b52dec8de67956728f68e71a41b1f1",
          "class_node_pos": [
            [
              285,
              0
            ],
            [
              338,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetCoeff",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "GetDQCoeff() const",
          "fn_dec_pos": [
            [
              329,
              14
            ],
            [
              329,
              32
            ]
          ],
          "class_code": "74e3420cf328d2d8b20399c23ea77af5d7b52dec8de67956728f68e71a41b1f1",
          "class_node_pos": [
            [
              285,
              0
            ],
            [
              338,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetDQCoeff",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "bc0eea9c19850f22c2d0c538e247bd091e52bba363179d869ecb12ef7e11516a": {
          "class_code": "template <typename Pixel>\nclass AverageTestBase : public ::testing::Test {\n public:\n  AverageTestBase(int width, int height)\n      : width_(width), height_(height), source_data_(NULL), source_stride_(0),\n        bit_depth_(8) {}\n\n  virtual void TearDown() {\n    vpx_free(source_data_);\n    source_data_ = NULL;\n    libvpx_test::ClearSystemState();\n  }\n\n protected:\n  // Handle blocks up to 4 blocks 64x64 with stride up to 128\n  static const int kDataAlignment = 16;\n  static const int kDataBlockSize = 64 * 128;\n\n  virtual void SetUp() {\n    source_data_ = reinterpret_cast<Pixel *>(\n        vpx_memalign(kDataAlignment, kDataBlockSize * sizeof(source_data_[0])));\n    ASSERT_TRUE(source_data_ != NULL);\n    source_stride_ = (width_ + 31) & ~31;\n    bit_depth_ = 8;\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n  }\n\n  // Sum Pixels\n  static unsigned int ReferenceAverage8x8(const Pixel *source, int pitch) {\n    unsigned int average = 0;\n    for (int h = 0; h < 8; ++h) {\n      for (int w = 0; w < 8; ++w) average += source[h * pitch + w];\n    }\n    return ((average + 32) >> 6);\n  }\n\n  static unsigned int ReferenceAverage4x4(const Pixel *source, int pitch) {\n    unsigned int average = 0;\n    for (int h = 0; h < 4; ++h) {\n      for (int w = 0; w < 4; ++w) average += source[h * pitch + w];\n    }\n    return ((average + 8) >> 4);\n  }\n\n  void FillConstant(Pixel fill_constant) {\n    for (int i = 0; i < width_ * height_; ++i) {\n      source_data_[i] = fill_constant;\n    }\n  }\n\n  void FillRandom() {\n    for (int i = 0; i < width_ * height_; ++i) {\n      source_data_[i] = rnd_.Rand16() & ((1 << bit_depth_) - 1);\n    }\n  }\n\n  int width_, height_;\n  Pixel *source_data_;\n  int source_stride_;\n  int bit_depth_;\n\n  ACMRandom rnd_;\n};",
          "class_name": "AverageTestBase",
          "class_pos": [
            [
              33,
              0
            ],
            [
              95,
              2
            ]
          ]
        },
        "d72fd37b55743bd80b4de8fd73f72f6da0a350a8d08d9f1227a566626a119d5b": {
          "class_code": "class AverageTest : public AverageTestBase<uint8_t>,\n                    public ::testing::WithParamInterface<AvgFunc> {\n public:\n  AverageTest() : AverageTestBase(GET_PARAM(0), GET_PARAM(1)) {}\n\n protected:\n  void CheckAverages() {\n    const int block_size = GET_PARAM(3);\n    unsigned int expected = 0;\n    if (block_size == 8) {\n      expected =\n          ReferenceAverage8x8(source_data_ + GET_PARAM(2), source_stride_);\n    } else if (block_size == 4) {\n      expected =\n          ReferenceAverage4x4(source_data_ + GET_PARAM(2), source_stride_);\n    }\n\n    ASM_REGISTER_STATE_CHECK(\n        GET_PARAM(4)(source_data_ + GET_PARAM(2), source_stride_));\n    unsigned int actual =\n        GET_PARAM(4)(source_data_ + GET_PARAM(2), source_stride_);\n\n    EXPECT_EQ(expected, actual);\n  }\n}",
          "class_name": "AverageTest",
          "class_pos": [
            [
              100,
              0
            ],
            [
              124,
              1
            ]
          ]
        },
        "99c0d87c7c6c98e27a02fe44dbfafe5a8bb11c823daa73c6efe176ba5db35adb": {
          "class_code": "class AverageTestHBD : public AverageTestBase<uint16_t>,\n                       public ::testing::WithParamInterface<AvgFunc> {\n public:\n  AverageTestHBD() : AverageTestBase(GET_PARAM(0), GET_PARAM(1)) {}\n\n protected:\n  void CheckAverages() {\n    const int block_size = GET_PARAM(3);\n    unsigned int expected = 0;\n    if (block_size == 8) {\n      expected =\n          ReferenceAverage8x8(source_data_ + GET_PARAM(2), source_stride_);\n    } else if (block_size == 4) {\n      expected =\n          ReferenceAverage4x4(source_data_ + GET_PARAM(2), source_stride_);\n    }\n\n    ASM_REGISTER_STATE_CHECK(GET_PARAM(4)(\n        CONVERT_TO_BYTEPTR(source_data_ + GET_PARAM(2)), source_stride_));\n    unsigned int actual = GET_PARAM(4)(\n        CONVERT_TO_BYTEPTR(source_data_ + GET_PARAM(2)), source_stride_);\n\n    EXPECT_EQ(expected, actual);\n  }\n}",
          "class_name": "AverageTestHBD",
          "class_pos": [
            [
              127,
              0
            ],
            [
              151,
              1
            ]
          ]
        },
        "c18163d3986246f44dee51d28d70f56d4cc7c179c006471a0c08c72b91f71275": {
          "class_code": "class IntProRowTest : public AverageTestBase<uint8_t>,\n                      public ::testing::WithParamInterface<IntProRowParam> {\n public:\n  IntProRowTest()\n      : AverageTestBase(16, GET_PARAM(0)), hbuf_asm_(NULL), hbuf_c_(NULL) {\n    asm_func_ = GET_PARAM(1);\n    c_func_ = GET_PARAM(2);\n  }\n\n protected:\n  virtual void SetUp() {\n    source_data_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kDataBlockSize * sizeof(source_data_[0])));\n    ASSERT_TRUE(source_data_ != NULL);\n\n    hbuf_asm_ = reinterpret_cast<int16_t *>(\n        vpx_memalign(kDataAlignment, sizeof(*hbuf_asm_) * 16));\n    hbuf_c_ = reinterpret_cast<int16_t *>(\n        vpx_memalign(kDataAlignment, sizeof(*hbuf_c_) * 16));\n  }\n\n  virtual void TearDown() {\n    vpx_free(source_data_);\n    source_data_ = NULL;\n    vpx_free(hbuf_c_);\n    hbuf_c_ = NULL;\n    vpx_free(hbuf_asm_);\n    hbuf_asm_ = NULL;\n  }\n\n  void RunComparison() {\n    ASM_REGISTER_STATE_CHECK(c_func_(hbuf_c_, source_data_, 0, height_));\n    ASM_REGISTER_STATE_CHECK(asm_func_(hbuf_asm_, source_data_, 0, height_));\n    EXPECT_EQ(0, memcmp(hbuf_c_, hbuf_asm_, sizeof(*hbuf_c_) * 16))\n        << \"Output mismatch\";\n  }\n\n private:\n  IntProRowFunc asm_func_;\n  IntProRowFunc c_func_;\n  int16_t *hbuf_asm_;\n  int16_t *hbuf_c_;\n}",
          "class_name": "IntProRowTest",
          "class_pos": [
            [
              159,
              0
            ],
            [
              201,
              1
            ]
          ]
        },
        "56157a62a90f2a49d5f5762f86ff8c521fa74467beeec79ca72dd662181982d8": {
          "class_code": "class IntProColTest : public AverageTestBase<uint8_t>,\n                      public ::testing::WithParamInterface<IntProColParam> {\n public:\n  IntProColTest() : AverageTestBase(GET_PARAM(0), 1), sum_asm_(0), sum_c_(0) {\n    asm_func_ = GET_PARAM(1);\n    c_func_ = GET_PARAM(2);\n  }\n\n protected:\n  void RunComparison() {\n    ASM_REGISTER_STATE_CHECK(sum_c_ = c_func_(source_data_, width_));\n    ASM_REGISTER_STATE_CHECK(sum_asm_ = asm_func_(source_data_, width_));\n    EXPECT_EQ(sum_c_, sum_asm_) << \"Output mismatch\";\n  }\n\n private:\n  IntProColFunc asm_func_;\n  IntProColFunc c_func_;\n  int16_t sum_asm_;\n  int16_t sum_c_;\n}",
          "class_name": "IntProColTest",
          "class_pos": [
            [
              207,
              0
            ],
            [
              227,
              1
            ]
          ]
        },
        "fda35c2ebd04d9fb0cc7824ba169a937f30ef481da0e8e397a10e6d80c091244": {
          "class_code": "class SatdTest : public ::testing::Test,\n                 public ::testing::WithParamInterface<SatdTestParam> {\n protected:\n  virtual void SetUp() {\n    satd_size_ = GET_PARAM(0);\n    satd_func_ = GET_PARAM(1);\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n    src_ = reinterpret_cast<tran_low_t *>(\n        vpx_memalign(16, sizeof(*src_) * satd_size_));\n    ASSERT_TRUE(src_ != NULL);\n  }\n\n  virtual void TearDown() {\n    libvpx_test::ClearSystemState();\n    vpx_free(src_);\n  }\n\n  void FillConstant(const tran_low_t val) {\n    for (int i = 0; i < satd_size_; ++i) src_[i] = val;\n  }\n\n  virtual void FillRandom() = 0;\n\n  void Check(const int expected) {\n    int total;\n    ASM_REGISTER_STATE_CHECK(total = satd_func_(src_, satd_size_));\n    EXPECT_EQ(expected, total);\n  }\n\n  tran_low_t *GetCoeff() const { return src_; }\n\n  int satd_size_;\n  ACMRandom rnd_;\n  tran_low_t *src_;\n\n private:\n  SatdFunc satd_func_;\n}",
          "class_name": "SatdTest",
          "class_pos": [
            [
              232,
              0
            ],
            [
              269,
              1
            ]
          ]
        },
        "6ea48944a2c9df2d728936986286a2f7ea4a4f42811a2d0512a112aafbbd40c8": {
          "class_code": "class SatdLowbdTest : public SatdTest {\n protected:\n  virtual void FillRandom() {\n    for (int i = 0; i < satd_size_; ++i) {\n      const int16_t tmp = rnd_.Rand16Signed();\n      src_[i] = (tran_low_t)tmp;\n    }\n  }\n}",
          "class_name": "SatdLowbdTest",
          "class_pos": [
            [
              271,
              0
            ],
            [
              279,
              1
            ]
          ]
        },
        "74e3420cf328d2d8b20399c23ea77af5d7b52dec8de67956728f68e71a41b1f1": {
          "class_code": "class BlockErrorTestFP\n    : public ::testing::Test,\n      public ::testing::WithParamInterface<BlockErrorTestFPParam> {\n protected:\n  virtual void SetUp() {\n    txfm_size_ = GET_PARAM(0);\n    block_error_func_ = GET_PARAM(1);\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n    coeff_ = reinterpret_cast<tran_low_t *>(\n        vpx_memalign(16, sizeof(*coeff_) * txfm_size_));\n    dqcoeff_ = reinterpret_cast<tran_low_t *>(\n        vpx_memalign(16, sizeof(*dqcoeff_) * txfm_size_));\n    ASSERT_TRUE(coeff_ != NULL);\n    ASSERT_TRUE(dqcoeff_ != NULL);\n  }\n\n  virtual void TearDown() {\n    libvpx_test::ClearSystemState();\n    vpx_free(coeff_);\n    vpx_free(dqcoeff_);\n  }\n\n  void FillConstant(const tran_low_t coeff_val, const tran_low_t dqcoeff_val) {\n    for (int i = 0; i < txfm_size_; ++i) coeff_[i] = coeff_val;\n    for (int i = 0; i < txfm_size_; ++i) dqcoeff_[i] = dqcoeff_val;\n  }\n\n  void FillRandom() {\n    // Just two fixed seeds\n    rnd_.Reset(0xb0b9);\n    for (int i = 0; i < txfm_size_; ++i) coeff_[i] = rnd_.Rand16() >> 1;\n    rnd_.Reset(0xb0c8);\n    for (int i = 0; i < txfm_size_; ++i) dqcoeff_[i] = rnd_.Rand16() >> 1;\n  }\n\n  void Check(const int64_t expected) {\n    int64_t total;\n    ASM_REGISTER_STATE_CHECK(\n        total = block_error_func_(coeff_, dqcoeff_, txfm_size_));\n    EXPECT_EQ(expected, total);\n  }\n\n  tran_low_t *GetCoeff() const { return coeff_; }\n\n  tran_low_t *GetDQCoeff() const { return dqcoeff_; }\n\n  int txfm_size_;\n\n private:\n  tran_low_t *coeff_;\n  tran_low_t *dqcoeff_;\n  BlockErrorFunc block_error_func_;\n  ACMRandom rnd_;\n}",
          "class_name": "BlockErrorTestFP",
          "class_pos": [
            [
              285,
              0
            ],
            [
              338,
              1
            ]
          ]
        },
        "77470ab9d05ff46566a453602a4d62021dd3269f3a1c18122796d06d483a823f": {
          "class_code": "class SatdHighbdTest : public SatdTest {\n protected:\n  virtual void FillRandom() {\n    for (int i = 0; i < satd_size_; ++i) {\n      src_[i] = rnd_.Rand20Signed();\n    }\n  }\n}",
          "class_name": "SatdHighbdTest",
          "class_pos": [
            [
              456,
              0
            ],
            [
              463,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <limits.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./vp9_rtcd.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_codec.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"vpx_ports/vpx_timer.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp9_quantize_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "template <QuantizeFPFunc fn>\nvoid QuantFPWrapper(const tran_low_t *coeff, intptr_t count, int skip_block,\n                    const int16_t *zbin, const int16_t *round,\n                    const int16_t *quant, const int16_t *quant_shift,\n                    tran_low_t *qcoeff, tran_low_t *dqcoeff,\n                    const int16_t *dequant, uint16_t *eob, const int16_t *scan,\n                    const int16_t *iscan) {\n  (void)zbin;\n  (void)quant_shift;\n\n  fn(coeff, count, skip_block, round, quant, qcoeff, dqcoeff, dequant, eob,\n     scan, iscan);\n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              70,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VP9QuantizeBase(vpx_bit_depth_t bit_depth, int max_size, bool is_fp)\n      : bit_depth_(bit_depth), max_size_(max_size), is_fp_(is_fp),\n        coeff_(Buffer<tran_low_t>(max_size_, max_size_, 0, 16)),\n        qcoeff_(Buffer<tran_low_t>(max_size_, max_size_, 0, 32)),\n        dqcoeff_(Buffer<tran_low_t>(max_size_, max_size_, 0, 32)) {\n    max_value_ = (1 << bit_depth_) - 1;\n    zbin_ptr_ =\n        reinterpret_cast<int16_t *>(vpx_memalign(16, 8 * sizeof(*zbin_ptr_)));\n    round_fp_ptr_ = reinterpret_cast<int16_t *>(\n        vpx_memalign(16, 8 * sizeof(*round_fp_ptr_)));\n    quant_fp_ptr_ = reinterpret_cast<int16_t *>(\n        vpx_memalign(16, 8 * sizeof(*quant_fp_ptr_)));\n    round_ptr_ =\n        reinterpret_cast<int16_t *>(vpx_memalign(16, 8 * sizeof(*round_ptr_)));\n    quant_ptr_ =\n        reinterpret_cast<int16_t *>(vpx_memalign(16, 8 * sizeof(*quant_ptr_)));\n    quant_shift_ptr_ = reinterpret_cast<int16_t *>(\n        vpx_memalign(16, 8 * sizeof(*quant_shift_ptr_)));\n    dequant_ptr_ = reinterpret_cast<int16_t *>(\n        vpx_memalign(16, 8 * sizeof(*dequant_ptr_)));\n\n    r_ptr_ = (is_fp_) ? round_fp_ptr_ : round_ptr_;\n    q_ptr_ = (is_fp_) ? quant_fp_ptr_ : quant_ptr_;\n  }",
          "fn_code_pos": [
            [
              74,
              2
            ],
            [
              97,
              3
            ]
          ],
          "class_code": "ce52f7bd0310d8035241d71776920c84fa1b9c49d957adc9ca57476b931272c8",
          "class_node_pos": [
            [
              72,
              0
            ],
            [
              138,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VP9QuantizeBase",
            "parameters": {
              "bit_depth": "vpx_bit_depth_t",
              "max_size": "int",
              "is_fp": "bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~VP9QuantizeBase() {\n    vpx_free(zbin_ptr_);\n    vpx_free(round_fp_ptr_);\n    vpx_free(quant_fp_ptr_);\n    vpx_free(round_ptr_);\n    vpx_free(quant_ptr_);\n    vpx_free(quant_shift_ptr_);\n    vpx_free(dequant_ptr_);\n    zbin_ptr_ = NULL;\n    round_fp_ptr_ = NULL;\n    quant_fp_ptr_ = NULL;\n    round_ptr_ = NULL;\n    quant_ptr_ = NULL;\n    quant_shift_ptr_ = NULL;\n    dequant_ptr_ = NULL;\n    libvpx_test::ClearSystemState();\n  }",
          "fn_code_pos": [
            [
              99,
              2
            ],
            [
              115,
              3
            ]
          ],
          "class_code": "ce52f7bd0310d8035241d71776920c84fa1b9c49d957adc9ca57476b931272c8",
          "class_node_pos": [
            [
              72,
              0
            ],
            [
              138,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VP9QuantizeTest()\n      : VP9QuantizeBase(GET_PARAM(2), GET_PARAM(3), GET_PARAM(4)),\n        quantize_op_(GET_PARAM(0)), ref_quantize_op_(GET_PARAM(1)) {}",
          "fn_code_pos": [
            [
              143,
              2
            ],
            [
              145,
              69
            ]
          ],
          "class_code": "91912332a08583a527fda8d42416c837f156e9b8eca9ca56a7aabfebc1a9ba7a",
          "class_node_pos": [
            [
              140,
              0
            ],
            [
              151,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VP9QuantizeTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void VP9QuantizeTest::Run() {\n  quantize_op_(coeff_.TopLeftPixel(), count_, skip_block_, zbin_ptr_, r_ptr_,\n               q_ptr_, quant_shift_ptr_, qcoeff_.TopLeftPixel(),\n               dqcoeff_.TopLeftPixel(), dequant_ptr_, &eob_, scan_->scan,\n               scan_->iscan);\n}",
          "fn_code_pos": [
            [
              153,
              0
            ],
            [
              158,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VP9QuantizeTest::Run",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "inline void quant_fp_nz(const tran_low_t *coeff_ptr, intptr_t n_coeffs,\n                        int skip_block, const int16_t *round_ptr,\n                        const int16_t *quant_ptr, tran_low_t *qcoeff_ptr,\n                        tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr,\n                        uint16_t *eob_ptr, const int16_t *scan,\n                        const int16_t *iscan, int is_32x32) {\n  int i, eob = -1;\n  const int thr = dequant_ptr[1] >> (1 + is_32x32);\n  (void)iscan;\n  (void)skip_block;\n  assert(!skip_block);\n\n  // Quantization pass: All coefficients with index >= zero_flag are\n  // skippable. Note: zero_flag can be zero.\n  for (i = 0; i < n_coeffs; i += 16) {\n    int y;\n    int nzflag_cnt = 0;\n    int abs_coeff[16];\n    int coeff_sign[16];\n\n    // count nzflag for each row (16 tran_low_t)\n    for (y = 0; y < 16; ++y) {\n      const int rc = i + y;\n      const int coeff = coeff_ptr[rc];\n      coeff_sign[y] = (coeff >> 31);\n      abs_coeff[y] = (coeff ^ coeff_sign[y]) - coeff_sign[y];\n      // The first 16 are skipped in the sse2 code.  Do the same here to match.\n      if (i >= 16 && (abs_coeff[y] <= thr)) {\n        nzflag_cnt++;\n      }\n    }\n\n    for (y = 0; y < 16; ++y) {\n      const int rc = i + y;\n      // If all of the AC coeffs in a row has magnitude less than the\n      // quantization step_size/2, quantize to zero.\n      if (nzflag_cnt < 16) {\n        int tmp;\n        int _round;\n\n        if (is_32x32) {\n          _round = ROUND_POWER_OF_TWO(round_ptr[rc != 0], 1);\n        } else {\n          _round = round_ptr[rc != 0];\n        }\n        tmp = clamp(abs_coeff[y] + _round, INT16_MIN, INT16_MAX);\n        tmp = (tmp * quant_ptr[rc != 0]) >> (16 - is_32x32);\n        qcoeff_ptr[rc] = (tmp ^ coeff_sign[y]) - coeff_sign[y];\n        dqcoeff_ptr[rc] = qcoeff_ptr[rc] * dequant_ptr[rc != 0];\n\n        if (is_32x32) {\n          dqcoeff_ptr[rc] = qcoeff_ptr[rc] * dequant_ptr[rc != 0] / 2;\n        } else {\n          dqcoeff_ptr[rc] = qcoeff_ptr[rc] * dequant_ptr[rc != 0];\n        }\n      } else {\n        qcoeff_ptr[rc] = 0;\n        dqcoeff_ptr[rc] = 0;\n      }\n    }\n  }\n\n  // Scan for eob.\n  for (i = 0; i < n_coeffs; i++) {\n    // Use the scan order to find the correct eob.\n    const int rc = scan[i];\n    if (qcoeff_ptr[rc]) {\n      eob = i;\n    }\n  }\n  *eob_ptr = eob + 1;\n}",
          "fn_code_pos": [
            [
              163,
              0
            ],
            [
              234,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "quant_fp_nz",
            "parameters": {
              "coeff_ptr": "tran_low_t",
              "n_coeffs": "intptr_t",
              "skip_block": "int",
              "round_ptr": "int16_t",
              "quant_ptr": "int16_t",
              "qcoeff_ptr": "tran_low_t",
              "dqcoeff_ptr": "tran_low_t",
              "dequant_ptr": "int16_t",
              "eob_ptr": "uint16_t",
              "scan": "int16_t",
              "iscan": "int16_t",
              "is_32x32": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void quantize_fp_nz_c(const tran_low_t *coeff_ptr, intptr_t n_coeffs,\n                      int skip_block, const int16_t *round_ptr,\n                      const int16_t *quant_ptr, tran_low_t *qcoeff_ptr,\n                      tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr,\n                      uint16_t *eob_ptr, const int16_t *scan,\n                      const int16_t *iscan) {\n  quant_fp_nz(coeff_ptr, n_coeffs, skip_block, round_ptr, quant_ptr, qcoeff_ptr,\n              dqcoeff_ptr, dequant_ptr, eob_ptr, scan, iscan, 0);\n}",
          "fn_code_pos": [
            [
              236,
              0
            ],
            [
              244,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "quantize_fp_nz_c",
            "parameters": {
              "coeff_ptr": "tran_low_t",
              "n_coeffs": "intptr_t",
              "skip_block": "int",
              "round_ptr": "int16_t",
              "quant_ptr": "int16_t",
              "qcoeff_ptr": "tran_low_t",
              "dqcoeff_ptr": "tran_low_t",
              "dequant_ptr": "int16_t",
              "eob_ptr": "uint16_t",
              "scan": "int16_t",
              "iscan": "int16_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void quantize_fp_32x32_nz_c(const tran_low_t *coeff_ptr, intptr_t n_coeffs,\n                            int skip_block, const int16_t *round_ptr,\n                            const int16_t *quant_ptr, tran_low_t *qcoeff_ptr,\n                            tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr,\n                            uint16_t *eob_ptr, const int16_t *scan,\n                            const int16_t *iscan) {\n  quant_fp_nz(coeff_ptr, n_coeffs, skip_block, round_ptr, quant_ptr, qcoeff_ptr,\n              dqcoeff_ptr, dequant_ptr, eob_ptr, scan, iscan, 1);\n}",
          "fn_code_pos": [
            [
              246,
              0
            ],
            [
              254,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "quantize_fp_32x32_nz_c",
            "parameters": {
              "coeff_ptr": "tran_low_t",
              "n_coeffs": "intptr_t",
              "skip_block": "int",
              "round_ptr": "int16_t",
              "quant_ptr": "int16_t",
              "qcoeff_ptr": "tran_low_t",
              "dqcoeff_ptr": "tran_low_t",
              "dequant_ptr": "int16_t",
              "eob_ptr": "uint16_t",
              "scan": "int16_t",
              "iscan": "int16_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void GenerateHelperArrays(ACMRandom *rnd, int16_t *zbin, int16_t *round,\n                          int16_t *quant, int16_t *quant_shift,\n                          int16_t *dequant, int16_t *round_fp,\n                          int16_t *quant_fp) {\n  // Max when q == 0.  Otherwise, it is 48 for Y and 42 for U/V.\n  const int max_qrounding_factor_fp = 64;\n\n  for (int j = 0; j < 2; j++) {\n    // The range is 4 to 1828 in the VP9 tables.\n    const int qlookup = rnd->RandRange(1825) + 4;\n    round_fp[j] = (max_qrounding_factor_fp * qlookup) >> 7;\n    quant_fp[j] = (1 << 16) / qlookup;\n\n    // Values determined by deconstructing vp9_init_quantizer().\n    // zbin may be up to 1143 for 8 and 10 bit Y values, or 1200 for 12 bit Y\n    // values or U/V values of any bit depth. This is because y_delta is not\n    // factored into the vp9_ac_quant() call.\n    zbin[j] = rnd->RandRange(1200);\n\n    // round may be up to 685 for Y values or 914 for U/V.\n    round[j] = rnd->RandRange(914);\n    // quant ranges from 1 to -32703\n    quant[j] = static_cast<int>(rnd->RandRange(32704)) - 32703;\n    // quant_shift goes up to 1 << 16.\n    quant_shift[j] = rnd->RandRange(16384);\n    // dequant maxes out at 1828 for all cases.\n    dequant[j] = rnd->RandRange(1828);\n  }\n  for (int j = 2; j < 8; j++) {\n    zbin[j] = zbin[1];\n    round_fp[j] = round_fp[1];\n    quant_fp[j] = quant_fp[1];\n    round[j] = round[1];\n    quant[j] = quant[1];\n    quant_shift[j] = quant_shift[1];\n    dequant[j] = dequant[1];\n  }\n}",
          "fn_code_pos": [
            [
              256,
              0
            ],
            [
              293,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GenerateHelperArrays",
            "parameters": {
              "rnd": "ACMRandom",
              "zbin": "int16_t",
              "round": "int16_t",
              "quant": "int16_t",
              "quant_shift": "int16_t",
              "dequant": "int16_t",
              "round_fp": "int16_t",
              "quant_fp": "int16_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(VP9QuantizeTest, OperationCheck) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  ASSERT_TRUE(coeff_.Init());\n  ASSERT_TRUE(qcoeff_.Init());\n  ASSERT_TRUE(dqcoeff_.Init());\n  Buffer<tran_low_t> ref_qcoeff =\n      Buffer<tran_low_t>(max_size_, max_size_, 0, 32);\n  ASSERT_TRUE(ref_qcoeff.Init());\n  Buffer<tran_low_t> ref_dqcoeff =\n      Buffer<tran_low_t>(max_size_, max_size_, 0, 32);\n  ASSERT_TRUE(ref_dqcoeff.Init());\n  uint16_t ref_eob = 0;\n  eob_ = 0;\n\n  for (int i = 0; i < number_of_iterations; ++i) {\n    // Test skip block for the first three iterations to catch all the different\n    // sizes.\n    const int skip_block = 0;\n    TX_SIZE sz;\n    if (max_size_ == 16) {\n      sz = static_cast<TX_SIZE>(i % 3);  // TX_4X4, TX_8X8 TX_16X16\n    } else {\n      sz = TX_32X32;\n    }\n    const TX_TYPE tx_type = static_cast<TX_TYPE>((i >> 2) % 3);\n    scan_ = &vp9_scan_orders[sz][tx_type];\n    count_ = (4 << sz) * (4 << sz);\n    coeff_.Set(&rnd, -max_value_, max_value_);\n    GenerateHelperArrays(&rnd, zbin_ptr_, round_ptr_, quant_ptr_,\n                         quant_shift_ptr_, dequant_ptr_, round_fp_ptr_,\n                         quant_fp_ptr_);\n    ref_quantize_op_(coeff_.TopLeftPixel(), count_, skip_block, zbin_ptr_,\n                     r_ptr_, q_ptr_, quant_shift_ptr_,\n                     ref_qcoeff.TopLeftPixel(), ref_dqcoeff.TopLeftPixel(),\n                     dequant_ptr_, &ref_eob, scan_->scan, scan_->iscan);\n\n    ASM_REGISTER_STATE_CHECK(quantize_op_(\n        coeff_.TopLeftPixel(), count_, skip_block, zbin_ptr_, r_ptr_, q_ptr_,\n        quant_shift_ptr_, qcoeff_.TopLeftPixel(), dqcoeff_.TopLeftPixel(),\n        dequant_ptr_, &eob_, scan_->scan, scan_->iscan));\n\n    EXPECT_TRUE(qcoeff_.CheckValues(ref_qcoeff));\n    EXPECT_TRUE(dqcoeff_.CheckValues(ref_dqcoeff));\n\n    EXPECT_EQ(eob_, ref_eob);\n\n    if (HasFailure()) {\n      printf(\"Failure on iteration %d.\\n\", i);\n      qcoeff_.PrintDifference(ref_qcoeff);\n      dqcoeff_.PrintDifference(ref_dqcoeff);\n      return;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              295,
              0
            ],
            [
              348,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VP9QuantizeTest, EOBCheck) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  ASSERT_TRUE(coeff_.Init());\n  ASSERT_TRUE(qcoeff_.Init());\n  ASSERT_TRUE(dqcoeff_.Init());\n  Buffer<tran_low_t> ref_qcoeff =\n      Buffer<tran_low_t>(max_size_, max_size_, 0, 32);\n  ASSERT_TRUE(ref_qcoeff.Init());\n  Buffer<tran_low_t> ref_dqcoeff =\n      Buffer<tran_low_t>(max_size_, max_size_, 0, 32);\n  ASSERT_TRUE(ref_dqcoeff.Init());\n  uint16_t ref_eob = 0;\n  eob_ = 0;\n  const uint32_t max_index = max_size_ * max_size_ - 1;\n\n  for (int i = 0; i < number_of_iterations; ++i) {\n    skip_block_ = 0;\n    TX_SIZE sz;\n    if (max_size_ == 16) {\n      sz = static_cast<TX_SIZE>(i % 3);  // TX_4X4, TX_8X8 TX_16X16\n    } else {\n      sz = TX_32X32;\n    }\n    const TX_TYPE tx_type = static_cast<TX_TYPE>((i >> 2) % 3);\n    scan_ = &vp9_scan_orders[sz][tx_type];\n    count_ = (4 << sz) * (4 << sz);\n    // Two random entries\n    coeff_.Set(0);\n    coeff_.TopLeftPixel()[rnd.RandRange(count_) & max_index] =\n        static_cast<int>(rnd.RandRange(max_value_ * 2)) - max_value_;\n    coeff_.TopLeftPixel()[rnd.RandRange(count_) & max_index] =\n        static_cast<int>(rnd.RandRange(max_value_ * 2)) - max_value_;\n    GenerateHelperArrays(&rnd, zbin_ptr_, round_ptr_, quant_ptr_,\n                         quant_shift_ptr_, dequant_ptr_, round_fp_ptr_,\n                         quant_fp_ptr_);\n    ref_quantize_op_(coeff_.TopLeftPixel(), count_, skip_block_, zbin_ptr_,\n                     r_ptr_, q_ptr_, quant_shift_ptr_,\n                     ref_qcoeff.TopLeftPixel(), ref_dqcoeff.TopLeftPixel(),\n                     dequant_ptr_, &ref_eob, scan_->scan, scan_->iscan);\n\n    ASM_REGISTER_STATE_CHECK(quantize_op_(\n        coeff_.TopLeftPixel(), count_, skip_block_, zbin_ptr_, r_ptr_, q_ptr_,\n        quant_shift_ptr_, qcoeff_.TopLeftPixel(), dqcoeff_.TopLeftPixel(),\n        dequant_ptr_, &eob_, scan_->scan, scan_->iscan));\n\n    EXPECT_TRUE(qcoeff_.CheckValues(ref_qcoeff));\n    EXPECT_TRUE(dqcoeff_.CheckValues(ref_dqcoeff));\n\n    EXPECT_EQ(eob_, ref_eob);\n\n    if (HasFailure()) {\n      printf(\"Failure on iteration %d.\\n\", i);\n      qcoeff_.PrintDifference(ref_qcoeff);\n      dqcoeff_.PrintDifference(ref_dqcoeff);\n      return;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              350,
              0
            ],
            [
              407,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VP9QuantizeTest, DISABLED_Speed) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  ASSERT_TRUE(coeff_.Init());\n  ASSERT_TRUE(qcoeff_.Init());\n  ASSERT_TRUE(dqcoeff_.Init());\n  TX_SIZE starting_sz, ending_sz;\n\n  if (max_size_ == 16) {\n    starting_sz = TX_4X4;\n    ending_sz = TX_16X16;\n  } else {\n    starting_sz = TX_32X32;\n    ending_sz = TX_32X32;\n  }\n\n  for (TX_SIZE sz = starting_sz; sz <= ending_sz; ++sz) {\n    // zbin > coeff, zbin < coeff.\n    for (int i = 0; i < 2; ++i) {\n      skip_block_ = 0;\n      // TX_TYPE defines the scan order. That is not relevant to the speed test.\n      // Pick the first one.\n      const TX_TYPE tx_type = DCT_DCT;\n      count_ = (4 << sz) * (4 << sz);\n      scan_ = &vp9_scan_orders[sz][tx_type];\n\n      GenerateHelperArrays(&rnd, zbin_ptr_, round_ptr_, quant_ptr_,\n                           quant_shift_ptr_, dequant_ptr_, round_fp_ptr_,\n                           quant_fp_ptr_);\n\n      if (i == 0) {\n        // When |coeff values| are less than zbin the results are 0.\n        int threshold = 100;\n        if (max_size_ == 32) {\n          // For 32x32, the threshold is halved. Double it to keep the values\n          // from clearing it.\n          threshold = 200;\n        }\n        for (int j = 0; j < 8; ++j) zbin_ptr_[j] = threshold;\n        coeff_.Set(&rnd, -99, 99);\n      } else if (i == 1) {\n        for (int j = 0; j < 8; ++j) zbin_ptr_[j] = 50;\n        coeff_.Set(&rnd, -500, 500);\n      }\n\n      RunNTimes(10000000 / count_);\n      const char *type =\n          (i == 0) ? \"Bypass calculations \" : \"Full calculations \";\n      char block_size[16];\n      snprintf(block_size, sizeof(block_size), \"%dx%d\", 4 << sz, 4 << sz);\n      char title[100];\n      snprintf(title, sizeof(title), \"%25s %8s \", type, block_size);\n      PrintMedian(title);\n    }\n  }\n}",
          "fn_code_pos": [
            [
              409,
              0
            ],
            [
              463,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*QuantizeFunc)(const tran_low_t *coeff, intptr_t count,\n                             int skip_block, const int16_t *zbin,\n                             const int16_t *round, const int16_t *quant,\n                             const int16_t *quant_shift, tran_low_t *qcoeff,\n                             tran_low_t *dqcoeff, const int16_t *dequant,\n                             uint16_t *eob, const int16_t *scan,\n                             const int16_t *iscan)",
          "fn_dec_pos": [
            [
              39,
              13
            ],
            [
              45,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "coeff": "tran_low_t",
              "count": "intptr_t",
              "skip_block": "int",
              "zbin": "int16_t",
              "round": "int16_t",
              "quant": "int16_t",
              "quant_shift": "int16_t",
              "qcoeff": "tran_low_t",
              "dqcoeff": "tran_low_t",
              "dequant": "int16_t",
              "eob": "uint16_t",
              "scan": "int16_t",
              "iscan": "int16_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*QuantizeFPFunc)(const tran_low_t *coeff, intptr_t count,\n                               int skip_block, const int16_t *round,\n                               const int16_t *quant, tran_low_t *qcoeff,\n                               tran_low_t *dqcoeff, const int16_t *dequant,\n                               uint16_t *eob, const int16_t *scan,\n                               const int16_t *iscan)",
          "fn_dec_pos": [
            [
              51,
              13
            ],
            [
              56,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "coeff": "tran_low_t",
              "count": "intptr_t",
              "skip_block": "int",
              "round": "int16_t",
              "quant": "int16_t",
              "qcoeff": "tran_low_t",
              "dqcoeff": "tran_low_t",
              "dequant": "int16_t",
              "eob": "uint16_t",
              "scan": "int16_t",
              "iscan": "int16_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "Run()",
          "fn_dec_pos": [
            [
              148,
              15
            ],
            [
              148,
              20
            ]
          ],
          "class_code": "91912332a08583a527fda8d42416c837f156e9b8eca9ca56a7aabfebc1a9ba7a",
          "class_node_pos": [
            [
              140,
              0
            ],
            [
              151,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Run",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              296,
              12
            ],
            [
              296,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              351,
              12
            ],
            [
              351,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              410,
              12
            ],
            [
              410,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        }
      ],
      "class_node_list": {
        "ce52f7bd0310d8035241d71776920c84fa1b9c49d957adc9ca57476b931272c8": {
          "class_code": "class VP9QuantizeBase : public AbstractBench {\n public:\n  VP9QuantizeBase(vpx_bit_depth_t bit_depth, int max_size, bool is_fp)\n      : bit_depth_(bit_depth), max_size_(max_size), is_fp_(is_fp),\n        coeff_(Buffer<tran_low_t>(max_size_, max_size_, 0, 16)),\n        qcoeff_(Buffer<tran_low_t>(max_size_, max_size_, 0, 32)),\n        dqcoeff_(Buffer<tran_low_t>(max_size_, max_size_, 0, 32)) {\n    max_value_ = (1 << bit_depth_) - 1;\n    zbin_ptr_ =\n        reinterpret_cast<int16_t *>(vpx_memalign(16, 8 * sizeof(*zbin_ptr_)));\n    round_fp_ptr_ = reinterpret_cast<int16_t *>(\n        vpx_memalign(16, 8 * sizeof(*round_fp_ptr_)));\n    quant_fp_ptr_ = reinterpret_cast<int16_t *>(\n        vpx_memalign(16, 8 * sizeof(*quant_fp_ptr_)));\n    round_ptr_ =\n        reinterpret_cast<int16_t *>(vpx_memalign(16, 8 * sizeof(*round_ptr_)));\n    quant_ptr_ =\n        reinterpret_cast<int16_t *>(vpx_memalign(16, 8 * sizeof(*quant_ptr_)));\n    quant_shift_ptr_ = reinterpret_cast<int16_t *>(\n        vpx_memalign(16, 8 * sizeof(*quant_shift_ptr_)));\n    dequant_ptr_ = reinterpret_cast<int16_t *>(\n        vpx_memalign(16, 8 * sizeof(*dequant_ptr_)));\n\n    r_ptr_ = (is_fp_) ? round_fp_ptr_ : round_ptr_;\n    q_ptr_ = (is_fp_) ? quant_fp_ptr_ : quant_ptr_;\n  }\n\n  ~VP9QuantizeBase() {\n    vpx_free(zbin_ptr_);\n    vpx_free(round_fp_ptr_);\n    vpx_free(quant_fp_ptr_);\n    vpx_free(round_ptr_);\n    vpx_free(quant_ptr_);\n    vpx_free(quant_shift_ptr_);\n    vpx_free(dequant_ptr_);\n    zbin_ptr_ = NULL;\n    round_fp_ptr_ = NULL;\n    quant_fp_ptr_ = NULL;\n    round_ptr_ = NULL;\n    quant_ptr_ = NULL;\n    quant_shift_ptr_ = NULL;\n    dequant_ptr_ = NULL;\n    libvpx_test::ClearSystemState();\n  }\n\n protected:\n  int16_t *zbin_ptr_;\n  int16_t *round_fp_ptr_;\n  int16_t *quant_fp_ptr_;\n  int16_t *round_ptr_;\n  int16_t *quant_ptr_;\n  int16_t *quant_shift_ptr_;\n  int16_t *dequant_ptr_;\n  const vpx_bit_depth_t bit_depth_;\n  int max_value_;\n  const int max_size_;\n  const bool is_fp_;\n  Buffer<tran_low_t> coeff_;\n  Buffer<tran_low_t> qcoeff_;\n  Buffer<tran_low_t> dqcoeff_;\n  int16_t *r_ptr_;\n  int16_t *q_ptr_;\n  int count_;\n  int skip_block_;\n  const scan_order *scan_;\n  uint16_t eob_;\n}",
          "class_name": "VP9QuantizeBase",
          "class_pos": [
            [
              72,
              0
            ],
            [
              138,
              1
            ]
          ]
        },
        "91912332a08583a527fda8d42416c837f156e9b8eca9ca56a7aabfebc1a9ba7a": {
          "class_code": "class VP9QuantizeTest : public VP9QuantizeBase,\n                        public ::testing::TestWithParam<QuantizeParam> {\n public:\n  VP9QuantizeTest()\n      : VP9QuantizeBase(GET_PARAM(2), GET_PARAM(3), GET_PARAM(4)),\n        quantize_op_(GET_PARAM(0)), ref_quantize_op_(GET_PARAM(1)) {}\n\n protected:\n  virtual void Run();\n  const QuantizeFunc quantize_op_;\n  const QuantizeFunc ref_quantize_op_;\n}",
          "class_name": "VP9QuantizeTest",
          "class_pos": [
            [
              140,
              0
            ],
            [
              151,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <math.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./vp9_rtcd.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"test/bench.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"test/buffer.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_entropy.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_scan.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_codec.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"vpx_ports/msvc.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"vpx_ports/vpx_timer.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/quantize_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "virtual ~QuantizeTestBase() {\n    vp8_remove_compressor(&vp8_comp_);\n    vp8_comp_ = NULL;\n    vpx_free(macroblockd_dst_);\n    macroblockd_dst_ = NULL;\n    libvpx_test::ClearSystemState();\n  }",
          "fn_code_pos": [
            [
              45,
              2
            ],
            [
              51,
              3
            ]
          ],
          "class_code": "cc7f3202992da1f61046337d073c2e87611d62c32fe1203335235f336452e5a7",
          "class_node_pos": [
            [
              43,
              0
            ],
            [
              116,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void SetupCompressor() {\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n\n    // The full configuration is necessary to generate the quantization tables.\n    VP8_CONFIG vp8_config;\n    memset(&vp8_config, 0, sizeof(vp8_config));\n\n    vp8_comp_ = vp8_create_compressor(&vp8_config);\n\n    // Set the tables based on a quantizer of 0.\n    vp8_set_quantizer(vp8_comp_, 0);\n\n    // Set up all the block/blockd pointers for the mb in vp8_comp_.\n    vp8cx_frame_init_quantizer(vp8_comp_);\n\n    // Copy macroblockd from the reference to get pre-set-up dequant values.\n    macroblockd_dst_ = reinterpret_cast<MACROBLOCKD *>(\n        vpx_memalign(32, sizeof(*macroblockd_dst_)));\n    memcpy(macroblockd_dst_, &vp8_comp_->mb.e_mbd, sizeof(*macroblockd_dst_));\n    // Fix block pointers - currently they point to the blocks in the reference\n    // structure.\n    vp8_setup_block_dptrs(macroblockd_dst_);\n  }",
          "fn_code_pos": [
            [
              54,
              2
            ],
            [
              76,
              3
            ]
          ],
          "class_code": "cc7f3202992da1f61046337d073c2e87611d62c32fe1203335235f336452e5a7",
          "class_node_pos": [
            [
              43,
              0
            ],
            [
              116,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetupCompressor",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UpdateQuantizer(int q) {\n    vp8_set_quantizer(vp8_comp_, q);\n\n    memcpy(macroblockd_dst_, &vp8_comp_->mb.e_mbd, sizeof(*macroblockd_dst_));\n    vp8_setup_block_dptrs(macroblockd_dst_);\n  }",
          "fn_code_pos": [
            [
              78,
              2
            ],
            [
              83,
              3
            ]
          ],
          "class_code": "cc7f3202992da1f61046337d073c2e87611d62c32fe1203335235f336452e5a7",
          "class_node_pos": [
            [
              43,
              0
            ],
            [
              116,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "UpdateQuantizer",
            "parameters": {
              "q": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void FillCoeffConstant(int16_t c) {\n    for (int i = 0; i < kNumBlocks * kNumBlockEntries; ++i) {\n      vp8_comp_->mb.coeff[i] = c;\n    }\n  }",
          "fn_code_pos": [
            [
              85,
              2
            ],
            [
              89,
              3
            ]
          ],
          "class_code": "cc7f3202992da1f61046337d073c2e87611d62c32fe1203335235f336452e5a7",
          "class_node_pos": [
            [
              43,
              0
            ],
            [
              116,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillCoeffConstant",
            "parameters": {
              "c": "int16_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void FillCoeffRandom() {\n    for (int i = 0; i < kNumBlocks * kNumBlockEntries; ++i) {\n      vp8_comp_->mb.coeff[i] = rnd_.Rand8();\n    }\n  }",
          "fn_code_pos": [
            [
              91,
              2
            ],
            [
              95,
              3
            ]
          ],
          "class_code": "cc7f3202992da1f61046337d073c2e87611d62c32fe1203335235f336452e5a7",
          "class_node_pos": [
            [
              43,
              0
            ],
            [
              116,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillCoeffRandom",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CheckOutput() {\n    EXPECT_EQ(0, memcmp(vp8_comp_->mb.e_mbd.qcoeff, macroblockd_dst_->qcoeff,\n                        sizeof(*macroblockd_dst_->qcoeff) * kNumBlocks *\n                            kNumBlockEntries))\n        << \"qcoeff mismatch\";\n    EXPECT_EQ(0, memcmp(vp8_comp_->mb.e_mbd.dqcoeff, macroblockd_dst_->dqcoeff,\n                        sizeof(*macroblockd_dst_->dqcoeff) * kNumBlocks *\n                            kNumBlockEntries))\n        << \"dqcoeff mismatch\";\n    EXPECT_EQ(0, memcmp(vp8_comp_->mb.e_mbd.eobs, macroblockd_dst_->eobs,\n                        sizeof(*macroblockd_dst_->eobs) * kNumBlocks))\n        << \"eobs mismatch\";\n  }",
          "fn_code_pos": [
            [
              97,
              2
            ],
            [
              109,
              3
            ]
          ],
          "class_code": "cc7f3202992da1f61046337d073c2e87611d62c32fe1203335235f336452e5a7",
          "class_node_pos": [
            [
              43,
              0
            ],
            [
              116,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckOutput",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    SetupCompressor();\n    asm_quant_ = GET_PARAM(0);\n    c_quant_ = GET_PARAM(1);\n  }",
          "fn_code_pos": [
            [
              121,
              2
            ],
            [
              125,
              3
            ]
          ],
          "class_code": "2aa9a49b9af77c04af81502e319959f21b8daa9584525d39e4b2b0619c5cb1cf",
          "class_node_pos": [
            [
              118,
              0
            ],
            [
              141,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunComparison() {\n    for (int i = 0; i < kNumBlocks; ++i) {\n      ASM_REGISTER_STATE_CHECK(\n          c_quant_(&vp8_comp_->mb.block[i], &vp8_comp_->mb.e_mbd.block[i]));\n      ASM_REGISTER_STATE_CHECK(\n          asm_quant_(&vp8_comp_->mb.block[i], &macroblockd_dst_->block[i]));\n    }\n\n    CheckOutput();\n  }",
          "fn_code_pos": [
            [
              127,
              2
            ],
            [
              136,
              3
            ]
          ],
          "class_code": "2aa9a49b9af77c04af81502e319959f21b8daa9584525d39e4b2b0619c5cb1cf",
          "class_node_pos": [
            [
              118,
              0
            ],
            [
              141,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunComparison",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(QuantizeTest, TestZeroInput) {\n  FillCoeffConstant(0);\n  RunComparison();\n}",
          "fn_code_pos": [
            [
              143,
              0
            ],
            [
              146,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(QuantizeTest, TestLargeNegativeInput) {\n  FillCoeffConstant(0);\n  // Generate a qcoeff which contains 512/-512 (0x0100/0xFE00) to catch issues\n  // like BUG=883 where the constant being compared was incorrectly initialized.\n  vp8_comp_->mb.coeff[0] = -8191;\n  RunComparison();\n}",
          "fn_code_pos": [
            [
              148,
              0
            ],
            [
              154,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(QuantizeTest, TestRandomInput) {\n  FillCoeffRandom();\n  RunComparison();\n}",
          "fn_code_pos": [
            [
              156,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(QuantizeTest, TestMultipleQ) {\n  for (int q = 0; q < QINDEX_RANGE; ++q) {\n    UpdateQuantizer(q);\n    FillCoeffRandom();\n    RunComparison();\n  }\n}",
          "fn_code_pos": [
            [
              161,
              0
            ],
            [
              167,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*VP8Quantize)(BLOCK *b, BLOCKD *d)",
          "fn_dec_pos": [
            [
              34,
              13
            ],
            [
              34,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "b": "BLOCK",
              "d": "BLOCKD"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {
        "cc7f3202992da1f61046337d073c2e87611d62c32fe1203335235f336452e5a7": {
          "class_code": "class QuantizeTestBase {\n public:\n  virtual ~QuantizeTestBase() {\n    vp8_remove_compressor(&vp8_comp_);\n    vp8_comp_ = NULL;\n    vpx_free(macroblockd_dst_);\n    macroblockd_dst_ = NULL;\n    libvpx_test::ClearSystemState();\n  }\n\n protected:\n  void SetupCompressor() {\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n\n    // The full configuration is necessary to generate the quantization tables.\n    VP8_CONFIG vp8_config;\n    memset(&vp8_config, 0, sizeof(vp8_config));\n\n    vp8_comp_ = vp8_create_compressor(&vp8_config);\n\n    // Set the tables based on a quantizer of 0.\n    vp8_set_quantizer(vp8_comp_, 0);\n\n    // Set up all the block/blockd pointers for the mb in vp8_comp_.\n    vp8cx_frame_init_quantizer(vp8_comp_);\n\n    // Copy macroblockd from the reference to get pre-set-up dequant values.\n    macroblockd_dst_ = reinterpret_cast<MACROBLOCKD *>(\n        vpx_memalign(32, sizeof(*macroblockd_dst_)));\n    memcpy(macroblockd_dst_, &vp8_comp_->mb.e_mbd, sizeof(*macroblockd_dst_));\n    // Fix block pointers - currently they point to the blocks in the reference\n    // structure.\n    vp8_setup_block_dptrs(macroblockd_dst_);\n  }\n\n  void UpdateQuantizer(int q) {\n    vp8_set_quantizer(vp8_comp_, q);\n\n    memcpy(macroblockd_dst_, &vp8_comp_->mb.e_mbd, sizeof(*macroblockd_dst_));\n    vp8_setup_block_dptrs(macroblockd_dst_);\n  }\n\n  void FillCoeffConstant(int16_t c) {\n    for (int i = 0; i < kNumBlocks * kNumBlockEntries; ++i) {\n      vp8_comp_->mb.coeff[i] = c;\n    }\n  }\n\n  void FillCoeffRandom() {\n    for (int i = 0; i < kNumBlocks * kNumBlockEntries; ++i) {\n      vp8_comp_->mb.coeff[i] = rnd_.Rand8();\n    }\n  }\n\n  void CheckOutput() {\n    EXPECT_EQ(0, memcmp(vp8_comp_->mb.e_mbd.qcoeff, macroblockd_dst_->qcoeff,\n                        sizeof(*macroblockd_dst_->qcoeff) * kNumBlocks *\n                            kNumBlockEntries))\n        << \"qcoeff mismatch\";\n    EXPECT_EQ(0, memcmp(vp8_comp_->mb.e_mbd.dqcoeff, macroblockd_dst_->dqcoeff,\n                        sizeof(*macroblockd_dst_->dqcoeff) * kNumBlocks *\n                            kNumBlockEntries))\n        << \"dqcoeff mismatch\";\n    EXPECT_EQ(0, memcmp(vp8_comp_->mb.e_mbd.eobs, macroblockd_dst_->eobs,\n                        sizeof(*macroblockd_dst_->eobs) * kNumBlocks))\n        << \"eobs mismatch\";\n  }\n\n  VP8_COMP *vp8_comp_;\n  MACROBLOCKD *macroblockd_dst_;\n\n private:\n  ACMRandom rnd_;\n}",
          "class_name": "QuantizeTestBase",
          "class_pos": [
            [
              43,
              0
            ],
            [
              116,
              1
            ]
          ]
        },
        "2aa9a49b9af77c04af81502e319959f21b8daa9584525d39e4b2b0619c5cb1cf": {
          "class_code": "class QuantizeTest : public QuantizeTestBase,\n                     public ::testing::TestWithParam<VP8QuantizeParam> {\n protected:\n  virtual void SetUp() {\n    SetupCompressor();\n    asm_quant_ = GET_PARAM(0);\n    c_quant_ = GET_PARAM(1);\n  }\n\n  void RunComparison() {\n    for (int i = 0; i < kNumBlocks; ++i) {\n      ASM_REGISTER_STATE_CHECK(\n          c_quant_(&vp8_comp_->mb.block[i], &vp8_comp_->mb.e_mbd.block[i]));\n      ASM_REGISTER_STATE_CHECK(\n          asm_quant_(&vp8_comp_->mb.block[i], &macroblockd_dst_->block[i]));\n    }\n\n    CheckOutput();\n  }\n\n private:\n  VP8Quantize asm_quant_;\n  VP8Quantize c_quant_;\n}",
          "class_name": "QuantizeTest",
          "class_pos": [
            [
              118,
              0
            ],
            [
              141,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <string.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./vp8_rtcd.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"vp8/common/blockd.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"vp8/common/onyx.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"vp8/encoder/block.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"vp8/encoder/onyx_int.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"vp8/encoder/quantize.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp9_thread_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "virtual ~VPxWorkerThreadTest() {}",
          "fn_code_pos": [
            [
              28,
              2
            ],
            [
              28,
              35
            ]
          ],
          "class_code": "a3c27b704efb8f85c283cb8511a826b1826ec1978df130101ed03f293470f6da",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              43,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() { vpx_get_worker_interface()->init(&worker_); }",
          "fn_code_pos": [
            [
              29,
              2
            ],
            [
              29,
              70
            ]
          ],
          "class_code": "a3c27b704efb8f85c283cb8511a826b1826ec1978df130101ed03f293470f6da",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              43,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() { vpx_get_worker_interface()->end(&worker_); }",
          "fn_code_pos": [
            [
              31,
              2
            ],
            [
              31,
              72
            ]
          ],
          "class_code": "a3c27b704efb8f85c283cb8511a826b1826ec1978df130101ed03f293470f6da",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              43,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Run(VPxWorker *worker) {\n    const bool synchronous = GetParam();\n    if (synchronous) {\n      vpx_get_worker_interface()->execute(worker);\n    } else {\n      vpx_get_worker_interface()->launch(worker);\n    }\n  }",
          "fn_code_pos": [
            [
              33,
              2
            ],
            [
              40,
              3
            ]
          ],
          "class_code": "a3c27b704efb8f85c283cb8511a826b1826ec1978df130101ed03f293470f6da",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              43,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Run",
            "parameters": {
              "worker": "VPxWorker"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int ThreadHook(void *data, void *return_value) {\n  int *const hook_data = reinterpret_cast<int *>(data);\n  *hook_data = 5;\n  return *reinterpret_cast<int *>(return_value);\n}",
          "fn_code_pos": [
            [
              45,
              0
            ],
            [
              49,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ThreadHook",
            "parameters": {
              "data": "void",
              "return_value": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TEST_P(VPxWorkerThreadTest, HookSuccess) {\n  // should be a no-op.\n  EXPECT_NE(vpx_get_worker_interface()->sync(&worker_), 0);\n\n  for (int i = 0; i < 2; ++i) {\n    EXPECT_NE(vpx_get_worker_interface()->reset(&worker_), 0);\n\n    int hook_data = 0;\n    int return_value = 1;  // return successfully from the hook\n    worker_.hook = ThreadHook;\n    worker_.data1 = &hook_data;\n    worker_.data2 = &return_value;\n\n    Run(&worker_);\n    EXPECT_NE(vpx_get_worker_interface()->sync(&worker_), 0);\n    EXPECT_FALSE(worker_.had_error);\n    EXPECT_EQ(5, hook_data);\n\n    // should be a no-op.\n    EXPECT_NE(vpx_get_worker_interface()->sync(&worker_), 0);\n  }\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              72,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VPxWorkerThreadTest, HookFailure) {\n  EXPECT_NE(vpx_get_worker_interface()->reset(&worker_), 0);\n\n  int hook_data = 0;\n  int return_value = 0;  // return failure from the hook\n  worker_.hook = ThreadHook;\n  worker_.data1 = &hook_data;\n  worker_.data2 = &return_value;\n\n  Run(&worker_);\n  EXPECT_FALSE(vpx_get_worker_interface()->sync(&worker_));\n  EXPECT_EQ(1, worker_.had_error);\n\n  // Ensure _reset() clears the error and _launch() can be called again.\n  return_value = 1;\n  EXPECT_NE(vpx_get_worker_interface()->reset(&worker_), 0);\n  EXPECT_FALSE(worker_.had_error);\n  vpx_get_worker_interface()->launch(&worker_);\n  EXPECT_NE(vpx_get_worker_interface()->sync(&worker_), 0);\n  EXPECT_FALSE(worker_.had_error);\n}",
          "fn_code_pos": [
            [
              74,
              0
            ],
            [
              94,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VPxWorkerThreadTest, EndWithoutSync) {\n  // Create a large number of threads to increase the chances of detecting a\n  // race. Doing more work in the hook is no guarantee as any race would occur\n  // post hook execution in the main thread loop driver.\n  static const int kNumWorkers = 64;\n  VPxWorker workers[kNumWorkers];\n  int hook_data[kNumWorkers];\n  int return_value[kNumWorkers];\n\n  for (int n = 0; n < kNumWorkers; ++n) {\n    vpx_get_worker_interface()->init(&workers[n]);\n    return_value[n] = 1;  // return successfully from the hook\n    workers[n].hook = ThreadHook;\n    workers[n].data1 = &hook_data[n];\n    workers[n].data2 = &return_value[n];\n  }\n\n  for (int i = 0; i < 2; ++i) {\n    for (int n = 0; n < kNumWorkers; ++n) {\n      EXPECT_NE(vpx_get_worker_interface()->reset(&workers[n]), 0);\n      hook_data[n] = 0;\n    }\n\n    for (int n = 0; n < kNumWorkers; ++n) {\n      Run(&workers[n]);\n    }\n\n    for (int n = kNumWorkers - 1; n >= 0; --n) {\n      vpx_get_worker_interface()->end(&workers[n]);\n    }\n  }\n}",
          "fn_code_pos": [
            [
              96,
              0
            ],
            [
              127,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(VPxWorkerThreadTest, TestInterfaceAPI) {\n  EXPECT_EQ(0, vpx_set_worker_interface(NULL));\n  EXPECT_TRUE(vpx_get_worker_interface() != NULL);\n  for (int i = 0; i < 6; ++i) {\n    VPxWorkerInterface winterface = *vpx_get_worker_interface();\n    switch (i) {\n      default:\n      case 0: winterface.init = NULL; break;\n      case 1: winterface.reset = NULL; break;\n      case 2: winterface.sync = NULL; break;\n      case 3: winterface.launch = NULL; break;\n      case 4: winterface.execute = NULL; break;\n      case 5: winterface.end = NULL; break;\n    }\n    EXPECT_EQ(0, vpx_set_worker_interface(&winterface));\n  }\n}",
          "fn_code_pos": [
            [
              129,
              0
            ],
            [
              145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "string DecodeFile(const string &filename, int num_threads) {\n  libvpx_test::WebMVideoSource video(filename);\n  video.Init();\n\n  vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n  cfg.threads = num_threads;\n  libvpx_test::VP9Decoder decoder(cfg, 0);\n\n  libvpx_test::MD5 md5;\n  for (video.Begin(); video.cxdata(); video.Next()) {\n    const vpx_codec_err_t res =\n        decoder.DecodeFrame(video.cxdata(), video.frame_size());\n    if (res != VPX_CODEC_OK) {\n      EXPECT_EQ(VPX_CODEC_OK, res) << decoder.DecodeError();\n      break;\n    }\n\n    libvpx_test::DxDataIterator dec_iter = decoder.GetDxData();\n    const vpx_image_t *img = NULL;\n\n    // Get decompressed data\n    while ((img = dec_iter.Next())) {\n      md5.Add(img);\n    }\n  }\n  return string(md5.Get());\n}",
          "fn_code_pos": [
            [
              156,
              0
            ],
            [
              182,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DecodeFile",
            "parameters": {
              "filename": "string",
              "num_threads": "int"
            },
            "return_type": "string"
          }
        },
        {
          "fn_code": "void DecodeFiles(const FileList files[]) {\n  for (const FileList *iter = files; iter->name != NULL; ++iter) {\n    SCOPED_TRACE(iter->name);\n    for (int t = 1; t <= 8; ++t) {\n      EXPECT_EQ(iter->expected_md5, DecodeFile(iter->name, t))\n          << \"threads = \" << t;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              184,
              0
            ],
            [
              192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DecodeFiles",
            "parameters": {
              "files": "FileList"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Init(VPxWorker *const worker) { memset(worker, 0, sizeof(*worker)); }",
          "fn_code_pos": [
            [
              199,
              0
            ],
            [
              199,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Init",
            "parameters": {
              "worker": "VPxWorker"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int Reset(VPxWorker *const /*worker*/) { return 1; }",
          "fn_code_pos": [
            [
              200,
              0
            ],
            [
              200,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Reset",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int Sync(VPxWorker *const worker) { return !worker->had_error; }",
          "fn_code_pos": [
            [
              201,
              0
            ],
            [
              201,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Sync",
            "parameters": {
              "worker": "VPxWorker"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void Execute(VPxWorker *const worker) {\n  worker->had_error |= !worker->hook(worker->data1, worker->data2);\n}",
          "fn_code_pos": [
            [
              203,
              0
            ],
            [
              205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Execute",
            "parameters": {
              "worker": "VPxWorker"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Launch(VPxWorker *const worker) { Execute(worker); }",
          "fn_code_pos": [
            [
              207,
              0
            ],
            [
              207,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Launch",
            "parameters": {
              "worker": "VPxWorker"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void End(VPxWorker *const /*worker*/) {}",
          "fn_code_pos": [
            [
              208,
              0
            ],
            [
              208,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "End",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST(VPxWorkerThreadTest, TestSerialInterface) {\n  static const VPxWorkerInterface serial_interface = {\n    impl::Init, impl::Reset, impl::Sync, impl::Launch, impl::Execute, impl::End\n  };\n  // TODO(jzern): Avoid using a file that will use the row-based thread\n  // loopfilter, with the simple serialized implementation it will hang. This is\n  // due to its expectation that rows will be run in parallel as they wait on\n  // progress in the row above before proceeding.\n  static const char expected_md5[] = \"b35a1b707b28e82be025d960aba039bc\";\n  static const char filename[] = \"vp90-2-03-size-226x226.webm\";\n  VPxWorkerInterface default_interface = *vpx_get_worker_interface();\n\n  EXPECT_NE(vpx_set_worker_interface(&serial_interface), 0);\n  EXPECT_EQ(expected_md5, DecodeFile(filename, 2));\n\n  // Reset the interface.\n  EXPECT_NE(vpx_set_worker_interface(&default_interface), 0);\n  EXPECT_EQ(expected_md5, DecodeFile(filename, 2));\n}",
          "fn_code_pos": [
            [
              212,
              0
            ],
            [
              230,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(VP9DecodeMultiThreadedTest, NoTilesNonFrameParallel) {\n  // no tiles or frame parallel; this exercises loop filter threading.\n  EXPECT_EQ(\"b35a1b707b28e82be025d960aba039bc\",\n            DecodeFile(\"vp90-2-03-size-226x226.webm\", 2));\n}",
          "fn_code_pos": [
            [
              232,
              0
            ],
            [
              236,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(VP9DecodeMultiThreadedTest, FrameParallel) {\n  static const FileList files[] = { { \"vp90-2-08-tile_1x2_frame_parallel.webm\",\n                                      \"68ede6abd66bae0a2edf2eb9232241b6\" },\n                                    { \"vp90-2-08-tile_1x4_frame_parallel.webm\",\n                                      \"368ebc6ebf3a5e478d85b2c3149b2848\" },\n                                    { \"vp90-2-08-tile_1x8_frame_parallel.webm\",\n                                      \"17e439da2388aff3a0f69cb22579c6c1\" },\n                                    { NULL, NULL } };\n\n  DecodeFiles(files);\n}",
          "fn_code_pos": [
            [
              238,
              0
            ],
            [
              248,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(VP9DecodeMultiThreadedTest, FrameParallelResize) {\n  static const FileList files[] = {\n    { \"vp90-2-14-resize-fp-tiles-1-16.webm\",\n      \"0cd5e632c326297e975f38949c31ea94\" },\n    { \"vp90-2-14-resize-fp-tiles-1-2-4-8-16.webm\",\n      \"5c78a96a42e7f4a4f6b2edcdb791e44c\" },\n    { \"vp90-2-14-resize-fp-tiles-1-2.webm\",\n      \"e030450ae85c3277be2a418769df98e2\" },\n    { \"vp90-2-14-resize-fp-tiles-1-4.webm\",\n      \"312eed4e2b64eb7a4e7f18916606a430\" },\n    { \"vp90-2-14-resize-fp-tiles-16-1.webm\",\n      \"1755c16d8af16a9cb3fe7338d90abe52\" },\n    { \"vp90-2-14-resize-fp-tiles-16-2.webm\",\n      \"500300592d3fcb6f12fab25e48aaf4df\" },\n    { \"vp90-2-14-resize-fp-tiles-16-4.webm\",\n      \"47c48379fa6331215d91c67648e1af6e\" },\n    { \"vp90-2-14-resize-fp-tiles-16-8-4-2-1.webm\",\n      \"eecf17290739bc708506fa4827665989\" },\n    { \"vp90-2-14-resize-fp-tiles-16-8.webm\",\n      \"29b6bb54e4c26b5ca85d5de5fed94e76\" },\n    { \"vp90-2-14-resize-fp-tiles-1-8.webm\",\n      \"1b6f175e08cd82cf84bb800ac6d1caa3\" },\n    { \"vp90-2-14-resize-fp-tiles-2-16.webm\",\n      \"ca3b03e4197995d8d5444ede7a6c0804\" },\n    { \"vp90-2-14-resize-fp-tiles-2-1.webm\",\n      \"99aec065369d70bbb78ccdff65afed3f\" },\n    { \"vp90-2-14-resize-fp-tiles-2-4.webm\",\n      \"22d0ebdb49b87d2920a85aea32e1afd5\" },\n    { \"vp90-2-14-resize-fp-tiles-2-8.webm\",\n      \"c2115cf051c62e0f7db1d4a783831541\" },\n    { \"vp90-2-14-resize-fp-tiles-4-16.webm\",\n      \"c690d7e1719b31367564cac0af0939cb\" },\n    { \"vp90-2-14-resize-fp-tiles-4-1.webm\",\n      \"a926020b2cc3e15ad4cc271853a0ff26\" },\n    { \"vp90-2-14-resize-fp-tiles-4-2.webm\",\n      \"42699063d9e581f1993d0cf890c2be78\" },\n    { \"vp90-2-14-resize-fp-tiles-4-8.webm\",\n      \"7f76d96036382f45121e3d5aa6f8ec52\" },\n    { \"vp90-2-14-resize-fp-tiles-8-16.webm\",\n      \"76a43fcdd7e658542913ea43216ec55d\" },\n    { \"vp90-2-14-resize-fp-tiles-8-1.webm\",\n      \"8e3fbe89486ca60a59299dea9da91378\" },\n    { \"vp90-2-14-resize-fp-tiles-8-2.webm\",\n      \"ae96f21f21b6370cc0125621b441fc52\" },\n    { \"vp90-2-14-resize-fp-tiles-8-4.webm\",\n      \"3eb4f24f10640d42218f7fd7b9fd30d4\" },\n    { NULL, NULL }\n  };\n\n  DecodeFiles(files);\n}",
          "fn_code_pos": [
            [
              250,
              0
            ],
            [
              300,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(VP9DecodeMultiThreadedTest, NonFrameParallel) {\n  static const FileList files[] = {\n    { \"vp90-2-08-tile_1x2.webm\", \"570b4a5d5a70d58b5359671668328a16\" },\n    { \"vp90-2-08-tile_1x4.webm\", \"988d86049e884c66909d2d163a09841a\" },\n    { \"vp90-2-08-tile_1x8.webm\", \"0941902a52e9092cb010905eab16364c\" },\n    { \"vp90-2-08-tile-4x1.webm\", \"06505aade6647c583c8e00a2f582266f\" },\n    { \"vp90-2-08-tile-4x4.webm\", \"85c2299892460d76e2c600502d52bfe2\" },\n    { NULL, NULL }\n  };\n\n  DecodeFiles(files);\n}",
          "fn_code_pos": [
            [
              302,
              0
            ],
            [
              313,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "video(filename)",
          "fn_dec_pos": [
            [
              157,
              31
            ],
            [
              157,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "video",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "a3c27b704efb8f85c283cb8511a826b1826ec1978df130101ed03f293470f6da": {
          "class_code": "class VPxWorkerThreadTest : public ::testing::TestWithParam<bool> {\n protected:\n  virtual ~VPxWorkerThreadTest() {}\n  virtual void SetUp() { vpx_get_worker_interface()->init(&worker_); }\n\n  virtual void TearDown() { vpx_get_worker_interface()->end(&worker_); }\n\n  void Run(VPxWorker *worker) {\n    const bool synchronous = GetParam();\n    if (synchronous) {\n      vpx_get_worker_interface()->execute(worker);\n    } else {\n      vpx_get_worker_interface()->launch(worker);\n    }\n  }\n\n  VPxWorker worker_;\n}",
          "class_name": "VPxWorkerThreadTest",
          "class_pos": [
            [
              26,
              0
            ],
            [
              43,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct FileList {\n  const char *name;\n  const char *expected_md5;\n}",
          {
            "char": "const"
          },
          "FileList",
          [
            150,
            0
          ],
          [
            153,
            1
          ]
        ],
        [
          "struct FileList {\n  const char *name;\n  const char *expected_md5;\n}",
          {
            "char": "const"
          },
          "FileList",
          [
            150,
            0
          ],
          [
            153,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include <string>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/decode_test_driver.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/md5_helper.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/webm_video_source.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"vpx_util/vpx_thread.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/realtime_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "RealtimeTest() : EncoderTest(GET_PARAM(0)), frame_packets_(0) {}",
          "fn_code_pos": [
            [
              25,
              2
            ],
            [
              25,
              66
            ]
          ],
          "class_code": "8b2c48be810d960f50390b7e2506e00f1568bcdf79639d840805962b5adcf1e5",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              47,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RealtimeTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~RealtimeTest() {}",
          "fn_code_pos": [
            [
              26,
              2
            ],
            [
              26,
              28
            ]
          ],
          "class_code": "8b2c48be810d960f50390b7e2506e00f1568bcdf79639d840805962b5adcf1e5",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              47,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    cfg_.g_lag_in_frames = 0;\n    SetMode(::libvpx_test::kRealTime);\n  }",
          "fn_code_pos": [
            [
              28,
              2
            ],
            [
              32,
              3
            ]
          ],
          "class_code": "8b2c48be810d960f50390b7e2506e00f1568bcdf79639d840805962b5adcf1e5",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              47,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void BeginPassHook(unsigned int /*pass*/) {\n    // TODO(tomfinegan): We're changing the pass value here to make sure\n    // we get frames when real time mode is combined with |g_pass| set to\n    // VPX_RC_FIRST_PASS. This is necessary because EncoderTest::RunLoop() sets\n    // the pass value based on the mode passed into EncoderTest::SetMode(),\n    // which overrides the one specified in SetUp() above.\n    cfg_.g_pass = VPX_RC_FIRST_PASS;\n  }",
          "fn_code_pos": [
            [
              34,
              2
            ],
            [
              41,
              3
            ]
          ],
          "class_code": "8b2c48be810d960f50390b7e2506e00f1568bcdf79639d840805962b5adcf1e5",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              47,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BeginPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t * /*pkt*/) {\n    frame_packets_++;\n  }",
          "fn_code_pos": [
            [
              42,
              2
            ],
            [
              44,
              3
            ]
          ],
          "class_code": "8b2c48be810d960f50390b7e2506e00f1568bcdf79639d840805962b5adcf1e5",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              47,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(RealtimeTest, RealtimeFirstPassProducesFrames) {\n  ::libvpx_test::RandomVideoSource video;\n  video.SetSize(kVideoSourceWidth, kVideoSourceHeight);\n  video.set_limit(kFramesToEncode);\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  EXPECT_EQ(kFramesToEncode, frame_packets_);\n}",
          "fn_code_pos": [
            [
              49,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "8b2c48be810d960f50390b7e2506e00f1568bcdf79639d840805962b5adcf1e5": {
          "class_code": "class RealtimeTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWithParam<libvpx_test::TestMode> {\n protected:\n  RealtimeTest() : EncoderTest(GET_PARAM(0)), frame_packets_(0) {}\n  virtual ~RealtimeTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    cfg_.g_lag_in_frames = 0;\n    SetMode(::libvpx_test::kRealTime);\n  }\n\n  virtual void BeginPassHook(unsigned int /*pass*/) {\n    // TODO(tomfinegan): We're changing the pass value here to make sure\n    // we get frames when real time mode is combined with |g_pass| set to\n    // VPX_RC_FIRST_PASS. This is necessary because EncoderTest::RunLoop() sets\n    // the pass value based on the mode passed into EncoderTest::SetMode(),\n    // which overrides the one specified in SetUp() above.\n    cfg_.g_pass = VPX_RC_FIRST_PASS;\n  }\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t * /*pkt*/) {\n    frame_packets_++;\n  }\n\n  int frame_packets_;\n}",
          "class_name": "RealtimeTest",
          "class_pos": [
            [
              21,
              0
            ],
            [
              47,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"test/codec_factory.h\"\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/video_source.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/sum_squares_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "virtual ~SumSquaresTest() {}",
          "fn_code_pos": [
            [
              35,
              2
            ],
            [
              35,
              30
            ]
          ],
          "class_code": "6b6483e53f55639743e15f7480ff3cb3aaf7a0a73f3992ecd410fb88150d97be",
          "class_node_pos": [
            [
              33,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    ref_func_ = GET_PARAM(0);\n    tst_func_ = GET_PARAM(1);\n  }",
          "fn_code_pos": [
            [
              36,
              2
            ],
            [
              39,
              3
            ]
          ],
          "class_code": "6b6483e53f55639743e15f7480ff3cb3aaf7a0a73f3992ecd410fb88150d97be",
          "class_node_pos": [
            [
              33,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              41,
              2
            ],
            [
              41,
              62
            ]
          ],
          "class_code": "6b6483e53f55639743e15f7480ff3cb3aaf7a0a73f3992ecd410fb88150d97be",
          "class_node_pos": [
            [
              33,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(SumSquaresTest, OperationCheck) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  DECLARE_ALIGNED(16, int16_t, src[256 * 256]);\n  const int msb = 11;  // Up to 12 bit input\n  const int limit = 1 << (msb + 1);\n\n  for (int k = 0; k < kNumIterations; k++) {\n    const int size = 4 << rnd(6);  // Up to 128x128\n    int stride = 4 << rnd(7);      // Up to 256 stride\n    while (stride < size) {        // Make sure it's valid\n      stride = 4 << rnd(7);\n    }\n\n    for (int i = 0; i < size; ++i) {\n      for (int j = 0; j < size; ++j) {\n        src[i * stride + j] = rnd(2) ? rnd(limit) : -rnd(limit);\n      }\n    }\n\n    const uint64_t res_ref = ref_func_(src, stride, size);\n    uint64_t res_tst;\n    ASM_REGISTER_STATE_CHECK(res_tst = tst_func_(src, stride, size));\n\n    ASSERT_EQ(res_ref, res_tst) << \"Error: Sum Squares Test\"\n                                << \" C output does not match optimized output.\";\n  }\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              74,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SumSquaresTest, ExtremeValues) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  DECLARE_ALIGNED(16, int16_t, src[256 * 256]);\n  const int msb = 11;  // Up to 12 bit input\n  const int limit = 1 << (msb + 1);\n\n  for (int k = 0; k < kNumIterations; k++) {\n    const int size = 4 << rnd(6);  // Up to 128x128\n    int stride = 4 << rnd(7);      // Up to 256 stride\n    while (stride < size) {        // Make sure it's valid\n      stride = 4 << rnd(7);\n    }\n\n    const int val = rnd(2) ? limit - 1 : -(limit - 1);\n    for (int i = 0; i < size; ++i) {\n      for (int j = 0; j < size; ++j) {\n        src[i * stride + j] = val;\n      }\n    }\n\n    const uint64_t res_ref = ref_func_(src, stride, size);\n    uint64_t res_tst;\n    ASM_REGISTER_STATE_CHECK(res_tst = tst_func_(src, stride, size));\n\n    ASSERT_EQ(res_ref, res_tst) << \"Error: Sum Squares Test\"\n                                << \" C output does not match optimized output.\";\n  }\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              103,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*SSI16Func)(const int16_t *src, int stride, int size)",
          "fn_dec_pos": [
            [
              30,
              17
            ],
            [
              30,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "src": "int16_t",
              "stride": "int",
              "size": "int"
            },
            "return_type": "uint64_t"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              49,
              12
            ],
            [
              49,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              77,
              12
            ],
            [
              77,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        }
      ],
      "class_node_list": {
        "6b6483e53f55639743e15f7480ff3cb3aaf7a0a73f3992ecd410fb88150d97be": {
          "class_code": "class SumSquaresTest : public ::testing::TestWithParam<SumSquaresParam> {\n public:\n  virtual ~SumSquaresTest() {}\n  virtual void SetUp() {\n    ref_func_ = GET_PARAM(0);\n    tst_func_ = GET_PARAM(1);\n  }\n\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  SSI16Func ref_func_;\n  SSI16Func tst_func_;\n}",
          "class_name": "SumSquaresTest",
          "class_pos": [
            [
              33,
              0
            ],
            [
              46,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <cmath>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <cstdlib>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"vpx_ports/mem.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/lpf_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "void InitInput(Pixel *s, Pixel *ref_s, ACMRandom *rnd, const uint8_t limit,\n               const int mask, const int32_t p, const int i) {\n  uint16_t tmp_s[kNumCoeffs];\n\n  for (int j = 0; j < kNumCoeffs;) {\n    const uint8_t val = rnd->Rand8();\n    if (val & 0x80) {  // 50% chance to choose a new value.\n      tmp_s[j] = rnd->Rand16();\n      j++;\n    } else {  // 50% chance to repeat previous value in row X times.\n      int k = 0;\n      while (k++ < ((val & 0x1f) + 1) && j < kNumCoeffs) {\n        if (j < 1) {\n          tmp_s[j] = rnd->Rand16();\n        } else if (val & 0x20) {  // Increment by a value within the limit.\n          tmp_s[j] = tmp_s[j - 1] + (limit - 1);\n        } else {  // Decrement by a value within the limit.\n          tmp_s[j] = tmp_s[j - 1] - (limit - 1);\n        }\n        j++;\n      }\n    }\n  }\n\n  for (int j = 0; j < kNumCoeffs;) {\n    const uint8_t val = rnd->Rand8();\n    if (val & 0x80) {\n      j++;\n    } else {  // 50% chance to repeat previous value in column X times.\n      int k = 0;\n      while (k++ < ((val & 0x1f) + 1) && j < kNumCoeffs) {\n        if (j < 1) {\n          tmp_s[j] = rnd->Rand16();\n        } else if (val & 0x20) {  // Increment by a value within the limit.\n          tmp_s[(j % 32) * 32 + j / 32] =\n              tmp_s[((j - 1) % 32) * 32 + (j - 1) / 32] + (limit - 1);\n        } else {  // Decrement by a value within the limit.\n          tmp_s[(j % 32) * 32 + j / 32] =\n              tmp_s[((j - 1) % 32) * 32 + (j - 1) / 32] - (limit - 1);\n        }\n        j++;\n      }\n    }\n  }\n\n  for (int j = 0; j < kNumCoeffs; j++) {\n    if (i % 2) {\n      s[j] = tmp_s[j] & mask;\n    } else {\n      s[j] = tmp_s[p * (j % p) + j / p] & mask;\n    }\n    ref_s[j] = s[j];\n  }\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "InitInput",
            "parameters": {
              "s": "Pixel",
              "ref_s": "Pixel",
              "rnd": "ACMRandom",
              "limit": "uint8_t",
              "mask": "int",
              "p": "int32_t",
              "i": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "uint8_t GetOuterThresh(ACMRandom *rnd) {\n  return static_cast<uint8_t>(rnd->RandRange(3 * MAX_LOOP_FILTER + 5));\n}",
          "fn_code_pos": [
            [
              117,
              0
            ],
            [
              119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetOuterThresh",
            "parameters": {
              "rnd": "ACMRandom"
            },
            "return_type": "uint8_t"
          }
        },
        {
          "fn_code": "uint8_t GetInnerThresh(ACMRandom *rnd) {\n  return static_cast<uint8_t>(rnd->RandRange(MAX_LOOP_FILTER + 1));\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              123,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetInnerThresh",
            "parameters": {
              "rnd": "ACMRandom"
            },
            "return_type": "uint8_t"
          }
        },
        {
          "fn_code": "uint8_t GetHevThresh(ACMRandom *rnd) {\n  return static_cast<uint8_t>(rnd->RandRange(MAX_LOOP_FILTER + 1) >> 4);\n}",
          "fn_code_pos": [
            [
              125,
              0
            ],
            [
              127,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetHevThresh",
            "parameters": {
              "rnd": "ACMRandom"
            },
            "return_type": "uint8_t"
          }
        },
        {
          "fn_code": "virtual ~Loop8Test6Param() {}",
          "fn_code_pos": [
            [
              131,
              2
            ],
            [
              131,
              31
            ]
          ],
          "class_code": "4bd72651920bc51c22b772775604f9d21e83e2f35f9e93e365eff77bccc0c140",
          "class_node_pos": [
            [
              129,
              0
            ],
            [
              146,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    loopfilter_op_ = GET_PARAM(0);\n    ref_loopfilter_op_ = GET_PARAM(1);\n    bit_depth_ = GET_PARAM(2);\n    mask_ = (1 << bit_depth_) - 1;\n  }",
          "fn_code_pos": [
            [
              132,
              2
            ],
            [
              137,
              3
            ]
          ],
          "class_code": "4bd72651920bc51c22b772775604f9d21e83e2f35f9e93e365eff77bccc0c140",
          "class_node_pos": [
            [
              129,
              0
            ],
            [
              146,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              139,
              2
            ],
            [
              139,
              62
            ]
          ],
          "class_code": "4bd72651920bc51c22b772775604f9d21e83e2f35f9e93e365eff77bccc0c140",
          "class_node_pos": [
            [
              129,
              0
            ],
            [
              146,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual ~Loop8Test9Param() {}",
          "fn_code_pos": [
            [
              150,
              2
            ],
            [
              150,
              31
            ]
          ],
          "class_code": "ae768b913f9bfd64252f70bfbceee9b6671ce19e078c9899275160763ef306fc",
          "class_node_pos": [
            [
              148,
              0
            ],
            [
              165,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    loopfilter_op_ = GET_PARAM(0);\n    ref_loopfilter_op_ = GET_PARAM(1);\n    bit_depth_ = GET_PARAM(2);\n    mask_ = (1 << bit_depth_) - 1;\n  }",
          "fn_code_pos": [
            [
              151,
              2
            ],
            [
              156,
              3
            ]
          ],
          "class_code": "ae768b913f9bfd64252f70bfbceee9b6671ce19e078c9899275160763ef306fc",
          "class_node_pos": [
            [
              148,
              0
            ],
            [
              165,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              158,
              2
            ],
            [
              158,
              62
            ]
          ],
          "class_code": "ae768b913f9bfd64252f70bfbceee9b6671ce19e078c9899275160763ef306fc",
          "class_node_pos": [
            [
              148,
              0
            ],
            [
              165,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(Loop8Test6Param, OperationCheck) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  const int count_test_block = number_of_iterations;\n  const int32_t p = kNumCoeffs / 32;\n  DECLARE_ALIGNED(PIXEL_WIDTH, Pixel, s[kNumCoeffs]);\n  DECLARE_ALIGNED(PIXEL_WIDTH, Pixel, ref_s[kNumCoeffs]);\n  int err_count_total = 0;\n  int first_failure = -1;\n  for (int i = 0; i < count_test_block; ++i) {\n    int err_count = 0;\n    uint8_t tmp = GetOuterThresh(&rnd);\n    DECLARE_ALIGNED(16, const uint8_t,\n                    blimit[16]) = { tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n                                    tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp };\n    tmp = GetInnerThresh(&rnd);\n    DECLARE_ALIGNED(16, const uint8_t,\n                    limit[16]) = { tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n                                   tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp };\n    tmp = GetHevThresh(&rnd);\n    DECLARE_ALIGNED(16, const uint8_t,\n                    thresh[16]) = { tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n                                    tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp };\n    InitInput(s, ref_s, &rnd, *limit, mask_, p, i);\n#if CONFIG_VP9_HIGHBITDEPTH\n    ref_loopfilter_op_(ref_s + 8 + p * 8, p, blimit, limit, thresh, bit_depth_);\n    ASM_REGISTER_STATE_CHECK(\n        loopfilter_op_(s + 8 + p * 8, p, blimit, limit, thresh, bit_depth_));\n#else\n    ref_loopfilter_op_(ref_s + 8 + p * 8, p, blimit, limit, thresh);\n    ASM_REGISTER_STATE_CHECK(\n        loopfilter_op_(s + 8 + p * 8, p, blimit, limit, thresh));\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n    for (int j = 0; j < kNumCoeffs; ++j) {\n      err_count += ref_s[j] != s[j];\n    }\n    if (err_count && !err_count_total) {\n      first_failure = i;\n    }\n    err_count_total += err_count;\n  }\n  EXPECT_EQ(0, err_count_total)\n      << \"Error: Loop8Test6Param, C output doesn't match SSE2 \"\n         \"loopfilter output. \"\n      << \"First failed at test case \" << first_failure;\n}",
          "fn_code_pos": [
            [
              167,
              0
            ],
            [
              212,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(Loop8Test6Param, ValueCheck) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  const int count_test_block = number_of_iterations;\n  DECLARE_ALIGNED(PIXEL_WIDTH, Pixel, s[kNumCoeffs]);\n  DECLARE_ALIGNED(PIXEL_WIDTH, Pixel, ref_s[kNumCoeffs]);\n  int err_count_total = 0;\n  int first_failure = -1;\n\n  // NOTE: The code in vp9_loopfilter.c:update_sharpness computes mblim as a\n  // function of sharpness_lvl and the loopfilter lvl as:\n  // block_inside_limit = lvl >> ((sharpness_lvl > 0) + (sharpness_lvl > 4));\n  // ...\n  // memset(lfi->lfthr[lvl].mblim, (2 * (lvl + 2) + block_inside_limit),\n  //        SIMD_WIDTH);\n  // This means that the largest value for mblim will occur when sharpness_lvl\n  // is equal to 0, and lvl is equal to its greatest value (MAX_LOOP_FILTER).\n  // In this case block_inside_limit will be equal to MAX_LOOP_FILTER and\n  // therefore mblim will be equal to (2 * (lvl + 2) + block_inside_limit) =\n  // 2 * (MAX_LOOP_FILTER + 2) + MAX_LOOP_FILTER = 3 * MAX_LOOP_FILTER + 4\n\n  for (int i = 0; i < count_test_block; ++i) {\n    int err_count = 0;\n    uint8_t tmp = GetOuterThresh(&rnd);\n    DECLARE_ALIGNED(16, const uint8_t,\n                    blimit[16]) = { tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n                                    tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp };\n    tmp = GetInnerThresh(&rnd);\n    DECLARE_ALIGNED(16, const uint8_t,\n                    limit[16]) = { tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n                                   tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp };\n    tmp = GetHevThresh(&rnd);\n    DECLARE_ALIGNED(16, const uint8_t,\n                    thresh[16]) = { tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n                                    tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp };\n    int32_t p = kNumCoeffs / 32;\n    for (int j = 0; j < kNumCoeffs; ++j) {\n      s[j] = rnd.Rand16() & mask_;\n      ref_s[j] = s[j];\n    }\n#if CONFIG_VP9_HIGHBITDEPTH\n    ref_loopfilter_op_(ref_s + 8 + p * 8, p, blimit, limit, thresh, bit_depth_);\n    ASM_REGISTER_STATE_CHECK(\n        loopfilter_op_(s + 8 + p * 8, p, blimit, limit, thresh, bit_depth_));\n#else\n    ref_loopfilter_op_(ref_s + 8 + p * 8, p, blimit, limit, thresh);\n    ASM_REGISTER_STATE_CHECK(\n        loopfilter_op_(s + 8 + p * 8, p, blimit, limit, thresh));\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n    for (int j = 0; j < kNumCoeffs; ++j) {\n      err_count += ref_s[j] != s[j];\n    }\n    if (err_count && !err_count_total) {\n      first_failure = i;\n    }\n    err_count_total += err_count;\n  }\n  EXPECT_EQ(0, err_count_total)\n      << \"Error: Loop8Test6Param, C output doesn't match SSE2 \"\n         \"loopfilter output. \"\n      << \"First failed at test case \" << first_failure;\n}",
          "fn_code_pos": [
            [
              214,
              0
            ],
            [
              275,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(Loop8Test9Param, OperationCheck) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  const int count_test_block = number_of_iterations;\n  DECLARE_ALIGNED(PIXEL_WIDTH, Pixel, s[kNumCoeffs]);\n  DECLARE_ALIGNED(PIXEL_WIDTH, Pixel, ref_s[kNumCoeffs]);\n  int err_count_total = 0;\n  int first_failure = -1;\n  for (int i = 0; i < count_test_block; ++i) {\n    int err_count = 0;\n    uint8_t tmp = GetOuterThresh(&rnd);\n    DECLARE_ALIGNED(16, const uint8_t,\n                    blimit0[16]) = { tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n                                     tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp };\n    tmp = GetInnerThresh(&rnd);\n    DECLARE_ALIGNED(16, const uint8_t,\n                    limit0[16]) = { tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n                                    tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp };\n    tmp = GetHevThresh(&rnd);\n    DECLARE_ALIGNED(16, const uint8_t,\n                    thresh0[16]) = { tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n                                     tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp };\n    tmp = GetOuterThresh(&rnd);\n    DECLARE_ALIGNED(16, const uint8_t,\n                    blimit1[16]) = { tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n                                     tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp };\n    tmp = GetInnerThresh(&rnd);\n    DECLARE_ALIGNED(16, const uint8_t,\n                    limit1[16]) = { tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n                                    tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp };\n    tmp = GetHevThresh(&rnd);\n    DECLARE_ALIGNED(16, const uint8_t,\n                    thresh1[16]) = { tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n                                     tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp };\n    int32_t p = kNumCoeffs / 32;\n    const uint8_t limit = *limit0 < *limit1 ? *limit0 : *limit1;\n    InitInput(s, ref_s, &rnd, limit, mask_, p, i);\n#if CONFIG_VP9_HIGHBITDEPTH\n    ref_loopfilter_op_(ref_s + 8 + p * 8, p, blimit0, limit0, thresh0, blimit1,\n                       limit1, thresh1, bit_depth_);\n    ASM_REGISTER_STATE_CHECK(loopfilter_op_(s + 8 + p * 8, p, blimit0, limit0,\n                                            thresh0, blimit1, limit1, thresh1,\n                                            bit_depth_));\n#else\n    ref_loopfilter_op_(ref_s + 8 + p * 8, p, blimit0, limit0, thresh0, blimit1,\n                       limit1, thresh1);\n    ASM_REGISTER_STATE_CHECK(loopfilter_op_(s + 8 + p * 8, p, blimit0, limit0,\n                                            thresh0, blimit1, limit1, thresh1));\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n    for (int j = 0; j < kNumCoeffs; ++j) {\n      err_count += ref_s[j] != s[j];\n    }\n    if (err_count && !err_count_total) {\n      first_failure = i;\n    }\n    err_count_total += err_count;\n  }\n  EXPECT_EQ(0, err_count_total)\n      << \"Error: Loop8Test9Param, C output doesn't match SSE2 \"\n         \"loopfilter output. \"\n      << \"First failed at test case \" << first_failure;\n}",
          "fn_code_pos": [
            [
              277,
              0
            ],
            [
              338,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(Loop8Test9Param, ValueCheck) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  const int count_test_block = number_of_iterations;\n  DECLARE_ALIGNED(PIXEL_WIDTH, Pixel, s[kNumCoeffs]);\n  DECLARE_ALIGNED(PIXEL_WIDTH, Pixel, ref_s[kNumCoeffs]);\n  int err_count_total = 0;\n  int first_failure = -1;\n  for (int i = 0; i < count_test_block; ++i) {\n    int err_count = 0;\n    uint8_t tmp = GetOuterThresh(&rnd);\n    DECLARE_ALIGNED(16, const uint8_t,\n                    blimit0[16]) = { tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n                                     tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp };\n    tmp = GetInnerThresh(&rnd);\n    DECLARE_ALIGNED(16, const uint8_t,\n                    limit0[16]) = { tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n                                    tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp };\n    tmp = GetHevThresh(&rnd);\n    DECLARE_ALIGNED(16, const uint8_t,\n                    thresh0[16]) = { tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n                                     tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp };\n    tmp = GetOuterThresh(&rnd);\n    DECLARE_ALIGNED(16, const uint8_t,\n                    blimit1[16]) = { tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n                                     tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp };\n    tmp = GetInnerThresh(&rnd);\n    DECLARE_ALIGNED(16, const uint8_t,\n                    limit1[16]) = { tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n                                    tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp };\n    tmp = GetHevThresh(&rnd);\n    DECLARE_ALIGNED(16, const uint8_t,\n                    thresh1[16]) = { tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp,\n                                     tmp, tmp, tmp, tmp, tmp, tmp, tmp, tmp };\n    int32_t p = kNumCoeffs / 32;  // TODO(pdlf) can we have non-square here?\n    for (int j = 0; j < kNumCoeffs; ++j) {\n      s[j] = rnd.Rand16() & mask_;\n      ref_s[j] = s[j];\n    }\n#if CONFIG_VP9_HIGHBITDEPTH\n    ref_loopfilter_op_(ref_s + 8 + p * 8, p, blimit0, limit0, thresh0, blimit1,\n                       limit1, thresh1, bit_depth_);\n    ASM_REGISTER_STATE_CHECK(loopfilter_op_(s + 8 + p * 8, p, blimit0, limit0,\n                                            thresh0, blimit1, limit1, thresh1,\n                                            bit_depth_));\n#else\n    ref_loopfilter_op_(ref_s + 8 + p * 8, p, blimit0, limit0, thresh0, blimit1,\n                       limit1, thresh1);\n    ASM_REGISTER_STATE_CHECK(loopfilter_op_(s + 8 + p * 8, p, blimit0, limit0,\n                                            thresh0, blimit1, limit1, thresh1));\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n    for (int j = 0; j < kNumCoeffs; ++j) {\n      err_count += ref_s[j] != s[j];\n    }\n    if (err_count && !err_count_total) {\n      first_failure = i;\n    }\n    err_count_total += err_count;\n  }\n  EXPECT_EQ(0, err_count_total)\n      << \"Error: Loop8Test9Param, C output doesn't match SSE2\"\n         \"loopfilter output. \"\n      << \"First failed at test case \" << first_failure;\n}",
          "fn_code_pos": [
            [
              340,
              0
            ],
            [
              403,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*loop_op_t)(Pixel *s, int p, const uint8_t *blimit,\n                          const uint8_t *limit, const uint8_t *thresh, int bd)",
          "fn_dec_pos": [
            [
              41,
              13
            ],
            [
              42,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "s": "Pixel",
              "p": "int",
              "blimit": "uint8_t",
              "limit": "uint8_t",
              "thresh": "uint8_t",
              "bd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*dual_loop_op_t)(Pixel *s, int p, const uint8_t *blimit0,\n                               const uint8_t *limit0, const uint8_t *thresh0,\n                               const uint8_t *blimit1, const uint8_t *limit1,\n                               const uint8_t *thresh1, int bd)",
          "fn_dec_pos": [
            [
              43,
              13
            ],
            [
              46,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "s": "Pixel",
              "p": "int",
              "blimit0": "uint8_t",
              "limit0": "uint8_t",
              "thresh0": "uint8_t",
              "blimit1": "uint8_t",
              "limit1": "uint8_t",
              "thresh1": "uint8_t",
              "bd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*loop_op_t)(Pixel *s, int p, const uint8_t *blimit,\n                          const uint8_t *limit, const uint8_t *thresh)",
          "fn_dec_pos": [
            [
              51,
              13
            ],
            [
              52,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "s": "Pixel",
              "p": "int",
              "blimit": "uint8_t",
              "limit": "uint8_t",
              "thresh": "uint8_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*dual_loop_op_t)(Pixel *s, int p, const uint8_t *blimit0,\n                               const uint8_t *limit0, const uint8_t *thresh0,\n                               const uint8_t *blimit1, const uint8_t *limit1,\n                               const uint8_t *thresh1)",
          "fn_dec_pos": [
            [
              53,
              13
            ],
            [
              56,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "s": "Pixel",
              "p": "int",
              "blimit0": "uint8_t",
              "limit0": "uint8_t",
              "thresh0": "uint8_t",
              "blimit1": "uint8_t",
              "limit1": "uint8_t",
              "thresh1": "uint8_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              168,
              12
            ],
            [
              168,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              215,
              12
            ],
            [
              215,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              278,
              12
            ],
            [
              278,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              341,
              12
            ],
            [
              341,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        }
      ],
      "class_node_list": {
        "4bd72651920bc51c22b772775604f9d21e83e2f35f9e93e365eff77bccc0c140": {
          "class_code": "class Loop8Test6Param : public ::testing::TestWithParam<loop8_param_t> {\n public:\n  virtual ~Loop8Test6Param() {}\n  virtual void SetUp() {\n    loopfilter_op_ = GET_PARAM(0);\n    ref_loopfilter_op_ = GET_PARAM(1);\n    bit_depth_ = GET_PARAM(2);\n    mask_ = (1 << bit_depth_) - 1;\n  }\n\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  int bit_depth_;\n  int mask_;\n  loop_op_t loopfilter_op_;\n  loop_op_t ref_loopfilter_op_;\n}",
          "class_name": "Loop8Test6Param",
          "class_pos": [
            [
              129,
              0
            ],
            [
              146,
              1
            ]
          ]
        },
        "ae768b913f9bfd64252f70bfbceee9b6671ce19e078c9899275160763ef306fc": {
          "class_code": "class Loop8Test9Param : public ::testing::TestWithParam<dualloop8_param_t> {\n public:\n  virtual ~Loop8Test9Param() {}\n  virtual void SetUp() {\n    loopfilter_op_ = GET_PARAM(0);\n    ref_loopfilter_op_ = GET_PARAM(1);\n    bit_depth_ = GET_PARAM(2);\n    mask_ = (1 << bit_depth_) - 1;\n  }\n\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  int bit_depth_;\n  int mask_;\n  dual_loop_op_t loopfilter_op_;\n  dual_loop_op_t ref_loopfilter_op_;\n}",
          "class_name": "Loop8Test9Param",
          "class_pos": [
            [
              148,
              0
            ],
            [
              165,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <cmath>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <cstdlib>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_entropy.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_loopfilter.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/idct8x8_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "void reference_dct_1d(double input[8], double output[8]) {\n  const double kPi = 3.141592653589793238462643383279502884;\n  const double kInvSqrt2 = 0.707106781186547524400844362104;\n  for (int k = 0; k < 8; k++) {\n    output[k] = 0.0;\n    for (int n = 0; n < 8; n++) {\n      output[k] += input[n] * cos(kPi * (2 * n + 1) * k / 16.0);\n    }\n    if (k == 0) output[k] = output[k] * kInvSqrt2;\n  }\n}",
          "fn_code_pos": [
            [
              25,
              0
            ],
            [
              35,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reference_dct_1d",
            "parameters": {
              "input": "double",
              "output": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void reference_dct_2d(int16_t input[64], double output[64]) {\n  // First transform columns\n  for (int i = 0; i < 8; ++i) {\n    double temp_in[8], temp_out[8];\n    for (int j = 0; j < 8; ++j) temp_in[j] = input[j * 8 + i];\n    reference_dct_1d(temp_in, temp_out);\n    for (int j = 0; j < 8; ++j) output[j * 8 + i] = temp_out[j];\n  }\n  // Then transform rows\n  for (int i = 0; i < 8; ++i) {\n    double temp_in[8], temp_out[8];\n    for (int j = 0; j < 8; ++j) temp_in[j] = output[j + i * 8];\n    reference_dct_1d(temp_in, temp_out);\n    for (int j = 0; j < 8; ++j) output[j + i * 8] = temp_out[j];\n  }\n  // Scale by some magic number\n  for (int i = 0; i < 64; ++i) output[i] *= 2;\n}",
          "fn_code_pos": [
            [
              37,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reference_dct_2d",
            "parameters": {
              "input": "int16_t",
              "output": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST(VP9Idct8x8Test, AccuracyCheck) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  const int count_test_block = 10000;\n  for (int i = 0; i < count_test_block; ++i) {\n    int16_t input[64];\n    tran_low_t coeff[64];\n    double output_r[64];\n    uint8_t dst[64], src[64];\n\n    for (int j = 0; j < 64; ++j) {\n      src[j] = rnd.Rand8();\n      dst[j] = rnd.Rand8();\n    }\n    // Initialize a test block with input range [-255, 255].\n    for (int j = 0; j < 64; ++j) input[j] = src[j] - dst[j];\n\n    reference_dct_2d(input, output_r);\n    for (int j = 0; j < 64; ++j) {\n      coeff[j] = static_cast<tran_low_t>(round(output_r[j]));\n    }\n    vpx_idct8x8_64_add_c(coeff, dst, 8);\n    for (int j = 0; j < 64; ++j) {\n      const int diff = dst[j] - src[j];\n      const int error = diff * diff;\n      EXPECT_GE(1, error) << \"Error: 8x8 FDCT/IDCT has error \" << error\n                          << \" at index \" << j;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              57,
              12
            ],
            [
              57,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <math.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"vpx_ports/msvc.h\"  // for round()\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp9_end_to_end_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "int is_extension_y4m(const char *filename) {\n  const char *dot = strrchr(filename, '.');\n  if (!dot || dot == filename) {\n    return 0;\n  } else {\n    return !strcmp(dot, \".y4m\");\n  }\n}",
          "fn_code_pos": [
            [
              70,
              0
            ],
            [
              77,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "is_extension_y4m",
            "parameters": {
              "filename": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "EndToEndTestAdaptiveRDThresh()\n      : EncoderTest(GET_PARAM(0)), cpu_used_start_(GET_PARAM(1)),\n        cpu_used_end_(GET_PARAM(2)) {}",
          "fn_code_pos": [
            [
              83,
              2
            ],
            [
              85,
              38
            ]
          ],
          "class_code": "3551e6f691060422968249f49b894cd5cfa5ff0ba2b8be7d89864f094902cd3d",
          "class_node_pos": [
            [
              79,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EndToEndTestAdaptiveRDThresh",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~EndToEndTestAdaptiveRDThresh() {}",
          "fn_code_pos": [
            [
              87,
              2
            ],
            [
              87,
              44
            ]
          ],
          "class_code": "3551e6f691060422968249f49b894cd5cfa5ff0ba2b8be7d89864f094902cd3d",
          "class_node_pos": [
            [
              79,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    cfg_.g_lag_in_frames = 0;\n    cfg_.rc_end_usage = VPX_CBR;\n    cfg_.rc_buf_sz = 1000;\n    cfg_.rc_buf_initial_sz = 500;\n    cfg_.rc_buf_optimal_sz = 600;\n    dec_cfg_.threads = 4;\n  }",
          "fn_code_pos": [
            [
              89,
              2
            ],
            [
              98,
              3
            ]
          ],
          "class_code": "3551e6f691060422968249f49b894cd5cfa5ff0ba2b8be7d89864f094902cd3d",
          "class_node_pos": [
            [
              79,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, cpu_used_start_);\n      encoder->Control(VP9E_SET_ROW_MT, 1);\n      encoder->Control(VP9E_SET_TILE_COLUMNS, 2);\n    }\n    if (video->frame() == 100)\n      encoder->Control(VP8E_SET_CPUUSED, cpu_used_end_);\n  }",
          "fn_code_pos": [
            [
              100,
              2
            ],
            [
              109,
              3
            ]
          ],
          "class_code": "3551e6f691060422968249f49b894cd5cfa5ff0ba2b8be7d89864f094902cd3d",
          "class_node_pos": [
            [
              79,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "EndToEndTestLarge()\n      : EncoderTest(GET_PARAM(0)), test_video_param_(GET_PARAM(2)),\n        cpu_used_(GET_PARAM(3)), psnr_(0.0), nframes_(0),\n        encoding_mode_(GET_PARAM(1)) {\n    cyclic_refresh_ = 0;\n    denoiser_on_ = 0;\n  }",
          "fn_code_pos": [
            [
              121,
              2
            ],
            [
              127,
              3
            ]
          ],
          "class_code": "484210bce53fb2a837b50447e2112604fe096849877a890489e3a59c0ede6461",
          "class_node_pos": [
            [
              116,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EndToEndTestLarge",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~EndToEndTestLarge() {}",
          "fn_code_pos": [
            [
              129,
              2
            ],
            [
              129,
              33
            ]
          ],
          "class_code": "484210bce53fb2a837b50447e2112604fe096849877a890489e3a59c0ede6461",
          "class_node_pos": [
            [
              116,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n    if (encoding_mode_ != ::libvpx_test::kRealTime) {\n      cfg_.g_lag_in_frames = 5;\n      cfg_.rc_end_usage = VPX_VBR;\n    } else {\n      cfg_.g_lag_in_frames = 0;\n      cfg_.rc_end_usage = VPX_CBR;\n      cfg_.rc_buf_sz = 1000;\n      cfg_.rc_buf_initial_sz = 500;\n      cfg_.rc_buf_optimal_sz = 600;\n    }\n    dec_cfg_.threads = 4;\n  }",
          "fn_code_pos": [
            [
              131,
              2
            ],
            [
              145,
              3
            ]
          ],
          "class_code": "484210bce53fb2a837b50447e2112604fe096849877a890489e3a59c0ede6461",
          "class_node_pos": [
            [
              116,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void BeginPassHook(unsigned int) {\n    psnr_ = 0.0;\n    nframes_ = 0;\n  }",
          "fn_code_pos": [
            [
              147,
              2
            ],
            [
              150,
              3
            ]
          ],
          "class_code": "484210bce53fb2a837b50447e2112604fe096849877a890489e3a59c0ede6461",
          "class_node_pos": [
            [
              116,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BeginPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    psnr_ += pkt->data.psnr.psnr[0];\n    nframes_++;\n  }",
          "fn_code_pos": [
            [
              152,
              2
            ],
            [
              155,
              3
            ]
          ],
          "class_code": "484210bce53fb2a837b50447e2112604fe096849877a890489e3a59c0ede6461",
          "class_node_pos": [
            [
              116,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PSNRPktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING, 1);\n      encoder->Control(VP9E_SET_TILE_COLUMNS, 4);\n      encoder->Control(VP8E_SET_CPUUSED, cpu_used_);\n      if (encoding_mode_ != ::libvpx_test::kRealTime) {\n        encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n        encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n        encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n        encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n      } else {\n        encoder->Control(VP9E_SET_NOISE_SENSITIVITY, denoiser_on_);\n        encoder->Control(VP9E_SET_AQ_MODE, cyclic_refresh_);\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              157,
              2
            ],
            [
              173,
              3
            ]
          ],
          "class_code": "484210bce53fb2a837b50447e2112604fe096849877a890489e3a59c0ede6461",
          "class_node_pos": [
            [
              116,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "double GetAveragePsnr() const {\n    if (nframes_) return psnr_ / nframes_;\n    return 0.0;\n  }",
          "fn_code_pos": [
            [
              175,
              2
            ],
            [
              178,
              3
            ]
          ],
          "class_code": "484210bce53fb2a837b50447e2112604fe096849877a890489e3a59c0ede6461",
          "class_node_pos": [
            [
              116,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetAveragePsnr",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "double GetPsnrThreshold() {\n    return kPsnrThreshold[cpu_used_][encoding_mode_];\n  }",
          "fn_code_pos": [
            [
              180,
              2
            ],
            [
              182,
              3
            ]
          ],
          "class_code": "484210bce53fb2a837b50447e2112604fe096849877a890489e3a59c0ede6461",
          "class_node_pos": [
            [
              116,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetPsnrThreshold",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "TEST_P(EndToEndTestLarge, EndtoEndPSNRTest) {\n  cfg_.rc_target_bitrate = kBitrate;\n  cfg_.g_error_resilient = 0;\n  cfg_.g_profile = test_video_param_.profile;\n  cfg_.g_input_bit_depth = test_video_param_.input_bit_depth;\n  cfg_.g_bit_depth = test_video_param_.bit_depth;\n  init_flags_ = VPX_CODEC_USE_PSNR;\n  if (cfg_.g_bit_depth > 8) init_flags_ |= VPX_CODEC_USE_HIGHBITDEPTH;\n\n  std::unique_ptr<libvpx_test::VideoSource> video;\n  if (is_extension_y4m(test_video_param_.filename)) {\n    video.reset(new libvpx_test::Y4mVideoSource(test_video_param_.filename, 0,\n                                                kFrames));\n  } else {\n    video.reset(new libvpx_test::YUVVideoSource(\n        test_video_param_.filename, test_video_param_.fmt, kWidth, kHeight,\n        kFramerate, 1, 0, kFrames));\n  }\n  ASSERT_TRUE(video.get() != NULL);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(video.get()));\n  const double psnr = GetAveragePsnr();\n  EXPECT_GT(psnr, GetPsnrThreshold());\n}",
          "fn_code_pos": [
            [
              195,
              0
            ],
            [
              218,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(EndToEndTestLarge, EndtoEndPSNRDenoiserAQTest) {\n  cfg_.rc_target_bitrate = kBitrate;\n  cfg_.g_error_resilient = 0;\n  cfg_.g_profile = test_video_param_.profile;\n  cfg_.g_input_bit_depth = test_video_param_.input_bit_depth;\n  cfg_.g_bit_depth = test_video_param_.bit_depth;\n  init_flags_ = VPX_CODEC_USE_PSNR;\n  cyclic_refresh_ = 3;\n  denoiser_on_ = 1;\n  if (cfg_.g_bit_depth > 8) init_flags_ |= VPX_CODEC_USE_HIGHBITDEPTH;\n\n  std::unique_ptr<libvpx_test::VideoSource> video;\n  if (is_extension_y4m(test_video_param_.filename)) {\n    video.reset(new libvpx_test::Y4mVideoSource(test_video_param_.filename, 0,\n                                                kFrames));\n  } else {\n    video.reset(new libvpx_test::YUVVideoSource(\n        test_video_param_.filename, test_video_param_.fmt, kWidth, kHeight,\n        kFramerate, 1, 0, kFrames));\n  }\n  ASSERT_TRUE(video.get() != NULL);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(video.get()));\n  const double psnr = GetAveragePsnr();\n  EXPECT_GT(psnr, GetPsnrThreshold());\n}",
          "fn_code_pos": [
            [
              220,
              0
            ],
            [
              245,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(EndToEndTestAdaptiveRDThresh, EndtoEndAdaptiveRDThreshRowMT) {\n  cfg_.rc_target_bitrate = kBitrate;\n  cfg_.g_error_resilient = 0;\n  cfg_.g_threads = 2;\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              247,
              0
            ],
            [
              255,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "3551e6f691060422968249f49b894cd5cfa5ff0ba2b8be7d89864f094902cd3d": {
          "class_code": "class EndToEndTestAdaptiveRDThresh\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWith2Params<int, int> {\n protected:\n  EndToEndTestAdaptiveRDThresh()\n      : EncoderTest(GET_PARAM(0)), cpu_used_start_(GET_PARAM(1)),\n        cpu_used_end_(GET_PARAM(2)) {}\n\n  virtual ~EndToEndTestAdaptiveRDThresh() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    cfg_.g_lag_in_frames = 0;\n    cfg_.rc_end_usage = VPX_CBR;\n    cfg_.rc_buf_sz = 1000;\n    cfg_.rc_buf_initial_sz = 500;\n    cfg_.rc_buf_optimal_sz = 600;\n    dec_cfg_.threads = 4;\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, cpu_used_start_);\n      encoder->Control(VP9E_SET_ROW_MT, 1);\n      encoder->Control(VP9E_SET_TILE_COLUMNS, 2);\n    }\n    if (video->frame() == 100)\n      encoder->Control(VP8E_SET_CPUUSED, cpu_used_end_);\n  }\n\n private:\n  int cpu_used_start_;\n  int cpu_used_end_;\n}",
          "class_name": "EndToEndTestAdaptiveRDThresh",
          "class_pos": [
            [
              79,
              0
            ],
            [
              114,
              1
            ]
          ]
        },
        "484210bce53fb2a837b50447e2112604fe096849877a890489e3a59c0ede6461": {
          "class_code": "class EndToEndTestLarge\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWith3Params<libvpx_test::TestMode,\n                                                 TestVideoParam, int> {\n protected:\n  EndToEndTestLarge()\n      : EncoderTest(GET_PARAM(0)), test_video_param_(GET_PARAM(2)),\n        cpu_used_(GET_PARAM(3)), psnr_(0.0), nframes_(0),\n        encoding_mode_(GET_PARAM(1)) {\n    cyclic_refresh_ = 0;\n    denoiser_on_ = 0;\n  }\n\n  virtual ~EndToEndTestLarge() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n    if (encoding_mode_ != ::libvpx_test::kRealTime) {\n      cfg_.g_lag_in_frames = 5;\n      cfg_.rc_end_usage = VPX_VBR;\n    } else {\n      cfg_.g_lag_in_frames = 0;\n      cfg_.rc_end_usage = VPX_CBR;\n      cfg_.rc_buf_sz = 1000;\n      cfg_.rc_buf_initial_sz = 500;\n      cfg_.rc_buf_optimal_sz = 600;\n    }\n    dec_cfg_.threads = 4;\n  }\n\n  virtual void BeginPassHook(unsigned int) {\n    psnr_ = 0.0;\n    nframes_ = 0;\n  }\n\n  virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    psnr_ += pkt->data.psnr.psnr[0];\n    nframes_++;\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING, 1);\n      encoder->Control(VP9E_SET_TILE_COLUMNS, 4);\n      encoder->Control(VP8E_SET_CPUUSED, cpu_used_);\n      if (encoding_mode_ != ::libvpx_test::kRealTime) {\n        encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n        encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n        encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n        encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n      } else {\n        encoder->Control(VP9E_SET_NOISE_SENSITIVITY, denoiser_on_);\n        encoder->Control(VP9E_SET_AQ_MODE, cyclic_refresh_);\n      }\n    }\n  }\n\n  double GetAveragePsnr() const {\n    if (nframes_) return psnr_ / nframes_;\n    return 0.0;\n  }\n\n  double GetPsnrThreshold() {\n    return kPsnrThreshold[cpu_used_][encoding_mode_];\n  }\n\n  TestVideoParam test_video_param_;\n  int cpu_used_;\n  int cyclic_refresh_;\n  int denoiser_on_;\n\n private:\n  double psnr_;\n  unsigned int nframes_;\n  libvpx_test::TestMode encoding_mode_;\n}",
          "class_name": "EndToEndTestLarge",
          "class_pos": [
            [
              116,
              0
            ],
            [
              193,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "typedef struct {\n  const char *filename;\n  unsigned int input_bit_depth;\n  vpx_img_fmt fmt;\n  vpx_bit_depth_t bit_depth;\n  unsigned int profile;\n} TestVideoParam;",
          {
            "char": "const",
            "input_bit_depth": "unsigned int",
            "fmt": "vpx_img_fmt",
            "bit_depth": "vpx_bit_depth_t",
            "profile": "unsigned int"
          },
          "TestVideoParam",
          [
            36,
            0
          ],
          [
            42,
            17
          ]
        ],
        [
          "typedef struct {\n  const char *filename;\n  unsigned int input_bit_depth;\n  vpx_img_fmt fmt;\n  vpx_bit_depth_t bit_depth;\n  unsigned int profile;\n} TestVideoParam;",
          {
            "char": "const",
            "input_bit_depth": "unsigned int",
            "fmt": "vpx_img_fmt",
            "bit_depth": "vpx_bit_depth_t",
            "profile": "unsigned int"
          },
          "TestVideoParam",
          [
            36,
            0
          ],
          [
            42,
            17
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"memory\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/y4m_video_source.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/yuv_video_source.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/byte_alignment_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "ByteAlignmentTest() : video_(NULL), decoder_(NULL), md5_file_(NULL) {}",
          "fn_code_pos": [
            [
              57,
              2
            ],
            [
              57,
              72
            ]
          ],
          "class_code": "00587864ba0cb2eec1083f6ea73a3903929d0faff61b506cb360104cac04b26d",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              155,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ByteAlignmentTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    video_ = new libvpx_test::WebMVideoSource(kVP9TestFile);\n    ASSERT_TRUE(video_ != NULL);\n    video_->Init();\n    video_->Begin();\n\n    const vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n    decoder_ = new libvpx_test::VP9Decoder(cfg, 0);\n    ASSERT_TRUE(decoder_ != NULL);\n\n    OpenMd5File(kVP9Md5File);\n  }",
          "fn_code_pos": [
            [
              59,
              2
            ],
            [
              70,
              3
            ]
          ],
          "class_code": "00587864ba0cb2eec1083f6ea73a3903929d0faff61b506cb360104cac04b26d",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              155,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() {\n    if (md5_file_ != NULL) fclose(md5_file_);\n\n    delete decoder_;\n    delete video_;\n  }",
          "fn_code_pos": [
            [
              72,
              2
            ],
            [
              77,
              3
            ]
          ],
          "class_code": "00587864ba0cb2eec1083f6ea73a3903929d0faff61b506cb360104cac04b26d",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              155,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SetByteAlignment(int byte_alignment, vpx_codec_err_t expected_value) {\n    decoder_->Control(VP9_SET_BYTE_ALIGNMENT, byte_alignment, expected_value);\n  }",
          "fn_code_pos": [
            [
              79,
              2
            ],
            [
              81,
              3
            ]
          ],
          "class_code": "00587864ba0cb2eec1083f6ea73a3903929d0faff61b506cb360104cac04b26d",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              155,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetByteAlignment",
            "parameters": {
              "byte_alignment": "int",
              "expected_value": "vpx_codec_err_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "vpx_codec_err_t DecodeOneFrame(int byte_alignment_to_check) {\n    const vpx_codec_err_t res =\n        decoder_->DecodeFrame(video_->cxdata(), video_->frame_size());\n    CheckDecodedFrames(byte_alignment_to_check);\n    if (res == VPX_CODEC_OK) video_->Next();\n    return res;\n  }",
          "fn_code_pos": [
            [
              83,
              2
            ],
            [
              89,
              3
            ]
          ],
          "class_code": "00587864ba0cb2eec1083f6ea73a3903929d0faff61b506cb360104cac04b26d",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              155,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecodeOneFrame",
            "parameters": {
              "byte_alignment_to_check": "int"
            },
            "return_type": "vpx_codec_err_t"
          }
        },
        {
          "fn_code": "vpx_codec_err_t DecodeRemainingFrames(int byte_alignment_to_check) {\n    for (; video_->cxdata() != NULL; video_->Next()) {\n      const vpx_codec_err_t res =\n          decoder_->DecodeFrame(video_->cxdata(), video_->frame_size());\n      if (res != VPX_CODEC_OK) return res;\n      CheckDecodedFrames(byte_alignment_to_check);\n    }\n    return VPX_CODEC_OK;\n  }",
          "fn_code_pos": [
            [
              91,
              2
            ],
            [
              99,
              3
            ]
          ],
          "class_code": "00587864ba0cb2eec1083f6ea73a3903929d0faff61b506cb360104cac04b26d",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              155,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecodeRemainingFrames",
            "parameters": {
              "byte_alignment_to_check": "int"
            },
            "return_type": "vpx_codec_err_t"
          }
        },
        {
          "fn_code": "void CheckByteAlignment(const uint8_t *data, int byte_alignment_to_check) {\n    ASSERT_EQ(0u, reinterpret_cast<size_t>(data) % byte_alignment_to_check);\n  }",
          "fn_code_pos": [
            [
              104,
              2
            ],
            [
              106,
              3
            ]
          ],
          "class_code": "00587864ba0cb2eec1083f6ea73a3903929d0faff61b506cb360104cac04b26d",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              155,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckByteAlignment",
            "parameters": {
              "data": "uint8_t",
              "byte_alignment_to_check": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CheckDecodedFrames(int byte_alignment_to_check) {\n    libvpx_test::DxDataIterator dec_iter = decoder_->GetDxData();\n    const vpx_image_t *img;\n\n    // Get decompressed data\n    while ((img = dec_iter.Next()) != NULL) {\n      if (byte_alignment_to_check == kLegacyByteAlignment) {\n        CheckByteAlignment(img->planes[0], kLegacyYPlaneByteAlignment);\n      } else {\n        for (int i = 0; i < kNumPlanesToCheck; ++i) {\n          CheckByteAlignment(img->planes[i], byte_alignment_to_check);\n        }\n      }\n      CheckMd5(*img);\n    }\n  }",
          "fn_code_pos": [
            [
              110,
              2
            ],
            [
              125,
              3
            ]
          ],
          "class_code": "00587864ba0cb2eec1083f6ea73a3903929d0faff61b506cb360104cac04b26d",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              155,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckDecodedFrames",
            "parameters": {
              "byte_alignment_to_check": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void OpenMd5File(const std::string &md5_file_name_) {\n    md5_file_ = libvpx_test::OpenTestDataFile(md5_file_name_);\n    ASSERT_TRUE(md5_file_ != NULL)\n        << \"MD5 file open failed. Filename: \" << md5_file_name_;\n  }",
          "fn_code_pos": [
            [
              128,
              2
            ],
            [
              132,
              3
            ]
          ],
          "class_code": "00587864ba0cb2eec1083f6ea73a3903929d0faff61b506cb360104cac04b26d",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              155,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "OpenMd5File",
            "parameters": {
              "md5_file_name_": "std::string"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CheckMd5(const vpx_image_t &img) {\n    ASSERT_TRUE(md5_file_ != NULL);\n    char expected_md5[33];\n    char junk[128];\n\n    // Read correct md5 checksums.\n    const int res = fscanf(md5_file_, \"%s  %s\", expected_md5, junk);\n    ASSERT_NE(EOF, res) << \"Read md5 data failed\";\n    expected_md5[32] = '\\0';\n\n    ::libvpx_test::MD5 md5_res;\n    md5_res.Add(&img);\n    const char *const actual_md5 = md5_res.Get();\n\n    // Check md5 match.\n    ASSERT_STREQ(expected_md5, actual_md5) << \"MD5 checksums don't match\";\n  }",
          "fn_code_pos": [
            [
              134,
              2
            ],
            [
              150,
              3
            ]
          ],
          "class_code": "00587864ba0cb2eec1083f6ea73a3903929d0faff61b506cb360104cac04b26d",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              155,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckMd5",
            "parameters": {
              "img": "vpx_image_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_F(ByteAlignmentTest, SwitchByteAlignment) {\n  const int num_elements = 14;\n  const int byte_alignments[] = { 0, 32,   64, 128, 256, 512, 1024,\n                                  0, 1024, 32, 512, 64,  256, 128 };\n\n  for (int i = 0; i < num_elements; ++i) {\n    SetByteAlignment(byte_alignments[i], VPX_CODEC_OK);\n    ASSERT_EQ(VPX_CODEC_OK, DecodeOneFrame(byte_alignments[i]));\n  }\n  SetByteAlignment(byte_alignments[0], VPX_CODEC_OK);\n  ASSERT_EQ(VPX_CODEC_OK, DecodeRemainingFrames(byte_alignments[0]));\n}",
          "fn_code_pos": [
            [
              157,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ByteAlignmentTest, TestAlignment) {\n  const ByteAlignmentTestParam t = GetParam();\n  SetByteAlignment(t.byte_alignment, t.expected_value);\n  if (t.decode_remaining) {\n    ASSERT_EQ(VPX_CODEC_OK, DecodeRemainingFrames(t.byte_alignment));\n  }\n}",
          "fn_code_pos": [
            [
              170,
              0
            ],
            [
              176,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "00587864ba0cb2eec1083f6ea73a3903929d0faff61b506cb360104cac04b26d": {
          "class_code": "class ByteAlignmentTest\n    : public ::testing::TestWithParam<ByteAlignmentTestParam> {\n protected:\n  ByteAlignmentTest() : video_(NULL), decoder_(NULL), md5_file_(NULL) {}\n\n  virtual void SetUp() {\n    video_ = new libvpx_test::WebMVideoSource(kVP9TestFile);\n    ASSERT_TRUE(video_ != NULL);\n    video_->Init();\n    video_->Begin();\n\n    const vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n    decoder_ = new libvpx_test::VP9Decoder(cfg, 0);\n    ASSERT_TRUE(decoder_ != NULL);\n\n    OpenMd5File(kVP9Md5File);\n  }\n\n  virtual void TearDown() {\n    if (md5_file_ != NULL) fclose(md5_file_);\n\n    delete decoder_;\n    delete video_;\n  }\n\n  void SetByteAlignment(int byte_alignment, vpx_codec_err_t expected_value) {\n    decoder_->Control(VP9_SET_BYTE_ALIGNMENT, byte_alignment, expected_value);\n  }\n\n  vpx_codec_err_t DecodeOneFrame(int byte_alignment_to_check) {\n    const vpx_codec_err_t res =\n        decoder_->DecodeFrame(video_->cxdata(), video_->frame_size());\n    CheckDecodedFrames(byte_alignment_to_check);\n    if (res == VPX_CODEC_OK) video_->Next();\n    return res;\n  }\n\n  vpx_codec_err_t DecodeRemainingFrames(int byte_alignment_to_check) {\n    for (; video_->cxdata() != NULL; video_->Next()) {\n      const vpx_codec_err_t res =\n          decoder_->DecodeFrame(video_->cxdata(), video_->frame_size());\n      if (res != VPX_CODEC_OK) return res;\n      CheckDecodedFrames(byte_alignment_to_check);\n    }\n    return VPX_CODEC_OK;\n  }\n\n private:\n  // Check if |data| is aligned to |byte_alignment_to_check|.\n  // |byte_alignment_to_check| must be a power of 2.\n  void CheckByteAlignment(const uint8_t *data, int byte_alignment_to_check) {\n    ASSERT_EQ(0u, reinterpret_cast<size_t>(data) % byte_alignment_to_check);\n  }\n\n  // Iterate through the planes of the decoded frames and check for\n  // alignment based off |byte_alignment_to_check|.\n  void CheckDecodedFrames(int byte_alignment_to_check) {\n    libvpx_test::DxDataIterator dec_iter = decoder_->GetDxData();\n    const vpx_image_t *img;\n\n    // Get decompressed data\n    while ((img = dec_iter.Next()) != NULL) {\n      if (byte_alignment_to_check == kLegacyByteAlignment) {\n        CheckByteAlignment(img->planes[0], kLegacyYPlaneByteAlignment);\n      } else {\n        for (int i = 0; i < kNumPlanesToCheck; ++i) {\n          CheckByteAlignment(img->planes[i], byte_alignment_to_check);\n        }\n      }\n      CheckMd5(*img);\n    }\n  }\n\n  // TODO(fgalligan): Move the MD5 testing code into another class.\n  void OpenMd5File(const std::string &md5_file_name_) {\n    md5_file_ = libvpx_test::OpenTestDataFile(md5_file_name_);\n    ASSERT_TRUE(md5_file_ != NULL)\n        << \"MD5 file open failed. Filename: \" << md5_file_name_;\n  }\n\n  void CheckMd5(const vpx_image_t &img) {\n    ASSERT_TRUE(md5_file_ != NULL);\n    char expected_md5[33];\n    char junk[128];\n\n    // Read correct md5 checksums.\n    const int res = fscanf(md5_file_, \"%s  %s\", expected_md5, junk);\n    ASSERT_NE(EOF, res) << \"Read md5 data failed\";\n    expected_md5[32] = '\\0';\n\n    ::libvpx_test::MD5 md5_res;\n    md5_res.Add(&img);\n    const char *const actual_md5 = md5_res.Get();\n\n    // Check md5 match.\n    ASSERT_STREQ(expected_md5, actual_md5) << \"MD5 checksums don't match\";\n  }\n\n  libvpx_test::WebMVideoSource *video_;\n  libvpx_test::VP9Decoder *decoder_;\n  FILE *md5_file_;\n}",
          "class_name": "ByteAlignmentTest",
          "class_pos": [
            [
              54,
              0
            ],
            [
              155,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct ByteAlignmentTestParam {\n  int byte_alignment;\n  vpx_codec_err_t expected_value;\n  bool decode_remaining;\n}",
          {
            "byte_alignment": "int",
            "expected_value": "vpx_codec_err_t",
            "decode_remaining": "bool"
          },
          "ByteAlignmentTestParam",
          [
            31,
            0
          ],
          [
            35,
            1
          ]
        ],
        [
          "struct ByteAlignmentTestParam {\n  int byte_alignment;\n  vpx_codec_err_t expected_value;\n  bool decode_remaining;\n}",
          {
            "byte_alignment": "int",
            "expected_value": "vpx_codec_err_t",
            "decode_remaining": "bool"
          },
          "ByteAlignmentTestParam",
          [
            31,
            0
          ],
          [
            35,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include <string>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/decode_test_driver.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/md5_helper.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/webm_video_source.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp9_encoder_parms_get_to_decoder.cc": {
      "fn_def_list": [
        {
          "fn_code": "VpxEncoderParmsGetToDecoder()\n      : EncoderTest(GET_PARAM(0)), encode_parms(GET_PARAM(1)) {}",
          "fn_code_pos": [
            [
              61,
              2
            ],
            [
              62,
              64
            ]
          ],
          "class_code": "f2197078dac75a4375aa6ae047438ffdee1cfcf93b75c7028231a9b4e845cf4c",
          "class_node_pos": [
            [
              56,
              0
            ],
            [
              137,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VpxEncoderParmsGetToDecoder",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~VpxEncoderParmsGetToDecoder() {}",
          "fn_code_pos": [
            [
              64,
              2
            ],
            [
              64,
              43
            ]
          ],
          "class_code": "f2197078dac75a4375aa6ae047438ffdee1cfcf93b75c7028231a9b4e845cf4c",
          "class_node_pos": [
            [
              56,
              0
            ],
            [
              137,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kTwoPassGood);\n    cfg_.g_lag_in_frames = 25;\n    cfg_.g_error_resilient = encode_parms.error_resilient;\n    dec_cfg_.threads = 4;\n    test_video_ = GET_PARAM(2);\n    cfg_.rc_target_bitrate = test_video_.bitrate;\n  }",
          "fn_code_pos": [
            [
              66,
              2
            ],
            [
              74,
              3
            ]
          ],
          "class_code": "f2197078dac75a4375aa6ae047438ffdee1cfcf93b75c7028231a9b4e845cf4c",
          "class_node_pos": [
            [
              56,
              0
            ],
            [
              137,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP9E_SET_COLOR_SPACE, encode_parms.cs);\n      encoder->Control(VP9E_SET_COLOR_RANGE, encode_parms.color_range);\n      encoder->Control(VP9E_SET_LOSSLESS, encode_parms.lossless);\n      encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING,\n                       encode_parms.frame_parallel);\n      encoder->Control(VP9E_SET_TILE_ROWS, encode_parms.tile_rows);\n      encoder->Control(VP9E_SET_TILE_COLUMNS, encode_parms.tile_cols);\n      encoder->Control(VP8E_SET_CPUUSED, kCpuUsed);\n      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n      encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n      encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n      encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n      if (encode_parms.render_size[0] > 0 && encode_parms.render_size[1] > 0) {\n        encoder->Control(VP9E_SET_RENDER_SIZE, encode_parms.render_size);\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              76,
              2
            ],
            [
              95,
              3
            ]
          ],
          "class_code": "f2197078dac75a4375aa6ae047438ffdee1cfcf93b75c7028231a9b4e845cf4c",
          "class_node_pos": [
            [
              56,
              0
            ],
            [
              137,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual bool HandleDecodeResult(const vpx_codec_err_t res_dec,\n                                  const libvpx_test::VideoSource & /*video*/,\n                                  libvpx_test::Decoder *decoder) {\n    vpx_codec_ctx_t *const vp9_decoder = decoder->GetDecoder();\n    vpx_codec_alg_priv_t *const priv =\n        reinterpret_cast<vpx_codec_alg_priv_t *>(vp9_decoder->priv);\n    VP9_COMMON *const common = &priv->pbi->common;\n\n    if (encode_parms.lossless) {\n      EXPECT_EQ(0, common->base_qindex);\n      EXPECT_EQ(0, common->y_dc_delta_q);\n      EXPECT_EQ(0, common->uv_dc_delta_q);\n      EXPECT_EQ(0, common->uv_ac_delta_q);\n      EXPECT_EQ(ONLY_4X4, common->tx_mode);\n    }\n    EXPECT_EQ(encode_parms.error_resilient, common->error_resilient_mode);\n    if (encode_parms.error_resilient) {\n      EXPECT_EQ(1, common->frame_parallel_decoding_mode);\n      EXPECT_EQ(0, common->use_prev_frame_mvs);\n    } else {\n      EXPECT_EQ(encode_parms.frame_parallel,\n                common->frame_parallel_decoding_mode);\n    }\n    EXPECT_EQ(encode_parms.color_range, common->color_range);\n    EXPECT_EQ(encode_parms.cs, common->color_space);\n    if (encode_parms.render_size[0] > 0 && encode_parms.render_size[1] > 0) {\n      EXPECT_EQ(encode_parms.render_size[0], common->render_width);\n      EXPECT_EQ(encode_parms.render_size[1], common->render_height);\n    }\n    EXPECT_EQ(encode_parms.tile_cols, common->log2_tile_cols);\n    EXPECT_EQ(encode_parms.tile_rows, common->log2_tile_rows);\n\n    EXPECT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();\n    return VPX_CODEC_OK == res_dec;\n  }",
          "fn_code_pos": [
            [
              97,
              2
            ],
            [
              131,
              3
            ]
          ],
          "class_code": "f2197078dac75a4375aa6ae047438ffdee1cfcf93b75c7028231a9b4e845cf4c",
          "class_node_pos": [
            [
              56,
              0
            ],
            [
              137,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "HandleDecodeResult",
            "parameters": {
              "res_dec": "vpx_codec_err_t",
              "decoder": "libvpx_test::Decoder"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "TEST_P(VpxEncoderParmsGetToDecoder, BitstreamParms) {\n  init_flags_ = VPX_CODEC_USE_PSNR;\n\n  std::unique_ptr<libvpx_test::VideoSource> video(\n      new libvpx_test::Y4mVideoSource(test_video_.name, 0, test_video_.frames));\n  ASSERT_TRUE(video.get() != NULL);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(video.get()));\n}",
          "fn_code_pos": [
            [
              139,
              0
            ],
            [
              147,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "f2197078dac75a4375aa6ae047438ffdee1cfcf93b75c7028231a9b4e845cf4c": {
          "class_code": "class VpxEncoderParmsGetToDecoder\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWith2Params<EncodeParameters,\n                                                 EncodePerfTestVideo> {\n protected:\n  VpxEncoderParmsGetToDecoder()\n      : EncoderTest(GET_PARAM(0)), encode_parms(GET_PARAM(1)) {}\n\n  virtual ~VpxEncoderParmsGetToDecoder() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kTwoPassGood);\n    cfg_.g_lag_in_frames = 25;\n    cfg_.g_error_resilient = encode_parms.error_resilient;\n    dec_cfg_.threads = 4;\n    test_video_ = GET_PARAM(2);\n    cfg_.rc_target_bitrate = test_video_.bitrate;\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP9E_SET_COLOR_SPACE, encode_parms.cs);\n      encoder->Control(VP9E_SET_COLOR_RANGE, encode_parms.color_range);\n      encoder->Control(VP9E_SET_LOSSLESS, encode_parms.lossless);\n      encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING,\n                       encode_parms.frame_parallel);\n      encoder->Control(VP9E_SET_TILE_ROWS, encode_parms.tile_rows);\n      encoder->Control(VP9E_SET_TILE_COLUMNS, encode_parms.tile_cols);\n      encoder->Control(VP8E_SET_CPUUSED, kCpuUsed);\n      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n      encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n      encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n      encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n      if (encode_parms.render_size[0] > 0 && encode_parms.render_size[1] > 0) {\n        encoder->Control(VP9E_SET_RENDER_SIZE, encode_parms.render_size);\n      }\n    }\n  }\n\n  virtual bool HandleDecodeResult(const vpx_codec_err_t res_dec,\n                                  const libvpx_test::VideoSource & /*video*/,\n                                  libvpx_test::Decoder *decoder) {\n    vpx_codec_ctx_t *const vp9_decoder = decoder->GetDecoder();\n    vpx_codec_alg_priv_t *const priv =\n        reinterpret_cast<vpx_codec_alg_priv_t *>(vp9_decoder->priv);\n    VP9_COMMON *const common = &priv->pbi->common;\n\n    if (encode_parms.lossless) {\n      EXPECT_EQ(0, common->base_qindex);\n      EXPECT_EQ(0, common->y_dc_delta_q);\n      EXPECT_EQ(0, common->uv_dc_delta_q);\n      EXPECT_EQ(0, common->uv_ac_delta_q);\n      EXPECT_EQ(ONLY_4X4, common->tx_mode);\n    }\n    EXPECT_EQ(encode_parms.error_resilient, common->error_resilient_mode);\n    if (encode_parms.error_resilient) {\n      EXPECT_EQ(1, common->frame_parallel_decoding_mode);\n      EXPECT_EQ(0, common->use_prev_frame_mvs);\n    } else {\n      EXPECT_EQ(encode_parms.frame_parallel,\n                common->frame_parallel_decoding_mode);\n    }\n    EXPECT_EQ(encode_parms.color_range, common->color_range);\n    EXPECT_EQ(encode_parms.cs, common->color_space);\n    if (encode_parms.render_size[0] > 0 && encode_parms.render_size[1] > 0) {\n      EXPECT_EQ(encode_parms.render_size[0], common->render_width);\n      EXPECT_EQ(encode_parms.render_size[1], common->render_height);\n    }\n    EXPECT_EQ(encode_parms.tile_cols, common->log2_tile_cols);\n    EXPECT_EQ(encode_parms.tile_rows, common->log2_tile_rows);\n\n    EXPECT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();\n    return VPX_CODEC_OK == res_dec;\n  }\n\n  EncodePerfTestVideo test_video_;\n\n private:\n  EncodeParameters encode_parms;\n}",
          "class_name": "VpxEncoderParmsGetToDecoder",
          "class_pos": [
            [
              56,
              0
            ],
            [
              137,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct EncodePerfTestVideo {\n  const char *name;\n  uint32_t width;\n  uint32_t height;\n  uint32_t bitrate;\n  int frames;\n}",
          {
            "char": "const",
            "width": "uint32_t",
            "height": "uint32_t",
            "bitrate": "uint32_t",
            "frames": "int"
          },
          "EncodePerfTestVideo",
          [
            24,
            0
          ],
          [
            30,
            1
          ]
        ],
        [
          "struct EncodeParameters {\n  int32_t tile_rows;\n  int32_t tile_cols;\n  int32_t lossless;\n  int32_t error_resilient;\n  int32_t frame_parallel;\n  vpx_color_range_t color_range;\n  vpx_color_space_t cs;\n  int render_size[2];\n  // TODO(JBB): quantizers / bitrate\n}",
          {
            "tile_rows": "int32_t",
            "tile_cols": "int32_t",
            "lossless": "int32_t",
            "error_resilient": "int32_t",
            "frame_parallel": "int32_t",
            "color_range": "vpx_color_range_t",
            "cs": "vpx_color_space_t",
            "render_size[2]": "int"
          },
          "EncodeParameters",
          [
            36,
            0
          ],
          [
            46,
            1
          ]
        ],
        [
          "struct EncodePerfTestVideo {\n  const char *name;\n  uint32_t width;\n  uint32_t height;\n  uint32_t bitrate;\n  int frames;\n}",
          {
            "char": "const",
            "width": "uint32_t",
            "height": "uint32_t",
            "bitrate": "uint32_t",
            "frames": "int"
          },
          "EncodePerfTestVideo",
          [
            24,
            0
          ],
          [
            30,
            1
          ]
        ],
        [
          "struct EncodeParameters {\n  int32_t tile_rows;\n  int32_t tile_cols;\n  int32_t lossless;\n  int32_t error_resilient;\n  int32_t frame_parallel;\n  vpx_color_range_t color_range;\n  vpx_color_space_t cs;\n  int render_size[2];\n  // TODO(JBB): quantizers / bitrate\n}",
          {
            "tile_rows": "int32_t",
            "tile_cols": "int32_t",
            "lossless": "int32_t",
            "error_resilient": "int32_t",
            "frame_parallel": "int32_t",
            "color_range": "vpx_color_range_t",
            "cs": "vpx_color_space_t",
            "render_size[2]": "int"
          },
          "EncodeParameters",
          [
            36,
            0
          ],
          [
            46,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include <memory>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/y4m_video_source.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"vp9/vp9_dx_iface.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/test_vector_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "TestVectorTest() : DecoderTest(GET_PARAM(0)), md5_file_(NULL) {\n#if CONFIG_VP9_DECODER\n    resize_clips_.insert(::libvpx_test::kVP9TestVectorsResize,\n                         ::libvpx_test::kVP9TestVectorsResize +\n                             ::libvpx_test::kNumVP9TestVectorsResize);\n#endif\n  }",
          "fn_code_pos": [
            [
              41,
              2
            ],
            [
              47,
              3
            ]
          ],
          "class_code": "41a7f956a7215bedc262779d43a8072f537dcf3c27da74a0840a23f2ce0feff1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              85,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TestVectorTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~TestVectorTest() {\n    if (md5_file_) fclose(md5_file_);\n  }",
          "fn_code_pos": [
            [
              49,
              2
            ],
            [
              51,
              3
            ]
          ],
          "class_code": "41a7f956a7215bedc262779d43a8072f537dcf3c27da74a0840a23f2ce0feff1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              85,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void OpenMD5File(const std::string &md5_file_name_) {\n    md5_file_ = libvpx_test::OpenTestDataFile(md5_file_name_);\n    ASSERT_TRUE(md5_file_ != NULL)\n        << \"Md5 file open failed. Filename: \" << md5_file_name_;\n  }",
          "fn_code_pos": [
            [
              53,
              2
            ],
            [
              57,
              3
            ]
          ],
          "class_code": "41a7f956a7215bedc262779d43a8072f537dcf3c27da74a0840a23f2ce0feff1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              85,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "OpenMD5File",
            "parameters": {
              "md5_file_name_": "std::string"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void DecompressedFrameHook(const vpx_image_t &img,\n                                     const unsigned int frame_number) {\n    ASSERT_TRUE(md5_file_ != NULL);\n    char expected_md5[33];\n    char junk[128];\n\n    // Read correct md5 checksums.\n    const int res = fscanf(md5_file_, \"%s  %s\", expected_md5, junk);\n    ASSERT_NE(res, EOF) << \"Read md5 data failed\";\n    expected_md5[32] = '\\0';\n\n    ::libvpx_test::MD5 md5_res;\n    md5_res.Add(&img);\n    const char *actual_md5 = md5_res.Get();\n\n    // Check md5 match.\n    ASSERT_STREQ(expected_md5, actual_md5)\n        << \"Md5 checksums don't match: frame number = \" << frame_number;\n  }",
          "fn_code_pos": [
            [
              59,
              2
            ],
            [
              77,
              3
            ]
          ],
          "class_code": "41a7f956a7215bedc262779d43a8072f537dcf3c27da74a0840a23f2ce0feff1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              85,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecompressedFrameHook",
            "parameters": {
              "img": "vpx_image_t",
              "frame_number": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(TestVectorTest, MD5Match) {\n  const DecodeParam input = GET_PARAM(1);\n  const std::string filename = std::get<kFileName>(input);\n  vpx_codec_flags_t flags = 0;\n  vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n  char str[256];\n\n  cfg.threads = std::get<kThreads>(input);\n\n  snprintf(str, sizeof(str) / sizeof(str[0]) - 1, \"file: %s threads: %d\",\n           filename.c_str(), cfg.threads);\n  SCOPED_TRACE(str);\n\n  // Open compressed video file.\n  std::unique_ptr<libvpx_test::CompressedVideoSource> video;\n  if (filename.substr(filename.length() - 3, 3) == \"ivf\") {\n    video.reset(new libvpx_test::IVFVideoSource(filename));\n  } else if (filename.substr(filename.length() - 4, 4) == \"webm\") {\n#if CONFIG_WEBM_IO\n    video.reset(new libvpx_test::WebMVideoSource(filename));\n#else\n    fprintf(stderr, \"WebM IO is disabled, skipping test vector %s\\n\",\n            filename.c_str());\n    return;\n#endif\n  }\n  ASSERT_TRUE(video.get() != NULL);\n  video->Init();\n\n  // Construct md5 file name.\n  const std::string md5_filename = filename + \".md5\";\n  OpenMD5File(md5_filename);\n\n  // Set decode config and flags.\n  set_cfg(cfg);\n  set_flags(flags);\n\n  // Decode frame, and check the md5 matching.\n  ASSERT_NO_FATAL_FAILURE(RunLoop(video.get(), cfg));\n}",
          "fn_code_pos": [
            [
              91,
              0
            ],
            [
              130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "41a7f956a7215bedc262779d43a8072f537dcf3c27da74a0840a23f2ce0feff1": {
          "class_code": "class TestVectorTest : public ::libvpx_test::DecoderTest,\n                       public ::libvpx_test::CodecTestWithParam<DecodeParam> {\n protected:\n  TestVectorTest() : DecoderTest(GET_PARAM(0)), md5_file_(NULL) {\n#if CONFIG_VP9_DECODER\n    resize_clips_.insert(::libvpx_test::kVP9TestVectorsResize,\n                         ::libvpx_test::kVP9TestVectorsResize +\n                             ::libvpx_test::kNumVP9TestVectorsResize);\n#endif\n  }\n\n  virtual ~TestVectorTest() {\n    if (md5_file_) fclose(md5_file_);\n  }\n\n  void OpenMD5File(const std::string &md5_file_name_) {\n    md5_file_ = libvpx_test::OpenTestDataFile(md5_file_name_);\n    ASSERT_TRUE(md5_file_ != NULL)\n        << \"Md5 file open failed. Filename: \" << md5_file_name_;\n  }\n\n  virtual void DecompressedFrameHook(const vpx_image_t &img,\n                                     const unsigned int frame_number) {\n    ASSERT_TRUE(md5_file_ != NULL);\n    char expected_md5[33];\n    char junk[128];\n\n    // Read correct md5 checksums.\n    const int res = fscanf(md5_file_, \"%s  %s\", expected_md5, junk);\n    ASSERT_NE(res, EOF) << \"Read md5 data failed\";\n    expected_md5[32] = '\\0';\n\n    ::libvpx_test::MD5 md5_res;\n    md5_res.Add(&img);\n    const char *actual_md5 = md5_res.Get();\n\n    // Check md5 match.\n    ASSERT_STREQ(expected_md5, actual_md5)\n        << \"Md5 checksums don't match: frame number = \" << frame_number;\n  }\n\n#if CONFIG_VP9_DECODER\n  std::set<std::string> resize_clips_;\n#endif\n\n private:\n  FILE *md5_file_;\n}",
          "class_name": "TestVectorTest",
          "class_pos": [
            [
              38,
              0
            ],
            [
              85,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <cstdio>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <cstdlib>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <memory>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <set>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"../tools_common.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"test/decode_test_driver.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"test/ivf_video_source.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"test/md5_helper.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"test/test_vectors.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"test/webm_video_source.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/error_resilience_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "ErrorResilienceTestLarge()\n      : EncoderTest(GET_PARAM(0)), svc_support_(GET_PARAM(2)), psnr_(0.0),\n        nframes_(0), mismatch_psnr_(0.0), mismatch_nframes_(0),\n        encoding_mode_(GET_PARAM(1)) {\n    Reset();\n  }",
          "fn_code_pos": [
            [
              25,
              2
            ],
            [
              30,
              3
            ]
          ],
          "class_code": "237e90c56c8a4eebb5913df06b40803114ea22c9a1fce738199b141be05a2cfe",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ErrorResilienceTestLarge",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~ErrorResilienceTestLarge() {}",
          "fn_code_pos": [
            [
              32,
              2
            ],
            [
              32,
              40
            ]
          ],
          "class_code": "237e90c56c8a4eebb5913df06b40803114ea22c9a1fce738199b141be05a2cfe",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void Reset() {\n    error_nframes_ = 0;\n    droppable_nframes_ = 0;\n    pattern_switch_ = 0;\n  }",
          "fn_code_pos": [
            [
              34,
              2
            ],
            [
              38,
              3
            ]
          ],
          "class_code": "237e90c56c8a4eebb5913df06b40803114ea22c9a1fce738199b141be05a2cfe",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Reset",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n  }",
          "fn_code_pos": [
            [
              40,
              2
            ],
            [
              43,
              3
            ]
          ],
          "class_code": "237e90c56c8a4eebb5913df06b40803114ea22c9a1fce738199b141be05a2cfe",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void BeginPassHook(unsigned int /*pass*/) {\n    psnr_ = 0.0;\n    nframes_ = 0;\n    mismatch_psnr_ = 0.0;\n    mismatch_nframes_ = 0;\n  }",
          "fn_code_pos": [
            [
              45,
              2
            ],
            [
              50,
              3
            ]
          ],
          "class_code": "237e90c56c8a4eebb5913df06b40803114ea22c9a1fce738199b141be05a2cfe",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BeginPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    psnr_ += pkt->data.psnr.psnr[0];\n    nframes_++;\n  }",
          "fn_code_pos": [
            [
              52,
              2
            ],
            [
              55,
              3
            ]
          ],
          "class_code": "237e90c56c8a4eebb5913df06b40803114ea22c9a1fce738199b141be05a2cfe",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PSNRPktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int SetFrameFlags(int frame_num, int num_temp_layers, int pattern_switch) {\n    int frame_flags = 0;\n    if (num_temp_layers == 2) {\n      if (frame_num % 2 == 0) {\n        if (frame_num < pattern_switch || pattern_switch == 0) {\n          // Layer 0: predict from LAST and ARF, update LAST.\n          frame_flags =\n              VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF;\n        } else {\n          // Layer 0: predict from GF and ARF, update GF.\n          frame_flags = VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_UPD_LAST |\n                        VP8_EFLAG_NO_UPD_ARF;\n        }\n      } else {\n        if (frame_num < pattern_switch || pattern_switch == 0) {\n          // Layer 1: predict from L, GF, and ARF, update GF.\n          frame_flags = VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST;\n        } else {\n          // Layer 1: predict from GF and ARF, update GF.\n          frame_flags = VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_UPD_LAST |\n                        VP8_EFLAG_NO_UPD_ARF;\n        }\n      }\n    }\n    return frame_flags;\n  }",
          "fn_code_pos": [
            [
              65,
              2
            ],
            [
              90,
              3
            ]
          ],
          "class_code": "237e90c56c8a4eebb5913df06b40803114ea22c9a1fce738199b141be05a2cfe",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetFrameFlags",
            "parameters": {
              "frame_num": "int",
              "num_temp_layers": "int",
              "pattern_switch": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video) {\n    frame_flags_ &=\n        ~(VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF);\n    // For temporal layer case.\n    if (cfg_.ts_number_layers > 1) {\n      frame_flags_ =\n          SetFrameFlags(video->frame(), cfg_.ts_number_layers, pattern_switch_);\n      for (unsigned int i = 0; i < droppable_nframes_; ++i) {\n        if (droppable_frames_[i] == video->frame()) {\n          std::cout << \"Encoding droppable frame: \" << droppable_frames_[i]\n                    << \"\\n\";\n        }\n      }\n    } else {\n      if (droppable_nframes_ > 0 &&\n          (cfg_.g_pass == VPX_RC_LAST_PASS || cfg_.g_pass == VPX_RC_ONE_PASS)) {\n        for (unsigned int i = 0; i < droppable_nframes_; ++i) {\n          if (droppable_frames_[i] == video->frame()) {\n            std::cout << \"Encoding droppable frame: \" << droppable_frames_[i]\n                      << \"\\n\";\n            frame_flags_ |= (VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF |\n                             VP8_EFLAG_NO_UPD_ARF);\n            return;\n          }\n        }\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              92,
              2
            ],
            [
              119,
              3
            ]
          ],
          "class_code": "237e90c56c8a4eebb5913df06b40803114ea22c9a1fce738199b141be05a2cfe",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "libvpx_test::VideoSource"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "double GetAveragePsnr() const {\n    if (nframes_) return psnr_ / nframes_;\n    return 0.0;\n  }",
          "fn_code_pos": [
            [
              121,
              2
            ],
            [
              124,
              3
            ]
          ],
          "class_code": "237e90c56c8a4eebb5913df06b40803114ea22c9a1fce738199b141be05a2cfe",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetAveragePsnr",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "double GetAverageMismatchPsnr() const {\n    if (mismatch_nframes_) return mismatch_psnr_ / mismatch_nframes_;\n    return 0.0;\n  }",
          "fn_code_pos": [
            [
              126,
              2
            ],
            [
              129,
              3
            ]
          ],
          "class_code": "237e90c56c8a4eebb5913df06b40803114ea22c9a1fce738199b141be05a2cfe",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetAverageMismatchPsnr",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "virtual bool DoDecode() const {\n    if (error_nframes_ > 0 &&\n        (cfg_.g_pass == VPX_RC_LAST_PASS || cfg_.g_pass == VPX_RC_ONE_PASS)) {\n      for (unsigned int i = 0; i < error_nframes_; ++i) {\n        if (error_frames_[i] == nframes_ - 1) {\n          std::cout << \"             Skipping decoding frame: \"\n                    << error_frames_[i] << \"\\n\";\n          return 0;\n        }\n      }\n    }\n    return 1;\n  }",
          "fn_code_pos": [
            [
              131,
              2
            ],
            [
              143,
              3
            ]
          ],
          "class_code": "237e90c56c8a4eebb5913df06b40803114ea22c9a1fce738199b141be05a2cfe",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DoDecode",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "virtual void MismatchHook(const vpx_image_t *img1, const vpx_image_t *img2) {\n    double mismatch_psnr = compute_psnr(img1, img2);\n    mismatch_psnr_ += mismatch_psnr;\n    ++mismatch_nframes_;\n    // std::cout << \"Mismatch frame psnr: \" << mismatch_psnr << \"\\n\";\n  }",
          "fn_code_pos": [
            [
              145,
              2
            ],
            [
              150,
              3
            ]
          ],
          "class_code": "237e90c56c8a4eebb5913df06b40803114ea22c9a1fce738199b141be05a2cfe",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MismatchHook",
            "parameters": {
              "img1": "vpx_image_t",
              "img2": "vpx_image_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SetErrorFrames(int num, unsigned int *list) {\n    if (num > kMaxErrorFrames) {\n      num = kMaxErrorFrames;\n    } else if (num < 0) {\n      num = 0;\n    }\n    error_nframes_ = num;\n    for (unsigned int i = 0; i < error_nframes_; ++i) {\n      error_frames_[i] = list[i];\n    }\n  }",
          "fn_code_pos": [
            [
              152,
              2
            ],
            [
              162,
              3
            ]
          ],
          "class_code": "237e90c56c8a4eebb5913df06b40803114ea22c9a1fce738199b141be05a2cfe",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetErrorFrames",
            "parameters": {
              "num": "int",
              "list": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SetDroppableFrames(int num, unsigned int *list) {\n    if (num > kMaxDroppableFrames) {\n      num = kMaxDroppableFrames;\n    } else if (num < 0) {\n      num = 0;\n    }\n    droppable_nframes_ = num;\n    for (unsigned int i = 0; i < droppable_nframes_; ++i) {\n      droppable_frames_[i] = list[i];\n    }\n  }",
          "fn_code_pos": [
            [
              164,
              2
            ],
            [
              174,
              3
            ]
          ],
          "class_code": "237e90c56c8a4eebb5913df06b40803114ea22c9a1fce738199b141be05a2cfe",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetDroppableFrames",
            "parameters": {
              "num": "int",
              "list": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "unsigned int GetMismatchFrames() { return mismatch_nframes_; }",
          "fn_code_pos": [
            [
              176,
              2
            ],
            [
              176,
              64
            ]
          ],
          "class_code": "237e90c56c8a4eebb5913df06b40803114ea22c9a1fce738199b141be05a2cfe",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetMismatchFrames",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void SetPatternSwitch(int frame_switch) { pattern_switch_ = frame_switch; }",
          "fn_code_pos": [
            [
              178,
              2
            ],
            [
              178,
              77
            ]
          ],
          "class_code": "237e90c56c8a4eebb5913df06b40803114ea22c9a1fce738199b141be05a2cfe",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              193,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetPatternSwitch",
            "parameters": {
              "frame_switch": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(ErrorResilienceTestLarge, OnVersusOff) {\n  const vpx_rational timebase = { 33333333, 1000000000 };\n  cfg_.g_timebase = timebase;\n  cfg_.rc_target_bitrate = 2000;\n  cfg_.g_lag_in_frames = 10;\n\n  init_flags_ = VPX_CODEC_USE_PSNR;\n\n  libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                     timebase.den, timebase.num, 0, 30);\n\n  // Error resilient mode OFF.\n  cfg_.g_error_resilient = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  const double psnr_resilience_off = GetAveragePsnr();\n  EXPECT_GT(psnr_resilience_off, 25.0);\n\n  // Error resilient mode ON.\n  cfg_.g_error_resilient = 1;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  const double psnr_resilience_on = GetAveragePsnr();\n  EXPECT_GT(psnr_resilience_on, 25.0);\n\n  // Test that turning on error resilient mode hurts by 10% at most.\n  if (psnr_resilience_off > 0.0) {\n    const double psnr_ratio = psnr_resilience_on / psnr_resilience_off;\n    EXPECT_GE(psnr_ratio, 0.9);\n    EXPECT_LE(psnr_ratio, 1.1);\n  }\n}",
          "fn_code_pos": [
            [
              195,
              0
            ],
            [
              224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ErrorResilienceTestLarge, DropFramesWithoutRecovery) {\n  const vpx_rational timebase = { 33333333, 1000000000 };\n  cfg_.g_timebase = timebase;\n  cfg_.rc_target_bitrate = 500;\n  // FIXME(debargha): Fix this to work for any lag.\n  // Currently this test only works for lag = 0\n  cfg_.g_lag_in_frames = 0;\n\n  init_flags_ = VPX_CODEC_USE_PSNR;\n\n  libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                     timebase.den, timebase.num, 0, 40);\n\n  // Error resilient mode ON.\n  cfg_.g_error_resilient = 1;\n  cfg_.kf_mode = VPX_KF_DISABLED;\n\n  // Set an arbitrary set of error frames same as droppable frames.\n  // In addition to isolated loss/drop, add a long consecutive series\n  // (of size 9) of dropped frames.\n  unsigned int num_droppable_frames = 11;\n  unsigned int droppable_frame_list[] = { 5,  16, 22, 23, 24, 25,\n                                          26, 27, 28, 29, 30 };\n  SetDroppableFrames(num_droppable_frames, droppable_frame_list);\n  SetErrorFrames(num_droppable_frames, droppable_frame_list);\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  // Test that no mismatches have been found\n  std::cout << \"             Mismatch frames: \" << GetMismatchFrames() << \"\\n\";\n  EXPECT_EQ(GetMismatchFrames(), (unsigned int)0);\n\n  // Reset previously set of error/droppable frames.\n  Reset();\n\n#if 0\n  // TODO(jkoleszar): This test is disabled for the time being as too\n  // sensitive. It's not clear how to set a reasonable threshold for\n  // this behavior.\n\n  // Now set an arbitrary set of error frames that are non-droppable\n  unsigned int num_error_frames = 3;\n  unsigned int error_frame_list[] = {3, 10, 20};\n  SetErrorFrames(num_error_frames, error_frame_list);\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  // Test that dropping an arbitrary set of inter frames does not hurt too much\n  // Note the Average Mismatch PSNR is the average of the PSNR between\n  // decoded frame and encoder's version of the same frame for all frames\n  // with mismatch.\n  const double psnr_resilience_mismatch = GetAverageMismatchPsnr();\n  std::cout << \"             Mismatch PSNR: \"\n            << psnr_resilience_mismatch << \"\\n\";\n  EXPECT_GT(psnr_resilience_mismatch, 20.0);\n#endif\n}",
          "fn_code_pos": [
            [
              230,
              0
            ],
            [
              283,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ErrorResilienceTestLargeCodecControls()\n      : EncoderTest(GET_PARAM(0)), encoding_mode_(GET_PARAM(1)) {\n    Reset();\n  }",
          "fn_code_pos": [
            [
              378,
              2
            ],
            [
              381,
              3
            ]
          ],
          "class_code": "62527c8397070bb19c6969c25bef244ba3a84bdd0edc2f6c69446bc3a4b340c4",
          "class_node_pos": [
            [
              374,
              0
            ],
            [
              521,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ErrorResilienceTestLargeCodecControls",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~ErrorResilienceTestLargeCodecControls() {}",
          "fn_code_pos": [
            [
              383,
              2
            ],
            [
              383,
              53
            ]
          ],
          "class_code": "62527c8397070bb19c6969c25bef244ba3a84bdd0edc2f6c69446bc3a4b340c4",
          "class_node_pos": [
            [
              374,
              0
            ],
            [
              521,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void Reset() {\n    last_pts_ = 0;\n    tot_frame_number_ = 0;\n    // For testing up to 3 layers.\n    for (int i = 0; i < 3; ++i) {\n      bits_total_[i] = 0;\n    }\n    duration_ = 0.0;\n  }",
          "fn_code_pos": [
            [
              385,
              2
            ],
            [
              393,
              3
            ]
          ],
          "class_code": "62527c8397070bb19c6969c25bef244ba3a84bdd0edc2f6c69446bc3a4b340c4",
          "class_node_pos": [
            [
              374,
              0
            ],
            [
              521,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Reset",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n  }",
          "fn_code_pos": [
            [
              395,
              2
            ],
            [
              398,
              3
            ]
          ],
          "class_code": "62527c8397070bb19c6969c25bef244ba3a84bdd0edc2f6c69446bc3a4b340c4",
          "class_node_pos": [
            [
              374,
              0
            ],
            [
              521,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int SetFrameFlags(int frame_num, int num_temp_layers) {\n    int frame_flags = 0;\n    if (num_temp_layers == 2) {\n      if (frame_num % 2 == 0) {\n        // Layer 0: predict from L and ARF, update L.\n        frame_flags =\n            VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF;\n      } else {\n        // Layer 1: predict from L, G and ARF, and update G.\n        frame_flags = VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST |\n                      VP8_EFLAG_NO_UPD_ENTROPY;\n      }\n    } else if (num_temp_layers == 3) {\n      if (frame_num % 4 == 0) {\n        // Layer 0: predict from L, update L.\n        frame_flags = VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF |\n                      VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_REF_ARF;\n      } else if ((frame_num - 2) % 4 == 0) {\n        // Layer 1: predict from L, G,  update G.\n        frame_flags =\n            VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_REF_ARF;\n      } else if ((frame_num - 1) % 2 == 0) {\n        // Layer 2: predict from L, G, ARF; update ARG.\n        frame_flags = VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_LAST;\n      }\n    }\n    return frame_flags;\n  }",
          "fn_code_pos": [
            [
              413,
              2
            ],
            [
              440,
              3
            ]
          ],
          "class_code": "62527c8397070bb19c6969c25bef244ba3a84bdd0edc2f6c69446bc3a4b340c4",
          "class_node_pos": [
            [
              374,
              0
            ],
            [
              521,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetFrameFlags",
            "parameters": {
              "frame_num": "int",
              "num_temp_layers": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int SetLayerId(int frame_num, int num_temp_layers) {\n    int layer_id = 0;\n    if (num_temp_layers == 2) {\n      if (frame_num % 2 == 0) {\n        layer_id = 0;\n      } else {\n        layer_id = 1;\n      }\n    } else if (num_temp_layers == 3) {\n      if (frame_num % 4 == 0) {\n        layer_id = 0;\n      } else if ((frame_num - 2) % 4 == 0) {\n        layer_id = 1;\n      } else if ((frame_num - 1) % 2 == 0) {\n        layer_id = 2;\n      }\n    }\n    return layer_id;\n  }",
          "fn_code_pos": [
            [
              442,
              2
            ],
            [
              460,
              3
            ]
          ],
          "class_code": "62527c8397070bb19c6969c25bef244ba3a84bdd0edc2f6c69446bc3a4b340c4",
          "class_node_pos": [
            [
              374,
              0
            ],
            [
              521,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetLayerId",
            "parameters": {
              "frame_num": "int",
              "num_temp_layers": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                                  libvpx_test::Encoder *encoder) {\n    if (cfg_.ts_number_layers > 1) {\n      int layer_id = SetLayerId(video->frame(), cfg_.ts_number_layers);\n      int frame_flags = SetFrameFlags(video->frame(), cfg_.ts_number_layers);\n      if (video->frame() > 0) {\n        encoder->Control(VP8E_SET_TEMPORAL_LAYER_ID, layer_id);\n        encoder->Control(VP8E_SET_FRAME_FLAGS, frame_flags);\n      }\n      const vpx_rational_t tb = video->timebase();\n      timebase_ = static_cast<double>(tb.num) / tb.den;\n      duration_ = 0;\n      return;\n    }\n  }",
          "fn_code_pos": [
            [
              462,
              2
            ],
            [
              476,
              3
            ]
          ],
          "class_code": "62527c8397070bb19c6969c25bef244ba3a84bdd0edc2f6c69446bc3a4b340c4",
          "class_node_pos": [
            [
              374,
              0
            ],
            [
              521,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "libvpx_test::VideoSource",
              "encoder": "libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    // Time since last timestamp = duration.\n    vpx_codec_pts_t duration = pkt->data.frame.pts - last_pts_;\n    if (duration > 1) {\n      // Update counter for total number of frames (#frames input to encoder).\n      // Needed for setting the proper layer_id below.\n      tot_frame_number_ += static_cast<int>(duration - 1);\n    }\n    int layer = SetLayerId(tot_frame_number_, cfg_.ts_number_layers);\n    const size_t frame_size_in_bits = pkt->data.frame.sz * 8;\n    // Update the total encoded bits. For temporal layers, update the cumulative\n    // encoded bits per layer.\n    for (int i = layer; i < static_cast<int>(cfg_.ts_number_layers); ++i) {\n      bits_total_[i] += frame_size_in_bits;\n    }\n    // Update the most recent pts.\n    last_pts_ = pkt->data.frame.pts;\n    ++tot_frame_number_;\n  }",
          "fn_code_pos": [
            [
              478,
              2
            ],
            [
              496,
              3
            ]
          ],
          "class_code": "62527c8397070bb19c6969c25bef244ba3a84bdd0edc2f6c69446bc3a4b340c4",
          "class_node_pos": [
            [
              374,
              0
            ],
            [
              521,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void EndPassHook(void) {\n    duration_ = (last_pts_ + 1) * timebase_;\n    if (cfg_.ts_number_layers > 1) {\n      for (int layer = 0; layer < static_cast<int>(cfg_.ts_number_layers);\n           ++layer) {\n        if (bits_total_[layer]) {\n          // Effective file datarate:\n          effective_datarate_[layer] =\n              (bits_total_[layer] / 1000.0) / duration_;\n        }\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              498,
              2
            ],
            [
              510,
              3
            ]
          ],
          "class_code": "62527c8397070bb19c6969c25bef244ba3a84bdd0edc2f6c69446bc3a4b340c4",
          "class_node_pos": [
            [
              374,
              0
            ],
            [
              521,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EndPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(ErrorResilienceTestLargeCodecControls, CodecControl3TemporalLayers) {\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_dropframe_thresh = 1;\n  cfg_.rc_min_quantizer = 2;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.rc_dropframe_thresh = 1;\n  cfg_.g_lag_in_frames = 0;\n  cfg_.kf_mode = VPX_KF_DISABLED;\n  cfg_.g_error_resilient = 1;\n\n  // 3 Temporal layers. Framerate decimation (4, 2, 1).\n  cfg_.ts_number_layers = 3;\n  cfg_.ts_rate_decimator[0] = 4;\n  cfg_.ts_rate_decimator[1] = 2;\n  cfg_.ts_rate_decimator[2] = 1;\n  cfg_.ts_periodicity = 4;\n  cfg_.ts_layer_id[0] = 0;\n  cfg_.ts_layer_id[1] = 2;\n  cfg_.ts_layer_id[2] = 1;\n  cfg_.ts_layer_id[3] = 2;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 200);\n  for (int i = 200; i <= 800; i += 200) {\n    cfg_.rc_target_bitrate = i;\n    Reset();\n    // 40-20-40 bitrate allocation for 3 temporal layers.\n    cfg_.ts_target_bitrate[0] = 40 * cfg_.rc_target_bitrate / 100;\n    cfg_.ts_target_bitrate[1] = 60 * cfg_.rc_target_bitrate / 100;\n    cfg_.ts_target_bitrate[2] = cfg_.rc_target_bitrate;\n    ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n    for (int j = 0; j < static_cast<int>(cfg_.ts_number_layers); ++j) {\n      ASSERT_GE(effective_datarate_[j], cfg_.ts_target_bitrate[j] * 0.75)\n          << \" The datarate for the file is lower than target by too much, \"\n             \"for layer: \"\n          << j;\n      ASSERT_LE(effective_datarate_[j], cfg_.ts_target_bitrate[j] * 1.25)\n          << \" The datarate for the file is greater than target by too much, \"\n             \"for layer: \"\n          << j;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              528,
              0
            ],
            [
              573,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "237e90c56c8a4eebb5913df06b40803114ea22c9a1fce738199b141be05a2cfe": {
          "class_code": "class ErrorResilienceTestLarge\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWith2Params<libvpx_test::TestMode, bool> {\n protected:\n  ErrorResilienceTestLarge()\n      : EncoderTest(GET_PARAM(0)), svc_support_(GET_PARAM(2)), psnr_(0.0),\n        nframes_(0), mismatch_psnr_(0.0), mismatch_nframes_(0),\n        encoding_mode_(GET_PARAM(1)) {\n    Reset();\n  }\n\n  virtual ~ErrorResilienceTestLarge() {}\n\n  void Reset() {\n    error_nframes_ = 0;\n    droppable_nframes_ = 0;\n    pattern_switch_ = 0;\n  }\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n  }\n\n  virtual void BeginPassHook(unsigned int /*pass*/) {\n    psnr_ = 0.0;\n    nframes_ = 0;\n    mismatch_psnr_ = 0.0;\n    mismatch_nframes_ = 0;\n  }\n\n  virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    psnr_ += pkt->data.psnr.psnr[0];\n    nframes_++;\n  }\n\n  //\n  // Frame flags and layer id for temporal layers.\n  // For two layers, test pattern is:\n  //   1     3\n  // 0    2     .....\n  // LAST is updated on base/layer 0, GOLDEN  updated on layer 1.\n  // Non-zero pattern_switch parameter means pattern will switch to\n  // not using LAST for frame_num >= pattern_switch.\n  int SetFrameFlags(int frame_num, int num_temp_layers, int pattern_switch) {\n    int frame_flags = 0;\n    if (num_temp_layers == 2) {\n      if (frame_num % 2 == 0) {\n        if (frame_num < pattern_switch || pattern_switch == 0) {\n          // Layer 0: predict from LAST and ARF, update LAST.\n          frame_flags =\n              VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF;\n        } else {\n          // Layer 0: predict from GF and ARF, update GF.\n          frame_flags = VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_UPD_LAST |\n                        VP8_EFLAG_NO_UPD_ARF;\n        }\n      } else {\n        if (frame_num < pattern_switch || pattern_switch == 0) {\n          // Layer 1: predict from L, GF, and ARF, update GF.\n          frame_flags = VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST;\n        } else {\n          // Layer 1: predict from GF and ARF, update GF.\n          frame_flags = VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_UPD_LAST |\n                        VP8_EFLAG_NO_UPD_ARF;\n        }\n      }\n    }\n    return frame_flags;\n  }\n\n  virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video) {\n    frame_flags_ &=\n        ~(VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF);\n    // For temporal layer case.\n    if (cfg_.ts_number_layers > 1) {\n      frame_flags_ =\n          SetFrameFlags(video->frame(), cfg_.ts_number_layers, pattern_switch_);\n      for (unsigned int i = 0; i < droppable_nframes_; ++i) {\n        if (droppable_frames_[i] == video->frame()) {\n          std::cout << \"Encoding droppable frame: \" << droppable_frames_[i]\n                    << \"\\n\";\n        }\n      }\n    } else {\n      if (droppable_nframes_ > 0 &&\n          (cfg_.g_pass == VPX_RC_LAST_PASS || cfg_.g_pass == VPX_RC_ONE_PASS)) {\n        for (unsigned int i = 0; i < droppable_nframes_; ++i) {\n          if (droppable_frames_[i] == video->frame()) {\n            std::cout << \"Encoding droppable frame: \" << droppable_frames_[i]\n                      << \"\\n\";\n            frame_flags_ |= (VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF |\n                             VP8_EFLAG_NO_UPD_ARF);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  double GetAveragePsnr() const {\n    if (nframes_) return psnr_ / nframes_;\n    return 0.0;\n  }\n\n  double GetAverageMismatchPsnr() const {\n    if (mismatch_nframes_) return mismatch_psnr_ / mismatch_nframes_;\n    return 0.0;\n  }\n\n  virtual bool DoDecode() const {\n    if (error_nframes_ > 0 &&\n        (cfg_.g_pass == VPX_RC_LAST_PASS || cfg_.g_pass == VPX_RC_ONE_PASS)) {\n      for (unsigned int i = 0; i < error_nframes_; ++i) {\n        if (error_frames_[i] == nframes_ - 1) {\n          std::cout << \"             Skipping decoding frame: \"\n                    << error_frames_[i] << \"\\n\";\n          return 0;\n        }\n      }\n    }\n    return 1;\n  }\n\n  virtual void MismatchHook(const vpx_image_t *img1, const vpx_image_t *img2) {\n    double mismatch_psnr = compute_psnr(img1, img2);\n    mismatch_psnr_ += mismatch_psnr;\n    ++mismatch_nframes_;\n    // std::cout << \"Mismatch frame psnr: \" << mismatch_psnr << \"\\n\";\n  }\n\n  void SetErrorFrames(int num, unsigned int *list) {\n    if (num > kMaxErrorFrames) {\n      num = kMaxErrorFrames;\n    } else if (num < 0) {\n      num = 0;\n    }\n    error_nframes_ = num;\n    for (unsigned int i = 0; i < error_nframes_; ++i) {\n      error_frames_[i] = list[i];\n    }\n  }\n\n  void SetDroppableFrames(int num, unsigned int *list) {\n    if (num > kMaxDroppableFrames) {\n      num = kMaxDroppableFrames;\n    } else if (num < 0) {\n      num = 0;\n    }\n    droppable_nframes_ = num;\n    for (unsigned int i = 0; i < droppable_nframes_; ++i) {\n      droppable_frames_[i] = list[i];\n    }\n  }\n\n  unsigned int GetMismatchFrames() { return mismatch_nframes_; }\n\n  void SetPatternSwitch(int frame_switch) { pattern_switch_ = frame_switch; }\n\n  bool svc_support_;\n\n private:\n  double psnr_;\n  unsigned int nframes_;\n  unsigned int error_nframes_;\n  unsigned int droppable_nframes_;\n  unsigned int pattern_switch_;\n  double mismatch_psnr_;\n  unsigned int mismatch_nframes_;\n  unsigned int error_frames_[kMaxErrorFrames];\n  unsigned int droppable_frames_[kMaxDroppableFrames];\n  libvpx_test::TestMode encoding_mode_;\n}",
          "class_name": "ErrorResilienceTestLarge",
          "class_pos": [
            [
              21,
              0
            ],
            [
              193,
              1
            ]
          ]
        },
        "62527c8397070bb19c6969c25bef244ba3a84bdd0edc2f6c69446bc3a4b340c4": {
          "class_code": "class ErrorResilienceTestLargeCodecControls\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWithParam<libvpx_test::TestMode> {\n protected:\n  ErrorResilienceTestLargeCodecControls()\n      : EncoderTest(GET_PARAM(0)), encoding_mode_(GET_PARAM(1)) {\n    Reset();\n  }\n\n  virtual ~ErrorResilienceTestLargeCodecControls() {}\n\n  void Reset() {\n    last_pts_ = 0;\n    tot_frame_number_ = 0;\n    // For testing up to 3 layers.\n    for (int i = 0; i < 3; ++i) {\n      bits_total_[i] = 0;\n    }\n    duration_ = 0.0;\n  }\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n  }\n\n  //\n  // Frame flags and layer id for temporal layers.\n  //\n\n  // For two layers, test pattern is:\n  //   1     3\n  // 0    2     .....\n  // For three layers, test pattern is:\n  //   1      3    5      7\n  //      2           6\n  // 0          4            ....\n  // LAST is always update on base/layer 0, GOLDEN is updated on layer 1,\n  // and ALTREF is updated on top layer for 3 layer pattern.\n  int SetFrameFlags(int frame_num, int num_temp_layers) {\n    int frame_flags = 0;\n    if (num_temp_layers == 2) {\n      if (frame_num % 2 == 0) {\n        // Layer 0: predict from L and ARF, update L.\n        frame_flags =\n            VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF;\n      } else {\n        // Layer 1: predict from L, G and ARF, and update G.\n        frame_flags = VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST |\n                      VP8_EFLAG_NO_UPD_ENTROPY;\n      }\n    } else if (num_temp_layers == 3) {\n      if (frame_num % 4 == 0) {\n        // Layer 0: predict from L, update L.\n        frame_flags = VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF |\n                      VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_REF_ARF;\n      } else if ((frame_num - 2) % 4 == 0) {\n        // Layer 1: predict from L, G,  update G.\n        frame_flags =\n            VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_REF_ARF;\n      } else if ((frame_num - 1) % 2 == 0) {\n        // Layer 2: predict from L, G, ARF; update ARG.\n        frame_flags = VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_LAST;\n      }\n    }\n    return frame_flags;\n  }\n\n  int SetLayerId(int frame_num, int num_temp_layers) {\n    int layer_id = 0;\n    if (num_temp_layers == 2) {\n      if (frame_num % 2 == 0) {\n        layer_id = 0;\n      } else {\n        layer_id = 1;\n      }\n    } else if (num_temp_layers == 3) {\n      if (frame_num % 4 == 0) {\n        layer_id = 0;\n      } else if ((frame_num - 2) % 4 == 0) {\n        layer_id = 1;\n      } else if ((frame_num - 1) % 2 == 0) {\n        layer_id = 2;\n      }\n    }\n    return layer_id;\n  }\n\n  virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                                  libvpx_test::Encoder *encoder) {\n    if (cfg_.ts_number_layers > 1) {\n      int layer_id = SetLayerId(video->frame(), cfg_.ts_number_layers);\n      int frame_flags = SetFrameFlags(video->frame(), cfg_.ts_number_layers);\n      if (video->frame() > 0) {\n        encoder->Control(VP8E_SET_TEMPORAL_LAYER_ID, layer_id);\n        encoder->Control(VP8E_SET_FRAME_FLAGS, frame_flags);\n      }\n      const vpx_rational_t tb = video->timebase();\n      timebase_ = static_cast<double>(tb.num) / tb.den;\n      duration_ = 0;\n      return;\n    }\n  }\n\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    // Time since last timestamp = duration.\n    vpx_codec_pts_t duration = pkt->data.frame.pts - last_pts_;\n    if (duration > 1) {\n      // Update counter for total number of frames (#frames input to encoder).\n      // Needed for setting the proper layer_id below.\n      tot_frame_number_ += static_cast<int>(duration - 1);\n    }\n    int layer = SetLayerId(tot_frame_number_, cfg_.ts_number_layers);\n    const size_t frame_size_in_bits = pkt->data.frame.sz * 8;\n    // Update the total encoded bits. For temporal layers, update the cumulative\n    // encoded bits per layer.\n    for (int i = layer; i < static_cast<int>(cfg_.ts_number_layers); ++i) {\n      bits_total_[i] += frame_size_in_bits;\n    }\n    // Update the most recent pts.\n    last_pts_ = pkt->data.frame.pts;\n    ++tot_frame_number_;\n  }\n\n  virtual void EndPassHook(void) {\n    duration_ = (last_pts_ + 1) * timebase_;\n    if (cfg_.ts_number_layers > 1) {\n      for (int layer = 0; layer < static_cast<int>(cfg_.ts_number_layers);\n           ++layer) {\n        if (bits_total_[layer]) {\n          // Effective file datarate:\n          effective_datarate_[layer] =\n              (bits_total_[layer] / 1000.0) / duration_;\n        }\n      }\n    }\n  }\n\n  double effective_datarate_[3];\n\n private:\n  libvpx_test::TestMode encoding_mode_;\n  vpx_codec_pts_t last_pts_;\n  double timebase_;\n  int64_t bits_total_[3];\n  double duration_;\n  int tot_frame_number_;\n}",
          "class_name": "ErrorResilienceTestLargeCodecControls",
          "class_pos": [
            [
              374,
              0
            ],
            [
              521,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/predict_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "PredictTestBase()\n      : width_(GET_PARAM(0)), height_(GET_PARAM(1)), predict_(GET_PARAM(2)),\n        src_(NULL), padded_dst_(NULL), dst_(NULL), dst_c_(NULL) {}",
          "fn_code_pos": [
            [
              41,
              2
            ],
            [
              43,
              66
            ]
          ],
          "class_code": "ce6b8f5a1bf7c527256c444b24db928172be856b18529ed520b0974b3aade72d",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PredictTestBase",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    src_ = new uint8_t[kSrcSize];\n    ASSERT_TRUE(src_ != NULL);\n\n    // padded_dst_ provides a buffer of kBorderSize around the destination\n    // memory to facilitate detecting out of bounds writes.\n    dst_stride_ = kBorderSize + width_ + kBorderSize;\n    padded_dst_size_ = dst_stride_ * (kBorderSize + height_ + kBorderSize);\n    padded_dst_ =\n        reinterpret_cast<uint8_t *>(vpx_memalign(16, padded_dst_size_));\n    ASSERT_TRUE(padded_dst_ != NULL);\n    dst_ = padded_dst_ + (kBorderSize * dst_stride_) + kBorderSize;\n\n    dst_c_ = new uint8_t[16 * 16];\n    ASSERT_TRUE(dst_c_ != NULL);\n\n    memset(src_, 0, kSrcSize);\n    memset(padded_dst_, 128, padded_dst_size_);\n    memset(dst_c_, 0, 16 * 16);\n  }",
          "fn_code_pos": [
            [
              45,
              2
            ],
            [
              64,
              3
            ]
          ],
          "class_code": "ce6b8f5a1bf7c527256c444b24db928172be856b18529ed520b0974b3aade72d",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() {\n    delete[] src_;\n    src_ = NULL;\n    vpx_free(padded_dst_);\n    padded_dst_ = NULL;\n    dst_ = NULL;\n    delete[] dst_c_;\n    dst_c_ = NULL;\n    libvpx_test::ClearSystemState();\n  }",
          "fn_code_pos": [
            [
              66,
              2
            ],
            [
              75,
              3
            ]
          ],
          "class_code": "ce6b8f5a1bf7c527256c444b24db928172be856b18529ed520b0974b3aade72d",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "bool CompareBuffers(const uint8_t *a, int a_stride, const uint8_t *b,\n                      int b_stride) const {\n    for (int height = 0; height < height_; ++height) {\n      EXPECT_EQ(0, memcmp(a + height * a_stride, b + height * b_stride,\n                          sizeof(*a) * width_))\n          << \"Row \" << height << \" does not match.\";\n    }\n\n    return !HasFailure();\n  }",
          "fn_code_pos": [
            [
              94,
              2
            ],
            [
              103,
              3
            ]
          ],
          "class_code": "ce6b8f5a1bf7c527256c444b24db928172be856b18529ed520b0974b3aade72d",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CompareBuffers",
            "parameters": {
              "a": "uint8_t",
              "a_stride": "int",
              "b": "uint8_t",
              "b_stride": "int"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "bool CheckBorder(const uint8_t *a, int a_size, const uint8_t *b, int b_width,\n                   int b_height, int b_stride, uint8_t c) const {\n    const uint8_t *a_end = a + a_size;\n    const int b_size = (b_stride * b_height) + b_width;\n    const uint8_t *b_end = b + b_size;\n    const int left_border = (b_stride - b_width) / 2;\n    const int right_border = left_border + ((b_stride - b_width) % 2);\n\n    EXPECT_GE(b - left_border, a) << \"'b' does not start within 'a'\";\n    EXPECT_LE(b_end + right_border, a_end) << \"'b' does not end within 'a'\";\n\n    // Top border.\n    for (int pixel = 0; pixel < b - a - left_border; ++pixel) {\n      EXPECT_EQ(c, a[pixel]) << \"Mismatch at \" << pixel << \" in top border.\";\n    }\n\n    // Left border.\n    for (int height = 0; height < b_height; ++height) {\n      for (int width = left_border; width > 0; --width) {\n        EXPECT_EQ(c, b[height * b_stride - width])\n            << \"Mismatch at row \" << height << \" column \" << left_border - width\n            << \" in left border.\";\n      }\n    }\n\n    // Right border.\n    for (int height = 0; height < b_height; ++height) {\n      for (int width = b_width; width < b_width + right_border; ++width) {\n        EXPECT_EQ(c, b[height * b_stride + width])\n            << \"Mismatch at row \" << height << \" column \" << width - b_width\n            << \" in right border.\";\n      }\n    }\n\n    // Bottom border.\n    for (int pixel = static_cast<int>(b - a + b_size); pixel < a_size;\n         ++pixel) {\n      EXPECT_EQ(c, a[pixel]) << \"Mismatch at \" << pixel << \" in bottom border.\";\n    }\n\n    return !HasFailure();\n  }",
          "fn_code_pos": [
            [
              108,
              2
            ],
            [
              149,
              3
            ]
          ],
          "class_code": "ce6b8f5a1bf7c527256c444b24db928172be856b18529ed520b0974b3aade72d",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckBorder",
            "parameters": {
              "a": "uint8_t",
              "a_size": "int",
              "b": "uint8_t",
              "b_width": "int",
              "b_height": "int",
              "b_stride": "int",
              "c": "uint8_t"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "void TestWithRandomData(PredictFunc reference) {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n\n    // Run tests for almost all possible offsets.\n    for (int xoffset = 0; xoffset < 8; ++xoffset) {\n      for (int yoffset = 0; yoffset < 8; ++yoffset) {\n        if (xoffset == 0 && yoffset == 0) {\n          // This represents a copy which is not required to be handled by this\n          // module.\n          continue;\n        }\n\n        for (int i = 0; i < kSrcSize; ++i) {\n          src_[i] = rnd.Rand8();\n        }\n        reference(&src_[kSrcStride * 2 + 2], kSrcStride, xoffset, yoffset,\n                  dst_c_, 16);\n\n        ASM_REGISTER_STATE_CHECK(predict_(&src_[kSrcStride * 2 + 2], kSrcStride,\n                                          xoffset, yoffset, dst_, dst_stride_));\n\n        ASSERT_TRUE(CompareBuffers(dst_c_, 16, dst_, dst_stride_));\n        ASSERT_TRUE(CheckBorder(padded_dst_, padded_dst_size_, dst_, width_,\n                                height_, dst_stride_, 128));\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              151,
              2
            ],
            [
              177,
              3
            ]
          ],
          "class_code": "ce6b8f5a1bf7c527256c444b24db928172be856b18529ed520b0974b3aade72d",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TestWithRandomData",
            "parameters": {
              "reference": "PredictFunc"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void TestWithUnalignedDst(PredictFunc reference) {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n\n    // Only the 4x4 need to be able to handle unaligned writes.\n    if (width_ == 4 && height_ == 4) {\n      for (int xoffset = 0; xoffset < 8; ++xoffset) {\n        for (int yoffset = 0; yoffset < 8; ++yoffset) {\n          if (xoffset == 0 && yoffset == 0) {\n            continue;\n          }\n          for (int i = 0; i < kSrcSize; ++i) {\n            src_[i] = rnd.Rand8();\n          }\n          reference(&src_[kSrcStride * 2 + 2], kSrcStride, xoffset, yoffset,\n                    dst_c_, 16);\n\n          for (int i = 1; i < 4; ++i) {\n            memset(padded_dst_, 128, padded_dst_size_);\n\n            ASM_REGISTER_STATE_CHECK(predict_(&src_[kSrcStride * 2 + 2],\n                                              kSrcStride, xoffset, yoffset,\n                                              dst_ + i, dst_stride_ + i));\n\n            ASSERT_TRUE(CompareBuffers(dst_c_, 16, dst_ + i, dst_stride_ + i));\n            ASSERT_TRUE(CheckBorder(padded_dst_, padded_dst_size_, dst_ + i,\n                                    width_, height_, dst_stride_ + i, 128));\n          }\n        }\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              179,
              2
            ],
            [
              209,
              3
            ]
          ],
          "class_code": "ce6b8f5a1bf7c527256c444b24db928172be856b18529ed520b0974b3aade72d",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TestWithUnalignedDst",
            "parameters": {
              "reference": "PredictFunc"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Run() {\n    for (int xoffset = 0; xoffset < 8; ++xoffset) {\n      for (int yoffset = 0; yoffset < 8; ++yoffset) {\n        if (xoffset == 0 && yoffset == 0) {\n          continue;\n        }\n\n        predict_(&src_[kSrcStride * 2 + 2], kSrcStride, xoffset, yoffset, dst_,\n                 dst_stride_);\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              211,
              2
            ],
            [
              222,
              3
            ]
          ],
          "class_code": "ce6b8f5a1bf7c527256c444b24db928172be856b18529ed520b0974b3aade72d",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Run",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(SixtapPredictTest, TestWithRandomData) {\n  TestWithRandomData(vp8_sixtap_predict16x16_c);\n}",
          "fn_code_pos": [
            [
              227,
              0
            ],
            [
              229,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SixtapPredictTest, TestWithUnalignedDst) {\n  TestWithUnalignedDst(vp8_sixtap_predict16x16_c);\n}",
          "fn_code_pos": [
            [
              230,
              0
            ],
            [
              232,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SixtapPredictTest, TestWithPresetData) {\n  // Test input\n  static const uint8_t kTestData[kSrcSize] = {\n    184, 4,   191, 82,  92,  41,  0,   1,   226, 236, 172, 20,  182, 42,  226,\n    177, 79,  94,  77,  179, 203, 206, 198, 22,  192, 19,  75,  17,  192, 44,\n    233, 120, 48,  168, 203, 141, 210, 203, 143, 180, 184, 59,  201, 110, 102,\n    171, 32,  182, 10,  109, 105, 213, 60,  47,  236, 253, 67,  55,  14,  3,\n    99,  247, 124, 148, 159, 71,  34,  114, 19,  177, 38,  203, 237, 239, 58,\n    83,  155, 91,  10,  166, 201, 115, 124, 5,   163, 104, 2,   231, 160, 16,\n    234, 4,   8,   103, 153, 167, 174, 187, 26,  193, 109, 64,  141, 90,  48,\n    200, 174, 204, 36,  184, 114, 237, 43,  238, 242, 207, 86,  245, 182, 247,\n    6,   161, 251, 14,  8,   148, 182, 182, 79,  208, 120, 188, 17,  6,   23,\n    65,  206, 197, 13,  242, 126, 128, 224, 170, 110, 211, 121, 197, 200, 47,\n    188, 207, 208, 184, 221, 216, 76,  148, 143, 156, 100, 8,   89,  117, 14,\n    112, 183, 221, 54,  197, 208, 180, 69,  176, 94,  180, 131, 215, 121, 76,\n    7,   54,  28,  216, 238, 249, 176, 58,  142, 64,  215, 242, 72,  49,  104,\n    87,  161, 32,  52,  216, 230, 4,   141, 44,  181, 235, 224, 57,  195, 89,\n    134, 203, 144, 162, 163, 126, 156, 84,  185, 42,  148, 145, 29,  221, 194,\n    134, 52,  100, 166, 105, 60,  140, 110, 201, 184, 35,  181, 153, 93,  121,\n    243, 227, 68,  131, 134, 232, 2,   35,  60,  187, 77,  209, 76,  106, 174,\n    15,  241, 227, 115, 151, 77,  175, 36,  187, 121, 221, 223, 47,  118, 61,\n    168, 105, 32,  237, 236, 167, 213, 238, 202, 17,  170, 24,  226, 247, 131,\n    145, 6,   116, 117, 121, 11,  194, 41,  48,  126, 162, 13,  93,  209, 131,\n    154, 122, 237, 187, 103, 217, 99,  60,  200, 45,  78,  115, 69,  49,  106,\n    200, 194, 112, 60,  56,  234, 72,  251, 19,  120, 121, 182, 134, 215, 135,\n    10,  114, 2,   247, 46,  105, 209, 145, 165, 153, 191, 243, 12,  5,   36,\n    119, 206, 231, 231, 11,  32,  209, 83,  27,  229, 204, 149, 155, 83,  109,\n    35,  93,  223, 37,  84,  14,  142, 37,  160, 52,  191, 96,  40,  204, 101,\n    77,  67,  52,  53,  43,  63,  85,  253, 147, 113, 226, 96,  6,   125, 179,\n    115, 161, 17,  83,  198, 101, 98,  85,  139, 3,   137, 75,  99,  178, 23,\n    201, 255, 91,  253, 52,  134, 60,  138, 131, 208, 251, 101, 48,  2,   227,\n    228, 118, 132, 245, 202, 75,  91,  44,  160, 231, 47,  41,  50,  147, 220,\n    74,  92,  219, 165, 89,  16\n  };\n\n  // Expected results for xoffset = 2 and yoffset = 2.\n  static const int kExpectedDstStride = 16;\n  static const uint8_t kExpectedDst[256] = {\n    117, 102, 74,  135, 42,  98,  175, 206, 70,  73,  222, 197, 50,  24,  39,\n    49,  38,  105, 90,  47,  169, 40,  171, 215, 200, 73,  109, 141, 53,  85,\n    177, 164, 79,  208, 124, 89,  212, 18,  81,  145, 151, 164, 217, 153, 91,\n    154, 102, 102, 159, 75,  164, 152, 136, 51,  213, 219, 186, 116, 193, 224,\n    186, 36,  231, 208, 84,  211, 155, 167, 35,  59,  42,  76,  216, 149, 73,\n    201, 78,  149, 184, 100, 96,  196, 189, 198, 188, 235, 195, 117, 129, 120,\n    129, 49,  25,  133, 113, 69,  221, 114, 70,  143, 99,  157, 108, 189, 140,\n    78,  6,   55,  65,  240, 255, 245, 184, 72,  90,  100, 116, 131, 39,  60,\n    234, 167, 33,  160, 88,  185, 200, 157, 159, 176, 127, 151, 138, 102, 168,\n    106, 170, 86,  82,  219, 189, 76,  33,  115, 197, 106, 96,  198, 136, 97,\n    141, 237, 151, 98,  137, 191, 185, 2,   57,  95,  142, 91,  255, 185, 97,\n    137, 76,  162, 94,  173, 131, 193, 161, 81,  106, 72,  135, 222, 234, 137,\n    66,  137, 106, 243, 210, 147, 95,  15,  137, 110, 85,  66,  16,  96,  167,\n    147, 150, 173, 203, 140, 118, 196, 84,  147, 160, 19,  95,  101, 123, 74,\n    132, 202, 82,  166, 12,  131, 166, 189, 170, 159, 85,  79,  66,  57,  152,\n    132, 203, 194, 0,   1,   56,  146, 180, 224, 156, 28,  83,  181, 79,  76,\n    80,  46,  160, 175, 59,  106, 43,  87,  75,  136, 85,  189, 46,  71,  200,\n    90\n  };\n\n  ASM_REGISTER_STATE_CHECK(\n      predict_(const_cast<uint8_t *>(kTestData) + kSrcStride * 2 + 2,\n               kSrcStride, 2, 2, dst_, dst_stride_));\n\n  ASSERT_TRUE(\n      CompareBuffers(kExpectedDst, kExpectedDstStride, dst_, dst_stride_));\n}",
          "fn_code_pos": [
            [
              234,
              0
            ],
            [
              298,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(BilinearPredictTest, TestWithRandomData) {\n  TestWithRandomData(vp8_bilinear_predict16x16_c);\n}",
          "fn_code_pos": [
            [
              354,
              0
            ],
            [
              356,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(BilinearPredictTest, TestWithUnalignedDst) {\n  TestWithUnalignedDst(vp8_bilinear_predict16x16_c);\n}",
          "fn_code_pos": [
            [
              357,
              0
            ],
            [
              359,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(BilinearPredictTest, DISABLED_Speed) {\n  const int kCountSpeedTestBlock = 5000000 / (width_ * height_);\n  RunNTimes(kCountSpeedTestBlock);\n\n  char title[16];\n  snprintf(title, sizeof(title), \"%dx%d\", width_, height_);\n  PrintMedian(title);\n}",
          "fn_code_pos": [
            [
              360,
              0
            ],
            [
              367,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*PredictFunc)(uint8_t *src_ptr, int src_pixels_per_line,\n                            int xoffset, int yoffset, uint8_t *dst_ptr,\n                            int dst_pitch)",
          "fn_dec_pos": [
            [
              32,
              13
            ],
            [
              34,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "src_ptr": "uint8_t",
              "src_pixels_per_line": "int",
              "xoffset": "int",
              "yoffset": "int",
              "dst_ptr": "uint8_t",
              "dst_pitch": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              152,
              14
            ],
            [
              152,
              49
            ]
          ],
          "class_code": "ce6b8f5a1bf7c527256c444b24db928172be856b18529ed520b0974b3aade72d",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              180,
              14
            ],
            [
              180,
              49
            ]
          ],
          "class_code": "ce6b8f5a1bf7c527256c444b24db928172be856b18529ed520b0974b3aade72d",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        }
      ],
      "class_node_list": {
        "ce6b8f5a1bf7c527256c444b24db928172be856b18529ed520b0974b3aade72d": {
          "class_code": "class PredictTestBase : public AbstractBench,\n                        public ::testing::TestWithParam<PredictParam> {\n public:\n  PredictTestBase()\n      : width_(GET_PARAM(0)), height_(GET_PARAM(1)), predict_(GET_PARAM(2)),\n        src_(NULL), padded_dst_(NULL), dst_(NULL), dst_c_(NULL) {}\n\n  virtual void SetUp() {\n    src_ = new uint8_t[kSrcSize];\n    ASSERT_TRUE(src_ != NULL);\n\n    // padded_dst_ provides a buffer of kBorderSize around the destination\n    // memory to facilitate detecting out of bounds writes.\n    dst_stride_ = kBorderSize + width_ + kBorderSize;\n    padded_dst_size_ = dst_stride_ * (kBorderSize + height_ + kBorderSize);\n    padded_dst_ =\n        reinterpret_cast<uint8_t *>(vpx_memalign(16, padded_dst_size_));\n    ASSERT_TRUE(padded_dst_ != NULL);\n    dst_ = padded_dst_ + (kBorderSize * dst_stride_) + kBorderSize;\n\n    dst_c_ = new uint8_t[16 * 16];\n    ASSERT_TRUE(dst_c_ != NULL);\n\n    memset(src_, 0, kSrcSize);\n    memset(padded_dst_, 128, padded_dst_size_);\n    memset(dst_c_, 0, 16 * 16);\n  }\n\n  virtual void TearDown() {\n    delete[] src_;\n    src_ = NULL;\n    vpx_free(padded_dst_);\n    padded_dst_ = NULL;\n    dst_ = NULL;\n    delete[] dst_c_;\n    dst_c_ = NULL;\n    libvpx_test::ClearSystemState();\n  }\n\n protected:\n  // Make reference arrays big enough for 16x16 functions. Six-tap filters need\n  // 5 extra pixels outside of the macroblock.\n  static const int kSrcStride = 21;\n  static const int kSrcSize = kSrcStride * kSrcStride;\n  static const int kBorderSize = 16;\n\n  int width_;\n  int height_;\n  PredictFunc predict_;\n  uint8_t *src_;\n  uint8_t *padded_dst_;\n  uint8_t *dst_;\n  int padded_dst_size_;\n  uint8_t *dst_c_;\n  int dst_stride_;\n\n  bool CompareBuffers(const uint8_t *a, int a_stride, const uint8_t *b,\n                      int b_stride) const {\n    for (int height = 0; height < height_; ++height) {\n      EXPECT_EQ(0, memcmp(a + height * a_stride, b + height * b_stride,\n                          sizeof(*a) * width_))\n          << \"Row \" << height << \" does not match.\";\n    }\n\n    return !HasFailure();\n  }\n\n  // Given a block of memory 'a' with size 'a_size', determine if all regions\n  // excepting block 'b' described by 'b_stride', 'b_height', and 'b_width'\n  // match pixel value 'c'.\n  bool CheckBorder(const uint8_t *a, int a_size, const uint8_t *b, int b_width,\n                   int b_height, int b_stride, uint8_t c) const {\n    const uint8_t *a_end = a + a_size;\n    const int b_size = (b_stride * b_height) + b_width;\n    const uint8_t *b_end = b + b_size;\n    const int left_border = (b_stride - b_width) / 2;\n    const int right_border = left_border + ((b_stride - b_width) % 2);\n\n    EXPECT_GE(b - left_border, a) << \"'b' does not start within 'a'\";\n    EXPECT_LE(b_end + right_border, a_end) << \"'b' does not end within 'a'\";\n\n    // Top border.\n    for (int pixel = 0; pixel < b - a - left_border; ++pixel) {\n      EXPECT_EQ(c, a[pixel]) << \"Mismatch at \" << pixel << \" in top border.\";\n    }\n\n    // Left border.\n    for (int height = 0; height < b_height; ++height) {\n      for (int width = left_border; width > 0; --width) {\n        EXPECT_EQ(c, b[height * b_stride - width])\n            << \"Mismatch at row \" << height << \" column \" << left_border - width\n            << \" in left border.\";\n      }\n    }\n\n    // Right border.\n    for (int height = 0; height < b_height; ++height) {\n      for (int width = b_width; width < b_width + right_border; ++width) {\n        EXPECT_EQ(c, b[height * b_stride + width])\n            << \"Mismatch at row \" << height << \" column \" << width - b_width\n            << \" in right border.\";\n      }\n    }\n\n    // Bottom border.\n    for (int pixel = static_cast<int>(b - a + b_size); pixel < a_size;\n         ++pixel) {\n      EXPECT_EQ(c, a[pixel]) << \"Mismatch at \" << pixel << \" in bottom border.\";\n    }\n\n    return !HasFailure();\n  }\n\n  void TestWithRandomData(PredictFunc reference) {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n\n    // Run tests for almost all possible offsets.\n    for (int xoffset = 0; xoffset < 8; ++xoffset) {\n      for (int yoffset = 0; yoffset < 8; ++yoffset) {\n        if (xoffset == 0 && yoffset == 0) {\n          // This represents a copy which is not required to be handled by this\n          // module.\n          continue;\n        }\n\n        for (int i = 0; i < kSrcSize; ++i) {\n          src_[i] = rnd.Rand8();\n        }\n        reference(&src_[kSrcStride * 2 + 2], kSrcStride, xoffset, yoffset,\n                  dst_c_, 16);\n\n        ASM_REGISTER_STATE_CHECK(predict_(&src_[kSrcStride * 2 + 2], kSrcStride,\n                                          xoffset, yoffset, dst_, dst_stride_));\n\n        ASSERT_TRUE(CompareBuffers(dst_c_, 16, dst_, dst_stride_));\n        ASSERT_TRUE(CheckBorder(padded_dst_, padded_dst_size_, dst_, width_,\n                                height_, dst_stride_, 128));\n      }\n    }\n  }\n\n  void TestWithUnalignedDst(PredictFunc reference) {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n\n    // Only the 4x4 need to be able to handle unaligned writes.\n    if (width_ == 4 && height_ == 4) {\n      for (int xoffset = 0; xoffset < 8; ++xoffset) {\n        for (int yoffset = 0; yoffset < 8; ++yoffset) {\n          if (xoffset == 0 && yoffset == 0) {\n            continue;\n          }\n          for (int i = 0; i < kSrcSize; ++i) {\n            src_[i] = rnd.Rand8();\n          }\n          reference(&src_[kSrcStride * 2 + 2], kSrcStride, xoffset, yoffset,\n                    dst_c_, 16);\n\n          for (int i = 1; i < 4; ++i) {\n            memset(padded_dst_, 128, padded_dst_size_);\n\n            ASM_REGISTER_STATE_CHECK(predict_(&src_[kSrcStride * 2 + 2],\n                                              kSrcStride, xoffset, yoffset,\n                                              dst_ + i, dst_stride_ + i));\n\n            ASSERT_TRUE(CompareBuffers(dst_c_, 16, dst_ + i, dst_stride_ + i));\n            ASSERT_TRUE(CheckBorder(padded_dst_, padded_dst_size_, dst_ + i,\n                                    width_, height_, dst_stride_ + i, 128));\n          }\n        }\n      }\n    }\n  }\n\n  void Run() {\n    for (int xoffset = 0; xoffset < 8; ++xoffset) {\n      for (int yoffset = 0; yoffset < 8; ++yoffset) {\n        if (xoffset == 0 && yoffset == 0) {\n          continue;\n        }\n\n        predict_(&src_[kSrcStride * 2 + 2], kSrcStride, xoffset, yoffset, dst_,\n                 dst_stride_);\n      }\n    }\n  }\n}",
          "class_name": "PredictTestBase",
          "class_pos": [
            [
              38,
              0
            ],
            [
              223,
              1
            ]
          ]
        },
        "4cc543dfb7b517a1c9aededf4d06cc69e0ad78a981426cfc7e9198b6721428c2": {
          "class_code": "class SixtapPredictTest : public PredictTestBase {}",
          "class_name": "SixtapPredictTest",
          "class_pos": [
            [
              225,
              0
            ],
            [
              225,
              51
            ]
          ]
        },
        "196f94a9aabb641e284e2b3bd61441e5706c181af82f037ea5e00e4e0c53182e": {
          "class_code": "class BilinearPredictTest : public PredictTestBase {}",
          "class_name": "BilinearPredictTest",
          "class_pos": [
            [
              352,
              0
            ],
            [
              352,
              53
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdlib.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"./vp8_rtcd.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/bench.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"vpx_ports/msvc.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/comp_avg_pred_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "uint8_t avg_with_rounding(uint8_t a, uint8_t b) { return (a + b + 1) >> 1; }",
          "fn_code_pos": [
            [
              27,
              0
            ],
            [
              27,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "avg_with_rounding",
            "parameters": {
              "a": "uint8_t",
              "b": "uint8_t"
            },
            "return_type": "uint8_t"
          }
        },
        {
          "fn_code": "void reference_pred(const Buffer<uint8_t> &pred, const Buffer<uint8_t> &ref,\n                    int width, int height, Buffer<uint8_t> *avg) {\n  ASSERT_TRUE(avg->TopLeftPixel() != NULL);\n  ASSERT_TRUE(pred.TopLeftPixel() != NULL);\n  ASSERT_TRUE(ref.TopLeftPixel() != NULL);\n\n  for (int y = 0; y < height; ++y) {\n    for (int x = 0; x < width; ++x) {\n      avg->TopLeftPixel()[y * avg->stride() + x] =\n          avg_with_rounding(pred.TopLeftPixel()[y * pred.stride() + x],\n                            ref.TopLeftPixel()[y * ref.stride() + x]);\n    }\n  }\n}",
          "fn_code_pos": [
            [
              29,
              0
            ],
            [
              42,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reference_pred",
            "parameters": {
              "pred": "Buffer<uint8_t>",
              "ref": "Buffer<uint8_t>",
              "width": "int",
              "height": "int",
              "avg": "Buffer<uint8_t>"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    avg_pred_func_ = GetParam();\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n  }",
          "fn_code_pos": [
            [
              46,
              2
            ],
            [
              49,
              3
            ]
          ],
          "class_code": "8e97f4a01c45baee3c7281e4861d2b0a21c3c5ae4bd54e2b7ae482c3452099c4",
          "class_node_pos": [
            [
              44,
              0
            ],
            [
              54,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(AvgPredTest, SizeCombinations) {\n  // This is called as part of the sub pixel variance. As such it must be one of\n  // the variance block sizes.\n\n  for (int width_pow = 2; width_pow <= 6; ++width_pow) {\n    for (int height_pow = width_pow - 1; height_pow <= width_pow + 1;\n         ++height_pow) {\n      // Don't test 4x2 or 64x128\n      if (height_pow == 1 || height_pow == 7) continue;\n\n      // The sse2 special-cases when ref width == stride, so make sure to test\n      // it.\n      for (int ref_padding = 0; ref_padding < 2; ref_padding++) {\n        const int width = 1 << width_pow;\n        const int height = 1 << height_pow;\n        // Only the reference buffer may have a stride not equal to width.\n        Buffer<uint8_t> ref =\n            Buffer<uint8_t>(width, height, ref_padding ? 8 : 0);\n        ASSERT_TRUE(ref.Init());\n        Buffer<uint8_t> pred = Buffer<uint8_t>(width, height, 0, 16);\n        ASSERT_TRUE(pred.Init());\n        Buffer<uint8_t> avg_ref = Buffer<uint8_t>(width, height, 0, 16);\n        ASSERT_TRUE(avg_ref.Init());\n        Buffer<uint8_t> avg_chk = Buffer<uint8_t>(width, height, 0, 16);\n        ASSERT_TRUE(avg_chk.Init());\n\n        ref.Set(&rnd_, &ACMRandom::Rand8);\n        pred.Set(&rnd_, &ACMRandom::Rand8);\n\n        reference_pred(pred, ref, width, height, &avg_ref);\n        ASM_REGISTER_STATE_CHECK(\n            avg_pred_func_(avg_chk.TopLeftPixel(), pred.TopLeftPixel(), width,\n                           height, ref.TopLeftPixel(), ref.stride()));\n\n        EXPECT_TRUE(avg_chk.CheckValues(avg_ref));\n        if (HasFailure()) {\n          printf(\"Width: %d Height: %d\\n\", width, height);\n          avg_chk.PrintDifference(avg_ref);\n          return;\n        }\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              99,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(AvgPredTest, CompareReferenceRandom) {\n  const int width = 64;\n  const int height = 32;\n  Buffer<uint8_t> ref = Buffer<uint8_t>(width, height, 8);\n  ASSERT_TRUE(ref.Init());\n  Buffer<uint8_t> pred = Buffer<uint8_t>(width, height, 0, 16);\n  ASSERT_TRUE(pred.Init());\n  Buffer<uint8_t> avg_ref = Buffer<uint8_t>(width, height, 0, 16);\n  ASSERT_TRUE(avg_ref.Init());\n  Buffer<uint8_t> avg_chk = Buffer<uint8_t>(width, height, 0, 16);\n  ASSERT_TRUE(avg_chk.Init());\n\n  for (int i = 0; i < 500; ++i) {\n    ref.Set(&rnd_, &ACMRandom::Rand8);\n    pred.Set(&rnd_, &ACMRandom::Rand8);\n\n    reference_pred(pred, ref, width, height, &avg_ref);\n    ASM_REGISTER_STATE_CHECK(avg_pred_func_(avg_chk.TopLeftPixel(),\n                                            pred.TopLeftPixel(), width, height,\n                                            ref.TopLeftPixel(), ref.stride()));\n    EXPECT_TRUE(avg_chk.CheckValues(avg_ref));\n    if (HasFailure()) {\n      printf(\"Width: %d Height: %d\\n\", width, height);\n      avg_chk.PrintDifference(avg_ref);\n      return;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              101,
              0
            ],
            [
              128,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(AvgPredTest, DISABLED_Speed) {\n  for (int width_pow = 2; width_pow <= 6; ++width_pow) {\n    for (int height_pow = width_pow - 1; height_pow <= width_pow + 1;\n         ++height_pow) {\n      // Don't test 4x2 or 64x128\n      if (height_pow == 1 || height_pow == 7) continue;\n\n      for (int ref_padding = 0; ref_padding < 2; ref_padding++) {\n        const int width = 1 << width_pow;\n        const int height = 1 << height_pow;\n        Buffer<uint8_t> ref =\n            Buffer<uint8_t>(width, height, ref_padding ? 8 : 0);\n        ASSERT_TRUE(ref.Init());\n        Buffer<uint8_t> pred = Buffer<uint8_t>(width, height, 0, 16);\n        ASSERT_TRUE(pred.Init());\n        Buffer<uint8_t> avg = Buffer<uint8_t>(width, height, 0, 16);\n        ASSERT_TRUE(avg.Init());\n\n        ref.Set(&rnd_, &ACMRandom::Rand8);\n        pred.Set(&rnd_, &ACMRandom::Rand8);\n\n        vpx_usec_timer timer;\n        vpx_usec_timer_start(&timer);\n        for (int i = 0; i < 10000000 / (width * height); ++i) {\n          avg_pred_func_(avg.TopLeftPixel(), pred.TopLeftPixel(), width, height,\n                         ref.TopLeftPixel(), ref.stride());\n        }\n        vpx_usec_timer_mark(&timer);\n\n        const int elapsed_time =\n            static_cast<int>(vpx_usec_timer_elapsed(&timer));\n        printf(\"Average Test (ref_padding: %d) %dx%d time: %5d us\\n\",\n               ref_padding, width, height, elapsed_time);\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              130,
              0
            ],
            [
              166,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*AvgPredFunc)(uint8_t *a, const uint8_t *b, int w, int h,\n                            const uint8_t *c, int c_stride)",
          "fn_dec_pos": [
            [
              24,
              13
            ],
            [
              25,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "a": "uint8_t",
              "b": "uint8_t",
              "w": "int",
              "h": "int",
              "c": "uint8_t",
              "c_stride": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {
        "8e97f4a01c45baee3c7281e4861d2b0a21c3c5ae4bd54e2b7ae482c3452099c4": {
          "class_code": "class AvgPredTest : public ::testing::TestWithParam<AvgPredFunc> {\n public:\n  virtual void SetUp() {\n    avg_pred_func_ = GetParam();\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n  }\n\n protected:\n  AvgPredFunc avg_pred_func_;\n  ACMRandom rnd_;\n}",
          "class_name": "AvgPredTest",
          "class_pos": [
            [
              44,
              0
            ],
            [
              54,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/buffer.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"vpx_ports/vpx_timer.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp8_denoiser_sse2_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "virtual ~VP8DenoiserTest() {}",
          "fn_code_pos": [
            [
              32,
              2
            ],
            [
              32,
              31
            ]
          ],
          "class_code": "fea61c74394f67c33ab29aa3a9277124a31cd5c3e3d9417ebdf7c503cdb22b16",
          "class_node_pos": [
            [
              30,
              0
            ],
            [
              40,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() { increase_denoising_ = GetParam(); }",
          "fn_code_pos": [
            [
              34,
              2
            ],
            [
              34,
              60
            ]
          ],
          "class_code": "fea61c74394f67c33ab29aa3a9277124a31cd5c3e3d9417ebdf7c503cdb22b16",
          "class_node_pos": [
            [
              30,
              0
            ],
            [
              40,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              36,
              2
            ],
            [
              36,
              62
            ]
          ],
          "class_code": "fea61c74394f67c33ab29aa3a9277124a31cd5c3e3d9417ebdf7c503cdb22b16",
          "class_node_pos": [
            [
              30,
              0
            ],
            [
              40,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(VP8DenoiserTest, BitexactCheck) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  const int count_test_block = 4000;\n  const int stride = 16;\n\n  // Allocate the space for input and output,\n  // where sig_block_c/_sse2 is the block to be denoised,\n  // mc_avg_block is the denoised reference block,\n  // avg_block_c is the denoised result from C code,\n  // avg_block_sse2 is the denoised result from SSE2 code.\n  DECLARE_ALIGNED(16, uint8_t, sig_block_c[kNumPixels]);\n  // Since in VP8 denoiser, the source signal will be changed,\n  // we need another copy of the source signal as the input of sse2 code.\n  DECLARE_ALIGNED(16, uint8_t, sig_block_sse2[kNumPixels]);\n  DECLARE_ALIGNED(16, uint8_t, mc_avg_block[kNumPixels]);\n  DECLARE_ALIGNED(16, uint8_t, avg_block_c[kNumPixels]);\n  DECLARE_ALIGNED(16, uint8_t, avg_block_sse2[kNumPixels]);\n\n  for (int i = 0; i < count_test_block; ++i) {\n    // Generate random motion magnitude, 20% of which exceed the threshold.\n    const int motion_magnitude_ran =\n        rnd.Rand8() % static_cast<int>(MOTION_MAGNITUDE_THRESHOLD * 1.2);\n\n    // Initialize a test block with random number in range [0, 255].\n    for (int j = 0; j < kNumPixels; ++j) {\n      int temp = 0;\n      sig_block_sse2[j] = sig_block_c[j] = rnd.Rand8();\n      // The pixels in mc_avg_block are generated by adding a random\n      // number in range [-19, 19] to corresponding pixels in sig_block.\n      temp =\n          sig_block_c[j] + (rnd.Rand8() % 2 == 0 ? -1 : 1) * (rnd.Rand8() % 20);\n      // Clip.\n      mc_avg_block[j] = (temp < 0) ? 0 : ((temp > 255) ? 255 : temp);\n    }\n\n    // Test denosiser on Y component.\n    ASM_REGISTER_STATE_CHECK(vp8_denoiser_filter_c(\n        mc_avg_block, stride, avg_block_c, stride, sig_block_c, stride,\n        motion_magnitude_ran, increase_denoising_));\n\n    ASM_REGISTER_STATE_CHECK(vp8_denoiser_filter_sse2(\n        mc_avg_block, stride, avg_block_sse2, stride, sig_block_sse2, stride,\n        motion_magnitude_ran, increase_denoising_));\n\n    // Check bitexactness.\n    for (int h = 0; h < 16; ++h) {\n      for (int w = 0; w < 16; ++w) {\n        EXPECT_EQ(avg_block_c[h * stride + w], avg_block_sse2[h * stride + w]);\n      }\n    }\n\n    // Test denoiser on UV component.\n    ASM_REGISTER_STATE_CHECK(vp8_denoiser_filter_uv_c(\n        mc_avg_block, stride, avg_block_c, stride, sig_block_c, stride,\n        motion_magnitude_ran, increase_denoising_));\n\n    ASM_REGISTER_STATE_CHECK(vp8_denoiser_filter_uv_sse2(\n        mc_avg_block, stride, avg_block_sse2, stride, sig_block_sse2, stride,\n        motion_magnitude_ran, increase_denoising_));\n\n    // Check bitexactness.\n    for (int h = 0; h < 16; ++h) {\n      for (int w = 0; w < 16; ++w) {\n        EXPECT_EQ(avg_block_c[h * stride + w], avg_block_sse2[h * stride + w]);\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              42,
              0
            ],
            [
              109,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              43,
              12
            ],
            [
              43,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        }
      ],
      "class_node_list": {
        "fea61c74394f67c33ab29aa3a9277124a31cd5c3e3d9417ebdf7c503cdb22b16": {
          "class_code": "class VP8DenoiserTest : public ::testing::TestWithParam<int> {\n public:\n  virtual ~VP8DenoiserTest() {}\n\n  virtual void SetUp() { increase_denoising_ = GetParam(); }\n\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  int increase_denoising_;\n}",
          "class_name": "VP8DenoiserTest",
          "class_pos": [
            [
              30,
              0
            ],
            [
              40,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <math.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"vp8/encoder/denoising.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"vp8/common/reconinter.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp8_fragments_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "VP8FramgmentsTest() : EncoderTest(&::libvpx_test::kVP8) {}",
          "fn_code_pos": [
            [
              18,
              2
            ],
            [
              18,
              60
            ]
          ],
          "class_code": "7a093e7a18566393760fb0b46327fe3691e077acc0a8fa23a7cc3a7f1e2526e7",
          "class_node_pos": [
            [
              15,
              0
            ],
            [
              28,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VP8FramgmentsTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~VP8FramgmentsTest() {}",
          "fn_code_pos": [
            [
              19,
              2
            ],
            [
              19,
              33
            ]
          ],
          "class_code": "7a093e7a18566393760fb0b46327fe3691e077acc0a8fa23a7cc3a7f1e2526e7",
          "class_node_pos": [
            [
              15,
              0
            ],
            [
              28,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    const unsigned long init_flags =  // NOLINT(runtime/int)\n        VPX_CODEC_USE_OUTPUT_PARTITION;\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    set_init_flags(init_flags);\n  }",
          "fn_code_pos": [
            [
              21,
              2
            ],
            [
              27,
              3
            ]
          ],
          "class_code": "7a093e7a18566393760fb0b46327fe3691e077acc0a8fa23a7cc3a7f1e2526e7",
          "class_node_pos": [
            [
              15,
              0
            ],
            [
              28,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_F(VP8FramgmentsTest, TestFragmentsEncodeDecode) {\n  ::libvpx_test::RandomVideoSource video;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              30,
              0
            ],
            [
              33,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "7a093e7a18566393760fb0b46327fe3691e077acc0a8fa23a7cc3a7f1e2526e7": {
          "class_code": "class VP8FramgmentsTest : public ::libvpx_test::EncoderTest,\n                          public ::testing::Test {\n protected:\n  VP8FramgmentsTest() : EncoderTest(&::libvpx_test::kVP8) {}\n  virtual ~VP8FramgmentsTest() {}\n\n  virtual void SetUp() {\n    const unsigned long init_flags =  // NOLINT(runtime/int)\n        VPX_CODEC_USE_OUTPUT_PARTITION;\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    set_init_flags(init_flags);\n  }\n}",
          "class_name": "VP8FramgmentsTest",
          "class_pos": [
            [
              15,
              0
            ],
            [
              28,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"test/video_source.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/consistency_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "ConsistencyTestBase(int width, int height) : width_(width), height_(height) {}",
          "fn_code_pos": [
            [
              39,
              2
            ],
            [
              39,
              80
            ]
          ],
          "class_code": "71d2a1046fda36433ddbb029a3a0445b0bfcba2524abefcc82804c38f0e8462d",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              127,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ConsistencyTestBase",
            "parameters": {
              "width": "int",
              "height": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void SetUpTestCase() {\n    source_data_[0] = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kDataBufferSize));\n    reference_data_[0] = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kDataBufferSize));\n    source_data_[1] = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kDataBufferSize));\n    reference_data_[1] = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kDataBufferSize));\n    ssim_array_ = new Ssimv[kDataBufferSize / 16];\n  }",
          "fn_code_pos": [
            [
              41,
              2
            ],
            [
              51,
              3
            ]
          ],
          "class_code": "71d2a1046fda36433ddbb029a3a0445b0bfcba2524abefcc82804c38f0e8462d",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              127,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUpTestCase",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ClearSsim() { memset(ssim_array_, 0, kDataBufferSize / 16); }",
          "fn_code_pos": [
            [
              53,
              2
            ],
            [
              53,
              75
            ]
          ],
          "class_code": "71d2a1046fda36433ddbb029a3a0445b0bfcba2524abefcc82804c38f0e8462d",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              127,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ClearSsim",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void TearDownTestCase() {\n    vpx_free(source_data_[0]);\n    source_data_[0] = NULL;\n    vpx_free(reference_data_[0]);\n    reference_data_[0] = NULL;\n    vpx_free(source_data_[1]);\n    source_data_[1] = NULL;\n    vpx_free(reference_data_[1]);\n    reference_data_[1] = NULL;\n\n    delete[] ssim_array_;\n  }",
          "fn_code_pos": [
            [
              54,
              2
            ],
            [
              65,
              3
            ]
          ],
          "class_code": "71d2a1046fda36433ddbb029a3a0445b0bfcba2524abefcc82804c38f0e8462d",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              127,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDownTestCase",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              67,
              2
            ],
            [
              67,
              62
            ]
          ],
          "class_code": "71d2a1046fda36433ddbb029a3a0445b0bfcba2524abefcc82804c38f0e8462d",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              127,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    source_stride_ = (width_ + 31) & ~31;\n    reference_stride_ = width_ * 2;\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n  }",
          "fn_code_pos": [
            [
              74,
              2
            ],
            [
              78,
              3
            ]
          ],
          "class_code": "71d2a1046fda36433ddbb029a3a0445b0bfcba2524abefcc82804c38f0e8462d",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              127,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void FillRandom(uint8_t *data, int stride, int width, int height) {\n    for (int h = 0; h < height; ++h) {\n      for (int w = 0; w < width; ++w) {\n        data[h * stride + w] = rnd_.Rand8();\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              80,
              2
            ],
            [
              86,
              3
            ]
          ],
          "class_code": "71d2a1046fda36433ddbb029a3a0445b0bfcba2524abefcc82804c38f0e8462d",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              127,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillRandom",
            "parameters": {
              "data": "uint8_t",
              "stride": "int",
              "width": "int",
              "height": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void FillRandom(uint8_t *data, int stride) {\n    FillRandom(data, stride, width_, height_);\n  }",
          "fn_code_pos": [
            [
              88,
              2
            ],
            [
              90,
              3
            ]
          ],
          "class_code": "71d2a1046fda36433ddbb029a3a0445b0bfcba2524abefcc82804c38f0e8462d",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              127,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillRandom",
            "parameters": {
              "data": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Copy(uint8_t *reference, uint8_t *source) {\n    memcpy(reference, source, kDataBufferSize);\n  }",
          "fn_code_pos": [
            [
              92,
              2
            ],
            [
              94,
              3
            ]
          ],
          "class_code": "71d2a1046fda36433ddbb029a3a0445b0bfcba2524abefcc82804c38f0e8462d",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              127,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Copy",
            "parameters": {
              "reference": "uint8_t",
              "source": "uint8_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Blur(uint8_t *data, int stride, int taps) {\n    int sum = 0;\n    int half_taps = taps / 2;\n    for (int h = 0; h < height_; ++h) {\n      for (int w = 0; w < taps; ++w) {\n        sum += data[w + h * stride];\n      }\n      for (int w = taps; w < width_; ++w) {\n        sum += data[w + h * stride] - data[w - taps + h * stride];\n        data[w - half_taps + h * stride] = (sum + half_taps) / taps;\n      }\n    }\n    for (int w = 0; w < width_; ++w) {\n      for (int h = 0; h < taps; ++h) {\n        sum += data[h + w * stride];\n      }\n      for (int h = taps; h < height_; ++h) {\n        sum += data[w + h * stride] - data[(h - taps) * stride + w];\n        data[(h - half_taps) * stride + w] = (sum + half_taps) / taps;\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              96,
              2
            ],
            [
              117,
              3
            ]
          ],
          "class_code": "71d2a1046fda36433ddbb029a3a0445b0bfcba2524abefcc82804c38f0e8462d",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              127,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Blur",
            "parameters": {
              "data": "uint8_t",
              "stride": "int",
              "taps": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ConsistencyVP9Test() : ConsistencyTestBase(GET_PARAM(0), GET_PARAM(1)) {}",
          "fn_code_pos": [
            [
              135,
              2
            ],
            [
              135,
              75
            ]
          ],
          "class_code": "1eb811747b6236ddd0b3f6bf2310153c195c20967e3f193df21f08c41ad51cf2",
          "class_node_pos": [
            [
              131,
              0
            ],
            [
              144,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ConsistencyVP9Test",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "double CheckConsistency(int frame) {\n    EXPECT_LT(frame, 2) << \"Frame to check has to be less than 2.\";\n    return vpx_get_ssim_metrics(source_data_[frame], source_stride_,\n                                reference_data_[frame], reference_stride_,\n                                width_, height_, ssim_array_, &metrics_, 1);\n  }",
          "fn_code_pos": [
            [
              138,
              2
            ],
            [
              143,
              3
            ]
          ],
          "class_code": "1eb811747b6236ddd0b3f6bf2310153c195c20967e3f193df21f08c41ad51cf2",
          "class_node_pos": [
            [
              131,
              0
            ],
            [
              144,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckConsistency",
            "parameters": {
              "frame": "int"
            },
            "return_type": "double"
          }
        },
        {
          "fn_code": "TEST_P(ConsistencyVP9Test, ConsistencyIsZero) {\n  FillRandom(source_data_[0], source_stride_);\n  Copy(source_data_[1], source_data_[0]);\n  Copy(reference_data_[0], source_data_[0]);\n  Blur(reference_data_[0], reference_stride_, 3);\n  Copy(reference_data_[1], source_data_[0]);\n  Blur(reference_data_[1], reference_stride_, 3);\n\n  double inconsistency = CheckConsistency(1);\n  inconsistency = CheckConsistency(0);\n  EXPECT_EQ(inconsistency, 0.0)\n      << \"Should have 0 inconsistency if they are exactly the same.\";\n\n  // If sources are not consistent reference frames inconsistency should\n  // be less than if the source is consistent.\n  FillRandom(source_data_[0], source_stride_);\n  FillRandom(source_data_[1], source_stride_);\n  FillRandom(reference_data_[0], reference_stride_);\n  FillRandom(reference_data_[1], reference_stride_);\n  CheckConsistency(0);\n  inconsistency = CheckConsistency(1);\n\n  Copy(source_data_[1], source_data_[0]);\n  CheckConsistency(0);\n  double inconsistency2 = CheckConsistency(1);\n  EXPECT_LT(inconsistency, inconsistency2)\n      << \"Should have less inconsistency if source itself is inconsistent.\";\n\n  // Less of a blur should be less inconsistent than more blur coming off a\n  // a frame with no blur.\n  ClearSsim();\n  FillRandom(source_data_[0], source_stride_);\n  Copy(source_data_[1], source_data_[0]);\n  Copy(reference_data_[0], source_data_[0]);\n  Copy(reference_data_[1], source_data_[0]);\n  Blur(reference_data_[1], reference_stride_, 4);\n  CheckConsistency(0);\n  inconsistency = CheckConsistency(1);\n  ClearSsim();\n  Copy(reference_data_[1], source_data_[0]);\n  Blur(reference_data_[1], reference_stride_, 8);\n  CheckConsistency(0);\n  inconsistency2 = CheckConsistency(1);\n\n  EXPECT_LT(inconsistency, inconsistency2)\n      << \"Stronger Blur should produce more inconsistency.\";\n}",
          "fn_code_pos": [
            [
              152,
              0
            ],
            [
              198,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "vpx_get_ssim_metrics(uint8_t *img1, int img1_pitch,\n                                       uint8_t *img2, int img2_pitch, int width,\n                                       int height, Ssimv *sv2, Metrics *m,\n                                       int do_inconsistency)",
          "fn_dec_pos": [
            [
              29,
              18
            ],
            [
              32,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "vpx_get_ssim_metrics",
            "parameters": {
              "img1": "uint8_t",
              "img1_pitch": "int",
              "img2": "uint8_t",
              "img2_pitch": "int",
              "width": "int",
              "height": "int",
              "sv2": "Ssimv",
              "m": "Metrics",
              "do_inconsistency": "int"
            },
            "return_type": "double"
          }
        }
      ],
      "class_node_list": {
        "71d2a1046fda36433ddbb029a3a0445b0bfcba2524abefcc82804c38f0e8462d": {
          "class_code": "class ConsistencyTestBase : public ::testing::Test {\n public:\n  ConsistencyTestBase(int width, int height) : width_(width), height_(height) {}\n\n  static void SetUpTestCase() {\n    source_data_[0] = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kDataBufferSize));\n    reference_data_[0] = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kDataBufferSize));\n    source_data_[1] = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kDataBufferSize));\n    reference_data_[1] = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kDataBufferSize));\n    ssim_array_ = new Ssimv[kDataBufferSize / 16];\n  }\n\n  static void ClearSsim() { memset(ssim_array_, 0, kDataBufferSize / 16); }\n  static void TearDownTestCase() {\n    vpx_free(source_data_[0]);\n    source_data_[0] = NULL;\n    vpx_free(reference_data_[0]);\n    reference_data_[0] = NULL;\n    vpx_free(source_data_[1]);\n    source_data_[1] = NULL;\n    vpx_free(reference_data_[1]);\n    reference_data_[1] = NULL;\n\n    delete[] ssim_array_;\n  }\n\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  // Handle frames up to 640x480\n  static const int kDataAlignment = 16;\n  static const int kDataBufferSize = 640 * 480;\n\n  virtual void SetUp() {\n    source_stride_ = (width_ + 31) & ~31;\n    reference_stride_ = width_ * 2;\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n  }\n\n  void FillRandom(uint8_t *data, int stride, int width, int height) {\n    for (int h = 0; h < height; ++h) {\n      for (int w = 0; w < width; ++w) {\n        data[h * stride + w] = rnd_.Rand8();\n      }\n    }\n  }\n\n  void FillRandom(uint8_t *data, int stride) {\n    FillRandom(data, stride, width_, height_);\n  }\n\n  void Copy(uint8_t *reference, uint8_t *source) {\n    memcpy(reference, source, kDataBufferSize);\n  }\n\n  void Blur(uint8_t *data, int stride, int taps) {\n    int sum = 0;\n    int half_taps = taps / 2;\n    for (int h = 0; h < height_; ++h) {\n      for (int w = 0; w < taps; ++w) {\n        sum += data[w + h * stride];\n      }\n      for (int w = taps; w < width_; ++w) {\n        sum += data[w + h * stride] - data[w - taps + h * stride];\n        data[w - half_taps + h * stride] = (sum + half_taps) / taps;\n      }\n    }\n    for (int w = 0; w < width_; ++w) {\n      for (int h = 0; h < taps; ++h) {\n        sum += data[h + w * stride];\n      }\n      for (int h = taps; h < height_; ++h) {\n        sum += data[w + h * stride] - data[(h - taps) * stride + w];\n        data[(h - half_taps) * stride + w] = (sum + half_taps) / taps;\n      }\n    }\n  }\n  int width_, height_;\n  static uint8_t *source_data_[2];\n  int source_stride_;\n  static uint8_t *reference_data_[2];\n  int reference_stride_;\n  static Ssimv *ssim_array_;\n  Metrics metrics_;\n\n  ACMRandom rnd_;\n}",
          "class_name": "ConsistencyTestBase",
          "class_pos": [
            [
              37,
              0
            ],
            [
              127,
              1
            ]
          ]
        },
        "1eb811747b6236ddd0b3f6bf2310153c195c20967e3f193df21f08c41ad51cf2": {
          "class_code": "class ConsistencyVP9Test\n    : public ConsistencyTestBase,\n      public ::testing::WithParamInterface<ConsistencyParam> {\n public:\n  ConsistencyVP9Test() : ConsistencyTestBase(GET_PARAM(0), GET_PARAM(1)) {}\n\n protected:\n  double CheckConsistency(int frame) {\n    EXPECT_LT(frame, 2) << \"Frame to check has to be less than 2.\";\n    return vpx_get_ssim_metrics(source_data_[frame], source_stride_,\n                                reference_data_[frame], reference_stride_,\n                                width_, height_, ssim_array_, &metrics_, 1);\n  }\n}",
          "class_name": "ConsistencyVP9Test",
          "class_pos": [
            [
              131,
              0
            ],
            [
              144,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <limits.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"./vp9_rtcd.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"vpx_dsp/ssim.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/y4m_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "static void write_image_file(const vpx_image_t *img, FILE *file) {\n  int plane, y;\n  for (plane = 0; plane < 3; ++plane) {\n    const unsigned char *buf = img->planes[plane];\n    const int stride = img->stride[plane];\n    const int bytes_per_sample = (img->fmt & VPX_IMG_FMT_HIGHBITDEPTH) ? 2 : 1;\n    const int h =\n        (plane ? (img->d_h + img->y_chroma_shift) >> img->y_chroma_shift\n               : img->d_h);\n    const int w =\n        (plane ? (img->d_w + img->x_chroma_shift) >> img->x_chroma_shift\n               : img->d_w);\n    for (y = 0; y < h; ++y) {\n      fwrite(buf, bytes_per_sample, w, file);\n      buf += stride;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              73,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "write_image_file",
            "parameters": {
              "img": "vpx_image_t",
              "file": "FILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "Y4mVideoSourceTest() : Y4mVideoSource(\"\", 0, 0) {}",
          "fn_code_pos": [
            [
              78,
              2
            ],
            [
              78,
              52
            ]
          ],
          "class_code": "bc2fafe50612e657aca2ad938448d3e11612a89e845dfbfe1f882cc238ccd513",
          "class_node_pos": [
            [
              75,
              0
            ],
            [
              126,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Y4mVideoSourceTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~Y4mVideoSourceTest() { CloseSource(); }",
          "fn_code_pos": [
            [
              80,
              2
            ],
            [
              80,
              50
            ]
          ],
          "class_code": "bc2fafe50612e657aca2ad938448d3e11612a89e845dfbfe1f882cc238ccd513",
          "class_node_pos": [
            [
              75,
              0
            ],
            [
              126,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void Init(const std::string &file_name, int limit) {\n    file_name_ = file_name;\n    start_ = 0;\n    limit_ = limit;\n    frame_ = 0;\n    Begin();\n  }",
          "fn_code_pos": [
            [
              82,
              2
            ],
            [
              88,
              3
            ]
          ],
          "class_code": "bc2fafe50612e657aca2ad938448d3e11612a89e845dfbfe1f882cc238ccd513",
          "class_node_pos": [
            [
              75,
              0
            ],
            [
              126,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Init",
            "parameters": {
              "file_name": "std::string",
              "limit": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void HeaderChecks(unsigned int bit_depth, vpx_img_fmt_t fmt) {\n    ASSERT_TRUE(input_file_ != NULL);\n    ASSERT_EQ(y4m_.pic_w, (int)kWidth);\n    ASSERT_EQ(y4m_.pic_h, (int)kHeight);\n    ASSERT_EQ(img()->d_w, kWidth);\n    ASSERT_EQ(img()->d_h, kHeight);\n    ASSERT_EQ(y4m_.bit_depth, bit_depth);\n    ASSERT_EQ(y4m_.vpx_fmt, fmt);\n    if (fmt == VPX_IMG_FMT_I420 || fmt == VPX_IMG_FMT_I42016) {\n      ASSERT_EQ(y4m_.bps, (int)y4m_.bit_depth * 3 / 2);\n      ASSERT_EQ(img()->x_chroma_shift, 1U);\n      ASSERT_EQ(img()->y_chroma_shift, 1U);\n    }\n    if (fmt == VPX_IMG_FMT_I422 || fmt == VPX_IMG_FMT_I42216) {\n      ASSERT_EQ(y4m_.bps, (int)y4m_.bit_depth * 2);\n      ASSERT_EQ(img()->x_chroma_shift, 1U);\n      ASSERT_EQ(img()->y_chroma_shift, 0U);\n    }\n    if (fmt == VPX_IMG_FMT_I444 || fmt == VPX_IMG_FMT_I44416) {\n      ASSERT_EQ(y4m_.bps, (int)y4m_.bit_depth * 3);\n      ASSERT_EQ(img()->x_chroma_shift, 0U);\n      ASSERT_EQ(img()->y_chroma_shift, 0U);\n    }\n  }",
          "fn_code_pos": [
            [
              91,
              2
            ],
            [
              114,
              3
            ]
          ],
          "class_code": "bc2fafe50612e657aca2ad938448d3e11612a89e845dfbfe1f882cc238ccd513",
          "class_node_pos": [
            [
              75,
              0
            ],
            [
              126,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "HeaderChecks",
            "parameters": {
              "bit_depth": "unsigned int",
              "fmt": "vpx_img_fmt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Md5Check(const string &expected_md5) {\n    ASSERT_TRUE(input_file_ != NULL);\n    libvpx_test::MD5 md5;\n    for (unsigned int i = start_; i < limit_; i++) {\n      md5.Add(img());\n      Next();\n    }\n    ASSERT_EQ(string(md5.Get()), expected_md5);\n  }",
          "fn_code_pos": [
            [
              117,
              2
            ],
            [
              125,
              3
            ]
          ],
          "class_code": "bc2fafe50612e657aca2ad938448d3e11612a89e845dfbfe1f882cc238ccd513",
          "class_node_pos": [
            [
              75,
              0
            ],
            [
              126,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Md5Check",
            "parameters": {
              "expected_md5": "string"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(Y4mVideoSourceTest, SourceTest) {\n  const Y4mTestParam t = GetParam();\n  Init(t.filename, kFrames);\n  HeaderChecks(t.bit_depth, t.format);\n  Md5Check(t.md5raw);\n}",
          "fn_code_pos": [
            [
              128,
              0
            ],
            [
              133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "Y4mVideoWriteTest() : tmpfile_(NULL) {}",
          "fn_code_pos": [
            [
              140,
              2
            ],
            [
              140,
              41
            ]
          ],
          "class_code": "c2d53dda227b660a5392cd498e4a92c1feb82ba358725e18ef70beaf79f68e02",
          "class_node_pos": [
            [
              138,
              0
            ],
            [
              179,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Y4mVideoWriteTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~Y4mVideoWriteTest() {\n    delete tmpfile_;\n    input_file_ = NULL;\n  }",
          "fn_code_pos": [
            [
              142,
              2
            ],
            [
              145,
              3
            ]
          ],
          "class_code": "c2d53dda227b660a5392cd498e4a92c1feb82ba358725e18ef70beaf79f68e02",
          "class_node_pos": [
            [
              138,
              0
            ],
            [
              179,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void ReplaceInputFile(FILE *input_file) {\n    CloseSource();\n    frame_ = 0;\n    input_file_ = input_file;\n    rewind(input_file_);\n    ReadSourceToStart();\n  }",
          "fn_code_pos": [
            [
              147,
              2
            ],
            [
              153,
              3
            ]
          ],
          "class_code": "c2d53dda227b660a5392cd498e4a92c1feb82ba358725e18ef70beaf79f68e02",
          "class_node_pos": [
            [
              138,
              0
            ],
            [
              179,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ReplaceInputFile",
            "parameters": {
              "input_file": "FILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void WriteY4mAndReadBack() {\n    ASSERT_TRUE(input_file_ != NULL);\n    char buf[Y4M_BUFFER_SIZE] = { 0 };\n    const struct VpxRational framerate = { y4m_.fps_n, y4m_.fps_d };\n    tmpfile_ = new libvpx_test::TempOutFile;\n    ASSERT_TRUE(tmpfile_->file() != NULL);\n    y4m_write_file_header(buf, sizeof(buf), kWidth, kHeight, &framerate,\n                          y4m_.vpx_fmt, y4m_.bit_depth);\n    fputs(buf, tmpfile_->file());\n    for (unsigned int i = start_; i < limit_; i++) {\n      y4m_write_frame_header(buf, sizeof(buf));\n      fputs(buf, tmpfile_->file());\n      write_image_file(img(), tmpfile_->file());\n      Next();\n    }\n    ReplaceInputFile(tmpfile_->file());\n  }",
          "fn_code_pos": [
            [
              156,
              2
            ],
            [
              172,
              3
            ]
          ],
          "class_code": "c2d53dda227b660a5392cd498e4a92c1feb82ba358725e18ef70beaf79f68e02",
          "class_node_pos": [
            [
              138,
              0
            ],
            [
              179,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "WriteY4mAndReadBack",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void Init(const std::string &file_name, int limit) {\n    Y4mVideoSourceTest::Init(file_name, limit);\n    WriteY4mAndReadBack();\n  }",
          "fn_code_pos": [
            [
              174,
              2
            ],
            [
              177,
              3
            ]
          ],
          "class_code": "c2d53dda227b660a5392cd498e4a92c1feb82ba358725e18ef70beaf79f68e02",
          "class_node_pos": [
            [
              138,
              0
            ],
            [
              179,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Init",
            "parameters": {
              "file_name": "std::string",
              "limit": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(Y4mVideoWriteTest, WriteTest) {\n  const Y4mTestParam t = GetParam();\n  Init(t.filename, kFrames);\n  HeaderChecks(t.bit_depth, t.format);\n  Md5Check(t.md5raw);\n}",
          "fn_code_pos": [
            [
              181,
              0
            ],
            [
              186,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "bc2fafe50612e657aca2ad938448d3e11612a89e845dfbfe1f882cc238ccd513": {
          "class_code": "class Y4mVideoSourceTest : public ::testing::TestWithParam<Y4mTestParam>,\n                           public ::libvpx_test::Y4mVideoSource {\n protected:\n  Y4mVideoSourceTest() : Y4mVideoSource(\"\", 0, 0) {}\n\n  virtual ~Y4mVideoSourceTest() { CloseSource(); }\n\n  virtual void Init(const std::string &file_name, int limit) {\n    file_name_ = file_name;\n    start_ = 0;\n    limit_ = limit;\n    frame_ = 0;\n    Begin();\n  }\n\n  // Checks y4m header information\n  void HeaderChecks(unsigned int bit_depth, vpx_img_fmt_t fmt) {\n    ASSERT_TRUE(input_file_ != NULL);\n    ASSERT_EQ(y4m_.pic_w, (int)kWidth);\n    ASSERT_EQ(y4m_.pic_h, (int)kHeight);\n    ASSERT_EQ(img()->d_w, kWidth);\n    ASSERT_EQ(img()->d_h, kHeight);\n    ASSERT_EQ(y4m_.bit_depth, bit_depth);\n    ASSERT_EQ(y4m_.vpx_fmt, fmt);\n    if (fmt == VPX_IMG_FMT_I420 || fmt == VPX_IMG_FMT_I42016) {\n      ASSERT_EQ(y4m_.bps, (int)y4m_.bit_depth * 3 / 2);\n      ASSERT_EQ(img()->x_chroma_shift, 1U);\n      ASSERT_EQ(img()->y_chroma_shift, 1U);\n    }\n    if (fmt == VPX_IMG_FMT_I422 || fmt == VPX_IMG_FMT_I42216) {\n      ASSERT_EQ(y4m_.bps, (int)y4m_.bit_depth * 2);\n      ASSERT_EQ(img()->x_chroma_shift, 1U);\n      ASSERT_EQ(img()->y_chroma_shift, 0U);\n    }\n    if (fmt == VPX_IMG_FMT_I444 || fmt == VPX_IMG_FMT_I44416) {\n      ASSERT_EQ(y4m_.bps, (int)y4m_.bit_depth * 3);\n      ASSERT_EQ(img()->x_chroma_shift, 0U);\n      ASSERT_EQ(img()->y_chroma_shift, 0U);\n    }\n  }\n\n  // Checks MD5 of the raw frame data\n  void Md5Check(const string &expected_md5) {\n    ASSERT_TRUE(input_file_ != NULL);\n    libvpx_test::MD5 md5;\n    for (unsigned int i = start_; i < limit_; i++) {\n      md5.Add(img());\n      Next();\n    }\n    ASSERT_EQ(string(md5.Get()), expected_md5);\n  }\n}",
          "class_name": "Y4mVideoSourceTest",
          "class_pos": [
            [
              75,
              0
            ],
            [
              126,
              1
            ]
          ]
        },
        "c2d53dda227b660a5392cd498e4a92c1feb82ba358725e18ef70beaf79f68e02": {
          "class_code": "class Y4mVideoWriteTest : public Y4mVideoSourceTest {\n protected:\n  Y4mVideoWriteTest() : tmpfile_(NULL) {}\n\n  virtual ~Y4mVideoWriteTest() {\n    delete tmpfile_;\n    input_file_ = NULL;\n  }\n\n  void ReplaceInputFile(FILE *input_file) {\n    CloseSource();\n    frame_ = 0;\n    input_file_ = input_file;\n    rewind(input_file_);\n    ReadSourceToStart();\n  }\n\n  // Writes out a y4m file and then reads it back\n  void WriteY4mAndReadBack() {\n    ASSERT_TRUE(input_file_ != NULL);\n    char buf[Y4M_BUFFER_SIZE] = { 0 };\n    const struct VpxRational framerate = { y4m_.fps_n, y4m_.fps_d };\n    tmpfile_ = new libvpx_test::TempOutFile;\n    ASSERT_TRUE(tmpfile_->file() != NULL);\n    y4m_write_file_header(buf, sizeof(buf), kWidth, kHeight, &framerate,\n                          y4m_.vpx_fmt, y4m_.bit_depth);\n    fputs(buf, tmpfile_->file());\n    for (unsigned int i = start_; i < limit_; i++) {\n      y4m_write_frame_header(buf, sizeof(buf));\n      fputs(buf, tmpfile_->file());\n      write_image_file(img(), tmpfile_->file());\n      Next();\n    }\n    ReplaceInputFile(tmpfile_->file());\n  }\n\n  virtual void Init(const std::string &file_name, int limit) {\n    Y4mVideoSourceTest::Init(file_name, limit);\n    WriteY4mAndReadBack();\n  }\n  libvpx_test::TempOutFile *tmpfile_;\n}",
          "class_name": "Y4mVideoWriteTest",
          "class_pos": [
            [
              138,
              0
            ],
            [
              179,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct Y4mTestParam {\n  const char *filename;\n  unsigned int bit_depth;\n  vpx_img_fmt format;\n  const char *md5raw;\n}",
          {
            "char": "const",
            "bit_depth": "unsigned int",
            "format": "vpx_img_fmt"
          },
          "Y4mTestParam",
          [
            28,
            0
          ],
          [
            33,
            1
          ]
        ],
        [
          "struct Y4mTestParam {\n  const char *filename;\n  unsigned int bit_depth;\n  vpx_img_fmt format;\n  const char *md5raw;\n}",
          {
            "char": "const",
            "bit_depth": "unsigned int",
            "format": "vpx_img_fmt"
          },
          "Y4mTestParam",
          [
            28,
            0
          ],
          [
            33,
            1
          ]
        ],
        [
          "struct VpxRational",
          {},
          "",
          [
            159,
            10
          ],
          [
            159,
            28
          ]
        ]
      ],
      "include_list": [
        [
          "#include <string>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"./y4menc.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/md5_helper.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/y4m_video_source.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/decode_test_driver.cc": {
      "fn_def_list": [
        {
          "fn_code": "vpx_codec_err_t Decoder::PeekStream(const uint8_t *cxdata, size_t size,\n                                    vpx_codec_stream_info_t *stream_info) {\n  return vpx_codec_peek_stream_info(\n      CodecInterface(), cxdata, static_cast<unsigned int>(size), stream_info);\n}",
          "fn_code_pos": [
            [
              21,
              0
            ],
            [
              25,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Decoder::PeekStream",
            "parameters": {
              "cxdata": "uint8_t",
              "size": "size_t",
              "stream_info": "vpx_codec_stream_info_t"
            },
            "return_type": "vpx_codec_err_t"
          }
        },
        {
          "fn_code": "vpx_codec_err_t Decoder::DecodeFrame(const uint8_t *cxdata, size_t size) {\n  return DecodeFrame(cxdata, size, NULL);\n}",
          "fn_code_pos": [
            [
              27,
              0
            ],
            [
              29,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Decoder::DecodeFrame",
            "parameters": {
              "cxdata": "uint8_t",
              "size": "size_t"
            },
            "return_type": "vpx_codec_err_t"
          }
        },
        {
          "fn_code": "vpx_codec_err_t Decoder::DecodeFrame(const uint8_t *cxdata, size_t size,\n                                     void *user_priv) {\n  vpx_codec_err_t res_dec;\n  InitOnce();\n  API_REGISTER_STATE_CHECK(\n      res_dec = vpx_codec_decode(\n          &decoder_, cxdata, static_cast<unsigned int>(size), user_priv, 0));\n  return res_dec;\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              39,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Decoder::DecodeFrame",
            "parameters": {
              "cxdata": "uint8_t",
              "size": "size_t",
              "user_priv": "void"
            },
            "return_type": "vpx_codec_err_t"
          }
        },
        {
          "fn_code": "bool Decoder::IsVP8() const {\n  const char *codec_name = GetDecoderName();\n  return strncmp(kVP8Name, codec_name, sizeof(kVP8Name) - 1) == 0;\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              44,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Decoder::IsVP8",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "void DecoderTest::HandlePeekResult(Decoder *const decoder,\n                                   CompressedVideoSource *video,\n                                   const vpx_codec_err_t res_peek) {\n  const bool is_vp8 = decoder->IsVP8();\n  if (is_vp8) {\n    /* Vp8's implementation of PeekStream returns an error if the frame you\n     * pass it is not a keyframe, so we only expect VPX_CODEC_OK on the first\n     * frame, which must be a keyframe. */\n    if (video->frame_number() == 0) {\n      ASSERT_EQ(VPX_CODEC_OK, res_peek)\n          << \"Peek return failed: \" << vpx_codec_err_to_string(res_peek);\n    }\n  } else {\n    /* The Vp9 implementation of PeekStream returns an error only if the\n     * data passed to it isn't a valid Vp9 chunk. */\n    ASSERT_EQ(VPX_CODEC_OK, res_peek)\n        << \"Peek return failed: \" << vpx_codec_err_to_string(res_peek);\n  }\n}",
          "fn_code_pos": [
            [
              46,
              0
            ],
            [
              64,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DecoderTest::HandlePeekResult",
            "parameters": {
              "decoder": "Decoder",
              "video": "CompressedVideoSource",
              "res_peek": "vpx_codec_err_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void DecoderTest::RunLoop(CompressedVideoSource *video,\n                          const vpx_codec_dec_cfg_t &dec_cfg) {\n  Decoder *const decoder = codec_->CreateDecoder(dec_cfg, flags_);\n  ASSERT_TRUE(decoder != NULL);\n  bool end_of_file = false;\n\n  // Decode frames.\n  for (video->Begin(); !::testing::Test::HasFailure() && !end_of_file;\n       video->Next()) {\n    PreDecodeFrameHook(*video, decoder);\n\n    vpx_codec_stream_info_t stream_info;\n    stream_info.sz = sizeof(stream_info);\n\n    if (video->cxdata() != NULL) {\n      const vpx_codec_err_t res_peek = decoder->PeekStream(\n          video->cxdata(), video->frame_size(), &stream_info);\n      HandlePeekResult(decoder, video, res_peek);\n      ASSERT_FALSE(::testing::Test::HasFailure());\n\n      vpx_codec_err_t res_dec =\n          decoder->DecodeFrame(video->cxdata(), video->frame_size());\n      if (!HandleDecodeResult(res_dec, *video, decoder)) break;\n    } else {\n      // Signal end of the file to the decoder.\n      const vpx_codec_err_t res_dec = decoder->DecodeFrame(NULL, 0);\n      ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();\n      end_of_file = true;\n    }\n\n    DxDataIterator dec_iter = decoder->GetDxData();\n    const vpx_image_t *img = NULL;\n\n    // Get decompressed data\n    while (!::testing::Test::HasFailure() && (img = dec_iter.Next())) {\n      DecompressedFrameHook(*img, video->frame_number());\n    }\n  }\n  delete decoder;\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DecoderTest::RunLoop",
            "parameters": {
              "video": "CompressedVideoSource",
              "dec_cfg": "vpx_codec_dec_cfg_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void DecoderTest::RunLoop(CompressedVideoSource *video) {\n  vpx_codec_dec_cfg_t dec_cfg = vpx_codec_dec_cfg_t();\n  RunLoop(video, dec_cfg);\n}",
          "fn_code_pos": [
            [
              107,
              0
            ],
            [
              110,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DecoderTest::RunLoop",
            "parameters": {
              "video": "CompressedVideoSource"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void DecoderTest::set_cfg(const vpx_codec_dec_cfg_t &dec_cfg) {\n  memcpy(&cfg_, &dec_cfg, sizeof(cfg_));\n}",
          "fn_code_pos": [
            [
              112,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DecoderTest::set_cfg",
            "parameters": {
              "dec_cfg": "vpx_codec_dec_cfg_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void DecoderTest::set_flags(const vpx_codec_flags_t flags) { flags_ = flags; }",
          "fn_code_pos": [
            [
              116,
              0
            ],
            [
              116,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DecoderTest::set_flags",
            "parameters": {
              "flags": "vpx_codec_flags_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/decode_test_driver.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/video_source.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/invalid_file_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "std::ostream &operator<<(std::ostream &os, const DecodeParam &dp) {\n  return os << \"threads: \" << dp.threads << \" file: \" << dp.filename;\n}",
          "fn_code_pos": [
            [
              33,
              0
            ],
            [
              35,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "InvalidFileTest() : DecoderTest(GET_PARAM(0)), res_file_(NULL) {}",
          "fn_code_pos": [
            [
              40,
              2
            ],
            [
              40,
              67
            ]
          ],
          "class_code": "358aeddf3f6276e0953ab8d7ad7a862ee974648bf3db5be45dc4892306e8715f",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              119,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "InvalidFileTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~InvalidFileTest() {\n    if (res_file_ != NULL) fclose(res_file_);\n  }",
          "fn_code_pos": [
            [
              42,
              2
            ],
            [
              44,
              3
            ]
          ],
          "class_code": "358aeddf3f6276e0953ab8d7ad7a862ee974648bf3db5be45dc4892306e8715f",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              119,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void OpenResFile(const std::string &res_file_name_) {\n    res_file_ = libvpx_test::OpenTestDataFile(res_file_name_);\n    ASSERT_TRUE(res_file_ != NULL)\n        << \"Result file open failed. Filename: \" << res_file_name_;\n  }",
          "fn_code_pos": [
            [
              46,
              2
            ],
            [
              50,
              3
            ]
          ],
          "class_code": "358aeddf3f6276e0953ab8d7ad7a862ee974648bf3db5be45dc4892306e8715f",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              119,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "OpenResFile",
            "parameters": {
              "res_file_name_": "std::string"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual bool HandleDecodeResult(\n      const vpx_codec_err_t res_dec,\n      const libvpx_test::CompressedVideoSource &video,\n      libvpx_test::Decoder *decoder) {\n    EXPECT_TRUE(res_file_ != NULL);\n    int expected_res_dec;\n\n    // Read integer result.\n    const int res = fscanf(res_file_, \"%d\", &expected_res_dec);\n    EXPECT_NE(res, EOF) << \"Read result data failed\";\n\n    // Check results match.\n    const DecodeParam input = GET_PARAM(1);\n    if (input.threads > 1) {\n      // The serial decode check is too strict for tile-threaded decoding as\n      // there is no guarantee on the decode order nor which specific error\n      // will take precedence. Currently a tile-level error is not forwarded so\n      // the frame will simply be marked corrupt.\n      EXPECT_TRUE(res_dec == expected_res_dec ||\n                  res_dec == VPX_CODEC_CORRUPT_FRAME)\n          << \"Results don't match: frame number = \" << video.frame_number()\n          << \". (\" << decoder->DecodeError()\n          << \"). Expected: \" << expected_res_dec << \" or \"\n          << VPX_CODEC_CORRUPT_FRAME;\n    } else {\n      EXPECT_EQ(expected_res_dec, res_dec)\n          << \"Results don't match: frame number = \" << video.frame_number()\n          << \". (\" << decoder->DecodeError() << \")\";\n    }\n\n    return !HasFailure();\n  }",
          "fn_code_pos": [
            [
              52,
              2
            ],
            [
              83,
              3
            ]
          ],
          "class_code": "358aeddf3f6276e0953ab8d7ad7a862ee974648bf3db5be45dc4892306e8715f",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              119,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "HandleDecodeResult",
            "parameters": {
              "res_dec": "vpx_codec_err_t",
              "video": "libvpx_test::CompressedVideoSource",
              "decoder": "libvpx_test::Decoder"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "void RunTest() {\n    const DecodeParam input = GET_PARAM(1);\n    vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n    cfg.threads = input.threads;\n    const std::string filename = input.filename;\n\n    // Open compressed video file.\n    std::unique_ptr<libvpx_test::CompressedVideoSource> video;\n    if (filename.substr(filename.length() - 3, 3) == \"ivf\") {\n      video.reset(new libvpx_test::IVFVideoSource(filename));\n    } else if (filename.substr(filename.length() - 4, 4) == \"webm\") {\n#if CONFIG_WEBM_IO\n      video.reset(new libvpx_test::WebMVideoSource(filename));\n#else\n      fprintf(stderr, \"WebM IO is disabled, skipping test vector %s\\n\",\n              filename.c_str());\n      return;\n#endif\n    }\n    ASSERT_TRUE(video.get() != NULL);\n    video->Init();\n\n    // Construct result file name. The file holds a list of expected integer\n    // results, one for each decoded frame.  Any result that doesn't match\n    // the files list will cause a test failure.\n    const std::string res_filename = filename + \".res\";\n    OpenResFile(res_filename);\n\n    // Decode frame, and check the md5 matching.\n    ASSERT_NO_FATAL_FAILURE(RunLoop(video.get(), cfg));\n  }",
          "fn_code_pos": [
            [
              85,
              2
            ],
            [
              115,
              3
            ]
          ],
          "class_code": "358aeddf3f6276e0953ab8d7ad7a862ee974648bf3db5be45dc4892306e8715f",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              119,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(InvalidFileTest, ReturnCode) { RunTest(); }",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              121,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "InvalidFileInvalidPeekTest() : InvalidFileTest() {}",
          "fn_code_pos": [
            [
              172,
              2
            ],
            [
              172,
              53
            ]
          ],
          "class_code": "2864859e4c5fdcbf230bc1cc97159254b69f6623cb692595e62163787b18c6c1",
          "class_node_pos": [
            [
              170,
              0
            ],
            [
              176,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "InvalidFileInvalidPeekTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void HandlePeekResult(libvpx_test::Decoder *const /*decoder*/,\n                                libvpx_test::CompressedVideoSource * /*video*/,\n                                const vpx_codec_err_t /*res_peek*/) {}",
          "fn_code_pos": [
            [
              173,
              2
            ],
            [
              175,
              70
            ]
          ],
          "class_code": "2864859e4c5fdcbf230bc1cc97159254b69f6623cb692595e62163787b18c6c1",
          "class_node_pos": [
            [
              170,
              0
            ],
            [
              176,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "HandlePeekResult",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(InvalidFileInvalidPeekTest, ReturnCode) { RunTest(); }",
          "fn_code_pos": [
            [
              178,
              0
            ],
            [
              178,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "operator<<(std::ostream &os, const DecodeParam &dp)",
          "fn_dec_pos": [
            [
              33,
              14
            ],
            [
              33,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "dp": "DecodeParam"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "358aeddf3f6276e0953ab8d7ad7a862ee974648bf3db5be45dc4892306e8715f": {
          "class_code": "class InvalidFileTest : public ::libvpx_test::DecoderTest,\n                        public ::libvpx_test::CodecTestWithParam<DecodeParam> {\n protected:\n  InvalidFileTest() : DecoderTest(GET_PARAM(0)), res_file_(NULL) {}\n\n  virtual ~InvalidFileTest() {\n    if (res_file_ != NULL) fclose(res_file_);\n  }\n\n  void OpenResFile(const std::string &res_file_name_) {\n    res_file_ = libvpx_test::OpenTestDataFile(res_file_name_);\n    ASSERT_TRUE(res_file_ != NULL)\n        << \"Result file open failed. Filename: \" << res_file_name_;\n  }\n\n  virtual bool HandleDecodeResult(\n      const vpx_codec_err_t res_dec,\n      const libvpx_test::CompressedVideoSource &video,\n      libvpx_test::Decoder *decoder) {\n    EXPECT_TRUE(res_file_ != NULL);\n    int expected_res_dec;\n\n    // Read integer result.\n    const int res = fscanf(res_file_, \"%d\", &expected_res_dec);\n    EXPECT_NE(res, EOF) << \"Read result data failed\";\n\n    // Check results match.\n    const DecodeParam input = GET_PARAM(1);\n    if (input.threads > 1) {\n      // The serial decode check is too strict for tile-threaded decoding as\n      // there is no guarantee on the decode order nor which specific error\n      // will take precedence. Currently a tile-level error is not forwarded so\n      // the frame will simply be marked corrupt.\n      EXPECT_TRUE(res_dec == expected_res_dec ||\n                  res_dec == VPX_CODEC_CORRUPT_FRAME)\n          << \"Results don't match: frame number = \" << video.frame_number()\n          << \". (\" << decoder->DecodeError()\n          << \"). Expected: \" << expected_res_dec << \" or \"\n          << VPX_CODEC_CORRUPT_FRAME;\n    } else {\n      EXPECT_EQ(expected_res_dec, res_dec)\n          << \"Results don't match: frame number = \" << video.frame_number()\n          << \". (\" << decoder->DecodeError() << \")\";\n    }\n\n    return !HasFailure();\n  }\n\n  void RunTest() {\n    const DecodeParam input = GET_PARAM(1);\n    vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n    cfg.threads = input.threads;\n    const std::string filename = input.filename;\n\n    // Open compressed video file.\n    std::unique_ptr<libvpx_test::CompressedVideoSource> video;\n    if (filename.substr(filename.length() - 3, 3) == \"ivf\") {\n      video.reset(new libvpx_test::IVFVideoSource(filename));\n    } else if (filename.substr(filename.length() - 4, 4) == \"webm\") {\n#if CONFIG_WEBM_IO\n      video.reset(new libvpx_test::WebMVideoSource(filename));\n#else\n      fprintf(stderr, \"WebM IO is disabled, skipping test vector %s\\n\",\n              filename.c_str());\n      return;\n#endif\n    }\n    ASSERT_TRUE(video.get() != NULL);\n    video->Init();\n\n    // Construct result file name. The file holds a list of expected integer\n    // results, one for each decoded frame.  Any result that doesn't match\n    // the files list will cause a test failure.\n    const std::string res_filename = filename + \".res\";\n    OpenResFile(res_filename);\n\n    // Decode frame, and check the md5 matching.\n    ASSERT_NO_FATAL_FAILURE(RunLoop(video.get(), cfg));\n  }\n\n private:\n  FILE *res_file_;\n}",
          "class_name": "InvalidFileTest",
          "class_pos": [
            [
              37,
              0
            ],
            [
              119,
              1
            ]
          ]
        },
        "2864859e4c5fdcbf230bc1cc97159254b69f6623cb692595e62163787b18c6c1": {
          "class_code": "class InvalidFileInvalidPeekTest : public InvalidFileTest {\n protected:\n  InvalidFileInvalidPeekTest() : InvalidFileTest() {}\n  virtual void HandlePeekResult(libvpx_test::Decoder *const /*decoder*/,\n                                libvpx_test::CompressedVideoSource * /*video*/,\n                                const vpx_codec_err_t /*res_peek*/) {}\n}",
          "class_name": "InvalidFileInvalidPeekTest",
          "class_pos": [
            [
              170,
              0
            ],
            [
              176,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct DecodeParam {\n  int threads;\n  const char *filename;\n}",
          {
            "threads": "int",
            "char": "const"
          },
          "DecodeParam",
          [
            28,
            0
          ],
          [
            31,
            1
          ]
        ],
        [
          "struct DecodeParam {\n  int threads;\n  const char *filename;\n}",
          {
            "threads": "int",
            "char": "const"
          },
          "DecodeParam",
          [
            28,
            0
          ],
          [
            31,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include <cstdio>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <cstdlib>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <memory>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/decode_test_driver.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/ivf_video_source.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"test/webm_video_source.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/superframe_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "SuperframeTest()\n      : EncoderTest(GET_PARAM(0)), modified_buf_(NULL), last_sf_pts_(0) {}",
          "fn_code_pos": [
            [
              28,
              2
            ],
            [
              29,
              74
            ]
          ],
          "class_code": "0540feb5627282933784b031a87316be793da66aed0418509a164c6badb3c6bf",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              85,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SuperframeTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~SuperframeTest() {}",
          "fn_code_pos": [
            [
              30,
              2
            ],
            [
              30,
              30
            ]
          ],
          "class_code": "0540feb5627282933784b031a87316be793da66aed0418509a164c6badb3c6bf",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              85,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    const SuperframeTestParam input = GET_PARAM(1);\n    const libvpx_test::TestMode mode = std::get<kTestMode>(input);\n    SetMode(mode);\n    sf_count_ = 0;\n    sf_count_max_ = INT_MAX;\n  }",
          "fn_code_pos": [
            [
              32,
              2
            ],
            [
              39,
              3
            ]
          ],
          "class_code": "0540feb5627282933784b031a87316be793da66aed0418509a164c6badb3c6bf",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              85,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() { delete[] modified_buf_; }",
          "fn_code_pos": [
            [
              41,
              2
            ],
            [
              41,
              53
            ]
          ],
          "class_code": "0540feb5627282933784b031a87316be793da66aed0418509a164c6badb3c6bf",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              85,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                                  libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n    }\n  }",
          "fn_code_pos": [
            [
              43,
              2
            ],
            [
              48,
              3
            ]
          ],
          "class_code": "0540feb5627282933784b031a87316be793da66aed0418509a164c6badb3c6bf",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              85,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "libvpx_test::VideoSource",
              "encoder": "libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual const vpx_codec_cx_pkt_t *MutateEncoderOutputHook(\n      const vpx_codec_cx_pkt_t *pkt) {\n    if (pkt->kind != VPX_CODEC_CX_FRAME_PKT) return pkt;\n\n    const uint8_t *buffer = reinterpret_cast<uint8_t *>(pkt->data.frame.buf);\n    const uint8_t marker = buffer[pkt->data.frame.sz - 1];\n    const int frames = (marker & 0x7) + 1;\n    const int mag = ((marker >> 3) & 3) + 1;\n    const unsigned int index_sz = 2 + mag * frames;\n    if ((marker & 0xe0) == 0xc0 && pkt->data.frame.sz >= index_sz &&\n        buffer[pkt->data.frame.sz - index_sz] == marker) {\n      // frame is a superframe. strip off the index.\n      if (modified_buf_) delete[] modified_buf_;\n      modified_buf_ = new uint8_t[pkt->data.frame.sz - index_sz];\n      memcpy(modified_buf_, pkt->data.frame.buf, pkt->data.frame.sz - index_sz);\n      modified_pkt_ = *pkt;\n      modified_pkt_.data.frame.buf = modified_buf_;\n      modified_pkt_.data.frame.sz -= index_sz;\n\n      sf_count_++;\n      last_sf_pts_ = pkt->data.frame.pts;\n      return &modified_pkt_;\n    }\n\n    // Make sure we do a few frames after the last SF\n    abort_ |=\n        sf_count_ > sf_count_max_ && pkt->data.frame.pts - last_sf_pts_ >= 5;\n    return pkt;\n  }",
          "fn_code_pos": [
            [
              50,
              2
            ],
            [
              78,
              3
            ]
          ],
          "class_code": "0540feb5627282933784b031a87316be793da66aed0418509a164c6badb3c6bf",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              85,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MutateEncoderOutputHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "vpx_codec_cx_pkt_t"
          }
        },
        {
          "fn_code": "TEST_P(SuperframeTest, TestSuperframeIndexIsOptional) {\n  sf_count_max_ = 0;  // early exit on successful test.\n  cfg_.g_lag_in_frames = 25;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 40);\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  EXPECT_EQ(sf_count_, 1);\n}",
          "fn_code_pos": [
            [
              87,
              0
            ],
            [
              95,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "MutateEncoderOutputHook(\n      const vpx_codec_cx_pkt_t *pkt)",
          "fn_dec_pos": [
            [
              50,
              36
            ],
            [
              51,
              36
            ]
          ],
          "class_code": "0540feb5627282933784b031a87316be793da66aed0418509a164c6badb3c6bf",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              85,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MutateEncoderOutputHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "0540feb5627282933784b031a87316be793da66aed0418509a164c6badb3c6bf": {
          "class_code": "class SuperframeTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWithParam<SuperframeTestParam> {\n protected:\n  SuperframeTest()\n      : EncoderTest(GET_PARAM(0)), modified_buf_(NULL), last_sf_pts_(0) {}\n  virtual ~SuperframeTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    const SuperframeTestParam input = GET_PARAM(1);\n    const libvpx_test::TestMode mode = std::get<kTestMode>(input);\n    SetMode(mode);\n    sf_count_ = 0;\n    sf_count_max_ = INT_MAX;\n  }\n\n  virtual void TearDown() { delete[] modified_buf_; }\n\n  virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                                  libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n    }\n  }\n\n  virtual const vpx_codec_cx_pkt_t *MutateEncoderOutputHook(\n      const vpx_codec_cx_pkt_t *pkt) {\n    if (pkt->kind != VPX_CODEC_CX_FRAME_PKT) return pkt;\n\n    const uint8_t *buffer = reinterpret_cast<uint8_t *>(pkt->data.frame.buf);\n    const uint8_t marker = buffer[pkt->data.frame.sz - 1];\n    const int frames = (marker & 0x7) + 1;\n    const int mag = ((marker >> 3) & 3) + 1;\n    const unsigned int index_sz = 2 + mag * frames;\n    if ((marker & 0xe0) == 0xc0 && pkt->data.frame.sz >= index_sz &&\n        buffer[pkt->data.frame.sz - index_sz] == marker) {\n      // frame is a superframe. strip off the index.\n      if (modified_buf_) delete[] modified_buf_;\n      modified_buf_ = new uint8_t[pkt->data.frame.sz - index_sz];\n      memcpy(modified_buf_, pkt->data.frame.buf, pkt->data.frame.sz - index_sz);\n      modified_pkt_ = *pkt;\n      modified_pkt_.data.frame.buf = modified_buf_;\n      modified_pkt_.data.frame.sz -= index_sz;\n\n      sf_count_++;\n      last_sf_pts_ = pkt->data.frame.pts;\n      return &modified_pkt_;\n    }\n\n    // Make sure we do a few frames after the last SF\n    abort_ |=\n        sf_count_ > sf_count_max_ && pkt->data.frame.pts - last_sf_pts_ >= 5;\n    return pkt;\n  }\n\n  int sf_count_;\n  int sf_count_max_;\n  vpx_codec_cx_pkt_t modified_pkt_;\n  uint8_t *modified_buf_;\n  vpx_codec_pts_t last_sf_pts_;\n}",
          "class_name": "SuperframeTest",
          "class_pos": [
            [
              24,
              0
            ],
            [
              85,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <climits>\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/minmax_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "virtual void SetUp() {\n    mm_func_ = GetParam();\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n  }",
          "fn_code_pos": [
            [
              30,
              2
            ],
            [
              33,
              3
            ]
          ],
          "class_code": "c4cb69b486ead89925dff80e9c56fa5d3d84851bdab255575e8032b190f375c4",
          "class_node_pos": [
            [
              28,
              0
            ],
            [
              38,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void reference_minmax(const uint8_t *a, int a_stride, const uint8_t *b,\n                      int b_stride, int *min_ret, int *max_ret) {\n  int min = 255;\n  int max = 0;\n  for (int i = 0; i < 8; i++) {\n    for (int j = 0; j < 8; j++) {\n      const int diff = abs(a[i * a_stride + j] - b[i * b_stride + j]);\n      if (min > diff) min = diff;\n      if (max < diff) max = diff;\n    }\n  }\n\n  *min_ret = min;\n  *max_ret = max;\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reference_minmax",
            "parameters": {
              "a": "uint8_t",
              "a_stride": "int",
              "b": "uint8_t",
              "b_stride": "int",
              "min_ret": "int",
              "max_ret": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(MinMaxTest, MinValue) {\n  for (int i = 0; i < 64; i++) {\n    uint8_t a[64], b[64];\n    memset(a, 0, sizeof(a));\n    memset(b, 255, sizeof(b));\n    b[i] = i;  // Set a minimum difference of i.\n\n    int min, max;\n    ASM_REGISTER_STATE_CHECK(mm_func_(a, 8, b, 8, &min, &max));\n    EXPECT_EQ(255, max);\n    EXPECT_EQ(i, min);\n  }\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              68,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MinMaxTest, MaxValue) {\n  for (int i = 0; i < 64; i++) {\n    uint8_t a[64], b[64];\n    memset(a, 0, sizeof(a));\n    memset(b, 0, sizeof(b));\n    b[i] = i;  // Set a maximum difference of i.\n\n    int min, max;\n    ASM_REGISTER_STATE_CHECK(mm_func_(a, 8, b, 8, &min, &max));\n    EXPECT_EQ(i, max);\n    EXPECT_EQ(0, min);\n  }\n}",
          "fn_code_pos": [
            [
              70,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MinMaxTest, CompareReference) {\n  uint8_t a[64], b[64];\n  for (int j = 0; j < 64; j++) {\n    a[j] = rnd_.Rand8();\n    b[j] = rnd_.Rand8();\n  }\n\n  int min_ref, max_ref, min, max;\n  reference_minmax(a, 8, b, 8, &min_ref, &max_ref);\n  ASM_REGISTER_STATE_CHECK(mm_func_(a, 8, b, 8, &min, &max));\n  EXPECT_EQ(max_ref, max);\n  EXPECT_EQ(min_ref, min);\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              96,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(MinMaxTest, CompareReferenceAndVaryStride) {\n  uint8_t a[8 * 64], b[8 * 64];\n  for (int i = 0; i < 8 * 64; i++) {\n    a[i] = rnd_.Rand8();\n    b[i] = rnd_.Rand8();\n  }\n  for (int a_stride = 8; a_stride <= 64; a_stride += 8) {\n    for (int b_stride = 8; b_stride <= 64; b_stride += 8) {\n      int min_ref, max_ref, min, max;\n      reference_minmax(a, a_stride, b, b_stride, &min_ref, &max_ref);\n      ASM_REGISTER_STATE_CHECK(mm_func_(a, a_stride, b, b_stride, &min, &max));\n      EXPECT_EQ(max_ref, max)\n          << \"when a_stride = \" << a_stride << \" and b_stride = \" << b_stride;\n      EXPECT_EQ(min_ref, min)\n          << \"when a_stride = \" << a_stride << \" and b_stride = \" << b_stride;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              98,
              0
            ],
            [
              115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*MinMaxFunc)(const uint8_t *a, int a_stride, const uint8_t *b,\n                           int b_stride, int *min, int *max)",
          "fn_dec_pos": [
            [
              25,
              13
            ],
            [
              26,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "a": "uint8_t",
              "a_stride": "int",
              "b": "uint8_t",
              "b_stride": "int",
              "min": "int",
              "max": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {
        "c4cb69b486ead89925dff80e9c56fa5d3d84851bdab255575e8032b190f375c4": {
          "class_code": "class MinMaxTest : public ::testing::TestWithParam<MinMaxFunc> {\n public:\n  virtual void SetUp() {\n    mm_func_ = GetParam();\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n  }\n\n protected:\n  MinMaxFunc mm_func_;\n  ACMRandom rnd_;\n}",
          "class_name": "MinMaxTest",
          "class_pos": [
            [
              28,
              0
            ],
            [
              38,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdlib.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/test_intra_pred_speed.cc": {
      "fn_def_list": [
        {
          "fn_code": "void Init(int block_size, int bd) {\n    libvpx_test::ACMRandom rnd(libvpx_test::ACMRandom::DeterministicSeed());\n    Pixel *const above = above_mem + 16;\n    const int mask = (1 << bd) - 1;\n    for (int i = 0; i < kTotalPixels; ++i) ref_src[i] = rnd.Rand16() & mask;\n    for (int i = 0; i < kBPS; ++i) left[i] = rnd.Rand16() & mask;\n    for (int i = -1; i < kBPS; ++i) above[i] = rnd.Rand16() & mask;\n\n    // some code assumes the top row has been extended:\n    // d45/d63 C-code, for instance, but not the assembly.\n    // TODO(jzern): this style of extension isn't strictly necessary.\n    ASSERT_LE(block_size, kBPS);\n    for (int i = block_size; i < 2 * kBPS; ++i) {\n      above[i] = above[block_size - 1];\n    }\n  }",
          "fn_code_pos": [
            [
              42,
              2
            ],
            [
              57,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Init",
            "parameters": {
              "block_size": "int",
              "bd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CheckMd5Signature(const char name[], const char *const signatures[],\n                       const void *data, size_t data_size, int elapsed_time,\n                       int idx) {\n  libvpx_test::MD5 md5;\n  md5.Add(reinterpret_cast<const uint8_t *>(data), data_size);\n  printf(\"Mode %s[%12s]: %5d ms     MD5: %s\\n\", name, kVp9IntraPredNames[idx],\n         elapsed_time, md5.Get());\n  EXPECT_STREQ(signatures[idx], md5.Get());\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              75,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMd5Signature",
            "parameters": {
              "name": "char",
              "signatures": "char",
              "data": "void",
              "data_size": "size_t",
              "elapsed_time": "int",
              "idx": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void TestIntraPred(const char name[], VpxPredFunc const *pred_funcs,\n                   const char *const signatures[], int block_size) {\n  const int kNumTests = static_cast<int>(\n      2.e10 / (block_size * block_size * kNumVp9IntraPredFuncs));\n  Vp9IntraPredTestMem intra_pred_test_mem;\n  const uint8_t *const above = intra_pred_test_mem.above_mem + 16;\n\n  intra_pred_test_mem.Init(block_size, 8);\n\n  for (int k = 0; k < kNumVp9IntraPredFuncs; ++k) {\n    if (pred_funcs[k] == NULL) continue;\n    memcpy(intra_pred_test_mem.src, intra_pred_test_mem.ref_src,\n           sizeof(intra_pred_test_mem.src));\n    vpx_usec_timer timer;\n    vpx_usec_timer_start(&timer);\n    for (int num_tests = 0; num_tests < kNumTests; ++num_tests) {\n      pred_funcs[k](intra_pred_test_mem.src, kBPS, above,\n                    intra_pred_test_mem.left);\n    }\n    libvpx_test::ClearSystemState();\n    vpx_usec_timer_mark(&timer);\n    const int elapsed_time =\n        static_cast<int>(vpx_usec_timer_elapsed(&timer) / 1000);\n    CheckMd5Signature(name, signatures, intra_pred_test_mem.src,\n                      sizeof(intra_pred_test_mem.src), elapsed_time, k);\n  }\n}",
          "fn_code_pos": [
            [
              77,
              0
            ],
            [
              103,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestIntraPred",
            "parameters": {
              "name": "char",
              "pred_funcs": "VpxPredFunc",
              "signatures": "char",
              "block_size": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void TestIntraPred4(VpxPredFunc const *pred_funcs) {\n  static const char *const kSignatures[kNumVp9IntraPredFuncs] = {\n    \"e7ed7353c3383fff942e500e9bfe82fe\", \"2a4a26fcc6ce005eadc08354d196c8a9\",\n    \"269d92eff86f315d9c38fe7640d85b15\", \"ae2960eea9f71ee3dabe08b282ec1773\",\n    \"6c1abcc44e90148998b51acd11144e9c\", \"f7bb3186e1ef8a2b326037ff898cad8e\",\n    \"364c1f3fb2f445f935aec2a70a67eaa4\", \"141624072a4a56773f68fadbdd07c4a7\",\n    \"7be49b08687a5f24df3a2c612fca3876\", \"459bb5d9fd5b238348179c9a22108cd6\",\n    \"73edb8831bf1bdfce21ae8eaa43b1234\", \"2e2457f2009c701a355a8b25eb74fcda\",\n    \"52ae4e8bdbe41494c1f43051d4dd7f0b\"\n  };\n  TestIntraPred(\"Intra4\", pred_funcs, kSignatures, 4);\n}",
          "fn_code_pos": [
            [
              105,
              0
            ],
            [
              116,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestIntraPred4",
            "parameters": {
              "pred_funcs": "VpxPredFunc"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void TestIntraPred8(VpxPredFunc const *pred_funcs) {\n  static const char *const kSignatures[kNumVp9IntraPredFuncs] = {\n    \"d8bbae5d6547cfc17e4f5f44c8730e88\", \"373bab6d931868d41a601d9d88ce9ac3\",\n    \"6fdd5ff4ff79656c14747598ca9e3706\", \"d9661c2811d6a73674f40ffb2b841847\",\n    \"7c722d10b19ccff0b8c171868e747385\", \"f81dd986eb2b50f750d3a7da716b7e27\",\n    \"d500f2c8fc78f46a4c74e4dcf51f14fb\", \"0e3523f9cab2142dd37fd07ec0760bce\",\n    \"79ac4efe907f0a0f1885d43066cfedee\", \"19ecf2432ac305057de3b6578474eec6\",\n    \"4f985b61acc6dd5d2d2585fa89ea2e2d\", \"f1bb25a9060dd262f405f15a38f5f674\",\n    \"209ea00801584829e9a0f7be7d4a74ba\"\n  };\n  TestIntraPred(\"Intra8\", pred_funcs, kSignatures, 8);\n}",
          "fn_code_pos": [
            [
              118,
              0
            ],
            [
              129,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestIntraPred8",
            "parameters": {
              "pred_funcs": "VpxPredFunc"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void TestIntraPred16(VpxPredFunc const *pred_funcs) {\n  static const char *const kSignatures[kNumVp9IntraPredFuncs] = {\n    \"50971c07ce26977d30298538fffec619\", \"527a6b9e0dc5b21b98cf276305432bef\",\n    \"7eff2868f80ebc2c43a4f367281d80f7\", \"67cd60512b54964ef6aff1bd4816d922\",\n    \"48371c87dc95c08a33b2048f89cf6468\", \"b0acf2872ee411d7530af6d2625a7084\",\n    \"f32aafed4d8d3776ed58bcb6188756d5\", \"dae208f3dca583529cff49b73f7c4183\",\n    \"7af66a2f4c8e0b4908e40f047e60c47c\", \"125e3ab6ab9bc961f183ec366a7afa88\",\n    \"6b90f25b23983c35386b9fd704427622\", \"f8d6b11d710edc136a7c62c917435f93\",\n    \"ed308f18614a362917f411c218aee532\"\n  };\n  TestIntraPred(\"Intra16\", pred_funcs, kSignatures, 16);\n}",
          "fn_code_pos": [
            [
              131,
              0
            ],
            [
              142,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestIntraPred16",
            "parameters": {
              "pred_funcs": "VpxPredFunc"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void TestIntraPred32(VpxPredFunc const *pred_funcs) {\n  static const char *const kSignatures[kNumVp9IntraPredFuncs] = {\n    \"a0a618c900e65ae521ccc8af789729f2\", \"985aaa7c72b4a6c2fb431d32100cf13a\",\n    \"10662d09febc3ca13ee4e700120daeb5\", \"b3b01379ba08916ef6b1b35f7d9ad51c\",\n    \"9f4261755795af97e34679c333ec7004\", \"bc2c9da91ad97ef0d1610fb0a9041657\",\n    \"75c79b1362ad18abfcdb1aa0aacfc21d\", \"4039bb7da0f6860090d3c57b5c85468f\",\n    \"b29fff7b61804e68383e3a609b33da58\", \"e1aa5e49067fd8dba66c2eb8d07b7a89\",\n    \"4e042822909c1c06d3b10a88281df1eb\", \"72eb9d9e0e67c93f4c66b70348e9fef7\",\n    \"a22d102bcb51ca798aac12ca4ae8f2e8\"\n  };\n  TestIntraPred(\"Intra32\", pred_funcs, kSignatures, 32);\n}",
          "fn_code_pos": [
            [
              144,
              0
            ],
            [
              155,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestIntraPred32",
            "parameters": {
              "pred_funcs": "VpxPredFunc"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void TestHighbdIntraPred(const char name[], VpxHighbdPredFunc const *pred_funcs,\n                         const char *const signatures[], int block_size) {\n  const int kNumTests = static_cast<int>(\n      2.e10 / (block_size * block_size * kNumVp9IntraPredFuncs));\n  Vp9HighbdIntraPredTestMem intra_pred_test_mem;\n  const uint16_t *const above = intra_pred_test_mem.above_mem + 16;\n\n  intra_pred_test_mem.Init(block_size, 12);\n\n  for (int k = 0; k < kNumVp9IntraPredFuncs; ++k) {\n    if (pred_funcs[k] == NULL) continue;\n    memcpy(intra_pred_test_mem.src, intra_pred_test_mem.ref_src,\n           sizeof(intra_pred_test_mem.src));\n    vpx_usec_timer timer;\n    vpx_usec_timer_start(&timer);\n    for (int num_tests = 0; num_tests < kNumTests; ++num_tests) {\n      pred_funcs[k](intra_pred_test_mem.src, kBPS, above,\n                    intra_pred_test_mem.left, 12);\n    }\n    libvpx_test::ClearSystemState();\n    vpx_usec_timer_mark(&timer);\n    const int elapsed_time =\n        static_cast<int>(vpx_usec_timer_elapsed(&timer) / 1000);\n    CheckMd5Signature(name, signatures, intra_pred_test_mem.src,\n                      sizeof(intra_pred_test_mem.src), elapsed_time, k);\n  }\n}",
          "fn_code_pos": [
            [
              350,
              0
            ],
            [
              376,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestHighbdIntraPred",
            "parameters": {
              "name": "char",
              "pred_funcs": "VpxHighbdPredFunc",
              "signatures": "char",
              "block_size": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void TestHighbdIntraPred4(VpxHighbdPredFunc const *pred_funcs) {\n  static const char *const kSignatures[kNumVp9IntraPredFuncs] = {\n    \"11f74af6c5737df472f3275cbde062fa\", \"51bea056b6447c93f6eb8f6b7e8f6f71\",\n    \"27e97f946766331795886f4de04c5594\", \"53ab15974b049111fb596c5168ec7e3f\",\n    \"f0b640bb176fbe4584cf3d32a9b0320a\", \"729783ca909e03afd4b47111c80d967b\",\n    \"fbf1c30793d9f32812e4d9f905d53530\", \"293fc903254a33754133314c6cdba81f\",\n    \"f8074d704233e73dfd35b458c6092374\", \"aa6363d08544a1ec4da33d7a0be5640d\",\n    \"462abcfdfa3d087bb33c9a88f2aec491\", \"863eab65d22550dd44a2397277c1ec71\",\n    \"23d61df1574d0fa308f9731811047c4b\"\n  };\n  TestHighbdIntraPred(\"Intra4\", pred_funcs, kSignatures, 4);\n}",
          "fn_code_pos": [
            [
              378,
              0
            ],
            [
              389,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestHighbdIntraPred4",
            "parameters": {
              "pred_funcs": "VpxHighbdPredFunc"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void TestHighbdIntraPred8(VpxHighbdPredFunc const *pred_funcs) {\n  static const char *const kSignatures[kNumVp9IntraPredFuncs] = {\n    \"03da8829fe94663047fd108c5fcaa71d\", \"ecdb37b8120a2d3a4c706b016bd1bfd7\",\n    \"1d4543ed8d2b9368cb96898095fe8a75\", \"f791c9a67b913cbd82d9da8ecede30e2\",\n    \"065c70646f4dbaff913282f55a45a441\", \"51f87123616662ef7c35691497dfd0ba\",\n    \"2a5b0131ef4716f098ee65e6df01e3dd\", \"9ffe186a6bc7db95275f1bbddd6f7aba\",\n    \"a3258a2eae2e2bd55cb8f71351b22998\", \"8d909f0a2066e39b3216092c6289ece4\",\n    \"d183abb30b9f24c886a0517e991b22c7\", \"702a42fe4c7d665dc561b2aeeb60f311\",\n    \"7b5dbbbe7ae3a4ac2948731600bde5d6\"\n  };\n  TestHighbdIntraPred(\"Intra8\", pred_funcs, kSignatures, 8);\n}",
          "fn_code_pos": [
            [
              391,
              0
            ],
            [
              402,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestHighbdIntraPred8",
            "parameters": {
              "pred_funcs": "VpxHighbdPredFunc"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void TestHighbdIntraPred16(VpxHighbdPredFunc const *pred_funcs) {\n  static const char *const kSignatures[kNumVp9IntraPredFuncs] = {\n    \"e33cb3f56a878e2fddb1b2fc51cdd275\", \"c7bff6f04b6052c8ab335d726dbbd52d\",\n    \"d0b0b47b654a9bcc5c6008110a44589b\", \"78f5da7b10b2b9ab39f114a33b6254e9\",\n    \"c78e31d23831abb40d6271a318fdd6f3\", \"90d1347f4ec9198a0320daecb6ff90b8\",\n    \"d2c623746cbb64a0c9e29c10f2c57041\", \"cf28bd387b81ad3e5f1a1c779a4b70a0\",\n    \"24c304330431ddeaf630f6ce94af2eac\", \"91a329798036bf64e8e00a87b131b8b1\",\n    \"d39111f22885307f920796a42084c872\", \"e2e702f7250ece98dd8f3f2854c31eeb\",\n    \"e2fb05b01eb8b88549e85641d8ce5b59\"\n  };\n  TestHighbdIntraPred(\"Intra16\", pred_funcs, kSignatures, 16);\n}",
          "fn_code_pos": [
            [
              404,
              0
            ],
            [
              415,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestHighbdIntraPred16",
            "parameters": {
              "pred_funcs": "VpxHighbdPredFunc"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void TestHighbdIntraPred32(VpxHighbdPredFunc const *pred_funcs) {\n  static const char *const kSignatures[kNumVp9IntraPredFuncs] = {\n    \"a3e8056ba7e36628cce4917cd956fedd\", \"cc7d3024fe8748b512407edee045377e\",\n    \"2aab0a0f330a1d3e19b8ecb8f06387a3\", \"a547bc3fb7b06910bf3973122a426661\",\n    \"26f712514da95042f93d6e8dc8e431dc\", \"bb08c6e16177081daa3d936538dbc2e3\",\n    \"8f031af3e2650e89620d8d2c3a843d8b\", \"42867c8553285e94ee8e4df7abafbda8\",\n    \"6496bdee96100667833f546e1be3d640\", \"2ebfa25bf981377e682e580208504300\",\n    \"3e8ae52fd1f607f348aa4cb436c71ab7\", \"3d4efe797ca82193613696753ea624c4\",\n    \"cb8aab6d372278f3131e8d99efde02d9\"\n  };\n  TestHighbdIntraPred(\"Intra32\", pred_funcs, kSignatures, 32);\n}",
          "fn_code_pos": [
            [
              417,
              0
            ],
            [
              428,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestHighbdIntraPred32",
            "parameters": {
              "pred_funcs": "VpxHighbdPredFunc"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*VpxPredFunc)(uint8_t *dst, ptrdiff_t y_stride,\n                            const uint8_t *above, const uint8_t *left)",
          "fn_dec_pos": [
            [
              28,
              13
            ],
            [
              29,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "dst": "uint8_t",
              "y_stride": "ptrdiff_t",
              "above": "uint8_t",
              "left": "uint8_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "rnd(libvpx_test::ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              43,
              27
            ],
            [
              43,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "(*VpxHighbdPredFunc)(uint16_t *dst, ptrdiff_t y_stride,\n                                  const uint16_t *above, const uint16_t *left,\n                                  int bd)",
          "fn_dec_pos": [
            [
              344,
              13
            ],
            [
              346,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "dst": "uint16_t",
              "y_stride": "ptrdiff_t",
              "above": "uint16_t",
              "left": "uint16_t",
              "bd": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct IntraPredTestMem {\n  void Init(int block_size, int bd) {\n    libvpx_test::ACMRandom rnd(libvpx_test::ACMRandom::DeterministicSeed());\n    Pixel *const above = above_mem + 16;\n    const int mask = (1 << bd) - 1;\n    for (int i = 0; i < kTotalPixels; ++i) ref_src[i] = rnd.Rand16() & mask;\n    for (int i = 0; i < kBPS; ++i) left[i] = rnd.Rand16() & mask;\n    for (int i = -1; i < kBPS; ++i) above[i] = rnd.Rand16() & mask;\n\n    // some code assumes the top row has been extended:\n    // d45/d63 C-code, for instance, but not the assembly.\n    // TODO(jzern): this style of extension isn't strictly necessary.\n    ASSERT_LE(block_size, kBPS);\n    for (int i = block_size; i < 2 * kBPS; ++i) {\n      above[i] = above[block_size - 1];\n    }\n  }\n\n  DECLARE_ALIGNED(16, Pixel, src[kTotalPixels]);\n  DECLARE_ALIGNED(16, Pixel, ref_src[kTotalPixels]);\n  DECLARE_ALIGNED(16, Pixel, left[kBPS]);\n  DECLARE_ALIGNED(16, Pixel, above_mem[2 * kBPS + 16]);\n}",
          {
            "(16, Pixel, src[kTotalPixels])": "DECLARE_ALIGNED",
            "(16, Pixel, ref_src[kTotalPixels])": "DECLARE_ALIGNED",
            "(16, Pixel, left[kBPS])": "DECLARE_ALIGNED",
            "(16, Pixel, above_mem[2 * kBPS + 16])": "DECLARE_ALIGNED"
          },
          "IntraPredTestMem",
          [
            41,
            0
          ],
          [
            63,
            1
          ]
        ],
        [
          "struct IntraPredTestMem {\n  void Init(int block_size, int bd) {\n    libvpx_test::ACMRandom rnd(libvpx_test::ACMRandom::DeterministicSeed());\n    Pixel *const above = above_mem + 16;\n    const int mask = (1 << bd) - 1;\n    for (int i = 0; i < kTotalPixels; ++i) ref_src[i] = rnd.Rand16() & mask;\n    for (int i = 0; i < kBPS; ++i) left[i] = rnd.Rand16() & mask;\n    for (int i = -1; i < kBPS; ++i) above[i] = rnd.Rand16() & mask;\n\n    // some code assumes the top row has been extended:\n    // d45/d63 C-code, for instance, but not the assembly.\n    // TODO(jzern): this style of extension isn't strictly necessary.\n    ASSERT_LE(block_size, kBPS);\n    for (int i = block_size; i < 2 * kBPS; ++i) {\n      above[i] = above[block_size - 1];\n    }\n  }\n\n  DECLARE_ALIGNED(16, Pixel, src[kTotalPixels]);\n  DECLARE_ALIGNED(16, Pixel, ref_src[kTotalPixels]);\n  DECLARE_ALIGNED(16, Pixel, left[kBPS]);\n  DECLARE_ALIGNED(16, Pixel, above_mem[2 * kBPS + 16]);\n}",
          {
            "(16, Pixel, src[kTotalPixels])": "DECLARE_ALIGNED",
            "(16, Pixel, ref_src[kTotalPixels])": "DECLARE_ALIGNED",
            "(16, Pixel, left[kBPS])": "DECLARE_ALIGNED",
            "(16, Pixel, above_mem[2 * kBPS + 16])": "DECLARE_ALIGNED"
          },
          "IntraPredTestMem",
          [
            41,
            0
          ],
          [
            63,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/md5_helper.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"vpx_ports/mem.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"vpx_ports/vpx_timer.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"test/test_libvpx.cc\"\n",
          [
            585,
            0
          ],
          [
            586,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/resize_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "static void mem_put_le16(char *const mem, const unsigned int val) {\n  mem[0] = val;\n  mem[1] = val >> 8;\n}",
          "fn_code_pos": [
            [
              26,
              0
            ],
            [
              29,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mem_put_le16",
            "parameters": {
              "mem": "char",
              "val": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void mem_put_le32(char *const mem, const unsigned int val) {\n  mem[0] = val;\n  mem[1] = val >> 8;\n  mem[2] = val >> 16;\n  mem[3] = val >> 24;\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              36,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mem_put_le32",
            "parameters": {
              "mem": "char",
              "val": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void write_ivf_file_header(const vpx_codec_enc_cfg_t *const cfg,\n                                  int frame_cnt, FILE *const outfile) {\n  char header[32];\n\n  header[0] = 'D';\n  header[1] = 'K';\n  header[2] = 'I';\n  header[3] = 'F';\n  mem_put_le16(header + 4, 0);                    /* version */\n  mem_put_le16(header + 6, 32);                   /* headersize */\n  mem_put_le32(header + 8, 0x30395056);           /* fourcc (vp9) */\n  mem_put_le16(header + 12, cfg->g_w);            /* width */\n  mem_put_le16(header + 14, cfg->g_h);            /* height */\n  mem_put_le32(header + 16, cfg->g_timebase.den); /* rate */\n  mem_put_le32(header + 20, cfg->g_timebase.num); /* scale */\n  mem_put_le32(header + 24, frame_cnt);           /* length */\n  mem_put_le32(header + 28, 0);                   /* unused */\n\n  (void)fwrite(header, 1, 32, outfile);\n}",
          "fn_code_pos": [
            [
              38,
              0
            ],
            [
              57,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "write_ivf_file_header",
            "parameters": {
              "cfg": "vpx_codec_enc_cfg_t",
              "frame_cnt": "int",
              "outfile": "FILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void write_ivf_frame_size(FILE *const outfile, const size_t size) {\n  char header[4];\n  mem_put_le32(header, static_cast<unsigned int>(size));\n  (void)fwrite(header, 1, 4, outfile);\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "write_ivf_frame_size",
            "parameters": {
              "outfile": "FILE",
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void write_ivf_frame_header(const vpx_codec_cx_pkt_t *const pkt,\n                                   FILE *const outfile) {\n  char header[12];\n  vpx_codec_pts_t pts;\n\n  if (pkt->kind != VPX_CODEC_CX_FRAME_PKT) return;\n\n  pts = pkt->data.frame.pts;\n  mem_put_le32(header, static_cast<unsigned int>(pkt->data.frame.sz));\n  mem_put_le32(header + 4, pts & 0xFFFFFFFF);\n  mem_put_le32(header + 8, pts >> 32);\n\n  (void)fwrite(header, 1, 12, outfile);\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              78,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "write_ivf_frame_header",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t",
              "outfile": "FILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "FrameInfo(vpx_codec_pts_t _pts, unsigned int _w, unsigned int _h)\n      : pts(_pts), w(_w), h(_h) {}",
          "fn_code_pos": [
            [
              85,
              2
            ],
            [
              86,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FrameInfo",
            "parameters": {
              "_pts": "vpx_codec_pts_t",
              "_w": "unsigned int",
              "_h": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void ScaleForFrameNumber(unsigned int frame, unsigned int initial_w,\n                         unsigned int initial_h, unsigned int *w,\n                         unsigned int *h, int flag_codec) {\n  if (frame < 10) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 20) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 30) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 40) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 50) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 60) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 70) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 80) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 90) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 100) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 110) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 120) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 130) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 140) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 150) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 160) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 170) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 180) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 190) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 200) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 210) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 220) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 230) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 240) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 250) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 260) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  // Go down very low.\n  if (frame < 270) {\n    *w = initial_w / 4;\n    *h = initial_h / 4;\n    return;\n  }\n  if (flag_codec == 1) {\n    // Cases that only works for VP9.\n    // For VP9: Swap width and height of original.\n    if (frame < 320) {\n      *w = initial_h;\n      *h = initial_w;\n      return;\n    }\n  }\n  *w = initial_w;\n  *h = initial_h;\n}",
          "fn_code_pos": [
            [
              93,
              0
            ],
            [
              243,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ScaleForFrameNumber",
            "parameters": {
              "frame": "unsigned int",
              "initial_w": "unsigned int",
              "initial_h": "unsigned int",
              "w": "unsigned int",
              "h": "unsigned int",
              "flag_codec": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ResizingVideoSource() {\n    SetSize(kInitialWidth, kInitialHeight);\n    limit_ = 350;\n  }",
          "fn_code_pos": [
            [
              247,
              2
            ],
            [
              250,
              3
            ]
          ],
          "class_code": "68717f8038ee5d3a32130ebfc18c77dbb3a0db292b9d103d2344fd86dafc46f6",
          "class_node_pos": [
            [
              245,
              0
            ],
            [
              264,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ResizingVideoSource",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~ResizingVideoSource() {}",
          "fn_code_pos": [
            [
              252,
              2
            ],
            [
              252,
              35
            ]
          ],
          "class_code": "68717f8038ee5d3a32130ebfc18c77dbb3a0db292b9d103d2344fd86dafc46f6",
          "class_node_pos": [
            [
              245,
              0
            ],
            [
              264,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void Next() {\n    ++frame_;\n    unsigned int width;\n    unsigned int height;\n    ScaleForFrameNumber(frame_, kInitialWidth, kInitialHeight, &width, &height,\n                        flag_codec_);\n    SetSize(width, height);\n    FillFrame();\n  }",
          "fn_code_pos": [
            [
              255,
              2
            ],
            [
              263,
              3
            ]
          ],
          "class_code": "68717f8038ee5d3a32130ebfc18c77dbb3a0db292b9d103d2344fd86dafc46f6",
          "class_node_pos": [
            [
              245,
              0
            ],
            [
              264,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Next",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "ResizeTest() : EncoderTest(GET_PARAM(0)) {}",
          "fn_code_pos": [
            [
              270,
              2
            ],
            [
              270,
              45
            ]
          ],
          "class_code": "c549b821a90b97b697e7650f97a52fd7be5a1d58aaa11610834b33b9e4baf1c3",
          "class_node_pos": [
            [
              266,
              0
            ],
            [
              302,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ResizeTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~ResizeTest() {}",
          "fn_code_pos": [
            [
              272,
              2
            ],
            [
              272,
              26
            ]
          ],
          "class_code": "c549b821a90b97b697e7650f97a52fd7be5a1d58aaa11610834b33b9e4baf1c3",
          "class_node_pos": [
            [
              266,
              0
            ],
            [
              302,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n  }",
          "fn_code_pos": [
            [
              274,
              2
            ],
            [
              277,
              3
            ]
          ],
          "class_code": "c549b821a90b97b697e7650f97a52fd7be5a1d58aaa11610834b33b9e4baf1c3",
          "class_node_pos": [
            [
              266,
              0
            ],
            [
              302,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    ASSERT_NE(static_cast<int>(pkt->data.frame.width[0]), 0);\n    ASSERT_NE(static_cast<int>(pkt->data.frame.height[0]), 0);\n    encode_frame_width_.push_back(pkt->data.frame.width[0]);\n    encode_frame_height_.push_back(pkt->data.frame.height[0]);\n  }",
          "fn_code_pos": [
            [
              279,
              2
            ],
            [
              284,
              3
            ]
          ],
          "class_code": "c549b821a90b97b697e7650f97a52fd7be5a1d58aaa11610834b33b9e4baf1c3",
          "class_node_pos": [
            [
              266,
              0
            ],
            [
              302,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "unsigned int GetFrameWidth(size_t idx) const {\n    return encode_frame_width_[idx];\n  }",
          "fn_code_pos": [
            [
              286,
              2
            ],
            [
              288,
              3
            ]
          ],
          "class_code": "c549b821a90b97b697e7650f97a52fd7be5a1d58aaa11610834b33b9e4baf1c3",
          "class_node_pos": [
            [
              266,
              0
            ],
            [
              302,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetFrameWidth",
            "parameters": {
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned int GetFrameHeight(size_t idx) const {\n    return encode_frame_height_[idx];\n  }",
          "fn_code_pos": [
            [
              290,
              2
            ],
            [
              292,
              3
            ]
          ],
          "class_code": "c549b821a90b97b697e7650f97a52fd7be5a1d58aaa11610834b33b9e4baf1c3",
          "class_node_pos": [
            [
              266,
              0
            ],
            [
              302,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetFrameHeight",
            "parameters": {
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void DecompressedFrameHook(const vpx_image_t &img,\n                                     vpx_codec_pts_t pts) {\n    frame_info_list_.push_back(FrameInfo(pts, img.d_w, img.d_h));\n  }",
          "fn_code_pos": [
            [
              294,
              2
            ],
            [
              297,
              3
            ]
          ],
          "class_code": "c549b821a90b97b697e7650f97a52fd7be5a1d58aaa11610834b33b9e4baf1c3",
          "class_node_pos": [
            [
              266,
              0
            ],
            [
              302,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecompressedFrameHook",
            "parameters": {
              "img": "vpx_image_t",
              "pts": "vpx_codec_pts_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(ResizeTest, TestExternalResizeWorks) {\n  ResizingVideoSource video;\n  video.flag_codec_ = 0;\n  cfg_.g_lag_in_frames = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const unsigned int frame = static_cast<unsigned>(info->pts);\n    unsigned int expected_w;\n    unsigned int expected_h;\n    const size_t idx = info - frame_info_list_.begin();\n    ASSERT_EQ(info->w, GetFrameWidth(idx));\n    ASSERT_EQ(info->h, GetFrameHeight(idx));\n    ScaleForFrameNumber(frame, kInitialWidth, kInitialHeight, &expected_w,\n                        &expected_h, 0);\n    EXPECT_EQ(expected_w, info->w)\n        << \"Frame \" << frame << \" had unexpected width\";\n    EXPECT_EQ(expected_h, info->h)\n        << \"Frame \" << frame << \" had unexpected height\";\n  }\n}",
          "fn_code_pos": [
            [
              304,
              0
            ],
            [
              325,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ResizeInternalTest()\n      : ResizeTest(), frame0_psnr_(0.0), outfile_(NULL), out_frames_(0) {}",
          "fn_code_pos": [
            [
              333,
              2
            ],
            [
              334,
              74
            ]
          ],
          "class_code": "d4417853be45218c1814e7ed76e09a48d1e68dfa43ab3bf19fac3f9a56fa03da",
          "class_node_pos": [
            [
              330,
              0
            ],
            [
              408,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ResizeInternalTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ResizeInternalTest() : ResizeTest(), frame0_psnr_(0.0) {}",
          "fn_code_pos": [
            [
              336,
              2
            ],
            [
              336,
              59
            ]
          ],
          "class_code": "d4417853be45218c1814e7ed76e09a48d1e68dfa43ab3bf19fac3f9a56fa03da",
          "class_node_pos": [
            [
              330,
              0
            ],
            [
              408,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ResizeInternalTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~ResizeInternalTest() {}",
          "fn_code_pos": [
            [
              339,
              2
            ],
            [
              339,
              34
            ]
          ],
          "class_code": "d4417853be45218c1814e7ed76e09a48d1e68dfa43ab3bf19fac3f9a56fa03da",
          "class_node_pos": [
            [
              330,
              0
            ],
            [
              408,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void BeginPassHook(unsigned int /*pass*/) {\n#if WRITE_COMPRESSED_STREAM\n    outfile_ = fopen(\"vp90-2-05-resize.ivf\", \"wb\");\n#endif\n  }",
          "fn_code_pos": [
            [
              341,
              2
            ],
            [
              345,
              3
            ]
          ],
          "class_code": "d4417853be45218c1814e7ed76e09a48d1e68dfa43ab3bf19fac3f9a56fa03da",
          "class_node_pos": [
            [
              330,
              0
            ],
            [
              408,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BeginPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void EndPassHook() {\n#if WRITE_COMPRESSED_STREAM\n    if (outfile_) {\n      if (!fseek(outfile_, 0, SEEK_SET))\n        write_ivf_file_header(&cfg_, out_frames_, outfile_);\n      fclose(outfile_);\n      outfile_ = NULL;\n    }\n#endif\n  }",
          "fn_code_pos": [
            [
              347,
              2
            ],
            [
              356,
              3
            ]
          ],
          "class_code": "d4417853be45218c1814e7ed76e09a48d1e68dfa43ab3bf19fac3f9a56fa03da",
          "class_node_pos": [
            [
              330,
              0
            ],
            [
              408,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EndPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                                  libvpx_test::Encoder *encoder) {\n    if (change_config_) {\n      int new_q = 60;\n      if (video->frame() == 0) {\n        struct vpx_scaling_mode mode = { VP8E_ONETWO, VP8E_ONETWO };\n        encoder->Control(VP8E_SET_SCALEMODE, &mode);\n      }\n      if (video->frame() == 1) {\n        struct vpx_scaling_mode mode = { VP8E_NORMAL, VP8E_NORMAL };\n        encoder->Control(VP8E_SET_SCALEMODE, &mode);\n        cfg_.rc_min_quantizer = cfg_.rc_max_quantizer = new_q;\n        encoder->Config(&cfg_);\n      }\n    } else {\n      if (video->frame() == kStepDownFrame) {\n        struct vpx_scaling_mode mode = { VP8E_FOURFIVE, VP8E_THREEFIVE };\n        encoder->Control(VP8E_SET_SCALEMODE, &mode);\n      }\n      if (video->frame() == kStepUpFrame) {\n        struct vpx_scaling_mode mode = { VP8E_NORMAL, VP8E_NORMAL };\n        encoder->Control(VP8E_SET_SCALEMODE, &mode);\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              358,
              2
            ],
            [
              382,
              3
            ]
          ],
          "class_code": "d4417853be45218c1814e7ed76e09a48d1e68dfa43ab3bf19fac3f9a56fa03da",
          "class_node_pos": [
            [
              330,
              0
            ],
            [
              408,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "libvpx_test::VideoSource",
              "encoder": "libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (frame0_psnr_ == 0.) frame0_psnr_ = pkt->data.psnr.psnr[0];\n    EXPECT_NEAR(pkt->data.psnr.psnr[0], frame0_psnr_, 2.0);\n  }",
          "fn_code_pos": [
            [
              384,
              2
            ],
            [
              387,
              3
            ]
          ],
          "class_code": "d4417853be45218c1814e7ed76e09a48d1e68dfa43ab3bf19fac3f9a56fa03da",
          "class_node_pos": [
            [
              330,
              0
            ],
            [
              408,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PSNRPktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    ++out_frames_;\n\n    // Write initial file header if first frame.\n    if (pkt->data.frame.pts == 0) write_ivf_file_header(&cfg_, 0, outfile_);\n\n    // Write frame header and data.\n    write_ivf_frame_header(pkt, outfile_);\n    (void)fwrite(pkt->data.frame.buf, 1, pkt->data.frame.sz, outfile_);\n  }",
          "fn_code_pos": [
            [
              390,
              2
            ],
            [
              399,
              3
            ]
          ],
          "class_code": "d4417853be45218c1814e7ed76e09a48d1e68dfa43ab3bf19fac3f9a56fa03da",
          "class_node_pos": [
            [
              330,
              0
            ],
            [
              408,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(ResizeInternalTest, TestInternalResizeWorks) {\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 10);\n  init_flags_ = VPX_CODEC_USE_PSNR;\n  change_config_ = false;\n\n  // q picked such that initial keyframe on this clip is ~30dB PSNR\n  cfg_.rc_min_quantizer = cfg_.rc_max_quantizer = 48;\n\n  // If the number of frames being encoded is smaller than g_lag_in_frames\n  // the encoded frame is unavailable using the current API. Comparing\n  // frames to detect mismatch would then not be possible. Set\n  // g_lag_in_frames = 0 to get around this.\n  cfg_.g_lag_in_frames = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const vpx_codec_pts_t pts = info->pts;\n    if (pts >= kStepDownFrame && pts < kStepUpFrame) {\n      ASSERT_EQ(282U, info->w) << \"Frame \" << pts << \" had unexpected width\";\n      ASSERT_EQ(173U, info->h) << \"Frame \" << pts << \" had unexpected height\";\n    } else {\n      EXPECT_EQ(352U, info->w) << \"Frame \" << pts << \" had unexpected width\";\n      EXPECT_EQ(288U, info->h) << \"Frame \" << pts << \" had unexpected height\";\n    }\n  }\n}",
          "fn_code_pos": [
            [
              410,
              0
            ],
            [
              437,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ResizeInternalTest, TestInternalResizeChangeConfig) {\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 10);\n  cfg_.g_w = 352;\n  cfg_.g_h = 288;\n  change_config_ = true;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              439,
              0
            ],
            [
              446,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ResizeRealtimeTest() : EncoderTest(GET_PARAM(0)) {}",
          "fn_code_pos": [
            [
              452,
              2
            ],
            [
              452,
              53
            ]
          ],
          "class_code": "9b11f33706e4a91aadddcdcd15ec993e54dfca2e95c5b9f60ab227a976f7dcad",
          "class_node_pos": [
            [
              448,
              0
            ],
            [
              532,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ResizeRealtimeTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~ResizeRealtimeTest() {}",
          "fn_code_pos": [
            [
              453,
              2
            ],
            [
              453,
              34
            ]
          ],
          "class_code": "9b11f33706e4a91aadddcdcd15ec993e54dfca2e95c5b9f60ab227a976f7dcad",
          "class_node_pos": [
            [
              448,
              0
            ],
            [
              532,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                                  libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP9E_SET_AQ_MODE, 3);\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n    }\n\n    if (change_bitrate_ && video->frame() == 120) {\n      change_bitrate_ = false;\n      cfg_.rc_target_bitrate = 500;\n      encoder->Config(&cfg_);\n    }\n  }",
          "fn_code_pos": [
            [
              455,
              2
            ],
            [
              467,
              3
            ]
          ],
          "class_code": "9b11f33706e4a91aadddcdcd15ec993e54dfca2e95c5b9f60ab227a976f7dcad",
          "class_node_pos": [
            [
              448,
              0
            ],
            [
              532,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "libvpx_test::VideoSource",
              "encoder": "libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n    set_cpu_used_ = GET_PARAM(2);\n  }",
          "fn_code_pos": [
            [
              469,
              2
            ],
            [
              473,
              3
            ]
          ],
          "class_code": "9b11f33706e4a91aadddcdcd15ec993e54dfca2e95c5b9f60ab227a976f7dcad",
          "class_node_pos": [
            [
              448,
              0
            ],
            [
              532,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void DecompressedFrameHook(const vpx_image_t &img,\n                                     vpx_codec_pts_t pts) {\n    frame_info_list_.push_back(FrameInfo(pts, img.d_w, img.d_h));\n  }",
          "fn_code_pos": [
            [
              475,
              2
            ],
            [
              478,
              3
            ]
          ],
          "class_code": "9b11f33706e4a91aadddcdcd15ec993e54dfca2e95c5b9f60ab227a976f7dcad",
          "class_node_pos": [
            [
              448,
              0
            ],
            [
              532,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecompressedFrameHook",
            "parameters": {
              "img": "vpx_image_t",
              "pts": "vpx_codec_pts_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void MismatchHook(const vpx_image_t *img1, const vpx_image_t *img2) {\n    double mismatch_psnr = compute_psnr(img1, img2);\n    mismatch_psnr_ += mismatch_psnr;\n    ++mismatch_nframes_;\n  }",
          "fn_code_pos": [
            [
              480,
              2
            ],
            [
              484,
              3
            ]
          ],
          "class_code": "9b11f33706e4a91aadddcdcd15ec993e54dfca2e95c5b9f60ab227a976f7dcad",
          "class_node_pos": [
            [
              448,
              0
            ],
            [
              532,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MismatchHook",
            "parameters": {
              "img1": "vpx_image_t",
              "img2": "vpx_image_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    ASSERT_NE(static_cast<int>(pkt->data.frame.width[0]), 0);\n    ASSERT_NE(static_cast<int>(pkt->data.frame.height[0]), 0);\n    encode_frame_width_.push_back(pkt->data.frame.width[0]);\n    encode_frame_height_.push_back(pkt->data.frame.height[0]);\n  }",
          "fn_code_pos": [
            [
              486,
              2
            ],
            [
              491,
              3
            ]
          ],
          "class_code": "9b11f33706e4a91aadddcdcd15ec993e54dfca2e95c5b9f60ab227a976f7dcad",
          "class_node_pos": [
            [
              448,
              0
            ],
            [
              532,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "unsigned int GetMismatchFrames() { return mismatch_nframes_; }",
          "fn_code_pos": [
            [
              493,
              2
            ],
            [
              493,
              64
            ]
          ],
          "class_code": "9b11f33706e4a91aadddcdcd15ec993e54dfca2e95c5b9f60ab227a976f7dcad",
          "class_node_pos": [
            [
              448,
              0
            ],
            [
              532,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetMismatchFrames",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned int GetFrameWidth(size_t idx) const {\n    return encode_frame_width_[idx];\n  }",
          "fn_code_pos": [
            [
              495,
              2
            ],
            [
              497,
              3
            ]
          ],
          "class_code": "9b11f33706e4a91aadddcdcd15ec993e54dfca2e95c5b9f60ab227a976f7dcad",
          "class_node_pos": [
            [
              448,
              0
            ],
            [
              532,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetFrameWidth",
            "parameters": {
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned int GetFrameHeight(size_t idx) const {\n    return encode_frame_height_[idx];\n  }",
          "fn_code_pos": [
            [
              499,
              2
            ],
            [
              501,
              3
            ]
          ],
          "class_code": "9b11f33706e4a91aadddcdcd15ec993e54dfca2e95c5b9f60ab227a976f7dcad",
          "class_node_pos": [
            [
              448,
              0
            ],
            [
              532,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetFrameHeight",
            "parameters": {
              "idx": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void DefaultConfig() {\n    cfg_.rc_buf_initial_sz = 500;\n    cfg_.rc_buf_optimal_sz = 600;\n    cfg_.rc_buf_sz = 1000;\n    cfg_.rc_min_quantizer = 2;\n    cfg_.rc_max_quantizer = 56;\n    cfg_.rc_undershoot_pct = 50;\n    cfg_.rc_overshoot_pct = 50;\n    cfg_.rc_end_usage = VPX_CBR;\n    cfg_.kf_mode = VPX_KF_AUTO;\n    cfg_.g_lag_in_frames = 0;\n    cfg_.kf_min_dist = cfg_.kf_max_dist = 3000;\n    // Enable dropped frames.\n    cfg_.rc_dropframe_thresh = 1;\n    // Enable error_resilience mode.\n    cfg_.g_error_resilient = 1;\n    // Enable dynamic resizing.\n    cfg_.rc_resize_allowed = 1;\n    // Run at low bitrate.\n    cfg_.rc_target_bitrate = 200;\n  }",
          "fn_code_pos": [
            [
              503,
              2
            ],
            [
              523,
              3
            ]
          ],
          "class_code": "9b11f33706e4a91aadddcdcd15ec993e54dfca2e95c5b9f60ab227a976f7dcad",
          "class_node_pos": [
            [
              448,
              0
            ],
            [
              532,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DefaultConfig",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(ResizeRealtimeTest, TestExternalResizeWorks) {\n  ResizingVideoSource video;\n  video.flag_codec_ = 1;\n  DefaultConfig();\n  // Disable internal resize for this test.\n  cfg_.rc_resize_allowed = 0;\n  change_bitrate_ = false;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const unsigned int frame = static_cast<unsigned>(info->pts);\n    unsigned int expected_w;\n    unsigned int expected_h;\n    ScaleForFrameNumber(frame, kInitialWidth, kInitialHeight, &expected_w,\n                        &expected_h, 1);\n    EXPECT_EQ(expected_w, info->w)\n        << \"Frame \" << frame << \" had unexpected width\";\n    EXPECT_EQ(expected_h, info->h)\n        << \"Frame \" << frame << \" had unexpected height\";\n    EXPECT_EQ(static_cast<unsigned int>(0), GetMismatchFrames());\n  }\n}",
          "fn_code_pos": [
            [
              534,
              0
            ],
            [
              558,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ResizeRealtimeTest, TestInternalResizeDown) {\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 299);\n  DefaultConfig();\n  cfg_.g_w = 352;\n  cfg_.g_h = 288;\n  change_bitrate_ = false;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  unsigned int last_w = cfg_.g_w;\n  unsigned int last_h = cfg_.g_h;\n  int resize_count = 0;\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    if (info->w != last_w || info->h != last_h) {\n      // Verify that resize down occurs.\n      ASSERT_LT(info->w, last_w);\n      ASSERT_LT(info->h, last_h);\n      last_w = info->w;\n      last_h = info->h;\n      resize_count++;\n    }\n  }\n\n#if CONFIG_VP9_DECODER\n  // Verify that we get 1 resize down event in this test.\n  ASSERT_EQ(1, resize_count) << \"Resizing should occur.\";\n  EXPECT_EQ(static_cast<unsigned int>(0), GetMismatchFrames());\n#else\n  printf(\"Warning: VP9 decoder unavailable, unable to check resize count!\\n\");\n#endif\n}",
          "fn_code_pos": [
            [
              563,
              0
            ],
            [
              596,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ResizeRealtimeTest, TestInternalResizeDownUpChangeBitRate) {\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 359);\n  DefaultConfig();\n  cfg_.g_w = 352;\n  cfg_.g_h = 288;\n  change_bitrate_ = true;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  // Disable dropped frames.\n  cfg_.rc_dropframe_thresh = 0;\n  // Starting bitrate low.\n  cfg_.rc_target_bitrate = 80;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  unsigned int last_w = cfg_.g_w;\n  unsigned int last_h = cfg_.g_h;\n  int resize_count = 0;\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const size_t idx = info - frame_info_list_.begin();\n    ASSERT_EQ(info->w, GetFrameWidth(idx));\n    ASSERT_EQ(info->h, GetFrameHeight(idx));\n    if (info->w != last_w || info->h != last_h) {\n      resize_count++;\n      if (resize_count == 1) {\n        // Verify that resize down occurs.\n        ASSERT_LT(info->w, last_w);\n        ASSERT_LT(info->h, last_h);\n      } else if (resize_count == 2) {\n        // Verify that resize up occurs.\n        ASSERT_GT(info->w, last_w);\n        ASSERT_GT(info->h, last_h);\n      }\n      last_w = info->w;\n      last_h = info->h;\n    }\n  }\n\n#if CONFIG_VP9_DECODER\n  // Verify that we get 2 resize events in this test.\n  ASSERT_EQ(resize_count, 2) << \"Resizing should occur twice.\";\n  EXPECT_EQ(static_cast<unsigned int>(0), GetMismatchFrames());\n#else\n  printf(\"Warning: VP9 decoder unavailable, unable to check resize count!\\n\");\n#endif\n}",
          "fn_code_pos": [
            [
              601,
              0
            ],
            [
              647,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "vpx_img_fmt_t CspForFrameNumber(int frame) {\n  if (frame < 10) return VPX_IMG_FMT_I420;\n  if (frame < 20) return VPX_IMG_FMT_I444;\n  return VPX_IMG_FMT_I420;\n}",
          "fn_code_pos": [
            [
              649,
              0
            ],
            [
              653,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CspForFrameNumber",
            "parameters": {
              "frame": "int"
            },
            "return_type": "vpx_img_fmt_t"
          }
        },
        {
          "fn_code": "ResizeCspTest()\n      : ResizeTest(), frame0_psnr_(0.0), outfile_(NULL), out_frames_(0) {}",
          "fn_code_pos": [
            [
              658,
              2
            ],
            [
              659,
              74
            ]
          ],
          "class_code": "710b37896703978d2fb78715f917041bd85b523c013c2c08a6616d9e3062fd78",
          "class_node_pos": [
            [
              655,
              0
            ],
            [
              720,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ResizeCspTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ResizeCspTest() : ResizeTest(), frame0_psnr_(0.0) {}",
          "fn_code_pos": [
            [
              661,
              2
            ],
            [
              661,
              54
            ]
          ],
          "class_code": "710b37896703978d2fb78715f917041bd85b523c013c2c08a6616d9e3062fd78",
          "class_node_pos": [
            [
              655,
              0
            ],
            [
              720,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ResizeCspTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~ResizeCspTest() {}",
          "fn_code_pos": [
            [
              664,
              2
            ],
            [
              664,
              29
            ]
          ],
          "class_code": "710b37896703978d2fb78715f917041bd85b523c013c2c08a6616d9e3062fd78",
          "class_node_pos": [
            [
              655,
              0
            ],
            [
              720,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void BeginPassHook(unsigned int /*pass*/) {\n#if WRITE_COMPRESSED_STREAM\n    outfile_ = fopen(\"vp91-2-05-cspchape.ivf\", \"wb\");\n#endif\n  }",
          "fn_code_pos": [
            [
              666,
              2
            ],
            [
              670,
              3
            ]
          ],
          "class_code": "710b37896703978d2fb78715f917041bd85b523c013c2c08a6616d9e3062fd78",
          "class_node_pos": [
            [
              655,
              0
            ],
            [
              720,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BeginPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void EndPassHook() {\n#if WRITE_COMPRESSED_STREAM\n    if (outfile_) {\n      if (!fseek(outfile_, 0, SEEK_SET))\n        write_ivf_file_header(&cfg_, out_frames_, outfile_);\n      fclose(outfile_);\n      outfile_ = NULL;\n    }\n#endif\n  }",
          "fn_code_pos": [
            [
              672,
              2
            ],
            [
              681,
              3
            ]
          ],
          "class_code": "710b37896703978d2fb78715f917041bd85b523c013c2c08a6616d9e3062fd78",
          "class_node_pos": [
            [
              655,
              0
            ],
            [
              720,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EndPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                                  libvpx_test::Encoder *encoder) {\n    if (CspForFrameNumber(video->frame()) != VPX_IMG_FMT_I420 &&\n        cfg_.g_profile != 1) {\n      cfg_.g_profile = 1;\n      encoder->Config(&cfg_);\n    }\n    if (CspForFrameNumber(video->frame()) == VPX_IMG_FMT_I420 &&\n        cfg_.g_profile != 0) {\n      cfg_.g_profile = 0;\n      encoder->Config(&cfg_);\n    }\n  }",
          "fn_code_pos": [
            [
              683,
              2
            ],
            [
              695,
              3
            ]
          ],
          "class_code": "710b37896703978d2fb78715f917041bd85b523c013c2c08a6616d9e3062fd78",
          "class_node_pos": [
            [
              655,
              0
            ],
            [
              720,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "libvpx_test::VideoSource",
              "encoder": "libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (frame0_psnr_ == 0.) frame0_psnr_ = pkt->data.psnr.psnr[0];\n    EXPECT_NEAR(pkt->data.psnr.psnr[0], frame0_psnr_, 2.0);\n  }",
          "fn_code_pos": [
            [
              697,
              2
            ],
            [
              700,
              3
            ]
          ],
          "class_code": "710b37896703978d2fb78715f917041bd85b523c013c2c08a6616d9e3062fd78",
          "class_node_pos": [
            [
              655,
              0
            ],
            [
              720,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PSNRPktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    ++out_frames_;\n\n    // Write initial file header if first frame.\n    if (pkt->data.frame.pts == 0) write_ivf_file_header(&cfg_, 0, outfile_);\n\n    // Write frame header and data.\n    write_ivf_frame_header(pkt, outfile_);\n    (void)fwrite(pkt->data.frame.buf, 1, pkt->data.frame.sz, outfile_);\n  }",
          "fn_code_pos": [
            [
              703,
              2
            ],
            [
              712,
              3
            ]
          ],
          "class_code": "710b37896703978d2fb78715f917041bd85b523c013c2c08a6616d9e3062fd78",
          "class_node_pos": [
            [
              655,
              0
            ],
            [
              720,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ResizingCspVideoSource() {\n    SetSize(kInitialWidth, kInitialHeight);\n    limit_ = 30;\n  }",
          "fn_code_pos": [
            [
              724,
              2
            ],
            [
              727,
              3
            ]
          ],
          "class_code": "ab1fc461207200223ee4e8147c374a37f242d8c96df921d59ee4068cdd051bb1",
          "class_node_pos": [
            [
              722,
              0
            ],
            [
              737,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ResizingCspVideoSource",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~ResizingCspVideoSource() {}",
          "fn_code_pos": [
            [
              729,
              2
            ],
            [
              729,
              38
            ]
          ],
          "class_code": "ab1fc461207200223ee4e8147c374a37f242d8c96df921d59ee4068cdd051bb1",
          "class_node_pos": [
            [
              722,
              0
            ],
            [
              737,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void Next() {\n    ++frame_;\n    SetImageFormat(CspForFrameNumber(frame_));\n    FillFrame();\n  }",
          "fn_code_pos": [
            [
              732,
              2
            ],
            [
              736,
              3
            ]
          ],
          "class_code": "ab1fc461207200223ee4e8147c374a37f242d8c96df921d59ee4068cdd051bb1",
          "class_node_pos": [
            [
              722,
              0
            ],
            [
              737,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Next",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(ResizeCspTest, TestResizeCspWorks) {\n  ResizingCspVideoSource video;\n  init_flags_ = VPX_CODEC_USE_PSNR;\n  cfg_.rc_min_quantizer = cfg_.rc_max_quantizer = 48;\n  cfg_.g_lag_in_frames = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              739,
              0
            ],
            [
              745,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "68717f8038ee5d3a32130ebfc18c77dbb3a0db292b9d103d2344fd86dafc46f6": {
          "class_code": "class ResizingVideoSource : public ::libvpx_test::DummyVideoSource {\n public:\n  ResizingVideoSource() {\n    SetSize(kInitialWidth, kInitialHeight);\n    limit_ = 350;\n  }\n  int flag_codec_;\n  virtual ~ResizingVideoSource() {}\n\n protected:\n  virtual void Next() {\n    ++frame_;\n    unsigned int width;\n    unsigned int height;\n    ScaleForFrameNumber(frame_, kInitialWidth, kInitialHeight, &width, &height,\n                        flag_codec_);\n    SetSize(width, height);\n    FillFrame();\n  }\n}",
          "class_name": "ResizingVideoSource",
          "class_pos": [
            [
              245,
              0
            ],
            [
              264,
              1
            ]
          ]
        },
        "c549b821a90b97b697e7650f97a52fd7be5a1d58aaa11610834b33b9e4baf1c3": {
          "class_code": "class ResizeTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWithParam<libvpx_test::TestMode> {\n protected:\n  ResizeTest() : EncoderTest(GET_PARAM(0)) {}\n\n  virtual ~ResizeTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n  }\n\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    ASSERT_NE(static_cast<int>(pkt->data.frame.width[0]), 0);\n    ASSERT_NE(static_cast<int>(pkt->data.frame.height[0]), 0);\n    encode_frame_width_.push_back(pkt->data.frame.width[0]);\n    encode_frame_height_.push_back(pkt->data.frame.height[0]);\n  }\n\n  unsigned int GetFrameWidth(size_t idx) const {\n    return encode_frame_width_[idx];\n  }\n\n  unsigned int GetFrameHeight(size_t idx) const {\n    return encode_frame_height_[idx];\n  }\n\n  virtual void DecompressedFrameHook(const vpx_image_t &img,\n                                     vpx_codec_pts_t pts) {\n    frame_info_list_.push_back(FrameInfo(pts, img.d_w, img.d_h));\n  }\n\n  std::vector<FrameInfo> frame_info_list_;\n  std::vector<unsigned int> encode_frame_width_;\n  std::vector<unsigned int> encode_frame_height_;\n}",
          "class_name": "ResizeTest",
          "class_pos": [
            [
              266,
              0
            ],
            [
              302,
              1
            ]
          ]
        },
        "d4417853be45218c1814e7ed76e09a48d1e68dfa43ab3bf19fac3f9a56fa03da": {
          "class_code": "class ResizeInternalTest : public ResizeTest {\n protected:\n#if WRITE_COMPRESSED_STREAM\n  ResizeInternalTest()\n      : ResizeTest(), frame0_psnr_(0.0), outfile_(NULL), out_frames_(0) {}\n#else\n  ResizeInternalTest() : ResizeTest(), frame0_psnr_(0.0) {}\n#endif\n\n  virtual ~ResizeInternalTest() {}\n\n  virtual void BeginPassHook(unsigned int /*pass*/) {\n#if WRITE_COMPRESSED_STREAM\n    outfile_ = fopen(\"vp90-2-05-resize.ivf\", \"wb\");\n#endif\n  }\n\n  virtual void EndPassHook() {\n#if WRITE_COMPRESSED_STREAM\n    if (outfile_) {\n      if (!fseek(outfile_, 0, SEEK_SET))\n        write_ivf_file_header(&cfg_, out_frames_, outfile_);\n      fclose(outfile_);\n      outfile_ = NULL;\n    }\n#endif\n  }\n\n  virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                                  libvpx_test::Encoder *encoder) {\n    if (change_config_) {\n      int new_q = 60;\n      if (video->frame() == 0) {\n        struct vpx_scaling_mode mode = { VP8E_ONETWO, VP8E_ONETWO };\n        encoder->Control(VP8E_SET_SCALEMODE, &mode);\n      }\n      if (video->frame() == 1) {\n        struct vpx_scaling_mode mode = { VP8E_NORMAL, VP8E_NORMAL };\n        encoder->Control(VP8E_SET_SCALEMODE, &mode);\n        cfg_.rc_min_quantizer = cfg_.rc_max_quantizer = new_q;\n        encoder->Config(&cfg_);\n      }\n    } else {\n      if (video->frame() == kStepDownFrame) {\n        struct vpx_scaling_mode mode = { VP8E_FOURFIVE, VP8E_THREEFIVE };\n        encoder->Control(VP8E_SET_SCALEMODE, &mode);\n      }\n      if (video->frame() == kStepUpFrame) {\n        struct vpx_scaling_mode mode = { VP8E_NORMAL, VP8E_NORMAL };\n        encoder->Control(VP8E_SET_SCALEMODE, &mode);\n      }\n    }\n  }\n\n  virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (frame0_psnr_ == 0.) frame0_psnr_ = pkt->data.psnr.psnr[0];\n    EXPECT_NEAR(pkt->data.psnr.psnr[0], frame0_psnr_, 2.0);\n  }\n\n#if WRITE_COMPRESSED_STREAM\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    ++out_frames_;\n\n    // Write initial file header if first frame.\n    if (pkt->data.frame.pts == 0) write_ivf_file_header(&cfg_, 0, outfile_);\n\n    // Write frame header and data.\n    write_ivf_frame_header(pkt, outfile_);\n    (void)fwrite(pkt->data.frame.buf, 1, pkt->data.frame.sz, outfile_);\n  }\n#endif\n\n  double frame0_psnr_;\n  bool change_config_;\n#if WRITE_COMPRESSED_STREAM\n  FILE *outfile_;\n  unsigned int out_frames_;\n#endif\n}",
          "class_name": "ResizeInternalTest",
          "class_pos": [
            [
              330,
              0
            ],
            [
              408,
              1
            ]
          ]
        },
        "9b11f33706e4a91aadddcdcd15ec993e54dfca2e95c5b9f60ab227a976f7dcad": {
          "class_code": "class ResizeRealtimeTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWith2Params<libvpx_test::TestMode, int> {\n protected:\n  ResizeRealtimeTest() : EncoderTest(GET_PARAM(0)) {}\n  virtual ~ResizeRealtimeTest() {}\n\n  virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                                  libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP9E_SET_AQ_MODE, 3);\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n    }\n\n    if (change_bitrate_ && video->frame() == 120) {\n      change_bitrate_ = false;\n      cfg_.rc_target_bitrate = 500;\n      encoder->Config(&cfg_);\n    }\n  }\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n    set_cpu_used_ = GET_PARAM(2);\n  }\n\n  virtual void DecompressedFrameHook(const vpx_image_t &img,\n                                     vpx_codec_pts_t pts) {\n    frame_info_list_.push_back(FrameInfo(pts, img.d_w, img.d_h));\n  }\n\n  virtual void MismatchHook(const vpx_image_t *img1, const vpx_image_t *img2) {\n    double mismatch_psnr = compute_psnr(img1, img2);\n    mismatch_psnr_ += mismatch_psnr;\n    ++mismatch_nframes_;\n  }\n\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    ASSERT_NE(static_cast<int>(pkt->data.frame.width[0]), 0);\n    ASSERT_NE(static_cast<int>(pkt->data.frame.height[0]), 0);\n    encode_frame_width_.push_back(pkt->data.frame.width[0]);\n    encode_frame_height_.push_back(pkt->data.frame.height[0]);\n  }\n\n  unsigned int GetMismatchFrames() { return mismatch_nframes_; }\n\n  unsigned int GetFrameWidth(size_t idx) const {\n    return encode_frame_width_[idx];\n  }\n\n  unsigned int GetFrameHeight(size_t idx) const {\n    return encode_frame_height_[idx];\n  }\n\n  void DefaultConfig() {\n    cfg_.rc_buf_initial_sz = 500;\n    cfg_.rc_buf_optimal_sz = 600;\n    cfg_.rc_buf_sz = 1000;\n    cfg_.rc_min_quantizer = 2;\n    cfg_.rc_max_quantizer = 56;\n    cfg_.rc_undershoot_pct = 50;\n    cfg_.rc_overshoot_pct = 50;\n    cfg_.rc_end_usage = VPX_CBR;\n    cfg_.kf_mode = VPX_KF_AUTO;\n    cfg_.g_lag_in_frames = 0;\n    cfg_.kf_min_dist = cfg_.kf_max_dist = 3000;\n    // Enable dropped frames.\n    cfg_.rc_dropframe_thresh = 1;\n    // Enable error_resilience mode.\n    cfg_.g_error_resilient = 1;\n    // Enable dynamic resizing.\n    cfg_.rc_resize_allowed = 1;\n    // Run at low bitrate.\n    cfg_.rc_target_bitrate = 200;\n  }\n\n  std::vector<FrameInfo> frame_info_list_;\n  int set_cpu_used_;\n  bool change_bitrate_;\n  double mismatch_psnr_;\n  int mismatch_nframes_;\n  std::vector<unsigned int> encode_frame_width_;\n  std::vector<unsigned int> encode_frame_height_;\n}",
          "class_name": "ResizeRealtimeTest",
          "class_pos": [
            [
              448,
              0
            ],
            [
              532,
              1
            ]
          ]
        },
        "710b37896703978d2fb78715f917041bd85b523c013c2c08a6616d9e3062fd78": {
          "class_code": "class ResizeCspTest : public ResizeTest {\n protected:\n#if WRITE_COMPRESSED_STREAM\n  ResizeCspTest()\n      : ResizeTest(), frame0_psnr_(0.0), outfile_(NULL), out_frames_(0) {}\n#else\n  ResizeCspTest() : ResizeTest(), frame0_psnr_(0.0) {}\n#endif\n\n  virtual ~ResizeCspTest() {}\n\n  virtual void BeginPassHook(unsigned int /*pass*/) {\n#if WRITE_COMPRESSED_STREAM\n    outfile_ = fopen(\"vp91-2-05-cspchape.ivf\", \"wb\");\n#endif\n  }\n\n  virtual void EndPassHook() {\n#if WRITE_COMPRESSED_STREAM\n    if (outfile_) {\n      if (!fseek(outfile_, 0, SEEK_SET))\n        write_ivf_file_header(&cfg_, out_frames_, outfile_);\n      fclose(outfile_);\n      outfile_ = NULL;\n    }\n#endif\n  }\n\n  virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                                  libvpx_test::Encoder *encoder) {\n    if (CspForFrameNumber(video->frame()) != VPX_IMG_FMT_I420 &&\n        cfg_.g_profile != 1) {\n      cfg_.g_profile = 1;\n      encoder->Config(&cfg_);\n    }\n    if (CspForFrameNumber(video->frame()) == VPX_IMG_FMT_I420 &&\n        cfg_.g_profile != 0) {\n      cfg_.g_profile = 0;\n      encoder->Config(&cfg_);\n    }\n  }\n\n  virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (frame0_psnr_ == 0.) frame0_psnr_ = pkt->data.psnr.psnr[0];\n    EXPECT_NEAR(pkt->data.psnr.psnr[0], frame0_psnr_, 2.0);\n  }\n\n#if WRITE_COMPRESSED_STREAM\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    ++out_frames_;\n\n    // Write initial file header if first frame.\n    if (pkt->data.frame.pts == 0) write_ivf_file_header(&cfg_, 0, outfile_);\n\n    // Write frame header and data.\n    write_ivf_frame_header(pkt, outfile_);\n    (void)fwrite(pkt->data.frame.buf, 1, pkt->data.frame.sz, outfile_);\n  }\n#endif\n\n  double frame0_psnr_;\n#if WRITE_COMPRESSED_STREAM\n  FILE *outfile_;\n  unsigned int out_frames_;\n#endif\n}",
          "class_name": "ResizeCspTest",
          "class_pos": [
            [
              655,
              0
            ],
            [
              720,
              1
            ]
          ]
        },
        "ab1fc461207200223ee4e8147c374a37f242d8c96df921d59ee4068cdd051bb1": {
          "class_code": "class ResizingCspVideoSource : public ::libvpx_test::DummyVideoSource {\n public:\n  ResizingCspVideoSource() {\n    SetSize(kInitialWidth, kInitialHeight);\n    limit_ = 30;\n  }\n\n  virtual ~ResizingCspVideoSource() {}\n\n protected:\n  virtual void Next() {\n    ++frame_;\n    SetImageFormat(CspForFrameNumber(frame_));\n    FillFrame();\n  }\n}",
          "class_name": "ResizingCspVideoSource",
          "class_pos": [
            [
              722,
              0
            ],
            [
              737,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct FrameInfo {\n  FrameInfo(vpx_codec_pts_t _pts, unsigned int _w, unsigned int _h)\n      : pts(_pts), w(_w), h(_h) {}\n\n  vpx_codec_pts_t pts;\n  unsigned int w;\n  unsigned int h;\n}",
          {
            "pts": "vpx_codec_pts_t",
            "w": "unsigned int",
            "h": "unsigned int"
          },
          "FrameInfo",
          [
            84,
            0
          ],
          [
            91,
            1
          ]
        ],
        [
          "struct FrameInfo {\n  FrameInfo(vpx_codec_pts_t _pts, unsigned int _w, unsigned int _h)\n      : pts(_pts), w(_w), h(_h) {}\n\n  vpx_codec_pts_t pts;\n  unsigned int w;\n  unsigned int h;\n}",
          {
            "pts": "vpx_codec_pts_t",
            "w": "unsigned int",
            "h": "unsigned int"
          },
          "FrameInfo",
          [
            84,
            0
          ],
          [
            91,
            1
          ]
        ],
        [
          "struct vpx_scaling_mode",
          {},
          "",
          [
            363,
            8
          ],
          [
            363,
            31
          ]
        ],
        [
          "struct vpx_scaling_mode",
          {},
          "",
          [
            367,
            8
          ],
          [
            367,
            31
          ]
        ],
        [
          "struct vpx_scaling_mode",
          {},
          "",
          [
            374,
            8
          ],
          [
            374,
            31
          ]
        ],
        [
          "struct vpx_scaling_mode",
          {},
          "",
          [
            378,
            8
          ],
          [
            378,
            31
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include <climits>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/video_source.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/hadamard_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "void hadamard_loop(const tran_low_t *a, tran_low_t *out) {\n  tran_low_t b[8];\n  for (int i = 0; i < 8; i += 2) {\n    b[i + 0] = a[i * 8] + a[(i + 1) * 8];\n    b[i + 1] = a[i * 8] - a[(i + 1) * 8];\n  }\n  tran_low_t c[8];\n  for (int i = 0; i < 8; i += 4) {\n    c[i + 0] = b[i + 0] + b[i + 2];\n    c[i + 1] = b[i + 1] + b[i + 3];\n    c[i + 2] = b[i + 0] - b[i + 2];\n    c[i + 3] = b[i + 1] - b[i + 3];\n  }\n  out[0] = c[0] + c[4];\n  out[7] = c[1] + c[5];\n  out[3] = c[2] + c[6];\n  out[4] = c[3] + c[7];\n  out[2] = c[0] - c[4];\n  out[6] = c[1] - c[5];\n  out[1] = c[2] - c[6];\n  out[5] = c[3] - c[7];\n}",
          "fn_code_pos": [
            [
              27,
              0
            ],
            [
              48,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "hadamard_loop",
            "parameters": {
              "a": "tran_low_t",
              "out": "tran_low_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void reference_hadamard8x8(const int16_t *a, int a_stride, tran_low_t *b) {\n  tran_low_t input[64];\n  tran_low_t buf[64];\n  for (int i = 0; i < 8; ++i) {\n    for (int j = 0; j < 8; ++j) {\n      input[i * 8 + j] = static_cast<tran_low_t>(a[i * a_stride + j]);\n    }\n  }\n  for (int i = 0; i < 8; ++i) hadamard_loop(input + i, buf + i * 8);\n  for (int i = 0; i < 8; ++i) hadamard_loop(buf + i, b + i * 8);\n}",
          "fn_code_pos": [
            [
              50,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reference_hadamard8x8",
            "parameters": {
              "a": "int16_t",
              "a_stride": "int",
              "b": "tran_low_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void reference_hadamard16x16(const int16_t *a, int a_stride, tran_low_t *b) {\n  /* The source is a 16x16 block. The destination is rearranged to 8x32.\n   * Input is 9 bit. */\n  reference_hadamard8x8(a + 0 + 0 * a_stride, a_stride, b + 0);\n  reference_hadamard8x8(a + 8 + 0 * a_stride, a_stride, b + 64);\n  reference_hadamard8x8(a + 0 + 8 * a_stride, a_stride, b + 128);\n  reference_hadamard8x8(a + 8 + 8 * a_stride, a_stride, b + 192);\n\n  /* Overlay the 8x8 blocks and combine. */\n  for (int i = 0; i < 64; ++i) {\n    /* 8x8 steps the range up to 15 bits. */\n    const tran_low_t a0 = b[0];\n    const tran_low_t a1 = b[64];\n    const tran_low_t a2 = b[128];\n    const tran_low_t a3 = b[192];\n\n    /* Prevent the result from escaping int16_t. */\n    const tran_low_t b0 = (a0 + a1) >> 1;\n    const tran_low_t b1 = (a0 - a1) >> 1;\n    const tran_low_t b2 = (a2 + a3) >> 1;\n    const tran_low_t b3 = (a2 - a3) >> 1;\n\n    /* Store a 16 bit value. */\n    b[0] = b0 + b2;\n    b[64] = b1 + b3;\n    b[128] = b0 - b2;\n    b[192] = b1 - b3;\n\n    ++b;\n  }\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              92,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reference_hadamard16x16",
            "parameters": {
              "a": "int16_t",
              "a_stride": "int",
              "b": "tran_low_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void reference_hadamard32x32(const int16_t *a, int a_stride, tran_low_t *b) {\n  reference_hadamard16x16(a + 0 + 0 * a_stride, a_stride, b + 0);\n  reference_hadamard16x16(a + 16 + 0 * a_stride, a_stride, b + 256);\n  reference_hadamard16x16(a + 0 + 16 * a_stride, a_stride, b + 512);\n  reference_hadamard16x16(a + 16 + 16 * a_stride, a_stride, b + 768);\n\n  for (int i = 0; i < 256; ++i) {\n    const tran_low_t a0 = b[0];\n    const tran_low_t a1 = b[256];\n    const tran_low_t a2 = b[512];\n    const tran_low_t a3 = b[768];\n\n    const tran_low_t b0 = (a0 + a1) >> 2;\n    const tran_low_t b1 = (a0 - a1) >> 2;\n    const tran_low_t b2 = (a2 + a3) >> 2;\n    const tran_low_t b3 = (a2 - a3) >> 2;\n\n    b[0] = b0 + b2;\n    b[256] = b1 + b3;\n    b[512] = b0 - b2;\n    b[768] = b1 - b3;\n\n    ++b;\n  }\n}",
          "fn_code_pos": [
            [
              94,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reference_hadamard32x32",
            "parameters": {
              "a": "int16_t",
              "a_stride": "int",
              "b": "tran_low_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "HadamardFuncWithSize(HadamardFunc f, int s) : func(f), block_size(s) {}",
          "fn_code_pos": [
            [
              121,
              2
            ],
            [
              121,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "HadamardFuncWithSize",
            "parameters": {
              "f": "HadamardFunc",
              "s": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::ostream &operator<<(std::ostream &os, const HadamardFuncWithSize &hfs) {\n  return os << \"block size: \" << hfs.block_size;\n}",
          "fn_code_pos": [
            [
              126,
              0
            ],
            [
              128,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    h_func_ = GetParam().func;\n    bwh_ = GetParam().block_size;\n    block_size_ = bwh_ * bwh_;\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n  }",
          "fn_code_pos": [
            [
              132,
              2
            ],
            [
              137,
              3
            ]
          ],
          "class_code": "93fa7238e8168980d53ebd12f75bb5dbe91620ffecb22a8c6483053f6bc13bd9",
          "class_node_pos": [
            [
              130,
              0
            ],
            [
              218,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual int16_t Rand() = 0;",
          "fn_code_pos": [
            [
              139,
              2
            ],
            [
              139,
              29
            ]
          ],
          "class_code": "93fa7238e8168980d53ebd12f75bb5dbe91620ffecb22a8c6483053f6bc13bd9",
          "class_node_pos": [
            [
              130,
              0
            ],
            [
              218,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Rand",
            "parameters": {},
            "return_type": "int16_t"
          }
        },
        {
          "fn_code": "void ReferenceHadamard(const int16_t *a, int a_stride, tran_low_t *b,\n                         int bwh) {\n    if (bwh == 32)\n      reference_hadamard32x32(a, a_stride, b);\n    else if (bwh == 16)\n      reference_hadamard16x16(a, a_stride, b);\n    else\n      reference_hadamard8x8(a, a_stride, b);\n  }",
          "fn_code_pos": [
            [
              141,
              2
            ],
            [
              149,
              3
            ]
          ],
          "class_code": "93fa7238e8168980d53ebd12f75bb5dbe91620ffecb22a8c6483053f6bc13bd9",
          "class_node_pos": [
            [
              130,
              0
            ],
            [
              218,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ReferenceHadamard",
            "parameters": {
              "a": "int16_t",
              "a_stride": "int",
              "b": "tran_low_t",
              "bwh": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CompareReferenceRandom() {\n    const int kMaxBlockSize = 32 * 32;\n    DECLARE_ALIGNED(16, int16_t, a[kMaxBlockSize]);\n    DECLARE_ALIGNED(16, tran_low_t, b[kMaxBlockSize]);\n    memset(a, 0, sizeof(a));\n    memset(b, 0, sizeof(b));\n\n    tran_low_t b_ref[kMaxBlockSize];\n    memset(b_ref, 0, sizeof(b_ref));\n\n    for (int i = 0; i < block_size_; ++i) a[i] = Rand();\n\n    ReferenceHadamard(a, bwh_, b_ref, bwh_);\n    ASM_REGISTER_STATE_CHECK(h_func_(a, bwh_, b));\n\n    // The order of the output is not important. Sort before checking.\n    std::sort(b, b + block_size_);\n    std::sort(b_ref, b_ref + block_size_);\n    EXPECT_EQ(0, memcmp(b, b_ref, sizeof(b)));\n  }",
          "fn_code_pos": [
            [
              151,
              2
            ],
            [
              170,
              3
            ]
          ],
          "class_code": "93fa7238e8168980d53ebd12f75bb5dbe91620ffecb22a8c6483053f6bc13bd9",
          "class_node_pos": [
            [
              130,
              0
            ],
            [
              218,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CompareReferenceRandom",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void VaryStride() {\n    const int kMaxBlockSize = 32 * 32;\n    DECLARE_ALIGNED(16, int16_t, a[kMaxBlockSize * 8]);\n    DECLARE_ALIGNED(16, tran_low_t, b[kMaxBlockSize]);\n    memset(a, 0, sizeof(a));\n    for (int i = 0; i < block_size_ * 8; ++i) a[i] = Rand();\n\n    tran_low_t b_ref[kMaxBlockSize];\n    for (int i = 8; i < 64; i += 8) {\n      memset(b, 0, sizeof(b));\n      memset(b_ref, 0, sizeof(b_ref));\n\n      ReferenceHadamard(a, i, b_ref, bwh_);\n      ASM_REGISTER_STATE_CHECK(h_func_(a, i, b));\n\n      // The order of the output is not important. Sort before checking.\n      std::sort(b, b + block_size_);\n      std::sort(b_ref, b_ref + block_size_);\n      EXPECT_EQ(0, memcmp(b, b_ref, sizeof(b)));\n    }\n  }",
          "fn_code_pos": [
            [
              172,
              2
            ],
            [
              192,
              3
            ]
          ],
          "class_code": "93fa7238e8168980d53ebd12f75bb5dbe91620ffecb22a8c6483053f6bc13bd9",
          "class_node_pos": [
            [
              130,
              0
            ],
            [
              218,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VaryStride",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SpeedTest(int times) {\n    const int kMaxBlockSize = 32 * 32;\n    DECLARE_ALIGNED(16, int16_t, input[kMaxBlockSize]);\n    DECLARE_ALIGNED(16, tran_low_t, output[kMaxBlockSize]);\n    memset(input, 1, sizeof(input));\n    memset(output, 0, sizeof(output));\n\n    vpx_usec_timer timer;\n    vpx_usec_timer_start(&timer);\n    for (int i = 0; i < times; ++i) {\n      h_func_(input, bwh_, output);\n    }\n    vpx_usec_timer_mark(&timer);\n\n    const int elapsed_time = static_cast<int>(vpx_usec_timer_elapsed(&timer));\n    printf(\"Hadamard%dx%d[%12d runs]: %d us\\n\", bwh_, bwh_, times,\n           elapsed_time);\n  }",
          "fn_code_pos": [
            [
              194,
              2
            ],
            [
              211,
              3
            ]
          ],
          "class_code": "93fa7238e8168980d53ebd12f75bb5dbe91620ffecb22a8c6483053f6bc13bd9",
          "class_node_pos": [
            [
              130,
              0
            ],
            [
              218,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SpeedTest",
            "parameters": {
              "times": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual int16_t Rand() { return rnd_.Rand9Signed(); }",
          "fn_code_pos": [
            [
              222,
              2
            ],
            [
              222,
              55
            ]
          ],
          "class_code": "3c98897ac329bd328cf036e7cc068b29faa6db6b3190933d028fc52a83d4388a",
          "class_node_pos": [
            [
              220,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Rand",
            "parameters": {},
            "return_type": "int16_t"
          }
        },
        {
          "fn_code": "TEST_P(HadamardLowbdTest, CompareReferenceRandom) { CompareReferenceRandom(); }",
          "fn_code_pos": [
            [
              225,
              0
            ],
            [
              225,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(HadamardLowbdTest, VaryStride) { VaryStride(); }",
          "fn_code_pos": [
            [
              227,
              0
            ],
            [
              227,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(HadamardLowbdTest, DISABLED_Speed) {\n  SpeedTest(10);\n  SpeedTest(10000);\n  SpeedTest(10000000);\n}",
          "fn_code_pos": [
            [
              229,
              0
            ],
            [
              233,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual int16_t Rand() { return rnd_.Rand13Signed(); }",
          "fn_code_pos": [
            [
              290,
              2
            ],
            [
              290,
              56
            ]
          ],
          "class_code": "f8822cd9dc2269647a5a65f8023b86488ffedccf52f3cb82ef1d1b58a8086a6a",
          "class_node_pos": [
            [
              288,
              0
            ],
            [
              291,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Rand",
            "parameters": {},
            "return_type": "int16_t"
          }
        },
        {
          "fn_code": "TEST_P(HadamardHighbdTest, CompareReferenceRandom) { CompareReferenceRandom(); }",
          "fn_code_pos": [
            [
              293,
              0
            ],
            [
              293,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(HadamardHighbdTest, VaryStride) { VaryStride(); }",
          "fn_code_pos": [
            [
              295,
              0
            ],
            [
              295,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(HadamardHighbdTest, DISABLED_Speed) {\n  SpeedTest(10);\n  SpeedTest(10000);\n  SpeedTest(10000000);\n}",
          "fn_code_pos": [
            [
              297,
              0
            ],
            [
              301,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*HadamardFunc)(const int16_t *a, ptrdiff_t a_stride,\n                             tran_low_t *b)",
          "fn_dec_pos": [
            [
              24,
              13
            ],
            [
              25,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "a": "int16_t",
              "a_stride": "ptrdiff_t",
              "b": "tran_low_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "operator<<(std::ostream &os, const HadamardFuncWithSize &hfs)",
          "fn_dec_pos": [
            [
              126,
              14
            ],
            [
              126,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "hfs": "HadamardFuncWithSize"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "93fa7238e8168980d53ebd12f75bb5dbe91620ffecb22a8c6483053f6bc13bd9": {
          "class_code": "class HadamardTestBase : public ::testing::TestWithParam<HadamardFuncWithSize> {\n public:\n  virtual void SetUp() {\n    h_func_ = GetParam().func;\n    bwh_ = GetParam().block_size;\n    block_size_ = bwh_ * bwh_;\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n  }\n\n  virtual int16_t Rand() = 0;\n\n  void ReferenceHadamard(const int16_t *a, int a_stride, tran_low_t *b,\n                         int bwh) {\n    if (bwh == 32)\n      reference_hadamard32x32(a, a_stride, b);\n    else if (bwh == 16)\n      reference_hadamard16x16(a, a_stride, b);\n    else\n      reference_hadamard8x8(a, a_stride, b);\n  }\n\n  void CompareReferenceRandom() {\n    const int kMaxBlockSize = 32 * 32;\n    DECLARE_ALIGNED(16, int16_t, a[kMaxBlockSize]);\n    DECLARE_ALIGNED(16, tran_low_t, b[kMaxBlockSize]);\n    memset(a, 0, sizeof(a));\n    memset(b, 0, sizeof(b));\n\n    tran_low_t b_ref[kMaxBlockSize];\n    memset(b_ref, 0, sizeof(b_ref));\n\n    for (int i = 0; i < block_size_; ++i) a[i] = Rand();\n\n    ReferenceHadamard(a, bwh_, b_ref, bwh_);\n    ASM_REGISTER_STATE_CHECK(h_func_(a, bwh_, b));\n\n    // The order of the output is not important. Sort before checking.\n    std::sort(b, b + block_size_);\n    std::sort(b_ref, b_ref + block_size_);\n    EXPECT_EQ(0, memcmp(b, b_ref, sizeof(b)));\n  }\n\n  void VaryStride() {\n    const int kMaxBlockSize = 32 * 32;\n    DECLARE_ALIGNED(16, int16_t, a[kMaxBlockSize * 8]);\n    DECLARE_ALIGNED(16, tran_low_t, b[kMaxBlockSize]);\n    memset(a, 0, sizeof(a));\n    for (int i = 0; i < block_size_ * 8; ++i) a[i] = Rand();\n\n    tran_low_t b_ref[kMaxBlockSize];\n    for (int i = 8; i < 64; i += 8) {\n      memset(b, 0, sizeof(b));\n      memset(b_ref, 0, sizeof(b_ref));\n\n      ReferenceHadamard(a, i, b_ref, bwh_);\n      ASM_REGISTER_STATE_CHECK(h_func_(a, i, b));\n\n      // The order of the output is not important. Sort before checking.\n      std::sort(b, b + block_size_);\n      std::sort(b_ref, b_ref + block_size_);\n      EXPECT_EQ(0, memcmp(b, b_ref, sizeof(b)));\n    }\n  }\n\n  void SpeedTest(int times) {\n    const int kMaxBlockSize = 32 * 32;\n    DECLARE_ALIGNED(16, int16_t, input[kMaxBlockSize]);\n    DECLARE_ALIGNED(16, tran_low_t, output[kMaxBlockSize]);\n    memset(input, 1, sizeof(input));\n    memset(output, 0, sizeof(output));\n\n    vpx_usec_timer timer;\n    vpx_usec_timer_start(&timer);\n    for (int i = 0; i < times; ++i) {\n      h_func_(input, bwh_, output);\n    }\n    vpx_usec_timer_mark(&timer);\n\n    const int elapsed_time = static_cast<int>(vpx_usec_timer_elapsed(&timer));\n    printf(\"Hadamard%dx%d[%12d runs]: %d us\\n\", bwh_, bwh_, times,\n           elapsed_time);\n  }\n\n protected:\n  int bwh_;\n  int block_size_;\n  HadamardFunc h_func_;\n  ACMRandom rnd_;\n}",
          "class_name": "HadamardTestBase",
          "class_pos": [
            [
              130,
              0
            ],
            [
              218,
              1
            ]
          ]
        },
        "3c98897ac329bd328cf036e7cc068b29faa6db6b3190933d028fc52a83d4388a": {
          "class_code": "class HadamardLowbdTest : public HadamardTestBase {\n protected:\n  virtual int16_t Rand() { return rnd_.Rand9Signed(); }\n}",
          "class_name": "HadamardLowbdTest",
          "class_pos": [
            [
              220,
              0
            ],
            [
              223,
              1
            ]
          ]
        },
        "f8822cd9dc2269647a5a65f8023b86488ffedccf52f3cb82ef1d1b58a8086a6a": {
          "class_code": "class HadamardHighbdTest : public HadamardTestBase {\n protected:\n  virtual int16_t Rand() { return rnd_.Rand13Signed(); }\n}",
          "class_name": "HadamardHighbdTest",
          "class_pos": [
            [
              288,
              0
            ],
            [
              291,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct HadamardFuncWithSize {\n  HadamardFuncWithSize(HadamardFunc f, int s) : func(f), block_size(s) {}\n  HadamardFunc func;\n  int block_size;\n}",
          {
            "func": "HadamardFunc",
            "block_size": "int"
          },
          "HadamardFuncWithSize",
          [
            120,
            0
          ],
          [
            124,
            1
          ]
        ],
        [
          "struct HadamardFuncWithSize {\n  HadamardFuncWithSize(HadamardFunc f, int s) : func(f), block_size(s) {}\n  HadamardFunc func;\n  int block_size;\n}",
          {
            "func": "HadamardFunc",
            "block_size": "int"
          },
          "HadamardFuncWithSize",
          [
            120,
            0
          ],
          [
            124,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include <algorithm>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"vpx_ports/vpx_timer.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/pp_filter_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "int q2mbl(int x) {\n  if (x < 20) x = 20;\n\n  x = 50 + (x - 50) * 10 / 8;\n  return x * x / 3;\n}",
          "fn_code_pos": [
            [
              36,
              0
            ],
            [
              41,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "q2mbl",
            "parameters": {
              "x": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "VpxPostProcDownAndAcrossMbRowTest()\n      : mb_post_proc_down_and_across_(GetParam()) {}",
          "fn_code_pos": [
            [
              47,
              2
            ],
            [
              48,
              52
            ]
          ],
          "class_code": "9edcd50245d0644beb45a725f42d530bd16776f2a2855fc1b28bd2113896004e",
          "class_node_pos": [
            [
              43,
              0
            ],
            [
              61,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VpxPostProcDownAndAcrossMbRowTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              49,
              2
            ],
            [
              49,
              62
            ]
          ],
          "class_code": "9edcd50245d0644beb45a725f42d530bd16776f2a2855fc1b28bd2113896004e",
          "class_node_pos": [
            [
              43,
              0
            ],
            [
              61,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void VpxPostProcDownAndAcrossMbRowTest::Run() {\n  mb_post_proc_down_and_across_(\n      src_image_->TopLeftPixel(), dst_image_->TopLeftPixel(),\n      src_image_->stride(), dst_image_->stride(), block_width_, flimits_, 16);\n}",
          "fn_code_pos": [
            [
              63,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VpxPostProcDownAndAcrossMbRowTest::Run",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(VpxPostProcDownAndAcrossMbRowTest, CheckFilterOutput) {\n  // Size of the underlying data block that will be filtered.\n  block_width_ = 16;\n  block_height_ = 16;\n\n  // 5-tap filter needs 2 padding rows above and below the block in the input.\n  Buffer<uint8_t> src_image = Buffer<uint8_t>(block_width_, block_height_, 2);\n  ASSERT_TRUE(src_image.Init());\n\n  // Filter extends output block by 8 samples at left and right edges.\n  // Though the left padding is only 8 bytes, the assembly code tries to\n  // read 16 bytes before the pointer.\n  Buffer<uint8_t> dst_image =\n      Buffer<uint8_t>(block_width_, block_height_, 8, 16, 8, 8);\n  ASSERT_TRUE(dst_image.Init());\n\n  flimits_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_width_));\n  (void)memset(flimits_, 255, block_width_);\n\n  // Initialize pixels in the input:\n  //   block pixels to value 1,\n  //   border pixels to value 10.\n  src_image.SetPadding(10);\n  src_image.Set(1);\n\n  // Initialize pixels in the output to 99.\n  dst_image.Set(99);\n\n  ASM_REGISTER_STATE_CHECK(mb_post_proc_down_and_across_(\n      src_image.TopLeftPixel(), dst_image.TopLeftPixel(), src_image.stride(),\n      dst_image.stride(), block_width_, flimits_, 16));\n\n  static const uint8_t kExpectedOutput[] = { 4, 3, 1, 1, 1, 1, 1, 1,\n                                             1, 1, 1, 1, 1, 1, 3, 4 };\n\n  uint8_t *pixel_ptr = dst_image.TopLeftPixel();\n  for (int i = 0; i < block_height_; ++i) {\n    for (int j = 0; j < block_width_; ++j) {\n      ASSERT_EQ(kExpectedOutput[i], pixel_ptr[j])\n          << \"at (\" << i << \", \" << j << \")\";\n    }\n    pixel_ptr += dst_image.stride();\n  }\n\n  vpx_free(flimits_);\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              117,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxPostProcDownAndAcrossMbRowTest, CheckCvsAssembly) {\n  // Size of the underlying data block that will be filtered.\n  // Y blocks are always a multiple of 16 wide and exactly 16 high. U and V\n  // blocks are always a multiple of 8 wide and exactly 8 high.\n  block_width_ = 136;\n  block_height_ = 16;\n\n  // 5-tap filter needs 2 padding rows above and below the block in the input.\n  // SSE2 reads in blocks of 16. Pad an extra 8 in case the width is not %16.\n  Buffer<uint8_t> src_image =\n      Buffer<uint8_t>(block_width_, block_height_, 2, 2, 10, 2);\n  ASSERT_TRUE(src_image.Init());\n\n  // Filter extends output block by 8 samples at left and right edges.\n  // Though the left padding is only 8 bytes, there is 'above' padding as well\n  // so when the assembly code tries to read 16 bytes before the pointer it is\n  // not a problem.\n  // SSE2 reads in blocks of 16. Pad an extra 8 in case the width is not %16.\n  Buffer<uint8_t> dst_image =\n      Buffer<uint8_t>(block_width_, block_height_, 8, 8, 16, 8);\n  ASSERT_TRUE(dst_image.Init());\n  Buffer<uint8_t> dst_image_ref =\n      Buffer<uint8_t>(block_width_, block_height_, 8);\n  ASSERT_TRUE(dst_image_ref.Init());\n\n  // Filter values are set in blocks of 16 for Y and 8 for U/V. Each macroblock\n  // can have a different filter. SSE2 assembly reads flimits in blocks of 16 so\n  // it must be padded out.\n  const int flimits_width = block_width_ % 16 ? block_width_ + 8 : block_width_;\n  flimits_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, flimits_width));\n\n  ACMRandom rnd;\n  rnd.Reset(ACMRandom::DeterministicSeed());\n  // Initialize pixels in the input:\n  //   block pixels to random values.\n  //   border pixels to value 10.\n  src_image.SetPadding(10);\n  src_image.Set(&rnd, &ACMRandom::Rand8);\n\n  for (int blocks = 0; blocks < block_width_; blocks += 8) {\n    (void)memset(flimits_, 0, sizeof(*flimits_) * flimits_width);\n\n    for (int f = 0; f < 255; f++) {\n      (void)memset(flimits_ + blocks, f, sizeof(*flimits_) * 8);\n      dst_image.Set(0);\n      dst_image_ref.Set(0);\n\n      vpx_post_proc_down_and_across_mb_row_c(\n          src_image.TopLeftPixel(), dst_image_ref.TopLeftPixel(),\n          src_image.stride(), dst_image_ref.stride(), block_width_, flimits_,\n          block_height_);\n      ASM_REGISTER_STATE_CHECK(mb_post_proc_down_and_across_(\n          src_image.TopLeftPixel(), dst_image.TopLeftPixel(),\n          src_image.stride(), dst_image.stride(), block_width_, flimits_,\n          block_height_));\n\n      ASSERT_TRUE(dst_image.CheckValues(dst_image_ref));\n    }\n  }\n\n  vpx_free(flimits_);\n}",
          "fn_code_pos": [
            [
              119,
              0
            ],
            [
              180,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxPostProcDownAndAcrossMbRowTest, DISABLED_Speed) {\n  // Size of the underlying data block that will be filtered.\n  block_width_ = 16;\n  block_height_ = 16;\n\n  // 5-tap filter needs 2 padding rows above and below the block in the input.\n  Buffer<uint8_t> src_image = Buffer<uint8_t>(block_width_, block_height_, 2);\n  ASSERT_TRUE(src_image.Init());\n  this->src_image_ = &src_image;\n\n  // Filter extends output block by 8 samples at left and right edges.\n  // Though the left padding is only 8 bytes, the assembly code tries to\n  // read 16 bytes before the pointer.\n  Buffer<uint8_t> dst_image =\n      Buffer<uint8_t>(block_width_, block_height_, 8, 16, 8, 8);\n  ASSERT_TRUE(dst_image.Init());\n  this->dst_image_ = &dst_image;\n\n  flimits_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_width_));\n  (void)memset(flimits_, 255, block_width_);\n\n  // Initialize pixels in the input:\n  //   block pixels to value 1,\n  //   border pixels to value 10.\n  src_image.SetPadding(10);\n  src_image.Set(1);\n\n  // Initialize pixels in the output to 99.\n  dst_image.Set(99);\n\n  RunNTimes(INT16_MAX);\n  PrintMedian(\"16x16\");\n\n  vpx_free(flimits_);\n}",
          "fn_code_pos": [
            [
              182,
              0
            ],
            [
              216,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VpxMbPostProcAcrossIpTest()\n      : rows_(16), cols_(16), mb_post_proc_across_ip_(GetParam()),\n        src_(Buffer<uint8_t>(rows_, cols_, 8, 8, 17, 8)) {}",
          "fn_code_pos": [
            [
              222,
              2
            ],
            [
              224,
              59
            ]
          ],
          "class_code": "fb3397982e4198091f4004b47382049a8c00ec9bb487f462ac780a7f1e2b88bd",
          "class_node_pos": [
            [
              218,
              0
            ],
            [
              261,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VpxMbPostProcAcrossIpTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              225,
              2
            ],
            [
              225,
              62
            ]
          ],
          "class_code": "fb3397982e4198091f4004b47382049a8c00ec9bb487f462ac780a7f1e2b88bd",
          "class_node_pos": [
            [
              218,
              0
            ],
            [
              261,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SetCols(unsigned char *s, int rows, int cols, int src_width) {\n    for (int r = 0; r < rows; r++) {\n      for (int c = 0; c < cols; c++) {\n        s[c] = c;\n      }\n      s += src_width;\n    }\n  }",
          "fn_code_pos": [
            [
              230,
              2
            ],
            [
              237,
              3
            ]
          ],
          "class_code": "fb3397982e4198091f4004b47382049a8c00ec9bb487f462ac780a7f1e2b88bd",
          "class_node_pos": [
            [
              218,
              0
            ],
            [
              261,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetCols",
            "parameters": {
              "s": "unsigned char",
              "rows": "int",
              "cols": "int",
              "src_width": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunComparison(const unsigned char *expected_output, unsigned char *src_c,\n                     int rows, int cols, int src_pitch) {\n    for (int r = 0; r < rows; r++) {\n      for (int c = 0; c < cols; c++) {\n        ASSERT_EQ(expected_output[c], src_c[c])\n            << \"at (\" << r << \", \" << c << \")\";\n      }\n      src_c += src_pitch;\n    }\n  }",
          "fn_code_pos": [
            [
              239,
              2
            ],
            [
              248,
              3
            ]
          ],
          "class_code": "fb3397982e4198091f4004b47382049a8c00ec9bb487f462ac780a7f1e2b88bd",
          "class_node_pos": [
            [
              218,
              0
            ],
            [
              261,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunComparison",
            "parameters": {
              "expected_output": "unsigned char",
              "src_c": "unsigned char",
              "rows": "int",
              "cols": "int",
              "src_pitch": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunFilterLevel(unsigned char *s, int rows, int cols, int src_width,\n                      int filter_level, const unsigned char *expected_output) {\n    ASM_REGISTER_STATE_CHECK(\n        GetParam()(s, src_width, rows, cols, filter_level));\n    RunComparison(expected_output, s, rows, cols, src_width);\n  }",
          "fn_code_pos": [
            [
              250,
              2
            ],
            [
              255,
              3
            ]
          ],
          "class_code": "fb3397982e4198091f4004b47382049a8c00ec9bb487f462ac780a7f1e2b88bd",
          "class_node_pos": [
            [
              218,
              0
            ],
            [
              261,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunFilterLevel",
            "parameters": {
              "s": "unsigned char",
              "rows": "int",
              "cols": "int",
              "src_width": "int",
              "filter_level": "int",
              "expected_output": "unsigned char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void VpxMbPostProcAcrossIpTest::Run() {\n  mb_post_proc_across_ip_(src_.TopLeftPixel(), src_.stride(), rows_, cols_,\n                          q2mbl(0));\n}",
          "fn_code_pos": [
            [
              263,
              0
            ],
            [
              266,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VpxMbPostProcAcrossIpTest::Run",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(VpxMbPostProcAcrossIpTest, CheckLowFilterOutput) {\n  ASSERT_TRUE(src_.Init());\n  src_.SetPadding(10);\n  SetCols(src_.TopLeftPixel(), rows_, cols_, src_.stride());\n\n  Buffer<uint8_t> expected_output = Buffer<uint8_t>(cols_, rows_, 0);\n  ASSERT_TRUE(expected_output.Init());\n  SetCols(expected_output.TopLeftPixel(), rows_, cols_,\n          expected_output.stride());\n\n  RunFilterLevel(src_.TopLeftPixel(), rows_, cols_, src_.stride(), q2mbl(0),\n                 expected_output.TopLeftPixel());\n}",
          "fn_code_pos": [
            [
              268,
              0
            ],
            [
              280,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxMbPostProcAcrossIpTest, CheckMediumFilterOutput) {\n  ASSERT_TRUE(src_.Init());\n  src_.SetPadding(10);\n  SetCols(src_.TopLeftPixel(), rows_, cols_, src_.stride());\n\n  static const unsigned char kExpectedOutput[] = {\n    2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 13\n  };\n\n  RunFilterLevel(src_.TopLeftPixel(), rows_, cols_, src_.stride(), q2mbl(70),\n                 kExpectedOutput);\n}",
          "fn_code_pos": [
            [
              282,
              0
            ],
            [
              293,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxMbPostProcAcrossIpTest, CheckHighFilterOutput) {\n  ASSERT_TRUE(src_.Init());\n  src_.SetPadding(10);\n  SetCols(src_.TopLeftPixel(), rows_, cols_, src_.stride());\n\n  static const unsigned char kExpectedOutput[] = {\n    2, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 11, 11, 12, 13, 13\n  };\n\n  RunFilterLevel(src_.TopLeftPixel(), rows_, cols_, src_.stride(), INT_MAX,\n                 kExpectedOutput);\n\n  SetCols(src_.TopLeftPixel(), rows_, cols_, src_.stride());\n\n  RunFilterLevel(src_.TopLeftPixel(), rows_, cols_, src_.stride(), q2mbl(100),\n                 kExpectedOutput);\n}",
          "fn_code_pos": [
            [
              295,
              0
            ],
            [
              311,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxMbPostProcAcrossIpTest, CheckCvsAssembly) {\n  Buffer<uint8_t> c_mem = Buffer<uint8_t>(cols_, rows_, 8, 8, 17, 8);\n  ASSERT_TRUE(c_mem.Init());\n  Buffer<uint8_t> asm_mem = Buffer<uint8_t>(cols_, rows_, 8, 8, 17, 8);\n  ASSERT_TRUE(asm_mem.Init());\n\n  // When level >= 100, the filter behaves the same as the level = INT_MAX\n  // When level < 20, it behaves the same as the level = 0\n  for (int level = 0; level < 100; level++) {\n    c_mem.SetPadding(10);\n    asm_mem.SetPadding(10);\n    SetCols(c_mem.TopLeftPixel(), rows_, cols_, c_mem.stride());\n    SetCols(asm_mem.TopLeftPixel(), rows_, cols_, asm_mem.stride());\n\n    vpx_mbpost_proc_across_ip_c(c_mem.TopLeftPixel(), c_mem.stride(), rows_,\n                                cols_, q2mbl(level));\n    ASM_REGISTER_STATE_CHECK(GetParam()(\n        asm_mem.TopLeftPixel(), asm_mem.stride(), rows_, cols_, q2mbl(level)));\n\n    ASSERT_TRUE(asm_mem.CheckValues(c_mem));\n  }\n}",
          "fn_code_pos": [
            [
              313,
              0
            ],
            [
              334,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxMbPostProcAcrossIpTest, DISABLED_Speed) {\n  ASSERT_TRUE(src_.Init());\n  src_.SetPadding(10);\n\n  SetCols(src_.TopLeftPixel(), rows_, cols_, src_.stride());\n\n  RunNTimes(100000);\n  PrintMedian(\"16x16\");\n}",
          "fn_code_pos": [
            [
              336,
              0
            ],
            [
              344,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VpxMbPostProcDownTest()\n      : rows_(16), cols_(16), mb_post_proc_down_(GetParam()),\n        src_c_(Buffer<uint8_t>(rows_, cols_, 8, 8, 8, 17)) {}",
          "fn_code_pos": [
            [
              350,
              2
            ],
            [
              352,
              61
            ]
          ],
          "class_code": "94b38f21c6baef242a10042502b90f6fe4bf5ac04d9ebb45fd1f9bb5213c054f",
          "class_node_pos": [
            [
              346,
              0
            ],
            [
              388,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VpxMbPostProcDownTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              354,
              2
            ],
            [
              354,
              62
            ]
          ],
          "class_code": "94b38f21c6baef242a10042502b90f6fe4bf5ac04d9ebb45fd1f9bb5213c054f",
          "class_node_pos": [
            [
              346,
              0
            ],
            [
              388,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SetRows(unsigned char *src_c, int rows, int cols, int src_width) {\n    for (int r = 0; r < rows; r++) {\n      memset(src_c, r, cols);\n      src_c += src_width;\n    }\n  }",
          "fn_code_pos": [
            [
              359,
              2
            ],
            [
              364,
              3
            ]
          ],
          "class_code": "94b38f21c6baef242a10042502b90f6fe4bf5ac04d9ebb45fd1f9bb5213c054f",
          "class_node_pos": [
            [
              346,
              0
            ],
            [
              388,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetRows",
            "parameters": {
              "src_c": "unsigned char",
              "rows": "int",
              "cols": "int",
              "src_width": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunComparison(const unsigned char *expected_output, unsigned char *src_c,\n                     int rows, int cols, int src_pitch) {\n    for (int r = 0; r < rows; r++) {\n      for (int c = 0; c < cols; c++) {\n        ASSERT_EQ(expected_output[r * rows + c], src_c[c])\n            << \"at (\" << r << \", \" << c << \")\";\n      }\n      src_c += src_pitch;\n    }\n  }",
          "fn_code_pos": [
            [
              366,
              2
            ],
            [
              375,
              3
            ]
          ],
          "class_code": "94b38f21c6baef242a10042502b90f6fe4bf5ac04d9ebb45fd1f9bb5213c054f",
          "class_node_pos": [
            [
              346,
              0
            ],
            [
              388,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunComparison",
            "parameters": {
              "expected_output": "unsigned char",
              "src_c": "unsigned char",
              "rows": "int",
              "cols": "int",
              "src_pitch": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunFilterLevel(unsigned char *s, int rows, int cols, int src_width,\n                      int filter_level, const unsigned char *expected_output) {\n    ASM_REGISTER_STATE_CHECK(\n        mb_post_proc_down_(s, src_width, rows, cols, filter_level));\n    RunComparison(expected_output, s, rows, cols, src_width);\n  }",
          "fn_code_pos": [
            [
              377,
              2
            ],
            [
              382,
              3
            ]
          ],
          "class_code": "94b38f21c6baef242a10042502b90f6fe4bf5ac04d9ebb45fd1f9bb5213c054f",
          "class_node_pos": [
            [
              346,
              0
            ],
            [
              388,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunFilterLevel",
            "parameters": {
              "s": "unsigned char",
              "rows": "int",
              "cols": "int",
              "src_width": "int",
              "filter_level": "int",
              "expected_output": "unsigned char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void VpxMbPostProcDownTest::Run() {\n  mb_post_proc_down_(src_c_.TopLeftPixel(), src_c_.stride(), rows_, cols_,\n                     q2mbl(0));\n}",
          "fn_code_pos": [
            [
              390,
              0
            ],
            [
              393,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "VpxMbPostProcDownTest::Run",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(VpxMbPostProcDownTest, CheckHighFilterOutput) {\n  ASSERT_TRUE(src_c_.Init());\n  src_c_.SetPadding(10);\n\n  SetRows(src_c_.TopLeftPixel(), rows_, cols_, src_c_.stride());\n\n  static const unsigned char kExpectedOutput[] = {\n    2,  2,  1,  1,  2,  2,  2,  2,  2,  2,  1,  1,  2,  2,  2,  2,  2,  2,  2,\n    2,  3,  2,  2,  2,  2,  2,  2,  2,  3,  2,  2,  2,  3,  3,  3,  3,  3,  3,\n    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  3,  4,  4,  3,  3,  3,\n    4,  4,  3,  4,  4,  3,  3,  4,  5,  4,  4,  4,  4,  4,  4,  4,  5,  4,  4,\n    4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n    5,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  7,  7,\n    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,\n    8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  9,  8,  9,  9,  8,  8,  8,  9,\n    9,  8,  9,  9,  8,  8,  8,  9,  9,  10, 10, 9,  9,  9,  10, 10, 9,  10, 10,\n    9,  9,  9,  10, 10, 10, 11, 10, 10, 10, 11, 10, 11, 10, 11, 10, 10, 10, 11,\n    10, 11, 11, 11, 11, 11, 11, 11, 12, 11, 11, 11, 11, 11, 11, 11, 12, 11, 12,\n    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12,\n    13, 12, 13, 12, 12, 12, 13, 12, 13, 12, 13, 12, 13, 13, 13, 14, 13, 13, 13,\n    13, 13, 13, 13, 14, 13, 13, 13, 13\n  };\n\n  RunFilterLevel(src_c_.TopLeftPixel(), rows_, cols_, src_c_.stride(), INT_MAX,\n                 kExpectedOutput);\n\n  src_c_.SetPadding(10);\n  SetRows(src_c_.TopLeftPixel(), rows_, cols_, src_c_.stride());\n  RunFilterLevel(src_c_.TopLeftPixel(), rows_, cols_, src_c_.stride(),\n                 q2mbl(100), kExpectedOutput);\n}",
          "fn_code_pos": [
            [
              395,
              0
            ],
            [
              425,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxMbPostProcDownTest, CheckMediumFilterOutput) {\n  ASSERT_TRUE(src_c_.Init());\n  src_c_.SetPadding(10);\n\n  SetRows(src_c_.TopLeftPixel(), rows_, cols_, src_c_.stride());\n\n  static const unsigned char kExpectedOutput[] = {\n    2,  2,  1,  1,  2,  2,  2,  2,  2,  2,  1,  1,  2,  2,  2,  2,  2,  2,  2,\n    2,  3,  2,  2,  2,  2,  2,  2,  2,  3,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n    3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,\n    4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n    5,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  7,  7,\n    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,\n    8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,\n    9,  9,  9,  9,  9,  9,  9,  9,  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n    10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n    11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13,\n    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 13, 12,\n    13, 12, 13, 12, 12, 12, 13, 12, 13, 12, 13, 12, 13, 13, 13, 14, 13, 13, 13,\n    13, 13, 13, 13, 14, 13, 13, 13, 13\n  };\n\n  RunFilterLevel(src_c_.TopLeftPixel(), rows_, cols_, src_c_.stride(),\n                 q2mbl(70), kExpectedOutput);\n}",
          "fn_code_pos": [
            [
              427,
              0
            ],
            [
              452,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxMbPostProcDownTest, CheckLowFilterOutput) {\n  ASSERT_TRUE(src_c_.Init());\n  src_c_.SetPadding(10);\n\n  SetRows(src_c_.TopLeftPixel(), rows_, cols_, src_c_.stride());\n\n  unsigned char *expected_output = new unsigned char[rows_ * cols_];\n  ASSERT_TRUE(expected_output != NULL);\n  SetRows(expected_output, rows_, cols_, cols_);\n\n  RunFilterLevel(src_c_.TopLeftPixel(), rows_, cols_, src_c_.stride(), q2mbl(0),\n                 expected_output);\n\n  delete[] expected_output;\n}",
          "fn_code_pos": [
            [
              454,
              0
            ],
            [
              468,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxMbPostProcDownTest, CheckCvsAssembly) {\n  ACMRandom rnd;\n  rnd.Reset(ACMRandom::DeterministicSeed());\n\n  ASSERT_TRUE(src_c_.Init());\n  Buffer<uint8_t> src_asm = Buffer<uint8_t>(cols_, rows_, 8, 8, 8, 17);\n  ASSERT_TRUE(src_asm.Init());\n\n  for (int level = 0; level < 100; level++) {\n    src_c_.SetPadding(10);\n    src_asm.SetPadding(10);\n    src_c_.Set(&rnd, &ACMRandom::Rand8);\n    src_asm.CopyFrom(src_c_);\n\n    vpx_mbpost_proc_down_c(src_c_.TopLeftPixel(), src_c_.stride(), rows_, cols_,\n                           q2mbl(level));\n    ASM_REGISTER_STATE_CHECK(mb_post_proc_down_(\n        src_asm.TopLeftPixel(), src_asm.stride(), rows_, cols_, q2mbl(level)));\n    ASSERT_TRUE(src_asm.CheckValues(src_c_));\n\n    src_c_.SetPadding(10);\n    src_asm.SetPadding(10);\n    src_c_.Set(&rnd, &ACMRandom::Rand8Extremes);\n    src_asm.CopyFrom(src_c_);\n\n    vpx_mbpost_proc_down_c(src_c_.TopLeftPixel(), src_c_.stride(), rows_, cols_,\n                           q2mbl(level));\n    ASM_REGISTER_STATE_CHECK(mb_post_proc_down_(\n        src_asm.TopLeftPixel(), src_asm.stride(), rows_, cols_, q2mbl(level)));\n    ASSERT_TRUE(src_asm.CheckValues(src_c_));\n  }\n}",
          "fn_code_pos": [
            [
              470,
              0
            ],
            [
              501,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxMbPostProcDownTest, DISABLED_Speed) {\n  ASSERT_TRUE(src_c_.Init());\n  src_c_.SetPadding(10);\n\n  SetRows(src_c_.TopLeftPixel(), rows_, cols_, src_c_.stride());\n\n  RunNTimes(100000);\n  PrintMedian(\"16x16\");\n}",
          "fn_code_pos": [
            [
              503,
              0
            ],
            [
              511,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*VpxPostProcDownAndAcrossMbRowFunc)(\n    unsigned char *src_ptr, unsigned char *dst_ptr, int src_pixels_per_line,\n    int dst_pixels_per_line, int cols, unsigned char *flimit, int size)",
          "fn_dec_pos": [
            [
              24,
              13
            ],
            [
              26,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "src_ptr": "unsigned char",
              "dst_ptr": "unsigned char",
              "src_pixels_per_line": "int",
              "dst_pixels_per_line": "int",
              "cols": "int",
              "flimit": "unsigned char",
              "size": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*VpxMbPostProcAcrossIpFunc)(unsigned char *src, int pitch,\n                                          int rows, int cols, int flimit)",
          "fn_dec_pos": [
            [
              28,
              13
            ],
            [
              29,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "src": "unsigned char",
              "pitch": "int",
              "rows": "int",
              "cols": "int",
              "flimit": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*VpxMbPostProcDownFunc)(unsigned char *dst, int pitch, int rows,\n                                      int cols, int flimit)",
          "fn_dec_pos": [
            [
              31,
              13
            ],
            [
              32,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "dst": "unsigned char",
              "pitch": "int",
              "rows": "int",
              "cols": "int",
              "flimit": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "Run()",
          "fn_dec_pos": [
            [
              52,
              15
            ],
            [
              52,
              20
            ]
          ],
          "class_code": "9edcd50245d0644beb45a725f42d530bd16776f2a2855fc1b28bd2113896004e",
          "class_node_pos": [
            [
              43,
              0
            ],
            [
              61,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Run",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "Run()",
          "fn_dec_pos": [
            [
              228,
              15
            ],
            [
              228,
              20
            ]
          ],
          "class_code": "fb3397982e4198091f4004b47382049a8c00ec9bb487f462ac780a7f1e2b88bd",
          "class_node_pos": [
            [
              218,
              0
            ],
            [
              261,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Run",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "Run()",
          "fn_dec_pos": [
            [
              357,
              15
            ],
            [
              357,
              20
            ]
          ],
          "class_code": "94b38f21c6baef242a10042502b90f6fe4bf5ac04d9ebb45fd1f9bb5213c054f",
          "class_node_pos": [
            [
              346,
              0
            ],
            [
              388,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Run",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {
        "9edcd50245d0644beb45a725f42d530bd16776f2a2855fc1b28bd2113896004e": {
          "class_code": "class VpxPostProcDownAndAcrossMbRowTest\n    : public AbstractBench,\n      public ::testing::TestWithParam<VpxPostProcDownAndAcrossMbRowFunc> {\n public:\n  VpxPostProcDownAndAcrossMbRowTest()\n      : mb_post_proc_down_and_across_(GetParam()) {}\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  virtual void Run();\n\n  const VpxPostProcDownAndAcrossMbRowFunc mb_post_proc_down_and_across_;\n  // Size of the underlying data block that will be filtered.\n  int block_width_;\n  int block_height_;\n  Buffer<uint8_t> *src_image_;\n  Buffer<uint8_t> *dst_image_;\n  uint8_t *flimits_;\n}",
          "class_name": "VpxPostProcDownAndAcrossMbRowTest",
          "class_pos": [
            [
              43,
              0
            ],
            [
              61,
              1
            ]
          ]
        },
        "fb3397982e4198091f4004b47382049a8c00ec9bb487f462ac780a7f1e2b88bd": {
          "class_code": "class VpxMbPostProcAcrossIpTest\n    : public AbstractBench,\n      public ::testing::TestWithParam<VpxMbPostProcAcrossIpFunc> {\n public:\n  VpxMbPostProcAcrossIpTest()\n      : rows_(16), cols_(16), mb_post_proc_across_ip_(GetParam()),\n        src_(Buffer<uint8_t>(rows_, cols_, 8, 8, 17, 8)) {}\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  virtual void Run();\n\n  void SetCols(unsigned char *s, int rows, int cols, int src_width) {\n    for (int r = 0; r < rows; r++) {\n      for (int c = 0; c < cols; c++) {\n        s[c] = c;\n      }\n      s += src_width;\n    }\n  }\n\n  void RunComparison(const unsigned char *expected_output, unsigned char *src_c,\n                     int rows, int cols, int src_pitch) {\n    for (int r = 0; r < rows; r++) {\n      for (int c = 0; c < cols; c++) {\n        ASSERT_EQ(expected_output[c], src_c[c])\n            << \"at (\" << r << \", \" << c << \")\";\n      }\n      src_c += src_pitch;\n    }\n  }\n\n  void RunFilterLevel(unsigned char *s, int rows, int cols, int src_width,\n                      int filter_level, const unsigned char *expected_output) {\n    ASM_REGISTER_STATE_CHECK(\n        GetParam()(s, src_width, rows, cols, filter_level));\n    RunComparison(expected_output, s, rows, cols, src_width);\n  }\n\n  const int rows_;\n  const int cols_;\n  const VpxMbPostProcAcrossIpFunc mb_post_proc_across_ip_;\n  Buffer<uint8_t> src_;\n}",
          "class_name": "VpxMbPostProcAcrossIpTest",
          "class_pos": [
            [
              218,
              0
            ],
            [
              261,
              1
            ]
          ]
        },
        "94b38f21c6baef242a10042502b90f6fe4bf5ac04d9ebb45fd1f9bb5213c054f": {
          "class_code": "class VpxMbPostProcDownTest\n    : public AbstractBench,\n      public ::testing::TestWithParam<VpxMbPostProcDownFunc> {\n public:\n  VpxMbPostProcDownTest()\n      : rows_(16), cols_(16), mb_post_proc_down_(GetParam()),\n        src_c_(Buffer<uint8_t>(rows_, cols_, 8, 8, 8, 17)) {}\n\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  virtual void Run();\n\n  void SetRows(unsigned char *src_c, int rows, int cols, int src_width) {\n    for (int r = 0; r < rows; r++) {\n      memset(src_c, r, cols);\n      src_c += src_width;\n    }\n  }\n\n  void RunComparison(const unsigned char *expected_output, unsigned char *src_c,\n                     int rows, int cols, int src_pitch) {\n    for (int r = 0; r < rows; r++) {\n      for (int c = 0; c < cols; c++) {\n        ASSERT_EQ(expected_output[r * rows + c], src_c[c])\n            << \"at (\" << r << \", \" << c << \")\";\n      }\n      src_c += src_pitch;\n    }\n  }\n\n  void RunFilterLevel(unsigned char *s, int rows, int cols, int src_width,\n                      int filter_level, const unsigned char *expected_output) {\n    ASM_REGISTER_STATE_CHECK(\n        mb_post_proc_down_(s, src_width, rows, cols, filter_level));\n    RunComparison(expected_output, s, rows, cols, src_width);\n  }\n\n  const int rows_;\n  const int cols_;\n  const VpxMbPostProcDownFunc mb_post_proc_down_;\n  Buffer<uint8_t> src_c_;\n}",
          "class_name": "VpxMbPostProcDownTest",
          "class_pos": [
            [
              346,
              0
            ],
            [
              388,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <limits.h>\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/bench.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/buffer.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/external_frame_buffer_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "ExternalFrameBufferList()\n      : num_buffers_(0), num_used_buffers_(0), ext_fb_list_(NULL) {}",
          "fn_code_pos": [
            [
              37,
              2
            ],
            [
              38,
              68
            ]
          ],
          "class_code": "1b5ba14f4832369e12838c1b54b11786d3e551dcc8cd77296b69074cb2690626",
          "class_node_pos": [
            [
              35,
              0
            ],
            [
              156,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ExternalFrameBufferList",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~ExternalFrameBufferList() {\n    for (int i = 0; i < num_buffers_; ++i) {\n      delete[] ext_fb_list_[i].data;\n    }\n    delete[] ext_fb_list_;\n  }",
          "fn_code_pos": [
            [
              40,
              2
            ],
            [
              45,
              3
            ]
          ],
          "class_code": "1b5ba14f4832369e12838c1b54b11786d3e551dcc8cd77296b69074cb2690626",
          "class_node_pos": [
            [
              35,
              0
            ],
            [
              156,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "bool CreateBufferList(int num_buffers) {\n    if (num_buffers < 0) return false;\n\n    num_buffers_ = num_buffers;\n    ext_fb_list_ = new ExternalFrameBuffer[num_buffers_];\n    EXPECT_TRUE(ext_fb_list_ != NULL);\n    memset(ext_fb_list_, 0, sizeof(ext_fb_list_[0]) * num_buffers_);\n    return true;\n  }",
          "fn_code_pos": [
            [
              48,
              2
            ],
            [
              56,
              3
            ]
          ],
          "class_code": "1b5ba14f4832369e12838c1b54b11786d3e551dcc8cd77296b69074cb2690626",
          "class_node_pos": [
            [
              35,
              0
            ],
            [
              156,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CreateBufferList",
            "parameters": {
              "num_buffers": "int"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "int GetFreeFrameBuffer(size_t min_size, vpx_codec_frame_buffer_t *fb) {\n    EXPECT_TRUE(fb != NULL);\n    const int idx = FindFreeBufferIndex();\n    if (idx == num_buffers_) return -1;\n\n    if (ext_fb_list_[idx].size < min_size) {\n      delete[] ext_fb_list_[idx].data;\n      ext_fb_list_[idx].data = new uint8_t[min_size];\n      memset(ext_fb_list_[idx].data, 0, min_size);\n      ext_fb_list_[idx].size = min_size;\n    }\n\n    SetFrameBuffer(idx, fb);\n\n    num_used_buffers_++;\n    return 0;\n  }",
          "fn_code_pos": [
            [
              62,
              2
            ],
            [
              78,
              3
            ]
          ],
          "class_code": "1b5ba14f4832369e12838c1b54b11786d3e551dcc8cd77296b69074cb2690626",
          "class_node_pos": [
            [
              35,
              0
            ],
            [
              156,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetFreeFrameBuffer",
            "parameters": {
              "min_size": "size_t",
              "fb": "vpx_codec_frame_buffer_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int GetZeroFrameBuffer(size_t min_size, vpx_codec_frame_buffer_t *fb) {\n    EXPECT_TRUE(fb != NULL);\n    const int idx = FindFreeBufferIndex();\n    if (idx == num_buffers_) return -1;\n\n    if (ext_fb_list_[idx].size < min_size) {\n      delete[] ext_fb_list_[idx].data;\n      ext_fb_list_[idx].data = NULL;\n      ext_fb_list_[idx].size = min_size;\n    }\n\n    SetFrameBuffer(idx, fb);\n    return 0;\n  }",
          "fn_code_pos": [
            [
              82,
              2
            ],
            [
              95,
              3
            ]
          ],
          "class_code": "1b5ba14f4832369e12838c1b54b11786d3e551dcc8cd77296b69074cb2690626",
          "class_node_pos": [
            [
              35,
              0
            ],
            [
              156,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetZeroFrameBuffer",
            "parameters": {
              "min_size": "size_t",
              "fb": "vpx_codec_frame_buffer_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ReturnFrameBuffer(vpx_codec_frame_buffer_t *fb) {\n    if (fb == NULL) {\n      EXPECT_TRUE(fb != NULL);\n      return -1;\n    }\n    ExternalFrameBuffer *const ext_fb =\n        reinterpret_cast<ExternalFrameBuffer *>(fb->priv);\n    if (ext_fb == NULL) {\n      EXPECT_TRUE(ext_fb != NULL);\n      return -1;\n    }\n    EXPECT_EQ(1, ext_fb->in_use);\n    ext_fb->in_use = 0;\n    num_used_buffers_--;\n    return 0;\n  }",
          "fn_code_pos": [
            [
              99,
              2
            ],
            [
              114,
              3
            ]
          ],
          "class_code": "1b5ba14f4832369e12838c1b54b11786d3e551dcc8cd77296b69074cb2690626",
          "class_node_pos": [
            [
              35,
              0
            ],
            [
              156,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ReturnFrameBuffer",
            "parameters": {
              "fb": "vpx_codec_frame_buffer_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void CheckImageFrameBuffer(const vpx_image_t *img) {\n    if (img->fb_priv != NULL) {\n      const struct ExternalFrameBuffer *const ext_fb =\n          reinterpret_cast<ExternalFrameBuffer *>(img->fb_priv);\n\n      ASSERT_TRUE(img->planes[0] >= ext_fb->data &&\n                  img->planes[0] < (ext_fb->data + ext_fb->size));\n    }\n  }",
          "fn_code_pos": [
            [
              118,
              2
            ],
            [
              126,
              3
            ]
          ],
          "class_code": "1b5ba14f4832369e12838c1b54b11786d3e551dcc8cd77296b69074cb2690626",
          "class_node_pos": [
            [
              35,
              0
            ],
            [
              156,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckImageFrameBuffer",
            "parameters": {
              "img": "vpx_image_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int num_used_buffers() const { return num_used_buffers_; }",
          "fn_code_pos": [
            [
              128,
              2
            ],
            [
              128,
              60
            ]
          ],
          "class_code": "1b5ba14f4832369e12838c1b54b11786d3e551dcc8cd77296b69074cb2690626",
          "class_node_pos": [
            [
              35,
              0
            ],
            [
              156,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "num_used_buffers",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int FindFreeBufferIndex() {\n    int i;\n    // Find a free frame buffer.\n    for (i = 0; i < num_buffers_; ++i) {\n      if (!ext_fb_list_[i].in_use) break;\n    }\n    return i;\n  }",
          "fn_code_pos": [
            [
              133,
              2
            ],
            [
              140,
              3
            ]
          ],
          "class_code": "1b5ba14f4832369e12838c1b54b11786d3e551dcc8cd77296b69074cb2690626",
          "class_node_pos": [
            [
              35,
              0
            ],
            [
              156,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FindFreeBufferIndex",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "void SetFrameBuffer(int idx, vpx_codec_frame_buffer_t *fb) {\n    ASSERT_TRUE(fb != NULL);\n    fb->data = ext_fb_list_[idx].data;\n    fb->size = ext_fb_list_[idx].size;\n    ASSERT_EQ(0, ext_fb_list_[idx].in_use);\n    ext_fb_list_[idx].in_use = 1;\n    fb->priv = &ext_fb_list_[idx];\n  }",
          "fn_code_pos": [
            [
              144,
              2
            ],
            [
              151,
              3
            ]
          ],
          "class_code": "1b5ba14f4832369e12838c1b54b11786d3e551dcc8cd77296b69074cb2690626",
          "class_node_pos": [
            [
              35,
              0
            ],
            [
              156,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetFrameBuffer",
            "parameters": {
              "idx": "int",
              "fb": "vpx_codec_frame_buffer_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int get_vp9_frame_buffer(void *user_priv, size_t min_size,\n                         vpx_codec_frame_buffer_t *fb) {\n  ExternalFrameBufferList *const fb_list =\n      reinterpret_cast<ExternalFrameBufferList *>(user_priv);\n  return fb_list->GetFreeFrameBuffer(min_size, fb);\n}",
          "fn_code_pos": [
            [
              162,
              0
            ],
            [
              167,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_vp9_frame_buffer",
            "parameters": {
              "user_priv": "void",
              "min_size": "size_t",
              "fb": "vpx_codec_frame_buffer_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int release_vp9_frame_buffer(void *user_priv, vpx_codec_frame_buffer_t *fb) {\n  ExternalFrameBufferList *const fb_list =\n      reinterpret_cast<ExternalFrameBufferList *>(user_priv);\n  return fb_list->ReturnFrameBuffer(fb);\n}",
          "fn_code_pos": [
            [
              171,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "release_vp9_frame_buffer",
            "parameters": {
              "user_priv": "void",
              "fb": "vpx_codec_frame_buffer_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int get_vp9_zero_frame_buffer(void *user_priv, size_t min_size,\n                              vpx_codec_frame_buffer_t *fb) {\n  ExternalFrameBufferList *const fb_list =\n      reinterpret_cast<ExternalFrameBufferList *>(user_priv);\n  return fb_list->GetZeroFrameBuffer(min_size, fb);\n}",
          "fn_code_pos": [
            [
              178,
              0
            ],
            [
              183,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_vp9_zero_frame_buffer",
            "parameters": {
              "user_priv": "void",
              "min_size": "size_t",
              "fb": "vpx_codec_frame_buffer_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int get_vp9_one_less_byte_frame_buffer(void *user_priv, size_t min_size,\n                                       vpx_codec_frame_buffer_t *fb) {\n  ExternalFrameBufferList *const fb_list =\n      reinterpret_cast<ExternalFrameBufferList *>(user_priv);\n  return fb_list->GetFreeFrameBuffer(min_size - 1, fb);\n}",
          "fn_code_pos": [
            [
              186,
              0
            ],
            [
              191,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_vp9_one_less_byte_frame_buffer",
            "parameters": {
              "user_priv": "void",
              "min_size": "size_t",
              "fb": "vpx_codec_frame_buffer_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int do_not_release_vp9_frame_buffer(void *user_priv,\n                                    vpx_codec_frame_buffer_t *fb) {\n  (void)user_priv;\n  (void)fb;\n  return 0;\n}",
          "fn_code_pos": [
            [
              194,
              0
            ],
            [
              199,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "do_not_release_vp9_frame_buffer",
            "parameters": {
              "user_priv": "void",
              "fb": "vpx_codec_frame_buffer_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ExternalFrameBufferMD5Test()\n      : DecoderTest(GET_PARAM(::libvpx_test::kCodecFactoryParam)),\n        md5_file_(NULL), num_buffers_(0) {}",
          "fn_code_pos": [
            [
              208,
              2
            ],
            [
              210,
              43
            ]
          ],
          "class_code": "20a4451c394ff638efd5b9c90024b426bfbfdc4607ce4d64cc3d4064012d5df1",
          "class_node_pos": [
            [
              204,
              0
            ],
            [
              279,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ExternalFrameBufferMD5Test",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~ExternalFrameBufferMD5Test() {\n    if (md5_file_ != NULL) fclose(md5_file_);\n  }",
          "fn_code_pos": [
            [
              212,
              2
            ],
            [
              214,
              3
            ]
          ],
          "class_code": "20a4451c394ff638efd5b9c90024b426bfbfdc4607ce4d64cc3d4064012d5df1",
          "class_node_pos": [
            [
              204,
              0
            ],
            [
              279,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void PreDecodeFrameHook(\n      const libvpx_test::CompressedVideoSource &video,\n      libvpx_test::Decoder *decoder) {\n    if (num_buffers_ > 0 && video.frame_number() == 0) {\n      // Have libvpx use frame buffers we create.\n      ASSERT_TRUE(fb_list_.CreateBufferList(num_buffers_));\n      ASSERT_EQ(VPX_CODEC_OK,\n                decoder->SetFrameBufferFunctions(GetVP9FrameBuffer,\n                                                 ReleaseVP9FrameBuffer, this));\n    }\n  }",
          "fn_code_pos": [
            [
              216,
              2
            ],
            [
              226,
              3
            ]
          ],
          "class_code": "20a4451c394ff638efd5b9c90024b426bfbfdc4607ce4d64cc3d4064012d5df1",
          "class_node_pos": [
            [
              204,
              0
            ],
            [
              279,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreDecodeFrameHook",
            "parameters": {
              "video": "libvpx_test::CompressedVideoSource",
              "decoder": "libvpx_test::Decoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void OpenMD5File(const std::string &md5_file_name_) {\n    md5_file_ = libvpx_test::OpenTestDataFile(md5_file_name_);\n    ASSERT_TRUE(md5_file_ != NULL)\n        << \"Md5 file open failed. Filename: \" << md5_file_name_;\n  }",
          "fn_code_pos": [
            [
              228,
              2
            ],
            [
              232,
              3
            ]
          ],
          "class_code": "20a4451c394ff638efd5b9c90024b426bfbfdc4607ce4d64cc3d4064012d5df1",
          "class_node_pos": [
            [
              204,
              0
            ],
            [
              279,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "OpenMD5File",
            "parameters": {
              "md5_file_name_": "std::string"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void DecompressedFrameHook(const vpx_image_t &img,\n                                     const unsigned int frame_number) {\n    ASSERT_TRUE(md5_file_ != NULL);\n    char expected_md5[33];\n    char junk[128];\n\n    // Read correct md5 checksums.\n    const int res = fscanf(md5_file_, \"%s  %s\", expected_md5, junk);\n    ASSERT_NE(EOF, res) << \"Read md5 data failed\";\n    expected_md5[32] = '\\0';\n\n    ::libvpx_test::MD5 md5_res;\n    md5_res.Add(&img);\n    const char *const actual_md5 = md5_res.Get();\n\n    // Check md5 match.\n    ASSERT_STREQ(expected_md5, actual_md5)\n        << \"Md5 checksums don't match: frame number = \" << frame_number;\n  }",
          "fn_code_pos": [
            [
              234,
              2
            ],
            [
              252,
              3
            ]
          ],
          "class_code": "20a4451c394ff638efd5b9c90024b426bfbfdc4607ce4d64cc3d4064012d5df1",
          "class_node_pos": [
            [
              204,
              0
            ],
            [
              279,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecompressedFrameHook",
            "parameters": {
              "img": "vpx_image_t",
              "frame_number": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int GetVP9FrameBuffer(void *user_priv, size_t min_size,\n                               vpx_codec_frame_buffer_t *fb) {\n    ExternalFrameBufferMD5Test *const md5Test =\n        reinterpret_cast<ExternalFrameBufferMD5Test *>(user_priv);\n    return md5Test->fb_list_.GetFreeFrameBuffer(min_size, fb);\n  }",
          "fn_code_pos": [
            [
              256,
              2
            ],
            [
              261,
              3
            ]
          ],
          "class_code": "20a4451c394ff638efd5b9c90024b426bfbfdc4607ce4d64cc3d4064012d5df1",
          "class_node_pos": [
            [
              204,
              0
            ],
            [
              279,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetVP9FrameBuffer",
            "parameters": {
              "user_priv": "void",
              "min_size": "size_t",
              "fb": "vpx_codec_frame_buffer_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int ReleaseVP9FrameBuffer(void *user_priv,\n                                   vpx_codec_frame_buffer_t *fb) {\n    ExternalFrameBufferMD5Test *const md5Test =\n        reinterpret_cast<ExternalFrameBufferMD5Test *>(user_priv);\n    return md5Test->fb_list_.ReturnFrameBuffer(fb);\n  }",
          "fn_code_pos": [
            [
              265,
              2
            ],
            [
              270,
              3
            ]
          ],
          "class_code": "20a4451c394ff638efd5b9c90024b426bfbfdc4607ce4d64cc3d4064012d5df1",
          "class_node_pos": [
            [
              204,
              0
            ],
            [
              279,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ReleaseVP9FrameBuffer",
            "parameters": {
              "user_priv": "void",
              "fb": "vpx_codec_frame_buffer_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void set_num_buffers(int num_buffers) { num_buffers_ = num_buffers; }",
          "fn_code_pos": [
            [
              272,
              2
            ],
            [
              272,
              71
            ]
          ],
          "class_code": "20a4451c394ff638efd5b9c90024b426bfbfdc4607ce4d64cc3d4064012d5df1",
          "class_node_pos": [
            [
              204,
              0
            ],
            [
              279,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "set_num_buffers",
            "parameters": {
              "num_buffers": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int num_buffers() const { return num_buffers_; }",
          "fn_code_pos": [
            [
              273,
              2
            ],
            [
              273,
              50
            ]
          ],
          "class_code": "20a4451c394ff638efd5b9c90024b426bfbfdc4607ce4d64cc3d4064012d5df1",
          "class_node_pos": [
            [
              204,
              0
            ],
            [
              279,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "num_buffers",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "ExternalFrameBufferTest() : video_(NULL), decoder_(NULL), num_buffers_(0) {}",
          "fn_code_pos": [
            [
              288,
              2
            ],
            [
              288,
              78
            ]
          ],
          "class_code": "974df0845bdbaf1035f1a1239ba6d9c878e15d971c2484190cbd2a7bd49ca12c",
          "class_node_pos": [
            [
              286,
              0
            ],
            [
              352,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ExternalFrameBufferTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    video_ = new libvpx_test::WebMVideoSource(kVP9TestFile);\n    ASSERT_TRUE(video_ != NULL);\n    video_->Init();\n    video_->Begin();\n\n    vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n    decoder_ = new libvpx_test::VP9Decoder(cfg, 0);\n    ASSERT_TRUE(decoder_ != NULL);\n  }",
          "fn_code_pos": [
            [
              290,
              2
            ],
            [
              299,
              3
            ]
          ],
          "class_code": "974df0845bdbaf1035f1a1239ba6d9c878e15d971c2484190cbd2a7bd49ca12c",
          "class_node_pos": [
            [
              286,
              0
            ],
            [
              352,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() {\n    delete decoder_;\n    decoder_ = NULL;\n    delete video_;\n    video_ = NULL;\n  }",
          "fn_code_pos": [
            [
              301,
              2
            ],
            [
              306,
              3
            ]
          ],
          "class_code": "974df0845bdbaf1035f1a1239ba6d9c878e15d971c2484190cbd2a7bd49ca12c",
          "class_node_pos": [
            [
              286,
              0
            ],
            [
              352,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "vpx_codec_err_t SetFrameBufferFunctions(\n      int num_buffers, vpx_get_frame_buffer_cb_fn_t cb_get,\n      vpx_release_frame_buffer_cb_fn_t cb_release) {\n    if (num_buffers > 0) {\n      num_buffers_ = num_buffers;\n      EXPECT_TRUE(fb_list_.CreateBufferList(num_buffers_));\n    }\n\n    return decoder_->SetFrameBufferFunctions(cb_get, cb_release, &fb_list_);\n  }",
          "fn_code_pos": [
            [
              309,
              2
            ],
            [
              318,
              3
            ]
          ],
          "class_code": "974df0845bdbaf1035f1a1239ba6d9c878e15d971c2484190cbd2a7bd49ca12c",
          "class_node_pos": [
            [
              286,
              0
            ],
            [
              352,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetFrameBufferFunctions",
            "parameters": {
              "num_buffers": "int",
              "cb_get": "vpx_get_frame_buffer_cb_fn_t",
              "cb_release": "vpx_release_frame_buffer_cb_fn_t"
            },
            "return_type": "vpx_codec_err_t"
          }
        },
        {
          "fn_code": "vpx_codec_err_t DecodeOneFrame() {\n    const vpx_codec_err_t res =\n        decoder_->DecodeFrame(video_->cxdata(), video_->frame_size());\n    CheckDecodedFrames();\n    if (res == VPX_CODEC_OK) video_->Next();\n    return res;\n  }",
          "fn_code_pos": [
            [
              320,
              2
            ],
            [
              326,
              3
            ]
          ],
          "class_code": "974df0845bdbaf1035f1a1239ba6d9c878e15d971c2484190cbd2a7bd49ca12c",
          "class_node_pos": [
            [
              286,
              0
            ],
            [
              352,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecodeOneFrame",
            "parameters": {},
            "return_type": "vpx_codec_err_t"
          }
        },
        {
          "fn_code": "vpx_codec_err_t DecodeRemainingFrames() {\n    for (; video_->cxdata() != NULL; video_->Next()) {\n      const vpx_codec_err_t res =\n          decoder_->DecodeFrame(video_->cxdata(), video_->frame_size());\n      if (res != VPX_CODEC_OK) return res;\n      CheckDecodedFrames();\n    }\n    return VPX_CODEC_OK;\n  }",
          "fn_code_pos": [
            [
              328,
              2
            ],
            [
              336,
              3
            ]
          ],
          "class_code": "974df0845bdbaf1035f1a1239ba6d9c878e15d971c2484190cbd2a7bd49ca12c",
          "class_node_pos": [
            [
              286,
              0
            ],
            [
              352,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecodeRemainingFrames",
            "parameters": {},
            "return_type": "vpx_codec_err_t"
          }
        },
        {
          "fn_code": "void CheckDecodedFrames() {\n    libvpx_test::DxDataIterator dec_iter = decoder_->GetDxData();\n    const vpx_image_t *img = NULL;\n\n    // Get decompressed data\n    while ((img = dec_iter.Next()) != NULL) {\n      fb_list_.CheckImageFrameBuffer(img);\n    }\n  }",
          "fn_code_pos": [
            [
              338,
              2
            ],
            [
              346,
              3
            ]
          ],
          "class_code": "974df0845bdbaf1035f1a1239ba6d9c878e15d971c2484190cbd2a7bd49ca12c",
          "class_node_pos": [
            [
              286,
              0
            ],
            [
              352,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckDecodedFrames",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    video_ = new libvpx_test::WebMVideoSource(kVP9NonRefTestFile);\n    ASSERT_TRUE(video_ != NULL);\n    video_->Init();\n    video_->Begin();\n\n    vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n    decoder_ = new libvpx_test::VP9Decoder(cfg, 0);\n    ASSERT_TRUE(decoder_ != NULL);\n  }",
          "fn_code_pos": [
            [
              356,
              2
            ],
            [
              365,
              3
            ]
          ],
          "class_code": "909383af64a0485fa6980d68d29a884bca25825c4cdcfbd5c2e3413372cd7cee",
          "class_node_pos": [
            [
              354,
              0
            ],
            [
              371,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void CheckFrameBufferRelease() {\n    TearDown();\n    ASSERT_EQ(0, fb_list_.num_used_buffers());\n  }",
          "fn_code_pos": [
            [
              367,
              2
            ],
            [
              370,
              3
            ]
          ],
          "class_code": "909383af64a0485fa6980d68d29a884bca25825c4cdcfbd5c2e3413372cd7cee",
          "class_node_pos": [
            [
              354,
              0
            ],
            [
              371,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckFrameBufferRelease",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(ExternalFrameBufferMD5Test, ExtFBMD5Match) {\n  const std::string filename = GET_PARAM(kVideoNameParam);\n\n  // Number of buffers equals #VP9_MAXIMUM_REF_BUFFERS +\n  // #VPX_MAXIMUM_WORK_BUFFERS + four jitter buffers.\n  const int jitter_buffers = 4;\n  const int num_buffers =\n      VP9_MAXIMUM_REF_BUFFERS + VPX_MAXIMUM_WORK_BUFFERS + jitter_buffers;\n  set_num_buffers(num_buffers);\n\n#if CONFIG_VP8_DECODER\n  // Tell compiler we are not using kVP8TestVectors.\n  (void)libvpx_test::kVP8TestVectors;\n#endif\n\n  // Open compressed video file.\n  std::unique_ptr<libvpx_test::CompressedVideoSource> video;\n  if (filename.substr(filename.length() - 3, 3) == \"ivf\") {\n    video.reset(new libvpx_test::IVFVideoSource(filename));\n  } else {\n#if CONFIG_WEBM_IO\n    video.reset(new libvpx_test::WebMVideoSource(filename));\n#else\n    fprintf(stderr, \"WebM IO is disabled, skipping test vector %s\\n\",\n            filename.c_str());\n    return;\n#endif\n  }\n  ASSERT_TRUE(video.get() != NULL);\n  video->Init();\n\n  // Construct md5 file name.\n  const std::string md5_filename = filename + \".md5\";\n  OpenMD5File(md5_filename);\n\n  // Decode frame, and check the md5 matching.\n  ASSERT_NO_FATAL_FAILURE(RunLoop(video.get()));\n}",
          "fn_code_pos": [
            [
              379,
              0
            ],
            [
              416,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(ExternalFrameBufferTest, MinFrameBuffers) {\n  // Minimum number of external frame buffers for VP9 is\n  // #VP9_MAXIMUM_REF_BUFFERS + #VPX_MAXIMUM_WORK_BUFFERS.\n  const int num_buffers = VP9_MAXIMUM_REF_BUFFERS + VPX_MAXIMUM_WORK_BUFFERS;\n  ASSERT_EQ(VPX_CODEC_OK,\n            SetFrameBufferFunctions(num_buffers, get_vp9_frame_buffer,\n                                    release_vp9_frame_buffer));\n  ASSERT_EQ(VPX_CODEC_OK, DecodeRemainingFrames());\n}",
          "fn_code_pos": [
            [
              419,
              0
            ],
            [
              427,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(ExternalFrameBufferTest, EightJitterBuffers) {\n  // Number of buffers equals #VP9_MAXIMUM_REF_BUFFERS +\n  // #VPX_MAXIMUM_WORK_BUFFERS + eight jitter buffers.\n  const int jitter_buffers = 8;\n  const int num_buffers =\n      VP9_MAXIMUM_REF_BUFFERS + VPX_MAXIMUM_WORK_BUFFERS + jitter_buffers;\n  ASSERT_EQ(VPX_CODEC_OK,\n            SetFrameBufferFunctions(num_buffers, get_vp9_frame_buffer,\n                                    release_vp9_frame_buffer));\n  ASSERT_EQ(VPX_CODEC_OK, DecodeRemainingFrames());\n}",
          "fn_code_pos": [
            [
              429,
              0
            ],
            [
              439,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(ExternalFrameBufferTest, NotEnoughBuffers) {\n  // Minimum number of external frame buffers for VP9 is\n  // #VP9_MAXIMUM_REF_BUFFERS + #VPX_MAXIMUM_WORK_BUFFERS. Most files will\n  // only use 5 frame buffers at one time.\n  const int num_buffers = 2;\n  ASSERT_EQ(VPX_CODEC_OK,\n            SetFrameBufferFunctions(num_buffers, get_vp9_frame_buffer,\n                                    release_vp9_frame_buffer));\n  ASSERT_EQ(VPX_CODEC_OK, DecodeOneFrame());\n  // Only run this on long clips. Decoding a very short clip will return\n  // VPX_CODEC_OK even with only 2 buffers.\n  ASSERT_EQ(VPX_CODEC_MEM_ERROR, DecodeRemainingFrames());\n}",
          "fn_code_pos": [
            [
              441,
              0
            ],
            [
              453,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(ExternalFrameBufferTest, NoRelease) {\n  const int num_buffers = VP9_MAXIMUM_REF_BUFFERS + VPX_MAXIMUM_WORK_BUFFERS;\n  ASSERT_EQ(VPX_CODEC_OK,\n            SetFrameBufferFunctions(num_buffers, get_vp9_frame_buffer,\n                                    do_not_release_vp9_frame_buffer));\n  ASSERT_EQ(VPX_CODEC_OK, DecodeOneFrame());\n  ASSERT_EQ(VPX_CODEC_MEM_ERROR, DecodeRemainingFrames());\n}",
          "fn_code_pos": [
            [
              455,
              0
            ],
            [
              462,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(ExternalFrameBufferTest, NullRealloc) {\n  const int num_buffers = VP9_MAXIMUM_REF_BUFFERS + VPX_MAXIMUM_WORK_BUFFERS;\n  ASSERT_EQ(VPX_CODEC_OK,\n            SetFrameBufferFunctions(num_buffers, get_vp9_zero_frame_buffer,\n                                    release_vp9_frame_buffer));\n  ASSERT_EQ(VPX_CODEC_MEM_ERROR, DecodeOneFrame());\n}",
          "fn_code_pos": [
            [
              464,
              0
            ],
            [
              470,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(ExternalFrameBufferTest, ReallocOneLessByte) {\n  const int num_buffers = VP9_MAXIMUM_REF_BUFFERS + VPX_MAXIMUM_WORK_BUFFERS;\n  ASSERT_EQ(VPX_CODEC_OK, SetFrameBufferFunctions(\n                              num_buffers, get_vp9_one_less_byte_frame_buffer,\n                              release_vp9_frame_buffer));\n  ASSERT_EQ(VPX_CODEC_MEM_ERROR, DecodeOneFrame());\n}",
          "fn_code_pos": [
            [
              472,
              0
            ],
            [
              478,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(ExternalFrameBufferTest, NullGetFunction) {\n  const int num_buffers = VP9_MAXIMUM_REF_BUFFERS + VPX_MAXIMUM_WORK_BUFFERS;\n  ASSERT_EQ(\n      VPX_CODEC_INVALID_PARAM,\n      SetFrameBufferFunctions(num_buffers, NULL, release_vp9_frame_buffer));\n}",
          "fn_code_pos": [
            [
              480,
              0
            ],
            [
              485,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(ExternalFrameBufferTest, NullReleaseFunction) {\n  const int num_buffers = VP9_MAXIMUM_REF_BUFFERS + VPX_MAXIMUM_WORK_BUFFERS;\n  ASSERT_EQ(VPX_CODEC_INVALID_PARAM,\n            SetFrameBufferFunctions(num_buffers, get_vp9_frame_buffer, NULL));\n}",
          "fn_code_pos": [
            [
              487,
              0
            ],
            [
              491,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(ExternalFrameBufferTest, SetAfterDecode) {\n  const int num_buffers = VP9_MAXIMUM_REF_BUFFERS + VPX_MAXIMUM_WORK_BUFFERS;\n  ASSERT_EQ(VPX_CODEC_OK, DecodeOneFrame());\n  ASSERT_EQ(VPX_CODEC_ERROR,\n            SetFrameBufferFunctions(num_buffers, get_vp9_frame_buffer,\n                                    release_vp9_frame_buffer));\n}",
          "fn_code_pos": [
            [
              493,
              0
            ],
            [
              499,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(ExternalFrameBufferNonRefTest, ReleaseNonRefFrameBuffer) {\n  const int num_buffers = VP9_MAXIMUM_REF_BUFFERS + VPX_MAXIMUM_WORK_BUFFERS;\n  ASSERT_EQ(VPX_CODEC_OK,\n            SetFrameBufferFunctions(num_buffers, get_vp9_frame_buffer,\n                                    release_vp9_frame_buffer));\n  ASSERT_EQ(VPX_CODEC_OK, DecodeRemainingFrames());\n  CheckFrameBufferRelease();\n}",
          "fn_code_pos": [
            [
              501,
              0
            ],
            [
              508,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "1b5ba14f4832369e12838c1b54b11786d3e551dcc8cd77296b69074cb2690626": {
          "class_code": "class ExternalFrameBufferList {\n public:\n  ExternalFrameBufferList()\n      : num_buffers_(0), num_used_buffers_(0), ext_fb_list_(NULL) {}\n\n  virtual ~ExternalFrameBufferList() {\n    for (int i = 0; i < num_buffers_; ++i) {\n      delete[] ext_fb_list_[i].data;\n    }\n    delete[] ext_fb_list_;\n  }\n\n  // Creates the list to hold the external buffers. Returns true on success.\n  bool CreateBufferList(int num_buffers) {\n    if (num_buffers < 0) return false;\n\n    num_buffers_ = num_buffers;\n    ext_fb_list_ = new ExternalFrameBuffer[num_buffers_];\n    EXPECT_TRUE(ext_fb_list_ != NULL);\n    memset(ext_fb_list_, 0, sizeof(ext_fb_list_[0]) * num_buffers_);\n    return true;\n  }\n\n  // Searches the frame buffer list for a free frame buffer. Makes sure\n  // that the frame buffer is at least |min_size| in bytes. Marks that the\n  // frame buffer is in use by libvpx. Finally sets |fb| to point to the\n  // external frame buffer. Returns < 0 on an error.\n  int GetFreeFrameBuffer(size_t min_size, vpx_codec_frame_buffer_t *fb) {\n    EXPECT_TRUE(fb != NULL);\n    const int idx = FindFreeBufferIndex();\n    if (idx == num_buffers_) return -1;\n\n    if (ext_fb_list_[idx].size < min_size) {\n      delete[] ext_fb_list_[idx].data;\n      ext_fb_list_[idx].data = new uint8_t[min_size];\n      memset(ext_fb_list_[idx].data, 0, min_size);\n      ext_fb_list_[idx].size = min_size;\n    }\n\n    SetFrameBuffer(idx, fb);\n\n    num_used_buffers_++;\n    return 0;\n  }\n\n  // Test function that will not allocate any data for the frame buffer.\n  // Returns < 0 on an error.\n  int GetZeroFrameBuffer(size_t min_size, vpx_codec_frame_buffer_t *fb) {\n    EXPECT_TRUE(fb != NULL);\n    const int idx = FindFreeBufferIndex();\n    if (idx == num_buffers_) return -1;\n\n    if (ext_fb_list_[idx].size < min_size) {\n      delete[] ext_fb_list_[idx].data;\n      ext_fb_list_[idx].data = NULL;\n      ext_fb_list_[idx].size = min_size;\n    }\n\n    SetFrameBuffer(idx, fb);\n    return 0;\n  }\n\n  // Marks the external frame buffer that |fb| is pointing to as free.\n  // Returns < 0 on an error.\n  int ReturnFrameBuffer(vpx_codec_frame_buffer_t *fb) {\n    if (fb == NULL) {\n      EXPECT_TRUE(fb != NULL);\n      return -1;\n    }\n    ExternalFrameBuffer *const ext_fb =\n        reinterpret_cast<ExternalFrameBuffer *>(fb->priv);\n    if (ext_fb == NULL) {\n      EXPECT_TRUE(ext_fb != NULL);\n      return -1;\n    }\n    EXPECT_EQ(1, ext_fb->in_use);\n    ext_fb->in_use = 0;\n    num_used_buffers_--;\n    return 0;\n  }\n\n  // Checks that the vpx_image_t data is contained within the external frame\n  // buffer private data passed back in the vpx_image_t.\n  void CheckImageFrameBuffer(const vpx_image_t *img) {\n    if (img->fb_priv != NULL) {\n      const struct ExternalFrameBuffer *const ext_fb =\n          reinterpret_cast<ExternalFrameBuffer *>(img->fb_priv);\n\n      ASSERT_TRUE(img->planes[0] >= ext_fb->data &&\n                  img->planes[0] < (ext_fb->data + ext_fb->size));\n    }\n  }\n\n  int num_used_buffers() const { return num_used_buffers_; }\n\n private:\n  // Returns the index of the first free frame buffer. Returns |num_buffers_|\n  // if there are no free frame buffers.\n  int FindFreeBufferIndex() {\n    int i;\n    // Find a free frame buffer.\n    for (i = 0; i < num_buffers_; ++i) {\n      if (!ext_fb_list_[i].in_use) break;\n    }\n    return i;\n  }\n\n  // Sets |fb| to an external frame buffer. idx is the index into the frame\n  // buffer list.\n  void SetFrameBuffer(int idx, vpx_codec_frame_buffer_t *fb) {\n    ASSERT_TRUE(fb != NULL);\n    fb->data = ext_fb_list_[idx].data;\n    fb->size = ext_fb_list_[idx].size;\n    ASSERT_EQ(0, ext_fb_list_[idx].in_use);\n    ext_fb_list_[idx].in_use = 1;\n    fb->priv = &ext_fb_list_[idx];\n  }\n\n  int num_buffers_;\n  int num_used_buffers_;\n  ExternalFrameBuffer *ext_fb_list_;\n}",
          "class_name": "ExternalFrameBufferList",
          "class_pos": [
            [
              35,
              0
            ],
            [
              156,
              1
            ]
          ]
        },
        "20a4451c394ff638efd5b9c90024b426bfbfdc4607ce4d64cc3d4064012d5df1": {
          "class_code": "class ExternalFrameBufferMD5Test\n    : public ::libvpx_test::DecoderTest,\n      public ::libvpx_test::CodecTestWithParam<const char *> {\n protected:\n  ExternalFrameBufferMD5Test()\n      : DecoderTest(GET_PARAM(::libvpx_test::kCodecFactoryParam)),\n        md5_file_(NULL), num_buffers_(0) {}\n\n  virtual ~ExternalFrameBufferMD5Test() {\n    if (md5_file_ != NULL) fclose(md5_file_);\n  }\n\n  virtual void PreDecodeFrameHook(\n      const libvpx_test::CompressedVideoSource &video,\n      libvpx_test::Decoder *decoder) {\n    if (num_buffers_ > 0 && video.frame_number() == 0) {\n      // Have libvpx use frame buffers we create.\n      ASSERT_TRUE(fb_list_.CreateBufferList(num_buffers_));\n      ASSERT_EQ(VPX_CODEC_OK,\n                decoder->SetFrameBufferFunctions(GetVP9FrameBuffer,\n                                                 ReleaseVP9FrameBuffer, this));\n    }\n  }\n\n  void OpenMD5File(const std::string &md5_file_name_) {\n    md5_file_ = libvpx_test::OpenTestDataFile(md5_file_name_);\n    ASSERT_TRUE(md5_file_ != NULL)\n        << \"Md5 file open failed. Filename: \" << md5_file_name_;\n  }\n\n  virtual void DecompressedFrameHook(const vpx_image_t &img,\n                                     const unsigned int frame_number) {\n    ASSERT_TRUE(md5_file_ != NULL);\n    char expected_md5[33];\n    char junk[128];\n\n    // Read correct md5 checksums.\n    const int res = fscanf(md5_file_, \"%s  %s\", expected_md5, junk);\n    ASSERT_NE(EOF, res) << \"Read md5 data failed\";\n    expected_md5[32] = '\\0';\n\n    ::libvpx_test::MD5 md5_res;\n    md5_res.Add(&img);\n    const char *const actual_md5 = md5_res.Get();\n\n    // Check md5 match.\n    ASSERT_STREQ(expected_md5, actual_md5)\n        << \"Md5 checksums don't match: frame number = \" << frame_number;\n  }\n\n  // Callback to get a free external frame buffer. Return value < 0 is an\n  // error.\n  static int GetVP9FrameBuffer(void *user_priv, size_t min_size,\n                               vpx_codec_frame_buffer_t *fb) {\n    ExternalFrameBufferMD5Test *const md5Test =\n        reinterpret_cast<ExternalFrameBufferMD5Test *>(user_priv);\n    return md5Test->fb_list_.GetFreeFrameBuffer(min_size, fb);\n  }\n\n  // Callback to release an external frame buffer. Return value < 0 is an\n  // error.\n  static int ReleaseVP9FrameBuffer(void *user_priv,\n                                   vpx_codec_frame_buffer_t *fb) {\n    ExternalFrameBufferMD5Test *const md5Test =\n        reinterpret_cast<ExternalFrameBufferMD5Test *>(user_priv);\n    return md5Test->fb_list_.ReturnFrameBuffer(fb);\n  }\n\n  void set_num_buffers(int num_buffers) { num_buffers_ = num_buffers; }\n  int num_buffers() const { return num_buffers_; }\n\n private:\n  FILE *md5_file_;\n  int num_buffers_;\n  ExternalFrameBufferList fb_list_;\n}",
          "class_name": "ExternalFrameBufferMD5Test",
          "class_pos": [
            [
              204,
              0
            ],
            [
              279,
              1
            ]
          ]
        },
        "974df0845bdbaf1035f1a1239ba6d9c878e15d971c2484190cbd2a7bd49ca12c": {
          "class_code": "class ExternalFrameBufferTest : public ::testing::Test {\n protected:\n  ExternalFrameBufferTest() : video_(NULL), decoder_(NULL), num_buffers_(0) {}\n\n  virtual void SetUp() {\n    video_ = new libvpx_test::WebMVideoSource(kVP9TestFile);\n    ASSERT_TRUE(video_ != NULL);\n    video_->Init();\n    video_->Begin();\n\n    vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n    decoder_ = new libvpx_test::VP9Decoder(cfg, 0);\n    ASSERT_TRUE(decoder_ != NULL);\n  }\n\n  virtual void TearDown() {\n    delete decoder_;\n    decoder_ = NULL;\n    delete video_;\n    video_ = NULL;\n  }\n\n  // Passes the external frame buffer information to libvpx.\n  vpx_codec_err_t SetFrameBufferFunctions(\n      int num_buffers, vpx_get_frame_buffer_cb_fn_t cb_get,\n      vpx_release_frame_buffer_cb_fn_t cb_release) {\n    if (num_buffers > 0) {\n      num_buffers_ = num_buffers;\n      EXPECT_TRUE(fb_list_.CreateBufferList(num_buffers_));\n    }\n\n    return decoder_->SetFrameBufferFunctions(cb_get, cb_release, &fb_list_);\n  }\n\n  vpx_codec_err_t DecodeOneFrame() {\n    const vpx_codec_err_t res =\n        decoder_->DecodeFrame(video_->cxdata(), video_->frame_size());\n    CheckDecodedFrames();\n    if (res == VPX_CODEC_OK) video_->Next();\n    return res;\n  }\n\n  vpx_codec_err_t DecodeRemainingFrames() {\n    for (; video_->cxdata() != NULL; video_->Next()) {\n      const vpx_codec_err_t res =\n          decoder_->DecodeFrame(video_->cxdata(), video_->frame_size());\n      if (res != VPX_CODEC_OK) return res;\n      CheckDecodedFrames();\n    }\n    return VPX_CODEC_OK;\n  }\n\n  void CheckDecodedFrames() {\n    libvpx_test::DxDataIterator dec_iter = decoder_->GetDxData();\n    const vpx_image_t *img = NULL;\n\n    // Get decompressed data\n    while ((img = dec_iter.Next()) != NULL) {\n      fb_list_.CheckImageFrameBuffer(img);\n    }\n  }\n\n  libvpx_test::WebMVideoSource *video_;\n  libvpx_test::VP9Decoder *decoder_;\n  int num_buffers_;\n  ExternalFrameBufferList fb_list_;\n}",
          "class_name": "ExternalFrameBufferTest",
          "class_pos": [
            [
              286,
              0
            ],
            [
              352,
              1
            ]
          ]
        },
        "909383af64a0485fa6980d68d29a884bca25825c4cdcfbd5c2e3413372cd7cee": {
          "class_code": "class ExternalFrameBufferNonRefTest : public ExternalFrameBufferTest {\n protected:\n  virtual void SetUp() {\n    video_ = new libvpx_test::WebMVideoSource(kVP9NonRefTestFile);\n    ASSERT_TRUE(video_ != NULL);\n    video_->Init();\n    video_->Begin();\n\n    vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n    decoder_ = new libvpx_test::VP9Decoder(cfg, 0);\n    ASSERT_TRUE(decoder_ != NULL);\n  }\n\n  virtual void CheckFrameBufferRelease() {\n    TearDown();\n    ASSERT_EQ(0, fb_list_.num_used_buffers());\n  }\n}",
          "class_name": "ExternalFrameBufferNonRefTest",
          "class_pos": [
            [
              354,
              0
            ],
            [
              371,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct ExternalFrameBuffer {\n  uint8_t *data;\n  size_t size;\n  int in_use;\n}",
          {
            "*data": "uint8_t",
            "size": "size_t",
            "in_use": "int"
          },
          "ExternalFrameBuffer",
          [
            28,
            0
          ],
          [
            32,
            1
          ]
        ],
        [
          "struct ExternalFrameBuffer {\n  uint8_t *data;\n  size_t size;\n  int in_use;\n}",
          {
            "*data": "uint8_t",
            "size": "size_t",
            "in_use": "int"
          },
          "ExternalFrameBuffer",
          [
            28,
            0
          ],
          [
            32,
            1
          ]
        ],
        [
          "struct ExternalFrameBuffer",
          {},
          "",
          [
            120,
            12
          ],
          [
            120,
            38
          ]
        ]
      ],
      "include_list": [
        [
          "#include <memory>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/decode_test_driver.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/ivf_video_source.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/md5_helper.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/test_vectors.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/webm_video_source.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/svc_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "void OnePassCbrSvc::SetSvcConfig(const int num_spatial_layer,\n                                 const int num_temporal_layer) {\n  SetConfig(num_temporal_layer);\n  cfg_.ss_number_layers = num_spatial_layer;\n  cfg_.ts_number_layers = num_temporal_layer;\n  if (num_spatial_layer == 1) {\n    svc_params_.scaling_factor_num[0] = 288;\n    svc_params_.scaling_factor_den[0] = 288;\n  } else if (num_spatial_layer == 2) {\n    svc_params_.scaling_factor_num[0] = 144;\n    svc_params_.scaling_factor_den[0] = 288;\n    svc_params_.scaling_factor_num[1] = 288;\n    svc_params_.scaling_factor_den[1] = 288;\n  } else if (num_spatial_layer == 3) {\n    svc_params_.scaling_factor_num[0] = 72;\n    svc_params_.scaling_factor_den[0] = 288;\n    svc_params_.scaling_factor_num[1] = 144;\n    svc_params_.scaling_factor_den[1] = 288;\n    svc_params_.scaling_factor_num[2] = 288;\n    svc_params_.scaling_factor_den[2] = 288;\n  }\n  number_spatial_layers_ = cfg_.ss_number_layers;\n  number_temporal_layers_ = cfg_.ts_number_layers;\n}",
          "fn_code_pos": [
            [
              13,
              0
            ],
            [
              36,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OnePassCbrSvc::SetSvcConfig",
            "parameters": {
              "num_spatial_layer": "int",
              "num_temporal_layer": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void OnePassCbrSvc::PreEncodeFrameHookSetup(::libvpx_test::VideoSource *video,\n                                            ::libvpx_test::Encoder *encoder) {\n  if (video->frame() == 0) {\n    for (int i = 0; i < VPX_MAX_LAYERS; ++i) {\n      svc_params_.max_quantizers[i] = 63;\n      svc_params_.min_quantizers[i] = 0;\n    }\n    svc_params_.speed_per_layer[0] = base_speed_setting_;\n    for (int i = 1; i < VPX_SS_MAX_LAYERS; ++i) {\n      svc_params_.speed_per_layer[i] = speed_setting_;\n    }\n\n    encoder->Control(VP9E_SET_SVC, 1);\n    encoder->Control(VP9E_SET_SVC_PARAMETERS, &svc_params_);\n    encoder->Control(VP8E_SET_CPUUSED, speed_setting_);\n    encoder->Control(VP9E_SET_AQ_MODE, 3);\n    encoder->Control(VP8E_SET_MAX_INTRA_BITRATE_PCT, 300);\n    encoder->Control(VP9E_SET_TILE_COLUMNS, get_msb(cfg_.g_threads));\n    encoder->Control(VP9E_SET_ROW_MT, 1);\n    encoder->Control(VP8E_SET_STATIC_THRESHOLD, 1);\n  }\n\n  superframe_count_++;\n  temporal_layer_id_ = 0;\n  if (number_temporal_layers_ == 2) {\n    temporal_layer_id_ = (superframe_count_ % 2 != 0);\n  } else if (number_temporal_layers_ == 3) {\n    if (superframe_count_ % 2 != 0) temporal_layer_id_ = 2;\n    if (superframe_count_ > 1) {\n      if ((superframe_count_ - 2) % 4 == 0) temporal_layer_id_ = 1;\n    }\n  }\n\n  frame_flags_ = 0;\n}",
          "fn_code_pos": [
            [
              38,
              0
            ],
            [
              72,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OnePassCbrSvc::PreEncodeFrameHookSetup",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void OnePassCbrSvc::PostEncodeFrameHook(::libvpx_test::Encoder *encoder) {\n  vpx_svc_layer_id_t layer_id;\n  encoder->Control(VP9E_GET_SVC_LAYER_ID, &layer_id);\n  temporal_layer_id_ = layer_id.temporal_layer_id;\n  for (int sl = 0; sl < number_spatial_layers_; ++sl) {\n    for (int tl = temporal_layer_id_; tl < number_temporal_layers_; ++tl) {\n      const int layer = sl * number_temporal_layers_ + tl;\n      bits_in_buffer_model_[layer] +=\n          static_cast<int64_t>(layer_target_avg_bandwidth_[layer]);\n    }\n  }\n}",
          "fn_code_pos": [
            [
              74,
              0
            ],
            [
              85,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OnePassCbrSvc::PostEncodeFrameHook",
            "parameters": {
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void OnePassCbrSvc::AssignLayerBitrates() {\n  int sl, spatial_layer_target;\n  int spatial_layers = cfg_.ss_number_layers;\n  int temporal_layers = cfg_.ts_number_layers;\n  float total = 0;\n  float alloc_ratio[VPX_MAX_LAYERS] = { 0 };\n  float framerate = 30.0;\n  for (sl = 0; sl < spatial_layers; ++sl) {\n    if (svc_params_.scaling_factor_den[sl] > 0) {\n      alloc_ratio[sl] =\n          static_cast<float>((svc_params_.scaling_factor_num[sl] * 1.0 /\n                              svc_params_.scaling_factor_den[sl]));\n      total += alloc_ratio[sl];\n    }\n  }\n  for (sl = 0; sl < spatial_layers; ++sl) {\n    cfg_.ss_target_bitrate[sl] = spatial_layer_target =\n        static_cast<unsigned int>(cfg_.rc_target_bitrate * alloc_ratio[sl] /\n                                  total);\n    const int index = sl * temporal_layers;\n    if (cfg_.temporal_layering_mode == 3) {\n      cfg_.layer_target_bitrate[index] = spatial_layer_target >> 1;\n      cfg_.layer_target_bitrate[index + 1] =\n          (spatial_layer_target >> 1) + (spatial_layer_target >> 2);\n      cfg_.layer_target_bitrate[index + 2] = spatial_layer_target;\n    } else if (cfg_.temporal_layering_mode == 2) {\n      cfg_.layer_target_bitrate[index] = spatial_layer_target * 2 / 3;\n      cfg_.layer_target_bitrate[index + 1] = spatial_layer_target;\n    } else if (cfg_.temporal_layering_mode <= 1) {\n      cfg_.layer_target_bitrate[index] = spatial_layer_target;\n    }\n  }\n  for (sl = 0; sl < spatial_layers; ++sl) {\n    for (int tl = 0; tl < temporal_layers; ++tl) {\n      const int layer = sl * temporal_layers + tl;\n      float layer_framerate = framerate;\n      if (temporal_layers == 2 && tl == 0) layer_framerate = framerate / 2;\n      if (temporal_layers == 3 && tl == 0) layer_framerate = framerate / 4;\n      if (temporal_layers == 3 && tl == 1) layer_framerate = framerate / 2;\n      layer_target_avg_bandwidth_[layer] = static_cast<int>(\n          cfg_.layer_target_bitrate[layer] * 1000.0 / layer_framerate);\n      bits_in_buffer_model_[layer] =\n          cfg_.layer_target_bitrate[layer] * cfg_.rc_buf_initial_sz;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              87,
              0
            ],
            [
              132,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OnePassCbrSvc::AssignLayerBitrates",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"test/svc_test.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/blockiness_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "BlockinessTestBase(int width, int height) : width_(width), height_(height) {}",
          "fn_code_pos": [
            [
              35,
              2
            ],
            [
              35,
              79
            ]
          ],
          "class_code": "90e4839d8a892fab77651905de6a8641178d871da036c6baea1b3dc6ac49f00c",
          "class_node_pos": [
            [
              33,
              0
            ],
            [
              138,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BlockinessTestBase",
            "parameters": {
              "width": "int",
              "height": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void SetUpTestCase() {\n    source_data_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kDataBufferSize));\n    reference_data_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kDataBufferSize));\n  }",
          "fn_code_pos": [
            [
              37,
              2
            ],
            [
              42,
              3
            ]
          ],
          "class_code": "90e4839d8a892fab77651905de6a8641178d871da036c6baea1b3dc6ac49f00c",
          "class_node_pos": [
            [
              33,
              0
            ],
            [
              138,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUpTestCase",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void TearDownTestCase() {\n    vpx_free(source_data_);\n    source_data_ = NULL;\n    vpx_free(reference_data_);\n    reference_data_ = NULL;\n  }",
          "fn_code_pos": [
            [
              44,
              2
            ],
            [
              49,
              3
            ]
          ],
          "class_code": "90e4839d8a892fab77651905de6a8641178d871da036c6baea1b3dc6ac49f00c",
          "class_node_pos": [
            [
              33,
              0
            ],
            [
              138,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDownTestCase",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              51,
              2
            ],
            [
              51,
              62
            ]
          ],
          "class_code": "90e4839d8a892fab77651905de6a8641178d871da036c6baea1b3dc6ac49f00c",
          "class_node_pos": [
            [
              33,
              0
            ],
            [
              138,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    source_stride_ = (width_ + 31) & ~31;\n    reference_stride_ = width_ * 2;\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n  }",
          "fn_code_pos": [
            [
              58,
              2
            ],
            [
              62,
              3
            ]
          ],
          "class_code": "90e4839d8a892fab77651905de6a8641178d871da036c6baea1b3dc6ac49f00c",
          "class_node_pos": [
            [
              33,
              0
            ],
            [
              138,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void FillConstant(uint8_t *data, int stride, uint8_t fill_constant, int width,\n                    int height) {\n    for (int h = 0; h < height; ++h) {\n      for (int w = 0; w < width; ++w) {\n        data[h * stride + w] = fill_constant;\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              64,
              2
            ],
            [
              71,
              3
            ]
          ],
          "class_code": "90e4839d8a892fab77651905de6a8641178d871da036c6baea1b3dc6ac49f00c",
          "class_node_pos": [
            [
              33,
              0
            ],
            [
              138,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillConstant",
            "parameters": {
              "data": "uint8_t",
              "stride": "int",
              "fill_constant": "uint8_t",
              "width": "int",
              "height": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void FillConstant(uint8_t *data, int stride, uint8_t fill_constant) {\n    FillConstant(data, stride, fill_constant, width_, height_);\n  }",
          "fn_code_pos": [
            [
              73,
              2
            ],
            [
              75,
              3
            ]
          ],
          "class_code": "90e4839d8a892fab77651905de6a8641178d871da036c6baea1b3dc6ac49f00c",
          "class_node_pos": [
            [
              33,
              0
            ],
            [
              138,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillConstant",
            "parameters": {
              "data": "uint8_t",
              "stride": "int",
              "fill_constant": "uint8_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void FillRandom(uint8_t *data, int stride, int width, int height) {\n    for (int h = 0; h < height; ++h) {\n      for (int w = 0; w < width; ++w) {\n        data[h * stride + w] = rnd_.Rand8();\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              77,
              2
            ],
            [
              83,
              3
            ]
          ],
          "class_code": "90e4839d8a892fab77651905de6a8641178d871da036c6baea1b3dc6ac49f00c",
          "class_node_pos": [
            [
              33,
              0
            ],
            [
              138,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillRandom",
            "parameters": {
              "data": "uint8_t",
              "stride": "int",
              "width": "int",
              "height": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void FillRandom(uint8_t *data, int stride) {\n    FillRandom(data, stride, width_, height_);\n  }",
          "fn_code_pos": [
            [
              85,
              2
            ],
            [
              87,
              3
            ]
          ],
          "class_code": "90e4839d8a892fab77651905de6a8641178d871da036c6baea1b3dc6ac49f00c",
          "class_node_pos": [
            [
              33,
              0
            ],
            [
              138,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillRandom",
            "parameters": {
              "data": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void FillRandomBlocky(uint8_t *data, int stride) {\n    for (int h = 0; h < height_; h += 4) {\n      for (int w = 0; w < width_; w += 4) {\n        FillRandom(data + h * stride + w, stride, 4, 4);\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              89,
              2
            ],
            [
              95,
              3
            ]
          ],
          "class_code": "90e4839d8a892fab77651905de6a8641178d871da036c6baea1b3dc6ac49f00c",
          "class_node_pos": [
            [
              33,
              0
            ],
            [
              138,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillRandomBlocky",
            "parameters": {
              "data": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void FillCheckerboard(uint8_t *data, int stride) {\n    for (int h = 0; h < height_; h += 4) {\n      for (int w = 0; w < width_; w += 4) {\n        if (((h / 4) ^ (w / 4)) & 1) {\n          FillConstant(data + h * stride + w, stride, 255, 4, 4);\n        } else {\n          FillConstant(data + h * stride + w, stride, 0, 4, 4);\n        }\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              97,
              2
            ],
            [
              107,
              3
            ]
          ],
          "class_code": "90e4839d8a892fab77651905de6a8641178d871da036c6baea1b3dc6ac49f00c",
          "class_node_pos": [
            [
              33,
              0
            ],
            [
              138,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillCheckerboard",
            "parameters": {
              "data": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Blur(uint8_t *data, int stride, int taps) {\n    int sum = 0;\n    int half_taps = taps / 2;\n    for (int h = 0; h < height_; ++h) {\n      for (int w = 0; w < taps; ++w) {\n        sum += data[w + h * stride];\n      }\n      for (int w = taps; w < width_; ++w) {\n        sum += data[w + h * stride] - data[w - taps + h * stride];\n        data[w - half_taps + h * stride] = (sum + half_taps) / taps;\n      }\n    }\n    for (int w = 0; w < width_; ++w) {\n      for (int h = 0; h < taps; ++h) {\n        sum += data[h + w * stride];\n      }\n      for (int h = taps; h < height_; ++h) {\n        sum += data[w + h * stride] - data[(h - taps) * stride + w];\n        data[(h - half_taps) * stride + w] = (sum + half_taps) / taps;\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              109,
              2
            ],
            [
              130,
              3
            ]
          ],
          "class_code": "90e4839d8a892fab77651905de6a8641178d871da036c6baea1b3dc6ac49f00c",
          "class_node_pos": [
            [
              33,
              0
            ],
            [
              138,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Blur",
            "parameters": {
              "data": "uint8_t",
              "stride": "int",
              "taps": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "BlockinessVP9Test() : BlockinessTestBase(GET_PARAM(0), GET_PARAM(1)) {}",
          "fn_code_pos": [
            [
              146,
              2
            ],
            [
              146,
              73
            ]
          ],
          "class_code": "6c7f581f346ae2a1fc84ab4669d488b114a084b864de1cc28417ea4e70847e9b",
          "class_node_pos": [
            [
              142,
              0
            ],
            [
              153,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BlockinessVP9Test",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "double GetBlockiness() const {\n    return vp9_get_blockiness(source_data_, source_stride_, reference_data_,\n                              reference_stride_, width_, height_);\n  }",
          "fn_code_pos": [
            [
              149,
              2
            ],
            [
              152,
              3
            ]
          ],
          "class_code": "6c7f581f346ae2a1fc84ab4669d488b114a084b864de1cc28417ea4e70847e9b",
          "class_node_pos": [
            [
              142,
              0
            ],
            [
              153,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetBlockiness",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "TEST_P(BlockinessVP9Test, SourceBlockierThanReference) {\n  // Source is blockier than reference.\n  FillRandomBlocky(source_data_, source_stride_);\n  FillConstant(reference_data_, reference_stride_, 128);\n  const double super_blocky = GetBlockiness();\n\n  EXPECT_DOUBLE_EQ(0.0, super_blocky)\n      << \"Blocky source should produce 0 blockiness.\";\n}",
          "fn_code_pos": [
            [
              160,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(BlockinessVP9Test, ReferenceBlockierThanSource) {\n  // Source is blockier than reference.\n  FillConstant(source_data_, source_stride_, 128);\n  FillRandomBlocky(reference_data_, reference_stride_);\n  const double super_blocky = GetBlockiness();\n\n  EXPECT_GT(super_blocky, 0.0)\n      << \"Blocky reference should score high for blockiness.\";\n}",
          "fn_code_pos": [
            [
              170,
              0
            ],
            [
              178,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(BlockinessVP9Test, BlurringDecreasesBlockiness) {\n  // Source is blockier than reference.\n  FillConstant(source_data_, source_stride_, 128);\n  FillRandomBlocky(reference_data_, reference_stride_);\n  const double super_blocky = GetBlockiness();\n\n  Blur(reference_data_, reference_stride_, 4);\n  const double less_blocky = GetBlockiness();\n\n  EXPECT_GT(super_blocky, less_blocky)\n      << \"A straight blur should decrease blockiness.\";\n}",
          "fn_code_pos": [
            [
              180,
              0
            ],
            [
              191,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(BlockinessVP9Test, WorstCaseBlockiness) {\n  // Source is blockier than reference.\n  FillConstant(source_data_, source_stride_, 128);\n  FillCheckerboard(reference_data_, reference_stride_);\n\n  const double super_blocky = GetBlockiness();\n\n  Blur(reference_data_, reference_stride_, 4);\n  const double less_blocky = GetBlockiness();\n\n  EXPECT_GT(super_blocky, less_blocky)\n      << \"A straight blur should decrease blockiness.\";\n}",
          "fn_code_pos": [
            [
              193,
              0
            ],
            [
              205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "90e4839d8a892fab77651905de6a8641178d871da036c6baea1b3dc6ac49f00c": {
          "class_code": "class BlockinessTestBase : public ::testing::Test {\n public:\n  BlockinessTestBase(int width, int height) : width_(width), height_(height) {}\n\n  static void SetUpTestCase() {\n    source_data_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kDataBufferSize));\n    reference_data_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kDataBufferSize));\n  }\n\n  static void TearDownTestCase() {\n    vpx_free(source_data_);\n    source_data_ = NULL;\n    vpx_free(reference_data_);\n    reference_data_ = NULL;\n  }\n\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  // Handle frames up to 640x480\n  static const int kDataAlignment = 16;\n  static const int kDataBufferSize = 640 * 480;\n\n  virtual void SetUp() {\n    source_stride_ = (width_ + 31) & ~31;\n    reference_stride_ = width_ * 2;\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n  }\n\n  void FillConstant(uint8_t *data, int stride, uint8_t fill_constant, int width,\n                    int height) {\n    for (int h = 0; h < height; ++h) {\n      for (int w = 0; w < width; ++w) {\n        data[h * stride + w] = fill_constant;\n      }\n    }\n  }\n\n  void FillConstant(uint8_t *data, int stride, uint8_t fill_constant) {\n    FillConstant(data, stride, fill_constant, width_, height_);\n  }\n\n  void FillRandom(uint8_t *data, int stride, int width, int height) {\n    for (int h = 0; h < height; ++h) {\n      for (int w = 0; w < width; ++w) {\n        data[h * stride + w] = rnd_.Rand8();\n      }\n    }\n  }\n\n  void FillRandom(uint8_t *data, int stride) {\n    FillRandom(data, stride, width_, height_);\n  }\n\n  void FillRandomBlocky(uint8_t *data, int stride) {\n    for (int h = 0; h < height_; h += 4) {\n      for (int w = 0; w < width_; w += 4) {\n        FillRandom(data + h * stride + w, stride, 4, 4);\n      }\n    }\n  }\n\n  void FillCheckerboard(uint8_t *data, int stride) {\n    for (int h = 0; h < height_; h += 4) {\n      for (int w = 0; w < width_; w += 4) {\n        if (((h / 4) ^ (w / 4)) & 1) {\n          FillConstant(data + h * stride + w, stride, 255, 4, 4);\n        } else {\n          FillConstant(data + h * stride + w, stride, 0, 4, 4);\n        }\n      }\n    }\n  }\n\n  void Blur(uint8_t *data, int stride, int taps) {\n    int sum = 0;\n    int half_taps = taps / 2;\n    for (int h = 0; h < height_; ++h) {\n      for (int w = 0; w < taps; ++w) {\n        sum += data[w + h * stride];\n      }\n      for (int w = taps; w < width_; ++w) {\n        sum += data[w + h * stride] - data[w - taps + h * stride];\n        data[w - half_taps + h * stride] = (sum + half_taps) / taps;\n      }\n    }\n    for (int w = 0; w < width_; ++w) {\n      for (int h = 0; h < taps; ++h) {\n        sum += data[h + w * stride];\n      }\n      for (int h = taps; h < height_; ++h) {\n        sum += data[w + h * stride] - data[(h - taps) * stride + w];\n        data[(h - half_taps) * stride + w] = (sum + half_taps) / taps;\n      }\n    }\n  }\n  int width_, height_;\n  static uint8_t *source_data_;\n  int source_stride_;\n  static uint8_t *reference_data_;\n  int reference_stride_;\n\n  ACMRandom rnd_;\n}",
          "class_name": "BlockinessTestBase",
          "class_pos": [
            [
              33,
              0
            ],
            [
              138,
              1
            ]
          ]
        },
        "6c7f581f346ae2a1fc84ab4669d488b114a084b864de1cc28417ea4e70847e9b": {
          "class_code": "class BlockinessVP9Test\n    : public BlockinessTestBase,\n      public ::testing::WithParamInterface<BlockinessParam> {\n public:\n  BlockinessVP9Test() : BlockinessTestBase(GET_PARAM(0), GET_PARAM(1)) {}\n\n protected:\n  double GetBlockiness() const {\n    return vp9_get_blockiness(source_data_, source_stride_, reference_data_,\n                              reference_stride_, width_, height_);\n  }\n}",
          "class_name": "BlockinessVP9Test",
          "class_pos": [
            [
              142,
              0
            ],
            [
              153,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <limits.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"./vp9_rtcd.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"vp9/encoder/vp9_blockiness.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/dct_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "template <FdctFunc fn>\nvoid fdct_wrapper(const int16_t *in, tran_low_t *out, int stride, int tx_type) {\n  (void)tx_type;\n  fn(in, out, stride);\n}",
          "fn_code_pos": [
            [
              46,
              0
            ],
            [
              50,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <IdctFunc fn>\nvoid idct_wrapper(const tran_low_t *in, uint8_t *out, int stride, int tx_type,\n                  int bd) {\n  (void)tx_type;\n  (void)bd;\n  fn(in, out, stride);\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              58,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <IhtFunc fn>\nvoid iht_wrapper(const tran_low_t *in, uint8_t *out, int stride, int tx_type,\n                 int bd) {\n  (void)bd;\n  fn(in, out, stride, tx_type);\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <HighbdIdctFunc fn>\nvoid highbd_idct_wrapper(const tran_low_t *in, uint8_t *out, int stride,\n                         int tx_type, int bd) {\n  (void)tx_type;\n  fn(in, CAST_TO_SHORTPTR(out), stride, bd);\n}",
          "fn_code_pos": [
            [
              74,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <HighbdIhtFunc fn>\nvoid highbd_iht_wrapper(const tran_low_t *in, uint8_t *out, int stride,\n                        int tx_type, int bd) {\n  fn(in, CAST_TO_SHORTPTR(out), stride, tx_type, bd);\n}",
          "fn_code_pos": [
            [
              81,
              0
            ],
            [
              85,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void fdct_ref(const Buffer<int16_t> &in, Buffer<tran_low_t> *out, int size,\n              int /*tx_type*/) {\n  const int16_t *i = in.TopLeftPixel();\n  const int i_stride = in.stride();\n  tran_low_t *o = out->TopLeftPixel();\n  if (size == 4) {\n    vpx_fdct4x4_c(i, o, i_stride);\n  } else if (size == 8) {\n    vpx_fdct8x8_c(i, o, i_stride);\n  } else if (size == 16) {\n    vpx_fdct16x16_c(i, o, i_stride);\n  } else if (size == 32) {\n    vpx_fdct32x32_c(i, o, i_stride);\n  }\n}",
          "fn_code_pos": [
            [
              98,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fdct_ref",
            "parameters": {
              "in": "Buffer<int16_t>",
              "out": "Buffer<tran_low_t>",
              "size": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void fht_ref(const Buffer<int16_t> &in, Buffer<tran_low_t> *out, int size,\n             int tx_type) {\n  const int16_t *i = in.TopLeftPixel();\n  const int i_stride = in.stride();\n  tran_low_t *o = out->TopLeftPixel();\n  if (size == 4) {\n    vp9_fht4x4_c(i, o, i_stride, tx_type);\n  } else if (size == 8) {\n    vp9_fht8x8_c(i, o, i_stride, tx_type);\n  } else if (size == 16) {\n    vp9_fht16x16_c(i, o, i_stride, tx_type);\n  }\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              126,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fht_ref",
            "parameters": {
              "in": "Buffer<int16_t>",
              "out": "Buffer<tran_low_t>",
              "size": "int",
              "tx_type": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void fwht_ref(const Buffer<int16_t> &in, Buffer<tran_low_t> *out, int size,\n              int /*tx_type*/) {\n  ASSERT_EQ(size, 4);\n  vp9_fwht4x4_c(in.TopLeftPixel(), out->TopLeftPixel(), in.stride());\n}",
          "fn_code_pos": [
            [
              128,
              0
            ],
            [
              132,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fwht_ref",
            "parameters": {
              "in": "Buffer<int16_t>",
              "out": "Buffer<tran_low_t>",
              "size": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n    const int idx = GET_PARAM(0);\n    const FuncInfo *func_info = &(GET_PARAM(1)[idx]);\n    tx_type_ = GET_PARAM(2);\n    bit_depth_ = GET_PARAM(3);\n    fwd_txfm_ = func_info->ft_func;\n    inv_txfm_ = func_info->it_func;\n    size_ = func_info->size;\n    pixel_size_ = func_info->pixel_size;\n    max_pixel_value_ = (1 << bit_depth_) - 1;\n\n    // Randomize stride_ to a value less than or equal to 1024\n    stride_ = rnd_(1024) + 1;\n    if (stride_ < size_) {\n      stride_ = size_;\n    }\n    // Align stride_ to 16 if it's bigger than 16.\n    if (stride_ > 16) {\n      stride_ &= ~15;\n    }\n\n    block_size_ = size_ * stride_;\n\n    src_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(16, pixel_size_ * block_size_));\n    ASSERT_TRUE(src_ != NULL);\n    dst_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(16, pixel_size_ * block_size_));\n    ASSERT_TRUE(dst_ != NULL);\n  }",
          "fn_code_pos": [
            [
              136,
              2
            ],
            [
              166,
              3
            ]
          ],
          "class_code": "d76a917b35fc5cca00579d327b72861f57c4d48687f603bba13424dc0135c666",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              431,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() {\n    vpx_free(src_);\n    src_ = NULL;\n    vpx_free(dst_);\n    dst_ = NULL;\n    libvpx_test::ClearSystemState();\n  }",
          "fn_code_pos": [
            [
              168,
              2
            ],
            [
              174,
              3
            ]
          ],
          "class_code": "d76a917b35fc5cca00579d327b72861f57c4d48687f603bba13424dc0135c666",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              431,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void InitMem() {\n    if (pixel_size_ == 1 && bit_depth_ > VPX_BITS_8) return;\n    if (pixel_size_ == 1) {\n      for (int j = 0; j < block_size_; ++j) {\n        src_[j] = rnd_.Rand16() & max_pixel_value_;\n      }\n      for (int j = 0; j < block_size_; ++j) {\n        dst_[j] = rnd_.Rand16() & max_pixel_value_;\n      }\n    } else {\n      ASSERT_EQ(pixel_size_, 2);\n      uint16_t *const src = reinterpret_cast<uint16_t *>(src_);\n      uint16_t *const dst = reinterpret_cast<uint16_t *>(dst_);\n      for (int j = 0; j < block_size_; ++j) {\n        src[j] = rnd_.Rand16() & max_pixel_value_;\n      }\n      for (int j = 0; j < block_size_; ++j) {\n        dst[j] = rnd_.Rand16() & max_pixel_value_;\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              176,
              2
            ],
            [
              196,
              3
            ]
          ],
          "class_code": "d76a917b35fc5cca00579d327b72861f57c4d48687f603bba13424dc0135c666",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              431,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "InitMem",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunFwdTxfm(const Buffer<int16_t> &in, Buffer<tran_low_t> *out) {\n    fwd_txfm_(in.TopLeftPixel(), out->TopLeftPixel(), in.stride(), tx_type_);\n  }",
          "fn_code_pos": [
            [
              198,
              2
            ],
            [
              200,
              3
            ]
          ],
          "class_code": "d76a917b35fc5cca00579d327b72861f57c4d48687f603bba13424dc0135c666",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              431,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunFwdTxfm",
            "parameters": {
              "in": "Buffer<int16_t>",
              "out": "Buffer<tran_low_t>"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunInvTxfm(const Buffer<tran_low_t> &in, uint8_t *out) {\n    inv_txfm_(in.TopLeftPixel(), out, stride_, tx_type_, bit_depth_);\n  }",
          "fn_code_pos": [
            [
              202,
              2
            ],
            [
              204,
              3
            ]
          ],
          "class_code": "d76a917b35fc5cca00579d327b72861f57c4d48687f603bba13424dc0135c666",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              431,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunInvTxfm",
            "parameters": {
              "in": "Buffer<tran_low_t>",
              "out": "uint8_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunAccuracyCheck(int limit) {\n    if (pixel_size_ == 1 && bit_depth_ > VPX_BITS_8) return;\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    Buffer<int16_t> test_input_block =\n        Buffer<int16_t>(size_, size_, 8, size_ == 4 ? 0 : 16);\n    ASSERT_TRUE(test_input_block.Init());\n    ASSERT_TRUE(test_input_block.TopLeftPixel() != NULL);\n    Buffer<tran_low_t> test_temp_block =\n        Buffer<tran_low_t>(size_, size_, 0, 16);\n    ASSERT_TRUE(test_temp_block.Init());\n    uint32_t max_error = 0;\n    int64_t total_error = 0;\n    const int count_test_block = 10000;\n    for (int i = 0; i < count_test_block; ++i) {\n      InitMem();\n      for (int h = 0; h < size_; ++h) {\n        for (int w = 0; w < size_; ++w) {\n          if (pixel_size_ == 1) {\n            test_input_block.TopLeftPixel()[h * test_input_block.stride() + w] =\n                src_[h * stride_ + w] - dst_[h * stride_ + w];\n          } else {\n            ASSERT_EQ(pixel_size_, 2);\n            const uint16_t *const src = reinterpret_cast<uint16_t *>(src_);\n            const uint16_t *const dst = reinterpret_cast<uint16_t *>(dst_);\n            test_input_block.TopLeftPixel()[h * test_input_block.stride() + w] =\n                src[h * stride_ + w] - dst[h * stride_ + w];\n          }\n        }\n      }\n\n      ASM_REGISTER_STATE_CHECK(RunFwdTxfm(test_input_block, &test_temp_block));\n      ASM_REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst_));\n\n      for (int h = 0; h < size_; ++h) {\n        for (int w = 0; w < size_; ++w) {\n          int diff;\n          if (pixel_size_ == 1) {\n            diff = dst_[h * stride_ + w] - src_[h * stride_ + w];\n          } else {\n            ASSERT_EQ(pixel_size_, 2);\n            const uint16_t *const src = reinterpret_cast<uint16_t *>(src_);\n            const uint16_t *const dst = reinterpret_cast<uint16_t *>(dst_);\n            diff = dst[h * stride_ + w] - src[h * stride_ + w];\n          }\n          const uint32_t error = diff * diff;\n          if (max_error < error) max_error = error;\n          total_error += error;\n        }\n      }\n    }\n\n    EXPECT_GE(static_cast<uint32_t>(limit), max_error)\n        << \"Error: \" << size_ << \"x\" << size_\n        << \" transform/inverse transform has an individual round trip error > \"\n        << limit;\n\n    EXPECT_GE(count_test_block * limit, total_error)\n        << \"Error: \" << size_ << \"x\" << size_\n        << \" transform/inverse transform has average round trip error > \"\n        << limit << \" per block\";\n  }",
          "fn_code_pos": [
            [
              207,
              2
            ],
            [
              267,
              3
            ]
          ],
          "class_code": "d76a917b35fc5cca00579d327b72861f57c4d48687f603bba13424dc0135c666",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              431,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunAccuracyCheck",
            "parameters": {
              "limit": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunCoeffCheck() {\n    if (pixel_size_ == 1 && bit_depth_ > VPX_BITS_8) return;\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 5000;\n    Buffer<int16_t> input_block =\n        Buffer<int16_t>(size_, size_, 8, size_ == 4 ? 0 : 16);\n    ASSERT_TRUE(input_block.Init());\n    Buffer<tran_low_t> output_ref_block = Buffer<tran_low_t>(size_, size_, 0);\n    ASSERT_TRUE(output_ref_block.Init());\n    Buffer<tran_low_t> output_block = Buffer<tran_low_t>(size_, size_, 0, 16);\n    ASSERT_TRUE(output_block.Init());\n\n    for (int i = 0; i < count_test_block; ++i) {\n      // Initialize a test block with input range [-max_pixel_value_,\n      // max_pixel_value_].\n      input_block.Set(&rnd, -max_pixel_value_, max_pixel_value_);\n\n      fwd_txfm_ref(input_block, &output_ref_block, size_, tx_type_);\n      ASM_REGISTER_STATE_CHECK(RunFwdTxfm(input_block, &output_block));\n\n      // The minimum quant value is 4.\n      EXPECT_TRUE(output_block.CheckValues(output_ref_block));\n      if (::testing::Test::HasFailure()) {\n        printf(\"Size: %d Transform type: %d\\n\", size_, tx_type_);\n        output_block.PrintDifference(output_ref_block);\n        return;\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              269,
              2
            ],
            [
              297,
              3
            ]
          ],
          "class_code": "d76a917b35fc5cca00579d327b72861f57c4d48687f603bba13424dc0135c666",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              431,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunCoeffCheck",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunMemCheck() {\n    if (pixel_size_ == 1 && bit_depth_ > VPX_BITS_8) return;\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 5000;\n    Buffer<int16_t> input_extreme_block =\n        Buffer<int16_t>(size_, size_, 8, size_ == 4 ? 0 : 16);\n    ASSERT_TRUE(input_extreme_block.Init());\n    Buffer<tran_low_t> output_ref_block = Buffer<tran_low_t>(size_, size_, 0);\n    ASSERT_TRUE(output_ref_block.Init());\n    Buffer<tran_low_t> output_block = Buffer<tran_low_t>(size_, size_, 0, 16);\n    ASSERT_TRUE(output_block.Init());\n\n    for (int i = 0; i < count_test_block; ++i) {\n      // Initialize a test block with -max_pixel_value_ or max_pixel_value_.\n      if (i == 0) {\n        input_extreme_block.Set(max_pixel_value_);\n      } else if (i == 1) {\n        input_extreme_block.Set(-max_pixel_value_);\n      } else {\n        ASSERT_TRUE(input_extreme_block.TopLeftPixel() != NULL);\n        for (int h = 0; h < size_; ++h) {\n          for (int w = 0; w < size_; ++w) {\n            input_extreme_block\n                .TopLeftPixel()[h * input_extreme_block.stride() + w] =\n                rnd.Rand8() % 2 ? max_pixel_value_ : -max_pixel_value_;\n          }\n        }\n      }\n\n      fwd_txfm_ref(input_extreme_block, &output_ref_block, size_, tx_type_);\n      ASM_REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block, &output_block));\n\n      // The minimum quant value is 4.\n      EXPECT_TRUE(output_block.CheckValues(output_ref_block));\n      ASSERT_TRUE(output_block.TopLeftPixel() != NULL);\n      for (int h = 0; h < size_; ++h) {\n        for (int w = 0; w < size_; ++w) {\n          EXPECT_GE(\n              4 * DCT_MAX_VALUE << (bit_depth_ - 8),\n              abs(output_block.TopLeftPixel()[h * output_block.stride() + w]))\n              << \"Error: \" << size_ << \"x\" << size_\n              << \" transform has coefficient larger than 4*DCT_MAX_VALUE\"\n              << \" at \" << w << \",\" << h;\n          if (::testing::Test::HasFailure()) {\n            printf(\"Size: %d Transform type: %d\\n\", size_, tx_type_);\n            output_block.DumpBuffer();\n            return;\n          }\n        }\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              299,
              2
            ],
            [
              350,
              3
            ]
          ],
          "class_code": "d76a917b35fc5cca00579d327b72861f57c4d48687f603bba13424dc0135c666",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              431,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunMemCheck",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunInvAccuracyCheck(int limit) {\n    if (pixel_size_ == 1 && bit_depth_ > VPX_BITS_8) return;\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 1000;\n    Buffer<int16_t> in = Buffer<int16_t>(size_, size_, 4);\n    ASSERT_TRUE(in.Init());\n    Buffer<tran_low_t> coeff = Buffer<tran_low_t>(size_, size_, 0, 16);\n    ASSERT_TRUE(coeff.Init());\n    Buffer<uint8_t> dst = Buffer<uint8_t>(size_, size_, 0, 16);\n    ASSERT_TRUE(dst.Init());\n    Buffer<uint8_t> src = Buffer<uint8_t>(size_, size_, 0);\n    ASSERT_TRUE(src.Init());\n    Buffer<uint16_t> dst16 = Buffer<uint16_t>(size_, size_, 0, 16);\n    ASSERT_TRUE(dst16.Init());\n    Buffer<uint16_t> src16 = Buffer<uint16_t>(size_, size_, 0);\n    ASSERT_TRUE(src16.Init());\n\n    for (int i = 0; i < count_test_block; ++i) {\n      InitMem();\n      ASSERT_TRUE(in.TopLeftPixel() != NULL);\n      // Initialize a test block with input range [-max_pixel_value_,\n      // max_pixel_value_].\n      for (int h = 0; h < size_; ++h) {\n        for (int w = 0; w < size_; ++w) {\n          if (pixel_size_ == 1) {\n            in.TopLeftPixel()[h * in.stride() + w] =\n                src_[h * stride_ + w] - dst_[h * stride_ + w];\n          } else {\n            ASSERT_EQ(pixel_size_, 2);\n            const uint16_t *const src = reinterpret_cast<uint16_t *>(src_);\n            const uint16_t *const dst = reinterpret_cast<uint16_t *>(dst_);\n            in.TopLeftPixel()[h * in.stride() + w] =\n                src[h * stride_ + w] - dst[h * stride_ + w];\n          }\n        }\n      }\n\n      fwd_txfm_ref(in, &coeff, size_, tx_type_);\n\n      ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst_));\n\n      for (int h = 0; h < size_; ++h) {\n        for (int w = 0; w < size_; ++w) {\n          int diff;\n          if (pixel_size_ == 1) {\n            diff = dst_[h * stride_ + w] - src_[h * stride_ + w];\n          } else {\n            ASSERT_EQ(pixel_size_, 2);\n            const uint16_t *const src = reinterpret_cast<uint16_t *>(src_);\n            const uint16_t *const dst = reinterpret_cast<uint16_t *>(dst_);\n            diff = dst[h * stride_ + w] - src[h * stride_ + w];\n          }\n          const uint32_t error = diff * diff;\n          EXPECT_GE(static_cast<uint32_t>(limit), error)\n              << \"Error: \" << size_ << \"x\" << size_\n              << \" inverse transform has error \" << error << \" at \" << w << \",\"\n              << h;\n          if (::testing::Test::HasFailure()) {\n            printf(\"Size: %d Transform type: %d\\n\", size_, tx_type_);\n            return;\n          }\n        }\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              352,
              2
            ],
            [
              416,
              3
            ]
          ],
          "class_code": "d76a917b35fc5cca00579d327b72861f57c4d48687f603bba13424dc0135c666",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              431,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunInvAccuracyCheck",
            "parameters": {
              "limit": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TransDCT() { fwd_txfm_ref = fdct_ref; }",
          "fn_code_pos": [
            [
              437,
              2
            ],
            [
              437,
              41
            ]
          ],
          "class_code": "cf251419ee2151d0dfad90824c0e6e09fc821b778c78a18d699a74c106c1d4ba",
          "class_node_pos": [
            [
              435,
              0
            ],
            [
              438,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TransDCT",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(TransDCT, AccuracyCheck) {\n  int t = 1;\n  if (size_ == 16 && bit_depth_ > 10 && pixel_size_ == 2) {\n    t = 2;\n  } else if (size_ == 32 && bit_depth_ > 10 && pixel_size_ == 2) {\n    t = 7;\n  }\n  RunAccuracyCheck(t);\n}",
          "fn_code_pos": [
            [
              440,
              0
            ],
            [
              448,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(TransDCT, CoeffCheck) { RunCoeffCheck(); }",
          "fn_code_pos": [
            [
              450,
              0
            ],
            [
              450,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(TransDCT, MemCheck) { RunMemCheck(); }",
          "fn_code_pos": [
            [
              452,
              0
            ],
            [
              452,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(TransDCT, InvAccuracyCheck) { RunInvAccuracyCheck(1); }",
          "fn_code_pos": [
            [
              454,
              0
            ],
            [
              454,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TransHT() { fwd_txfm_ref = fht_ref; }",
          "fn_code_pos": [
            [
              594,
              2
            ],
            [
              594,
              39
            ]
          ],
          "class_code": "fba2c5e2c2c8a7b5a10e043bba817174cbfdc89cba1bea63806cea3d498fe35a",
          "class_node_pos": [
            [
              592,
              0
            ],
            [
              595,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TransHT",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(TransHT, AccuracyCheck) {\n  RunAccuracyCheck(size_ == 16 && bit_depth_ > 10 && pixel_size_ == 2 ? 2 : 1);\n}",
          "fn_code_pos": [
            [
              597,
              0
            ],
            [
              599,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(TransHT, CoeffCheck) { RunCoeffCheck(); }",
          "fn_code_pos": [
            [
              601,
              0
            ],
            [
              601,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(TransHT, MemCheck) { RunMemCheck(); }",
          "fn_code_pos": [
            [
              603,
              0
            ],
            [
              603,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(TransHT, InvAccuracyCheck) { RunInvAccuracyCheck(1); }",
          "fn_code_pos": [
            [
              605,
              0
            ],
            [
              605,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TransWHT() { fwd_txfm_ref = fwht_ref; }",
          "fn_code_pos": [
            [
              709,
              2
            ],
            [
              709,
              41
            ]
          ],
          "class_code": "2177ccf9f92c009c43bb2e9fa9ce1d60c1f06f761c707b2d76c5819d2365ee5b",
          "class_node_pos": [
            [
              707,
              0
            ],
            [
              710,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TransWHT",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(TransWHT, AccuracyCheck) { RunAccuracyCheck(0); }",
          "fn_code_pos": [
            [
              712,
              0
            ],
            [
              712,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(TransWHT, CoeffCheck) { RunCoeffCheck(); }",
          "fn_code_pos": [
            [
              714,
              0
            ],
            [
              714,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(TransWHT, MemCheck) { RunMemCheck(); }",
          "fn_code_pos": [
            [
              716,
              0
            ],
            [
              716,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(TransWHT, InvAccuracyCheck) { RunInvAccuracyCheck(0); }",
          "fn_code_pos": [
            [
              718,
              0
            ],
            [
              718,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*FdctFunc)(const int16_t *in, tran_low_t *out, int stride)",
          "fn_dec_pos": [
            [
              35,
              13
            ],
            [
              35,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "int16_t",
              "out": "tran_low_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*IdctFunc)(const tran_low_t *in, uint8_t *out, int stride)",
          "fn_dec_pos": [
            [
              36,
              13
            ],
            [
              36,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*FhtFunc)(const int16_t *in, tran_low_t *out, int stride,\n                        int tx_type)",
          "fn_dec_pos": [
            [
              37,
              13
            ],
            [
              38,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "int16_t",
              "out": "tran_low_t",
              "stride": "int",
              "tx_type": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*FhtFuncRef)(const Buffer<int16_t> &in, Buffer<tran_low_t> *out,\n                           int size, int tx_type)",
          "fn_dec_pos": [
            [
              39,
              13
            ],
            [
              40,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "Buffer<int16_t>",
              "out": "Buffer<tran_low_t>",
              "size": "int",
              "tx_type": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*IhtFunc)(const tran_low_t *in, uint8_t *out, int stride,\n                        int tx_type)",
          "fn_dec_pos": [
            [
              41,
              13
            ],
            [
              42,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int",
              "tx_type": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*IhtWithBdFunc)(const tran_low_t *in, uint8_t *out, int stride,\n                              int tx_type, int bd)",
          "fn_dec_pos": [
            [
              43,
              13
            ],
            [
              44,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int",
              "tx_type": "int",
              "bd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*HighbdIdctFunc)(const tran_low_t *in, uint16_t *out, int stride,\n                               int bd)",
          "fn_dec_pos": [
            [
              68,
              13
            ],
            [
              69,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint16_t",
              "stride": "int",
              "bd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*HighbdIhtFunc)(const tran_low_t *in, uint16_t *out, int stride,\n                              int tx_type, int bd)",
          "fn_dec_pos": [
            [
              71,
              13
            ],
            [
              72,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint16_t",
              "stride": "int",
              "tx_type": "int",
              "bd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              209,
              14
            ],
            [
              209,
              49
            ]
          ],
          "class_code": "d76a917b35fc5cca00579d327b72861f57c4d48687f603bba13424dc0135c666",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              431,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              271,
              14
            ],
            [
              271,
              49
            ]
          ],
          "class_code": "d76a917b35fc5cca00579d327b72861f57c4d48687f603bba13424dc0135c666",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              431,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              301,
              14
            ],
            [
              301,
              49
            ]
          ],
          "class_code": "d76a917b35fc5cca00579d327b72861f57c4d48687f603bba13424dc0135c666",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              431,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              354,
              14
            ],
            [
              354,
              49
            ]
          ],
          "class_code": "d76a917b35fc5cca00579d327b72861f57c4d48687f603bba13424dc0135c666",
          "class_node_pos": [
            [
              134,
              0
            ],
            [
              431,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        }
      ],
      "class_node_list": {
        "d76a917b35fc5cca00579d327b72861f57c4d48687f603bba13424dc0135c666": {
          "class_code": "class TransTestBase : public ::testing::TestWithParam<DctParam> {\n public:\n  virtual void SetUp() {\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n    const int idx = GET_PARAM(0);\n    const FuncInfo *func_info = &(GET_PARAM(1)[idx]);\n    tx_type_ = GET_PARAM(2);\n    bit_depth_ = GET_PARAM(3);\n    fwd_txfm_ = func_info->ft_func;\n    inv_txfm_ = func_info->it_func;\n    size_ = func_info->size;\n    pixel_size_ = func_info->pixel_size;\n    max_pixel_value_ = (1 << bit_depth_) - 1;\n\n    // Randomize stride_ to a value less than or equal to 1024\n    stride_ = rnd_(1024) + 1;\n    if (stride_ < size_) {\n      stride_ = size_;\n    }\n    // Align stride_ to 16 if it's bigger than 16.\n    if (stride_ > 16) {\n      stride_ &= ~15;\n    }\n\n    block_size_ = size_ * stride_;\n\n    src_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(16, pixel_size_ * block_size_));\n    ASSERT_TRUE(src_ != NULL);\n    dst_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(16, pixel_size_ * block_size_));\n    ASSERT_TRUE(dst_ != NULL);\n  }\n\n  virtual void TearDown() {\n    vpx_free(src_);\n    src_ = NULL;\n    vpx_free(dst_);\n    dst_ = NULL;\n    libvpx_test::ClearSystemState();\n  }\n\n  void InitMem() {\n    if (pixel_size_ == 1 && bit_depth_ > VPX_BITS_8) return;\n    if (pixel_size_ == 1) {\n      for (int j = 0; j < block_size_; ++j) {\n        src_[j] = rnd_.Rand16() & max_pixel_value_;\n      }\n      for (int j = 0; j < block_size_; ++j) {\n        dst_[j] = rnd_.Rand16() & max_pixel_value_;\n      }\n    } else {\n      ASSERT_EQ(pixel_size_, 2);\n      uint16_t *const src = reinterpret_cast<uint16_t *>(src_);\n      uint16_t *const dst = reinterpret_cast<uint16_t *>(dst_);\n      for (int j = 0; j < block_size_; ++j) {\n        src[j] = rnd_.Rand16() & max_pixel_value_;\n      }\n      for (int j = 0; j < block_size_; ++j) {\n        dst[j] = rnd_.Rand16() & max_pixel_value_;\n      }\n    }\n  }\n\n  void RunFwdTxfm(const Buffer<int16_t> &in, Buffer<tran_low_t> *out) {\n    fwd_txfm_(in.TopLeftPixel(), out->TopLeftPixel(), in.stride(), tx_type_);\n  }\n\n  void RunInvTxfm(const Buffer<tran_low_t> &in, uint8_t *out) {\n    inv_txfm_(in.TopLeftPixel(), out, stride_, tx_type_, bit_depth_);\n  }\n\n protected:\n  void RunAccuracyCheck(int limit) {\n    if (pixel_size_ == 1 && bit_depth_ > VPX_BITS_8) return;\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    Buffer<int16_t> test_input_block =\n        Buffer<int16_t>(size_, size_, 8, size_ == 4 ? 0 : 16);\n    ASSERT_TRUE(test_input_block.Init());\n    ASSERT_TRUE(test_input_block.TopLeftPixel() != NULL);\n    Buffer<tran_low_t> test_temp_block =\n        Buffer<tran_low_t>(size_, size_, 0, 16);\n    ASSERT_TRUE(test_temp_block.Init());\n    uint32_t max_error = 0;\n    int64_t total_error = 0;\n    const int count_test_block = 10000;\n    for (int i = 0; i < count_test_block; ++i) {\n      InitMem();\n      for (int h = 0; h < size_; ++h) {\n        for (int w = 0; w < size_; ++w) {\n          if (pixel_size_ == 1) {\n            test_input_block.TopLeftPixel()[h * test_input_block.stride() + w] =\n                src_[h * stride_ + w] - dst_[h * stride_ + w];\n          } else {\n            ASSERT_EQ(pixel_size_, 2);\n            const uint16_t *const src = reinterpret_cast<uint16_t *>(src_);\n            const uint16_t *const dst = reinterpret_cast<uint16_t *>(dst_);\n            test_input_block.TopLeftPixel()[h * test_input_block.stride() + w] =\n                src[h * stride_ + w] - dst[h * stride_ + w];\n          }\n        }\n      }\n\n      ASM_REGISTER_STATE_CHECK(RunFwdTxfm(test_input_block, &test_temp_block));\n      ASM_REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst_));\n\n      for (int h = 0; h < size_; ++h) {\n        for (int w = 0; w < size_; ++w) {\n          int diff;\n          if (pixel_size_ == 1) {\n            diff = dst_[h * stride_ + w] - src_[h * stride_ + w];\n          } else {\n            ASSERT_EQ(pixel_size_, 2);\n            const uint16_t *const src = reinterpret_cast<uint16_t *>(src_);\n            const uint16_t *const dst = reinterpret_cast<uint16_t *>(dst_);\n            diff = dst[h * stride_ + w] - src[h * stride_ + w];\n          }\n          const uint32_t error = diff * diff;\n          if (max_error < error) max_error = error;\n          total_error += error;\n        }\n      }\n    }\n\n    EXPECT_GE(static_cast<uint32_t>(limit), max_error)\n        << \"Error: \" << size_ << \"x\" << size_\n        << \" transform/inverse transform has an individual round trip error > \"\n        << limit;\n\n    EXPECT_GE(count_test_block * limit, total_error)\n        << \"Error: \" << size_ << \"x\" << size_\n        << \" transform/inverse transform has average round trip error > \"\n        << limit << \" per block\";\n  }\n\n  void RunCoeffCheck() {\n    if (pixel_size_ == 1 && bit_depth_ > VPX_BITS_8) return;\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 5000;\n    Buffer<int16_t> input_block =\n        Buffer<int16_t>(size_, size_, 8, size_ == 4 ? 0 : 16);\n    ASSERT_TRUE(input_block.Init());\n    Buffer<tran_low_t> output_ref_block = Buffer<tran_low_t>(size_, size_, 0);\n    ASSERT_TRUE(output_ref_block.Init());\n    Buffer<tran_low_t> output_block = Buffer<tran_low_t>(size_, size_, 0, 16);\n    ASSERT_TRUE(output_block.Init());\n\n    for (int i = 0; i < count_test_block; ++i) {\n      // Initialize a test block with input range [-max_pixel_value_,\n      // max_pixel_value_].\n      input_block.Set(&rnd, -max_pixel_value_, max_pixel_value_);\n\n      fwd_txfm_ref(input_block, &output_ref_block, size_, tx_type_);\n      ASM_REGISTER_STATE_CHECK(RunFwdTxfm(input_block, &output_block));\n\n      // The minimum quant value is 4.\n      EXPECT_TRUE(output_block.CheckValues(output_ref_block));\n      if (::testing::Test::HasFailure()) {\n        printf(\"Size: %d Transform type: %d\\n\", size_, tx_type_);\n        output_block.PrintDifference(output_ref_block);\n        return;\n      }\n    }\n  }\n\n  void RunMemCheck() {\n    if (pixel_size_ == 1 && bit_depth_ > VPX_BITS_8) return;\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 5000;\n    Buffer<int16_t> input_extreme_block =\n        Buffer<int16_t>(size_, size_, 8, size_ == 4 ? 0 : 16);\n    ASSERT_TRUE(input_extreme_block.Init());\n    Buffer<tran_low_t> output_ref_block = Buffer<tran_low_t>(size_, size_, 0);\n    ASSERT_TRUE(output_ref_block.Init());\n    Buffer<tran_low_t> output_block = Buffer<tran_low_t>(size_, size_, 0, 16);\n    ASSERT_TRUE(output_block.Init());\n\n    for (int i = 0; i < count_test_block; ++i) {\n      // Initialize a test block with -max_pixel_value_ or max_pixel_value_.\n      if (i == 0) {\n        input_extreme_block.Set(max_pixel_value_);\n      } else if (i == 1) {\n        input_extreme_block.Set(-max_pixel_value_);\n      } else {\n        ASSERT_TRUE(input_extreme_block.TopLeftPixel() != NULL);\n        for (int h = 0; h < size_; ++h) {\n          for (int w = 0; w < size_; ++w) {\n            input_extreme_block\n                .TopLeftPixel()[h * input_extreme_block.stride() + w] =\n                rnd.Rand8() % 2 ? max_pixel_value_ : -max_pixel_value_;\n          }\n        }\n      }\n\n      fwd_txfm_ref(input_extreme_block, &output_ref_block, size_, tx_type_);\n      ASM_REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block, &output_block));\n\n      // The minimum quant value is 4.\n      EXPECT_TRUE(output_block.CheckValues(output_ref_block));\n      ASSERT_TRUE(output_block.TopLeftPixel() != NULL);\n      for (int h = 0; h < size_; ++h) {\n        for (int w = 0; w < size_; ++w) {\n          EXPECT_GE(\n              4 * DCT_MAX_VALUE << (bit_depth_ - 8),\n              abs(output_block.TopLeftPixel()[h * output_block.stride() + w]))\n              << \"Error: \" << size_ << \"x\" << size_\n              << \" transform has coefficient larger than 4*DCT_MAX_VALUE\"\n              << \" at \" << w << \",\" << h;\n          if (::testing::Test::HasFailure()) {\n            printf(\"Size: %d Transform type: %d\\n\", size_, tx_type_);\n            output_block.DumpBuffer();\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  void RunInvAccuracyCheck(int limit) {\n    if (pixel_size_ == 1 && bit_depth_ > VPX_BITS_8) return;\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int count_test_block = 1000;\n    Buffer<int16_t> in = Buffer<int16_t>(size_, size_, 4);\n    ASSERT_TRUE(in.Init());\n    Buffer<tran_low_t> coeff = Buffer<tran_low_t>(size_, size_, 0, 16);\n    ASSERT_TRUE(coeff.Init());\n    Buffer<uint8_t> dst = Buffer<uint8_t>(size_, size_, 0, 16);\n    ASSERT_TRUE(dst.Init());\n    Buffer<uint8_t> src = Buffer<uint8_t>(size_, size_, 0);\n    ASSERT_TRUE(src.Init());\n    Buffer<uint16_t> dst16 = Buffer<uint16_t>(size_, size_, 0, 16);\n    ASSERT_TRUE(dst16.Init());\n    Buffer<uint16_t> src16 = Buffer<uint16_t>(size_, size_, 0);\n    ASSERT_TRUE(src16.Init());\n\n    for (int i = 0; i < count_test_block; ++i) {\n      InitMem();\n      ASSERT_TRUE(in.TopLeftPixel() != NULL);\n      // Initialize a test block with input range [-max_pixel_value_,\n      // max_pixel_value_].\n      for (int h = 0; h < size_; ++h) {\n        for (int w = 0; w < size_; ++w) {\n          if (pixel_size_ == 1) {\n            in.TopLeftPixel()[h * in.stride() + w] =\n                src_[h * stride_ + w] - dst_[h * stride_ + w];\n          } else {\n            ASSERT_EQ(pixel_size_, 2);\n            const uint16_t *const src = reinterpret_cast<uint16_t *>(src_);\n            const uint16_t *const dst = reinterpret_cast<uint16_t *>(dst_);\n            in.TopLeftPixel()[h * in.stride() + w] =\n                src[h * stride_ + w] - dst[h * stride_ + w];\n          }\n        }\n      }\n\n      fwd_txfm_ref(in, &coeff, size_, tx_type_);\n\n      ASM_REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst_));\n\n      for (int h = 0; h < size_; ++h) {\n        for (int w = 0; w < size_; ++w) {\n          int diff;\n          if (pixel_size_ == 1) {\n            diff = dst_[h * stride_ + w] - src_[h * stride_ + w];\n          } else {\n            ASSERT_EQ(pixel_size_, 2);\n            const uint16_t *const src = reinterpret_cast<uint16_t *>(src_);\n            const uint16_t *const dst = reinterpret_cast<uint16_t *>(dst_);\n            diff = dst[h * stride_ + w] - src[h * stride_ + w];\n          }\n          const uint32_t error = diff * diff;\n          EXPECT_GE(static_cast<uint32_t>(limit), error)\n              << \"Error: \" << size_ << \"x\" << size_\n              << \" inverse transform has error \" << error << \" at \" << w << \",\"\n              << h;\n          if (::testing::Test::HasFailure()) {\n            printf(\"Size: %d Transform type: %d\\n\", size_, tx_type_);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  FhtFunc fwd_txfm_;\n  FhtFuncRef fwd_txfm_ref;\n  IhtWithBdFunc inv_txfm_;\n  ACMRandom rnd_;\n  uint8_t *src_;\n  uint8_t *dst_;\n  vpx_bit_depth_t bit_depth_;\n  int tx_type_;\n  int max_pixel_value_;\n  int size_;\n  int stride_;\n  int pixel_size_;\n  int block_size_;\n}",
          "class_name": "TransTestBase",
          "class_pos": [
            [
              134,
              0
            ],
            [
              431,
              1
            ]
          ]
        },
        "cf251419ee2151d0dfad90824c0e6e09fc821b778c78a18d699a74c106c1d4ba": {
          "class_code": "class TransDCT : public TransTestBase {\n public:\n  TransDCT() { fwd_txfm_ref = fdct_ref; }\n}",
          "class_name": "TransDCT",
          "class_pos": [
            [
              435,
              0
            ],
            [
              438,
              1
            ]
          ]
        },
        "fba2c5e2c2c8a7b5a10e043bba817174cbfdc89cba1bea63806cea3d498fe35a": {
          "class_code": "class TransHT : public TransTestBase {\n public:\n  TransHT() { fwd_txfm_ref = fht_ref; }\n}",
          "class_name": "TransHT",
          "class_pos": [
            [
              592,
              0
            ],
            [
              595,
              1
            ]
          ]
        },
        "2177ccf9f92c009c43bb2e9fa9ce1d60c1f06f761c707b2d76c5819d2365ee5b": {
          "class_code": "class TransWHT : public TransTestBase {\n public:\n  TransWHT() { fwd_txfm_ref = fwht_ref; }\n}",
          "class_name": "TransWHT",
          "class_pos": [
            [
              707,
              0
            ],
            [
              710,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct FuncInfo {\n  FhtFunc ft_func;\n  IhtWithBdFunc it_func;\n  int size;\n  int pixel_size;\n}",
          {
            "ft_func": "FhtFunc",
            "it_func": "IhtWithBdFunc",
            "size": "int",
            "pixel_size": "int"
          },
          "FuncInfo",
          [
            88,
            0
          ],
          [
            93,
            1
          ]
        ],
        [
          "struct FuncInfo {\n  FhtFunc ft_func;\n  IhtWithBdFunc it_func;\n  int size;\n  int pixel_size;\n}",
          {
            "ft_func": "FhtFunc",
            "it_func": "IhtWithBdFunc",
            "size": "int",
            "pixel_size": "int"
          },
          "FuncInfo",
          [
            88,
            0
          ],
          [
            93,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include <math.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./vp9_rtcd.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/buffer.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_entropy.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_codec.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"vpx_ports/mem.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/decode_corrupted.cc": {
      "fn_def_list": [
        {
          "fn_code": "DecodeCorruptedFrameTest() : EncoderTest(GET_PARAM(0)) {}",
          "fn_code_pos": [
            [
              27,
              2
            ],
            [
              27,
              59
            ]
          ],
          "class_code": "53b7fcd136c13c68198a2d459efd1970edbca43a9b634eda5969688340a0b92d",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              76,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecodeCorruptedFrameTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DecodeCorruptedFrameTest() {}",
          "fn_code_pos": [
            [
              30,
              2
            ],
            [
              30,
              40
            ]
          ],
          "class_code": "53b7fcd136c13c68198a2d459efd1970edbca43a9b634eda5969688340a0b92d",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              76,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    cfg_.g_lag_in_frames = 0;\n    cfg_.rc_end_usage = VPX_CBR;\n    cfg_.rc_buf_sz = 1000;\n    cfg_.rc_buf_initial_sz = 500;\n    cfg_.rc_buf_optimal_sz = 600;\n\n    // Set small key frame distance such that we insert more key frames.\n    cfg_.kf_max_dist = 3;\n    dec_cfg_.threads = 1;\n  }",
          "fn_code_pos": [
            [
              32,
              2
            ],
            [
              44,
              3
            ]
          ],
          "class_code": "53b7fcd136c13c68198a2d459efd1970edbca43a9b634eda5969688340a0b92d",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              76,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) encoder->Control(VP8E_SET_CPUUSED, 7);\n  }",
          "fn_code_pos": [
            [
              46,
              2
            ],
            [
              49,
              3
            ]
          ],
          "class_code": "53b7fcd136c13c68198a2d459efd1970edbca43a9b634eda5969688340a0b92d",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              76,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void MismatchHook(const vpx_image_t * /*img1*/,\n                            const vpx_image_t * /*img2*/) {}",
          "fn_code_pos": [
            [
              51,
              2
            ],
            [
              52,
              60
            ]
          ],
          "class_code": "53b7fcd136c13c68198a2d459efd1970edbca43a9b634eda5969688340a0b92d",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              76,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MismatchHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual const vpx_codec_cx_pkt_t *MutateEncoderOutputHook(\n      const vpx_codec_cx_pkt_t *pkt) {\n    // Don't edit frame packet on key frame.\n    if (pkt->data.frame.flags & VPX_FRAME_IS_KEY) return pkt;\n    if (pkt->kind != VPX_CODEC_CX_FRAME_PKT) return pkt;\n\n    memcpy(&modified_pkt_, pkt, sizeof(*pkt));\n\n    // Halve the size so it's corrupted to decoder.\n    modified_pkt_.data.frame.sz = modified_pkt_.data.frame.sz / 2;\n\n    return &modified_pkt_;\n  }",
          "fn_code_pos": [
            [
              54,
              2
            ],
            [
              66,
              3
            ]
          ],
          "class_code": "53b7fcd136c13c68198a2d459efd1970edbca43a9b634eda5969688340a0b92d",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              76,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MutateEncoderOutputHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "vpx_codec_cx_pkt_t"
          }
        },
        {
          "fn_code": "virtual bool HandleDecodeResult(const vpx_codec_err_t res_dec,\n                                  const libvpx_test::VideoSource & /*video*/,\n                                  libvpx_test::Decoder *decoder) {\n    EXPECT_NE(res_dec, VPX_CODEC_MEM_ERROR) << decoder->DecodeError();\n    return VPX_CODEC_MEM_ERROR != res_dec;\n  }",
          "fn_code_pos": [
            [
              68,
              2
            ],
            [
              73,
              3
            ]
          ],
          "class_code": "53b7fcd136c13c68198a2d459efd1970edbca43a9b634eda5969688340a0b92d",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              76,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "HandleDecodeResult",
            "parameters": {
              "res_dec": "vpx_codec_err_t",
              "decoder": "libvpx_test::Decoder"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "TEST_P(DecodeCorruptedFrameTest, DecodeCorruptedFrame) {\n  cfg_.rc_target_bitrate = 200;\n  cfg_.g_error_resilient = 0;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 300);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              78,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "MutateEncoderOutputHook(\n      const vpx_codec_cx_pkt_t *pkt)",
          "fn_dec_pos": [
            [
              54,
              36
            ],
            [
              55,
              36
            ]
          ],
          "class_code": "53b7fcd136c13c68198a2d459efd1970edbca43a9b634eda5969688340a0b92d",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              76,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MutateEncoderOutputHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "53b7fcd136c13c68198a2d459efd1970edbca43a9b634eda5969688340a0b92d": {
          "class_code": "class DecodeCorruptedFrameTest\n    : public ::libvpx_test::EncoderTest,\n      public ::testing::TestWithParam<\n          std::tuple<const libvpx_test::CodecFactory *> > {\n public:\n  DecodeCorruptedFrameTest() : EncoderTest(GET_PARAM(0)) {}\n\n protected:\n  virtual ~DecodeCorruptedFrameTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    cfg_.g_lag_in_frames = 0;\n    cfg_.rc_end_usage = VPX_CBR;\n    cfg_.rc_buf_sz = 1000;\n    cfg_.rc_buf_initial_sz = 500;\n    cfg_.rc_buf_optimal_sz = 600;\n\n    // Set small key frame distance such that we insert more key frames.\n    cfg_.kf_max_dist = 3;\n    dec_cfg_.threads = 1;\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) encoder->Control(VP8E_SET_CPUUSED, 7);\n  }\n\n  virtual void MismatchHook(const vpx_image_t * /*img1*/,\n                            const vpx_image_t * /*img2*/) {}\n\n  virtual const vpx_codec_cx_pkt_t *MutateEncoderOutputHook(\n      const vpx_codec_cx_pkt_t *pkt) {\n    // Don't edit frame packet on key frame.\n    if (pkt->data.frame.flags & VPX_FRAME_IS_KEY) return pkt;\n    if (pkt->kind != VPX_CODEC_CX_FRAME_PKT) return pkt;\n\n    memcpy(&modified_pkt_, pkt, sizeof(*pkt));\n\n    // Halve the size so it's corrupted to decoder.\n    modified_pkt_.data.frame.sz = modified_pkt_.data.frame.sz / 2;\n\n    return &modified_pkt_;\n  }\n\n  virtual bool HandleDecodeResult(const vpx_codec_err_t res_dec,\n                                  const libvpx_test::VideoSource & /*video*/,\n                                  libvpx_test::Decoder *decoder) {\n    EXPECT_NE(res_dec, VPX_CODEC_MEM_ERROR) << decoder->DecodeError();\n    return VPX_CODEC_MEM_ERROR != res_dec;\n  }\n\n  vpx_codec_cx_pkt_t modified_pkt_;\n}",
          "class_name": "DecodeCorruptedFrameTest",
          "class_pos": [
            [
              22,
              0
            ],
            [
              76,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <tuple>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/config_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "ConfigTest()\n      : EncoderTest(GET_PARAM(0)), frame_count_in_(0), frame_count_out_(0),\n        frame_count_max_(0) {}",
          "fn_code_pos": [
            [
              21,
              2
            ],
            [
              23,
              30
            ]
          ],
          "class_code": "8a639ff3672f4d550f47d767e30722fbe4a35fd9cbf9c0474c0e4c178ce18c5d",
          "class_node_pos": [
            [
              17,
              0
            ],
            [
              48,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ConfigTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~ConfigTest() {}",
          "fn_code_pos": [
            [
              24,
              2
            ],
            [
              24,
              26
            ]
          ],
          "class_code": "8a639ff3672f4d550f47d767e30722fbe4a35fd9cbf9c0474c0e4c178ce18c5d",
          "class_node_pos": [
            [
              17,
              0
            ],
            [
              48,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n  }",
          "fn_code_pos": [
            [
              26,
              2
            ],
            [
              29,
              3
            ]
          ],
          "class_code": "8a639ff3672f4d550f47d767e30722fbe4a35fd9cbf9c0474c0e4c178ce18c5d",
          "class_node_pos": [
            [
              17,
              0
            ],
            [
              48,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void BeginPassHook(unsigned int /*pass*/) {\n    frame_count_in_ = 0;\n    frame_count_out_ = 0;\n  }",
          "fn_code_pos": [
            [
              31,
              2
            ],
            [
              34,
              3
            ]
          ],
          "class_code": "8a639ff3672f4d550f47d767e30722fbe4a35fd9cbf9c0474c0e4c178ce18c5d",
          "class_node_pos": [
            [
              17,
              0
            ],
            [
              48,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BeginPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(libvpx_test::VideoSource * /*video*/) {\n    ++frame_count_in_;\n    abort_ |= (frame_count_in_ >= frame_count_max_);\n  }",
          "fn_code_pos": [
            [
              36,
              2
            ],
            [
              39,
              3
            ]
          ],
          "class_code": "8a639ff3672f4d550f47d767e30722fbe4a35fd9cbf9c0474c0e4c178ce18c5d",
          "class_node_pos": [
            [
              17,
              0
            ],
            [
              48,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t * /*pkt*/) {\n    ++frame_count_out_;\n  }",
          "fn_code_pos": [
            [
              41,
              2
            ],
            [
              43,
              3
            ]
          ],
          "class_code": "8a639ff3672f4d550f47d767e30722fbe4a35fd9cbf9c0474c0e4c178ce18c5d",
          "class_node_pos": [
            [
              17,
              0
            ],
            [
              48,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(ConfigTest, LagIsDisabled) {\n  frame_count_max_ = 2;\n  cfg_.g_lag_in_frames = 15;\n\n  libvpx_test::DummyVideoSource video;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  EXPECT_EQ(frame_count_in_, frame_count_out_);\n}",
          "fn_code_pos": [
            [
              50,
              0
            ],
            [
              58,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "8a639ff3672f4d550f47d767e30722fbe4a35fd9cbf9c0474c0e4c178ce18c5d": {
          "class_code": "class ConfigTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWithParam<libvpx_test::TestMode> {\n protected:\n  ConfigTest()\n      : EncoderTest(GET_PARAM(0)), frame_count_in_(0), frame_count_out_(0),\n        frame_count_max_(0) {}\n  virtual ~ConfigTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n  }\n\n  virtual void BeginPassHook(unsigned int /*pass*/) {\n    frame_count_in_ = 0;\n    frame_count_out_ = 0;\n  }\n\n  virtual void PreEncodeFrameHook(libvpx_test::VideoSource * /*video*/) {\n    ++frame_count_in_;\n    abort_ |= (frame_count_in_ >= frame_count_max_);\n  }\n\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t * /*pkt*/) {\n    ++frame_count_out_;\n  }\n\n  unsigned int frame_count_in_;\n  unsigned int frame_count_out_;\n  unsigned int frame_count_max_;\n}",
          "class_name": "ConfigTest",
          "class_pos": [
            [
              17,
              0
            ],
            [
              48,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/video_source.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/dct_partial_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "tran_low_t partial_fdct_ref(const Buffer<int16_t> &in, int size) {\n  int64_t sum = 0;\n  if (in.TopLeftPixel() != NULL) {\n    for (int y = 0; y < size; ++y) {\n      for (int x = 0; x < size; ++x) {\n        sum += in.TopLeftPixel()[y * in.stride() + x];\n      }\n    }\n  } else {\n    assert(0);\n  }\n\n  switch (size) {\n    case 4: sum *= 2; break;\n    case 8: /*sum = sum;*/ break;\n    case 16: sum >>= 1; break;\n    case 32: sum >>= 3; break;\n  }\n\n  return static_cast<tran_low_t>(sum);\n}",
          "fn_code_pos": [
            [
              39,
              0
            ],
            [
              59,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "partial_fdct_ref",
            "parameters": {
              "in": "Buffer<int16_t>",
              "size": "int"
            },
            "return_type": "tran_low_t"
          }
        },
        {
          "fn_code": "PartialFdctTest() {\n    fwd_txfm_ = GET_PARAM(0);\n    size_ = GET_PARAM(1);\n    bit_depth_ = GET_PARAM(2);\n  }",
          "fn_code_pos": [
            [
              63,
              2
            ],
            [
              67,
              3
            ]
          ],
          "class_code": "5e1bc8f0b88d0afdf7a18e520cda0f7022606e098f0885335027284508b1163b",
          "class_node_pos": [
            [
              61,
              0
            ],
            [
              108,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PartialFdctTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              69,
              2
            ],
            [
              69,
              62
            ]
          ],
          "class_code": "5e1bc8f0b88d0afdf7a18e520cda0f7022606e098f0885335027284508b1163b",
          "class_node_pos": [
            [
              61,
              0
            ],
            [
              108,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunTest() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int16_t maxvalue =\n        clip_pixel_highbd(std::numeric_limits<int16_t>::max(), bit_depth_);\n    const int16_t minvalue = -maxvalue;\n    Buffer<int16_t> input_block =\n        Buffer<int16_t>(size_, size_, 8, size_ == 4 ? 0 : 16);\n    ASSERT_TRUE(input_block.Init());\n    Buffer<tran_low_t> output_block = Buffer<tran_low_t>(size_, size_, 0, 16);\n    ASSERT_TRUE(output_block.Init());\n\n    if (output_block.TopLeftPixel() != NULL) {\n      for (int i = 0; i < 100; ++i) {\n        if (i == 0) {\n          input_block.Set(maxvalue);\n        } else if (i == 1) {\n          input_block.Set(minvalue);\n        } else {\n          input_block.Set(&rnd, minvalue, maxvalue);\n        }\n\n        ASM_REGISTER_STATE_CHECK(fwd_txfm_(input_block.TopLeftPixel(),\n                                           output_block.TopLeftPixel(),\n                                           input_block.stride()));\n\n        EXPECT_EQ(partial_fdct_ref(input_block, size_),\n                  output_block.TopLeftPixel()[0]);\n      }\n    } else {\n      assert(0);\n    }\n  }",
          "fn_code_pos": [
            [
              72,
              2
            ],
            [
              103,
              3
            ]
          ],
          "class_code": "5e1bc8f0b88d0afdf7a18e520cda0f7022606e098f0885335027284508b1163b",
          "class_node_pos": [
            [
              61,
              0
            ],
            [
              108,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(PartialFdctTest, PartialFdctTest) { RunTest(); }",
          "fn_code_pos": [
            [
              110,
              0
            ],
            [
              110,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*PartialFdctFunc)(const int16_t *in, tran_low_t *out, int stride)",
          "fn_dec_pos": [
            [
              34,
              13
            ],
            [
              34,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "int16_t",
              "out": "tran_low_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              73,
              14
            ],
            [
              73,
              49
            ]
          ],
          "class_code": "5e1bc8f0b88d0afdf7a18e520cda0f7022606e098f0885335027284508b1163b",
          "class_node_pos": [
            [
              61,
              0
            ],
            [
              108,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        }
      ],
      "class_node_list": {
        "5e1bc8f0b88d0afdf7a18e520cda0f7022606e098f0885335027284508b1163b": {
          "class_code": "class PartialFdctTest : public ::testing::TestWithParam<PartialFdctParam> {\n public:\n  PartialFdctTest() {\n    fwd_txfm_ = GET_PARAM(0);\n    size_ = GET_PARAM(1);\n    bit_depth_ = GET_PARAM(2);\n  }\n\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  void RunTest() {\n    ACMRandom rnd(ACMRandom::DeterministicSeed());\n    const int16_t maxvalue =\n        clip_pixel_highbd(std::numeric_limits<int16_t>::max(), bit_depth_);\n    const int16_t minvalue = -maxvalue;\n    Buffer<int16_t> input_block =\n        Buffer<int16_t>(size_, size_, 8, size_ == 4 ? 0 : 16);\n    ASSERT_TRUE(input_block.Init());\n    Buffer<tran_low_t> output_block = Buffer<tran_low_t>(size_, size_, 0, 16);\n    ASSERT_TRUE(output_block.Init());\n\n    if (output_block.TopLeftPixel() != NULL) {\n      for (int i = 0; i < 100; ++i) {\n        if (i == 0) {\n          input_block.Set(maxvalue);\n        } else if (i == 1) {\n          input_block.Set(minvalue);\n        } else {\n          input_block.Set(&rnd, minvalue, maxvalue);\n        }\n\n        ASM_REGISTER_STATE_CHECK(fwd_txfm_(input_block.TopLeftPixel(),\n                                           output_block.TopLeftPixel(),\n                                           input_block.stride()));\n\n        EXPECT_EQ(partial_fdct_ref(input_block, size_),\n                  output_block.TopLeftPixel()[0]);\n      }\n    } else {\n      assert(0);\n    }\n  }\n\n  PartialFdctFunc fwd_txfm_;\n  vpx_bit_depth_t bit_depth_;\n  int size_;\n}",
          "class_name": "PartialFdctTest",
          "class_pos": [
            [
              61,
              0
            ],
            [
              108,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <math.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <limits>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/buffer.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_codec.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"vpx_dsp/vpx_dsp_common.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/test_libvpx.cc": {
      "fn_def_list": [
        {
          "fn_code": "static void append_negative_gtest_filter(const char *str) {\n  std::string filter = ::testing::FLAGS_gtest_filter;\n  // Negative patterns begin with one '-' followed by a ':' separated list.\n  if (filter.find('-') == std::string::npos) filter += '-';\n  filter += str;\n  ::testing::FLAGS_gtest_filter = filter;\n}",
          "fn_code_pos": [
            [
              29,
              0
            ],
            [
              35,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "append_negative_gtest_filter",
            "parameters": {
              "str": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(int argc, char **argv) {\n  ::testing::InitGoogleTest(&argc, argv);\n\n#if ARCH_X86 || ARCH_X86_64\n  const int simd_caps = x86_simd_caps();\n  if (!(simd_caps & HAS_MMX)) append_negative_gtest_filter(\":MMX.*:MMX/*\");\n  if (!(simd_caps & HAS_SSE)) append_negative_gtest_filter(\":SSE.*:SSE/*\");\n  if (!(simd_caps & HAS_SSE2)) append_negative_gtest_filter(\":SSE2.*:SSE2/*\");\n  if (!(simd_caps & HAS_SSE3)) append_negative_gtest_filter(\":SSE3.*:SSE3/*\");\n  if (!(simd_caps & HAS_SSSE3)) {\n    append_negative_gtest_filter(\":SSSE3.*:SSSE3/*\");\n  }\n  if (!(simd_caps & HAS_SSE4_1)) {\n    append_negative_gtest_filter(\":SSE4_1.*:SSE4_1/*\");\n  }\n  if (!(simd_caps & HAS_AVX)) append_negative_gtest_filter(\":AVX.*:AVX/*\");\n  if (!(simd_caps & HAS_AVX2)) append_negative_gtest_filter(\":AVX2.*:AVX2/*\");\n  if (!(simd_caps & HAS_AVX512)) {\n    append_negative_gtest_filter(\":AVX512.*:AVX512/*\");\n  }\n#endif  // ARCH_X86 || ARCH_X86_64\n\n#if !CONFIG_SHARED\n// Shared library builds don't support whitebox tests\n// that exercise internal symbols.\n#if CONFIG_VP8\n  vp8_rtcd();\n#endif  // CONFIG_VP8\n#if CONFIG_VP9\n  vp9_rtcd();\n#endif  // CONFIG_VP9\n  vpx_dsp_rtcd();\n  vpx_scale_rtcd();\n#endif  // !CONFIG_SHARED\n\n  return RUN_ALL_TESTS();\n}",
          "fn_code_pos": [
            [
              38,
              0
            ],
            [
              74,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "vp8_rtcd()",
          "fn_dec_pos": [
            [
              19,
              12
            ],
            [
              19,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "vp8_rtcd",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "vp9_rtcd()",
          "fn_dec_pos": [
            [
              22,
              12
            ],
            [
              22,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "vp9_rtcd",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "vpx_dsp_rtcd()",
          "fn_dec_pos": [
            [
              24,
              12
            ],
            [
              24,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "vpx_dsp_rtcd",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "vpx_scale_rtcd()",
          "fn_dec_pos": [
            [
              25,
              12
            ],
            [
              25,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "vpx_scale_rtcd",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <string>\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"vpx_ports/x86.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp9_skip_loopfilter_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "SkipLoopFilterTest() : video_(NULL), decoder_(NULL), md5_file_(NULL) {}",
          "fn_code_pos": [
            [
              26,
              2
            ],
            [
              26,
              73
            ]
          ],
          "class_code": "fcc267235e22d2beb863d1b93db32c55801fb8c28f414c9ae2457fe7bdbea25b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              117,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SkipLoopFilterTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~SkipLoopFilterTest() {\n    if (md5_file_ != NULL) fclose(md5_file_);\n    delete decoder_;\n    delete video_;\n  }",
          "fn_code_pos": [
            [
              28,
              2
            ],
            [
              32,
              3
            ]
          ],
          "class_code": "fcc267235e22d2beb863d1b93db32c55801fb8c28f414c9ae2457fe7bdbea25b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              117,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void Init(int num_threads) {\n    expected_md5_[0] = '\\0';\n    junk_[0] = '\\0';\n    video_ = new libvpx_test::WebMVideoSource(kVp9TestFile);\n    ASSERT_TRUE(video_ != NULL);\n    video_->Init();\n    video_->Begin();\n\n    vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n    if (num_threads > 0) cfg.threads = num_threads;\n    decoder_ = new libvpx_test::VP9Decoder(cfg, 0);\n    ASSERT_TRUE(decoder_ != NULL);\n\n    OpenMd5File(kVp9Md5File);\n  }",
          "fn_code_pos": [
            [
              35,
              2
            ],
            [
              49,
              3
            ]
          ],
          "class_code": "fcc267235e22d2beb863d1b93db32c55801fb8c28f414c9ae2457fe7bdbea25b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              117,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Init",
            "parameters": {
              "num_threads": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SetSkipLoopFilter(int value, vpx_codec_err_t expected_value) {\n    decoder_->Control(VP9_SET_SKIP_LOOP_FILTER, value, expected_value);\n  }",
          "fn_code_pos": [
            [
              52,
              2
            ],
            [
              54,
              3
            ]
          ],
          "class_code": "fcc267235e22d2beb863d1b93db32c55801fb8c28f414c9ae2457fe7bdbea25b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              117,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetSkipLoopFilter",
            "parameters": {
              "value": "int",
              "expected_value": "vpx_codec_err_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "vpx_codec_err_t DecodeOneFrame() {\n    const vpx_codec_err_t res =\n        decoder_->DecodeFrame(video_->cxdata(), video_->frame_size());\n    if (res == VPX_CODEC_OK) {\n      ReadMd5();\n      video_->Next();\n    }\n    return res;\n  }",
          "fn_code_pos": [
            [
              56,
              2
            ],
            [
              64,
              3
            ]
          ],
          "class_code": "fcc267235e22d2beb863d1b93db32c55801fb8c28f414c9ae2457fe7bdbea25b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              117,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecodeOneFrame",
            "parameters": {},
            "return_type": "vpx_codec_err_t"
          }
        },
        {
          "fn_code": "vpx_codec_err_t DecodeRemainingFrames() {\n    for (; video_->cxdata() != NULL; video_->Next()) {\n      const vpx_codec_err_t res =\n          decoder_->DecodeFrame(video_->cxdata(), video_->frame_size());\n      if (res != VPX_CODEC_OK) return res;\n      ReadMd5();\n    }\n    return VPX_CODEC_OK;\n  }",
          "fn_code_pos": [
            [
              66,
              2
            ],
            [
              74,
              3
            ]
          ],
          "class_code": "fcc267235e22d2beb863d1b93db32c55801fb8c28f414c9ae2457fe7bdbea25b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              117,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecodeRemainingFrames",
            "parameters": {},
            "return_type": "vpx_codec_err_t"
          }
        },
        {
          "fn_code": "void CheckMd5(bool matches) {\n    libvpx_test::DxDataIterator dec_iter = decoder_->GetDxData();\n    const vpx_image_t *img = dec_iter.Next();\n    CheckMd5Vpx(*img, matches);\n  }",
          "fn_code_pos": [
            [
              77,
              2
            ],
            [
              81,
              3
            ]
          ],
          "class_code": "fcc267235e22d2beb863d1b93db32c55801fb8c28f414c9ae2457fe7bdbea25b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              117,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckMd5",
            "parameters": {
              "matches": "bool"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void OpenMd5File(const std::string &md5_file_name) {\n    md5_file_ = libvpx_test::OpenTestDataFile(md5_file_name);\n    ASSERT_TRUE(md5_file_ != NULL)\n        << \"MD5 file open failed. Filename: \" << md5_file_name;\n  }",
          "fn_code_pos": [
            [
              85,
              2
            ],
            [
              89,
              3
            ]
          ],
          "class_code": "fcc267235e22d2beb863d1b93db32c55801fb8c28f414c9ae2457fe7bdbea25b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              117,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "OpenMd5File",
            "parameters": {
              "md5_file_name": "std::string"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ReadMd5() {\n    ASSERT_TRUE(md5_file_ != NULL);\n    const int res = fscanf(md5_file_, \"%s  %s\", expected_md5_, junk_);\n    ASSERT_NE(EOF, res) << \"Read md5 data failed\";\n    expected_md5_[32] = '\\0';\n  }",
          "fn_code_pos": [
            [
              92,
              2
            ],
            [
              97,
              3
            ]
          ],
          "class_code": "fcc267235e22d2beb863d1b93db32c55801fb8c28f414c9ae2457fe7bdbea25b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              117,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ReadMd5",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CheckMd5Vpx(const vpx_image_t &img, bool matches) {\n    ::libvpx_test::MD5 md5_res;\n    md5_res.Add(&img);\n    const char *const actual_md5 = md5_res.Get();\n\n    // Check MD5.\n    if (matches)\n      ASSERT_STREQ(expected_md5_, actual_md5) << \"MD5 checksums don't match\";\n    else\n      ASSERT_STRNE(expected_md5_, actual_md5) << \"MD5 checksums match\";\n  }",
          "fn_code_pos": [
            [
              100,
              2
            ],
            [
              110,
              3
            ]
          ],
          "class_code": "fcc267235e22d2beb863d1b93db32c55801fb8c28f414c9ae2457fe7bdbea25b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              117,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckMd5Vpx",
            "parameters": {
              "img": "vpx_image_t",
              "matches": "bool"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST(SkipLoopFilterTest, ShutOffLoopFilter) {\n  const int non_zero_value = 1;\n  const int num_threads = 0;\n  SkipLoopFilterTest skip_loop_filter;\n  skip_loop_filter.Init(num_threads);\n  skip_loop_filter.SetSkipLoopFilter(non_zero_value, VPX_CODEC_OK);\n  ASSERT_EQ(VPX_CODEC_OK, skip_loop_filter.DecodeRemainingFrames());\n  skip_loop_filter.CheckMd5(false);\n}",
          "fn_code_pos": [
            [
              119,
              0
            ],
            [
              127,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(SkipLoopFilterTest, ShutOffLoopFilterSingleThread) {\n  const int non_zero_value = 1;\n  const int num_threads = 1;\n  SkipLoopFilterTest skip_loop_filter;\n  skip_loop_filter.Init(num_threads);\n  skip_loop_filter.SetSkipLoopFilter(non_zero_value, VPX_CODEC_OK);\n  ASSERT_EQ(VPX_CODEC_OK, skip_loop_filter.DecodeRemainingFrames());\n  skip_loop_filter.CheckMd5(false);\n}",
          "fn_code_pos": [
            [
              129,
              0
            ],
            [
              137,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(SkipLoopFilterTest, ShutOffLoopFilter8Threads) {\n  const int non_zero_value = 1;\n  const int num_threads = 8;\n  SkipLoopFilterTest skip_loop_filter;\n  skip_loop_filter.Init(num_threads);\n  skip_loop_filter.SetSkipLoopFilter(non_zero_value, VPX_CODEC_OK);\n  ASSERT_EQ(VPX_CODEC_OK, skip_loop_filter.DecodeRemainingFrames());\n  skip_loop_filter.CheckMd5(false);\n}",
          "fn_code_pos": [
            [
              139,
              0
            ],
            [
              147,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(SkipLoopFilterTest, WithLoopFilter) {\n  const int non_zero_value = 1;\n  const int num_threads = 0;\n  SkipLoopFilterTest skip_loop_filter;\n  skip_loop_filter.Init(num_threads);\n  skip_loop_filter.SetSkipLoopFilter(non_zero_value, VPX_CODEC_OK);\n  skip_loop_filter.SetSkipLoopFilter(0, VPX_CODEC_OK);\n  ASSERT_EQ(VPX_CODEC_OK, skip_loop_filter.DecodeRemainingFrames());\n  skip_loop_filter.CheckMd5(true);\n}",
          "fn_code_pos": [
            [
              149,
              0
            ],
            [
              158,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(SkipLoopFilterTest, ToggleLoopFilter) {\n  const int num_threads = 0;\n  SkipLoopFilterTest skip_loop_filter;\n  skip_loop_filter.Init(num_threads);\n\n  for (int i = 0; i < 10; ++i) {\n    skip_loop_filter.SetSkipLoopFilter(i % 2, VPX_CODEC_OK);\n    ASSERT_EQ(VPX_CODEC_OK, skip_loop_filter.DecodeOneFrame());\n  }\n  ASSERT_EQ(VPX_CODEC_OK, skip_loop_filter.DecodeRemainingFrames());\n  skip_loop_filter.CheckMd5(false);\n}",
          "fn_code_pos": [
            [
              160,
              0
            ],
            [
              171,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "fcc267235e22d2beb863d1b93db32c55801fb8c28f414c9ae2457fe7bdbea25b": {
          "class_code": "class SkipLoopFilterTest {\n public:\n  SkipLoopFilterTest() : video_(NULL), decoder_(NULL), md5_file_(NULL) {}\n\n  ~SkipLoopFilterTest() {\n    if (md5_file_ != NULL) fclose(md5_file_);\n    delete decoder_;\n    delete video_;\n  }\n\n  // If |threads| > 0 then set the decoder with that number of threads.\n  void Init(int num_threads) {\n    expected_md5_[0] = '\\0';\n    junk_[0] = '\\0';\n    video_ = new libvpx_test::WebMVideoSource(kVp9TestFile);\n    ASSERT_TRUE(video_ != NULL);\n    video_->Init();\n    video_->Begin();\n\n    vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n    if (num_threads > 0) cfg.threads = num_threads;\n    decoder_ = new libvpx_test::VP9Decoder(cfg, 0);\n    ASSERT_TRUE(decoder_ != NULL);\n\n    OpenMd5File(kVp9Md5File);\n  }\n\n  // Set the VP9 skipLoopFilter control value.\n  void SetSkipLoopFilter(int value, vpx_codec_err_t expected_value) {\n    decoder_->Control(VP9_SET_SKIP_LOOP_FILTER, value, expected_value);\n  }\n\n  vpx_codec_err_t DecodeOneFrame() {\n    const vpx_codec_err_t res =\n        decoder_->DecodeFrame(video_->cxdata(), video_->frame_size());\n    if (res == VPX_CODEC_OK) {\n      ReadMd5();\n      video_->Next();\n    }\n    return res;\n  }\n\n  vpx_codec_err_t DecodeRemainingFrames() {\n    for (; video_->cxdata() != NULL; video_->Next()) {\n      const vpx_codec_err_t res =\n          decoder_->DecodeFrame(video_->cxdata(), video_->frame_size());\n      if (res != VPX_CODEC_OK) return res;\n      ReadMd5();\n    }\n    return VPX_CODEC_OK;\n  }\n\n  // Checks if MD5 matches or doesn't.\n  void CheckMd5(bool matches) {\n    libvpx_test::DxDataIterator dec_iter = decoder_->GetDxData();\n    const vpx_image_t *img = dec_iter.Next();\n    CheckMd5Vpx(*img, matches);\n  }\n\n private:\n  // TODO(fgalligan): Move the MD5 testing code into another class.\n  void OpenMd5File(const std::string &md5_file_name) {\n    md5_file_ = libvpx_test::OpenTestDataFile(md5_file_name);\n    ASSERT_TRUE(md5_file_ != NULL)\n        << \"MD5 file open failed. Filename: \" << md5_file_name;\n  }\n\n  // Reads the next line of the MD5 file.\n  void ReadMd5() {\n    ASSERT_TRUE(md5_file_ != NULL);\n    const int res = fscanf(md5_file_, \"%s  %s\", expected_md5_, junk_);\n    ASSERT_NE(EOF, res) << \"Read md5 data failed\";\n    expected_md5_[32] = '\\0';\n  }\n\n  // Checks if the last read MD5 matches |img| or doesn't.\n  void CheckMd5Vpx(const vpx_image_t &img, bool matches) {\n    ::libvpx_test::MD5 md5_res;\n    md5_res.Add(&img);\n    const char *const actual_md5 = md5_res.Get();\n\n    // Check MD5.\n    if (matches)\n      ASSERT_STREQ(expected_md5_, actual_md5) << \"MD5 checksums don't match\";\n    else\n      ASSERT_STRNE(expected_md5_, actual_md5) << \"MD5 checksums match\";\n  }\n\n  libvpx_test::WebMVideoSource *video_;\n  libvpx_test::VP9Decoder *decoder_;\n  FILE *md5_file_;\n  char expected_md5_[33];\n  char junk_[128];\n}",
          "class_name": "SkipLoopFilterTest",
          "class_pos": [
            [
              24,
              0
            ],
            [
              117,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <string>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/decode_test_driver.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/md5_helper.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/webm_video_source.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp9_block_error_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "template <BlockErrorFunc fn>\nint64_t BlockError8BitWrapper(const tran_low_t *coeff,\n                              const tran_low_t *dqcoeff, intptr_t block_size,\n                              int64_t *ssz, int bps) {\n  EXPECT_EQ(bps, 8);\n  return fn(coeff, dqcoeff, block_size, ssz);\n}",
          "fn_code_pos": [
            [
              45,
              0
            ],
            [
              51,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~BlockErrorTest() {}",
          "fn_code_pos": [
            [
              55,
              2
            ],
            [
              55,
              30
            ]
          ],
          "class_code": "a5b2ac6c17e87806f1d87b385c9609b0d59aca09f31f202f80397950e6b84037",
          "class_node_pos": [
            [
              53,
              0
            ],
            [
              68,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    error_block_op_ = GET_PARAM(0);\n    ref_error_block_op_ = GET_PARAM(1);\n    bit_depth_ = GET_PARAM(2);\n  }",
          "fn_code_pos": [
            [
              56,
              2
            ],
            [
              60,
              3
            ]
          ],
          "class_code": "a5b2ac6c17e87806f1d87b385c9609b0d59aca09f31f202f80397950e6b84037",
          "class_node_pos": [
            [
              53,
              0
            ],
            [
              68,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              62,
              2
            ],
            [
              62,
              62
            ]
          ],
          "class_code": "a5b2ac6c17e87806f1d87b385c9609b0d59aca09f31f202f80397950e6b84037",
          "class_node_pos": [
            [
              53,
              0
            ],
            [
              68,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(BlockErrorTest, OperationCheck) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  DECLARE_ALIGNED(16, tran_low_t, coeff[4096]);\n  DECLARE_ALIGNED(16, tran_low_t, dqcoeff[4096]);\n  int err_count_total = 0;\n  int first_failure = -1;\n  intptr_t block_size;\n  int64_t ssz;\n  int64_t ret;\n  int64_t ref_ssz;\n  int64_t ref_ret;\n  const int msb = bit_depth_ + 8 - 1;\n  for (int i = 0; i < kNumIterations; ++i) {\n    int err_count = 0;\n    block_size = 16 << (i % 9);  // All block sizes from 4x4, 8x4 ..64x64\n    for (int j = 0; j < block_size; j++) {\n      // coeff and dqcoeff will always have at least the same sign, and this\n      // can be used for optimization, so generate test input precisely.\n      if (rnd(2)) {\n        // Positive number\n        coeff[j] = rnd(1 << msb);\n        dqcoeff[j] = rnd(1 << msb);\n      } else {\n        // Negative number\n        coeff[j] = -rnd(1 << msb);\n        dqcoeff[j] = -rnd(1 << msb);\n      }\n    }\n    ref_ret =\n        ref_error_block_op_(coeff, dqcoeff, block_size, &ref_ssz, bit_depth_);\n    ASM_REGISTER_STATE_CHECK(\n        ret = error_block_op_(coeff, dqcoeff, block_size, &ssz, bit_depth_));\n    err_count += (ref_ret != ret) | (ref_ssz != ssz);\n    if (err_count && !err_count_total) {\n      first_failure = i;\n    }\n    err_count_total += err_count;\n  }\n  EXPECT_EQ(0, err_count_total)\n      << \"Error: Error Block Test, C output doesn't match optimized output. \"\n      << \"First failed at test case \" << first_failure;\n}",
          "fn_code_pos": [
            [
              70,
              0
            ],
            [
              111,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(BlockErrorTest, ExtremeValues) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  DECLARE_ALIGNED(16, tran_low_t, coeff[4096]);\n  DECLARE_ALIGNED(16, tran_low_t, dqcoeff[4096]);\n  int err_count_total = 0;\n  int first_failure = -1;\n  intptr_t block_size;\n  int64_t ssz;\n  int64_t ret;\n  int64_t ref_ssz;\n  int64_t ref_ret;\n  const int msb = bit_depth_ + 8 - 1;\n  int max_val = ((1 << msb) - 1);\n  for (int i = 0; i < kNumIterations; ++i) {\n    int err_count = 0;\n    int k = (i / 9) % 9;\n\n    // Change the maximum coeff value, to test different bit boundaries\n    if (k == 8 && (i % 9) == 0) {\n      max_val >>= 1;\n    }\n    block_size = 16 << (i % 9);  // All block sizes from 4x4, 8x4 ..64x64\n    for (int j = 0; j < block_size; j++) {\n      if (k < 4) {\n        // Test at positive maximum values\n        coeff[j] = k % 2 ? max_val : 0;\n        dqcoeff[j] = (k >> 1) % 2 ? max_val : 0;\n      } else if (k < 8) {\n        // Test at negative maximum values\n        coeff[j] = k % 2 ? -max_val : 0;\n        dqcoeff[j] = (k >> 1) % 2 ? -max_val : 0;\n      } else {\n        if (rnd(2)) {\n          // Positive number\n          coeff[j] = rnd(1 << 14);\n          dqcoeff[j] = rnd(1 << 14);\n        } else {\n          // Negative number\n          coeff[j] = -rnd(1 << 14);\n          dqcoeff[j] = -rnd(1 << 14);\n        }\n      }\n    }\n    ref_ret =\n        ref_error_block_op_(coeff, dqcoeff, block_size, &ref_ssz, bit_depth_);\n    ASM_REGISTER_STATE_CHECK(\n        ret = error_block_op_(coeff, dqcoeff, block_size, &ssz, bit_depth_));\n    err_count += (ref_ret != ret) | (ref_ssz != ssz);\n    if (err_count && !err_count_total) {\n      first_failure = i;\n    }\n    err_count_total += err_count;\n  }\n  EXPECT_EQ(0, err_count_total)\n      << \"Error: Error Block Test, C output doesn't match optimized output. \"\n      << \"First failed at test case \" << first_failure;\n}",
          "fn_code_pos": [
            [
              113,
              0
            ],
            [
              169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*HBDBlockErrorFunc)(const tran_low_t *coeff,\n                                     const tran_low_t *dqcoeff,\n                                     intptr_t block_size, int64_t *ssz,\n                                     int bps)",
          "fn_dec_pos": [
            [
              33,
              16
            ],
            [
              36,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "coeff": "tran_low_t",
              "dqcoeff": "tran_low_t",
              "block_size": "intptr_t",
              "ssz": "int64_t",
              "bps": "int"
            },
            "return_type": "int64_t"
          }
        },
        {
          "fn_code": "(*BlockErrorFunc)(const tran_low_t *coeff,\n                                  const tran_low_t *dqcoeff,\n                                  intptr_t block_size, int64_t *ssz)",
          "fn_dec_pos": [
            [
              41,
              16
            ],
            [
              43,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "coeff": "tran_low_t",
              "dqcoeff": "tran_low_t",
              "block_size": "intptr_t",
              "ssz": "int64_t"
            },
            "return_type": "int64_t"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              71,
              12
            ],
            [
              71,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              114,
              12
            ],
            [
              114,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        }
      ],
      "class_node_list": {
        "a5b2ac6c17e87806f1d87b385c9609b0d59aca09f31f202f80397950e6b84037": {
          "class_code": "class BlockErrorTest : public ::testing::TestWithParam<BlockErrorParam> {\n public:\n  virtual ~BlockErrorTest() {}\n  virtual void SetUp() {\n    error_block_op_ = GET_PARAM(0);\n    ref_error_block_op_ = GET_PARAM(1);\n    bit_depth_ = GET_PARAM(2);\n  }\n\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  vpx_bit_depth_t bit_depth_;\n  HBDBlockErrorFunc error_block_op_;\n  HBDBlockErrorFunc ref_error_block_op_;\n}",
          "class_name": "BlockErrorTest",
          "class_pos": [
            [
              53,
              0
            ],
            [
              68,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <cmath>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <cstdlib>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"./vp9_rtcd.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_entropy.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_codec.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"vpx_dsp/vpx_dsp_common.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vpx_scale_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "virtual ~ExtendBorderTest() {}",
          "fn_code_pos": [
            [
              40,
              2
            ],
            [
              40,
              32
            ]
          ],
          "class_code": "bc44854b6daf5749180cabebce6f3cc437b9526b91ed1cf2e121f5f352350b48",
          "class_node_pos": [
            [
              36,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() { extend_fn_ = GetParam(); }",
          "fn_code_pos": [
            [
              43,
              2
            ],
            [
              43,
              51
            ]
          ],
          "class_code": "bc44854b6daf5749180cabebce6f3cc437b9526b91ed1cf2e121f5f352350b48",
          "class_node_pos": [
            [
              36,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ExtendBorder() { ASM_REGISTER_STATE_CHECK(extend_fn_(&img_)); }",
          "fn_code_pos": [
            [
              45,
              2
            ],
            [
              45,
              70
            ]
          ],
          "class_code": "bc44854b6daf5749180cabebce6f3cc437b9526b91ed1cf2e121f5f352350b48",
          "class_node_pos": [
            [
              36,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ExtendBorder",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunTest() {\n    for (int h = 0; h < kNumSizesToTest; ++h) {\n      for (int w = 0; w < kNumSizesToTest; ++w) {\n        ASSERT_NO_FATAL_FAILURE(ResetImages(kSizesToTest[w], kSizesToTest[h]));\n        ReferenceCopyFrame();\n        ExtendBorder();\n        CompareImages(img_);\n        DeallocImages();\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              47,
              2
            ],
            [
              57,
              3
            ]
          ],
          "class_code": "bc44854b6daf5749180cabebce6f3cc437b9526b91ed1cf2e121f5f352350b48",
          "class_node_pos": [
            [
              36,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(ExtendBorderTest, ExtendBorder) { ASSERT_NO_FATAL_FAILURE(RunTest()); }",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              62,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~CopyFrameTest() {}",
          "fn_code_pos": [
            [
              70,
              2
            ],
            [
              70,
              29
            ]
          ],
          "class_code": "f18630dd0486c516f02dfb991c4edd3dbde24b62ad43d7cc592a729748f33d4b",
          "class_node_pos": [
            [
              67,
              0
            ],
            [
              92,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() { copy_frame_fn_ = GetParam(); }",
          "fn_code_pos": [
            [
              73,
              2
            ],
            [
              73,
              55
            ]
          ],
          "class_code": "f18630dd0486c516f02dfb991c4edd3dbde24b62ad43d7cc592a729748f33d4b",
          "class_node_pos": [
            [
              67,
              0
            ],
            [
              92,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CopyFrame() {\n    ASM_REGISTER_STATE_CHECK(copy_frame_fn_(&img_, &dst_img_));\n  }",
          "fn_code_pos": [
            [
              75,
              2
            ],
            [
              77,
              3
            ]
          ],
          "class_code": "f18630dd0486c516f02dfb991c4edd3dbde24b62ad43d7cc592a729748f33d4b",
          "class_node_pos": [
            [
              67,
              0
            ],
            [
              92,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CopyFrame",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunTest() {\n    for (int h = 0; h < kNumSizesToTest; ++h) {\n      for (int w = 0; w < kNumSizesToTest; ++w) {\n        ASSERT_NO_FATAL_FAILURE(ResetImages(kSizesToTest[w], kSizesToTest[h]));\n        ReferenceCopyFrame();\n        CopyFrame();\n        CompareImages(dst_img_);\n        DeallocImages();\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              79,
              2
            ],
            [
              89,
              3
            ]
          ],
          "class_code": "f18630dd0486c516f02dfb991c4edd3dbde24b62ad43d7cc592a729748f33d4b",
          "class_node_pos": [
            [
              67,
              0
            ],
            [
              92,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(CopyFrameTest, CopyFrame) { ASSERT_NO_FATAL_FAILURE(RunTest()); }",
          "fn_code_pos": [
            [
              94,
              0
            ],
            [
              94,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*ExtendFrameBorderFunc)(YV12_BUFFER_CONFIG *ybf)",
          "fn_dec_pos": [
            [
              32,
              13
            ],
            [
              32,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ybf": "YV12_BUFFER_CONFIG"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*CopyFrameFunc)(const YV12_BUFFER_CONFIG *src_ybf,\n                              YV12_BUFFER_CONFIG *dst_ybf)",
          "fn_dec_pos": [
            [
              33,
              13
            ],
            [
              34,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "src_ybf": "YV12_BUFFER_CONFIG",
              "dst_ybf": "YV12_BUFFER_CONFIG"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {
        "bc44854b6daf5749180cabebce6f3cc437b9526b91ed1cf2e121f5f352350b48": {
          "class_code": "class ExtendBorderTest\n    : public VpxScaleBase,\n      public ::testing::TestWithParam<ExtendFrameBorderFunc> {\n public:\n  virtual ~ExtendBorderTest() {}\n\n protected:\n  virtual void SetUp() { extend_fn_ = GetParam(); }\n\n  void ExtendBorder() { ASM_REGISTER_STATE_CHECK(extend_fn_(&img_)); }\n\n  void RunTest() {\n    for (int h = 0; h < kNumSizesToTest; ++h) {\n      for (int w = 0; w < kNumSizesToTest; ++w) {\n        ASSERT_NO_FATAL_FAILURE(ResetImages(kSizesToTest[w], kSizesToTest[h]));\n        ReferenceCopyFrame();\n        ExtendBorder();\n        CompareImages(img_);\n        DeallocImages();\n      }\n    }\n  }\n\n  ExtendFrameBorderFunc extend_fn_;\n}",
          "class_name": "ExtendBorderTest",
          "class_pos": [
            [
              36,
              0
            ],
            [
              60,
              1
            ]
          ]
        },
        "f18630dd0486c516f02dfb991c4edd3dbde24b62ad43d7cc592a729748f33d4b": {
          "class_code": "class CopyFrameTest : public VpxScaleBase,\n                      public ::testing::TestWithParam<CopyFrameFunc> {\n public:\n  virtual ~CopyFrameTest() {}\n\n protected:\n  virtual void SetUp() { copy_frame_fn_ = GetParam(); }\n\n  void CopyFrame() {\n    ASM_REGISTER_STATE_CHECK(copy_frame_fn_(&img_, &dst_img_));\n  }\n\n  void RunTest() {\n    for (int h = 0; h < kNumSizesToTest; ++h) {\n      for (int w = 0; w < kNumSizesToTest; ++w) {\n        ASSERT_NO_FATAL_FAILURE(ResetImages(kSizesToTest[w], kSizesToTest[h]));\n        ReferenceCopyFrame();\n        CopyFrame();\n        CompareImages(dst_img_);\n        DeallocImages();\n      }\n    }\n  }\n\n  CopyFrameFunc copy_frame_fn_;\n}",
          "class_name": "CopyFrameTest",
          "class_pos": [
            [
              67,
              0
            ],
            [
              92,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"./vpx_scale_rtcd.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/vpx_scale_test.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"vpx_ports/vpx_timer.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"vpx_scale/yv12config.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp8_decrypt_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "void encrypt_buffer(const uint8_t *src, uint8_t *dst, size_t size,\n                    ptrdiff_t offset) {\n  for (size_t i = 0; i < size; ++i) {\n    dst[i] = src[i] ^ test_key[(offset + i) & 15];\n  }\n}",
          "fn_code_pos": [
            [
              26,
              0
            ],
            [
              31,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "encrypt_buffer",
            "parameters": {
              "src": "uint8_t",
              "dst": "uint8_t",
              "size": "size_t",
              "offset": "ptrdiff_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void test_decrypt_cb(void *decrypt_state, const uint8_t *input, uint8_t *output,\n                     int count) {\n  encrypt_buffer(input, output, count,\n                 input - reinterpret_cast<uint8_t *>(decrypt_state));\n}",
          "fn_code_pos": [
            [
              33,
              0
            ],
            [
              37,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "test_decrypt_cb",
            "parameters": {
              "decrypt_state": "void",
              "input": "uint8_t",
              "output": "uint8_t",
              "count": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST(TestDecrypt, DecryptWorksVp8) {\n  libvpx_test::IVFVideoSource video(\"vp80-00-comprehensive-001.ivf\");\n  video.Init();\n\n  vpx_codec_dec_cfg_t dec_cfg = vpx_codec_dec_cfg_t();\n  VP8Decoder decoder(dec_cfg, 0);\n\n  video.Begin();\n\n  // no decryption\n  vpx_codec_err_t res = decoder.DecodeFrame(video.cxdata(), video.frame_size());\n  ASSERT_EQ(VPX_CODEC_OK, res) << decoder.DecodeError();\n\n  // decrypt frame\n  video.Next();\n\n  std::vector<uint8_t> encrypted(video.frame_size());\n  encrypt_buffer(video.cxdata(), &encrypted[0], video.frame_size(), 0);\n  vpx_decrypt_init di = { test_decrypt_cb, &encrypted[0] };\n  decoder.Control(VPXD_SET_DECRYPTOR, &di);\n\n  res = decoder.DecodeFrame(&encrypted[0], encrypted.size());\n  ASSERT_EQ(VPX_CODEC_OK, res) << decoder.DecodeError();\n}",
          "fn_code_pos": [
            [
              43,
              0
            ],
            [
              66,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <cstdio>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <cstdlib>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/ivf_video_source.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/cq_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "static void SetUpTestCase() { bitrates_.clear(); }",
          "fn_code_pos": [
            [
              31,
              2
            ],
            [
              31,
              52
            ]
          ],
          "class_code": "5c698993593ad2965fe2f65f1e9df541d98805f5bb25dd0976cb38a2e7f57de8",
          "class_node_pos": [
            [
              25,
              0
            ],
            [
              100,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUpTestCase",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void TearDownTestCase() {\n    ASSERT_TRUE(!HasFailure())\n        << \"skipping bitrate validation due to earlier failure.\";\n    uint32_t prev_actual_bitrate = kCQTargetBitrate;\n    for (BitrateMap::const_iterator iter = bitrates_.begin();\n         iter != bitrates_.end(); ++iter) {\n      const uint32_t cq_actual_bitrate = iter->second;\n      EXPECT_LE(cq_actual_bitrate, prev_actual_bitrate)\n          << \"cq_level: \" << iter->first\n          << \", bitrate should decrease with increase in CQ level.\";\n      prev_actual_bitrate = cq_actual_bitrate;\n    }\n  }",
          "fn_code_pos": [
            [
              33,
              2
            ],
            [
              45,
              3
            ]
          ],
          "class_code": "5c698993593ad2965fe2f65f1e9df541d98805f5bb25dd0976cb38a2e7f57de8",
          "class_node_pos": [
            [
              25,
              0
            ],
            [
              100,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDownTestCase",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "CQTest() : EncoderTest(GET_PARAM(0)), cq_level_(GET_PARAM(1)) {\n    init_flags_ = VPX_CODEC_USE_PSNR;\n  }",
          "fn_code_pos": [
            [
              48,
              2
            ],
            [
              50,
              3
            ]
          ],
          "class_code": "5c698993593ad2965fe2f65f1e9df541d98805f5bb25dd0976cb38a2e7f57de8",
          "class_node_pos": [
            [
              25,
              0
            ],
            [
              100,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CQTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~CQTest() {}",
          "fn_code_pos": [
            [
              52,
              2
            ],
            [
              52,
              22
            ]
          ],
          "class_code": "5c698993593ad2965fe2f65f1e9df541d98805f5bb25dd0976cb38a2e7f57de8",
          "class_node_pos": [
            [
              25,
              0
            ],
            [
              100,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(libvpx_test::kTwoPassGood);\n  }",
          "fn_code_pos": [
            [
              54,
              2
            ],
            [
              57,
              3
            ]
          ],
          "class_code": "5c698993593ad2965fe2f65f1e9df541d98805f5bb25dd0976cb38a2e7f57de8",
          "class_node_pos": [
            [
              25,
              0
            ],
            [
              100,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void BeginPassHook(unsigned int /*pass*/) {\n    file_size_ = 0;\n    psnr_ = 0.0;\n    n_frames_ = 0;\n  }",
          "fn_code_pos": [
            [
              59,
              2
            ],
            [
              63,
              3
            ]
          ],
          "class_code": "5c698993593ad2965fe2f65f1e9df541d98805f5bb25dd0976cb38a2e7f57de8",
          "class_node_pos": [
            [
              25,
              0
            ],
            [
              100,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BeginPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                                  libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      if (cfg_.rc_end_usage == VPX_CQ) {\n        encoder->Control(VP8E_SET_CQ_LEVEL, cq_level_);\n      }\n      encoder->Control(VP8E_SET_CPUUSED, 3);\n    }\n  }",
          "fn_code_pos": [
            [
              65,
              2
            ],
            [
              73,
              3
            ]
          ],
          "class_code": "5c698993593ad2965fe2f65f1e9df541d98805f5bb25dd0976cb38a2e7f57de8",
          "class_node_pos": [
            [
              25,
              0
            ],
            [
              100,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "libvpx_test::VideoSource",
              "encoder": "libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    psnr_ += pow(10.0, pkt->data.psnr.psnr[0] / 10.0);\n    n_frames_++;\n  }",
          "fn_code_pos": [
            [
              75,
              2
            ],
            [
              78,
              3
            ]
          ],
          "class_code": "5c698993593ad2965fe2f65f1e9df541d98805f5bb25dd0976cb38a2e7f57de8",
          "class_node_pos": [
            [
              25,
              0
            ],
            [
              100,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PSNRPktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    file_size_ += pkt->data.frame.sz;\n  }",
          "fn_code_pos": [
            [
              80,
              2
            ],
            [
              82,
              3
            ]
          ],
          "class_code": "5c698993593ad2965fe2f65f1e9df541d98805f5bb25dd0976cb38a2e7f57de8",
          "class_node_pos": [
            [
              25,
              0
            ],
            [
              100,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "double GetLinearPSNROverBitrate() const {\n    double avg_psnr = log10(psnr_ / n_frames_) * 10.0;\n    return pow(10.0, avg_psnr / 10.0) / file_size_;\n  }",
          "fn_code_pos": [
            [
              84,
              2
            ],
            [
              87,
              3
            ]
          ],
          "class_code": "5c698993593ad2965fe2f65f1e9df541d98805f5bb25dd0976cb38a2e7f57de8",
          "class_node_pos": [
            [
              25,
              0
            ],
            [
              100,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetLinearPSNROverBitrate",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "int cq_level() const { return cq_level_; }",
          "fn_code_pos": [
            [
              89,
              2
            ],
            [
              89,
              44
            ]
          ],
          "class_code": "5c698993593ad2965fe2f65f1e9df541d98805f5bb25dd0976cb38a2e7f57de8",
          "class_node_pos": [
            [
              25,
              0
            ],
            [
              100,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "cq_level",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "size_t file_size() const { return file_size_; }",
          "fn_code_pos": [
            [
              90,
              2
            ],
            [
              90,
              49
            ]
          ],
          "class_code": "5c698993593ad2965fe2f65f1e9df541d98805f5bb25dd0976cb38a2e7f57de8",
          "class_node_pos": [
            [
              25,
              0
            ],
            [
              100,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "file_size",
            "parameters": {},
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "int n_frames() const { return n_frames_; }",
          "fn_code_pos": [
            [
              91,
              2
            ],
            [
              91,
              44
            ]
          ],
          "class_code": "5c698993593ad2965fe2f65f1e9df541d98805f5bb25dd0976cb38a2e7f57de8",
          "class_node_pos": [
            [
              25,
              0
            ],
            [
              100,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "n_frames",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TEST_P(CQTest, LinearPSNRIsHigherForCQLevel) {\n  const vpx_rational timebase = { 33333333, 1000000000 };\n  cfg_.g_timebase = timebase;\n  cfg_.rc_target_bitrate = kCQTargetBitrate;\n  cfg_.g_lag_in_frames = 25;\n\n  cfg_.rc_end_usage = VPX_CQ;\n  libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                     timebase.den, timebase.num, 0, 30);\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  const double cq_psnr_lin = GetLinearPSNROverBitrate();\n  const unsigned int cq_actual_bitrate =\n      static_cast<unsigned int>(file_size()) * 8 * 30 / (n_frames() * 1000);\n  EXPECT_LE(cq_actual_bitrate, kCQTargetBitrate);\n  bitrates_[cq_level()] = cq_actual_bitrate;\n\n  // try targeting the approximate same bitrate with VBR mode\n  cfg_.rc_end_usage = VPX_VBR;\n  cfg_.rc_target_bitrate = cq_actual_bitrate;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  const double vbr_psnr_lin = GetLinearPSNROverBitrate();\n  EXPECT_GE(cq_psnr_lin, vbr_psnr_lin);\n}",
          "fn_code_pos": [
            [
              104,
              0
            ],
            [
              126,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "5c698993593ad2965fe2f65f1e9df541d98805f5bb25dd0976cb38a2e7f57de8": {
          "class_code": "class CQTest : public ::libvpx_test::EncoderTest,\n               public ::libvpx_test::CodecTestWithParam<int> {\n public:\n  // maps the cqlevel to the bitrate produced.\n  typedef std::map<int, uint32_t> BitrateMap;\n\n  static void SetUpTestCase() { bitrates_.clear(); }\n\n  static void TearDownTestCase() {\n    ASSERT_TRUE(!HasFailure())\n        << \"skipping bitrate validation due to earlier failure.\";\n    uint32_t prev_actual_bitrate = kCQTargetBitrate;\n    for (BitrateMap::const_iterator iter = bitrates_.begin();\n         iter != bitrates_.end(); ++iter) {\n      const uint32_t cq_actual_bitrate = iter->second;\n      EXPECT_LE(cq_actual_bitrate, prev_actual_bitrate)\n          << \"cq_level: \" << iter->first\n          << \", bitrate should decrease with increase in CQ level.\";\n      prev_actual_bitrate = cq_actual_bitrate;\n    }\n  }\n\n protected:\n  CQTest() : EncoderTest(GET_PARAM(0)), cq_level_(GET_PARAM(1)) {\n    init_flags_ = VPX_CODEC_USE_PSNR;\n  }\n\n  virtual ~CQTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(libvpx_test::kTwoPassGood);\n  }\n\n  virtual void BeginPassHook(unsigned int /*pass*/) {\n    file_size_ = 0;\n    psnr_ = 0.0;\n    n_frames_ = 0;\n  }\n\n  virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                                  libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      if (cfg_.rc_end_usage == VPX_CQ) {\n        encoder->Control(VP8E_SET_CQ_LEVEL, cq_level_);\n      }\n      encoder->Control(VP8E_SET_CPUUSED, 3);\n    }\n  }\n\n  virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    psnr_ += pow(10.0, pkt->data.psnr.psnr[0] / 10.0);\n    n_frames_++;\n  }\n\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    file_size_ += pkt->data.frame.sz;\n  }\n\n  double GetLinearPSNROverBitrate() const {\n    double avg_psnr = log10(psnr_ / n_frames_) * 10.0;\n    return pow(10.0, avg_psnr / 10.0) / file_size_;\n  }\n\n  int cq_level() const { return cq_level_; }\n  size_t file_size() const { return file_size_; }\n  int n_frames() const { return n_frames_; }\n\n  static BitrateMap bitrates_;\n\n private:\n  int cq_level_;\n  size_t file_size_;\n  double psnr_;\n  int n_frames_;\n}",
          "class_name": "CQTest",
          "class_pos": [
            [
              25,
              0
            ],
            [
              100,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <cmath>\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include <map>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp9_denoiser_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "virtual ~VP9DenoiserTest() {}",
          "fn_code_pos": [
            [
              44,
              2
            ],
            [
              44,
              31
            ]
          ],
          "class_code": "78399f845cef82e21e6ca68ee59dfdbc840a1f107365e342fc04622888cf1972",
          "class_node_pos": [
            [
              40,
              0
            ],
            [
              52,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() { bs_ = GET_PARAM(1); }",
          "fn_code_pos": [
            [
              46,
              2
            ],
            [
              46,
              46
            ]
          ],
          "class_code": "78399f845cef82e21e6ca68ee59dfdbc840a1f107365e342fc04622888cf1972",
          "class_node_pos": [
            [
              40,
              0
            ],
            [
              52,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              48,
              2
            ],
            [
              48,
              62
            ]
          ],
          "class_code": "78399f845cef82e21e6ca68ee59dfdbc840a1f107365e342fc04622888cf1972",
          "class_node_pos": [
            [
              40,
              0
            ],
            [
              52,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(VP9DenoiserTest, BitexactCheck) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  const int count_test_block = 4000;\n\n  // Allocate the space for input and output,\n  // where sig_block is the block to be denoised,\n  // mc_avg_block is the denoised reference block,\n  // avg_block_c is the denoised result from C code,\n  // avg_block_sse2 is the denoised result from SSE2 code.\n  DECLARE_ALIGNED(16, uint8_t, sig_block[kNumPixels]);\n  DECLARE_ALIGNED(16, uint8_t, mc_avg_block[kNumPixels]);\n  DECLARE_ALIGNED(16, uint8_t, avg_block_c[kNumPixels]);\n  DECLARE_ALIGNED(16, uint8_t, avg_block_sse2[kNumPixels]);\n\n  for (int i = 0; i < count_test_block; ++i) {\n    // Generate random motion magnitude, 20% of which exceed the threshold.\n    const int motion_magnitude_random =\n        rnd.Rand8() % static_cast<int>(MOTION_MAGNITUDE_THRESHOLD * 1.2);\n\n    // Initialize a test block with random number in range [0, 255].\n    for (int j = 0; j < kNumPixels; ++j) {\n      int temp = 0;\n      sig_block[j] = rnd.Rand8();\n      // The pixels in mc_avg_block are generated by adding a random\n      // number in range [-19, 19] to corresponding pixels in sig_block.\n      temp =\n          sig_block[j] + ((rnd.Rand8() % 2 == 0) ? -1 : 1) * (rnd.Rand8() % 20);\n      // Clip.\n      mc_avg_block[j] = (temp < 0) ? 0 : ((temp > 255) ? 255 : temp);\n    }\n\n    ASM_REGISTER_STATE_CHECK(vp9_denoiser_filter_c(sig_block, 64, mc_avg_block,\n                                                   64, avg_block_c, 64, 0, bs_,\n                                                   motion_magnitude_random));\n\n    ASM_REGISTER_STATE_CHECK(GET_PARAM(0)(sig_block, 64, mc_avg_block, 64,\n                                          avg_block_sse2, 64, 0, bs_,\n                                          motion_magnitude_random));\n\n    // Test bitexactness.\n    for (int h = 0; h < (4 << b_height_log2_lookup[bs_]); ++h) {\n      for (int w = 0; w < (4 << b_width_log2_lookup[bs_]); ++w) {\n        EXPECT_EQ(avg_block_c[h * 64 + w], avg_block_sse2[h * 64 + w]);\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              54,
              0
            ],
            [
              100,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*Vp9DenoiserFilterFunc)(const uint8_t *sig, int sig_stride,\n                                     const uint8_t *mc_avg, int mc_avg_stride,\n                                     uint8_t *avg, int avg_stride,\n                                     int increase_denoising, BLOCK_SIZE bs,\n                                     int motion_magnitude)",
          "fn_dec_pos": [
            [
              33,
              12
            ],
            [
              37,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "sig": "uint8_t",
              "sig_stride": "int",
              "mc_avg": "uint8_t",
              "mc_avg_stride": "int",
              "avg": "uint8_t",
              "avg_stride": "int",
              "increase_denoising": "int",
              "bs": "BLOCK_SIZE",
              "motion_magnitude": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              55,
              12
            ],
            [
              55,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        }
      ],
      "class_node_list": {
        "78399f845cef82e21e6ca68ee59dfdbc840a1f107365e342fc04622888cf1972": {
          "class_code": "class VP9DenoiserTest\n    : public ::testing::Test,\n      public ::testing::WithParamInterface<VP9DenoiserTestParam> {\n public:\n  virtual ~VP9DenoiserTest() {}\n\n  virtual void SetUp() { bs_ = GET_PARAM(1); }\n\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  BLOCK_SIZE bs_;\n}",
          "class_name": "VP9DenoiserTest",
          "class_pos": [
            [
              40,
              0
            ],
            [
              52,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <math.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"vpx_scale/yv12config.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_reconinter.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"vp9/encoder/vp9_context_tree.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"vp9/encoder/vp9_denoiser.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/altref_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "AltRefTest() : EncoderTest(GET_PARAM(0)), altref_count_(0) {}",
          "fn_code_pos": [
            [
              25,
              2
            ],
            [
              25,
              63
            ]
          ],
          "class_code": "521beb3dc0a71bf03da997a0bcc5f047ec13995193fbca4c1eaa7aafd4eef3f1",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              51,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "AltRefTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~AltRefTest() {}",
          "fn_code_pos": [
            [
              26,
              2
            ],
            [
              26,
              26
            ]
          ],
          "class_code": "521beb3dc0a71bf03da997a0bcc5f047ec13995193fbca4c1eaa7aafd4eef3f1",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              51,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(libvpx_test::kTwoPassGood);\n  }",
          "fn_code_pos": [
            [
              28,
              2
            ],
            [
              31,
              3
            ]
          ],
          "class_code": "521beb3dc0a71bf03da997a0bcc5f047ec13995193fbca4c1eaa7aafd4eef3f1",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              51,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void BeginPassHook(unsigned int /*pass*/) { altref_count_ = 0; }",
          "fn_code_pos": [
            [
              33,
              2
            ],
            [
              33,
              74
            ]
          ],
          "class_code": "521beb3dc0a71bf03da997a0bcc5f047ec13995193fbca4c1eaa7aafd4eef3f1",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              51,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BeginPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                                  libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n      encoder->Control(VP8E_SET_CPUUSED, 3);\n    }\n  }",
          "fn_code_pos": [
            [
              35,
              2
            ],
            [
              41,
              3
            ]
          ],
          "class_code": "521beb3dc0a71bf03da997a0bcc5f047ec13995193fbca4c1eaa7aafd4eef3f1",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              51,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "libvpx_test::VideoSource",
              "encoder": "libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (pkt->data.frame.flags & VPX_FRAME_IS_INVISIBLE) ++altref_count_;\n  }",
          "fn_code_pos": [
            [
              43,
              2
            ],
            [
              45,
              3
            ]
          ],
          "class_code": "521beb3dc0a71bf03da997a0bcc5f047ec13995193fbca4c1eaa7aafd4eef3f1",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              51,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int altref_count() const { return altref_count_; }",
          "fn_code_pos": [
            [
              47,
              2
            ],
            [
              47,
              52
            ]
          ],
          "class_code": "521beb3dc0a71bf03da997a0bcc5f047ec13995193fbca4c1eaa7aafd4eef3f1",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              51,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "altref_count",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TEST_P(AltRefTest, MonotonicTimestamps) {\n  const vpx_rational timebase = { 33333333, 1000000000 };\n  cfg_.g_timebase = timebase;\n  cfg_.rc_target_bitrate = 1000;\n  cfg_.g_lag_in_frames = GET_PARAM(1);\n\n  libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                     timebase.den, timebase.num, 0, 30);\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  EXPECT_GE(altref_count(), 1);\n}",
          "fn_code_pos": [
            [
              53,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "AltRefForcedKeyTestLarge()\n      : EncoderTest(GET_PARAM(0)), encoding_mode_(GET_PARAM(1)),\n        cpu_used_(GET_PARAM(2)), forced_kf_frame_num_(1), frame_num_(0) {}",
          "fn_code_pos": [
            [
              74,
              2
            ],
            [
              76,
              74
            ]
          ],
          "class_code": "2ccc1d3fb8b3b4cd3f49ca4972781abb886afb1dde7094f292435a13b0996c29",
          "class_node_pos": [
            [
              70,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "AltRefForcedKeyTestLarge",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~AltRefForcedKeyTestLarge() {}",
          "fn_code_pos": [
            [
              77,
              2
            ],
            [
              77,
              40
            ]
          ],
          "class_code": "2ccc1d3fb8b3b4cd3f49ca4972781abb886afb1dde7094f292435a13b0996c29",
          "class_node_pos": [
            [
              70,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n    cfg_.rc_end_usage = VPX_VBR;\n    cfg_.g_threads = 0;\n  }",
          "fn_code_pos": [
            [
              79,
              2
            ],
            [
              84,
              3
            ]
          ],
          "class_code": "2ccc1d3fb8b3b4cd3f49ca4972781abb886afb1dde7094f292435a13b0996c29",
          "class_node_pos": [
            [
              70,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, cpu_used_);\n      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n#if CONFIG_VP9_ENCODER\n      // override test default for tile columns if necessary.\n      if (GET_PARAM(0) == &libvpx_test::kVP9) {\n        encoder->Control(VP9E_SET_TILE_COLUMNS, 6);\n      }\n#endif\n    }\n    frame_flags_ =\n        (video->frame() == forced_kf_frame_num_) ? VPX_EFLAG_FORCE_KF : 0;\n  }",
          "fn_code_pos": [
            [
              86,
              2
            ],
            [
              100,
              3
            ]
          ],
          "class_code": "2ccc1d3fb8b3b4cd3f49ca4972781abb886afb1dde7094f292435a13b0996c29",
          "class_node_pos": [
            [
              70,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (frame_num_ == forced_kf_frame_num_) {\n      ASSERT_TRUE(!!(pkt->data.frame.flags & VPX_FRAME_IS_KEY))\n          << \"Frame #\" << frame_num_ << \" isn't a keyframe!\";\n    }\n    ++frame_num_;\n  }",
          "fn_code_pos": [
            [
              102,
              2
            ],
            [
              108,
              3
            ]
          ],
          "class_code": "2ccc1d3fb8b3b4cd3f49ca4972781abb886afb1dde7094f292435a13b0996c29",
          "class_node_pos": [
            [
              70,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(AltRefForcedKeyTestLarge, Frame1IsKey) {\n  const vpx_rational timebase = { 1, 30 };\n  const int lag_values[] = { 3, 15, 25, -1 };\n\n  forced_kf_frame_num_ = 1;\n  for (int i = 0; lag_values[i] != -1; ++i) {\n    frame_num_ = 0;\n    cfg_.g_lag_in_frames = lag_values[i];\n    libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       timebase.den, timebase.num, 0, 30);\n    ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  }\n}",
          "fn_code_pos": [
            [
              116,
              0
            ],
            [
              128,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(AltRefForcedKeyTestLarge, ForcedFrameIsKey) {\n  const vpx_rational timebase = { 1, 30 };\n  const int lag_values[] = { 3, 15, 25, -1 };\n\n  for (int i = 0; lag_values[i] != -1; ++i) {\n    frame_num_ = 0;\n    forced_kf_frame_num_ = lag_values[i] - 1;\n    cfg_.g_lag_in_frames = lag_values[i];\n    libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       timebase.den, timebase.num, 0, 30);\n    ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  }\n}",
          "fn_code_pos": [
            [
              130,
              0
            ],
            [
              142,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "521beb3dc0a71bf03da997a0bcc5f047ec13995193fbca4c1eaa7aafd4eef3f1": {
          "class_code": "class AltRefTest : public ::libvpx_test::EncoderTest,\n                   public ::libvpx_test::CodecTestWithParam<int> {\n protected:\n  AltRefTest() : EncoderTest(GET_PARAM(0)), altref_count_(0) {}\n  virtual ~AltRefTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(libvpx_test::kTwoPassGood);\n  }\n\n  virtual void BeginPassHook(unsigned int /*pass*/) { altref_count_ = 0; }\n\n  virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                                  libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n      encoder->Control(VP8E_SET_CPUUSED, 3);\n    }\n  }\n\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (pkt->data.frame.flags & VPX_FRAME_IS_INVISIBLE) ++altref_count_;\n  }\n\n  int altref_count() const { return altref_count_; }\n\n private:\n  int altref_count_;\n}",
          "class_name": "AltRefTest",
          "class_pos": [
            [
              22,
              0
            ],
            [
              51,
              1
            ]
          ]
        },
        "2ccc1d3fb8b3b4cd3f49ca4972781abb886afb1dde7094f292435a13b0996c29": {
          "class_code": "class AltRefForcedKeyTestLarge\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWith2Params<libvpx_test::TestMode, int> {\n protected:\n  AltRefForcedKeyTestLarge()\n      : EncoderTest(GET_PARAM(0)), encoding_mode_(GET_PARAM(1)),\n        cpu_used_(GET_PARAM(2)), forced_kf_frame_num_(1), frame_num_(0) {}\n  virtual ~AltRefForcedKeyTestLarge() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n    cfg_.rc_end_usage = VPX_VBR;\n    cfg_.g_threads = 0;\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, cpu_used_);\n      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n#if CONFIG_VP9_ENCODER\n      // override test default for tile columns if necessary.\n      if (GET_PARAM(0) == &libvpx_test::kVP9) {\n        encoder->Control(VP9E_SET_TILE_COLUMNS, 6);\n      }\n#endif\n    }\n    frame_flags_ =\n        (video->frame() == forced_kf_frame_num_) ? VPX_EFLAG_FORCE_KF : 0;\n  }\n\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (frame_num_ == forced_kf_frame_num_) {\n      ASSERT_TRUE(!!(pkt->data.frame.flags & VPX_FRAME_IS_KEY))\n          << \"Frame #\" << frame_num_ << \" isn't a keyframe!\";\n    }\n    ++frame_num_;\n  }\n\n  ::libvpx_test::TestMode encoding_mode_;\n  int cpu_used_;\n  unsigned int forced_kf_frame_num_;\n  unsigned int frame_num_;\n}",
          "class_name": "AltRefForcedKeyTestLarge",
          "class_pos": [
            [
              70,
              0
            ],
            [
              114,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/encode_api_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST(EncodeAPI, InvalidParams) {\n  static const vpx_codec_iface_t *kCodecs[] = {\n#if CONFIG_VP8_ENCODER\n    &vpx_codec_vp8_cx_algo,\n#endif\n#if CONFIG_VP9_ENCODER\n    &vpx_codec_vp9_cx_algo,\n#endif\n  };\n  uint8_t buf[1] = { 0 };\n  vpx_image_t img;\n  vpx_codec_ctx_t enc;\n  vpx_codec_enc_cfg_t cfg;\n\n  EXPECT_EQ(&img, vpx_img_wrap(&img, VPX_IMG_FMT_I420, 1, 1, 1, buf));\n\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, vpx_codec_enc_init(NULL, NULL, NULL, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, vpx_codec_enc_init(&enc, NULL, NULL, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, vpx_codec_encode(NULL, NULL, 0, 0, 0, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, vpx_codec_encode(NULL, &img, 0, 0, 0, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM, vpx_codec_destroy(NULL));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n            vpx_codec_enc_config_default(NULL, NULL, 0));\n  EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n            vpx_codec_enc_config_default(NULL, &cfg, 0));\n  EXPECT_TRUE(vpx_codec_error(NULL) != NULL);\n\n  for (int i = 0; i < NELEMENTS(kCodecs); ++i) {\n    SCOPED_TRACE(vpx_codec_iface_name(kCodecs[i]));\n    EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n              vpx_codec_enc_init(NULL, kCodecs[i], NULL, 0));\n    EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n              vpx_codec_enc_init(&enc, kCodecs[i], NULL, 0));\n    EXPECT_EQ(VPX_CODEC_INVALID_PARAM,\n              vpx_codec_enc_config_default(kCodecs[i], &cfg, 1));\n\n    EXPECT_EQ(VPX_CODEC_OK, vpx_codec_enc_config_default(kCodecs[i], &cfg, 0));\n    EXPECT_EQ(VPX_CODEC_OK, vpx_codec_enc_init(&enc, kCodecs[i], &cfg, 0));\n    EXPECT_EQ(VPX_CODEC_OK, vpx_codec_encode(&enc, NULL, 0, 0, 0, 0));\n\n    EXPECT_EQ(VPX_CODEC_OK, vpx_codec_destroy(&enc));\n  }\n}",
          "fn_code_pos": [
            [
              20,
              0
            ],
            [
              62,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(EncodeAPI, HighBitDepthCapability) {\n// VP8 should not claim VP9 HBD as a capability.\n#if CONFIG_VP8_ENCODER\n  const vpx_codec_caps_t vp8_caps = vpx_codec_get_caps(&vpx_codec_vp8_cx_algo);\n  EXPECT_EQ(vp8_caps & VPX_CODEC_CAP_HIGHBITDEPTH, 0);\n#endif\n\n#if CONFIG_VP9_ENCODER\n  const vpx_codec_caps_t vp9_caps = vpx_codec_get_caps(&vpx_codec_vp9_cx_algo);\n#if CONFIG_VP9_HIGHBITDEPTH\n  EXPECT_EQ(vp9_caps & VPX_CODEC_CAP_HIGHBITDEPTH, VPX_CODEC_CAP_HIGHBITDEPTH);\n#else\n  EXPECT_EQ(vp9_caps & VPX_CODEC_CAP_HIGHBITDEPTH, 0);\n#endif\n#endif\n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(EncodeAPI, ImageSizeSetting) {\n  const int width = 711;\n  const int height = 360;\n  const int bps = 12;\n  vpx_image_t img;\n  vpx_codec_ctx_t enc;\n  vpx_codec_enc_cfg_t cfg;\n  uint8_t *img_buf = reinterpret_cast<uint8_t *>(\n      calloc(width * height * bps / 8, sizeof(*img_buf)));\n  vpx_codec_enc_config_default(vpx_codec_vp8_cx(), &cfg, 0);\n\n  cfg.g_w = width;\n  cfg.g_h = height;\n\n  vpx_img_wrap(&img, VPX_IMG_FMT_I420, width, height, 1, img_buf);\n\n  vpx_codec_enc_init(&enc, vpx_codec_vp8_cx(), &cfg, 0);\n\n  EXPECT_EQ(VPX_CODEC_OK, vpx_codec_encode(&enc, &img, 0, 1, 0, 0));\n\n  free(img_buf);\n\n  vpx_codec_destroy(&enc);\n}",
          "fn_code_pos": [
            [
              82,
              0
            ],
            [
              105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST(EncodeAPI, MultiResEncode) {\n  static const vpx_codec_iface_t *kCodecs[] = {\n#if CONFIG_VP8_ENCODER\n    &vpx_codec_vp8_cx_algo,\n#endif\n#if CONFIG_VP9_ENCODER\n    &vpx_codec_vp9_cx_algo,\n#endif\n  };\n  const int width = 1280;\n  const int height = 720;\n  const int width_down = width / 2;\n  const int height_down = height / 2;\n  const int target_bitrate = 1000;\n  const int framerate = 30;\n\n  for (int c = 0; c < NELEMENTS(kCodecs); ++c) {\n    const vpx_codec_iface_t *const iface = kCodecs[c];\n    vpx_codec_ctx_t enc[2];\n    vpx_codec_enc_cfg_t cfg[2];\n    vpx_rational_t dsf[2] = { { 2, 1 }, { 2, 1 } };\n\n    memset(enc, 0, sizeof(enc));\n\n    for (int i = 0; i < 2; i++) {\n      vpx_codec_enc_config_default(iface, &cfg[i], 0);\n    }\n\n    /* Highest-resolution encoder settings */\n    cfg[0].g_w = width;\n    cfg[0].g_h = height;\n    cfg[0].rc_dropframe_thresh = 0;\n    cfg[0].rc_end_usage = VPX_CBR;\n    cfg[0].rc_resize_allowed = 0;\n    cfg[0].rc_min_quantizer = 2;\n    cfg[0].rc_max_quantizer = 56;\n    cfg[0].rc_undershoot_pct = 100;\n    cfg[0].rc_overshoot_pct = 15;\n    cfg[0].rc_buf_initial_sz = 500;\n    cfg[0].rc_buf_optimal_sz = 600;\n    cfg[0].rc_buf_sz = 1000;\n    cfg[0].g_error_resilient = 1; /* Enable error resilient mode */\n    cfg[0].g_lag_in_frames = 0;\n\n    cfg[0].kf_mode = VPX_KF_AUTO;\n    cfg[0].kf_min_dist = 3000;\n    cfg[0].kf_max_dist = 3000;\n\n    cfg[0].rc_target_bitrate = target_bitrate; /* Set target bitrate */\n    cfg[0].g_timebase.num = 1;                 /* Set fps */\n    cfg[0].g_timebase.den = framerate;\n\n    memcpy(&cfg[1], &cfg[0], sizeof(cfg[0]));\n    cfg[1].rc_target_bitrate = 500;\n    cfg[1].g_w = width_down;\n    cfg[1].g_h = height_down;\n\n    for (int i = 0; i < 2; i++) {\n      cfg[i].ts_number_layers = 2;\n      cfg[i].ts_periodicity = 2;\n      cfg[i].ts_rate_decimator[0] = 2;\n      cfg[i].ts_rate_decimator[1] = 1;\n      cfg[i].ts_layer_id[0] = 0;\n      cfg[i].ts_layer_id[1] = 1;\n      // Invalid parameters.\n      cfg[i].ts_target_bitrate[0] = 0;\n      cfg[i].ts_target_bitrate[1] = 0;\n    }\n\n    // VP9 should report incapable, VP8 invalid for all configurations.\n    const char kVP9Name[] = \"WebM Project VP9\";\n    const bool is_vp9 = strncmp(kVP9Name, vpx_codec_iface_name(iface),\n                                sizeof(kVP9Name) - 1) == 0;\n    EXPECT_EQ(is_vp9 ? VPX_CODEC_INCAPABLE : VPX_CODEC_INVALID_PARAM,\n              vpx_codec_enc_init_multi(&enc[0], iface, &cfg[0], 2, 0, &dsf[0]));\n\n    for (int i = 0; i < 2; i++) {\n      vpx_codec_destroy(&enc[i]);\n    }\n  }\n}",
          "fn_code_pos": [
            [
              112,
              0
            ],
            [
              192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"vpx/vp8cx.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_encoder.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/yuv_temporal_filter_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "template <typename PixelType>\nint GetModIndex(int sum_dist, int index, int rounding, int strength,\n                int filter_weight) {\n  int mod = sum_dist * 3 / index;\n  mod += rounding;\n  mod >>= strength;\n\n  mod = VPXMIN(16, mod);\n\n  mod = 16 - mod;\n  mod *= filter_weight;\n\n  return mod;\n}",
          "fn_code_pos": [
            [
              54,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <>\nint GetModIndex<uint8_t>(int sum_dist, int index, int rounding, int strength,\n                         int filter_weight) {\n  unsigned int index_mult[14] = {\n    0, 0, 0, 0, 49152, 39322, 32768, 28087, 24576, 21846, 19661, 17874, 0, 15124\n  };\n\n  assert(index >= 0 && index <= 13);\n  assert(index_mult[index] != 0);\n\n  int mod = (clamp(sum_dist, 0, UINT16_MAX) * index_mult[index]) >> 16;\n  mod += rounding;\n  mod >>= strength;\n\n  mod = VPXMIN(16, mod);\n\n  mod = 16 - mod;\n  mod *= filter_weight;\n\n  return mod;\n}",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              89,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <>\nint GetModIndex<uint16_t>(int sum_dist, int index, int rounding, int strength,\n                          int filter_weight) {\n  int64_t index_mult[14] = { 0U,          0U,          0U,          0U,\n                             3221225472U, 2576980378U, 2147483648U, 1840700270U,\n                             1610612736U, 1431655766U, 1288490189U, 1171354718U,\n                             0U,          991146300U };\n\n  assert(index >= 0 && index <= 13);\n  assert(index_mult[index] != 0);\n\n  int mod = static_cast<int>((sum_dist * index_mult[index]) >> 32);\n  mod += rounding;\n  mod >>= strength;\n\n  mod = VPXMIN(16, mod);\n\n  mod = 16 - mod;\n  mod *= filter_weight;\n\n  return mod;\n}",
          "fn_code_pos": [
            [
              91,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename PixelType>\nvoid ApplyReferenceFilter(\n    const Buffer<PixelType> &y_src, const Buffer<PixelType> &y_pre,\n    const Buffer<PixelType> &u_src, const Buffer<PixelType> &v_src,\n    const Buffer<PixelType> &u_pre, const Buffer<PixelType> &v_pre,\n    unsigned int block_width, unsigned int block_height, int ss_x, int ss_y,\n    int strength, const int *const blk_fw, int use_32x32,\n    Buffer<uint32_t> *y_accumulator, Buffer<uint16_t> *y_counter,\n    Buffer<uint32_t> *u_accumulator, Buffer<uint16_t> *u_counter,\n    Buffer<uint32_t> *v_accumulator, Buffer<uint16_t> *v_counter) {\n  const PixelType *y_src_ptr = y_src.TopLeftPixel();\n  const PixelType *y_pre_ptr = y_pre.TopLeftPixel();\n  const PixelType *u_src_ptr = u_src.TopLeftPixel();\n  const PixelType *u_pre_ptr = u_pre.TopLeftPixel();\n  const PixelType *v_src_ptr = v_src.TopLeftPixel();\n  const PixelType *v_pre_ptr = v_pre.TopLeftPixel();\n\n  const int uv_block_width = block_width >> ss_x,\n            uv_block_height = block_height >> ss_y;\n  const int y_src_stride = y_src.stride(), y_pre_stride = y_pre.stride();\n  const int uv_src_stride = u_src.stride(), uv_pre_stride = u_pre.stride();\n  const int y_diff_stride = block_width, uv_diff_stride = uv_block_width;\n\n  Buffer<int> y_dif = Buffer<int>(block_width, block_height, 0);\n  Buffer<int> u_dif = Buffer<int>(uv_block_width, uv_block_height, 0);\n  Buffer<int> v_dif = Buffer<int>(uv_block_width, uv_block_height, 0);\n\n  ASSERT_TRUE(y_dif.Init());\n  ASSERT_TRUE(u_dif.Init());\n  ASSERT_TRUE(v_dif.Init());\n  y_dif.Set(0);\n  u_dif.Set(0);\n  v_dif.Set(0);\n\n  int *y_diff_ptr = y_dif.TopLeftPixel();\n  int *u_diff_ptr = u_dif.TopLeftPixel();\n  int *v_diff_ptr = v_dif.TopLeftPixel();\n\n  uint32_t *y_accum = y_accumulator->TopLeftPixel();\n  uint32_t *u_accum = u_accumulator->TopLeftPixel();\n  uint32_t *v_accum = v_accumulator->TopLeftPixel();\n  uint16_t *y_count = y_counter->TopLeftPixel();\n  uint16_t *u_count = u_counter->TopLeftPixel();\n  uint16_t *v_count = v_counter->TopLeftPixel();\n\n  const int y_accum_stride = y_accumulator->stride();\n  const int u_accum_stride = u_accumulator->stride();\n  const int v_accum_stride = v_accumulator->stride();\n  const int y_count_stride = y_counter->stride();\n  const int u_count_stride = u_counter->stride();\n  const int v_count_stride = v_counter->stride();\n\n  const int rounding = (1 << strength) >> 1;\n\n  // Get the square diffs\n  for (int row = 0; row < static_cast<int>(block_height); row++) {\n    for (int col = 0; col < static_cast<int>(block_width); col++) {\n      const int diff = y_src_ptr[row * y_src_stride + col] -\n                       y_pre_ptr[row * y_pre_stride + col];\n      y_diff_ptr[row * y_diff_stride + col] = diff * diff;\n    }\n  }\n\n  for (int row = 0; row < uv_block_height; row++) {\n    for (int col = 0; col < uv_block_width; col++) {\n      const int u_diff = u_src_ptr[row * uv_src_stride + col] -\n                         u_pre_ptr[row * uv_pre_stride + col];\n      const int v_diff = v_src_ptr[row * uv_src_stride + col] -\n                         v_pre_ptr[row * uv_pre_stride + col];\n      u_diff_ptr[row * uv_diff_stride + col] = u_diff * u_diff;\n      v_diff_ptr[row * uv_diff_stride + col] = v_diff * v_diff;\n    }\n  }\n\n  // Apply the filter to luma\n  for (int row = 0; row < static_cast<int>(block_height); row++) {\n    for (int col = 0; col < static_cast<int>(block_width); col++) {\n      const int uv_row = row >> ss_y;\n      const int uv_col = col >> ss_x;\n      const int filter_weight = GetFilterWeight(row, col, block_height,\n                                                block_width, blk_fw, use_32x32);\n\n      // First we get the modifier for the current y pixel\n      const int y_pixel = y_pre_ptr[row * y_pre_stride + col];\n      int y_num_used = 0;\n      int y_mod = 0;\n\n      // Sum the neighboring 3x3 y pixels\n      for (int row_step = -1; row_step <= 1; row_step++) {\n        for (int col_step = -1; col_step <= 1; col_step++) {\n          const int sub_row = row + row_step;\n          const int sub_col = col + col_step;\n\n          if (sub_row >= 0 && sub_row < static_cast<int>(block_height) &&\n              sub_col >= 0 && sub_col < static_cast<int>(block_width)) {\n            y_mod += y_diff_ptr[sub_row * y_diff_stride + sub_col];\n            y_num_used++;\n          }\n        }\n      }\n\n      // Sum the corresponding uv pixels to the current y modifier\n      // Note we are rounding down instead of rounding to the nearest pixel.\n      y_mod += u_diff_ptr[uv_row * uv_diff_stride + uv_col];\n      y_mod += v_diff_ptr[uv_row * uv_diff_stride + uv_col];\n\n      y_num_used += 2;\n\n      // Set the modifier\n      y_mod = GetModIndex<PixelType>(y_mod, y_num_used, rounding, strength,\n                                     filter_weight);\n\n      // Accumulate the result\n      y_count[row * y_count_stride + col] += y_mod;\n      y_accum[row * y_accum_stride + col] += y_mod * y_pixel;\n    }\n  }\n\n  // Apply the filter to chroma\n  for (int uv_row = 0; uv_row < uv_block_height; uv_row++) {\n    for (int uv_col = 0; uv_col < uv_block_width; uv_col++) {\n      const int y_row = uv_row << ss_y;\n      const int y_col = uv_col << ss_x;\n      const int filter_weight = GetFilterWeight(\n          uv_row, uv_col, uv_block_height, uv_block_width, blk_fw, use_32x32);\n\n      const int u_pixel = u_pre_ptr[uv_row * uv_pre_stride + uv_col];\n      const int v_pixel = v_pre_ptr[uv_row * uv_pre_stride + uv_col];\n\n      int uv_num_used = 0;\n      int u_mod = 0, v_mod = 0;\n\n      // Sum the neighboring 3x3 chromal pixels to the chroma modifier\n      for (int row_step = -1; row_step <= 1; row_step++) {\n        for (int col_step = -1; col_step <= 1; col_step++) {\n          const int sub_row = uv_row + row_step;\n          const int sub_col = uv_col + col_step;\n\n          if (sub_row >= 0 && sub_row < uv_block_height && sub_col >= 0 &&\n              sub_col < uv_block_width) {\n            u_mod += u_diff_ptr[sub_row * uv_diff_stride + sub_col];\n            v_mod += v_diff_ptr[sub_row * uv_diff_stride + sub_col];\n            uv_num_used++;\n          }\n        }\n      }\n\n      // Sum all the luma pixels associated with the current luma pixel\n      for (int row_step = 0; row_step < 1 + ss_y; row_step++) {\n        for (int col_step = 0; col_step < 1 + ss_x; col_step++) {\n          const int sub_row = y_row + row_step;\n          const int sub_col = y_col + col_step;\n          const int y_diff = y_diff_ptr[sub_row * y_diff_stride + sub_col];\n\n          u_mod += y_diff;\n          v_mod += y_diff;\n          uv_num_used++;\n        }\n      }\n\n      // Set the modifier\n      u_mod = GetModIndex<PixelType>(u_mod, uv_num_used, rounding, strength,\n                                     filter_weight);\n      v_mod = GetModIndex<PixelType>(v_mod, uv_num_used, rounding, strength,\n                                     filter_weight);\n\n      // Accumulate the result\n      u_count[uv_row * u_count_stride + uv_col] += u_mod;\n      u_accum[uv_row * u_accum_stride + uv_col] += u_mod * u_pixel;\n      v_count[uv_row * v_count_stride + uv_col] += v_mod;\n      v_accum[uv_row * v_accum_stride + uv_col] += v_mod * v_pixel;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              287,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename PixelType>\nvoid YUVTemporalFilterTest::CompareTestWithParam(int width, int height,\n                                                 int ss_x, int ss_y,\n                                                 int filter_strength,\n                                                 int use_32x32,\n                                                 const int *filter_weight) {\n  const int uv_width = width >> ss_x, uv_height = height >> ss_y;\n\n  Buffer<PixelType> y_src = Buffer<PixelType>(width, height, 0);\n  Buffer<PixelType> y_pre = Buffer<PixelType>(width, height, 0);\n  Buffer<uint16_t> y_count_ref = Buffer<uint16_t>(width, height, 0);\n  Buffer<uint32_t> y_accum_ref = Buffer<uint32_t>(width, height, 0);\n  Buffer<uint16_t> y_count_tst = Buffer<uint16_t>(width, height, 0);\n  Buffer<uint32_t> y_accum_tst = Buffer<uint32_t>(width, height, 0);\n\n  Buffer<PixelType> u_src = Buffer<PixelType>(uv_width, uv_height, 0);\n  Buffer<PixelType> u_pre = Buffer<PixelType>(uv_width, uv_height, 0);\n  Buffer<uint16_t> u_count_ref = Buffer<uint16_t>(uv_width, uv_height, 0);\n  Buffer<uint32_t> u_accum_ref = Buffer<uint32_t>(uv_width, uv_height, 0);\n  Buffer<uint16_t> u_count_tst = Buffer<uint16_t>(uv_width, uv_height, 0);\n  Buffer<uint32_t> u_accum_tst = Buffer<uint32_t>(uv_width, uv_height, 0);\n\n  Buffer<PixelType> v_src = Buffer<PixelType>(uv_width, uv_height, 0);\n  Buffer<PixelType> v_pre = Buffer<PixelType>(uv_width, uv_height, 0);\n  Buffer<uint16_t> v_count_ref = Buffer<uint16_t>(uv_width, uv_height, 0);\n  Buffer<uint32_t> v_accum_ref = Buffer<uint32_t>(uv_width, uv_height, 0);\n  Buffer<uint16_t> v_count_tst = Buffer<uint16_t>(uv_width, uv_height, 0);\n  Buffer<uint32_t> v_accum_tst = Buffer<uint32_t>(uv_width, uv_height, 0);\n\n  ASSERT_TRUE(y_src.Init());\n  ASSERT_TRUE(y_pre.Init());\n  ASSERT_TRUE(y_count_ref.Init());\n  ASSERT_TRUE(y_accum_ref.Init());\n  ASSERT_TRUE(y_count_tst.Init());\n  ASSERT_TRUE(y_accum_tst.Init());\n  ASSERT_TRUE(u_src.Init());\n  ASSERT_TRUE(u_pre.Init());\n  ASSERT_TRUE(u_count_ref.Init());\n  ASSERT_TRUE(u_accum_ref.Init());\n  ASSERT_TRUE(u_count_tst.Init());\n  ASSERT_TRUE(u_accum_tst.Init());\n\n  ASSERT_TRUE(v_src.Init());\n  ASSERT_TRUE(v_pre.Init());\n  ASSERT_TRUE(v_count_ref.Init());\n  ASSERT_TRUE(v_accum_ref.Init());\n  ASSERT_TRUE(v_count_tst.Init());\n  ASSERT_TRUE(v_accum_tst.Init());\n\n  y_accum_ref.Set(0);\n  y_accum_tst.Set(0);\n  y_count_ref.Set(0);\n  y_count_tst.Set(0);\n  u_accum_ref.Set(0);\n  u_accum_tst.Set(0);\n  u_count_ref.Set(0);\n  u_count_tst.Set(0);\n  v_accum_ref.Set(0);\n  v_accum_tst.Set(0);\n  v_count_ref.Set(0);\n  v_count_tst.Set(0);\n\n  for (int repeats = 0; repeats < num_repeats_; repeats++) {\n    if (saturate_test_) {\n      const int max_val = (1 << bd_) - 1;\n      y_src.Set(max_val);\n      y_pre.Set(0);\n      u_src.Set(max_val);\n      u_pre.Set(0);\n      v_src.Set(max_val);\n      v_pre.Set(0);\n    } else {\n      y_src.Set(&rnd_, 0, 7 << (bd_ - 8));\n      y_pre.Set(&rnd_, 0, 7 << (bd_ - 8));\n      u_src.Set(&rnd_, 0, 7 << (bd_ - 8));\n      u_pre.Set(&rnd_, 0, 7 << (bd_ - 8));\n      v_src.Set(&rnd_, 0, 7 << (bd_ - 8));\n      v_pre.Set(&rnd_, 0, 7 << (bd_ - 8));\n    }\n\n    ApplyReferenceFilter<PixelType>(\n        y_src, y_pre, u_src, v_src, u_pre, v_pre, width, height, ss_x, ss_y,\n        filter_strength, filter_weight, use_32x32, &y_accum_ref, &y_count_ref,\n        &u_accum_ref, &u_count_ref, &v_accum_ref, &v_count_ref);\n\n    ASM_REGISTER_STATE_CHECK(filter_func_(\n        reinterpret_cast<const uint8_t *>(y_src.TopLeftPixel()), y_src.stride(),\n        reinterpret_cast<const uint8_t *>(y_pre.TopLeftPixel()), y_pre.stride(),\n        reinterpret_cast<const uint8_t *>(u_src.TopLeftPixel()),\n        reinterpret_cast<const uint8_t *>(v_src.TopLeftPixel()), u_src.stride(),\n        reinterpret_cast<const uint8_t *>(u_pre.TopLeftPixel()),\n        reinterpret_cast<const uint8_t *>(v_pre.TopLeftPixel()), u_pre.stride(),\n        width, height, ss_x, ss_y, filter_strength, filter_weight, use_32x32,\n        y_accum_tst.TopLeftPixel(), y_count_tst.TopLeftPixel(),\n        u_accum_tst.TopLeftPixel(), u_count_tst.TopLeftPixel(),\n        v_accum_tst.TopLeftPixel(), v_count_tst.TopLeftPixel()));\n\n    EXPECT_TRUE(y_accum_tst.CheckValues(y_accum_ref));\n    EXPECT_TRUE(y_count_tst.CheckValues(y_count_ref));\n    EXPECT_TRUE(u_accum_tst.CheckValues(u_accum_ref));\n    EXPECT_TRUE(u_count_tst.CheckValues(u_count_ref));\n    EXPECT_TRUE(v_accum_tst.CheckValues(v_accum_ref));\n    EXPECT_TRUE(v_count_tst.CheckValues(v_count_ref));\n\n    if (HasFailure()) {\n      if (use_32x32) {\n        printf(\"SS_X: %d, SS_Y: %d, Strength: %d, Weight: %d\\n\", ss_x, ss_y,\n               filter_strength, *filter_weight);\n      } else {\n        printf(\"SS_X: %d, SS_Y: %d, Strength: %d, Weights: %d,%d,%d,%d\\n\", ss_x,\n               ss_y, filter_strength, filter_weight[0], filter_weight[1],\n               filter_weight[2], filter_weight[3]);\n      }\n      y_accum_tst.PrintDifference(y_accum_ref);\n      y_count_tst.PrintDifference(y_count_ref);\n      u_accum_tst.PrintDifference(u_accum_ref);\n      u_count_tst.PrintDifference(u_count_ref);\n      v_accum_tst.PrintDifference(v_accum_ref);\n      v_count_tst.PrintDifference(v_count_ref);\n\n      return;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              321,
              0
            ],
            [
              444,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename PixelType>\nvoid YUVTemporalFilterTest::RunTestFilterWithParam(int width, int height,\n                                                   int ss_x, int ss_y,\n                                                   int filter_strength,\n                                                   int use_32x32,\n                                                   const int *filter_weight) {\n  const int uv_width = width >> ss_x, uv_height = height >> ss_y;\n\n  Buffer<PixelType> y_src = Buffer<PixelType>(width, height, 0);\n  Buffer<PixelType> y_pre = Buffer<PixelType>(width, height, 0);\n  Buffer<uint16_t> y_count = Buffer<uint16_t>(width, height, 0);\n  Buffer<uint32_t> y_accum = Buffer<uint32_t>(width, height, 0);\n\n  Buffer<PixelType> u_src = Buffer<PixelType>(uv_width, uv_height, 0);\n  Buffer<PixelType> u_pre = Buffer<PixelType>(uv_width, uv_height, 0);\n  Buffer<uint16_t> u_count = Buffer<uint16_t>(uv_width, uv_height, 0);\n  Buffer<uint32_t> u_accum = Buffer<uint32_t>(uv_width, uv_height, 0);\n\n  Buffer<PixelType> v_src = Buffer<PixelType>(uv_width, uv_height, 0);\n  Buffer<PixelType> v_pre = Buffer<PixelType>(uv_width, uv_height, 0);\n  Buffer<uint16_t> v_count = Buffer<uint16_t>(uv_width, uv_height, 0);\n  Buffer<uint32_t> v_accum = Buffer<uint32_t>(uv_width, uv_height, 0);\n\n  ASSERT_TRUE(y_src.Init());\n  ASSERT_TRUE(y_pre.Init());\n  ASSERT_TRUE(y_count.Init());\n  ASSERT_TRUE(y_accum.Init());\n\n  ASSERT_TRUE(u_src.Init());\n  ASSERT_TRUE(u_pre.Init());\n  ASSERT_TRUE(u_count.Init());\n  ASSERT_TRUE(u_accum.Init());\n\n  ASSERT_TRUE(v_src.Init());\n  ASSERT_TRUE(v_pre.Init());\n  ASSERT_TRUE(v_count.Init());\n  ASSERT_TRUE(v_accum.Init());\n\n  y_accum.Set(0);\n  y_count.Set(0);\n\n  u_accum.Set(0);\n  u_count.Set(0);\n\n  v_accum.Set(0);\n  v_count.Set(0);\n\n  y_src.Set(&rnd_, 0, 7 << (bd_ - 8));\n  y_pre.Set(&rnd_, 0, 7 << (bd_ - 8));\n  u_src.Set(&rnd_, 0, 7 << (bd_ - 8));\n  u_pre.Set(&rnd_, 0, 7 << (bd_ - 8));\n  v_src.Set(&rnd_, 0, 7 << (bd_ - 8));\n  v_pre.Set(&rnd_, 0, 7 << (bd_ - 8));\n\n  for (int repeats = 0; repeats < num_repeats_; repeats++) {\n    ASM_REGISTER_STATE_CHECK(filter_func_(\n        reinterpret_cast<const uint8_t *>(y_src.TopLeftPixel()), y_src.stride(),\n        reinterpret_cast<const uint8_t *>(y_pre.TopLeftPixel()), y_pre.stride(),\n        reinterpret_cast<const uint8_t *>(u_src.TopLeftPixel()),\n        reinterpret_cast<const uint8_t *>(v_src.TopLeftPixel()), u_src.stride(),\n        reinterpret_cast<const uint8_t *>(u_pre.TopLeftPixel()),\n        reinterpret_cast<const uint8_t *>(v_pre.TopLeftPixel()), u_pre.stride(),\n        width, height, ss_x, ss_y, filter_strength, filter_weight, use_32x32,\n        y_accum.TopLeftPixel(), y_count.TopLeftPixel(), u_accum.TopLeftPixel(),\n        u_count.TopLeftPixel(), v_accum.TopLeftPixel(),\n        v_count.TopLeftPixel()));\n  }\n}",
          "fn_code_pos": [
            [
              446,
              0
            ],
            [
              513,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TemporalFilterWithBd(YUVTemporalFilterFunc func, int bitdepth)\n      : temporal_filter(func), bd(bitdepth) {}",
          "fn_code_pos": [
            [
              33,
              2
            ],
            [
              34,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TemporalFilterWithBd",
            "parameters": {
              "func": "YUVTemporalFilterFunc",
              "bitdepth": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::ostream &operator<<(std::ostream &os, const TemporalFilterWithBd &tf) {\n  return os << \"Bitdepth: \" << tf.bd;\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              42,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "int GetFilterWeight(unsigned int row, unsigned int col,\n                    unsigned int block_height, unsigned int block_width,\n                    const int *const blk_fw, int use_32x32) {\n  if (use_32x32) {\n    return blk_fw[0];\n  }\n\n  return blk_fw[2 * (row >= block_height / 2) + (col >= block_width / 2)];\n}",
          "fn_code_pos": [
            [
              44,
              0
            ],
            [
              52,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetFilterWeight",
            "parameters": {
              "row": "unsigned int",
              "col": "unsigned int",
              "block_height": "unsigned int",
              "block_width": "unsigned int",
              "blk_fw": "int",
              "use_32x32": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    filter_func_ = GetParam().temporal_filter;\n    bd_ = GetParam().bd;\n    use_highbd_ = (bd_ != 8);\n\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n    saturate_test_ = 0;\n    num_repeats_ = 10;\n\n    ASSERT_TRUE(bd_ == 8 || bd_ == 10 || bd_ == 12);\n  }",
          "fn_code_pos": [
            [
              292,
              2
            ],
            [
              302,
              3
            ]
          ],
          "class_code": "5c3c79008a280ddf1fd32d4e309e18acc4e41e38c65a0e51ae22b49e5b646939",
          "class_node_pos": [
            [
              289,
              0
            ],
            [
              319,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(YUVTemporalFilterTest, Use32x32) {\n  const int width = 32, height = 32;\n  const int use_32x32 = 1;\n\n  for (int ss_x = 0; ss_x <= 1; ss_x++) {\n    for (int ss_y = 0; ss_y <= 1; ss_y++) {\n      for (int filter_strength = 0; filter_strength <= 6;\n           filter_strength += 2) {\n        for (int filter_weight = 0; filter_weight <= 2; filter_weight++) {\n          if (use_highbd_) {\n            const int adjusted_strength = filter_strength + 2 * (bd_ - 8);\n            CompareTestWithParam<uint16_t>(width, height, ss_x, ss_y,\n                                           adjusted_strength, use_32x32,\n                                           &filter_weight);\n          } else {\n            CompareTestWithParam<uint8_t>(width, height, ss_x, ss_y,\n                                          filter_strength, use_32x32,\n                                          &filter_weight);\n          }\n          ASSERT_FALSE(HasFailure());\n        }\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              515,
              0
            ],
            [
              539,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(YUVTemporalFilterTest, Use16x16) {\n  const int width = 32, height = 32;\n  const int use_32x32 = 0;\n\n  for (int ss_x = 0; ss_x <= 1; ss_x++) {\n    for (int ss_y = 0; ss_y <= 1; ss_y++) {\n      for (int filter_idx = 0; filter_idx < 3 * 3 * 3 * 3; filter_idx++) {\n        // Set up the filter\n        int filter_weight[4];\n        int filter_idx_cp = filter_idx;\n        for (int idx = 0; idx < 4; idx++) {\n          filter_weight[idx] = filter_idx_cp % 3;\n          filter_idx_cp /= 3;\n        }\n\n        // Test each parameter\n        for (int filter_strength = 0; filter_strength <= 6;\n             filter_strength += 2) {\n          if (use_highbd_) {\n            const int adjusted_strength = filter_strength + 2 * (bd_ - 8);\n            CompareTestWithParam<uint16_t>(width, height, ss_x, ss_y,\n                                           adjusted_strength, use_32x32,\n                                           filter_weight);\n          } else {\n            CompareTestWithParam<uint8_t>(width, height, ss_x, ss_y,\n                                          filter_strength, use_32x32,\n                                          filter_weight);\n          }\n\n          ASSERT_FALSE(HasFailure());\n        }\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              541,
              0
            ],
            [
              575,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(YUVTemporalFilterTest, SaturationTest) {\n  const int width = 32, height = 32;\n  const int use_32x32 = 1;\n  const int filter_weight = 1;\n  saturate_test_ = 1;\n\n  for (int ss_x = 0; ss_x <= 1; ss_x++) {\n    for (int ss_y = 0; ss_y <= 1; ss_y++) {\n      for (int filter_strength = 0; filter_strength <= 6;\n           filter_strength += 2) {\n        if (use_highbd_) {\n          const int adjusted_strength = filter_strength + 2 * (bd_ - 8);\n          CompareTestWithParam<uint16_t>(width, height, ss_x, ss_y,\n                                         adjusted_strength, use_32x32,\n                                         &filter_weight);\n        } else {\n          CompareTestWithParam<uint8_t>(width, height, ss_x, ss_y,\n                                        filter_strength, use_32x32,\n                                        &filter_weight);\n        }\n\n        ASSERT_FALSE(HasFailure());\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              577,
              0
            ],
            [
              602,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(YUVTemporalFilterTest, DISABLED_Speed) {\n  const int width = 32, height = 32;\n  num_repeats_ = 1000;\n\n  for (int use_32x32 = 0; use_32x32 <= 1; use_32x32++) {\n    const int num_filter_weights = use_32x32 ? 3 : 3 * 3 * 3 * 3;\n    for (int ss_x = 0; ss_x <= 1; ss_x++) {\n      for (int ss_y = 0; ss_y <= 1; ss_y++) {\n        for (int filter_idx = 0; filter_idx < num_filter_weights;\n             filter_idx++) {\n          // Set up the filter\n          int filter_weight[4];\n          int filter_idx_cp = filter_idx;\n          for (int idx = 0; idx < 4; idx++) {\n            filter_weight[idx] = filter_idx_cp % 3;\n            filter_idx_cp /= 3;\n          }\n\n          // Test each parameter\n          for (int filter_strength = 0; filter_strength <= 6;\n               filter_strength += 2) {\n            vpx_usec_timer timer;\n            vpx_usec_timer_start(&timer);\n\n            if (use_highbd_) {\n              RunTestFilterWithParam<uint16_t>(width, height, ss_x, ss_y,\n                                               filter_strength, use_32x32,\n                                               filter_weight);\n            } else {\n              RunTestFilterWithParam<uint8_t>(width, height, ss_x, ss_y,\n                                              filter_strength, use_32x32,\n                                              filter_weight);\n            }\n\n            vpx_usec_timer_mark(&timer);\n            const int elapsed_time =\n                static_cast<int>(vpx_usec_timer_elapsed(&timer));\n\n            printf(\n                \"Bitdepth: %d, Use 32X32: %d, SS_X: %d, SS_Y: %d, Weight Idx: \"\n                \"%d, Strength: %d, Time: %5d\\n\",\n                bd_, use_32x32, ss_x, ss_y, filter_idx, filter_strength,\n                elapsed_time);\n          }\n        }\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              604,
              0
            ],
            [
              652,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*YUVTemporalFilterFunc)(\n    const uint8_t *y_src, int y_src_stride, const uint8_t *y_pre,\n    int y_pre_stride, const uint8_t *u_src, const uint8_t *v_src,\n    int uv_src_stride, const uint8_t *u_pre, const uint8_t *v_pre,\n    int uv_pre_stride, unsigned int block_width, unsigned int block_height,\n    int ss_x, int ss_y, int strength, const int *const blk_fw, int use_32x32,\n    uint32_t *y_accumulator, uint16_t *y_count, uint32_t *u_accumulator,\n    uint16_t *u_count, uint32_t *v_accumulator, uint16_t *v_count)",
          "fn_dec_pos": [
            [
              23,
              13
            ],
            [
              30,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "y_src": "uint8_t",
              "y_src_stride": "int",
              "y_pre": "uint8_t",
              "y_pre_stride": "int",
              "u_src": "uint8_t",
              "v_src": "uint8_t",
              "uv_src_stride": "int",
              "u_pre": "uint8_t",
              "v_pre": "uint8_t",
              "uv_pre_stride": "int",
              "block_width": "unsigned int",
              "block_height": "unsigned int",
              "ss_x": "int",
              "ss_y": "int",
              "strength": "int",
              "blk_fw": "int",
              "use_32x32": "int",
              "y_accumulator": "uint32_t",
              "y_count": "uint16_t",
              "u_accumulator": "uint32_t",
              "u_count": "uint16_t",
              "v_accumulator": "uint32_t",
              "v_count": "uint16_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "operator<<(std::ostream &os, const TemporalFilterWithBd &tf)",
          "fn_dec_pos": [
            [
              40,
              14
            ],
            [
              40,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "tf": "TemporalFilterWithBd"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename PixelType>\n  void CompareTestWithParam(int width, int height, int ss_x, int ss_y,\n                            int filter_strength, int use_32x32,\n                            const int *filter_weight);",
          "fn_dec_pos": [
            [
              305,
              2
            ],
            [
              308,
              54
            ]
          ],
          "class_code": "5c3c79008a280ddf1fd32d4e309e18acc4e41e38c65a0e51ae22b49e5b646939",
          "class_node_pos": [
            [
              289,
              0
            ],
            [
              319,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename PixelType>\n  void RunTestFilterWithParam(int width, int height, int ss_x, int ss_y,\n                              int filter_strength, int use_32x32,\n                              const int *filter_weight);",
          "fn_dec_pos": [
            [
              309,
              2
            ],
            [
              312,
              56
            ]
          ],
          "class_code": "5c3c79008a280ddf1fd32d4e309e18acc4e41e38c65a0e51ae22b49e5b646939",
          "class_node_pos": [
            [
              289,
              0
            ],
            [
              319,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "5c3c79008a280ddf1fd32d4e309e18acc4e41e38c65a0e51ae22b49e5b646939": {
          "class_code": "class YUVTemporalFilterTest\n    : public ::testing::TestWithParam<TemporalFilterWithBd> {\n public:\n  virtual void SetUp() {\n    filter_func_ = GetParam().temporal_filter;\n    bd_ = GetParam().bd;\n    use_highbd_ = (bd_ != 8);\n\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n    saturate_test_ = 0;\n    num_repeats_ = 10;\n\n    ASSERT_TRUE(bd_ == 8 || bd_ == 10 || bd_ == 12);\n  }\n\n protected:\n  template <typename PixelType>\n  void CompareTestWithParam(int width, int height, int ss_x, int ss_y,\n                            int filter_strength, int use_32x32,\n                            const int *filter_weight);\n  template <typename PixelType>\n  void RunTestFilterWithParam(int width, int height, int ss_x, int ss_y,\n                              int filter_strength, int use_32x32,\n                              const int *filter_weight);\n  YUVTemporalFilterFunc filter_func_;\n  ACMRandom rnd_;\n  int saturate_test_;\n  int num_repeats_;\n  int use_highbd_;\n  int bd_;\n}",
          "class_name": "YUVTemporalFilterTest",
          "class_pos": [
            [
              289,
              0
            ],
            [
              319,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct TemporalFilterWithBd {\n  TemporalFilterWithBd(YUVTemporalFilterFunc func, int bitdepth)\n      : temporal_filter(func), bd(bitdepth) {}\n\n  YUVTemporalFilterFunc temporal_filter;\n  int bd;\n}",
          {
            "temporal_filter": "YUVTemporalFilterFunc",
            "bd": "int"
          },
          "TemporalFilterWithBd",
          [
            32,
            0
          ],
          [
            38,
            1
          ]
        ],
        [
          "struct TemporalFilterWithBd {\n  TemporalFilterWithBd(YUVTemporalFilterFunc func, int bitdepth)\n      : temporal_filter(func), bd(bitdepth) {}\n\n  YUVTemporalFilterFunc temporal_filter;\n  int bd;\n}",
          {
            "temporal_filter": "YUVTemporalFilterFunc",
            "bd": "int"
          },
          "TemporalFilterWithBd",
          [
            32,
            0
          ],
          [
            38,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"./vp9_rtcd.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/buffer.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"vpx_ports/vpx_timer.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/variance_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "template <typename Func>\nstd::ostream &operator<<(std::ostream &os, const TestParams<Func> &p) {\n  return os << \"log2width/height:\" << p.log2width << \"/\" << p.log2height\n            << \" function:\" << reinterpret_cast<const void *>(p.func)\n            << \" bit-depth:\" << p.bit_depth;\n}",
          "fn_code_pos": [
            [
              279,
              0
            ],
            [
              284,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename VarianceFunctionType>\nvoid MainTestClass<VarianceFunctionType>::ZeroTest() {\n  for (int i = 0; i <= 255; ++i) {\n    if (!use_high_bit_depth()) {\n      memset(src_, i, block_size());\n    } else {\n      uint16_t *const src16 = CONVERT_TO_SHORTPTR(src_);\n      for (int k = 0; k < block_size(); ++k) src16[k] = i << byte_shift();\n    }\n    for (int j = 0; j <= 255; ++j) {\n      if (!use_high_bit_depth()) {\n        memset(ref_, j, block_size());\n      } else {\n        uint16_t *const ref16 = CONVERT_TO_SHORTPTR(ref_);\n        for (int k = 0; k < block_size(); ++k) ref16[k] = j << byte_shift();\n      }\n      unsigned int sse, var;\n      ASM_REGISTER_STATE_CHECK(\n          var = params_.func(src_, width(), ref_, width(), &sse));\n      EXPECT_EQ(0u, var) << \"src values: \" << i << \" ref values: \" << j;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              363,
              0
            ],
            [
              385,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename VarianceFunctionType>\nvoid MainTestClass<VarianceFunctionType>::RefTest() {\n  for (int i = 0; i < 10; ++i) {\n    for (int j = 0; j < block_size(); j++) {\n      if (!use_high_bit_depth()) {\n        src_[j] = rnd_.Rand8();\n        ref_[j] = rnd_.Rand8();\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        CONVERT_TO_SHORTPTR(src_)[j] = rnd_.Rand16() & mask();\n        CONVERT_TO_SHORTPTR(ref_)[j] = rnd_.Rand16() & mask();\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n      }\n    }\n    unsigned int sse1, sse2, var1, var2;\n    const int stride = width();\n    ASM_REGISTER_STATE_CHECK(\n        var1 = params_.func(src_, stride, ref_, stride, &sse1));\n    var2 =\n        variance_ref(src_, ref_, params_.log2width, params_.log2height, stride,\n                     stride, &sse2, use_high_bit_depth(), params_.bit_depth);\n    EXPECT_EQ(sse1, sse2) << \"Error at test index: \" << i;\n    EXPECT_EQ(var1, var2) << \"Error at test index: \" << i;\n  }\n}",
          "fn_code_pos": [
            [
              387,
              0
            ],
            [
              411,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename VarianceFunctionType>\nvoid MainTestClass<VarianceFunctionType>::RefStrideTest() {\n  for (int i = 0; i < 10; ++i) {\n    const int ref_stride = (i & 1) * width();\n    const int src_stride = ((i >> 1) & 1) * width();\n    for (int j = 0; j < block_size(); j++) {\n      const int ref_ind = (j / width()) * ref_stride + j % width();\n      const int src_ind = (j / width()) * src_stride + j % width();\n      if (!use_high_bit_depth()) {\n        src_[src_ind] = rnd_.Rand8();\n        ref_[ref_ind] = rnd_.Rand8();\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        CONVERT_TO_SHORTPTR(src_)[src_ind] = rnd_.Rand16() & mask();\n        CONVERT_TO_SHORTPTR(ref_)[ref_ind] = rnd_.Rand16() & mask();\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n      }\n    }\n    unsigned int sse1, sse2;\n    unsigned int var1, var2;\n\n    ASM_REGISTER_STATE_CHECK(\n        var1 = params_.func(src_, src_stride, ref_, ref_stride, &sse1));\n    var2 = variance_ref(src_, ref_, params_.log2width, params_.log2height,\n                        src_stride, ref_stride, &sse2, use_high_bit_depth(),\n                        params_.bit_depth);\n    EXPECT_EQ(sse1, sse2) << \"Error at test index: \" << i;\n    EXPECT_EQ(var1, var2) << \"Error at test index: \" << i;\n  }\n}",
          "fn_code_pos": [
            [
              413,
              0
            ],
            [
              442,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename VarianceFunctionType>\nvoid MainTestClass<VarianceFunctionType>::OneQuarterTest() {\n  const int half = block_size() / 2;\n  if (!use_high_bit_depth()) {\n    memset(src_, 255, block_size());\n    memset(ref_, 255, half);\n    memset(ref_ + half, 0, half);\n#if CONFIG_VP9_HIGHBITDEPTH\n  } else {\n    vpx_memset16(CONVERT_TO_SHORTPTR(src_), 255 << byte_shift(), block_size());\n    vpx_memset16(CONVERT_TO_SHORTPTR(ref_), 255 << byte_shift(), half);\n    vpx_memset16(CONVERT_TO_SHORTPTR(ref_) + half, 0, half);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n  }\n  unsigned int sse, var, expected;\n  ASM_REGISTER_STATE_CHECK(\n      var = params_.func(src_, width(), ref_, width(), &sse));\n  expected = block_size() * 255 * 255 / 4;\n  EXPECT_EQ(expected, var);\n}",
          "fn_code_pos": [
            [
              444,
              0
            ],
            [
              463,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename VarianceFunctionType>\nvoid MainTestClass<VarianceFunctionType>::SpeedTest() {\n  const int half = block_size() / 2;\n  if (!use_high_bit_depth()) {\n    memset(src_, 255, block_size());\n    memset(ref_, 255, half);\n    memset(ref_ + half, 0, half);\n#if CONFIG_VP9_HIGHBITDEPTH\n  } else {\n    vpx_memset16(CONVERT_TO_SHORTPTR(src_), 255 << byte_shift(), block_size());\n    vpx_memset16(CONVERT_TO_SHORTPTR(ref_), 255 << byte_shift(), half);\n    vpx_memset16(CONVERT_TO_SHORTPTR(ref_) + half, 0, half);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n  }\n  unsigned int sse;\n\n  vpx_usec_timer timer;\n  vpx_usec_timer_start(&timer);\n  for (int i = 0; i < (1 << 30) / block_size(); ++i) {\n    const uint32_t variance = params_.func(src_, width(), ref_, width(), &sse);\n    // Ignore return value.\n    (void)variance;\n  }\n  vpx_usec_timer_mark(&timer);\n  const int elapsed_time = static_cast<int>(vpx_usec_timer_elapsed(&timer));\n  printf(\"Variance %dx%d time: %5d ms\\n\", width(), height(),\n         elapsed_time / 1000);\n}",
          "fn_code_pos": [
            [
              465,
              0
            ],
            [
              492,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename FunctionType>\nvoid MainTestClass<FunctionType>::RefTestMse() {\n  for (int i = 0; i < 10; ++i) {\n    for (int j = 0; j < block_size(); ++j) {\n      src_[j] = rnd_.Rand8();\n      ref_[j] = rnd_.Rand8();\n    }\n    unsigned int sse1, sse2;\n    const int stride = width();\n    ASM_REGISTER_STATE_CHECK(params_.func(src_, stride, ref_, stride, &sse1));\n    variance_ref(src_, ref_, params_.log2width, params_.log2height, stride,\n                 stride, &sse2, false, VPX_BITS_8);\n    EXPECT_EQ(sse1, sse2);\n  }\n}",
          "fn_code_pos": [
            [
              497,
              0
            ],
            [
              511,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename FunctionType>\nvoid MainTestClass<FunctionType>::RefTestSse() {\n  for (int i = 0; i < 10; ++i) {\n    for (int j = 0; j < block_size(); ++j) {\n      src_[j] = rnd_.Rand8();\n      ref_[j] = rnd_.Rand8();\n    }\n    unsigned int sse2;\n    unsigned int var1;\n    const int stride = width();\n    ASM_REGISTER_STATE_CHECK(var1 = params_.func(src_, stride, ref_, stride));\n    variance_ref(src_, ref_, params_.log2width, params_.log2height, stride,\n                 stride, &sse2, false, VPX_BITS_8);\n    EXPECT_EQ(var1, sse2);\n  }\n}",
          "fn_code_pos": [
            [
              513,
              0
            ],
            [
              528,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename FunctionType>\nvoid MainTestClass<FunctionType>::MaxTestMse() {\n  memset(src_, 255, block_size());\n  memset(ref_, 0, block_size());\n  unsigned int sse;\n  ASM_REGISTER_STATE_CHECK(params_.func(src_, width(), ref_, width(), &sse));\n  const unsigned int expected = block_size() * 255 * 255;\n  EXPECT_EQ(expected, sse);\n}",
          "fn_code_pos": [
            [
              530,
              0
            ],
            [
              538,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename FunctionType>\nvoid MainTestClass<FunctionType>::MaxTestSse() {\n  memset(src_, 255, block_size());\n  memset(ref_, 0, block_size());\n  unsigned int var;\n  ASM_REGISTER_STATE_CHECK(var = params_.func(src_, width(), ref_, width()));\n  const unsigned int expected = block_size() * 255 * 255;\n  EXPECT_EQ(expected, var);\n}",
          "fn_code_pos": [
            [
              540,
              0
            ],
            [
              548,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename SubpelVarianceFunctionType>\nvoid SubpelVarianceTest<SubpelVarianceFunctionType>::RefTest() {\n  for (int x = 0; x < 8; ++x) {\n    for (int y = 0; y < 8; ++y) {\n      if (!use_high_bit_depth()) {\n        for (int j = 0; j < block_size(); j++) {\n          src_[j] = rnd_.Rand8();\n        }\n        for (int j = 0; j < block_size() + width() + height() + 1; j++) {\n          ref_[j] = rnd_.Rand8();\n        }\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        for (int j = 0; j < block_size(); j++) {\n          CONVERT_TO_SHORTPTR(src_)[j] = rnd_.Rand16() & mask();\n        }\n        for (int j = 0; j < block_size() + width() + height() + 1; j++) {\n          CONVERT_TO_SHORTPTR(ref_)[j] = rnd_.Rand16() & mask();\n        }\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n      }\n      unsigned int sse1, sse2;\n      unsigned int var1;\n      ASM_REGISTER_STATE_CHECK(\n          var1 = params_.func(ref_, width() + 1, x, y, src_, width(), &sse1));\n      const unsigned int var2 = subpel_variance_ref(\n          ref_, src_, params_.log2width, params_.log2height, x, y, &sse2,\n          use_high_bit_depth(), params_.bit_depth);\n      EXPECT_EQ(sse1, sse2) << \"at position \" << x << \", \" << y;\n      EXPECT_EQ(var1, var2) << \"at position \" << x << \", \" << y;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              614,
              0
            ],
            [
              646,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename SubpelVarianceFunctionType>\nvoid SubpelVarianceTest<SubpelVarianceFunctionType>::ExtremeRefTest() {\n  // Compare against reference.\n  // Src: Set the first half of values to 0, the second half to the maximum.\n  // Ref: Set the first half of values to the maximum, the second half to 0.\n  for (int x = 0; x < 8; ++x) {\n    for (int y = 0; y < 8; ++y) {\n      const int half = block_size() / 2;\n      if (!use_high_bit_depth()) {\n        memset(src_, 0, half);\n        memset(src_ + half, 255, half);\n        memset(ref_, 255, half);\n        memset(ref_ + half, 0, half + width() + height() + 1);\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        vpx_memset16(CONVERT_TO_SHORTPTR(src_), mask(), half);\n        vpx_memset16(CONVERT_TO_SHORTPTR(src_) + half, 0, half);\n        vpx_memset16(CONVERT_TO_SHORTPTR(ref_), 0, half);\n        vpx_memset16(CONVERT_TO_SHORTPTR(ref_) + half, mask(),\n                     half + width() + height() + 1);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n      }\n      unsigned int sse1, sse2;\n      unsigned int var1;\n      ASM_REGISTER_STATE_CHECK(\n          var1 = params_.func(ref_, width() + 1, x, y, src_, width(), &sse1));\n      const unsigned int var2 = subpel_variance_ref(\n          ref_, src_, params_.log2width, params_.log2height, x, y, &sse2,\n          use_high_bit_depth(), params_.bit_depth);\n      EXPECT_EQ(sse1, sse2) << \"for xoffset \" << x << \" and yoffset \" << y;\n      EXPECT_EQ(var1, var2) << \"for xoffset \" << x << \" and yoffset \" << y;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              648,
              0
            ],
            [
              681,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <>\nvoid SubpelVarianceTest<vpx_subp_avg_variance_fn_t>::RefTest() {\n  for (int x = 0; x < 8; ++x) {\n    for (int y = 0; y < 8; ++y) {\n      if (!use_high_bit_depth()) {\n        for (int j = 0; j < block_size(); j++) {\n          src_[j] = rnd_.Rand8();\n          sec_[j] = rnd_.Rand8();\n        }\n        for (int j = 0; j < block_size() + width() + height() + 1; j++) {\n          ref_[j] = rnd_.Rand8();\n        }\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        for (int j = 0; j < block_size(); j++) {\n          CONVERT_TO_SHORTPTR(src_)[j] = rnd_.Rand16() & mask();\n          CONVERT_TO_SHORTPTR(sec_)[j] = rnd_.Rand16() & mask();\n        }\n        for (int j = 0; j < block_size() + width() + height() + 1; j++) {\n          CONVERT_TO_SHORTPTR(ref_)[j] = rnd_.Rand16() & mask();\n        }\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n      }\n      uint32_t sse1, sse2;\n      uint32_t var1, var2;\n      ASM_REGISTER_STATE_CHECK(var1 = params_.func(ref_, width() + 1, x, y,\n                                                   src_, width(), &sse1, sec_));\n      var2 = subpel_avg_variance_ref(ref_, src_, sec_, params_.log2width,\n                                     params_.log2height, x, y, &sse2,\n                                     use_high_bit_depth(), params_.bit_depth);\n      EXPECT_EQ(sse1, sse2) << \"at position \" << x << \", \" << y;\n      EXPECT_EQ(var1, var2) << \"at position \" << x << \", \" << y;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              683,
              0
            ],
            [
              717,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static void RoundHighBitDepth(int bit_depth, int64_t *se, uint64_t *sse) {\n  switch (bit_depth) {\n    case VPX_BITS_12:\n      *sse = (*sse + 128) >> 8;\n      *se = (*se + 8) >> 4;\n      break;\n    case VPX_BITS_10:\n      *sse = (*sse + 8) >> 4;\n      *se = (*se + 2) >> 2;\n      break;\n    case VPX_BITS_8:\n    default: break;\n  }\n}",
          "fn_code_pos": [
            [
              38,
              0
            ],
            [
              51,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RoundHighBitDepth",
            "parameters": {
              "bit_depth": "int",
              "se": "int64_t",
              "sse": "uint64_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static unsigned int mb_ss_ref(const int16_t *src) {\n  unsigned int res = 0;\n  for (int i = 0; i < 256; ++i) {\n    res += src[i] * src[i];\n  }\n  return res;\n}",
          "fn_code_pos": [
            [
              53,
              0
            ],
            [
              59,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mb_ss_ref",
            "parameters": {
              "src": "int16_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static uint32_t variance_ref(const uint8_t *src, const uint8_t *ref, int l2w,\n                             int l2h, int src_stride, int ref_stride,\n                             uint32_t *sse_ptr, bool use_high_bit_depth_,\n                             vpx_bit_depth_t bit_depth) {\n  int64_t se = 0;\n  uint64_t sse = 0;\n  const int w = 1 << l2w;\n  const int h = 1 << l2h;\n  for (int y = 0; y < h; y++) {\n    for (int x = 0; x < w; x++) {\n      int diff;\n      if (!use_high_bit_depth_) {\n        diff = src[y * src_stride + x] - ref[y * ref_stride + x];\n        se += diff;\n        sse += diff * diff;\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        diff = CONVERT_TO_SHORTPTR(src)[y * src_stride + x] -\n               CONVERT_TO_SHORTPTR(ref)[y * ref_stride + x];\n        se += diff;\n        sse += diff * diff;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n      }\n    }\n  }\n  RoundHighBitDepth(bit_depth, &se, &sse);\n  *sse_ptr = static_cast<uint32_t>(sse);\n  return static_cast<uint32_t>(\n      sse - ((static_cast<int64_t>(se) * se) >> (l2w + l2h)));\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              94,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "variance_ref",
            "parameters": {
              "src": "uint8_t",
              "ref": "uint8_t",
              "l2w": "int",
              "l2h": "int",
              "src_stride": "int",
              "ref_stride": "int",
              "sse_ptr": "uint32_t",
              "use_high_bit_depth_": "bool",
              "bit_depth": "vpx_bit_depth_t"
            },
            "return_type": "uint32_t"
          }
        },
        {
          "fn_code": "static uint32_t subpel_variance_ref(const uint8_t *ref, const uint8_t *src,\n                                    int l2w, int l2h, int xoff, int yoff,\n                                    uint32_t *sse_ptr, bool use_high_bit_depth_,\n                                    vpx_bit_depth_t bit_depth) {\n  int64_t se = 0;\n  uint64_t sse = 0;\n  const int w = 1 << l2w;\n  const int h = 1 << l2h;\n\n  xoff <<= 1;\n  yoff <<= 1;\n\n  for (int y = 0; y < h; y++) {\n    for (int x = 0; x < w; x++) {\n      // Bilinear interpolation at a 16th pel step.\n      if (!use_high_bit_depth_) {\n        const int a1 = ref[(w + 1) * (y + 0) + x + 0];\n        const int a2 = ref[(w + 1) * (y + 0) + x + 1];\n        const int b1 = ref[(w + 1) * (y + 1) + x + 0];\n        const int b2 = ref[(w + 1) * (y + 1) + x + 1];\n        const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);\n        const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);\n        const int r = a + (((b - a) * yoff + 8) >> 4);\n        const int diff = r - src[w * y + x];\n        se += diff;\n        sse += diff * diff;\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        uint16_t *ref16 = CONVERT_TO_SHORTPTR(ref);\n        uint16_t *src16 = CONVERT_TO_SHORTPTR(src);\n        const int a1 = ref16[(w + 1) * (y + 0) + x + 0];\n        const int a2 = ref16[(w + 1) * (y + 0) + x + 1];\n        const int b1 = ref16[(w + 1) * (y + 1) + x + 0];\n        const int b2 = ref16[(w + 1) * (y + 1) + x + 1];\n        const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);\n        const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);\n        const int r = a + (((b - a) * yoff + 8) >> 4);\n        const int diff = r - src16[w * y + x];\n        se += diff;\n        sse += diff * diff;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n      }\n    }\n  }\n  RoundHighBitDepth(bit_depth, &se, &sse);\n  *sse_ptr = static_cast<uint32_t>(sse);\n  return static_cast<uint32_t>(\n      sse - ((static_cast<int64_t>(se) * se) >> (l2w + l2h)));\n}",
          "fn_code_pos": [
            [
              102,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "subpel_variance_ref",
            "parameters": {
              "ref": "uint8_t",
              "src": "uint8_t",
              "l2w": "int",
              "l2h": "int",
              "xoff": "int",
              "yoff": "int",
              "sse_ptr": "uint32_t",
              "use_high_bit_depth_": "bool",
              "bit_depth": "vpx_bit_depth_t"
            },
            "return_type": "uint32_t"
          }
        },
        {
          "fn_code": "static uint32_t subpel_avg_variance_ref(const uint8_t *ref, const uint8_t *src,\n                                        const uint8_t *second_pred, int l2w,\n                                        int l2h, int xoff, int yoff,\n                                        uint32_t *sse_ptr,\n                                        bool use_high_bit_depth,\n                                        vpx_bit_depth_t bit_depth) {\n  int64_t se = 0;\n  uint64_t sse = 0;\n  const int w = 1 << l2w;\n  const int h = 1 << l2h;\n\n  xoff <<= 1;\n  yoff <<= 1;\n\n  for (int y = 0; y < h; y++) {\n    for (int x = 0; x < w; x++) {\n      // bilinear interpolation at a 16th pel step\n      if (!use_high_bit_depth) {\n        const int a1 = ref[(w + 1) * (y + 0) + x + 0];\n        const int a2 = ref[(w + 1) * (y + 0) + x + 1];\n        const int b1 = ref[(w + 1) * (y + 1) + x + 0];\n        const int b2 = ref[(w + 1) * (y + 1) + x + 1];\n        const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);\n        const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);\n        const int r = a + (((b - a) * yoff + 8) >> 4);\n        const int diff =\n            ((r + second_pred[w * y + x] + 1) >> 1) - src[w * y + x];\n        se += diff;\n        sse += diff * diff;\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        const uint16_t *ref16 = CONVERT_TO_SHORTPTR(ref);\n        const uint16_t *src16 = CONVERT_TO_SHORTPTR(src);\n        const uint16_t *sec16 = CONVERT_TO_SHORTPTR(second_pred);\n        const int a1 = ref16[(w + 1) * (y + 0) + x + 0];\n        const int a2 = ref16[(w + 1) * (y + 0) + x + 1];\n        const int b1 = ref16[(w + 1) * (y + 1) + x + 0];\n        const int b2 = ref16[(w + 1) * (y + 1) + x + 1];\n        const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);\n        const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);\n        const int r = a + (((b - a) * yoff + 8) >> 4);\n        const int diff = ((r + sec16[w * y + x] + 1) >> 1) - src16[w * y + x];\n        se += diff;\n        sse += diff * diff;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n      }\n    }\n  }\n  RoundHighBitDepth(bit_depth, &se, &sse);\n  *sse_ptr = static_cast<uint32_t>(sse);\n  return static_cast<uint32_t>(\n      sse - ((static_cast<int64_t>(se) * se) >> (l2w + l2h)));\n}",
          "fn_code_pos": [
            [
              152,
              0
            ],
            [
              204,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "subpel_avg_variance_ref",
            "parameters": {
              "ref": "uint8_t",
              "src": "uint8_t",
              "second_pred": "uint8_t",
              "l2w": "int",
              "l2h": "int",
              "xoff": "int",
              "yoff": "int",
              "sse_ptr": "uint32_t",
              "use_high_bit_depth": "bool",
              "bit_depth": "vpx_bit_depth_t"
            },
            "return_type": "uint32_t"
          }
        },
        {
          "fn_code": "SumOfSquaresTest() : func_(GetParam()) {}",
          "fn_code_pos": [
            [
              210,
              2
            ],
            [
              210,
              43
            ]
          ],
          "class_code": "32b740aa6c8d70788ecf5c915672eadc4d84123419195853048e7d66b111e8e6",
          "class_node_pos": [
            [
              208,
              0
            ],
            [
              220,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SumOfSquaresTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~SumOfSquaresTest() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              212,
              2
            ],
            [
              212,
              66
            ]
          ],
          "class_code": "32b740aa6c8d70788ecf5c915672eadc4d84123419195853048e7d66b111e8e6",
          "class_node_pos": [
            [
              208,
              0
            ],
            [
              220,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void SumOfSquaresTest::ConstTest() {\n  int16_t mem[256];\n  unsigned int res;\n  for (int v = 0; v < 256; ++v) {\n    for (int i = 0; i < 256; ++i) {\n      mem[i] = v;\n    }\n    ASM_REGISTER_STATE_CHECK(res = func_(mem));\n    EXPECT_EQ(256u * (v * v), res);\n  }\n}",
          "fn_code_pos": [
            [
              222,
              0
            ],
            [
              232,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SumOfSquaresTest::ConstTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SumOfSquaresTest::RefTest() {\n  int16_t mem[256];\n  for (int i = 0; i < 100; ++i) {\n    for (int j = 0; j < 256; ++j) {\n      mem[j] = rnd_.Rand8() - rnd_.Rand8();\n    }\n\n    const unsigned int expected = mb_ss_ref(mem);\n    unsigned int res;\n    ASM_REGISTER_STATE_CHECK(res = func_(mem));\n    EXPECT_EQ(expected, res);\n  }\n}",
          "fn_code_pos": [
            [
              234,
              0
            ],
            [
              246,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SumOfSquaresTest::RefTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TestParams(int log2w = 0, int log2h = 0, Func function = NULL,\n             int bit_depth_value = 0)\n      : log2width(log2w), log2height(log2h), func(function) {\n    use_high_bit_depth = (bit_depth_value > 0);\n    if (use_high_bit_depth) {\n      bit_depth = static_cast<vpx_bit_depth_t>(bit_depth_value);\n    } else {\n      bit_depth = VPX_BITS_8;\n    }\n    width = 1 << log2width;\n    height = 1 << log2height;\n    block_size = width * height;\n    mask = (1u << bit_depth) - 1;\n  }",
          "fn_code_pos": [
            [
              255,
              2
            ],
            [
              268,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestParams",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    params_ = this->GetParam();\n\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n    const size_t unit =\n        use_high_bit_depth() ? sizeof(uint16_t) : sizeof(uint8_t);\n    src_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size() * unit));\n    ref_ = new uint8_t[block_size() * unit];\n    ASSERT_TRUE(src_ != NULL);\n    ASSERT_TRUE(ref_ != NULL);\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (use_high_bit_depth()) {\n      // TODO(skal): remove!\n      src_ = CONVERT_TO_BYTEPTR(src_);\n      ref_ = CONVERT_TO_BYTEPTR(ref_);\n    }\n#endif\n  }",
          "fn_code_pos": [
            [
              291,
              2
            ],
            [
              308,
              3
            ]
          ],
          "class_code": "2bec3e5374a779e78636fd400fe75d670935823cffd338b9363b4c5808eff170",
          "class_node_pos": [
            [
              288,
              0
            ],
            [
              358,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() {\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (use_high_bit_depth()) {\n      // TODO(skal): remove!\n      src_ = reinterpret_cast<uint8_t *>(CONVERT_TO_SHORTPTR(src_));\n      ref_ = reinterpret_cast<uint8_t *>(CONVERT_TO_SHORTPTR(ref_));\n    }\n#endif\n\n    vpx_free(src_);\n    delete[] ref_;\n    src_ = NULL;\n    ref_ = NULL;\n    libvpx_test::ClearSystemState();\n  }",
          "fn_code_pos": [
            [
              310,
              2
            ],
            [
              324,
              3
            ]
          ],
          "class_code": "2bec3e5374a779e78636fd400fe75d670935823cffd338b9363b4c5808eff170",
          "class_node_pos": [
            [
              288,
              0
            ],
            [
              358,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "bool use_high_bit_depth() const { return params_.use_high_bit_depth; }",
          "fn_code_pos": [
            [
              352,
              2
            ],
            [
              352,
              72
            ]
          ],
          "class_code": "2bec3e5374a779e78636fd400fe75d670935823cffd338b9363b4c5808eff170",
          "class_node_pos": [
            [
              288,
              0
            ],
            [
              358,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "use_high_bit_depth",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "int byte_shift() const { return params_.bit_depth - 8; }",
          "fn_code_pos": [
            [
              353,
              2
            ],
            [
              353,
              58
            ]
          ],
          "class_code": "2bec3e5374a779e78636fd400fe75d670935823cffd338b9363b4c5808eff170",
          "class_node_pos": [
            [
              288,
              0
            ],
            [
              358,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "byte_shift",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int block_size() const { return params_.block_size; }",
          "fn_code_pos": [
            [
              354,
              2
            ],
            [
              354,
              55
            ]
          ],
          "class_code": "2bec3e5374a779e78636fd400fe75d670935823cffd338b9363b4c5808eff170",
          "class_node_pos": [
            [
              288,
              0
            ],
            [
              358,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "block_size",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int width() const { return params_.width; }",
          "fn_code_pos": [
            [
              355,
              2
            ],
            [
              355,
              45
            ]
          ],
          "class_code": "2bec3e5374a779e78636fd400fe75d670935823cffd338b9363b4c5808eff170",
          "class_node_pos": [
            [
              288,
              0
            ],
            [
              358,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "width",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int height() const { return params_.height; }",
          "fn_code_pos": [
            [
              356,
              2
            ],
            [
              356,
              47
            ]
          ],
          "class_code": "2bec3e5374a779e78636fd400fe75d670935823cffd338b9363b4c5808eff170",
          "class_node_pos": [
            [
              288,
              0
            ],
            [
              358,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "height",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "uint32_t mask() const { return params_.mask; }",
          "fn_code_pos": [
            [
              357,
              2
            ],
            [
              357,
              48
            ]
          ],
          "class_code": "2bec3e5374a779e78636fd400fe75d670935823cffd338b9363b4c5808eff170",
          "class_node_pos": [
            [
              288,
              0
            ],
            [
              358,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "mask",
            "parameters": {},
            "return_type": "uint32_t"
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    params_ = this->GetParam();\n\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n    if (!use_high_bit_depth()) {\n      src_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size()));\n      sec_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size()));\n      ref_ = reinterpret_cast<uint8_t *>(\n          vpx_malloc(block_size() + width() + height() + 1));\n#if CONFIG_VP9_HIGHBITDEPTH\n    } else {\n      src_ = CONVERT_TO_BYTEPTR(reinterpret_cast<uint16_t *>(\n          vpx_memalign(16, block_size() * sizeof(uint16_t))));\n      sec_ = CONVERT_TO_BYTEPTR(reinterpret_cast<uint16_t *>(\n          vpx_memalign(16, block_size() * sizeof(uint16_t))));\n      ref_ = CONVERT_TO_BYTEPTR(reinterpret_cast<uint16_t *>(vpx_malloc(\n          (block_size() + width() + height() + 1) * sizeof(uint16_t))));\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    }\n    ASSERT_TRUE(src_ != NULL);\n    ASSERT_TRUE(sec_ != NULL);\n    ASSERT_TRUE(ref_ != NULL);\n  }",
          "fn_code_pos": [
            [
              556,
              2
            ],
            [
              578,
              3
            ]
          ],
          "class_code": "55889d652293e3a44529aa48d054162e533c6cf8d4dd7524ed86f2d28563b5c6",
          "class_node_pos": [
            [
              553,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() {\n    if (!use_high_bit_depth()) {\n      vpx_free(src_);\n      vpx_free(sec_);\n      vpx_free(ref_);\n#if CONFIG_VP9_HIGHBITDEPTH\n    } else {\n      vpx_free(CONVERT_TO_SHORTPTR(src_));\n      vpx_free(CONVERT_TO_SHORTPTR(ref_));\n      vpx_free(CONVERT_TO_SHORTPTR(sec_));\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    }\n    libvpx_test::ClearSystemState();\n  }",
          "fn_code_pos": [
            [
              580,
              2
            ],
            [
              593,
              3
            ]
          ],
          "class_code": "55889d652293e3a44529aa48d054162e533c6cf8d4dd7524ed86f2d28563b5c6",
          "class_node_pos": [
            [
              553,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "bool use_high_bit_depth() const { return params_.use_high_bit_depth; }",
          "fn_code_pos": [
            [
              606,
              2
            ],
            [
              606,
              72
            ]
          ],
          "class_code": "55889d652293e3a44529aa48d054162e533c6cf8d4dd7524ed86f2d28563b5c6",
          "class_node_pos": [
            [
              553,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "use_high_bit_depth",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "int byte_shift() const { return params_.bit_depth - 8; }",
          "fn_code_pos": [
            [
              607,
              2
            ],
            [
              607,
              58
            ]
          ],
          "class_code": "55889d652293e3a44529aa48d054162e533c6cf8d4dd7524ed86f2d28563b5c6",
          "class_node_pos": [
            [
              553,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "byte_shift",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int block_size() const { return params_.block_size; }",
          "fn_code_pos": [
            [
              608,
              2
            ],
            [
              608,
              55
            ]
          ],
          "class_code": "55889d652293e3a44529aa48d054162e533c6cf8d4dd7524ed86f2d28563b5c6",
          "class_node_pos": [
            [
              553,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "block_size",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int width() const { return params_.width; }",
          "fn_code_pos": [
            [
              609,
              2
            ],
            [
              609,
              45
            ]
          ],
          "class_code": "55889d652293e3a44529aa48d054162e533c6cf8d4dd7524ed86f2d28563b5c6",
          "class_node_pos": [
            [
              553,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "width",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int height() const { return params_.height; }",
          "fn_code_pos": [
            [
              610,
              2
            ],
            [
              610,
              47
            ]
          ],
          "class_code": "55889d652293e3a44529aa48d054162e533c6cf8d4dd7524ed86f2d28563b5c6",
          "class_node_pos": [
            [
              553,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "height",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "uint32_t mask() const { return params_.mask; }",
          "fn_code_pos": [
            [
              611,
              2
            ],
            [
              611,
              48
            ]
          ],
          "class_code": "55889d652293e3a44529aa48d054162e533c6cf8d4dd7524ed86f2d28563b5c6",
          "class_node_pos": [
            [
              553,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "mask",
            "parameters": {},
            "return_type": "uint32_t"
          }
        },
        {
          "fn_code": "TEST_P(VpxSseTest, RefSse) { RefTestSse(); }",
          "fn_code_pos": [
            [
              725,
              0
            ],
            [
              725,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxSseTest, MaxSse) { MaxTestSse(); }",
          "fn_code_pos": [
            [
              726,
              0
            ],
            [
              726,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxMseTest, RefMse) { RefTestMse(); }",
          "fn_code_pos": [
            [
              727,
              0
            ],
            [
              727,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxMseTest, MaxMse) { MaxTestMse(); }",
          "fn_code_pos": [
            [
              728,
              0
            ],
            [
              728,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxVarianceTest, Zero) { ZeroTest(); }",
          "fn_code_pos": [
            [
              729,
              0
            ],
            [
              729,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxVarianceTest, Ref) { RefTest(); }",
          "fn_code_pos": [
            [
              730,
              0
            ],
            [
              730,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxVarianceTest, RefStride) { RefStrideTest(); }",
          "fn_code_pos": [
            [
              731,
              0
            ],
            [
              731,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxVarianceTest, OneQuarter) { OneQuarterTest(); }",
          "fn_code_pos": [
            [
              732,
              0
            ],
            [
              732,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxVarianceTest, DISABLED_Speed) { SpeedTest(); }",
          "fn_code_pos": [
            [
              733,
              0
            ],
            [
              733,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SumOfSquaresTest, Const) { ConstTest(); }",
          "fn_code_pos": [
            [
              734,
              0
            ],
            [
              734,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SumOfSquaresTest, Ref) { RefTest(); }",
          "fn_code_pos": [
            [
              735,
              0
            ],
            [
              735,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxSubpelVarianceTest, Ref) { RefTest(); }",
          "fn_code_pos": [
            [
              736,
              0
            ],
            [
              736,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxSubpelVarianceTest, ExtremeRef) { ExtremeRefTest(); }",
          "fn_code_pos": [
            [
              737,
              0
            ],
            [
              737,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxSubpelAvgVarianceTest, Ref) { RefTest(); }",
          "fn_code_pos": [
            [
              738,
              0
            ],
            [
              738,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxHBDMseTest, RefMse) { RefTestMse(); }",
          "fn_code_pos": [
            [
              815,
              0
            ],
            [
              815,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxHBDMseTest, MaxMse) { MaxTestMse(); }",
          "fn_code_pos": [
            [
              816,
              0
            ],
            [
              816,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxHBDVarianceTest, Zero) { ZeroTest(); }",
          "fn_code_pos": [
            [
              817,
              0
            ],
            [
              817,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxHBDVarianceTest, Ref) { RefTest(); }",
          "fn_code_pos": [
            [
              818,
              0
            ],
            [
              818,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxHBDVarianceTest, RefStride) { RefStrideTest(); }",
          "fn_code_pos": [
            [
              819,
              0
            ],
            [
              819,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxHBDVarianceTest, OneQuarter) { OneQuarterTest(); }",
          "fn_code_pos": [
            [
              820,
              0
            ],
            [
              820,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxHBDVarianceTest, DISABLED_Speed) { SpeedTest(); }",
          "fn_code_pos": [
            [
              821,
              0
            ],
            [
              821,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxHBDSubpelVarianceTest, Ref) { RefTest(); }",
          "fn_code_pos": [
            [
              822,
              0
            ],
            [
              822,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxHBDSubpelVarianceTest, ExtremeRef) { ExtremeRefTest(); }",
          "fn_code_pos": [
            [
              823,
              0
            ],
            [
              823,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VpxHBDSubpelAvgVarianceTest, Ref) { RefTest(); }",
          "fn_code_pos": [
            [
              824,
              0
            ],
            [
              824,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*Get4x4SseFunc)(const uint8_t *a, int a_stride,\n                                      const uint8_t *b, int b_stride)",
          "fn_dec_pos": [
            [
              29,
              21
            ],
            [
              30,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "a": "uint8_t",
              "a_stride": "int",
              "b": "uint8_t",
              "b_stride": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*SumOfSquaresFunction)(const int16_t *src)",
          "fn_dec_pos": [
            [
              31,
              21
            ],
            [
              31,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "src": "int16_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ConstTest()",
          "fn_dec_pos": [
            [
              215,
              7
            ],
            [
              215,
              18
            ]
          ],
          "class_code": "32b740aa6c8d70788ecf5c915672eadc4d84123419195853048e7d66b111e8e6",
          "class_node_pos": [
            [
              208,
              0
            ],
            [
              220,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ConstTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "RefTest()",
          "fn_dec_pos": [
            [
              216,
              7
            ],
            [
              216,
              16
            ]
          ],
          "class_code": "32b740aa6c8d70788ecf5c915672eadc4d84123419195853048e7d66b111e8e6",
          "class_node_pos": [
            [
              208,
              0
            ],
            [
              220,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RefTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "operator<<(std::ostream &os, const TestParams<Func> &p)",
          "fn_dec_pos": [
            [
              280,
              14
            ],
            [
              280,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "p": "TestParams<Func>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ZeroTest()",
          "fn_dec_pos": [
            [
              333,
              7
            ],
            [
              333,
              17
            ]
          ],
          "class_code": "2bec3e5374a779e78636fd400fe75d670935823cffd338b9363b4c5808eff170",
          "class_node_pos": [
            [
              288,
              0
            ],
            [
              358,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ZeroTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "RefTest()",
          "fn_dec_pos": [
            [
              334,
              7
            ],
            [
              334,
              16
            ]
          ],
          "class_code": "2bec3e5374a779e78636fd400fe75d670935823cffd338b9363b4c5808eff170",
          "class_node_pos": [
            [
              288,
              0
            ],
            [
              358,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RefTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "RefStrideTest()",
          "fn_dec_pos": [
            [
              335,
              7
            ],
            [
              335,
              22
            ]
          ],
          "class_code": "2bec3e5374a779e78636fd400fe75d670935823cffd338b9363b4c5808eff170",
          "class_node_pos": [
            [
              288,
              0
            ],
            [
              358,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RefStrideTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "OneQuarterTest()",
          "fn_dec_pos": [
            [
              336,
              7
            ],
            [
              336,
              23
            ]
          ],
          "class_code": "2bec3e5374a779e78636fd400fe75d670935823cffd338b9363b4c5808eff170",
          "class_node_pos": [
            [
              288,
              0
            ],
            [
              358,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "OneQuarterTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "SpeedTest()",
          "fn_dec_pos": [
            [
              337,
              7
            ],
            [
              337,
              18
            ]
          ],
          "class_code": "2bec3e5374a779e78636fd400fe75d670935823cffd338b9363b4c5808eff170",
          "class_node_pos": [
            [
              288,
              0
            ],
            [
              358,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SpeedTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "RefTestMse()",
          "fn_dec_pos": [
            [
              340,
              7
            ],
            [
              340,
              19
            ]
          ],
          "class_code": "2bec3e5374a779e78636fd400fe75d670935823cffd338b9363b4c5808eff170",
          "class_node_pos": [
            [
              288,
              0
            ],
            [
              358,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RefTestMse",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "RefTestSse()",
          "fn_dec_pos": [
            [
              341,
              7
            ],
            [
              341,
              19
            ]
          ],
          "class_code": "2bec3e5374a779e78636fd400fe75d670935823cffd338b9363b4c5808eff170",
          "class_node_pos": [
            [
              288,
              0
            ],
            [
              358,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RefTestSse",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "MaxTestMse()",
          "fn_dec_pos": [
            [
              342,
              7
            ],
            [
              342,
              19
            ]
          ],
          "class_code": "2bec3e5374a779e78636fd400fe75d670935823cffd338b9363b4c5808eff170",
          "class_node_pos": [
            [
              288,
              0
            ],
            [
              358,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MaxTestMse",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "MaxTestSse()",
          "fn_dec_pos": [
            [
              343,
              7
            ],
            [
              343,
              19
            ]
          ],
          "class_code": "2bec3e5374a779e78636fd400fe75d670935823cffd338b9363b4c5808eff170",
          "class_node_pos": [
            [
              288,
              0
            ],
            [
              358,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MaxTestSse",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "RefTest()",
          "fn_dec_pos": [
            [
              596,
              7
            ],
            [
              596,
              16
            ]
          ],
          "class_code": "55889d652293e3a44529aa48d054162e533c6cf8d4dd7524ed86f2d28563b5c6",
          "class_node_pos": [
            [
              553,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RefTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "ExtremeRefTest()",
          "fn_dec_pos": [
            [
              597,
              7
            ],
            [
              597,
              23
            ]
          ],
          "class_code": "55889d652293e3a44529aa48d054162e533c6cf8d4dd7524ed86f2d28563b5c6",
          "class_node_pos": [
            [
              553,
              0
            ],
            [
              612,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ExtremeRefTest",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {
        "32b740aa6c8d70788ecf5c915672eadc4d84123419195853048e7d66b111e8e6": {
          "class_code": "class SumOfSquaresTest : public ::testing::TestWithParam<SumOfSquaresFunction> {\n public:\n  SumOfSquaresTest() : func_(GetParam()) {}\n\n  virtual ~SumOfSquaresTest() { libvpx_test::ClearSystemState(); }\n\n protected:\n  void ConstTest();\n  void RefTest();\n\n  SumOfSquaresFunction func_;\n  ACMRandom rnd_;\n}",
          "class_name": "SumOfSquaresTest",
          "class_pos": [
            [
              208,
              0
            ],
            [
              220,
              1
            ]
          ]
        },
        "47a7df382ee2e1f63445f78d33702c20e937c04540d4e3e01083125518e93e81": {
          "class_code": "template <typename FunctionType>\nclass MainTestClass\n    : public ::testing::TestWithParam<TestParams<FunctionType> > {\n public:\n  virtual void SetUp() {\n    params_ = this->GetParam();\n\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n    const size_t unit =\n        use_high_bit_depth() ? sizeof(uint16_t) : sizeof(uint8_t);\n    src_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size() * unit));\n    ref_ = new uint8_t[block_size() * unit];\n    ASSERT_TRUE(src_ != NULL);\n    ASSERT_TRUE(ref_ != NULL);\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (use_high_bit_depth()) {\n      // TODO(skal): remove!\n      src_ = CONVERT_TO_BYTEPTR(src_);\n      ref_ = CONVERT_TO_BYTEPTR(ref_);\n    }\n#endif\n  }\n\n  virtual void TearDown() {\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (use_high_bit_depth()) {\n      // TODO(skal): remove!\n      src_ = reinterpret_cast<uint8_t *>(CONVERT_TO_SHORTPTR(src_));\n      ref_ = reinterpret_cast<uint8_t *>(CONVERT_TO_SHORTPTR(ref_));\n    }\n#endif\n\n    vpx_free(src_);\n    delete[] ref_;\n    src_ = NULL;\n    ref_ = NULL;\n    libvpx_test::ClearSystemState();\n  }\n\n protected:\n  // We could sub-class MainTestClass into dedicated class for Variance\n  // and MSE/SSE, but it involves a lot of 'this->xxx' dereferencing\n  // to access top class fields xxx. That's cumbersome, so for now we'll just\n  // implement the testing methods here:\n\n  // Variance tests\n  void ZeroTest();\n  void RefTest();\n  void RefStrideTest();\n  void OneQuarterTest();\n  void SpeedTest();\n\n  // MSE/SSE tests\n  void RefTestMse();\n  void RefTestSse();\n  void MaxTestMse();\n  void MaxTestSse();\n\n protected:\n  ACMRandom rnd_;\n  uint8_t *src_;\n  uint8_t *ref_;\n  TestParams<FunctionType> params_;\n\n  // some relay helpers\n  bool use_high_bit_depth() const { return params_.use_high_bit_depth; }\n  int byte_shift() const { return params_.bit_depth - 8; }\n  int block_size() const { return params_.block_size; }\n  int width() const { return params_.width; }\n  int height() const { return params_.height; }\n  uint32_t mask() const { return params_.mask; }\n};",
          "class_name": "MainTestClass",
          "class_pos": [
            [
              287,
              0
            ],
            [
              358,
              2
            ]
          ]
        },
        "4b229bebda9af7c28858e9fa9f5b609ecdc5268183259b6a7872fc21012e8650": {
          "class_code": "template <typename FunctionType>\nclass SubpelVarianceTest\n    : public ::testing::TestWithParam<TestParams<FunctionType> > {\n public:\n  virtual void SetUp() {\n    params_ = this->GetParam();\n\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n    if (!use_high_bit_depth()) {\n      src_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size()));\n      sec_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size()));\n      ref_ = reinterpret_cast<uint8_t *>(\n          vpx_malloc(block_size() + width() + height() + 1));\n#if CONFIG_VP9_HIGHBITDEPTH\n    } else {\n      src_ = CONVERT_TO_BYTEPTR(reinterpret_cast<uint16_t *>(\n          vpx_memalign(16, block_size() * sizeof(uint16_t))));\n      sec_ = CONVERT_TO_BYTEPTR(reinterpret_cast<uint16_t *>(\n          vpx_memalign(16, block_size() * sizeof(uint16_t))));\n      ref_ = CONVERT_TO_BYTEPTR(reinterpret_cast<uint16_t *>(vpx_malloc(\n          (block_size() + width() + height() + 1) * sizeof(uint16_t))));\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    }\n    ASSERT_TRUE(src_ != NULL);\n    ASSERT_TRUE(sec_ != NULL);\n    ASSERT_TRUE(ref_ != NULL);\n  }\n\n  virtual void TearDown() {\n    if (!use_high_bit_depth()) {\n      vpx_free(src_);\n      vpx_free(sec_);\n      vpx_free(ref_);\n#if CONFIG_VP9_HIGHBITDEPTH\n    } else {\n      vpx_free(CONVERT_TO_SHORTPTR(src_));\n      vpx_free(CONVERT_TO_SHORTPTR(ref_));\n      vpx_free(CONVERT_TO_SHORTPTR(sec_));\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    }\n    libvpx_test::ClearSystemState();\n  }\n\n protected:\n  void RefTest();\n  void ExtremeRefTest();\n\n  ACMRandom rnd_;\n  uint8_t *src_;\n  uint8_t *ref_;\n  uint8_t *sec_;\n  TestParams<FunctionType> params_;\n\n  // some relay helpers\n  bool use_high_bit_depth() const { return params_.use_high_bit_depth; }\n  int byte_shift() const { return params_.bit_depth - 8; }\n  int block_size() const { return params_.block_size; }\n  int width() const { return params_.width; }\n  int height() const { return params_.height; }\n  uint32_t mask() const { return params_.mask; }\n};",
          "class_name": "SubpelVarianceTest",
          "class_pos": [
            [
              552,
              0
            ],
            [
              612,
              2
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct TestParams {\n  TestParams(int log2w = 0, int log2h = 0, Func function = NULL,\n             int bit_depth_value = 0)\n      : log2width(log2w), log2height(log2h), func(function) {\n    use_high_bit_depth = (bit_depth_value > 0);\n    if (use_high_bit_depth) {\n      bit_depth = static_cast<vpx_bit_depth_t>(bit_depth_value);\n    } else {\n      bit_depth = VPX_BITS_8;\n    }\n    width = 1 << log2width;\n    height = 1 << log2height;\n    block_size = width * height;\n    mask = (1u << bit_depth) - 1;\n  }\n\n  int log2width, log2height;\n  int width, height;\n  int block_size;\n  Func func;\n  vpx_bit_depth_t bit_depth;\n  bool use_high_bit_depth;\n  uint32_t mask;\n}",
          {
            "log2width": "int",
            "width": "int",
            "block_size": "int",
            "func": "Func",
            "bit_depth": "vpx_bit_depth_t",
            "use_high_bit_depth": "bool",
            "mask": "uint32_t"
          },
          "TestParams",
          [
            254,
            0
          ],
          [
            277,
            1
          ]
        ],
        [
          "struct TestParams {\n  TestParams(int log2w = 0, int log2h = 0, Func function = NULL,\n             int bit_depth_value = 0)\n      : log2width(log2w), log2height(log2h), func(function) {\n    use_high_bit_depth = (bit_depth_value > 0);\n    if (use_high_bit_depth) {\n      bit_depth = static_cast<vpx_bit_depth_t>(bit_depth_value);\n    } else {\n      bit_depth = VPX_BITS_8;\n    }\n    width = 1 << log2width;\n    height = 1 << log2height;\n    block_size = width * height;\n    mask = (1u << bit_depth) - 1;\n  }\n\n  int log2width, log2height;\n  int width, height;\n  int block_size;\n  Func func;\n  vpx_bit_depth_t bit_depth;\n  bool use_high_bit_depth;\n  uint32_t mask;\n}",
          {
            "log2width": "int",
            "width": "int",
            "block_size": "int",
            "func": "Func",
            "bit_depth": "vpx_bit_depth_t",
            "use_high_bit_depth": "bool",
            "mask": "uint32_t"
          },
          "TestParams",
          [
            254,
            0
          ],
          [
            277,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include <cstdlib>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <new>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_codec.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"vpx_dsp/variance.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"vpx_ports/mem.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"vpx_ports/vpx_timer.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp9_lossless_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "LosslessTest()\n      : EncoderTest(GET_PARAM(0)), psnr_(kMaxPsnr), nframes_(0),\n        encoding_mode_(GET_PARAM(1)) {}",
          "fn_code_pos": [
            [
              27,
              2
            ],
            [
              29,
              39
            ]
          ],
          "class_code": "5392ea32fd041073fb331232d5fca58898c083e24c2eab7c6202c7bed48f4a9a",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              64,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "LosslessTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~LosslessTest() {}",
          "fn_code_pos": [
            [
              31,
              2
            ],
            [
              31,
              28
            ]
          ],
          "class_code": "5392ea32fd041073fb331232d5fca58898c083e24c2eab7c6202c7bed48f4a9a",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              64,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n  }",
          "fn_code_pos": [
            [
              33,
              2
            ],
            [
              36,
              3
            ]
          ],
          "class_code": "5392ea32fd041073fb331232d5fca58898c083e24c2eab7c6202c7bed48f4a9a",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              64,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      // Only call Control if quantizer > 0 to verify that using quantizer\n      // alone will activate lossless\n      if (cfg_.rc_max_quantizer > 0 || cfg_.rc_min_quantizer > 0) {\n        encoder->Control(VP9E_SET_LOSSLESS, 1);\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              38,
              2
            ],
            [
              47,
              3
            ]
          ],
          "class_code": "5392ea32fd041073fb331232d5fca58898c083e24c2eab7c6202c7bed48f4a9a",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              64,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void BeginPassHook(unsigned int /*pass*/) {\n    psnr_ = kMaxPsnr;\n    nframes_ = 0;\n  }",
          "fn_code_pos": [
            [
              49,
              2
            ],
            [
              52,
              3
            ]
          ],
          "class_code": "5392ea32fd041073fb331232d5fca58898c083e24c2eab7c6202c7bed48f4a9a",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              64,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BeginPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (pkt->data.psnr.psnr[0] < psnr_) psnr_ = pkt->data.psnr.psnr[0];\n  }",
          "fn_code_pos": [
            [
              54,
              2
            ],
            [
              56,
              3
            ]
          ],
          "class_code": "5392ea32fd041073fb331232d5fca58898c083e24c2eab7c6202c7bed48f4a9a",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              64,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PSNRPktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "double GetMinPsnr() const { return psnr_; }",
          "fn_code_pos": [
            [
              58,
              2
            ],
            [
              58,
              45
            ]
          ],
          "class_code": "5392ea32fd041073fb331232d5fca58898c083e24c2eab7c6202c7bed48f4a9a",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              64,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetMinPsnr",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "TEST_P(LosslessTest, TestLossLessEncoding) {\n  const vpx_rational timebase = { 33333333, 1000000000 };\n  cfg_.g_timebase = timebase;\n  cfg_.rc_target_bitrate = 2000;\n  cfg_.g_lag_in_frames = 25;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 0;\n\n  init_flags_ = VPX_CODEC_USE_PSNR;\n\n  // intentionally changed the dimension for better testing coverage\n  libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                     timebase.den, timebase.num, 0, 10);\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  const double psnr_lossless = GetMinPsnr();\n  EXPECT_GE(psnr_lossless, kMaxPsnr);\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(LosslessTest, TestLossLessEncoding444) {\n  libvpx_test::Y4mVideoSource video(\"rush_hour_444.y4m\", 0, 10);\n\n  cfg_.g_profile = 1;\n  cfg_.g_timebase = video.timebase();\n  cfg_.rc_target_bitrate = 2000;\n  cfg_.g_lag_in_frames = 25;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 0;\n\n  init_flags_ = VPX_CODEC_USE_PSNR;\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  const double psnr_lossless = GetMinPsnr();\n  EXPECT_GE(psnr_lossless, kMaxPsnr);\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              99,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(LosslessTest, TestLossLessEncodingCtrl) {\n  const vpx_rational timebase = { 33333333, 1000000000 };\n  cfg_.g_timebase = timebase;\n  cfg_.rc_target_bitrate = 2000;\n  cfg_.g_lag_in_frames = 25;\n  // Intentionally set Q > 0, to make sure control can be used to activate\n  // lossless\n  cfg_.rc_min_quantizer = 10;\n  cfg_.rc_max_quantizer = 20;\n\n  init_flags_ = VPX_CODEC_USE_PSNR;\n\n  libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                     timebase.den, timebase.num, 0, 10);\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  const double psnr_lossless = GetMinPsnr();\n  EXPECT_GE(psnr_lossless, kMaxPsnr);\n}",
          "fn_code_pos": [
            [
              101,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "5392ea32fd041073fb331232d5fca58898c083e24c2eab7c6202c7bed48f4a9a": {
          "class_code": "class LosslessTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWithParam<libvpx_test::TestMode> {\n protected:\n  LosslessTest()\n      : EncoderTest(GET_PARAM(0)), psnr_(kMaxPsnr), nframes_(0),\n        encoding_mode_(GET_PARAM(1)) {}\n\n  virtual ~LosslessTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      // Only call Control if quantizer > 0 to verify that using quantizer\n      // alone will activate lossless\n      if (cfg_.rc_max_quantizer > 0 || cfg_.rc_min_quantizer > 0) {\n        encoder->Control(VP9E_SET_LOSSLESS, 1);\n      }\n    }\n  }\n\n  virtual void BeginPassHook(unsigned int /*pass*/) {\n    psnr_ = kMaxPsnr;\n    nframes_ = 0;\n  }\n\n  virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (pkt->data.psnr.psnr[0] < psnr_) psnr_ = pkt->data.psnr.psnr[0];\n  }\n\n  double GetMinPsnr() const { return psnr_; }\n\n private:\n  double psnr_;\n  unsigned int nframes_;\n  libvpx_test::TestMode encoding_mode_;\n}",
          "class_name": "LosslessTest",
          "class_pos": [
            [
              23,
              0
            ],
            [
              64,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/y4m_video_source.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp9_scale_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "virtual ~ScaleTest() {}",
          "fn_code_pos": [
            [
              35,
              2
            ],
            [
              35,
              25
            ]
          ],
          "class_code": "59896c4a4f6667f6b4a4cea33274e858a51096ebcaf198a88d7fa850b925dd7c",
          "class_node_pos": [
            [
              32,
              0
            ],
            [
              143,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() { scale_fn_ = GetParam(); }",
          "fn_code_pos": [
            [
              38,
              2
            ],
            [
              38,
              50
            ]
          ],
          "class_code": "59896c4a4f6667f6b4a4cea33274e858a51096ebcaf198a88d7fa850b925dd7c",
          "class_node_pos": [
            [
              32,
              0
            ],
            [
              143,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ReferenceScaleFrame(INTERP_FILTER filter_type, int phase_scaler) {\n    vp9_scale_and_extend_frame_c(&img_, &ref_img_, filter_type, phase_scaler);\n  }",
          "fn_code_pos": [
            [
              40,
              2
            ],
            [
              42,
              3
            ]
          ],
          "class_code": "59896c4a4f6667f6b4a4cea33274e858a51096ebcaf198a88d7fa850b925dd7c",
          "class_node_pos": [
            [
              32,
              0
            ],
            [
              143,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ReferenceScaleFrame",
            "parameters": {
              "filter_type": "INTERP_FILTER",
              "phase_scaler": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ScaleFrame(INTERP_FILTER filter_type, int phase_scaler) {\n    ASM_REGISTER_STATE_CHECK(\n        scale_fn_(&img_, &dst_img_, filter_type, phase_scaler));\n  }",
          "fn_code_pos": [
            [
              44,
              2
            ],
            [
              47,
              3
            ]
          ],
          "class_code": "59896c4a4f6667f6b4a4cea33274e858a51096ebcaf198a88d7fa850b925dd7c",
          "class_node_pos": [
            [
              32,
              0
            ],
            [
              143,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ScaleFrame",
            "parameters": {
              "filter_type": "INTERP_FILTER",
              "phase_scaler": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void RunTest(INTERP_FILTER filter_type) {\n    static const int kNumSizesToTest = 20;\n    static const int kNumScaleFactorsToTest = 4;\n    static const int kSizesToTest[] = {\n      2,  4,  6,  8,  10, 12, 14, 16, 18,  20,\n      22, 24, 26, 28, 30, 32, 34, 68, 128, 134\n    };\n    static const int kScaleFactors[] = { 1, 2, 3, 4 };\n    for (int phase_scaler = 0; phase_scaler < 16; ++phase_scaler) {\n      for (int h = 0; h < kNumSizesToTest; ++h) {\n        const int src_height = kSizesToTest[h];\n        for (int w = 0; w < kNumSizesToTest; ++w) {\n          const int src_width = kSizesToTest[w];\n          for (int sf_up_idx = 0; sf_up_idx < kNumScaleFactorsToTest;\n               ++sf_up_idx) {\n            const int sf_up = kScaleFactors[sf_up_idx];\n            for (int sf_down_idx = 0; sf_down_idx < kNumScaleFactorsToTest;\n                 ++sf_down_idx) {\n              const int sf_down = kScaleFactors[sf_down_idx];\n              const int dst_width = src_width * sf_up / sf_down;\n              const int dst_height = src_height * sf_up / sf_down;\n              if (sf_up == sf_down && sf_up != 1) {\n                continue;\n              }\n              // I420 frame width and height must be even.\n              if (!dst_width || !dst_height || dst_width & 1 ||\n                  dst_height & 1) {\n                continue;\n              }\n              // vpx_convolve8_c() has restriction on the step which cannot\n              // exceed 64 (ratio 1 to 4).\n              if (src_width > 4 * dst_width || src_height > 4 * dst_height) {\n                continue;\n              }\n              ASSERT_NO_FATAL_FAILURE(ResetScaleImages(src_width, src_height,\n                                                       dst_width, dst_height));\n              ReferenceScaleFrame(filter_type, phase_scaler);\n              ScaleFrame(filter_type, phase_scaler);\n              if (memcmp(dst_img_.buffer_alloc, ref_img_.buffer_alloc,\n                         ref_img_.frame_size)) {\n                printf(\n                    \"filter_type = %d, phase_scaler = %d, src_width = %4d, \"\n                    \"src_height = %4d, dst_width = %4d, dst_height = %4d, \"\n                    \"scale factor = %d:%d\\n\",\n                    filter_type, phase_scaler, src_width, src_height, dst_width,\n                    dst_height, sf_down, sf_up);\n                PrintDiff();\n              }\n              CompareImages(dst_img_);\n              DeallocScaleImages();\n            }\n          }\n        }\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              49,
              2
            ],
            [
              104,
              3
            ]
          ],
          "class_code": "59896c4a4f6667f6b4a4cea33274e858a51096ebcaf198a88d7fa850b925dd7c",
          "class_node_pos": [
            [
              32,
              0
            ],
            [
              143,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunTest",
            "parameters": {
              "filter_type": "INTERP_FILTER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void PrintDiffComponent(const uint8_t *const ref, const uint8_t *const opt,\n                          const int stride, const int width, const int height,\n                          const int plane_idx) const {\n    for (int y = 0; y < height; y++) {\n      for (int x = 0; x < width; x++) {\n        if (ref[y * stride + x] != opt[y * stride + x]) {\n          printf(\"Plane %d pixel[%d][%d] diff:%6d (ref),%6d (opt)\\n\", plane_idx,\n                 y, x, ref[y * stride + x], opt[y * stride + x]);\n          break;\n        }\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              106,
              2
            ],
            [
              118,
              3
            ]
          ],
          "class_code": "59896c4a4f6667f6b4a4cea33274e858a51096ebcaf198a88d7fa850b925dd7c",
          "class_node_pos": [
            [
              32,
              0
            ],
            [
              143,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PrintDiffComponent",
            "parameters": {
              "ref": "uint8_t",
              "opt": "uint8_t",
              "stride": "int",
              "width": "int",
              "height": "int",
              "plane_idx": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void PrintDiff() const {\n    assert(ref_img_.y_stride == dst_img_.y_stride);\n    assert(ref_img_.y_width == dst_img_.y_width);\n    assert(ref_img_.y_height == dst_img_.y_height);\n    assert(ref_img_.uv_stride == dst_img_.uv_stride);\n    assert(ref_img_.uv_width == dst_img_.uv_width);\n    assert(ref_img_.uv_height == dst_img_.uv_height);\n\n    if (memcmp(dst_img_.buffer_alloc, ref_img_.buffer_alloc,\n               ref_img_.frame_size)) {\n      PrintDiffComponent(ref_img_.y_buffer, dst_img_.y_buffer,\n                         ref_img_.y_stride, ref_img_.y_width, ref_img_.y_height,\n                         0);\n      PrintDiffComponent(ref_img_.u_buffer, dst_img_.u_buffer,\n                         ref_img_.uv_stride, ref_img_.uv_width,\n                         ref_img_.uv_height, 1);\n      PrintDiffComponent(ref_img_.v_buffer, dst_img_.v_buffer,\n                         ref_img_.uv_stride, ref_img_.uv_width,\n                         ref_img_.uv_height, 2);\n    }\n  }",
          "fn_code_pos": [
            [
              120,
              2
            ],
            [
              140,
              3
            ]
          ],
          "class_code": "59896c4a4f6667f6b4a4cea33274e858a51096ebcaf198a88d7fa850b925dd7c",
          "class_node_pos": [
            [
              32,
              0
            ],
            [
              143,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PrintDiff",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(ScaleTest, ScaleFrame_EightTap) { RunTest(EIGHTTAP); }",
          "fn_code_pos": [
            [
              145,
              0
            ],
            [
              145,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ScaleTest, ScaleFrame_EightTapSmooth) { RunTest(EIGHTTAP_SMOOTH); }",
          "fn_code_pos": [
            [
              146,
              0
            ],
            [
              146,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ScaleTest, ScaleFrame_EightTapSharp) { RunTest(EIGHTTAP_SHARP); }",
          "fn_code_pos": [
            [
              147,
              0
            ],
            [
              147,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ScaleTest, ScaleFrame_Bilinear) { RunTest(BILINEAR); }",
          "fn_code_pos": [
            [
              148,
              0
            ],
            [
              148,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(ScaleTest, DISABLED_Speed) {\n  static const int kCountSpeedTestBlock = 100;\n  static const int kNumScaleFactorsToTest = 4;\n  static const int kScaleFactors[] = { 1, 2, 3, 4 };\n  const int src_width = 1280;\n  const int src_height = 720;\n  for (INTERP_FILTER filter_type = 2; filter_type < 4; ++filter_type) {\n    for (int phase_scaler = 0; phase_scaler < 2; ++phase_scaler) {\n      for (int sf_up_idx = 0; sf_up_idx < kNumScaleFactorsToTest; ++sf_up_idx) {\n        const int sf_up = kScaleFactors[sf_up_idx];\n        for (int sf_down_idx = 0; sf_down_idx < kNumScaleFactorsToTest;\n             ++sf_down_idx) {\n          const int sf_down = kScaleFactors[sf_down_idx];\n          const int dst_width = src_width * sf_up / sf_down;\n          const int dst_height = src_height * sf_up / sf_down;\n          if (sf_up == sf_down && sf_up != 1) {\n            continue;\n          }\n          // I420 frame width and height must be even.\n          if (dst_width & 1 || dst_height & 1) {\n            continue;\n          }\n          ASSERT_NO_FATAL_FAILURE(\n              ResetScaleImages(src_width, src_height, dst_width, dst_height));\n          ASM_REGISTER_STATE_CHECK(\n              ReferenceScaleFrame(filter_type, phase_scaler));\n\n          vpx_usec_timer timer;\n          vpx_usec_timer_start(&timer);\n          for (int i = 0; i < kCountSpeedTestBlock; ++i) {\n            ScaleFrame(filter_type, phase_scaler);\n          }\n          libvpx_test::ClearSystemState();\n          vpx_usec_timer_mark(&timer);\n          const int elapsed_time =\n              static_cast<int>(vpx_usec_timer_elapsed(&timer) / 1000);\n          CompareImages(dst_img_);\n          DeallocScaleImages();\n\n          printf(\n              \"filter_type = %d, phase_scaler = %d, src_width = %4d, \"\n              \"src_height = %4d, dst_width = %4d, dst_height = %4d, \"\n              \"scale factor = %d:%d, scale time: %5d ms\\n\",\n              filter_type, phase_scaler, src_width, src_height, dst_width,\n              dst_height, sf_down, sf_up, elapsed_time);\n        }\n      }\n    }\n  }\n}",
          "fn_code_pos": [
            [
              150,
              0
            ],
            [
              199,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*ScaleFrameFunc)(const YV12_BUFFER_CONFIG *src,\n                               YV12_BUFFER_CONFIG *dst,\n                               INTERP_FILTER filter_type, int phase_scaler)",
          "fn_dec_pos": [
            [
              28,
              13
            ],
            [
              30,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "src": "YV12_BUFFER_CONFIG",
              "dst": "YV12_BUFFER_CONFIG",
              "filter_type": "INTERP_FILTER",
              "phase_scaler": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {
        "59896c4a4f6667f6b4a4cea33274e858a51096ebcaf198a88d7fa850b925dd7c": {
          "class_code": "class ScaleTest : public VpxScaleBase,\n                  public ::testing::TestWithParam<ScaleFrameFunc> {\n public:\n  virtual ~ScaleTest() {}\n\n protected:\n  virtual void SetUp() { scale_fn_ = GetParam(); }\n\n  void ReferenceScaleFrame(INTERP_FILTER filter_type, int phase_scaler) {\n    vp9_scale_and_extend_frame_c(&img_, &ref_img_, filter_type, phase_scaler);\n  }\n\n  void ScaleFrame(INTERP_FILTER filter_type, int phase_scaler) {\n    ASM_REGISTER_STATE_CHECK(\n        scale_fn_(&img_, &dst_img_, filter_type, phase_scaler));\n  }\n\n  void RunTest(INTERP_FILTER filter_type) {\n    static const int kNumSizesToTest = 20;\n    static const int kNumScaleFactorsToTest = 4;\n    static const int kSizesToTest[] = {\n      2,  4,  6,  8,  10, 12, 14, 16, 18,  20,\n      22, 24, 26, 28, 30, 32, 34, 68, 128, 134\n    };\n    static const int kScaleFactors[] = { 1, 2, 3, 4 };\n    for (int phase_scaler = 0; phase_scaler < 16; ++phase_scaler) {\n      for (int h = 0; h < kNumSizesToTest; ++h) {\n        const int src_height = kSizesToTest[h];\n        for (int w = 0; w < kNumSizesToTest; ++w) {\n          const int src_width = kSizesToTest[w];\n          for (int sf_up_idx = 0; sf_up_idx < kNumScaleFactorsToTest;\n               ++sf_up_idx) {\n            const int sf_up = kScaleFactors[sf_up_idx];\n            for (int sf_down_idx = 0; sf_down_idx < kNumScaleFactorsToTest;\n                 ++sf_down_idx) {\n              const int sf_down = kScaleFactors[sf_down_idx];\n              const int dst_width = src_width * sf_up / sf_down;\n              const int dst_height = src_height * sf_up / sf_down;\n              if (sf_up == sf_down && sf_up != 1) {\n                continue;\n              }\n              // I420 frame width and height must be even.\n              if (!dst_width || !dst_height || dst_width & 1 ||\n                  dst_height & 1) {\n                continue;\n              }\n              // vpx_convolve8_c() has restriction on the step which cannot\n              // exceed 64 (ratio 1 to 4).\n              if (src_width > 4 * dst_width || src_height > 4 * dst_height) {\n                continue;\n              }\n              ASSERT_NO_FATAL_FAILURE(ResetScaleImages(src_width, src_height,\n                                                       dst_width, dst_height));\n              ReferenceScaleFrame(filter_type, phase_scaler);\n              ScaleFrame(filter_type, phase_scaler);\n              if (memcmp(dst_img_.buffer_alloc, ref_img_.buffer_alloc,\n                         ref_img_.frame_size)) {\n                printf(\n                    \"filter_type = %d, phase_scaler = %d, src_width = %4d, \"\n                    \"src_height = %4d, dst_width = %4d, dst_height = %4d, \"\n                    \"scale factor = %d:%d\\n\",\n                    filter_type, phase_scaler, src_width, src_height, dst_width,\n                    dst_height, sf_down, sf_up);\n                PrintDiff();\n              }\n              CompareImages(dst_img_);\n              DeallocScaleImages();\n            }\n          }\n        }\n      }\n    }\n  }\n\n  void PrintDiffComponent(const uint8_t *const ref, const uint8_t *const opt,\n                          const int stride, const int width, const int height,\n                          const int plane_idx) const {\n    for (int y = 0; y < height; y++) {\n      for (int x = 0; x < width; x++) {\n        if (ref[y * stride + x] != opt[y * stride + x]) {\n          printf(\"Plane %d pixel[%d][%d] diff:%6d (ref),%6d (opt)\\n\", plane_idx,\n                 y, x, ref[y * stride + x], opt[y * stride + x]);\n          break;\n        }\n      }\n    }\n  }\n\n  void PrintDiff() const {\n    assert(ref_img_.y_stride == dst_img_.y_stride);\n    assert(ref_img_.y_width == dst_img_.y_width);\n    assert(ref_img_.y_height == dst_img_.y_height);\n    assert(ref_img_.uv_stride == dst_img_.uv_stride);\n    assert(ref_img_.uv_width == dst_img_.uv_width);\n    assert(ref_img_.uv_height == dst_img_.uv_height);\n\n    if (memcmp(dst_img_.buffer_alloc, ref_img_.buffer_alloc,\n               ref_img_.frame_size)) {\n      PrintDiffComponent(ref_img_.y_buffer, dst_img_.y_buffer,\n                         ref_img_.y_stride, ref_img_.y_width, ref_img_.y_height,\n                         0);\n      PrintDiffComponent(ref_img_.u_buffer, dst_img_.u_buffer,\n                         ref_img_.uv_stride, ref_img_.uv_width,\n                         ref_img_.uv_height, 1);\n      PrintDiffComponent(ref_img_.v_buffer, dst_img_.v_buffer,\n                         ref_img_.uv_stride, ref_img_.uv_width,\n                         ref_img_.uv_height, 2);\n    }\n  }\n\n  ScaleFrameFunc scale_fn_;\n}",
          "class_name": "ScaleTest",
          "class_pos": [
            [
              32,
              0
            ],
            [
              143,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <assert.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"./vp9_rtcd.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"./vpx_scale_rtcd.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"test/vpx_scale_test.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"vpx_ports/vpx_timer.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"vpx_scale/yv12config.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/dct32x32_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "void reference_32x32_dct_1d(const double in[32], double out[32]) {\n  const double kInvSqrt2 = 0.707106781186547524400844362104;\n  for (int k = 0; k < 32; k++) {\n    out[k] = 0.0;\n    for (int n = 0; n < 32; n++) {\n      out[k] += in[n] * cos(kPi * (2 * n + 1) * k / 64.0);\n    }\n    if (k == 0) out[k] = out[k] * kInvSqrt2;\n  }\n}",
          "fn_code_pos": [
            [
              37,
              0
            ],
            [
              46,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reference_32x32_dct_1d",
            "parameters": {
              "in": "double",
              "out": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void reference_32x32_dct_2d(const int16_t input[kNumCoeffs],\n                            double output[kNumCoeffs]) {\n  // First transform columns\n  for (int i = 0; i < 32; ++i) {\n    double temp_in[32], temp_out[32];\n    for (int j = 0; j < 32; ++j) temp_in[j] = input[j * 32 + i];\n    reference_32x32_dct_1d(temp_in, temp_out);\n    for (int j = 0; j < 32; ++j) output[j * 32 + i] = temp_out[j];\n  }\n  // Then transform rows\n  for (int i = 0; i < 32; ++i) {\n    double temp_in[32], temp_out[32];\n    for (int j = 0; j < 32; ++j) temp_in[j] = output[j + i * 32];\n    reference_32x32_dct_1d(temp_in, temp_out);\n    // Scale by some magic number\n    for (int j = 0; j < 32; ++j) output[j + i * 32] = temp_out[j] / 4;\n  }\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reference_32x32_dct_2d",
            "parameters": {
              "input": "int16_t",
              "output": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct32x32_10(const tran_low_t *in, uint8_t *out, int stride) {\n  vpx_highbd_idct32x32_1024_add_c(in, CAST_TO_SHORTPTR(out), stride, 10);\n}",
          "fn_code_pos": [
            [
              74,
              0
            ],
            [
              76,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct32x32_10",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void idct32x32_12(const tran_low_t *in, uint8_t *out, int stride) {\n  vpx_highbd_idct32x32_1024_add_c(in, CAST_TO_SHORTPTR(out), stride, 12);\n}",
          "fn_code_pos": [
            [
              78,
              0
            ],
            [
              80,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "idct32x32_12",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual ~Trans32x32Test() {}",
          "fn_code_pos": [
            [
              86,
              2
            ],
            [
              86,
              30
            ]
          ],
          "class_code": "b5e8c4988ed84c8ac5e0f1d7d687548d155d0f09cca2d4b04cc85cd4f8701494",
          "class_node_pos": [
            [
              83,
              0
            ],
            [
              108,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n    version_ = GET_PARAM(2);  // 0: high precision forward transform\n                              // 1: low precision version for rd loop\n    bit_depth_ = GET_PARAM(3);\n    mask_ = (1 << bit_depth_) - 1;\n  }",
          "fn_code_pos": [
            [
              87,
              2
            ],
            [
              94,
              3
            ]
          ],
          "class_code": "b5e8c4988ed84c8ac5e0f1d7d687548d155d0f09cca2d4b04cc85cd4f8701494",
          "class_node_pos": [
            [
              83,
              0
            ],
            [
              108,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              96,
              2
            ],
            [
              96,
              62
            ]
          ],
          "class_code": "b5e8c4988ed84c8ac5e0f1d7d687548d155d0f09cca2d4b04cc85cd4f8701494",
          "class_node_pos": [
            [
              83,
              0
            ],
            [
              108,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Trans32x32Test::Run() { fwd_txfm_(bench_in_, bench_out_, 32); }",
          "fn_code_pos": [
            [
              110,
              0
            ],
            [
              110,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Trans32x32Test::Run",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(Trans32x32Test, AccuracyCheck) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  uint32_t max_error = 0;\n  int64_t total_error = 0;\n  const int count_test_block = 10000;\n  DECLARE_ALIGNED(16, int16_t, test_input_block[kNumCoeffs]);\n  DECLARE_ALIGNED(16, tran_low_t, test_temp_block[kNumCoeffs]);\n  DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n  DECLARE_ALIGNED(16, uint8_t, src[kNumCoeffs]);\n#if CONFIG_VP9_HIGHBITDEPTH\n  DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n  DECLARE_ALIGNED(16, uint16_t, src16[kNumCoeffs]);\n#endif\n\n  for (int i = 0; i < count_test_block; ++i) {\n    // Initialize a test block with input range [-mask_, mask_].\n    for (int j = 0; j < kNumCoeffs; ++j) {\n      if (bit_depth_ == VPX_BITS_8) {\n        src[j] = rnd.Rand8();\n        dst[j] = rnd.Rand8();\n        test_input_block[j] = src[j] - dst[j];\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        src16[j] = rnd.Rand16() & mask_;\n        dst16[j] = rnd.Rand16() & mask_;\n        test_input_block[j] = src16[j] - dst16[j];\n#endif\n      }\n    }\n\n    ASM_REGISTER_STATE_CHECK(fwd_txfm_(test_input_block, test_temp_block, 32));\n    if (bit_depth_ == VPX_BITS_8) {\n      ASM_REGISTER_STATE_CHECK(inv_txfm_(test_temp_block, dst, 32));\n#if CONFIG_VP9_HIGHBITDEPTH\n    } else {\n      ASM_REGISTER_STATE_CHECK(\n          inv_txfm_(test_temp_block, CAST_TO_BYTEPTR(dst16), 32));\n#endif\n    }\n\n    for (int j = 0; j < kNumCoeffs; ++j) {\n#if CONFIG_VP9_HIGHBITDEPTH\n      const int32_t diff =\n          bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n#else\n      const int32_t diff = dst[j] - src[j];\n#endif\n      const uint32_t error = diff * diff;\n      if (max_error < error) max_error = error;\n      total_error += error;\n    }\n  }\n\n  if (version_ == 1) {\n    max_error /= 2;\n    total_error /= 45;\n  }\n\n  EXPECT_GE(1u << 2 * (bit_depth_ - 8), max_error)\n      << \"Error: 32x32 FDCT/IDCT has an individual round-trip error > 1\";\n\n  EXPECT_GE(count_test_block << 2 * (bit_depth_ - 8), total_error)\n      << \"Error: 32x32 FDCT/IDCT has average round-trip error > 1 per block\";\n}",
          "fn_code_pos": [
            [
              112,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(Trans32x32Test, CoeffCheck) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  const int count_test_block = 1000;\n\n  DECLARE_ALIGNED(16, int16_t, input_block[kNumCoeffs]);\n  DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);\n  DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);\n\n  for (int i = 0; i < count_test_block; ++i) {\n    for (int j = 0; j < kNumCoeffs; ++j) {\n      input_block[j] = (rnd.Rand16() & mask_) - (rnd.Rand16() & mask_);\n    }\n\n    const int stride = 32;\n    vpx_fdct32x32_c(input_block, output_ref_block, stride);\n    ASM_REGISTER_STATE_CHECK(fwd_txfm_(input_block, output_block, stride));\n\n    if (version_ == 0) {\n      for (int j = 0; j < kNumCoeffs; ++j)\n        EXPECT_EQ(output_block[j], output_ref_block[j])\n            << \"Error: 32x32 FDCT versions have mismatched coefficients\";\n    } else {\n      for (int j = 0; j < kNumCoeffs; ++j)\n        EXPECT_GE(6, abs(output_block[j] - output_ref_block[j]))\n            << \"Error: 32x32 FDCT rd has mismatched coefficients\";\n    }\n  }\n}",
          "fn_code_pos": [
            [
              177,
              0
            ],
            [
              204,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(Trans32x32Test, MemCheck) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  const int count_test_block = 2000;\n\n  DECLARE_ALIGNED(16, int16_t, input_extreme_block[kNumCoeffs]);\n  DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);\n  DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);\n\n  for (int i = 0; i < count_test_block; ++i) {\n    // Initialize a test block with input range [-mask_, mask_].\n    for (int j = 0; j < kNumCoeffs; ++j) {\n      input_extreme_block[j] = rnd.Rand8() & 1 ? mask_ : -mask_;\n    }\n    if (i == 0) {\n      for (int j = 0; j < kNumCoeffs; ++j) input_extreme_block[j] = mask_;\n    } else if (i == 1) {\n      for (int j = 0; j < kNumCoeffs; ++j) input_extreme_block[j] = -mask_;\n    }\n\n    const int stride = 32;\n    vpx_fdct32x32_c(input_extreme_block, output_ref_block, stride);\n    ASM_REGISTER_STATE_CHECK(\n        fwd_txfm_(input_extreme_block, output_block, stride));\n\n    // The minimum quant value is 4.\n    for (int j = 0; j < kNumCoeffs; ++j) {\n      if (version_ == 0) {\n        EXPECT_EQ(output_block[j], output_ref_block[j])\n            << \"Error: 32x32 FDCT versions have mismatched coefficients\";\n      } else {\n        EXPECT_GE(6, abs(output_block[j] - output_ref_block[j]))\n            << \"Error: 32x32 FDCT rd has mismatched coefficients\";\n      }\n      EXPECT_GE(4 * DCT_MAX_VALUE << (bit_depth_ - 8), abs(output_ref_block[j]))\n          << \"Error: 32x32 FDCT C has coefficient larger than 4*DCT_MAX_VALUE\";\n      EXPECT_GE(4 * DCT_MAX_VALUE << (bit_depth_ - 8), abs(output_block[j]))\n          << \"Error: 32x32 FDCT has coefficient larger than \"\n          << \"4*DCT_MAX_VALUE\";\n    }\n  }\n}",
          "fn_code_pos": [
            [
              206,
              0
            ],
            [
              246,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(Trans32x32Test, DISABLED_Speed) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n\n  DECLARE_ALIGNED(16, int16_t, input_extreme_block[kNumCoeffs]);\n  DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);\n\n  bench_in_ = input_extreme_block;\n  bench_out_ = output_block;\n\n  RunNTimes(INT16_MAX);\n  PrintMedian(\"32x32\");\n}",
          "fn_code_pos": [
            [
              248,
              0
            ],
            [
              259,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(Trans32x32Test, InverseAccuracy) {\n  ACMRandom rnd(ACMRandom::DeterministicSeed());\n  const int count_test_block = 1000;\n  DECLARE_ALIGNED(16, int16_t, in[kNumCoeffs]);\n  DECLARE_ALIGNED(16, tran_low_t, coeff[kNumCoeffs]);\n  DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);\n  DECLARE_ALIGNED(16, uint8_t, src[kNumCoeffs]);\n#if CONFIG_VP9_HIGHBITDEPTH\n  DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);\n  DECLARE_ALIGNED(16, uint16_t, src16[kNumCoeffs]);\n#endif\n\n  for (int i = 0; i < count_test_block; ++i) {\n    double out_r[kNumCoeffs];\n\n    // Initialize a test block with input range [-255, 255]\n    for (int j = 0; j < kNumCoeffs; ++j) {\n      if (bit_depth_ == VPX_BITS_8) {\n        src[j] = rnd.Rand8();\n        dst[j] = rnd.Rand8();\n        in[j] = src[j] - dst[j];\n#if CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        src16[j] = rnd.Rand16() & mask_;\n        dst16[j] = rnd.Rand16() & mask_;\n        in[j] = src16[j] - dst16[j];\n#endif\n      }\n    }\n\n    reference_32x32_dct_2d(in, out_r);\n    for (int j = 0; j < kNumCoeffs; ++j) {\n      coeff[j] = static_cast<tran_low_t>(round(out_r[j]));\n    }\n    if (bit_depth_ == VPX_BITS_8) {\n      ASM_REGISTER_STATE_CHECK(inv_txfm_(coeff, dst, 32));\n#if CONFIG_VP9_HIGHBITDEPTH\n    } else {\n      ASM_REGISTER_STATE_CHECK(inv_txfm_(coeff, CAST_TO_BYTEPTR(dst16), 32));\n#endif\n    }\n    for (int j = 0; j < kNumCoeffs; ++j) {\n#if CONFIG_VP9_HIGHBITDEPTH\n      const int diff =\n          bit_depth_ == VPX_BITS_8 ? dst[j] - src[j] : dst16[j] - src16[j];\n#else\n      const int diff = dst[j] - src[j];\n#endif\n      const int error = diff * diff;\n      EXPECT_GE(1, error) << \"Error: 32x32 IDCT has error \" << error\n                          << \" at index \" << j;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              261,
              0
            ],
            [
              314,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*FwdTxfmFunc)(const int16_t *in, tran_low_t *out, int stride)",
          "fn_dec_pos": [
            [
              67,
              13
            ],
            [
              67,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "int16_t",
              "out": "tran_low_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*InvTxfmFunc)(const tran_low_t *in, uint8_t *out, int stride)",
          "fn_dec_pos": [
            [
              68,
              13
            ],
            [
              68,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "Run()",
          "fn_dec_pos": [
            [
              107,
              15
            ],
            [
              107,
              20
            ]
          ],
          "class_code": "b5e8c4988ed84c8ac5e0f1d7d687548d155d0f09cca2d4b04cc85cd4f8701494",
          "class_node_pos": [
            [
              83,
              0
            ],
            [
              108,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Run",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              113,
              12
            ],
            [
              113,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              178,
              12
            ],
            [
              178,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              207,
              12
            ],
            [
              207,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              249,
              12
            ],
            [
              249,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        },
        {
          "fn_code": "rnd(ACMRandom::DeterministicSeed())",
          "fn_dec_pos": [
            [
              262,
              12
            ],
            [
              262,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rnd",
            "parameters": {},
            "return_type": "ACMRandom"
          }
        }
      ],
      "class_node_list": {
        "b5e8c4988ed84c8ac5e0f1d7d687548d155d0f09cca2d4b04cc85cd4f8701494": {
          "class_code": "class Trans32x32Test : public AbstractBench,\n                       public ::testing::TestWithParam<Trans32x32Param> {\n public:\n  virtual ~Trans32x32Test() {}\n  virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n    version_ = GET_PARAM(2);  // 0: high precision forward transform\n                              // 1: low precision version for rd loop\n    bit_depth_ = GET_PARAM(3);\n    mask_ = (1 << bit_depth_) - 1;\n  }\n\n  virtual void TearDown() { libvpx_test::ClearSystemState(); }\n\n protected:\n  int version_;\n  vpx_bit_depth_t bit_depth_;\n  int mask_;\n  FwdTxfmFunc fwd_txfm_;\n  InvTxfmFunc inv_txfm_;\n\n  int16_t *bench_in_;\n  tran_low_t *bench_out_;\n  virtual void Run();\n}",
          "class_name": "Trans32x32Test",
          "class_pos": [
            [
              83,
              0
            ],
            [
              108,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <math.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./vp9_rtcd.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"test/bench.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_entropy.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_codec.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"vpx_ports/mem.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"vpx_ports/msvc.h\"  // for round()\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp9_ethread_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "VPxFirstPassEncoderThreadTest()\n      : EncoderTest(GET_PARAM(0)), encoder_initialized_(false), tiles_(0),\n        encoding_mode_(GET_PARAM(1)), set_cpu_used_(GET_PARAM(2)) {\n    init_flags_ = VPX_CODEC_USE_PSNR;\n\n    row_mt_mode_ = 1;\n    first_pass_only_ = true;\n    firstpass_stats_.buf = NULL;\n    firstpass_stats_.sz = 0;\n  }",
          "fn_code_pos": [
            [
              36,
              2
            ],
            [
              45,
              3
            ]
          ],
          "class_code": "9ec0307148f62979ad73e5b764555a445f2a3f1b53af98da420bfc9bc658c80e",
          "class_node_pos": [
            [
              32,
              0
            ],
            [
              112,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VPxFirstPassEncoderThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~VPxFirstPassEncoderThreadTest() { free(firstpass_stats_.buf); }",
          "fn_code_pos": [
            [
              46,
              2
            ],
            [
              46,
              74
            ]
          ],
          "class_code": "9ec0307148f62979ad73e5b764555a445f2a3f1b53af98da420bfc9bc658c80e",
          "class_node_pos": [
            [
              32,
              0
            ],
            [
              112,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n\n    cfg_.rc_end_usage = VPX_VBR;\n    cfg_.rc_2pass_vbr_minsection_pct = 5;\n    cfg_.rc_2pass_vbr_maxsection_pct = 2000;\n    cfg_.rc_max_quantizer = 56;\n    cfg_.rc_min_quantizer = 0;\n  }",
          "fn_code_pos": [
            [
              48,
              2
            ],
            [
              57,
              3
            ]
          ],
          "class_code": "9ec0307148f62979ad73e5b764555a445f2a3f1b53af98da420bfc9bc658c80e",
          "class_node_pos": [
            [
              32,
              0
            ],
            [
              112,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void BeginPassHook(unsigned int /*pass*/) {\n    encoder_initialized_ = false;\n    abort_ = false;\n  }",
          "fn_code_pos": [
            [
              59,
              2
            ],
            [
              62,
              3
            ]
          ],
          "class_code": "9ec0307148f62979ad73e5b764555a445f2a3f1b53af98da420bfc9bc658c80e",
          "class_node_pos": [
            [
              32,
              0
            ],
            [
              112,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BeginPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void EndPassHook() {\n    // For first pass stats test, only run first pass encoder.\n    if (first_pass_only_ && cfg_.g_pass == VPX_RC_FIRST_PASS)\n      abort_ |= first_pass_only_;\n  }",
          "fn_code_pos": [
            [
              64,
              2
            ],
            [
              68,
              3
            ]
          ],
          "class_code": "9ec0307148f62979ad73e5b764555a445f2a3f1b53af98da420bfc9bc658c80e",
          "class_node_pos": [
            [
              32,
              0
            ],
            [
              112,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EndPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource * /*video*/,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (!encoder_initialized_) {\n      // Encode in 2-pass mode.\n      encoder->Control(VP9E_SET_TILE_COLUMNS, tiles_);\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n      encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n      encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n      encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n      encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING, 0);\n\n      if (encoding_mode_ == ::libvpx_test::kTwoPassGood)\n        encoder->Control(VP9E_SET_ROW_MT, row_mt_mode_);\n\n      encoder_initialized_ = true;\n    }\n  }",
          "fn_code_pos": [
            [
              70,
              2
            ],
            [
              87,
              3
            ]
          ],
          "class_code": "9ec0307148f62979ad73e5b764555a445f2a3f1b53af98da420bfc9bc658c80e",
          "class_node_pos": [
            [
              32,
              0
            ],
            [
              112,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void StatsPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    const uint8_t *const pkt_buf =\n        reinterpret_cast<uint8_t *>(pkt->data.twopass_stats.buf);\n    const size_t pkt_size = pkt->data.twopass_stats.sz;\n\n    // First pass stats size equals sizeof(FIRSTPASS_STATS)\n    EXPECT_EQ(pkt_size, kFirstPassStatsSz)\n        << \"Error: First pass stats size doesn't equal kFirstPassStatsSz\";\n\n    firstpass_stats_.buf =\n        realloc(firstpass_stats_.buf, firstpass_stats_.sz + pkt_size);\n    memcpy((uint8_t *)firstpass_stats_.buf + firstpass_stats_.sz, pkt_buf,\n           pkt_size);\n    firstpass_stats_.sz += pkt_size;\n  }",
          "fn_code_pos": [
            [
              89,
              2
            ],
            [
              103,
              3
            ]
          ],
          "class_code": "9ec0307148f62979ad73e5b764555a445f2a3f1b53af98da420bfc9bc658c80e",
          "class_node_pos": [
            [
              32,
              0
            ],
            [
              112,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "StatsPktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void compare_fp_stats(vpx_fixed_buf_t *fp_stats, double factor) {\n  // fp_stats consists of 2 set of first pass encoding stats. These 2 set of\n  // stats are compared to check if the stats match or at least are very close.\n  FIRSTPASS_STATS *stats1 = reinterpret_cast<FIRSTPASS_STATS *>(fp_stats->buf);\n  int nframes_ = (int)(fp_stats->sz / sizeof(FIRSTPASS_STATS));\n  FIRSTPASS_STATS *stats2 = stats1 + nframes_ / 2;\n  int i, j;\n\n  // The total stats are also output and included in the first pass stats. Here\n  // ignore that in the comparison.\n  for (i = 0; i < (nframes_ / 2 - 1); ++i) {\n    const double *frame_stats1 = reinterpret_cast<double *>(stats1);\n    const double *frame_stats2 = reinterpret_cast<double *>(stats2);\n\n    for (j = 0; j < kDbl; ++j) {\n      ASSERT_LE(fabs(*frame_stats1 - *frame_stats2),\n                fabs(*frame_stats1) / factor)\n          << \"First failure @ frame #\" << i << \" stat #\" << j << \" (\"\n          << *frame_stats1 << \" vs. \" << *frame_stats2 << \")\";\n      frame_stats1++;\n      frame_stats2++;\n    }\n\n    stats1++;\n    stats2++;\n  }\n\n  // Reset firstpass_stats_ to 0.\n  memset((uint8_t *)fp_stats->buf, 0, fp_stats->sz);\n  fp_stats->sz = 0;\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              144,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compare_fp_stats",
            "parameters": {
              "fp_stats": "vpx_fixed_buf_t",
              "factor": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void compare_fp_stats_md5(vpx_fixed_buf_t *fp_stats) {\n  // fp_stats consists of 2 set of first pass encoding stats. These 2 set of\n  // stats are compared to check if the stats match.\n  uint8_t *stats1 = reinterpret_cast<uint8_t *>(fp_stats->buf);\n  uint8_t *stats2 = stats1 + fp_stats->sz / 2;\n  ::libvpx_test::MD5 md5_row_mt_0, md5_row_mt_1;\n\n  md5_row_mt_0.Add(stats1, fp_stats->sz / 2);\n  const char *md5_row_mt_0_str = md5_row_mt_0.Get();\n\n  md5_row_mt_1.Add(stats2, fp_stats->sz / 2);\n  const char *md5_row_mt_1_str = md5_row_mt_1.Get();\n\n  // Check md5 match.\n  ASSERT_STREQ(md5_row_mt_0_str, md5_row_mt_1_str)\n      << \"MD5 checksums don't match\";\n\n  // Reset firstpass_stats_ to 0.\n  memset((uint8_t *)fp_stats->buf, 0, fp_stats->sz);\n  fp_stats->sz = 0;\n}",
          "fn_code_pos": [
            [
              146,
              0
            ],
            [
              166,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compare_fp_stats_md5",
            "parameters": {
              "fp_stats": "vpx_fixed_buf_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(VPxFirstPassEncoderThreadTest, FirstPassStatsTest) {\n  ::libvpx_test::Y4mVideoSource video(\"niklas_1280_720_30.y4m\", 0, 60);\n\n  first_pass_only_ = true;\n  cfg_.rc_target_bitrate = 1000;\n\n  // Test row_mt_mode: 0 vs 1 at single thread case(threads = 1, tiles_ = 0)\n  tiles_ = 0;\n  cfg_.g_threads = 1;\n\n  row_mt_mode_ = 0;\n  init_flags_ = VPX_CODEC_USE_PSNR;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  row_mt_mode_ = 1;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  // Compare to check if using or not using row-mt generates close stats.\n  ASSERT_NO_FATAL_FAILURE(compare_fp_stats(&firstpass_stats_, 1000.0));\n\n  // Test single thread vs multiple threads\n  row_mt_mode_ = 1;\n  tiles_ = 0;\n\n  cfg_.g_threads = 1;\n  init_flags_ = VPX_CODEC_USE_PSNR;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  cfg_.g_threads = 4;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  // Compare to check if single-thread and multi-thread stats are close enough.\n  ASSERT_NO_FATAL_FAILURE(compare_fp_stats(&firstpass_stats_, 1000.0));\n\n  // Bit exact test in row_mt mode.\n  // When row_mt_mode_=1 and using >1 threads, the encoder generates bit exact\n  // result.\n  row_mt_mode_ = 1;\n  tiles_ = 2;\n\n  cfg_.g_threads = 2;\n  init_flags_ = VPX_CODEC_USE_PSNR;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  cfg_.g_threads = 8;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  // Compare to check if stats match with row-mt=0/1.\n  compare_fp_stats_md5(&firstpass_stats_);\n}",
          "fn_code_pos": [
            [
              168,
              0
            ],
            [
              217,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VPxEncoderThreadTest()\n      : EncoderTest(GET_PARAM(0)), encoder_initialized_(false),\n        tiles_(GET_PARAM(3)), threads_(GET_PARAM(4)),\n        encoding_mode_(GET_PARAM(1)), set_cpu_used_(GET_PARAM(2)) {\n    init_flags_ = VPX_CODEC_USE_PSNR;\n    md5_.clear();\n    row_mt_mode_ = 1;\n    psnr_ = 0.0;\n    nframes_ = 0;\n  }",
          "fn_code_pos": [
            [
              224,
              2
            ],
            [
              233,
              3
            ]
          ],
          "class_code": "6575560f8a4f4f1d906480c1a7bfcd59f1548d121a786ac22a1baf35a9d7d86d",
          "class_node_pos": [
            [
              219,
              0
            ],
            [
              315,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VPxEncoderThreadTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~VPxEncoderThreadTest() {}",
          "fn_code_pos": [
            [
              234,
              2
            ],
            [
              234,
              36
            ]
          ],
          "class_code": "6575560f8a4f4f1d906480c1a7bfcd59f1548d121a786ac22a1baf35a9d7d86d",
          "class_node_pos": [
            [
              219,
              0
            ],
            [
              315,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n\n    if (encoding_mode_ != ::libvpx_test::kRealTime) {\n      cfg_.rc_end_usage = VPX_VBR;\n      cfg_.rc_2pass_vbr_minsection_pct = 5;\n      cfg_.rc_2pass_vbr_maxsection_pct = 2000;\n    } else {\n      cfg_.g_lag_in_frames = 0;\n      cfg_.rc_end_usage = VPX_CBR;\n      cfg_.g_error_resilient = 1;\n    }\n    cfg_.rc_max_quantizer = 56;\n    cfg_.rc_min_quantizer = 0;\n  }",
          "fn_code_pos": [
            [
              236,
              2
            ],
            [
              251,
              3
            ]
          ],
          "class_code": "6575560f8a4f4f1d906480c1a7bfcd59f1548d121a786ac22a1baf35a9d7d86d",
          "class_node_pos": [
            [
              219,
              0
            ],
            [
              315,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void BeginPassHook(unsigned int /*pass*/) {\n    encoder_initialized_ = false;\n    psnr_ = 0.0;\n    nframes_ = 0;\n  }",
          "fn_code_pos": [
            [
              253,
              2
            ],
            [
              257,
              3
            ]
          ],
          "class_code": "6575560f8a4f4f1d906480c1a7bfcd59f1548d121a786ac22a1baf35a9d7d86d",
          "class_node_pos": [
            [
              219,
              0
            ],
            [
              315,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BeginPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource * /*video*/,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (!encoder_initialized_) {\n      // Encode 4 column tiles.\n      encoder->Control(VP9E_SET_TILE_COLUMNS, tiles_);\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n      if (encoding_mode_ != ::libvpx_test::kRealTime) {\n        encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n        encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n        encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n        encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n        encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING, 0);\n      } else {\n        encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 0);\n        encoder->Control(VP9E_SET_AQ_MODE, 3);\n      }\n      encoder->Control(VP9E_SET_ROW_MT, row_mt_mode_);\n\n      encoder_initialized_ = true;\n    }\n  }",
          "fn_code_pos": [
            [
              259,
              2
            ],
            [
              279,
              3
            ]
          ],
          "class_code": "6575560f8a4f4f1d906480c1a7bfcd59f1548d121a786ac22a1baf35a9d7d86d",
          "class_node_pos": [
            [
              219,
              0
            ],
            [
              315,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    psnr_ += pkt->data.psnr.psnr[0];\n    nframes_++;\n  }",
          "fn_code_pos": [
            [
              281,
              2
            ],
            [
              284,
              3
            ]
          ],
          "class_code": "6575560f8a4f4f1d906480c1a7bfcd59f1548d121a786ac22a1baf35a9d7d86d",
          "class_node_pos": [
            [
              219,
              0
            ],
            [
              315,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PSNRPktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void DecompressedFrameHook(const vpx_image_t &img,\n                                     vpx_codec_pts_t /*pts*/) {\n    ::libvpx_test::MD5 md5_res;\n    md5_res.Add(&img);\n    md5_.push_back(md5_res.Get());\n  }",
          "fn_code_pos": [
            [
              286,
              2
            ],
            [
              291,
              3
            ]
          ],
          "class_code": "6575560f8a4f4f1d906480c1a7bfcd59f1548d121a786ac22a1baf35a9d7d86d",
          "class_node_pos": [
            [
              219,
              0
            ],
            [
              315,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecompressedFrameHook",
            "parameters": {
              "img": "vpx_image_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual bool HandleDecodeResult(const vpx_codec_err_t res,\n                                  const libvpx_test::VideoSource & /*video*/,\n                                  libvpx_test::Decoder * /*decoder*/) {\n    if (res != VPX_CODEC_OK) {\n      EXPECT_EQ(VPX_CODEC_OK, res);\n      return false;\n    }\n\n    return true;\n  }",
          "fn_code_pos": [
            [
              293,
              2
            ],
            [
              302,
              3
            ]
          ],
          "class_code": "6575560f8a4f4f1d906480c1a7bfcd59f1548d121a786ac22a1baf35a9d7d86d",
          "class_node_pos": [
            [
              219,
              0
            ],
            [
              315,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "HandleDecodeResult",
            "parameters": {
              "res": "vpx_codec_err_t"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "double GetAveragePsnr() const { return nframes_ ? (psnr_ / nframes_) : 0.0; }",
          "fn_code_pos": [
            [
              304,
              2
            ],
            [
              304,
              79
            ]
          ],
          "class_code": "6575560f8a4f4f1d906480c1a7bfcd59f1548d121a786ac22a1baf35a9d7d86d",
          "class_node_pos": [
            [
              219,
              0
            ],
            [
              315,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetAveragePsnr",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "TEST_P(VPxEncoderThreadTest, EncoderResultTest) {\n  ::libvpx_test::Y4mVideoSource video(\"niklas_1280_720_30.y4m\", 15, 20);\n  cfg_.rc_target_bitrate = 1000;\n\n  // Part 1: Bit exact test for row_mt_mode_ = 0.\n  // This part keeps original unit tests done before row-mt code is checked in.\n  row_mt_mode_ = 0;\n\n  // Encode using single thread.\n  cfg_.g_threads = 1;\n  init_flags_ = VPX_CODEC_USE_PSNR;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  const std::vector<std::string> single_thr_md5 = md5_;\n  md5_.clear();\n\n  // Encode using multiple threads.\n  cfg_.g_threads = threads_;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  const std::vector<std::string> multi_thr_md5 = md5_;\n  md5_.clear();\n\n  // Compare to check if two vectors are equal.\n  ASSERT_EQ(single_thr_md5, multi_thr_md5);\n\n  // Part 2: row_mt_mode_ = 0 vs row_mt_mode_ = 1 single thread bit exact test.\n  row_mt_mode_ = 1;\n\n  // Encode using single thread\n  cfg_.g_threads = 1;\n  init_flags_ = VPX_CODEC_USE_PSNR;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  std::vector<std::string> row_mt_single_thr_md5 = md5_;\n  md5_.clear();\n\n  ASSERT_EQ(single_thr_md5, row_mt_single_thr_md5);\n\n  // Part 3: Bit exact test with row-mt on\n  // When row_mt_mode_=1 and using >1 threads, the encoder generates bit exact\n  // result.\n  row_mt_mode_ = 1;\n  row_mt_single_thr_md5.clear();\n\n  // Encode using 2 threads.\n  cfg_.g_threads = 2;\n  init_flags_ = VPX_CODEC_USE_PSNR;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  row_mt_single_thr_md5 = md5_;\n  md5_.clear();\n\n  // Encode using multiple threads.\n  cfg_.g_threads = threads_;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  const std::vector<std::string> row_mt_multi_thr_md5 = md5_;\n  md5_.clear();\n\n  // Compare to check if two vectors are equal.\n  ASSERT_EQ(row_mt_single_thr_md5, row_mt_multi_thr_md5);\n\n  // Part 4: PSNR test with bit_match_mode_ = 0\n  row_mt_mode_ = 1;\n\n  // Encode using single thread.\n  cfg_.g_threads = 1;\n  init_flags_ = VPX_CODEC_USE_PSNR;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  const double single_thr_psnr = GetAveragePsnr();\n\n  // Encode using multiple threads.\n  cfg_.g_threads = threads_;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  const double multi_thr_psnr = GetAveragePsnr();\n\n  EXPECT_NEAR(single_thr_psnr, multi_thr_psnr, 0.2);\n}",
          "fn_code_pos": [
            [
              317,
              0
            ],
            [
              390,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "9ec0307148f62979ad73e5b764555a445f2a3f1b53af98da420bfc9bc658c80e": {
          "class_code": "class VPxFirstPassEncoderThreadTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWith2Params<libvpx_test::TestMode, int> {\n protected:\n  VPxFirstPassEncoderThreadTest()\n      : EncoderTest(GET_PARAM(0)), encoder_initialized_(false), tiles_(0),\n        encoding_mode_(GET_PARAM(1)), set_cpu_used_(GET_PARAM(2)) {\n    init_flags_ = VPX_CODEC_USE_PSNR;\n\n    row_mt_mode_ = 1;\n    first_pass_only_ = true;\n    firstpass_stats_.buf = NULL;\n    firstpass_stats_.sz = 0;\n  }\n  virtual ~VPxFirstPassEncoderThreadTest() { free(firstpass_stats_.buf); }\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n\n    cfg_.rc_end_usage = VPX_VBR;\n    cfg_.rc_2pass_vbr_minsection_pct = 5;\n    cfg_.rc_2pass_vbr_maxsection_pct = 2000;\n    cfg_.rc_max_quantizer = 56;\n    cfg_.rc_min_quantizer = 0;\n  }\n\n  virtual void BeginPassHook(unsigned int /*pass*/) {\n    encoder_initialized_ = false;\n    abort_ = false;\n  }\n\n  virtual void EndPassHook() {\n    // For first pass stats test, only run first pass encoder.\n    if (first_pass_only_ && cfg_.g_pass == VPX_RC_FIRST_PASS)\n      abort_ |= first_pass_only_;\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource * /*video*/,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (!encoder_initialized_) {\n      // Encode in 2-pass mode.\n      encoder->Control(VP9E_SET_TILE_COLUMNS, tiles_);\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n      encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n      encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n      encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n      encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING, 0);\n\n      if (encoding_mode_ == ::libvpx_test::kTwoPassGood)\n        encoder->Control(VP9E_SET_ROW_MT, row_mt_mode_);\n\n      encoder_initialized_ = true;\n    }\n  }\n\n  virtual void StatsPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    const uint8_t *const pkt_buf =\n        reinterpret_cast<uint8_t *>(pkt->data.twopass_stats.buf);\n    const size_t pkt_size = pkt->data.twopass_stats.sz;\n\n    // First pass stats size equals sizeof(FIRSTPASS_STATS)\n    EXPECT_EQ(pkt_size, kFirstPassStatsSz)\n        << \"Error: First pass stats size doesn't equal kFirstPassStatsSz\";\n\n    firstpass_stats_.buf =\n        realloc(firstpass_stats_.buf, firstpass_stats_.sz + pkt_size);\n    memcpy((uint8_t *)firstpass_stats_.buf + firstpass_stats_.sz, pkt_buf,\n           pkt_size);\n    firstpass_stats_.sz += pkt_size;\n  }\n\n  bool encoder_initialized_;\n  int tiles_;\n  ::libvpx_test::TestMode encoding_mode_;\n  int set_cpu_used_;\n  int row_mt_mode_;\n  bool first_pass_only_;\n  vpx_fixed_buf_t firstpass_stats_;\n}",
          "class_name": "VPxFirstPassEncoderThreadTest",
          "class_pos": [
            [
              32,
              0
            ],
            [
              112,
              1
            ]
          ]
        },
        "6575560f8a4f4f1d906480c1a7bfcd59f1548d121a786ac22a1baf35a9d7d86d": {
          "class_code": "class VPxEncoderThreadTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWith4Params<libvpx_test::TestMode, int,\n                                                 int, int> {\n protected:\n  VPxEncoderThreadTest()\n      : EncoderTest(GET_PARAM(0)), encoder_initialized_(false),\n        tiles_(GET_PARAM(3)), threads_(GET_PARAM(4)),\n        encoding_mode_(GET_PARAM(1)), set_cpu_used_(GET_PARAM(2)) {\n    init_flags_ = VPX_CODEC_USE_PSNR;\n    md5_.clear();\n    row_mt_mode_ = 1;\n    psnr_ = 0.0;\n    nframes_ = 0;\n  }\n  virtual ~VPxEncoderThreadTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n\n    if (encoding_mode_ != ::libvpx_test::kRealTime) {\n      cfg_.rc_end_usage = VPX_VBR;\n      cfg_.rc_2pass_vbr_minsection_pct = 5;\n      cfg_.rc_2pass_vbr_maxsection_pct = 2000;\n    } else {\n      cfg_.g_lag_in_frames = 0;\n      cfg_.rc_end_usage = VPX_CBR;\n      cfg_.g_error_resilient = 1;\n    }\n    cfg_.rc_max_quantizer = 56;\n    cfg_.rc_min_quantizer = 0;\n  }\n\n  virtual void BeginPassHook(unsigned int /*pass*/) {\n    encoder_initialized_ = false;\n    psnr_ = 0.0;\n    nframes_ = 0;\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource * /*video*/,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (!encoder_initialized_) {\n      // Encode 4 column tiles.\n      encoder->Control(VP9E_SET_TILE_COLUMNS, tiles_);\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n      if (encoding_mode_ != ::libvpx_test::kRealTime) {\n        encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n        encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n        encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n        encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n        encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING, 0);\n      } else {\n        encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 0);\n        encoder->Control(VP9E_SET_AQ_MODE, 3);\n      }\n      encoder->Control(VP9E_SET_ROW_MT, row_mt_mode_);\n\n      encoder_initialized_ = true;\n    }\n  }\n\n  virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    psnr_ += pkt->data.psnr.psnr[0];\n    nframes_++;\n  }\n\n  virtual void DecompressedFrameHook(const vpx_image_t &img,\n                                     vpx_codec_pts_t /*pts*/) {\n    ::libvpx_test::MD5 md5_res;\n    md5_res.Add(&img);\n    md5_.push_back(md5_res.Get());\n  }\n\n  virtual bool HandleDecodeResult(const vpx_codec_err_t res,\n                                  const libvpx_test::VideoSource & /*video*/,\n                                  libvpx_test::Decoder * /*decoder*/) {\n    if (res != VPX_CODEC_OK) {\n      EXPECT_EQ(VPX_CODEC_OK, res);\n      return false;\n    }\n\n    return true;\n  }\n\n  double GetAveragePsnr() const { return nframes_ ? (psnr_ / nframes_) : 0.0; }\n\n  bool encoder_initialized_;\n  int tiles_;\n  int threads_;\n  ::libvpx_test::TestMode encoding_mode_;\n  int set_cpu_used_;\n  int row_mt_mode_;\n  double psnr_;\n  unsigned int nframes_;\n  std::vector<std::string> md5_;\n}",
          "class_name": "VPxEncoderThreadTest",
          "class_pos": [
            [
              219,
              0
            ],
            [
              315,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <string>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/md5_helper.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/y4m_video_source.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"vp9/encoder/vp9_firstpass.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp9_decrypt_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "void encrypt_buffer(const uint8_t *src, uint8_t *dst, size_t size,\n                    ptrdiff_t offset) {\n  for (size_t i = 0; i < size; ++i) {\n    dst[i] = src[i] ^ test_key[(offset + i) & 15];\n  }\n}",
          "fn_code_pos": [
            [
              26,
              0
            ],
            [
              31,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "encrypt_buffer",
            "parameters": {
              "src": "uint8_t",
              "dst": "uint8_t",
              "size": "size_t",
              "offset": "ptrdiff_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void test_decrypt_cb(void *decrypt_state, const uint8_t *input, uint8_t *output,\n                     int count) {\n  encrypt_buffer(input, output, count,\n                 input - reinterpret_cast<uint8_t *>(decrypt_state));\n}",
          "fn_code_pos": [
            [
              33,
              0
            ],
            [
              37,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "test_decrypt_cb",
            "parameters": {
              "decrypt_state": "void",
              "input": "uint8_t",
              "output": "uint8_t",
              "count": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST(TestDecrypt, DecryptWorksVp9) {\n  libvpx_test::IVFVideoSource video(\"vp90-2-05-resize.ivf\");\n  video.Init();\n\n  vpx_codec_dec_cfg_t dec_cfg = vpx_codec_dec_cfg_t();\n  VP9Decoder decoder(dec_cfg, 0);\n\n  video.Begin();\n\n  // no decryption\n  vpx_codec_err_t res = decoder.DecodeFrame(video.cxdata(), video.frame_size());\n  ASSERT_EQ(VPX_CODEC_OK, res) << decoder.DecodeError();\n\n  // decrypt frame\n  video.Next();\n\n  std::vector<uint8_t> encrypted(video.frame_size());\n  encrypt_buffer(video.cxdata(), &encrypted[0], video.frame_size(), 0);\n  vpx_decrypt_init di = { test_decrypt_cb, &encrypted[0] };\n  decoder.Control(VPXD_SET_DECRYPTOR, &di);\n\n  res = decoder.DecodeFrame(&encrypted[0], encrypted.size());\n  ASSERT_EQ(VPX_CODEC_OK, res) << decoder.DecodeError();\n}",
          "fn_code_pos": [
            [
              43,
              0
            ],
            [
              66,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <cstdio>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <cstdlib>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/ivf_video_source.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/cpu_speed_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "CpuSpeedTest()\n      : EncoderTest(GET_PARAM(0)), encoding_mode_(GET_PARAM(1)),\n        set_cpu_used_(GET_PARAM(2)), min_psnr_(kMaxPSNR),\n        tune_content_(VP9E_CONTENT_DEFAULT) {}",
          "fn_code_pos": [
            [
              24,
              2
            ],
            [
              27,
              46
            ]
          ],
          "class_code": "d19b019b35824be4a747416f58ead68149ef98e350ef61a84c4d94b4776f992d",
          "class_node_pos": [
            [
              20,
              0
            ],
            [
              66,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CpuSpeedTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~CpuSpeedTest() {}",
          "fn_code_pos": [
            [
              28,
              2
            ],
            [
              28,
              28
            ]
          ],
          "class_code": "d19b019b35824be4a747416f58ead68149ef98e350ef61a84c4d94b4776f992d",
          "class_node_pos": [
            [
              20,
              0
            ],
            [
              66,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n    if (encoding_mode_ != ::libvpx_test::kRealTime) {\n      cfg_.g_lag_in_frames = 25;\n      cfg_.rc_end_usage = VPX_VBR;\n    } else {\n      cfg_.g_lag_in_frames = 0;\n      cfg_.rc_end_usage = VPX_CBR;\n    }\n  }",
          "fn_code_pos": [
            [
              30,
              2
            ],
            [
              40,
              3
            ]
          ],
          "class_code": "d19b019b35824be4a747416f58ead68149ef98e350ef61a84c4d94b4776f992d",
          "class_node_pos": [
            [
              20,
              0
            ],
            [
              66,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void BeginPassHook(unsigned int /*pass*/) { min_psnr_ = kMaxPSNR; }",
          "fn_code_pos": [
            [
              42,
              2
            ],
            [
              42,
              77
            ]
          ],
          "class_code": "d19b019b35824be4a747416f58ead68149ef98e350ef61a84c4d94b4776f992d",
          "class_node_pos": [
            [
              20,
              0
            ],
            [
              66,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BeginPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n      encoder->Control(VP9E_SET_TUNE_CONTENT, tune_content_);\n      if (encoding_mode_ != ::libvpx_test::kRealTime) {\n        encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n        encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n        encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n        encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              44,
              2
            ],
            [
              56,
              3
            ]
          ],
          "class_code": "d19b019b35824be4a747416f58ead68149ef98e350ef61a84c4d94b4776f992d",
          "class_node_pos": [
            [
              20,
              0
            ],
            [
              66,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (pkt->data.psnr.psnr[0] < min_psnr_) min_psnr_ = pkt->data.psnr.psnr[0];\n  }",
          "fn_code_pos": [
            [
              58,
              2
            ],
            [
              60,
              3
            ]
          ],
          "class_code": "d19b019b35824be4a747416f58ead68149ef98e350ef61a84c4d94b4776f992d",
          "class_node_pos": [
            [
              20,
              0
            ],
            [
              66,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PSNRPktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(CpuSpeedTest, TestQ0) {\n  // Validate that this non multiple of 64 wide clip encodes and decodes\n  // without a mismatch when passing in a very low max q.  This pushes\n  // the encoder to producing lots of big partitions which will likely\n  // extend into the border and test the border condition.\n  cfg_.rc_2pass_vbr_minsection_pct = 5;\n  cfg_.rc_2pass_vbr_maxsection_pct = 2000;\n  cfg_.rc_target_bitrate = 400;\n  cfg_.rc_max_quantizer = 0;\n  cfg_.rc_min_quantizer = 0;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_odd.yuv\", 208, 144, 30, 1, 0,\n                                       20);\n\n  init_flags_ = VPX_CODEC_USE_PSNR;\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  EXPECT_GE(min_psnr_, kMaxPSNR);\n}",
          "fn_code_pos": [
            [
              68,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(CpuSpeedTest, TestScreencastQ0) {\n  ::libvpx_test::Y4mVideoSource video(\"screendata.y4m\", 0, 25);\n  cfg_.g_timebase = video.timebase();\n  cfg_.rc_2pass_vbr_minsection_pct = 5;\n  cfg_.rc_2pass_vbr_maxsection_pct = 2000;\n  cfg_.rc_target_bitrate = 400;\n  cfg_.rc_max_quantizer = 0;\n  cfg_.rc_min_quantizer = 0;\n\n  init_flags_ = VPX_CODEC_USE_PSNR;\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  EXPECT_GE(min_psnr_, kMaxPSNR);\n}",
          "fn_code_pos": [
            [
              88,
              0
            ],
            [
              101,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(CpuSpeedTest, TestTuneScreen) {\n  ::libvpx_test::Y4mVideoSource video(\"screendata.y4m\", 0, 25);\n  cfg_.g_timebase = video.timebase();\n  cfg_.rc_2pass_vbr_minsection_pct = 5;\n  cfg_.rc_2pass_vbr_minsection_pct = 2000;\n  cfg_.rc_target_bitrate = 2000;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.rc_min_quantizer = 0;\n  tune_content_ = VP9E_CONTENT_SCREEN;\n\n  init_flags_ = VPX_CODEC_USE_PSNR;\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              103,
              0
            ],
            [
              116,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(CpuSpeedTest, TestEncodeHighBitrate) {\n  // Validate that this non multiple of 64 wide clip encodes and decodes\n  // without a mismatch when passing in a very low max q.  This pushes\n  // the encoder to producing lots of big partitions which will likely\n  // extend into the border and test the border condition.\n  cfg_.rc_2pass_vbr_minsection_pct = 5;\n  cfg_.rc_2pass_vbr_maxsection_pct = 2000;\n  cfg_.rc_target_bitrate = 12000;\n  cfg_.rc_max_quantizer = 10;\n  cfg_.rc_min_quantizer = 0;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_odd.yuv\", 208, 144, 30, 1, 0,\n                                       20);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              118,
              0
            ],
            [
              133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(CpuSpeedTest, TestLowBitrate) {\n  // Validate that this clip encodes and decodes without a mismatch\n  // when passing in a very high min q.  This pushes the encoder to producing\n  // lots of small partitions which might will test the other condition.\n  cfg_.rc_2pass_vbr_minsection_pct = 5;\n  cfg_.rc_2pass_vbr_maxsection_pct = 2000;\n  cfg_.rc_target_bitrate = 200;\n  cfg_.rc_min_quantizer = 40;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_odd.yuv\", 208, 144, 30, 1, 0,\n                                       20);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              135,
              0
            ],
            [
              148,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "d19b019b35824be4a747416f58ead68149ef98e350ef61a84c4d94b4776f992d": {
          "class_code": "class CpuSpeedTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWith2Params<libvpx_test::TestMode, int> {\n protected:\n  CpuSpeedTest()\n      : EncoderTest(GET_PARAM(0)), encoding_mode_(GET_PARAM(1)),\n        set_cpu_used_(GET_PARAM(2)), min_psnr_(kMaxPSNR),\n        tune_content_(VP9E_CONTENT_DEFAULT) {}\n  virtual ~CpuSpeedTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n    if (encoding_mode_ != ::libvpx_test::kRealTime) {\n      cfg_.g_lag_in_frames = 25;\n      cfg_.rc_end_usage = VPX_VBR;\n    } else {\n      cfg_.g_lag_in_frames = 0;\n      cfg_.rc_end_usage = VPX_CBR;\n    }\n  }\n\n  virtual void BeginPassHook(unsigned int /*pass*/) { min_psnr_ = kMaxPSNR; }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n      encoder->Control(VP9E_SET_TUNE_CONTENT, tune_content_);\n      if (encoding_mode_ != ::libvpx_test::kRealTime) {\n        encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n        encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n        encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n        encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n      }\n    }\n  }\n\n  virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (pkt->data.psnr.psnr[0] < min_psnr_) min_psnr_ = pkt->data.psnr.psnr[0];\n  }\n\n  ::libvpx_test::TestMode encoding_mode_;\n  int set_cpu_used_;\n  double min_psnr_;\n  int tune_content_;\n}",
          "class_name": "CpuSpeedTest",
          "class_pos": [
            [
              20,
              0
            ],
            [
              66,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/y4m_video_source.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/frame_size_tests.cc": {
      "fn_def_list": [
        {
          "fn_code": "VP9FrameSizeTestsLarge()\n      : EncoderTest(&::libvpx_test::kVP9), expected_res_(VPX_CODEC_OK) {}",
          "fn_code_pos": [
            [
              18,
              2
            ],
            [
              19,
              73
            ]
          ],
          "class_code": "0d8fa901e9065ac182e2fa6f68ac1b5d2dbb2a44f06f9bd1b0121a03805ab042",
          "class_node_pos": [
            [
              15,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VP9FrameSizeTestsLarge",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~VP9FrameSizeTestsLarge() {}",
          "fn_code_pos": [
            [
              20,
              2
            ],
            [
              20,
              38
            ]
          ],
          "class_code": "0d8fa901e9065ac182e2fa6f68ac1b5d2dbb2a44f06f9bd1b0121a03805ab042",
          "class_node_pos": [
            [
              15,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n  }",
          "fn_code_pos": [
            [
              22,
              2
            ],
            [
              25,
              3
            ]
          ],
          "class_code": "0d8fa901e9065ac182e2fa6f68ac1b5d2dbb2a44f06f9bd1b0121a03805ab042",
          "class_node_pos": [
            [
              15,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual bool HandleDecodeResult(const vpx_codec_err_t res_dec,\n                                  const libvpx_test::VideoSource & /*video*/,\n                                  libvpx_test::Decoder *decoder) {\n    EXPECT_EQ(expected_res_, res_dec) << decoder->DecodeError();\n    return !::testing::Test::HasFailure();\n  }",
          "fn_code_pos": [
            [
              27,
              2
            ],
            [
              32,
              3
            ]
          ],
          "class_code": "0d8fa901e9065ac182e2fa6f68ac1b5d2dbb2a44f06f9bd1b0121a03805ab042",
          "class_node_pos": [
            [
              15,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "HandleDecodeResult",
            "parameters": {
              "res_dec": "vpx_codec_err_t",
              "decoder": "libvpx_test::Decoder"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, 7);\n      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n      encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n      encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n      encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n    }\n  }",
          "fn_code_pos": [
            [
              34,
              2
            ],
            [
              43,
              3
            ]
          ],
          "class_code": "0d8fa901e9065ac182e2fa6f68ac1b5d2dbb2a44f06f9bd1b0121a03805ab042",
          "class_node_pos": [
            [
              15,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_F(VP9FrameSizeTestsLarge, TestInvalidSizes) {\n  ::libvpx_test::RandomVideoSource video;\n\n#if CONFIG_SIZE_LIMIT\n  video.SetSize(DECODE_WIDTH_LIMIT + 16, DECODE_HEIGHT_LIMIT + 16);\n  video.set_limit(2);\n  expected_res_ = VPX_CODEC_CORRUPT_FRAME;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n#endif\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              57,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(VP9FrameSizeTestsLarge, ValidSizes) {\n  ::libvpx_test::RandomVideoSource video;\n\n#if CONFIG_SIZE_LIMIT\n  video.SetSize(DECODE_WIDTH_LIMIT, DECODE_HEIGHT_LIMIT);\n  video.set_limit(2);\n  expected_res_ = VPX_CODEC_OK;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n#else\n// This test produces a pretty large single frame allocation,  (roughly\n// 25 megabits). The encoder allocates a good number of these frames\n// one for each lag in frames (for 2 pass), and then one for each possible\n// reference buffer (8) - we can end up with up to 30 buffers of roughly this\n// size or almost 1 gig of memory.\n// In total the allocations will exceed 2GiB which may cause a failure with\n// mingw + wine, use a smaller size in that case.\n#if defined(_WIN32) && !defined(_WIN64) || defined(__OS2__)\n  video.SetSize(4096, 3072);\n#else\n  video.SetSize(4096, 4096);\n#endif\n  video.set_limit(2);\n  expected_res_ = VPX_CODEC_OK;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n#endif\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(VP9FrameSizeTestsLarge, OneByOneVideo) {\n  ::libvpx_test::RandomVideoSource video;\n\n  video.SetSize(1, 1);\n  video.set_limit(2);\n  expected_res_ = VPX_CODEC_OK;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              93,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "0d8fa901e9065ac182e2fa6f68ac1b5d2dbb2a44f06f9bd1b0121a03805ab042": {
          "class_code": "class VP9FrameSizeTestsLarge : public ::libvpx_test::EncoderTest,\n                               public ::testing::Test {\n protected:\n  VP9FrameSizeTestsLarge()\n      : EncoderTest(&::libvpx_test::kVP9), expected_res_(VPX_CODEC_OK) {}\n  virtual ~VP9FrameSizeTestsLarge() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n  }\n\n  virtual bool HandleDecodeResult(const vpx_codec_err_t res_dec,\n                                  const libvpx_test::VideoSource & /*video*/,\n                                  libvpx_test::Decoder *decoder) {\n    EXPECT_EQ(expected_res_, res_dec) << decoder->DecodeError();\n    return !::testing::Test::HasFailure();\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, 7);\n      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n      encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n      encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n      encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n    }\n  }\n\n  int expected_res_;\n}",
          "class_name": "VP9FrameSizeTestsLarge",
          "class_pos": [
            [
              15,
              0
            ],
            [
              46,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"test/video_source.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/sad_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "TestParams(int w, int h, Function f, int bd = -1)\n      : width(w), height(h), bit_depth(bd), func(f) {}",
          "fn_code_pos": [
            [
              30,
              2
            ],
            [
              31,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestParams",
            "parameters": {
              "w": "int",
              "h": "int",
              "f": "Function"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "explicit SADTestBase(const ParamType &params) : params_(params) {}",
          "fn_code_pos": [
            [
              56,
              2
            ],
            [
              56,
              68
            ]
          ],
          "class_code": "dcea0f620f5a368fc1ba3523cc8d8a60f3de5d613a74f2bc8099a46fec367bff",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              241,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SADTestBase",
            "parameters": {
              "params": "ParamType"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    source_data8_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kDataBlockSize));\n    reference_data8_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kDataBufferSize));\n    second_pred8_ =\n        reinterpret_cast<uint8_t *>(vpx_memalign(kDataAlignment, 64 * 64));\n    source_data16_ = reinterpret_cast<uint16_t *>(\n        vpx_memalign(kDataAlignment, kDataBlockSize * sizeof(uint16_t)));\n    reference_data16_ = reinterpret_cast<uint16_t *>(\n        vpx_memalign(kDataAlignment, kDataBufferSize * sizeof(uint16_t)));\n    second_pred16_ = reinterpret_cast<uint16_t *>(\n        vpx_memalign(kDataAlignment, 64 * 64 * sizeof(uint16_t)));\n\n    if (params_.bit_depth == -1) {\n      use_high_bit_depth_ = false;\n      bit_depth_ = VPX_BITS_8;\n      source_data_ = source_data8_;\n      reference_data_ = reference_data8_;\n      second_pred_ = second_pred8_;\n#if CONFIG_VP9_HIGHBITDEPTH\n    } else {\n      use_high_bit_depth_ = true;\n      bit_depth_ = static_cast<vpx_bit_depth_t>(params_.bit_depth);\n      source_data_ = CONVERT_TO_BYTEPTR(source_data16_);\n      reference_data_ = CONVERT_TO_BYTEPTR(reference_data16_);\n      second_pred_ = CONVERT_TO_BYTEPTR(second_pred16_);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    }\n    mask_ = (1 << bit_depth_) - 1;\n    source_stride_ = (params_.width + 63) & ~63;\n    reference_stride_ = params_.width * 2;\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n  }",
          "fn_code_pos": [
            [
              58,
              2
            ],
            [
              91,
              3
            ]
          ],
          "class_code": "dcea0f620f5a368fc1ba3523cc8d8a60f3de5d613a74f2bc8099a46fec367bff",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              241,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() {\n    vpx_free(source_data8_);\n    source_data8_ = NULL;\n    vpx_free(reference_data8_);\n    reference_data8_ = NULL;\n    vpx_free(second_pred8_);\n    second_pred8_ = NULL;\n    vpx_free(source_data16_);\n    source_data16_ = NULL;\n    vpx_free(reference_data16_);\n    reference_data16_ = NULL;\n    vpx_free(second_pred16_);\n    second_pred16_ = NULL;\n\n    libvpx_test::ClearSystemState();\n  }",
          "fn_code_pos": [
            [
              93,
              2
            ],
            [
              108,
              3
            ]
          ],
          "class_code": "dcea0f620f5a368fc1ba3523cc8d8a60f3de5d613a74f2bc8099a46fec367bff",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              241,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "uint8_t *GetReference(int block_idx) const {\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (use_high_bit_depth_) {\n      return CONVERT_TO_BYTEPTR(CONVERT_TO_SHORTPTR(reference_data_) +\n                                block_idx * kDataBlockSize);\n    }\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    return reference_data_ + block_idx * kDataBlockSize;\n  }",
          "fn_code_pos": [
            [
              116,
              2
            ],
            [
              124,
              3
            ]
          ],
          "class_code": "dcea0f620f5a368fc1ba3523cc8d8a60f3de5d613a74f2bc8099a46fec367bff",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              241,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetReference",
            "parameters": {
              "block_idx": "int"
            },
            "return_type": "uint8_t"
          }
        },
        {
          "fn_code": "uint32_t ReferenceSAD(int block_idx) const {\n    uint32_t sad = 0;\n    const uint8_t *const reference8 = GetReference(block_idx);\n    const uint8_t *const source8 = source_data_;\n#if CONFIG_VP9_HIGHBITDEPTH\n    const uint16_t *const reference16 =\n        CONVERT_TO_SHORTPTR(GetReference(block_idx));\n    const uint16_t *const source16 = CONVERT_TO_SHORTPTR(source_data_);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    for (int h = 0; h < params_.height; ++h) {\n      for (int w = 0; w < params_.width; ++w) {\n        if (!use_high_bit_depth_) {\n          sad += abs(source8[h * source_stride_ + w] -\n                     reference8[h * reference_stride_ + w]);\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          sad += abs(source16[h * source_stride_ + w] -\n                     reference16[h * reference_stride_ + w]);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n        }\n      }\n    }\n    return sad;\n  }",
          "fn_code_pos": [
            [
              128,
              2
            ],
            [
              151,
              3
            ]
          ],
          "class_code": "dcea0f620f5a368fc1ba3523cc8d8a60f3de5d613a74f2bc8099a46fec367bff",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              241,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ReferenceSAD",
            "parameters": {
              "block_idx": "int"
            },
            "return_type": "uint32_t"
          }
        },
        {
          "fn_code": "unsigned int ReferenceSADavg(int block_idx) const {\n    unsigned int sad = 0;\n    const uint8_t *const reference8 = GetReference(block_idx);\n    const uint8_t *const source8 = source_data_;\n    const uint8_t *const second_pred8 = second_pred_;\n#if CONFIG_VP9_HIGHBITDEPTH\n    const uint16_t *const reference16 =\n        CONVERT_TO_SHORTPTR(GetReference(block_idx));\n    const uint16_t *const source16 = CONVERT_TO_SHORTPTR(source_data_);\n    const uint16_t *const second_pred16 = CONVERT_TO_SHORTPTR(second_pred_);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    for (int h = 0; h < params_.height; ++h) {\n      for (int w = 0; w < params_.width; ++w) {\n        if (!use_high_bit_depth_) {\n          const int tmp = second_pred8[h * params_.width + w] +\n                          reference8[h * reference_stride_ + w];\n          const uint8_t comp_pred = ROUND_POWER_OF_TWO(tmp, 1);\n          sad += abs(source8[h * source_stride_ + w] - comp_pred);\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          const int tmp = second_pred16[h * params_.width + w] +\n                          reference16[h * reference_stride_ + w];\n          const uint16_t comp_pred = ROUND_POWER_OF_TWO(tmp, 1);\n          sad += abs(source16[h * source_stride_ + w] - comp_pred);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n        }\n      }\n    }\n    return sad;\n  }",
          "fn_code_pos": [
            [
              156,
              2
            ],
            [
              185,
              3
            ]
          ],
          "class_code": "dcea0f620f5a368fc1ba3523cc8d8a60f3de5d613a74f2bc8099a46fec367bff",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              241,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ReferenceSADavg",
            "parameters": {
              "block_idx": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void FillConstant(uint8_t *data, int stride, uint16_t fill_constant) const {\n    uint8_t *data8 = data;\n#if CONFIG_VP9_HIGHBITDEPTH\n    uint16_t *data16 = CONVERT_TO_SHORTPTR(data);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    for (int h = 0; h < params_.height; ++h) {\n      for (int w = 0; w < params_.width; ++w) {\n        if (!use_high_bit_depth_) {\n          data8[h * stride + w] = static_cast<uint8_t>(fill_constant);\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          data16[h * stride + w] = fill_constant;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n        }\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              187,
              2
            ],
            [
              203,
              3
            ]
          ],
          "class_code": "dcea0f620f5a368fc1ba3523cc8d8a60f3de5d613a74f2bc8099a46fec367bff",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              241,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillConstant",
            "parameters": {
              "data": "uint8_t",
              "stride": "int",
              "fill_constant": "uint16_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void FillRandom(uint8_t *data, int stride) {\n    uint8_t *data8 = data;\n#if CONFIG_VP9_HIGHBITDEPTH\n    uint16_t *data16 = CONVERT_TO_SHORTPTR(data);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    for (int h = 0; h < params_.height; ++h) {\n      for (int w = 0; w < params_.width; ++w) {\n        if (!use_high_bit_depth_) {\n          data8[h * stride + w] = rnd_.Rand8();\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          data16[h * stride + w] = rnd_.Rand16() & mask_;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n        }\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              205,
              2
            ],
            [
              221,
              3
            ]
          ],
          "class_code": "dcea0f620f5a368fc1ba3523cc8d8a60f3de5d613a74f2bc8099a46fec367bff",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              241,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillRandom",
            "parameters": {
              "data": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "SADx4Test() : SADTestBase(GetParam()) {}",
          "fn_code_pos": [
            [
              245,
              2
            ],
            [
              245,
              42
            ]
          ],
          "class_code": "e05910ff2dd51ae4176109e5d38c1ea7cfcb236624ef5d83a1067f3a969bcbe6",
          "class_node_pos": [
            [
              243,
              0
            ],
            [
              266,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SADx4Test",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void SADs(unsigned int *results) const {\n    const uint8_t *references[] = { GetReference(0), GetReference(1),\n                                    GetReference(2), GetReference(3) };\n\n    ASM_REGISTER_STATE_CHECK(params_.func(\n        source_data_, source_stride_, references, reference_stride_, results));\n  }",
          "fn_code_pos": [
            [
              248,
              2
            ],
            [
              254,
              3
            ]
          ],
          "class_code": "e05910ff2dd51ae4176109e5d38c1ea7cfcb236624ef5d83a1067f3a969bcbe6",
          "class_node_pos": [
            [
              243,
              0
            ],
            [
              266,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SADs",
            "parameters": {
              "results": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CheckSADs() const {\n    uint32_t reference_sad, exp_sad[4];\n\n    SADs(exp_sad);\n    for (int block = 0; block < 4; ++block) {\n      reference_sad = ReferenceSAD(block);\n\n      EXPECT_EQ(reference_sad, exp_sad[block]) << \"block \" << block;\n    }\n  }",
          "fn_code_pos": [
            [
              256,
              2
            ],
            [
              265,
              3
            ]
          ],
          "class_code": "e05910ff2dd51ae4176109e5d38c1ea7cfcb236624ef5d83a1067f3a969bcbe6",
          "class_node_pos": [
            [
              243,
              0
            ],
            [
              266,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckSADs",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "SADTest() : SADTestBase(GetParam()) {}",
          "fn_code_pos": [
            [
              270,
              2
            ],
            [
              270,
              40
            ]
          ],
          "class_code": "2b13afe642a43c7501ca0c179925e27e54b023e3e184c2ff8979710aaecc33bd",
          "class_node_pos": [
            [
              268,
              0
            ],
            [
              293,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SADTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned int SAD(int block_idx) const {\n    unsigned int ret;\n    const uint8_t *const reference = GetReference(block_idx);\n\n    ASM_REGISTER_STATE_CHECK(ret = params_.func(source_data_, source_stride_,\n                                                reference, reference_stride_));\n    return ret;\n  }",
          "fn_code_pos": [
            [
              273,
              2
            ],
            [
              280,
              3
            ]
          ],
          "class_code": "2b13afe642a43c7501ca0c179925e27e54b023e3e184c2ff8979710aaecc33bd",
          "class_node_pos": [
            [
              268,
              0
            ],
            [
              293,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SAD",
            "parameters": {
              "block_idx": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void CheckSAD() const {\n    const unsigned int reference_sad = ReferenceSAD(0);\n    const unsigned int exp_sad = SAD(0);\n\n    ASSERT_EQ(reference_sad, exp_sad);\n  }",
          "fn_code_pos": [
            [
              282,
              2
            ],
            [
              287,
              3
            ]
          ],
          "class_code": "2b13afe642a43c7501ca0c179925e27e54b023e3e184c2ff8979710aaecc33bd",
          "class_node_pos": [
            [
              268,
              0
            ],
            [
              293,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckSAD",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Run() {\n    params_.func(source_data_, source_stride_, reference_data_,\n                 reference_stride_);\n  }",
          "fn_code_pos": [
            [
              289,
              2
            ],
            [
              292,
              3
            ]
          ],
          "class_code": "2b13afe642a43c7501ca0c179925e27e54b023e3e184c2ff8979710aaecc33bd",
          "class_node_pos": [
            [
              268,
              0
            ],
            [
              293,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Run",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "SADavgTest() : SADTestBase(GetParam()) {}",
          "fn_code_pos": [
            [
              297,
              2
            ],
            [
              297,
              43
            ]
          ],
          "class_code": "29772dbdde0ddb5c06adffeaf36830e7df2b773ae5dfc2639b1e519ae927a46f",
          "class_node_pos": [
            [
              295,
              0
            ],
            [
              316,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SADavgTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned int SAD_avg(int block_idx) const {\n    unsigned int ret;\n    const uint8_t *const reference = GetReference(block_idx);\n\n    ASM_REGISTER_STATE_CHECK(ret = params_.func(source_data_, source_stride_,\n                                                reference, reference_stride_,\n                                                second_pred_));\n    return ret;\n  }",
          "fn_code_pos": [
            [
              300,
              2
            ],
            [
              308,
              3
            ]
          ],
          "class_code": "29772dbdde0ddb5c06adffeaf36830e7df2b773ae5dfc2639b1e519ae927a46f",
          "class_node_pos": [
            [
              295,
              0
            ],
            [
              316,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SAD_avg",
            "parameters": {
              "block_idx": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void CheckSAD() const {\n    const unsigned int reference_sad = ReferenceSADavg(0);\n    const unsigned int exp_sad = SAD_avg(0);\n\n    ASSERT_EQ(reference_sad, exp_sad);\n  }",
          "fn_code_pos": [
            [
              310,
              2
            ],
            [
              315,
              3
            ]
          ],
          "class_code": "29772dbdde0ddb5c06adffeaf36830e7df2b773ae5dfc2639b1e519ae927a46f",
          "class_node_pos": [
            [
              295,
              0
            ],
            [
              316,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckSAD",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(SADTest, MaxRef) {\n  FillConstant(source_data_, source_stride_, 0);\n  FillConstant(reference_data_, reference_stride_, mask_);\n  CheckSAD();\n}",
          "fn_code_pos": [
            [
              318,
              0
            ],
            [
              322,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SADTest, MaxSrc) {\n  FillConstant(source_data_, source_stride_, mask_);\n  FillConstant(reference_data_, reference_stride_, 0);\n  CheckSAD();\n}",
          "fn_code_pos": [
            [
              324,
              0
            ],
            [
              328,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SADTest, ShortRef) {\n  const int tmp_stride = reference_stride_;\n  reference_stride_ >>= 1;\n  FillRandom(source_data_, source_stride_);\n  FillRandom(reference_data_, reference_stride_);\n  CheckSAD();\n  reference_stride_ = tmp_stride;\n}",
          "fn_code_pos": [
            [
              330,
              0
            ],
            [
              337,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SADTest, UnalignedRef) {\n  // The reference frame, but not the source frame, may be unaligned for\n  // certain types of searches.\n  const int tmp_stride = reference_stride_;\n  reference_stride_ -= 1;\n  FillRandom(source_data_, source_stride_);\n  FillRandom(reference_data_, reference_stride_);\n  CheckSAD();\n  reference_stride_ = tmp_stride;\n}",
          "fn_code_pos": [
            [
              339,
              0
            ],
            [
              348,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SADTest, ShortSrc) {\n  const int tmp_stride = source_stride_;\n  source_stride_ >>= 1;\n  FillRandom(source_data_, source_stride_);\n  FillRandom(reference_data_, reference_stride_);\n  CheckSAD();\n  source_stride_ = tmp_stride;\n}",
          "fn_code_pos": [
            [
              350,
              0
            ],
            [
              357,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SADTest, DISABLED_Speed) {\n  const int kCountSpeedTestBlock = 50000000 / (params_.width * params_.height);\n  FillRandom(source_data_, source_stride_);\n\n  RunNTimes(kCountSpeedTestBlock);\n\n  char title[16];\n  snprintf(title, sizeof(title), \"%dx%d\", params_.width, params_.height);\n  PrintMedian(title);\n}",
          "fn_code_pos": [
            [
              359,
              0
            ],
            [
              368,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SADavgTest, MaxRef) {\n  FillConstant(source_data_, source_stride_, 0);\n  FillConstant(reference_data_, reference_stride_, mask_);\n  FillConstant(second_pred_, params_.width, 0);\n  CheckSAD();\n}",
          "fn_code_pos": [
            [
              370,
              0
            ],
            [
              375,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SADavgTest, MaxSrc) {\n  FillConstant(source_data_, source_stride_, mask_);\n  FillConstant(reference_data_, reference_stride_, 0);\n  FillConstant(second_pred_, params_.width, 0);\n  CheckSAD();\n}",
          "fn_code_pos": [
            [
              376,
              0
            ],
            [
              381,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SADavgTest, ShortRef) {\n  const int tmp_stride = reference_stride_;\n  reference_stride_ >>= 1;\n  FillRandom(source_data_, source_stride_);\n  FillRandom(reference_data_, reference_stride_);\n  FillRandom(second_pred_, params_.width);\n  CheckSAD();\n  reference_stride_ = tmp_stride;\n}",
          "fn_code_pos": [
            [
              383,
              0
            ],
            [
              391,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SADavgTest, UnalignedRef) {\n  // The reference frame, but not the source frame, may be unaligned for\n  // certain types of searches.\n  const int tmp_stride = reference_stride_;\n  reference_stride_ -= 1;\n  FillRandom(source_data_, source_stride_);\n  FillRandom(reference_data_, reference_stride_);\n  FillRandom(second_pred_, params_.width);\n  CheckSAD();\n  reference_stride_ = tmp_stride;\n}",
          "fn_code_pos": [
            [
              393,
              0
            ],
            [
              403,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SADavgTest, ShortSrc) {\n  const int tmp_stride = source_stride_;\n  source_stride_ >>= 1;\n  FillRandom(source_data_, source_stride_);\n  FillRandom(reference_data_, reference_stride_);\n  FillRandom(second_pred_, params_.width);\n  CheckSAD();\n  source_stride_ = tmp_stride;\n}",
          "fn_code_pos": [
            [
              405,
              0
            ],
            [
              413,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SADx4Test, MaxRef) {\n  FillConstant(source_data_, source_stride_, 0);\n  FillConstant(GetReference(0), reference_stride_, mask_);\n  FillConstant(GetReference(1), reference_stride_, mask_);\n  FillConstant(GetReference(2), reference_stride_, mask_);\n  FillConstant(GetReference(3), reference_stride_, mask_);\n  CheckSADs();\n}",
          "fn_code_pos": [
            [
              415,
              0
            ],
            [
              422,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SADx4Test, MaxSrc) {\n  FillConstant(source_data_, source_stride_, mask_);\n  FillConstant(GetReference(0), reference_stride_, 0);\n  FillConstant(GetReference(1), reference_stride_, 0);\n  FillConstant(GetReference(2), reference_stride_, 0);\n  FillConstant(GetReference(3), reference_stride_, 0);\n  CheckSADs();\n}",
          "fn_code_pos": [
            [
              424,
              0
            ],
            [
              431,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SADx4Test, ShortRef) {\n  int tmp_stride = reference_stride_;\n  reference_stride_ >>= 1;\n  FillRandom(source_data_, source_stride_);\n  FillRandom(GetReference(0), reference_stride_);\n  FillRandom(GetReference(1), reference_stride_);\n  FillRandom(GetReference(2), reference_stride_);\n  FillRandom(GetReference(3), reference_stride_);\n  CheckSADs();\n  reference_stride_ = tmp_stride;\n}",
          "fn_code_pos": [
            [
              433,
              0
            ],
            [
              443,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SADx4Test, UnalignedRef) {\n  // The reference frame, but not the source frame, may be unaligned for\n  // certain types of searches.\n  int tmp_stride = reference_stride_;\n  reference_stride_ -= 1;\n  FillRandom(source_data_, source_stride_);\n  FillRandom(GetReference(0), reference_stride_);\n  FillRandom(GetReference(1), reference_stride_);\n  FillRandom(GetReference(2), reference_stride_);\n  FillRandom(GetReference(3), reference_stride_);\n  CheckSADs();\n  reference_stride_ = tmp_stride;\n}",
          "fn_code_pos": [
            [
              445,
              0
            ],
            [
              457,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SADx4Test, ShortSrc) {\n  int tmp_stride = source_stride_;\n  source_stride_ >>= 1;\n  FillRandom(source_data_, source_stride_);\n  FillRandom(GetReference(0), reference_stride_);\n  FillRandom(GetReference(1), reference_stride_);\n  FillRandom(GetReference(2), reference_stride_);\n  FillRandom(GetReference(3), reference_stride_);\n  CheckSADs();\n  source_stride_ = tmp_stride;\n}",
          "fn_code_pos": [
            [
              459,
              0
            ],
            [
              469,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SADx4Test, SrcAlignedByWidth) {\n  uint8_t *tmp_source_data = source_data_;\n  source_data_ += params_.width;\n  FillRandom(source_data_, source_stride_);\n  FillRandom(GetReference(0), reference_stride_);\n  FillRandom(GetReference(1), reference_stride_);\n  FillRandom(GetReference(2), reference_stride_);\n  FillRandom(GetReference(3), reference_stride_);\n  CheckSADs();\n  source_data_ = tmp_source_data;\n}",
          "fn_code_pos": [
            [
              471,
              0
            ],
            [
              481,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(SADx4Test, DISABLED_Speed) {\n  int tmp_stride = reference_stride_;\n  reference_stride_ -= 1;\n  FillRandom(source_data_, source_stride_);\n  FillRandom(GetReference(0), reference_stride_);\n  FillRandom(GetReference(1), reference_stride_);\n  FillRandom(GetReference(2), reference_stride_);\n  FillRandom(GetReference(3), reference_stride_);\n  const int kCountSpeedTestBlock = 500000000 / (params_.width * params_.height);\n  uint32_t reference_sad[4], exp_sad[4];\n  vpx_usec_timer timer;\n\n  memset(reference_sad, 0, sizeof(reference_sad));\n  SADs(exp_sad);\n  vpx_usec_timer_start(&timer);\n  for (int i = 0; i < kCountSpeedTestBlock; ++i) {\n    for (int block = 0; block < 4; ++block) {\n      reference_sad[block] = ReferenceSAD(block);\n    }\n  }\n  vpx_usec_timer_mark(&timer);\n  for (int block = 0; block < 4; ++block) {\n    EXPECT_EQ(reference_sad[block], exp_sad[block]) << \"block \" << block;\n  }\n  const int elapsed_time =\n      static_cast<int>(vpx_usec_timer_elapsed(&timer) / 1000);\n  printf(\"sad%dx%dx4 (%2dbit) time: %5d ms\\n\", params_.width, params_.height,\n         bit_depth_, elapsed_time);\n\n  reference_stride_ = tmp_stride;\n}",
          "fn_code_pos": [
            [
              483,
              0
            ],
            [
              513,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*SadMxNFunc)(const uint8_t *src_ptr, int src_stride,\n                                   const uint8_t *ref_ptr, int ref_stride)",
          "fn_dec_pos": [
            [
              36,
              21
            ],
            [
              37,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "src_ptr": "uint8_t",
              "src_stride": "int",
              "ref_ptr": "uint8_t",
              "ref_stride": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*SadMxNAvgFunc)(const uint8_t *src_ptr, int src_stride,\n                                      const uint8_t *ref_ptr, int ref_stride,\n                                      const uint8_t *second_pred)",
          "fn_dec_pos": [
            [
              40,
              21
            ],
            [
              42,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "src_ptr": "uint8_t",
              "src_stride": "int",
              "ref_ptr": "uint8_t",
              "ref_stride": "int",
              "second_pred": "uint8_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*SadMxNx4Func)(const uint8_t *src_ptr, int src_stride,\n                             const uint8_t *const ref_ptr[], int ref_stride,\n                             unsigned int *sad_array)",
          "fn_dec_pos": [
            [
              45,
              13
            ],
            [
              47,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "src_ptr": "uint8_t",
              "src_stride": "int",
              "ref_ptr": "uint8_t",
              "ref_stride": "int",
              "sad_array": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "GetReference(int block_idx) const",
          "fn_dec_pos": [
            [
              116,
              11
            ],
            [
              116,
              44
            ]
          ],
          "class_code": "dcea0f620f5a368fc1ba3523cc8d8a60f3de5d613a74f2bc8099a46fec367bff",
          "class_node_pos": [
            [
              54,
              0
            ],
            [
              241,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetReference",
            "parameters": {
              "block_idx": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "17f63fd7fbbe610f8f71524364b9a0ba8f413d8fab627b52f4175251edd29bab": {
          "class_code": "template <typename ParamType>\nclass SADTestBase : public ::testing::TestWithParam<ParamType> {\n public:\n  explicit SADTestBase(const ParamType &params) : params_(params) {}\n\n  virtual void SetUp() {\n    source_data8_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kDataBlockSize));\n    reference_data8_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(kDataAlignment, kDataBufferSize));\n    second_pred8_ =\n        reinterpret_cast<uint8_t *>(vpx_memalign(kDataAlignment, 64 * 64));\n    source_data16_ = reinterpret_cast<uint16_t *>(\n        vpx_memalign(kDataAlignment, kDataBlockSize * sizeof(uint16_t)));\n    reference_data16_ = reinterpret_cast<uint16_t *>(\n        vpx_memalign(kDataAlignment, kDataBufferSize * sizeof(uint16_t)));\n    second_pred16_ = reinterpret_cast<uint16_t *>(\n        vpx_memalign(kDataAlignment, 64 * 64 * sizeof(uint16_t)));\n\n    if (params_.bit_depth == -1) {\n      use_high_bit_depth_ = false;\n      bit_depth_ = VPX_BITS_8;\n      source_data_ = source_data8_;\n      reference_data_ = reference_data8_;\n      second_pred_ = second_pred8_;\n#if CONFIG_VP9_HIGHBITDEPTH\n    } else {\n      use_high_bit_depth_ = true;\n      bit_depth_ = static_cast<vpx_bit_depth_t>(params_.bit_depth);\n      source_data_ = CONVERT_TO_BYTEPTR(source_data16_);\n      reference_data_ = CONVERT_TO_BYTEPTR(reference_data16_);\n      second_pred_ = CONVERT_TO_BYTEPTR(second_pred16_);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    }\n    mask_ = (1 << bit_depth_) - 1;\n    source_stride_ = (params_.width + 63) & ~63;\n    reference_stride_ = params_.width * 2;\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n  }\n\n  virtual void TearDown() {\n    vpx_free(source_data8_);\n    source_data8_ = NULL;\n    vpx_free(reference_data8_);\n    reference_data8_ = NULL;\n    vpx_free(second_pred8_);\n    second_pred8_ = NULL;\n    vpx_free(source_data16_);\n    source_data16_ = NULL;\n    vpx_free(reference_data16_);\n    reference_data16_ = NULL;\n    vpx_free(second_pred16_);\n    second_pred16_ = NULL;\n\n    libvpx_test::ClearSystemState();\n  }\n\n protected:\n  // Handle blocks up to 4 blocks 64x64 with stride up to 128\n  static const int kDataAlignment = 32;\n  static const int kDataBlockSize = 64 * 128;\n  static const int kDataBufferSize = 4 * kDataBlockSize;\n\n  uint8_t *GetReference(int block_idx) const {\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (use_high_bit_depth_) {\n      return CONVERT_TO_BYTEPTR(CONVERT_TO_SHORTPTR(reference_data_) +\n                                block_idx * kDataBlockSize);\n    }\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    return reference_data_ + block_idx * kDataBlockSize;\n  }\n\n  // Sum of Absolute Differences. Given two blocks, calculate the absolute\n  // difference between two pixels in the same relative location; accumulate.\n  uint32_t ReferenceSAD(int block_idx) const {\n    uint32_t sad = 0;\n    const uint8_t *const reference8 = GetReference(block_idx);\n    const uint8_t *const source8 = source_data_;\n#if CONFIG_VP9_HIGHBITDEPTH\n    const uint16_t *const reference16 =\n        CONVERT_TO_SHORTPTR(GetReference(block_idx));\n    const uint16_t *const source16 = CONVERT_TO_SHORTPTR(source_data_);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    for (int h = 0; h < params_.height; ++h) {\n      for (int w = 0; w < params_.width; ++w) {\n        if (!use_high_bit_depth_) {\n          sad += abs(source8[h * source_stride_ + w] -\n                     reference8[h * reference_stride_ + w]);\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          sad += abs(source16[h * source_stride_ + w] -\n                     reference16[h * reference_stride_ + w]);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n        }\n      }\n    }\n    return sad;\n  }\n\n  // Sum of Absolute Differences Average. Given two blocks, and a prediction\n  // calculate the absolute difference between one pixel and average of the\n  // corresponding and predicted pixels; accumulate.\n  unsigned int ReferenceSADavg(int block_idx) const {\n    unsigned int sad = 0;\n    const uint8_t *const reference8 = GetReference(block_idx);\n    const uint8_t *const source8 = source_data_;\n    const uint8_t *const second_pred8 = second_pred_;\n#if CONFIG_VP9_HIGHBITDEPTH\n    const uint16_t *const reference16 =\n        CONVERT_TO_SHORTPTR(GetReference(block_idx));\n    const uint16_t *const source16 = CONVERT_TO_SHORTPTR(source_data_);\n    const uint16_t *const second_pred16 = CONVERT_TO_SHORTPTR(second_pred_);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    for (int h = 0; h < params_.height; ++h) {\n      for (int w = 0; w < params_.width; ++w) {\n        if (!use_high_bit_depth_) {\n          const int tmp = second_pred8[h * params_.width + w] +\n                          reference8[h * reference_stride_ + w];\n          const uint8_t comp_pred = ROUND_POWER_OF_TWO(tmp, 1);\n          sad += abs(source8[h * source_stride_ + w] - comp_pred);\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          const int tmp = second_pred16[h * params_.width + w] +\n                          reference16[h * reference_stride_ + w];\n          const uint16_t comp_pred = ROUND_POWER_OF_TWO(tmp, 1);\n          sad += abs(source16[h * source_stride_ + w] - comp_pred);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n        }\n      }\n    }\n    return sad;\n  }\n\n  void FillConstant(uint8_t *data, int stride, uint16_t fill_constant) const {\n    uint8_t *data8 = data;\n#if CONFIG_VP9_HIGHBITDEPTH\n    uint16_t *data16 = CONVERT_TO_SHORTPTR(data);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    for (int h = 0; h < params_.height; ++h) {\n      for (int w = 0; w < params_.width; ++w) {\n        if (!use_high_bit_depth_) {\n          data8[h * stride + w] = static_cast<uint8_t>(fill_constant);\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          data16[h * stride + w] = fill_constant;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n        }\n      }\n    }\n  }\n\n  void FillRandom(uint8_t *data, int stride) {\n    uint8_t *data8 = data;\n#if CONFIG_VP9_HIGHBITDEPTH\n    uint16_t *data16 = CONVERT_TO_SHORTPTR(data);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    for (int h = 0; h < params_.height; ++h) {\n      for (int w = 0; w < params_.width; ++w) {\n        if (!use_high_bit_depth_) {\n          data8[h * stride + w] = rnd_.Rand8();\n#if CONFIG_VP9_HIGHBITDEPTH\n        } else {\n          data16[h * stride + w] = rnd_.Rand16() & mask_;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n        }\n      }\n    }\n  }\n\n  uint32_t mask_;\n  vpx_bit_depth_t bit_depth_;\n  int source_stride_;\n  int reference_stride_;\n  bool use_high_bit_depth_;\n\n  uint8_t *source_data_;\n  uint8_t *reference_data_;\n  uint8_t *second_pred_;\n  uint8_t *source_data8_;\n  uint8_t *reference_data8_;\n  uint8_t *second_pred8_;\n  uint16_t *source_data16_;\n  uint16_t *reference_data16_;\n  uint16_t *second_pred16_;\n\n  ACMRandom rnd_;\n  ParamType params_;\n};",
          "class_name": "SADTestBase",
          "class_pos": [
            [
              53,
              0
            ],
            [
              241,
              2
            ]
          ]
        },
        "e05910ff2dd51ae4176109e5d38c1ea7cfcb236624ef5d83a1067f3a969bcbe6": {
          "class_code": "class SADx4Test : public SADTestBase<SadMxNx4Param> {\n public:\n  SADx4Test() : SADTestBase(GetParam()) {}\n\n protected:\n  void SADs(unsigned int *results) const {\n    const uint8_t *references[] = { GetReference(0), GetReference(1),\n                                    GetReference(2), GetReference(3) };\n\n    ASM_REGISTER_STATE_CHECK(params_.func(\n        source_data_, source_stride_, references, reference_stride_, results));\n  }\n\n  void CheckSADs() const {\n    uint32_t reference_sad, exp_sad[4];\n\n    SADs(exp_sad);\n    for (int block = 0; block < 4; ++block) {\n      reference_sad = ReferenceSAD(block);\n\n      EXPECT_EQ(reference_sad, exp_sad[block]) << \"block \" << block;\n    }\n  }\n}",
          "class_name": "SADx4Test",
          "class_pos": [
            [
              243,
              0
            ],
            [
              266,
              1
            ]
          ]
        },
        "2b13afe642a43c7501ca0c179925e27e54b023e3e184c2ff8979710aaecc33bd": {
          "class_code": "class SADTest : public AbstractBench, public SADTestBase<SadMxNParam> {\n public:\n  SADTest() : SADTestBase(GetParam()) {}\n\n protected:\n  unsigned int SAD(int block_idx) const {\n    unsigned int ret;\n    const uint8_t *const reference = GetReference(block_idx);\n\n    ASM_REGISTER_STATE_CHECK(ret = params_.func(source_data_, source_stride_,\n                                                reference, reference_stride_));\n    return ret;\n  }\n\n  void CheckSAD() const {\n    const unsigned int reference_sad = ReferenceSAD(0);\n    const unsigned int exp_sad = SAD(0);\n\n    ASSERT_EQ(reference_sad, exp_sad);\n  }\n\n  void Run() {\n    params_.func(source_data_, source_stride_, reference_data_,\n                 reference_stride_);\n  }\n}",
          "class_name": "SADTest",
          "class_pos": [
            [
              268,
              0
            ],
            [
              293,
              1
            ]
          ]
        },
        "29772dbdde0ddb5c06adffeaf36830e7df2b773ae5dfc2639b1e519ae927a46f": {
          "class_code": "class SADavgTest : public SADTestBase<SadMxNAvgParam> {\n public:\n  SADavgTest() : SADTestBase(GetParam()) {}\n\n protected:\n  unsigned int SAD_avg(int block_idx) const {\n    unsigned int ret;\n    const uint8_t *const reference = GetReference(block_idx);\n\n    ASM_REGISTER_STATE_CHECK(ret = params_.func(source_data_, source_stride_,\n                                                reference, reference_stride_,\n                                                second_pred_));\n    return ret;\n  }\n\n  void CheckSAD() const {\n    const unsigned int reference_sad = ReferenceSADavg(0);\n    const unsigned int exp_sad = SAD_avg(0);\n\n    ASSERT_EQ(reference_sad, exp_sad);\n  }\n}",
          "class_name": "SADavgTest",
          "class_pos": [
            [
              295,
              0
            ],
            [
              316,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct TestParams {\n  TestParams(int w, int h, Function f, int bd = -1)\n      : width(w), height(h), bit_depth(bd), func(f) {}\n  int width, height, bit_depth;\n  Function func;\n}",
          {
            "width": "int",
            "func": "Function"
          },
          "TestParams",
          [
            29,
            0
          ],
          [
            34,
            1
          ]
        ],
        [
          "struct TestParams {\n  TestParams(int w, int h, Function f, int bd = -1)\n      : width(w), height(h), bit_depth(bd), func(f) {}\n  int width, height, bit_depth;\n  Function func;\n}",
          {
            "width": "int",
            "func": "Function"
          },
          "TestParams",
          [
            29,
            0
          ],
          [
            34,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include <string.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/bench.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_codec.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"vpx_ports/mem.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"vpx_ports/msvc.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"vpx_ports/vpx_timer.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/partial_idct_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "template <InvTxfmFunc fn>\nvoid wrapper(const tran_low_t *in, uint8_t *out, int stride, int bd) {\n  (void)bd;\n  fn(in, out, stride);\n}",
          "fn_code_pos": [
            [
              38,
              0
            ],
            [
              42,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <InvTxfmHighbdFunc fn>\nvoid highbd_wrapper(const tran_low_t *in, uint8_t *out, int stride, int bd) {\n  fn(in, CAST_TO_SHORTPTR(out), stride, bd);\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              50,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~PartialIDctTest() {}",
          "fn_code_pos": [
            [
              61,
              2
            ],
            [
              61,
              31
            ]
          ],
          "class_code": "d0ba74e21df2387d10b51accbe7ce955e6475dc2ec1134754c77974698b4d257",
          "class_node_pos": [
            [
              59,
              0
            ],
            [
              191,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n    fwd_txfm_ = GET_PARAM(0);\n    full_inv_txfm_ = GET_PARAM(1);\n    partial_inv_txfm_ = GET_PARAM(2);\n    tx_size_ = GET_PARAM(3);\n    last_nonzero_ = GET_PARAM(4);\n    bit_depth_ = GET_PARAM(5);\n    pixel_size_ = GET_PARAM(6);\n    mask_ = (1 << bit_depth_) - 1;\n\n    switch (tx_size_) {\n      case TX_4X4: size_ = 4; break;\n      case TX_8X8: size_ = 8; break;\n      case TX_16X16: size_ = 16; break;\n      case TX_32X32: size_ = 32; break;\n      default: FAIL() << \"Wrong Size!\"; break;\n    }\n\n    // Randomize stride_ to a value less than or equal to 1024\n    stride_ = rnd_(1024) + 1;\n    if (stride_ < size_) {\n      stride_ = size_;\n    }\n    // Align stride_ to 16 if it's bigger than 16.\n    if (stride_ > 16) {\n      stride_ &= ~15;\n    }\n\n    input_block_size_ = size_ * size_;\n    output_block_size_ = size_ * stride_;\n\n    input_block_ = reinterpret_cast<tran_low_t *>(\n        vpx_memalign(16, sizeof(*input_block_) * input_block_size_));\n    output_block_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(16, pixel_size_ * output_block_size_));\n    output_block_ref_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(16, pixel_size_ * output_block_size_));\n  }",
          "fn_code_pos": [
            [
              62,
              2
            ],
            [
              100,
              3
            ]
          ],
          "class_code": "d0ba74e21df2387d10b51accbe7ce955e6475dc2ec1134754c77974698b4d257",
          "class_node_pos": [
            [
              59,
              0
            ],
            [
              191,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void TearDown() {\n    vpx_free(input_block_);\n    input_block_ = NULL;\n    vpx_free(output_block_);\n    output_block_ = NULL;\n    vpx_free(output_block_ref_);\n    output_block_ref_ = NULL;\n    libvpx_test::ClearSystemState();\n  }",
          "fn_code_pos": [
            [
              102,
              2
            ],
            [
              110,
              3
            ]
          ],
          "class_code": "d0ba74e21df2387d10b51accbe7ce955e6475dc2ec1134754c77974698b4d257",
          "class_node_pos": [
            [
              59,
              0
            ],
            [
              191,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void InitMem() {\n    memset(input_block_, 0, sizeof(*input_block_) * input_block_size_);\n    if (pixel_size_ == 1) {\n      for (int j = 0; j < output_block_size_; ++j) {\n        output_block_[j] = output_block_ref_[j] = rnd_.Rand16() & mask_;\n      }\n    } else {\n      ASSERT_EQ(2, pixel_size_);\n      uint16_t *const output = reinterpret_cast<uint16_t *>(output_block_);\n      uint16_t *const output_ref =\n          reinterpret_cast<uint16_t *>(output_block_ref_);\n      for (int j = 0; j < output_block_size_; ++j) {\n        output[j] = output_ref[j] = rnd_.Rand16() & mask_;\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              112,
              2
            ],
            [
              127,
              3
            ]
          ],
          "class_code": "d0ba74e21df2387d10b51accbe7ce955e6475dc2ec1134754c77974698b4d257",
          "class_node_pos": [
            [
              59,
              0
            ],
            [
              191,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "InitMem",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void InitInput() {\n    const int64_t max_coeff = (32766 << (bit_depth_ - 8)) / 4;\n    int64_t max_energy_leftover = max_coeff * max_coeff;\n    for (int j = 0; j < last_nonzero_; ++j) {\n      tran_low_t coeff = static_cast<tran_low_t>(\n          sqrt(1.0 * max_energy_leftover) * (rnd_.Rand16() - 32768) / 65536);\n      max_energy_leftover -= static_cast<int64_t>(coeff) * coeff;\n      if (max_energy_leftover < 0) {\n        max_energy_leftover = 0;\n        coeff = 0;\n      }\n      input_block_[vp9_default_scan_orders[tx_size_].scan[j]] = coeff;\n    }\n  }",
          "fn_code_pos": [
            [
              129,
              2
            ],
            [
              142,
              3
            ]
          ],
          "class_code": "d0ba74e21df2387d10b51accbe7ce955e6475dc2ec1134754c77974698b4d257",
          "class_node_pos": [
            [
              59,
              0
            ],
            [
              191,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "InitInput",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void PrintDiff() {\n    if (memcmp(output_block_ref_, output_block_,\n               pixel_size_ * output_block_size_)) {\n      uint16_t ref, opt;\n      for (int y = 0; y < size_; y++) {\n        for (int x = 0; x < size_; x++) {\n          if (pixel_size_ == 1) {\n            ref = output_block_ref_[y * stride_ + x];\n            opt = output_block_[y * stride_ + x];\n          } else {\n            ref = reinterpret_cast<uint16_t *>(\n                output_block_ref_)[y * stride_ + x];\n            opt = reinterpret_cast<uint16_t *>(output_block_)[y * stride_ + x];\n          }\n          if (ref != opt) {\n            printf(\"dest[%d][%d] diff:%6d (ref),%6d (opt)\\n\", y, x, ref, opt);\n          }\n        }\n      }\n\n      printf(\"\\ninput_block_:\\n\");\n      for (int y = 0; y < size_; y++) {\n        for (int x = 0; x < size_; x++) {\n          printf(\"%6d,\", input_block_[y * size_ + x]);\n        }\n        printf(\"\\n\");\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              144,
              2
            ],
            [
              172,
              3
            ]
          ],
          "class_code": "d0ba74e21df2387d10b51accbe7ce955e6475dc2ec1134754c77974698b4d257",
          "class_node_pos": [
            [
              59,
              0
            ],
            [
              191,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PrintDiff",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(PartialIDctTest, RunQuantCheck) {\n  const int count_test_block = (size_ != 4) ? kCountTestBlock : 65536;\n  DECLARE_ALIGNED(16, int16_t, input_extreme_block[kMaxNumCoeffs]);\n  DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kMaxNumCoeffs]);\n\n  InitMem();\n\n  for (int i = 0; i < count_test_block; ++i) {\n    // Initialize a test block with input range [-mask_, mask_].\n    if (size_ != 4) {\n      if (i == 0) {\n        for (int k = 0; k < input_block_size_; ++k) {\n          input_extreme_block[k] = mask_;\n        }\n      } else if (i == 1) {\n        for (int k = 0; k < input_block_size_; ++k) {\n          input_extreme_block[k] = -mask_;\n        }\n      } else {\n        for (int k = 0; k < input_block_size_; ++k) {\n          input_extreme_block[k] = rnd_.Rand8() % 2 ? mask_ : -mask_;\n        }\n      }\n    } else {\n      // Try all possible combinations.\n      for (int k = 0; k < input_block_size_; ++k) {\n        input_extreme_block[k] = (i & (1 << k)) ? mask_ : -mask_;\n      }\n    }\n\n    fwd_txfm_(input_extreme_block, output_ref_block, size_);\n\n    // quantization with minimum allowed step sizes\n    input_block_[0] = (output_ref_block[0] / 4) * 4;\n    for (int k = 1; k < last_nonzero_; ++k) {\n      const int pos = vp9_default_scan_orders[tx_size_].scan[k];\n      input_block_[pos] = (output_ref_block[pos] / 4) * 4;\n    }\n\n    ASM_REGISTER_STATE_CHECK(\n        full_inv_txfm_(input_block_, output_block_ref_, stride_, bit_depth_));\n    ASM_REGISTER_STATE_CHECK(\n        partial_inv_txfm_(input_block_, output_block_, stride_, bit_depth_));\n    ASSERT_EQ(0, memcmp(output_block_ref_, output_block_,\n                        pixel_size_ * output_block_size_))\n        << \"Error: partial inverse transform produces different results\";\n  }\n}",
          "fn_code_pos": [
            [
              193,
              0
            ],
            [
              240,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(PartialIDctTest, ResultsMatch) {\n  for (int i = 0; i < kCountTestBlock; ++i) {\n    InitMem();\n    InitInput();\n\n    ASM_REGISTER_STATE_CHECK(\n        full_inv_txfm_(input_block_, output_block_ref_, stride_, bit_depth_));\n    ASM_REGISTER_STATE_CHECK(\n        partial_inv_txfm_(input_block_, output_block_, stride_, bit_depth_));\n    ASSERT_EQ(0, memcmp(output_block_ref_, output_block_,\n                        pixel_size_ * output_block_size_))\n        << \"Error: partial inverse transform produces different results\";\n  }\n}",
          "fn_code_pos": [
            [
              242,
              0
            ],
            [
              255,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(PartialIDctTest, AddOutputBlock) {\n  for (int i = 0; i < kCountTestBlock; ++i) {\n    InitMem();\n    for (int j = 0; j < last_nonzero_; ++j) {\n      input_block_[vp9_default_scan_orders[tx_size_].scan[j]] = 10;\n    }\n\n    ASM_REGISTER_STATE_CHECK(\n        full_inv_txfm_(input_block_, output_block_ref_, stride_, bit_depth_));\n    ASM_REGISTER_STATE_CHECK(\n        partial_inv_txfm_(input_block_, output_block_, stride_, bit_depth_));\n    ASSERT_EQ(0, memcmp(output_block_ref_, output_block_,\n                        pixel_size_ * output_block_size_))\n        << \"Error: Transform results are not correctly added to output.\";\n  }\n}",
          "fn_code_pos": [
            [
              257,
              0
            ],
            [
              272,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(PartialIDctTest, SingleExtremeCoeff) {\n  const int16_t max_coeff = std::numeric_limits<int16_t>::max();\n  const int16_t min_coeff = std::numeric_limits<int16_t>::min();\n  for (int i = 0; i < last_nonzero_; ++i) {\n    memset(input_block_, 0, sizeof(*input_block_) * input_block_size_);\n    // Run once for min and once for max.\n    for (int j = 0; j < 2; ++j) {\n      const int coeff = j ? min_coeff : max_coeff;\n\n      memset(output_block_, 0, pixel_size_ * output_block_size_);\n      memset(output_block_ref_, 0, pixel_size_ * output_block_size_);\n      input_block_[vp9_default_scan_orders[tx_size_].scan[i]] = coeff;\n\n      ASM_REGISTER_STATE_CHECK(\n          full_inv_txfm_(input_block_, output_block_ref_, stride_, bit_depth_));\n      ASM_REGISTER_STATE_CHECK(\n          partial_inv_txfm_(input_block_, output_block_, stride_, bit_depth_));\n      ASSERT_EQ(0, memcmp(output_block_ref_, output_block_,\n                          pixel_size_ * output_block_size_))\n          << \"Error: Fails with single coeff of \" << coeff << \" at \" << i\n          << \".\";\n    }\n  }\n}",
          "fn_code_pos": [
            [
              274,
              0
            ],
            [
              297,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(PartialIDctTest, DISABLED_Speed) {\n  // Keep runtime stable with transform size.\n  const int kCountSpeedTestBlock = 500000000 / input_block_size_;\n  InitMem();\n  InitInput();\n\n  for (int i = 0; i < kCountSpeedTestBlock; ++i) {\n    ASM_REGISTER_STATE_CHECK(\n        full_inv_txfm_(input_block_, output_block_ref_, stride_, bit_depth_));\n  }\n  vpx_usec_timer timer;\n  vpx_usec_timer_start(&timer);\n  for (int i = 0; i < kCountSpeedTestBlock; ++i) {\n    partial_inv_txfm_(input_block_, output_block_, stride_, bit_depth_);\n  }\n  libvpx_test::ClearSystemState();\n  vpx_usec_timer_mark(&timer);\n  const int elapsed_time =\n      static_cast<int>(vpx_usec_timer_elapsed(&timer) / 1000);\n  printf(\"idct%dx%d_%d (%s %d) time: %5d ms\\n\", size_, size_, last_nonzero_,\n         (pixel_size_ == 1) ? \"bitdepth\" : \"high bitdepth\", bit_depth_,\n         elapsed_time);\n  ASSERT_EQ(0, memcmp(output_block_ref_, output_block_,\n                      pixel_size_ * output_block_size_))\n      << \"Error: partial inverse transform produces different results\";\n}",
          "fn_code_pos": [
            [
              299,
              0
            ],
            [
              324,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*FwdTxfmFunc)(const int16_t *in, tran_low_t *out, int stride)",
          "fn_dec_pos": [
            [
              33,
              13
            ],
            [
              33,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "int16_t",
              "out": "tran_low_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*InvTxfmFunc)(const tran_low_t *in, uint8_t *out, int stride)",
          "fn_dec_pos": [
            [
              34,
              13
            ],
            [
              34,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*InvTxfmWithBdFunc)(const tran_low_t *in, uint8_t *out,\n                                  int stride, int bd)",
          "fn_dec_pos": [
            [
              35,
              13
            ],
            [
              36,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint8_t",
              "stride": "int",
              "bd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*InvTxfmHighbdFunc)(const tran_low_t *in, uint16_t *out,\n                                  int stride, int bd)",
          "fn_dec_pos": [
            [
              45,
              13
            ],
            [
              46,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "tran_low_t",
              "out": "uint16_t",
              "stride": "int",
              "bd": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {
        "d0ba74e21df2387d10b51accbe7ce955e6475dc2ec1134754c77974698b4d257": {
          "class_code": "class PartialIDctTest : public ::testing::TestWithParam<PartialInvTxfmParam> {\n public:\n  virtual ~PartialIDctTest() {}\n  virtual void SetUp() {\n    rnd_.Reset(ACMRandom::DeterministicSeed());\n    fwd_txfm_ = GET_PARAM(0);\n    full_inv_txfm_ = GET_PARAM(1);\n    partial_inv_txfm_ = GET_PARAM(2);\n    tx_size_ = GET_PARAM(3);\n    last_nonzero_ = GET_PARAM(4);\n    bit_depth_ = GET_PARAM(5);\n    pixel_size_ = GET_PARAM(6);\n    mask_ = (1 << bit_depth_) - 1;\n\n    switch (tx_size_) {\n      case TX_4X4: size_ = 4; break;\n      case TX_8X8: size_ = 8; break;\n      case TX_16X16: size_ = 16; break;\n      case TX_32X32: size_ = 32; break;\n      default: FAIL() << \"Wrong Size!\"; break;\n    }\n\n    // Randomize stride_ to a value less than or equal to 1024\n    stride_ = rnd_(1024) + 1;\n    if (stride_ < size_) {\n      stride_ = size_;\n    }\n    // Align stride_ to 16 if it's bigger than 16.\n    if (stride_ > 16) {\n      stride_ &= ~15;\n    }\n\n    input_block_size_ = size_ * size_;\n    output_block_size_ = size_ * stride_;\n\n    input_block_ = reinterpret_cast<tran_low_t *>(\n        vpx_memalign(16, sizeof(*input_block_) * input_block_size_));\n    output_block_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(16, pixel_size_ * output_block_size_));\n    output_block_ref_ = reinterpret_cast<uint8_t *>(\n        vpx_memalign(16, pixel_size_ * output_block_size_));\n  }\n\n  virtual void TearDown() {\n    vpx_free(input_block_);\n    input_block_ = NULL;\n    vpx_free(output_block_);\n    output_block_ = NULL;\n    vpx_free(output_block_ref_);\n    output_block_ref_ = NULL;\n    libvpx_test::ClearSystemState();\n  }\n\n  void InitMem() {\n    memset(input_block_, 0, sizeof(*input_block_) * input_block_size_);\n    if (pixel_size_ == 1) {\n      for (int j = 0; j < output_block_size_; ++j) {\n        output_block_[j] = output_block_ref_[j] = rnd_.Rand16() & mask_;\n      }\n    } else {\n      ASSERT_EQ(2, pixel_size_);\n      uint16_t *const output = reinterpret_cast<uint16_t *>(output_block_);\n      uint16_t *const output_ref =\n          reinterpret_cast<uint16_t *>(output_block_ref_);\n      for (int j = 0; j < output_block_size_; ++j) {\n        output[j] = output_ref[j] = rnd_.Rand16() & mask_;\n      }\n    }\n  }\n\n  void InitInput() {\n    const int64_t max_coeff = (32766 << (bit_depth_ - 8)) / 4;\n    int64_t max_energy_leftover = max_coeff * max_coeff;\n    for (int j = 0; j < last_nonzero_; ++j) {\n      tran_low_t coeff = static_cast<tran_low_t>(\n          sqrt(1.0 * max_energy_leftover) * (rnd_.Rand16() - 32768) / 65536);\n      max_energy_leftover -= static_cast<int64_t>(coeff) * coeff;\n      if (max_energy_leftover < 0) {\n        max_energy_leftover = 0;\n        coeff = 0;\n      }\n      input_block_[vp9_default_scan_orders[tx_size_].scan[j]] = coeff;\n    }\n  }\n\n  void PrintDiff() {\n    if (memcmp(output_block_ref_, output_block_,\n               pixel_size_ * output_block_size_)) {\n      uint16_t ref, opt;\n      for (int y = 0; y < size_; y++) {\n        for (int x = 0; x < size_; x++) {\n          if (pixel_size_ == 1) {\n            ref = output_block_ref_[y * stride_ + x];\n            opt = output_block_[y * stride_ + x];\n          } else {\n            ref = reinterpret_cast<uint16_t *>(\n                output_block_ref_)[y * stride_ + x];\n            opt = reinterpret_cast<uint16_t *>(output_block_)[y * stride_ + x];\n          }\n          if (ref != opt) {\n            printf(\"dest[%d][%d] diff:%6d (ref),%6d (opt)\\n\", y, x, ref, opt);\n          }\n        }\n      }\n\n      printf(\"\\ninput_block_:\\n\");\n      for (int y = 0; y < size_; y++) {\n        for (int x = 0; x < size_; x++) {\n          printf(\"%6d,\", input_block_[y * size_ + x]);\n        }\n        printf(\"\\n\");\n      }\n    }\n  }\n\n protected:\n  int last_nonzero_;\n  TX_SIZE tx_size_;\n  tran_low_t *input_block_;\n  uint8_t *output_block_;\n  uint8_t *output_block_ref_;\n  int size_;\n  int stride_;\n  int pixel_size_;\n  int input_block_size_;\n  int output_block_size_;\n  int bit_depth_;\n  int mask_;\n  FwdTxfmFunc fwd_txfm_;\n  InvTxfmWithBdFunc full_inv_txfm_;\n  InvTxfmWithBdFunc partial_inv_txfm_;\n  ACMRandom rnd_;\n}",
          "class_name": "PartialIDctTest",
          "class_pos": [
            [
              59,
              0
            ],
            [
              191,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <math.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <limits>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"./vp9_rtcd.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"./vpx_dsp_rtcd.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_blockd.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_scan.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"vpx_ports/vpx_timer.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vp9_datarate_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "explicit DatarateTestVP9(const ::libvpx_test::CodecFactory *codec)\n      : EncoderTest(codec) {\n    tune_content_ = 0;\n  }",
          "fn_code_pos": [
            [
              23,
              2
            ],
            [
              26,
              3
            ]
          ],
          "class_code": "370ecbb9f003864fff53df573b33f5cd43f1fb37104ca52fe7806f2c446fe449",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              226,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DatarateTestVP9",
            "parameters": {
              "codec": "::libvpx_test::CodecFactory"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DatarateTestVP9() {}",
          "fn_code_pos": [
            [
              29,
              2
            ],
            [
              29,
              31
            ]
          ],
          "class_code": "370ecbb9f003864fff53df573b33f5cd43f1fb37104ca52fe7806f2c446fe449",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              226,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void ResetModel() {\n    last_pts_ = 0;\n    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;\n    frame_number_ = 0;\n    tot_frame_number_ = 0;\n    first_drop_ = 0;\n    num_drops_ = 0;\n    aq_mode_ = 3;\n    // Denoiser is off by default.\n    denoiser_on_ = 0;\n    // For testing up to 3 layers.\n    for (int i = 0; i < 3; ++i) {\n      bits_total_[i] = 0;\n    }\n    denoiser_offon_test_ = 0;\n    denoiser_offon_period_ = -1;\n    frame_parallel_decoding_mode_ = 1;\n    use_roi_ = false;\n  }",
          "fn_code_pos": [
            [
              31,
              2
            ],
            [
              49,
              3
            ]
          ],
          "class_code": "370ecbb9f003864fff53df573b33f5cd43f1fb37104ca52fe7806f2c446fe449",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              226,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ResetModel",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int GetFrameFlags(int frame_num, int num_temp_layers) {\n    int frame_flags = 0;\n    if (num_temp_layers == 2) {\n      if (frame_num % 2 == 0) {\n        // Layer 0: predict from L and ARF, update L.\n        frame_flags =\n            VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF;\n      } else {\n        // Layer 1: predict from L, G and ARF, and update G.\n        frame_flags = VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST |\n                      VP8_EFLAG_NO_UPD_ENTROPY;\n      }\n    } else if (num_temp_layers == 3) {\n      if (frame_num % 4 == 0) {\n        // Layer 0: predict from L and ARF; update L.\n        frame_flags =\n            VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_REF_GF;\n      } else if ((frame_num - 2) % 4 == 0) {\n        // Layer 1: predict from L, G, ARF; update G.\n        frame_flags = VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST;\n      } else if ((frame_num - 1) % 2 == 0) {\n        // Layer 2: predict from L, G, ARF; update ARF.\n        frame_flags = VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_LAST;\n      }\n    }\n    return frame_flags;\n  }",
          "fn_code_pos": [
            [
              65,
              2
            ],
            [
              91,
              3
            ]
          ],
          "class_code": "370ecbb9f003864fff53df573b33f5cd43f1fb37104ca52fe7806f2c446fe449",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              226,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetFrameFlags",
            "parameters": {
              "frame_num": "int",
              "num_temp_layers": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int SetLayerId(int frame_num, int num_temp_layers) {\n    int layer_id = 0;\n    if (num_temp_layers == 2) {\n      if (frame_num % 2 == 0) {\n        layer_id = 0;\n      } else {\n        layer_id = 1;\n      }\n    } else if (num_temp_layers == 3) {\n      if (frame_num % 4 == 0) {\n        layer_id = 0;\n      } else if ((frame_num - 2) % 4 == 0) {\n        layer_id = 1;\n      } else if ((frame_num - 1) % 2 == 0) {\n        layer_id = 2;\n      }\n    }\n    return layer_id;\n  }",
          "fn_code_pos": [
            [
              93,
              2
            ],
            [
              111,
              3
            ]
          ],
          "class_code": "370ecbb9f003864fff53df573b33f5cd43f1fb37104ca52fe7806f2c446fe449",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              226,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetLayerId",
            "parameters": {
              "frame_num": "int",
              "num_temp_layers": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n      encoder->Control(VP9E_SET_AQ_MODE, aq_mode_);\n      encoder->Control(VP9E_SET_TUNE_CONTENT, tune_content_);\n    }\n\n    if (denoiser_offon_test_) {\n      ASSERT_GT(denoiser_offon_period_, 0)\n          << \"denoiser_offon_period_ is not positive.\";\n      if ((video->frame() + 1) % denoiser_offon_period_ == 0) {\n        // Flip denoiser_on_ periodically\n        denoiser_on_ ^= 1;\n      }\n    }\n\n    encoder->Control(VP9E_SET_NOISE_SENSITIVITY, denoiser_on_);\n    encoder->Control(VP9E_SET_TILE_COLUMNS, get_msb(cfg_.g_threads));\n    encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING,\n                     frame_parallel_decoding_mode_);\n\n    if (use_roi_) {\n      encoder->Control(VP9E_SET_ROI_MAP, &roi_);\n      encoder->Control(VP9E_SET_AQ_MODE, 0);\n    }\n\n    if (cfg_.ts_number_layers > 1) {\n      if (video->frame() == 0) {\n        encoder->Control(VP9E_SET_SVC, 1);\n      }\n      vpx_svc_layer_id_t layer_id;\n      layer_id.spatial_layer_id = 0;\n      frame_flags_ = GetFrameFlags(video->frame(), cfg_.ts_number_layers);\n      layer_id.temporal_layer_id =\n          SetLayerId(video->frame(), cfg_.ts_number_layers);\n      layer_id.temporal_layer_id_per_spatial[0] =\n          SetLayerId(video->frame(), cfg_.ts_number_layers);\n      encoder->Control(VP9E_SET_SVC_LAYER_ID, &layer_id);\n    }\n    const vpx_rational_t tb = video->timebase();\n    timebase_ = static_cast<double>(tb.num) / tb.den;\n    duration_ = 0;\n  }",
          "fn_code_pos": [
            [
              113,
              2
            ],
            [
              156,
              3
            ]
          ],
          "class_code": "370ecbb9f003864fff53df573b33f5cd43f1fb37104ca52fe7806f2c446fe449",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              226,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    // Time since last timestamp = duration.\n    vpx_codec_pts_t duration = pkt->data.frame.pts - last_pts_;\n\n    if (duration > 1) {\n      // If first drop not set and we have a drop set it to this time.\n      if (!first_drop_) first_drop_ = last_pts_ + 1;\n      // Update the number of frame drops.\n      num_drops_ += static_cast<int>(duration - 1);\n      // Update counter for total number of frames (#frames input to encoder).\n      // Needed for setting the proper layer_id below.\n      tot_frame_number_ += static_cast<int>(duration - 1);\n    }\n\n    int layer = SetLayerId(tot_frame_number_, cfg_.ts_number_layers);\n\n    // Add to the buffer the bits we'd expect from a constant bitrate server.\n    bits_in_buffer_model_ += static_cast<int64_t>(\n        duration * timebase_ * cfg_.rc_target_bitrate * 1000);\n\n    // Buffer should not go negative.\n    ASSERT_GE(bits_in_buffer_model_, 0)\n        << \"Buffer Underrun at frame \" << pkt->data.frame.pts;\n\n    const size_t frame_size_in_bits = pkt->data.frame.sz * 8;\n\n    // Update the total encoded bits. For temporal layers, update the cumulative\n    // encoded bits per layer.\n    for (int i = layer; i < static_cast<int>(cfg_.ts_number_layers); ++i) {\n      bits_total_[i] += frame_size_in_bits;\n    }\n\n    // Update the most recent pts.\n    last_pts_ = pkt->data.frame.pts;\n    ++frame_number_;\n    ++tot_frame_number_;\n  }",
          "fn_code_pos": [
            [
              158,
              2
            ],
            [
              194,
              3
            ]
          ],
          "class_code": "370ecbb9f003864fff53df573b33f5cd43f1fb37104ca52fe7806f2c446fe449",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              226,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void EndPassHook(void) {\n    for (int layer = 0; layer < static_cast<int>(cfg_.ts_number_layers);\n         ++layer) {\n      duration_ = (last_pts_ + 1) * timebase_;\n      if (bits_total_[layer]) {\n        // Effective file datarate:\n        effective_datarate_[layer] = (bits_total_[layer] / 1000.0) / duration_;\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              196,
              2
            ],
            [
              205,
              3
            ]
          ],
          "class_code": "370ecbb9f003864fff53df573b33f5cd43f1fb37104ca52fe7806f2c446fe449",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              226,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EndPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "DatarateTestVP9RealTimeMultiBR() : DatarateTestVP9(GET_PARAM(0)) {}",
          "fn_code_pos": [
            [
              233,
              2
            ],
            [
              233,
              69
            ]
          ],
          "class_code": "11eacb48f53427cd1713d8885e02c70325c127b61a18cff13d1b2ee5b1fd74e9",
          "class_node_pos": [
            [
              229,
              0
            ],
            [
              242,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DatarateTestVP9RealTimeMultiBR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    set_cpu_used_ = GET_PARAM(1);\n    ResetModel();\n  }",
          "fn_code_pos": [
            [
              236,
              2
            ],
            [
              241,
              3
            ]
          ],
          "class_code": "11eacb48f53427cd1713d8885e02c70325c127b61a18cff13d1b2ee5b1fd74e9",
          "class_node_pos": [
            [
              229,
              0
            ],
            [
              242,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "DatarateTestVP9LargeVBR() : DatarateTestVP9(GET_PARAM(0)) {}",
          "fn_code_pos": [
            [
              250,
              2
            ],
            [
              250,
              62
            ]
          ],
          "class_code": "86b04d4ae7b81cbb002725838e7ea3d775a66368a0d62a3a21dd1475539c8d16",
          "class_node_pos": [
            [
              245,
              0
            ],
            [
              259,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DatarateTestVP9LargeVBR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n    set_cpu_used_ = GET_PARAM(2);\n    ResetModel();\n  }",
          "fn_code_pos": [
            [
              253,
              2
            ],
            [
              258,
              3
            ]
          ],
          "class_code": "86b04d4ae7b81cbb002725838e7ea3d775a66368a0d62a3a21dd1475539c8d16",
          "class_node_pos": [
            [
              245,
              0
            ],
            [
              259,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestVP9LargeVBR, BasicRateTargetingVBRLagZero) {\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_error_resilient = 0;\n  cfg_.rc_end_usage = VPX_VBR;\n  cfg_.g_lag_in_frames = 0;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 300);\n\n  const int bitrates[2] = { 400, 800 };\n  const int bitrate_index = GET_PARAM(3);\n  cfg_.rc_target_bitrate = bitrates[bitrate_index];\n  ResetModel();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(effective_datarate_[0], cfg_.rc_target_bitrate * 0.75)\n      << \" The datarate for the file is lower than target by too much!\";\n  ASSERT_LE(effective_datarate_[0], cfg_.rc_target_bitrate * 1.36)\n      << \" The datarate for the file is greater than target by too much!\";\n}",
          "fn_code_pos": [
            [
              262,
              0
            ],
            [
              281,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestVP9LargeVBR, BasicRateTargetingVBRLagNonZero) {\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_error_resilient = 0;\n  cfg_.rc_end_usage = VPX_VBR;\n  // For non-zero lag, rate control will work (be within bounds) for\n  // real-time mode.\n  if (deadline_ == VPX_DL_REALTIME) {\n    cfg_.g_lag_in_frames = 15;\n  } else {\n    cfg_.g_lag_in_frames = 0;\n  }\n\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 300);\n  const int bitrates[2] = { 400, 800 };\n  const int bitrate_index = GET_PARAM(3);\n  cfg_.rc_target_bitrate = bitrates[bitrate_index];\n  ResetModel();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(effective_datarate_[0], cfg_.rc_target_bitrate * 0.75)\n      << \" The datarate for the file is lower than target by too much!\";\n  ASSERT_LE(effective_datarate_[0], cfg_.rc_target_bitrate * 1.35)\n      << \" The datarate for the file is greater than target by too much!\";\n}",
          "fn_code_pos": [
            [
              284,
              0
            ],
            [
              308,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestVP9LargeVBR, BasicRateTargetingVBRLagNonZeroFrameParDecOff) {\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_error_resilient = 0;\n  cfg_.rc_end_usage = VPX_VBR;\n  // For non-zero lag, rate control will work (be within bounds) for\n  // real-time mode.\n  if (deadline_ == VPX_DL_REALTIME) {\n    cfg_.g_lag_in_frames = 15;\n  } else {\n    cfg_.g_lag_in_frames = 0;\n  }\n\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 300);\n  const int bitrates[2] = { 400, 800 };\n  const int bitrate_index = GET_PARAM(3);\n  cfg_.rc_target_bitrate = bitrates[bitrate_index];\n  ResetModel();\n  frame_parallel_decoding_mode_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(effective_datarate_[0], cfg_.rc_target_bitrate * 0.75)\n      << \" The datarate for the file is lower than target by too much!\";\n  ASSERT_LE(effective_datarate_[0], cfg_.rc_target_bitrate * 1.35)\n      << \" The datarate for the file is greater than target by too much!\";\n}",
          "fn_code_pos": [
            [
              313,
              0
            ],
            [
              338,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestVP9RealTimeMultiBR, BasicRateTargeting) {\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_dropframe_thresh = 1;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_lag_in_frames = 0;\n\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  const int bitrates[4] = { 150, 350, 550, 750 };\n  const int bitrate_index = GET_PARAM(2);\n  cfg_.rc_target_bitrate = bitrates[bitrate_index];\n  ResetModel();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(effective_datarate_[0], cfg_.rc_target_bitrate * 0.85)\n      << \" The datarate for the file is lower than target by too much!\";\n  ASSERT_LE(effective_datarate_[0], cfg_.rc_target_bitrate * 1.15)\n      << \" The datarate for the file is greater than target by too much!\";\n}",
          "fn_code_pos": [
            [
              341,
              0
            ],
            [
              362,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestVP9RealTimeMultiBR, BasicRateTargetingFrameParDecOff) {\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_dropframe_thresh = 1;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_lag_in_frames = 0;\n  cfg_.g_error_resilient = 0;\n\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  const int bitrates[4] = { 150, 350, 550, 750 };\n  const int bitrate_index = GET_PARAM(2);\n  cfg_.rc_target_bitrate = bitrates[bitrate_index];\n  ResetModel();\n  frame_parallel_decoding_mode_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(effective_datarate_[0], cfg_.rc_target_bitrate * 0.85)\n      << \" The datarate for the file is lower than target by too much!\";\n  ASSERT_LE(effective_datarate_[0], cfg_.rc_target_bitrate * 1.15)\n      << \" The datarate for the file is greater than target by too much!\";\n}",
          "fn_code_pos": [
            [
              366,
              0
            ],
            [
              389,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestVP9RealTimeMultiBR, BasicRateTargeting444) {\n  ::libvpx_test::Y4mVideoSource video(\"rush_hour_444.y4m\", 0, 140);\n\n  cfg_.g_profile = 1;\n  cfg_.g_timebase = video.timebase();\n\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_dropframe_thresh = 1;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.rc_end_usage = VPX_CBR;\n  const int bitrates[4] = { 250, 450, 650, 850 };\n  const int bitrate_index = GET_PARAM(2);\n  cfg_.rc_target_bitrate = bitrates[bitrate_index];\n  ResetModel();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(static_cast<double>(cfg_.rc_target_bitrate),\n            effective_datarate_[0] * 0.80)\n      << \" The datarate for the file exceeds the target by too much!\";\n  ASSERT_LE(static_cast<double>(cfg_.rc_target_bitrate),\n            effective_datarate_[0] * 1.15)\n      << \" The datarate for the file missed the target!\"\n      << cfg_.rc_target_bitrate << \" \" << effective_datarate_;\n}",
          "fn_code_pos": [
            [
              392,
              0
            ],
            [
              417,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestVP9RealTimeMultiBR, ChangingDropFrameThresh) {\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_undershoot_pct = 20;\n  cfg_.rc_undershoot_pct = 20;\n  cfg_.rc_dropframe_thresh = 10;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 50;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.rc_target_bitrate = 200;\n  cfg_.g_lag_in_frames = 0;\n  // TODO(marpan): Investigate datarate target failures with a smaller keyframe\n  // interval (128).\n  cfg_.kf_max_dist = 9999;\n\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n\n  const int kDropFrameThreshTestStep = 30;\n  const int bitrates[2] = { 50, 150 };\n  const int bitrate_index = GET_PARAM(2);\n  if (bitrate_index > 1) return;\n  cfg_.rc_target_bitrate = bitrates[bitrate_index];\n  vpx_codec_pts_t last_drop = 140;\n  int last_num_drops = 0;\n  for (int i = 10; i < 100; i += kDropFrameThreshTestStep) {\n    cfg_.rc_dropframe_thresh = i;\n    ResetModel();\n    ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n    ASSERT_GE(effective_datarate_[0], cfg_.rc_target_bitrate * 0.85)\n        << \" The datarate for the file is lower than target by too much!\";\n    ASSERT_LE(effective_datarate_[0], cfg_.rc_target_bitrate * 1.25)\n        << \" The datarate for the file is greater than target by too much!\";\n    ASSERT_LE(first_drop_, last_drop)\n        << \" The first dropped frame for drop_thresh \" << i\n        << \" > first dropped frame for drop_thresh \"\n        << i - kDropFrameThreshTestStep;\n    ASSERT_GE(num_drops_, last_num_drops * 0.85)\n        << \" The number of dropped frames for drop_thresh \" << i\n        << \" < number of dropped frames for drop_thresh \"\n        << i - kDropFrameThreshTestStep;\n    last_drop = first_drop_;\n    last_num_drops = num_drops_;\n  }\n}",
          "fn_code_pos": [
            [
              423,
              0
            ],
            [
              468,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestVP9RealTimeMultiBR, BasicRateTargeting2TemporalLayers) {\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_dropframe_thresh = 1;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_lag_in_frames = 0;\n\n  // 2 Temporal layers, no spatial layers: Framerate decimation (2, 1).\n  cfg_.ss_number_layers = 1;\n  cfg_.ts_number_layers = 2;\n  cfg_.ts_rate_decimator[0] = 2;\n  cfg_.ts_rate_decimator[1] = 1;\n\n  cfg_.temporal_layering_mode = VP9E_TEMPORAL_LAYERING_MODE_BYPASS;\n\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  const int bitrates[4] = { 200, 400, 600, 800 };\n  const int bitrate_index = GET_PARAM(2);\n  cfg_.rc_target_bitrate = bitrates[bitrate_index];\n  ResetModel();\n  // 60-40 bitrate allocation for 2 temporal layers.\n  cfg_.layer_target_bitrate[0] = 60 * cfg_.rc_target_bitrate / 100;\n  cfg_.layer_target_bitrate[1] = cfg_.rc_target_bitrate;\n  aq_mode_ = 0;\n  if (deadline_ == VPX_DL_REALTIME) {\n    aq_mode_ = 3;\n    cfg_.g_error_resilient = 1;\n  }\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  for (int j = 0; j < static_cast<int>(cfg_.ts_number_layers); ++j) {\n    ASSERT_GE(effective_datarate_[j], cfg_.layer_target_bitrate[j] * 0.85)\n        << \" The datarate for the file is lower than target by too much, \"\n           \"for layer: \"\n        << j;\n    ASSERT_LE(effective_datarate_[j], cfg_.layer_target_bitrate[j] * 1.15)\n        << \" The datarate for the file is greater than target by too much, \"\n           \"for layer: \"\n        << j;\n  }\n}",
          "fn_code_pos": [
            [
              471,
              0
            ],
            [
              514,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestVP9RealTimeMultiBR, BasicRateTargeting3TemporalLayers) {\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_dropframe_thresh = 1;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_lag_in_frames = 0;\n\n  // 3 Temporal layers, no spatial layers: Framerate decimation (4, 2, 1).\n  cfg_.ss_number_layers = 1;\n  cfg_.ts_number_layers = 3;\n  cfg_.ts_rate_decimator[0] = 4;\n  cfg_.ts_rate_decimator[1] = 2;\n  cfg_.ts_rate_decimator[2] = 1;\n\n  cfg_.temporal_layering_mode = VP9E_TEMPORAL_LAYERING_MODE_BYPASS;\n\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  const int bitrates[4] = { 200, 400, 600, 800 };\n  const int bitrate_index = GET_PARAM(2);\n  cfg_.rc_target_bitrate = bitrates[bitrate_index];\n  ResetModel();\n  // 40-20-40 bitrate allocation for 3 temporal layers.\n  cfg_.layer_target_bitrate[0] = 40 * cfg_.rc_target_bitrate / 100;\n  cfg_.layer_target_bitrate[1] = 60 * cfg_.rc_target_bitrate / 100;\n  cfg_.layer_target_bitrate[2] = cfg_.rc_target_bitrate;\n  aq_mode_ = 0;\n  if (deadline_ == VPX_DL_REALTIME) {\n    aq_mode_ = 3;\n    cfg_.g_error_resilient = 1;\n  }\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  for (int j = 0; j < static_cast<int>(cfg_.ts_number_layers); ++j) {\n    // TODO(yaowu): Work out more stable rc control strategy and\n    //              Adjust the thresholds to be tighter than .75.\n    ASSERT_GE(effective_datarate_[j], cfg_.layer_target_bitrate[j] * 0.75)\n        << \" The datarate for the file is lower than target by too much, \"\n           \"for layer: \"\n        << j;\n    // TODO(yaowu): Work out more stable rc control strategy and\n    //              Adjust the thresholds to be tighter than 1.25.\n    ASSERT_LE(effective_datarate_[j], cfg_.layer_target_bitrate[j] * 1.25)\n        << \" The datarate for the file is greater than target by too much, \"\n           \"for layer: \"\n        << j;\n  }\n}",
          "fn_code_pos": [
            [
              517,
              0
            ],
            [
              566,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DatarateTestVP9RealTime() : DatarateTestVP9(GET_PARAM(0)) {}",
          "fn_code_pos": [
            [
              572,
              2
            ],
            [
              572,
              62
            ]
          ],
          "class_code": "8508977ef6e5bdc97fd123b601e02110831c08cd4348a0c3dacf723510610108",
          "class_node_pos": [
            [
              569,
              0
            ],
            [
              582,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DatarateTestVP9RealTime",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DatarateTestVP9RealTime() {}",
          "fn_code_pos": [
            [
              573,
              2
            ],
            [
              573,
              39
            ]
          ],
          "class_code": "8508977ef6e5bdc97fd123b601e02110831c08cd4348a0c3dacf723510610108",
          "class_node_pos": [
            [
              569,
              0
            ],
            [
              582,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    set_cpu_used_ = GET_PARAM(1);\n    ResetModel();\n  }",
          "fn_code_pos": [
            [
              576,
              2
            ],
            [
              581,
              3
            ]
          ],
          "class_code": "8508977ef6e5bdc97fd123b601e02110831c08cd4348a0c3dacf723510610108",
          "class_node_pos": [
            [
              569,
              0
            ],
            [
              582,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestVP9RealTime, BasicRateTargetingDropFramesMultiThreads) {\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_dropframe_thresh = 30;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_lag_in_frames = 0;\n  // Encode using multiple threads.\n  cfg_.g_threads = 2;\n\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  cfg_.rc_target_bitrate = 200;\n  ResetModel();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(effective_datarate_[0], cfg_.rc_target_bitrate * 0.85)\n      << \" The datarate for the file is lower than target by too much!\";\n  ASSERT_LE(effective_datarate_[0], cfg_.rc_target_bitrate * 1.15)\n      << \" The datarate for the file is greater than target by too much!\";\n}",
          "fn_code_pos": [
            [
              585,
              0
            ],
            [
              606,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestVP9RealTime,\n       BasicRateTargeting3TemporalLayersFrameDropping) {\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  // Set frame drop threshold and rc_max_quantizer to force some frame drops.\n  cfg_.rc_dropframe_thresh = 20;\n  cfg_.rc_max_quantizer = 45;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_lag_in_frames = 0;\n\n  // 3 Temporal layers, no spatial layers: Framerate decimation (4, 2, 1).\n  cfg_.ss_number_layers = 1;\n  cfg_.ts_number_layers = 3;\n  cfg_.ts_rate_decimator[0] = 4;\n  cfg_.ts_rate_decimator[1] = 2;\n  cfg_.ts_rate_decimator[2] = 1;\n\n  cfg_.temporal_layering_mode = VP9E_TEMPORAL_LAYERING_MODE_BYPASS;\n\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  cfg_.rc_target_bitrate = 200;\n  ResetModel();\n  // 40-20-40 bitrate allocation for 3 temporal layers.\n  cfg_.layer_target_bitrate[0] = 40 * cfg_.rc_target_bitrate / 100;\n  cfg_.layer_target_bitrate[1] = 60 * cfg_.rc_target_bitrate / 100;\n  cfg_.layer_target_bitrate[2] = cfg_.rc_target_bitrate;\n  aq_mode_ = 0;\n  if (deadline_ == VPX_DL_REALTIME) {\n    aq_mode_ = 3;\n    cfg_.g_error_resilient = 1;\n  }\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  for (int j = 0; j < static_cast<int>(cfg_.ts_number_layers); ++j) {\n    ASSERT_GE(effective_datarate_[j], cfg_.layer_target_bitrate[j] * 0.85)\n        << \" The datarate for the file is lower than target by too much, \"\n           \"for layer: \"\n        << j;\n    ASSERT_LE(effective_datarate_[j], cfg_.layer_target_bitrate[j] * 1.20)\n        << \" The datarate for the file is greater than target by too much, \"\n           \"for layer: \"\n        << j;\n    // Expect some frame drops in this test: for this 200 frames test,\n    // expect at least 10% and not more than 60% drops.\n    ASSERT_GE(num_drops_, 20);\n    ASSERT_LE(num_drops_, 280);\n  }\n}",
          "fn_code_pos": [
            [
              611,
              0
            ],
            [
              660,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestVP9RealTime, RegionOfInterest) {\n  if (deadline_ != VPX_DL_REALTIME || set_cpu_used_ < 5) return;\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_dropframe_thresh = 0;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_lag_in_frames = 0;\n\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n\n  cfg_.rc_target_bitrate = 450;\n  cfg_.g_w = 640;\n  cfg_.g_h = 480;\n\n  ResetModel();\n\n  // Set ROI parameters\n  use_roi_ = true;\n  memset(&roi_, 0, sizeof(roi_));\n\n  roi_.rows = (cfg_.g_h + 7) / 8;\n  roi_.cols = (cfg_.g_w + 7) / 8;\n\n  roi_.delta_q[1] = -20;\n  roi_.delta_lf[1] = -20;\n  memset(roi_.ref_frame, -1, sizeof(roi_.ref_frame));\n  roi_.ref_frame[1] = 1;\n\n  // Use 2 states: 1 is center square, 0 is the rest.\n  roi_.roi_map = reinterpret_cast<uint8_t *>(\n      calloc(roi_.rows * roi_.cols, sizeof(*roi_.roi_map)));\n  ASSERT_TRUE(roi_.roi_map != NULL);\n\n  for (unsigned int i = 0; i < roi_.rows; ++i) {\n    for (unsigned int j = 0; j < roi_.cols; ++j) {\n      if (i > (roi_.rows >> 2) && i < ((roi_.rows * 3) >> 2) &&\n          j > (roi_.cols >> 2) && j < ((roi_.cols * 3) >> 2)) {\n        roi_.roi_map[i * roi_.cols + j] = 1;\n      }\n    }\n  }\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(cfg_.rc_target_bitrate, effective_datarate_[0] * 0.90)\n      << \" The datarate for the file exceeds the target!\";\n\n  ASSERT_LE(cfg_.rc_target_bitrate, effective_datarate_[0] * 1.4)\n      << \" The datarate for the file missed the target!\";\n\n  free(roi_.roi_map);\n}",
          "fn_code_pos": [
            [
              663,
              0
            ],
            [
              717,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DatarateTestVP9PostEncodeDrop() : DatarateTestVP9(GET_PARAM(0)) {}",
          "fn_code_pos": [
            [
              724,
              2
            ],
            [
              724,
              68
            ]
          ],
          "class_code": "df8eba8aaeaa3618242dbafa8ff79ef5d25a3fa27874574c1d1795b70febcd58",
          "class_node_pos": [
            [
              720,
              0
            ],
            [
              733,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DatarateTestVP9PostEncodeDrop",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    set_cpu_used_ = GET_PARAM(1);\n    ResetModel();\n  }",
          "fn_code_pos": [
            [
              727,
              2
            ],
            [
              732,
              3
            ]
          ],
          "class_code": "df8eba8aaeaa3618242dbafa8ff79ef5d25a3fa27874574c1d1795b70febcd58",
          "class_node_pos": [
            [
              720,
              0
            ],
            [
              733,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestVP9PostEncodeDrop, PostEncodeDropScreenContent) {\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_dropframe_thresh = 30;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_lag_in_frames = 0;\n  // Encode using multiple threads.\n  cfg_.g_threads = 2;\n  cfg_.g_error_resilient = 0;\n  tune_content_ = 1;\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 300);\n  cfg_.rc_target_bitrate = 300;\n  ResetModel();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(effective_datarate_[0], cfg_.rc_target_bitrate * 0.85)\n      << \" The datarate for the file is lower than target by too much!\";\n  ASSERT_LE(effective_datarate_[0], cfg_.rc_target_bitrate * 1.15)\n      << \" The datarate for the file is greater than target by too much!\";\n}",
          "fn_code_pos": [
            [
              736,
              0
            ],
            [
              758,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DatarateTestVP9RealTimeDenoiser() {}",
          "fn_code_pos": [
            [
              764,
              2
            ],
            [
              764,
              47
            ]
          ],
          "class_code": "298bed03c9d75e511021c6d223720ff1219d654439e9f9b0147528ff973d5143",
          "class_node_pos": [
            [
              762,
              0
            ],
            [
              765,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestVP9RealTimeDenoiser, LowNoise) {\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_dropframe_thresh = 1;\n  cfg_.rc_min_quantizer = 2;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_lag_in_frames = 0;\n\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n\n  // For the temporal denoiser (#if CONFIG_VP9_TEMPORAL_DENOISING),\n  // there is only one denoiser mode: denoiserYonly(which is 1),\n  // but may add more modes in the future.\n  cfg_.rc_target_bitrate = 400;\n  ResetModel();\n  // Turn on the denoiser.\n  denoiser_on_ = 1;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(effective_datarate_[0], cfg_.rc_target_bitrate * 0.85)\n      << \" The datarate for the file is lower than target by too much!\";\n  ASSERT_LE(effective_datarate_[0], cfg_.rc_target_bitrate * 1.15)\n      << \" The datarate for the file is greater than target by too much!\";\n}",
          "fn_code_pos": [
            [
              768,
              0
            ],
            [
              793,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestVP9RealTimeDenoiser, HighNoise) {\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_dropframe_thresh = 1;\n  cfg_.rc_min_quantizer = 2;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_lag_in_frames = 0;\n  cfg_.g_threads = 2;\n\n  ::libvpx_test::Y4mVideoSource video(\"noisy_clip_640_360.y4m\", 0, 200);\n\n  // For the temporal denoiser (#if CONFIG_VP9_TEMPORAL_DENOISING),\n  // there is only one denoiser mode: kDenoiserOnYOnly(which is 1),\n  // but may add more modes in the future.\n  cfg_.rc_target_bitrate = 1000;\n  ResetModel();\n  // Turn on the denoiser.\n  denoiser_on_ = 1;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(effective_datarate_[0], cfg_.rc_target_bitrate * 0.85)\n      << \" The datarate for the file is lower than target by too much!\";\n  ASSERT_LE(effective_datarate_[0], cfg_.rc_target_bitrate * 1.15)\n      << \" The datarate for the file is greater than target by too much!\";\n}",
          "fn_code_pos": [
            [
              797,
              0
            ],
            [
              822,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateTestVP9RealTimeDenoiser, DenoiserOffOn) {\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_dropframe_thresh = 1;\n  cfg_.rc_min_quantizer = 2;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_lag_in_frames = 0;\n\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n\n  // For the temporal denoiser (#if CONFIG_VP9_TEMPORAL_DENOISING),\n  // there is only one denoiser mode: denoiserYonly(which is 1),\n  // but may add more modes in the future.\n  cfg_.rc_target_bitrate = 400;\n  ResetModel();\n  // The denoiser is off by default.\n  denoiser_on_ = 0;\n  // Set the offon test flag.\n  denoiser_offon_test_ = 1;\n  denoiser_offon_period_ = 100;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  ASSERT_GE(effective_datarate_[0], cfg_.rc_target_bitrate * 0.85)\n      << \" The datarate for the file is lower than target by too much!\";\n  ASSERT_LE(effective_datarate_[0], cfg_.rc_target_bitrate * 1.15)\n      << \" The datarate for the file is greater than target by too much!\";\n}",
          "fn_code_pos": [
            [
              855,
              0
            ],
            [
              883,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "370ecbb9f003864fff53df573b33f5cd43f1fb37104ca52fe7806f2c446fe449": {
          "class_code": "class DatarateTestVP9 : public ::libvpx_test::EncoderTest {\n public:\n  explicit DatarateTestVP9(const ::libvpx_test::CodecFactory *codec)\n      : EncoderTest(codec) {\n    tune_content_ = 0;\n  }\n\n protected:\n  virtual ~DatarateTestVP9() {}\n\n  virtual void ResetModel() {\n    last_pts_ = 0;\n    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;\n    frame_number_ = 0;\n    tot_frame_number_ = 0;\n    first_drop_ = 0;\n    num_drops_ = 0;\n    aq_mode_ = 3;\n    // Denoiser is off by default.\n    denoiser_on_ = 0;\n    // For testing up to 3 layers.\n    for (int i = 0; i < 3; ++i) {\n      bits_total_[i] = 0;\n    }\n    denoiser_offon_test_ = 0;\n    denoiser_offon_period_ = -1;\n    frame_parallel_decoding_mode_ = 1;\n    use_roi_ = false;\n  }\n\n  //\n  // Frame flags and layer id for temporal layers.\n  //\n\n  // For two layers, test pattern is:\n  //   1     3\n  // 0    2     .....\n  // For three layers, test pattern is:\n  //   1      3    5      7\n  //      2           6\n  // 0          4            ....\n  // LAST is always update on base/layer 0, GOLDEN is updated on layer 1.\n  // For this 3 layer example, the 2nd enhancement layer (layer 2) updates\n  // the altref frame.\n  static int GetFrameFlags(int frame_num, int num_temp_layers) {\n    int frame_flags = 0;\n    if (num_temp_layers == 2) {\n      if (frame_num % 2 == 0) {\n        // Layer 0: predict from L and ARF, update L.\n        frame_flags =\n            VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF;\n      } else {\n        // Layer 1: predict from L, G and ARF, and update G.\n        frame_flags = VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST |\n                      VP8_EFLAG_NO_UPD_ENTROPY;\n      }\n    } else if (num_temp_layers == 3) {\n      if (frame_num % 4 == 0) {\n        // Layer 0: predict from L and ARF; update L.\n        frame_flags =\n            VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_REF_GF;\n      } else if ((frame_num - 2) % 4 == 0) {\n        // Layer 1: predict from L, G, ARF; update G.\n        frame_flags = VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST;\n      } else if ((frame_num - 1) % 2 == 0) {\n        // Layer 2: predict from L, G, ARF; update ARF.\n        frame_flags = VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_LAST;\n      }\n    }\n    return frame_flags;\n  }\n\n  static int SetLayerId(int frame_num, int num_temp_layers) {\n    int layer_id = 0;\n    if (num_temp_layers == 2) {\n      if (frame_num % 2 == 0) {\n        layer_id = 0;\n      } else {\n        layer_id = 1;\n      }\n    } else if (num_temp_layers == 3) {\n      if (frame_num % 4 == 0) {\n        layer_id = 0;\n      } else if ((frame_num - 2) % 4 == 0) {\n        layer_id = 1;\n      } else if ((frame_num - 1) % 2 == 0) {\n        layer_id = 2;\n      }\n    }\n    return layer_id;\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n      encoder->Control(VP9E_SET_AQ_MODE, aq_mode_);\n      encoder->Control(VP9E_SET_TUNE_CONTENT, tune_content_);\n    }\n\n    if (denoiser_offon_test_) {\n      ASSERT_GT(denoiser_offon_period_, 0)\n          << \"denoiser_offon_period_ is not positive.\";\n      if ((video->frame() + 1) % denoiser_offon_period_ == 0) {\n        // Flip denoiser_on_ periodically\n        denoiser_on_ ^= 1;\n      }\n    }\n\n    encoder->Control(VP9E_SET_NOISE_SENSITIVITY, denoiser_on_);\n    encoder->Control(VP9E_SET_TILE_COLUMNS, get_msb(cfg_.g_threads));\n    encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING,\n                     frame_parallel_decoding_mode_);\n\n    if (use_roi_) {\n      encoder->Control(VP9E_SET_ROI_MAP, &roi_);\n      encoder->Control(VP9E_SET_AQ_MODE, 0);\n    }\n\n    if (cfg_.ts_number_layers > 1) {\n      if (video->frame() == 0) {\n        encoder->Control(VP9E_SET_SVC, 1);\n      }\n      vpx_svc_layer_id_t layer_id;\n      layer_id.spatial_layer_id = 0;\n      frame_flags_ = GetFrameFlags(video->frame(), cfg_.ts_number_layers);\n      layer_id.temporal_layer_id =\n          SetLayerId(video->frame(), cfg_.ts_number_layers);\n      layer_id.temporal_layer_id_per_spatial[0] =\n          SetLayerId(video->frame(), cfg_.ts_number_layers);\n      encoder->Control(VP9E_SET_SVC_LAYER_ID, &layer_id);\n    }\n    const vpx_rational_t tb = video->timebase();\n    timebase_ = static_cast<double>(tb.num) / tb.den;\n    duration_ = 0;\n  }\n\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    // Time since last timestamp = duration.\n    vpx_codec_pts_t duration = pkt->data.frame.pts - last_pts_;\n\n    if (duration > 1) {\n      // If first drop not set and we have a drop set it to this time.\n      if (!first_drop_) first_drop_ = last_pts_ + 1;\n      // Update the number of frame drops.\n      num_drops_ += static_cast<int>(duration - 1);\n      // Update counter for total number of frames (#frames input to encoder).\n      // Needed for setting the proper layer_id below.\n      tot_frame_number_ += static_cast<int>(duration - 1);\n    }\n\n    int layer = SetLayerId(tot_frame_number_, cfg_.ts_number_layers);\n\n    // Add to the buffer the bits we'd expect from a constant bitrate server.\n    bits_in_buffer_model_ += static_cast<int64_t>(\n        duration * timebase_ * cfg_.rc_target_bitrate * 1000);\n\n    // Buffer should not go negative.\n    ASSERT_GE(bits_in_buffer_model_, 0)\n        << \"Buffer Underrun at frame \" << pkt->data.frame.pts;\n\n    const size_t frame_size_in_bits = pkt->data.frame.sz * 8;\n\n    // Update the total encoded bits. For temporal layers, update the cumulative\n    // encoded bits per layer.\n    for (int i = layer; i < static_cast<int>(cfg_.ts_number_layers); ++i) {\n      bits_total_[i] += frame_size_in_bits;\n    }\n\n    // Update the most recent pts.\n    last_pts_ = pkt->data.frame.pts;\n    ++frame_number_;\n    ++tot_frame_number_;\n  }\n\n  virtual void EndPassHook(void) {\n    for (int layer = 0; layer < static_cast<int>(cfg_.ts_number_layers);\n         ++layer) {\n      duration_ = (last_pts_ + 1) * timebase_;\n      if (bits_total_[layer]) {\n        // Effective file datarate:\n        effective_datarate_[layer] = (bits_total_[layer] / 1000.0) / duration_;\n      }\n    }\n  }\n\n  vpx_codec_pts_t last_pts_;\n  double timebase_;\n  int tune_content_;\n  int frame_number_;      // Counter for number of non-dropped/encoded frames.\n  int tot_frame_number_;  // Counter for total number of input frames.\n  int64_t bits_total_[3];\n  double duration_;\n  double effective_datarate_[3];\n  int set_cpu_used_;\n  int64_t bits_in_buffer_model_;\n  vpx_codec_pts_t first_drop_;\n  int num_drops_;\n  int aq_mode_;\n  int denoiser_on_;\n  int denoiser_offon_test_;\n  int denoiser_offon_period_;\n  int frame_parallel_decoding_mode_;\n  bool use_roi_;\n  vpx_roi_map_t roi_;\n}",
          "class_name": "DatarateTestVP9",
          "class_pos": [
            [
              21,
              0
            ],
            [
              226,
              1
            ]
          ]
        },
        "11eacb48f53427cd1713d8885e02c70325c127b61a18cff13d1b2ee5b1fd74e9": {
          "class_code": "class DatarateTestVP9RealTimeMultiBR\n    : public DatarateTestVP9,\n      public ::libvpx_test::CodecTestWith2Params<int, int> {\n public:\n  DatarateTestVP9RealTimeMultiBR() : DatarateTestVP9(GET_PARAM(0)) {}\n\n protected:\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    set_cpu_used_ = GET_PARAM(1);\n    ResetModel();\n  }\n}",
          "class_name": "DatarateTestVP9RealTimeMultiBR",
          "class_pos": [
            [
              229,
              0
            ],
            [
              242,
              1
            ]
          ]
        },
        "86b04d4ae7b81cbb002725838e7ea3d775a66368a0d62a3a21dd1475539c8d16": {
          "class_code": "class DatarateTestVP9LargeVBR\n    : public DatarateTestVP9,\n      public ::libvpx_test::CodecTestWith3Params<libvpx_test::TestMode, int,\n                                                 int> {\n public:\n  DatarateTestVP9LargeVBR() : DatarateTestVP9(GET_PARAM(0)) {}\n\n protected:\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n    set_cpu_used_ = GET_PARAM(2);\n    ResetModel();\n  }\n}",
          "class_name": "DatarateTestVP9LargeVBR",
          "class_pos": [
            [
              245,
              0
            ],
            [
              259,
              1
            ]
          ]
        },
        "8508977ef6e5bdc97fd123b601e02110831c08cd4348a0c3dacf723510610108": {
          "class_code": "class DatarateTestVP9RealTime : public DatarateTestVP9,\n                                public ::libvpx_test::CodecTestWithParam<int> {\n public:\n  DatarateTestVP9RealTime() : DatarateTestVP9(GET_PARAM(0)) {}\n  virtual ~DatarateTestVP9RealTime() {}\n\n protected:\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    set_cpu_used_ = GET_PARAM(1);\n    ResetModel();\n  }\n}",
          "class_name": "DatarateTestVP9RealTime",
          "class_pos": [
            [
              569,
              0
            ],
            [
              582,
              1
            ]
          ]
        },
        "df8eba8aaeaa3618242dbafa8ff79ef5d25a3fa27874574c1d1795b70febcd58": {
          "class_code": "class DatarateTestVP9PostEncodeDrop\n    : public DatarateTestVP9,\n      public ::libvpx_test::CodecTestWithParam<int> {\n public:\n  DatarateTestVP9PostEncodeDrop() : DatarateTestVP9(GET_PARAM(0)) {}\n\n protected:\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    set_cpu_used_ = GET_PARAM(1);\n    ResetModel();\n  }\n}",
          "class_name": "DatarateTestVP9PostEncodeDrop",
          "class_pos": [
            [
              720,
              0
            ],
            [
              733,
              1
            ]
          ]
        },
        "298bed03c9d75e511021c6d223720ff1219d654439e9f9b0147528ff973d5143": {
          "class_code": "class DatarateTestVP9RealTimeDenoiser : public DatarateTestVP9RealTime {\n public:\n  virtual ~DatarateTestVP9RealTimeDenoiser() {}\n}",
          "class_name": "DatarateTestVP9RealTimeDenoiser",
          "class_pos": [
            [
              762,
              0
            ],
            [
              765,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"./vpx_config.h\"\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/y4m_video_source.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_codec.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"vpx_ports/bitops.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/decode_perf_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "TEST_P(DecodePerfTest, PerfTest) {\n  const char *const video_name = GET_PARAM(VIDEO_NAME);\n  const unsigned threads = GET_PARAM(THREADS);\n\n  libvpx_test::WebMVideoSource video(video_name);\n  video.Init();\n\n  vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n  cfg.threads = threads;\n  libvpx_test::VP9Decoder decoder(cfg, 0);\n\n  vpx_usec_timer t;\n  vpx_usec_timer_start(&t);\n\n  for (video.Begin(); video.cxdata() != NULL; video.Next()) {\n    decoder.DecodeFrame(video.cxdata(), video.frame_size());\n  }\n\n  vpx_usec_timer_mark(&t);\n  const double elapsed_secs = double(vpx_usec_timer_elapsed(&t)) / kUsecsInSec;\n  const unsigned frames = video.frame_number();\n  const double fps = double(frames) / elapsed_secs;\n\n  printf(\"{\\n\");\n  printf(\"\\t\\\"type\\\" : \\\"decode_perf_test\\\",\\n\");\n  printf(\"\\t\\\"version\\\" : \\\"%s\\\",\\n\", VERSION_STRING_NOSP);\n  printf(\"\\t\\\"videoName\\\" : \\\"%s\\\",\\n\", video_name);\n  printf(\"\\t\\\"threadCount\\\" : %u,\\n\", threads);\n  printf(\"\\t\\\"decodeTimeSecs\\\" : %f,\\n\", elapsed_secs);\n  printf(\"\\t\\\"totalFrames\\\" : %u,\\n\", frames);\n  printf(\"\\t\\\"framesPerSecond\\\" : %f\\n\", fps);\n  printf(\"}\\n\");\n}",
          "fn_code_pos": [
            [
              75,
              0
            ],
            [
              107,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "VP9NewEncodeDecodePerfTest()\n      : EncoderTest(GET_PARAM(0)), encoding_mode_(GET_PARAM(1)), speed_(0),\n        outfile_(0), out_frames_(0) {}",
          "fn_code_pos": [
            [
              116,
              2
            ],
            [
              118,
              38
            ]
          ],
          "class_code": "849b94f7b33bc8d4f421f850d1fc6d2727f155eca0bee9216803ccfce73ffdd1",
          "class_node_pos": [
            [
              112,
              0
            ],
            [
              188,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VP9NewEncodeDecodePerfTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~VP9NewEncodeDecodePerfTest() {}",
          "fn_code_pos": [
            [
              120,
              2
            ],
            [
              120,
              42
            ]
          ],
          "class_code": "849b94f7b33bc8d4f421f850d1fc6d2727f155eca0bee9216803ccfce73ffdd1",
          "class_node_pos": [
            [
              112,
              0
            ],
            [
              188,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n\n    cfg_.g_lag_in_frames = 25;\n    cfg_.rc_min_quantizer = 2;\n    cfg_.rc_max_quantizer = 56;\n    cfg_.rc_dropframe_thresh = 0;\n    cfg_.rc_undershoot_pct = 50;\n    cfg_.rc_overshoot_pct = 50;\n    cfg_.rc_buf_sz = 1000;\n    cfg_.rc_buf_initial_sz = 500;\n    cfg_.rc_buf_optimal_sz = 600;\n    cfg_.rc_resize_allowed = 0;\n    cfg_.rc_end_usage = VPX_VBR;\n  }",
          "fn_code_pos": [
            [
              122,
              2
            ],
            [
              137,
              3
            ]
          ],
          "class_code": "849b94f7b33bc8d4f421f850d1fc6d2727f155eca0bee9216803ccfce73ffdd1",
          "class_node_pos": [
            [
              112,
              0
            ],
            [
              188,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, speed_);\n      encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING, 1);\n      encoder->Control(VP9E_SET_TILE_COLUMNS, 2);\n    }\n  }",
          "fn_code_pos": [
            [
              139,
              2
            ],
            [
              146,
              3
            ]
          ],
          "class_code": "849b94f7b33bc8d4f421f850d1fc6d2727f155eca0bee9216803ccfce73ffdd1",
          "class_node_pos": [
            [
              112,
              0
            ],
            [
              188,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void BeginPassHook(unsigned int /*pass*/) {\n    const std::string data_path = getenv(\"LIBVPX_TEST_DATA_PATH\");\n    const std::string path_to_source = data_path + \"/\" + kNewEncodeOutputFile;\n    outfile_ = fopen(path_to_source.c_str(), \"wb\");\n    ASSERT_TRUE(outfile_ != NULL);\n  }",
          "fn_code_pos": [
            [
              148,
              2
            ],
            [
              153,
              3
            ]
          ],
          "class_code": "849b94f7b33bc8d4f421f850d1fc6d2727f155eca0bee9216803ccfce73ffdd1",
          "class_node_pos": [
            [
              112,
              0
            ],
            [
              188,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BeginPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void EndPassHook() {\n    if (outfile_ != NULL) {\n      if (!fseek(outfile_, 0, SEEK_SET)) {\n        ivf_write_file_header(outfile_, &cfg_, VP9_FOURCC, out_frames_);\n      }\n      fclose(outfile_);\n      outfile_ = NULL;\n    }\n  }",
          "fn_code_pos": [
            [
              155,
              2
            ],
            [
              163,
              3
            ]
          ],
          "class_code": "849b94f7b33bc8d4f421f850d1fc6d2727f155eca0bee9216803ccfce73ffdd1",
          "class_node_pos": [
            [
              112,
              0
            ],
            [
              188,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EndPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    ++out_frames_;\n\n    // Write initial file header if first frame.\n    if (pkt->data.frame.pts == 0) {\n      ivf_write_file_header(outfile_, &cfg_, VP9_FOURCC, out_frames_);\n    }\n\n    // Write frame header and data.\n    ivf_write_frame_header(outfile_, out_frames_, pkt->data.frame.sz);\n    ASSERT_EQ(fwrite(pkt->data.frame.buf, 1, pkt->data.frame.sz, outfile_),\n              pkt->data.frame.sz);\n  }",
          "fn_code_pos": [
            [
              165,
              2
            ],
            [
              177,
              3
            ]
          ],
          "class_code": "849b94f7b33bc8d4f421f850d1fc6d2727f155eca0bee9216803ccfce73ffdd1",
          "class_node_pos": [
            [
              112,
              0
            ],
            [
              188,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual bool DoDecode() const { return false; }",
          "fn_code_pos": [
            [
              179,
              2
            ],
            [
              179,
              49
            ]
          ],
          "class_code": "849b94f7b33bc8d4f421f850d1fc6d2727f155eca0bee9216803ccfce73ffdd1",
          "class_node_pos": [
            [
              112,
              0
            ],
            [
              188,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DoDecode",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "void set_speed(unsigned int speed) { speed_ = speed; }",
          "fn_code_pos": [
            [
              181,
              2
            ],
            [
              181,
              56
            ]
          ],
          "class_code": "849b94f7b33bc8d4f421f850d1fc6d2727f155eca0bee9216803ccfce73ffdd1",
          "class_node_pos": [
            [
              112,
              0
            ],
            [
              188,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "set_speed",
            "parameters": {
              "speed": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "EncodePerfTestVideo(const char *name_, uint32_t width_, uint32_t height_,\n                      uint32_t bitrate_, int frames_)\n      : name(name_), width(width_), height(height_), bitrate(bitrate_),\n        frames(frames_) {}",
          "fn_code_pos": [
            [
              191,
              2
            ],
            [
              194,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EncodePerfTestVideo",
            "parameters": {
              "name_": "char",
              "width_": "uint32_t",
              "height_": "uint32_t",
              "bitrate_": "uint32_t",
              "frames_": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(VP9NewEncodeDecodePerfTest, PerfTest) {\n  SetUp();\n\n  // TODO(JBB): Make this work by going through the set of given files.\n  const int i = 0;\n  const vpx_rational timebase = { 33333333, 1000000000 };\n  cfg_.g_timebase = timebase;\n  cfg_.rc_target_bitrate = kVP9EncodePerfTestVectors[i].bitrate;\n\n  init_flags_ = VPX_CODEC_USE_PSNR;\n\n  const char *video_name = kVP9EncodePerfTestVectors[i].name;\n  libvpx_test::I420VideoSource video(\n      video_name, kVP9EncodePerfTestVectors[i].width,\n      kVP9EncodePerfTestVectors[i].height, timebase.den, timebase.num, 0,\n      kVP9EncodePerfTestVectors[i].frames);\n  set_speed(2);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  const uint32_t threads = 4;\n\n  libvpx_test::IVFVideoSource decode_video(kNewEncodeOutputFile);\n  decode_video.Init();\n\n  vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n  cfg.threads = threads;\n  libvpx_test::VP9Decoder decoder(cfg, 0);\n\n  vpx_usec_timer t;\n  vpx_usec_timer_start(&t);\n\n  for (decode_video.Begin(); decode_video.cxdata() != NULL;\n       decode_video.Next()) {\n    decoder.DecodeFrame(decode_video.cxdata(), decode_video.frame_size());\n  }\n\n  vpx_usec_timer_mark(&t);\n  const double elapsed_secs =\n      static_cast<double>(vpx_usec_timer_elapsed(&t)) / kUsecsInSec;\n  const unsigned decode_frames = decode_video.frame_number();\n  const double fps = static_cast<double>(decode_frames) / elapsed_secs;\n\n  printf(\"{\\n\");\n  printf(\"\\t\\\"type\\\" : \\\"decode_perf_test\\\",\\n\");\n  printf(\"\\t\\\"version\\\" : \\\"%s\\\",\\n\", VERSION_STRING_NOSP);\n  printf(\"\\t\\\"videoName\\\" : \\\"%s\\\",\\n\", kNewEncodeOutputFile);\n  printf(\"\\t\\\"threadCount\\\" : %u,\\n\", threads);\n  printf(\"\\t\\\"decodeTimeSecs\\\" : %f,\\n\", elapsed_secs);\n  printf(\"\\t\\\"totalFrames\\\" : %u,\\n\", decode_frames);\n  printf(\"\\t\\\"framesPerSecond\\\" : %f\\n\", fps);\n  printf(\"}\\n\");\n}",
          "fn_code_pos": [
            [
              206,
              0
            ],
            [
              258,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "video(video_name)",
          "fn_dec_pos": [
            [
              79,
              31
            ],
            [
              79,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "video",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "decode_video(kNewEncodeOutputFile)",
          "fn_dec_pos": [
            [
              228,
              30
            ],
            [
              228,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "decode_video",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "d4562d20ac17712220cda0937f67c938a32a21ffb0111dc17eab0ae97dd38a1a": {
          "class_code": "class DecodePerfTest : public ::testing::TestWithParam<DecodePerfParam> {}",
          "class_name": "DecodePerfTest",
          "class_pos": [
            [
              73,
              0
            ],
            [
              73,
              74
            ]
          ]
        },
        "849b94f7b33bc8d4f421f850d1fc6d2727f155eca0bee9216803ccfce73ffdd1": {
          "class_code": "class VP9NewEncodeDecodePerfTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWithParam<libvpx_test::TestMode> {\n protected:\n  VP9NewEncodeDecodePerfTest()\n      : EncoderTest(GET_PARAM(0)), encoding_mode_(GET_PARAM(1)), speed_(0),\n        outfile_(0), out_frames_(0) {}\n\n  virtual ~VP9NewEncodeDecodePerfTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(encoding_mode_);\n\n    cfg_.g_lag_in_frames = 25;\n    cfg_.rc_min_quantizer = 2;\n    cfg_.rc_max_quantizer = 56;\n    cfg_.rc_dropframe_thresh = 0;\n    cfg_.rc_undershoot_pct = 50;\n    cfg_.rc_overshoot_pct = 50;\n    cfg_.rc_buf_sz = 1000;\n    cfg_.rc_buf_initial_sz = 500;\n    cfg_.rc_buf_optimal_sz = 600;\n    cfg_.rc_resize_allowed = 0;\n    cfg_.rc_end_usage = VPX_VBR;\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, speed_);\n      encoder->Control(VP9E_SET_FRAME_PARALLEL_DECODING, 1);\n      encoder->Control(VP9E_SET_TILE_COLUMNS, 2);\n    }\n  }\n\n  virtual void BeginPassHook(unsigned int /*pass*/) {\n    const std::string data_path = getenv(\"LIBVPX_TEST_DATA_PATH\");\n    const std::string path_to_source = data_path + \"/\" + kNewEncodeOutputFile;\n    outfile_ = fopen(path_to_source.c_str(), \"wb\");\n    ASSERT_TRUE(outfile_ != NULL);\n  }\n\n  virtual void EndPassHook() {\n    if (outfile_ != NULL) {\n      if (!fseek(outfile_, 0, SEEK_SET)) {\n        ivf_write_file_header(outfile_, &cfg_, VP9_FOURCC, out_frames_);\n      }\n      fclose(outfile_);\n      outfile_ = NULL;\n    }\n  }\n\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    ++out_frames_;\n\n    // Write initial file header if first frame.\n    if (pkt->data.frame.pts == 0) {\n      ivf_write_file_header(outfile_, &cfg_, VP9_FOURCC, out_frames_);\n    }\n\n    // Write frame header and data.\n    ivf_write_frame_header(outfile_, out_frames_, pkt->data.frame.sz);\n    ASSERT_EQ(fwrite(pkt->data.frame.buf, 1, pkt->data.frame.sz, outfile_),\n              pkt->data.frame.sz);\n  }\n\n  virtual bool DoDecode() const { return false; }\n\n  void set_speed(unsigned int speed) { speed_ = speed; }\n\n private:\n  libvpx_test::TestMode encoding_mode_;\n  uint32_t speed_;\n  FILE *outfile_;\n  uint32_t out_frames_;\n}",
          "class_name": "VP9NewEncodeDecodePerfTest",
          "class_pos": [
            [
              112,
              0
            ],
            [
              188,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct EncodePerfTestVideo {\n  EncodePerfTestVideo(const char *name_, uint32_t width_, uint32_t height_,\n                      uint32_t bitrate_, int frames_)\n      : name(name_), width(width_), height(height_), bitrate(bitrate_),\n        frames(frames_) {}\n  const char *name;\n  uint32_t width;\n  uint32_t height;\n  uint32_t bitrate;\n  int frames;\n}",
          {
            "char": "const",
            "width": "uint32_t",
            "height": "uint32_t",
            "bitrate": "uint32_t",
            "frames": "int"
          },
          "EncodePerfTestVideo",
          [
            190,
            0
          ],
          [
            200,
            1
          ]
        ],
        [
          "struct EncodePerfTestVideo {\n  EncodePerfTestVideo(const char *name_, uint32_t width_, uint32_t height_,\n                      uint32_t bitrate_, int frames_)\n      : name(name_), width(width_), height(height_), bitrate(bitrate_),\n        frames(frames_) {}\n  const char *name;\n  uint32_t width;\n  uint32_t height;\n  uint32_t bitrate;\n  int frames;\n}",
          {
            "char": "const",
            "width": "uint32_t",
            "height": "uint32_t",
            "bitrate": "uint32_t",
            "frames": "int"
          },
          "EncodePerfTestVideo",
          [
            190,
            0
          ],
          [
            200,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include <string>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/decode_test_driver.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/ivf_video_source.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/md5_helper.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"test/webm_video_source.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"vpx_ports/vpx_timer.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"./ivfenc.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"./vpx_version.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/aq_segment_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "AqSegmentTest() : EncoderTest(GET_PARAM(0)) {}",
          "fn_code_pos": [
            [
              21,
              2
            ],
            [
              21,
              48
            ]
          ],
          "class_code": "57659368547b8d4606dfd51334b9a237d89830830b1560a7ab2417c95f283e9a",
          "class_node_pos": [
            [
              17,
              0
            ],
            [
              42,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "AqSegmentTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~AqSegmentTest() {}",
          "fn_code_pos": [
            [
              22,
              2
            ],
            [
              22,
              29
            ]
          ],
          "class_code": "57659368547b8d4606dfd51334b9a237d89830830b1560a7ab2417c95f283e9a",
          "class_node_pos": [
            [
              17,
              0
            ],
            [
              42,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n    set_cpu_used_ = GET_PARAM(2);\n    aq_mode_ = 0;\n  }",
          "fn_code_pos": [
            [
              24,
              2
            ],
            [
              29,
              3
            ]
          ],
          "class_code": "57659368547b8d4606dfd51334b9a237d89830830b1560a7ab2417c95f283e9a",
          "class_node_pos": [
            [
              17,
              0
            ],
            [
              42,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n      encoder->Control(VP9E_SET_AQ_MODE, aq_mode_);\n      encoder->Control(VP8E_SET_MAX_INTRA_BITRATE_PCT, 100);\n    }\n  }",
          "fn_code_pos": [
            [
              31,
              2
            ],
            [
              38,
              3
            ]
          ],
          "class_code": "57659368547b8d4606dfd51334b9a237d89830830b1560a7ab2417c95f283e9a",
          "class_node_pos": [
            [
              17,
              0
            ],
            [
              42,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(AqSegmentTest, TestNoMisMatchAQ1) {\n  cfg_.rc_min_quantizer = 8;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_lag_in_frames = 0;\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_target_bitrate = 300;\n\n  aq_mode_ = 1;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 100);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              46,
              0
            ],
            [
              62,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(AqSegmentTest, TestNoMisMatchAQ2) {\n  cfg_.rc_min_quantizer = 8;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_lag_in_frames = 0;\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_target_bitrate = 300;\n\n  aq_mode_ = 2;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 100);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(AqSegmentTest, TestNoMisMatchAQ3) {\n  cfg_.rc_min_quantizer = 8;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_lag_in_frames = 0;\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_target_bitrate = 300;\n\n  aq_mode_ = 3;\n\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 100);\n\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              102,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "57659368547b8d4606dfd51334b9a237d89830830b1560a7ab2417c95f283e9a": {
          "class_code": "class AqSegmentTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWith2Params<libvpx_test::TestMode, int> {\n protected:\n  AqSegmentTest() : EncoderTest(GET_PARAM(0)) {}\n  virtual ~AqSegmentTest() {}\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n    set_cpu_used_ = GET_PARAM(2);\n    aq_mode_ = 0;\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n      encoder->Control(VP9E_SET_AQ_MODE, aq_mode_);\n      encoder->Control(VP8E_SET_MAX_INTRA_BITRATE_PCT, 100);\n    }\n  }\n\n  int set_cpu_used_;\n  int aq_mode_;\n}",
          "class_name": "AqSegmentTest",
          "class_pos": [
            [
              17,
              0
            ],
            [
              42,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/tile_independence_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "TileIndependenceTest()\n      : EncoderTest(GET_PARAM(0)), md5_fw_order_(), md5_inv_order_(),\n        n_tiles_(GET_PARAM(1)) {\n    init_flags_ = VPX_CODEC_USE_PSNR;\n    vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n    cfg.w = 704;\n    cfg.h = 144;\n    cfg.threads = 1;\n    fw_dec_ = codec_->CreateDecoder(cfg, 0);\n    inv_dec_ = codec_->CreateDecoder(cfg, 0);\n    inv_dec_->Control(VP9_INVERT_TILE_DECODE_ORDER, 1);\n  }",
          "fn_code_pos": [
            [
              25,
              2
            ],
            [
              36,
              3
            ]
          ],
          "class_code": "daa56e2819d822d0c42f7aa1d5ae0324070c5e78b52897795e96e1840a2f0bda",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              77,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TileIndependenceTest",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~TileIndependenceTest() {\n    delete fw_dec_;\n    delete inv_dec_;\n  }",
          "fn_code_pos": [
            [
              38,
              2
            ],
            [
              41,
              3
            ]
          ],
          "class_code": "daa56e2819d822d0c42f7aa1d5ae0324070c5e78b52897795e96e1840a2f0bda",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              77,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(libvpx_test::kTwoPassGood);\n  }",
          "fn_code_pos": [
            [
              43,
              2
            ],
            [
              46,
              3
            ]
          ],
          "class_code": "daa56e2819d822d0c42f7aa1d5ae0324070c5e78b52897795e96e1840a2f0bda",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              77,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                                  libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP9E_SET_TILE_COLUMNS, n_tiles_);\n    }\n  }",
          "fn_code_pos": [
            [
              48,
              2
            ],
            [
              53,
              3
            ]
          ],
          "class_code": "daa56e2819d822d0c42f7aa1d5ae0324070c5e78b52897795e96e1840a2f0bda",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              77,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "libvpx_test::VideoSource",
              "encoder": "libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UpdateMD5(::libvpx_test::Decoder *dec, const vpx_codec_cx_pkt_t *pkt,\n                 ::libvpx_test::MD5 *md5) {\n    const vpx_codec_err_t res = dec->DecodeFrame(\n        reinterpret_cast<uint8_t *>(pkt->data.frame.buf), pkt->data.frame.sz);\n    if (res != VPX_CODEC_OK) {\n      abort_ = true;\n      ASSERT_EQ(VPX_CODEC_OK, res);\n    }\n    const vpx_image_t *img = dec->GetDxData().Next();\n    md5->Add(img);\n  }",
          "fn_code_pos": [
            [
              55,
              2
            ],
            [
              65,
              3
            ]
          ],
          "class_code": "daa56e2819d822d0c42f7aa1d5ae0324070c5e78b52897795e96e1840a2f0bda",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              77,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "UpdateMD5",
            "parameters": {
              "dec": "::libvpx_test::Decoder",
              "pkt": "vpx_codec_cx_pkt_t",
              "md5": "::libvpx_test::MD5"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    UpdateMD5(fw_dec_, pkt, &md5_fw_order_);\n    UpdateMD5(inv_dec_, pkt, &md5_inv_order_);\n  }",
          "fn_code_pos": [
            [
              67,
              2
            ],
            [
              70,
              3
            ]
          ],
          "class_code": "daa56e2819d822d0c42f7aa1d5ae0324070c5e78b52897795e96e1840a2f0bda",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              77,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(TileIndependenceTest, MD5Match) {\n  const vpx_rational timebase = { 33333333, 1000000000 };\n  cfg_.g_timebase = timebase;\n  cfg_.rc_target_bitrate = 500;\n  cfg_.g_lag_in_frames = 25;\n  cfg_.rc_end_usage = VPX_VBR;\n\n  libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 704, 144,\n                                     timebase.den, timebase.num, 0, 30);\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  const char *md5_fw_str = md5_fw_order_.Get();\n  const char *md5_inv_str = md5_inv_order_.Get();\n\n  // could use ASSERT_EQ(!memcmp(.., .., 16) here, but this gives nicer\n  // output if it fails. Not sure if it's helpful since it's really just\n  // a MD5...\n  ASSERT_STREQ(md5_fw_str, md5_inv_str);\n}",
          "fn_code_pos": [
            [
              82,
              0
            ],
            [
              100,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "daa56e2819d822d0c42f7aa1d5ae0324070c5e78b52897795e96e1840a2f0bda": {
          "class_code": "class TileIndependenceTest : public ::libvpx_test::EncoderTest,\n                             public ::libvpx_test::CodecTestWithParam<int> {\n protected:\n  TileIndependenceTest()\n      : EncoderTest(GET_PARAM(0)), md5_fw_order_(), md5_inv_order_(),\n        n_tiles_(GET_PARAM(1)) {\n    init_flags_ = VPX_CODEC_USE_PSNR;\n    vpx_codec_dec_cfg_t cfg = vpx_codec_dec_cfg_t();\n    cfg.w = 704;\n    cfg.h = 144;\n    cfg.threads = 1;\n    fw_dec_ = codec_->CreateDecoder(cfg, 0);\n    inv_dec_ = codec_->CreateDecoder(cfg, 0);\n    inv_dec_->Control(VP9_INVERT_TILE_DECODE_ORDER, 1);\n  }\n\n  virtual ~TileIndependenceTest() {\n    delete fw_dec_;\n    delete inv_dec_;\n  }\n\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(libvpx_test::kTwoPassGood);\n  }\n\n  virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                                  libvpx_test::Encoder *encoder) {\n    if (video->frame() == 0) {\n      encoder->Control(VP9E_SET_TILE_COLUMNS, n_tiles_);\n    }\n  }\n\n  void UpdateMD5(::libvpx_test::Decoder *dec, const vpx_codec_cx_pkt_t *pkt,\n                 ::libvpx_test::MD5 *md5) {\n    const vpx_codec_err_t res = dec->DecodeFrame(\n        reinterpret_cast<uint8_t *>(pkt->data.frame.buf), pkt->data.frame.sz);\n    if (res != VPX_CODEC_OK) {\n      abort_ = true;\n      ASSERT_EQ(VPX_CODEC_OK, res);\n    }\n    const vpx_image_t *img = dec->GetDxData().Next();\n    md5->Add(img);\n  }\n\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    UpdateMD5(fw_dec_, pkt, &md5_fw_order_);\n    UpdateMD5(inv_dec_, pkt, &md5_inv_order_);\n  }\n\n  ::libvpx_test::MD5 md5_fw_order_, md5_inv_order_;\n  ::libvpx_test::Decoder *fw_dec_, *inv_dec_;\n\n private:\n  int n_tiles_;\n}",
          "class_name": "TileIndependenceTest",
          "class_pos": [
            [
              22,
              0
            ],
            [
              77,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <cstdio>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <cstdlib>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/md5_helper.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/svc_datarate_test.cc": {
      "fn_def_list": [
        {
          "fn_code": "explicit DatarateOnePassCbrSvc(const ::libvpx_test::CodecFactory *codec)\n      : OnePassCbrSvc(codec) {\n    inter_layer_pred_mode_ = 0;\n  }",
          "fn_code_pos": [
            [
              39,
              2
            ],
            [
              42,
              3
            ]
          ],
          "class_code": "b96b8206828665d92d8f9b8aae8446b8a5d62e8d87055aa8394aa6b2ee5cff0b",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              573,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DatarateOnePassCbrSvc",
            "parameters": {
              "codec": "::libvpx_test::CodecFactory"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DatarateOnePassCbrSvc() {}",
          "fn_code_pos": [
            [
              45,
              2
            ],
            [
              45,
              37
            ]
          ],
          "class_code": "b96b8206828665d92d8f9b8aae8446b8a5d62e8d87055aa8394aa6b2ee5cff0b",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              573,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void ResetModel() {\n    last_pts_ = 0;\n    duration_ = 0.0;\n    mismatch_psnr_ = 0.0;\n    mismatch_nframes_ = 0;\n    denoiser_on_ = 0;\n    tune_content_ = 0;\n    base_speed_setting_ = 5;\n    spatial_layer_id_ = 0;\n    temporal_layer_id_ = 0;\n    update_pattern_ = 0;\n    memset(bits_in_buffer_model_, 0, sizeof(bits_in_buffer_model_));\n    memset(bits_total_, 0, sizeof(bits_total_));\n    memset(layer_target_avg_bandwidth_, 0, sizeof(layer_target_avg_bandwidth_));\n    dynamic_drop_layer_ = false;\n    change_bitrate_ = false;\n    last_pts_ref_ = 0;\n    middle_bitrate_ = 0;\n    top_bitrate_ = 0;\n    superframe_count_ = -1;\n    key_frame_spacing_ = 9999;\n    num_nonref_frames_ = 0;\n    layer_framedrop_ = 0;\n    force_key_ = 0;\n    force_key_test_ = 0;\n    insert_layer_sync_ = 0;\n    layer_sync_on_base_ = 0;\n    force_intra_only_frame_ = 0;\n    superframe_has_intra_only_ = 0;\n    use_post_encode_drop_ = 0;\n    denoiser_off_on_ = false;\n    denoiser_enable_layers_ = false;\n  }",
          "fn_code_pos": [
            [
              47,
              2
            ],
            [
              79,
              3
            ]
          ],
          "class_code": "b96b8206828665d92d8f9b8aae8446b8a5d62e8d87055aa8394aa6b2ee5cff0b",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              573,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ResetModel",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void BeginPassHook(unsigned int /*pass*/) {}",
          "fn_code_pos": [
            [
              80,
              2
            ],
            [
              80,
              54
            ]
          ],
          "class_code": "b96b8206828665d92d8f9b8aae8446b8a5d62e8d87055aa8394aa6b2ee5cff0b",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              573,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BeginPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void set_frame_flags_bypass_mode(\n      int tl, int num_spatial_layers, int is_key_frame,\n      vpx_svc_ref_frame_config_t *ref_frame_config) {\n    for (int sl = 0; sl < num_spatial_layers; ++sl)\n      ref_frame_config->update_buffer_slot[sl] = 0;\n\n    for (int sl = 0; sl < num_spatial_layers; ++sl) {\n      if (tl == 0) {\n        ref_frame_config->lst_fb_idx[sl] = sl;\n        if (sl) {\n          if (is_key_frame) {\n            ref_frame_config->lst_fb_idx[sl] = sl - 1;\n            ref_frame_config->gld_fb_idx[sl] = sl;\n          } else {\n            ref_frame_config->gld_fb_idx[sl] = sl - 1;\n          }\n        } else {\n          ref_frame_config->gld_fb_idx[sl] = 0;\n        }\n        ref_frame_config->alt_fb_idx[sl] = 0;\n      } else if (tl == 1) {\n        ref_frame_config->lst_fb_idx[sl] = sl;\n        ref_frame_config->gld_fb_idx[sl] =\n            VPXMIN(REF_FRAMES - 1, num_spatial_layers + sl - 1);\n        ref_frame_config->alt_fb_idx[sl] =\n            VPXMIN(REF_FRAMES - 1, num_spatial_layers + sl);\n      }\n      if (!tl) {\n        if (!sl) {\n          ref_frame_config->reference_last[sl] = 1;\n          ref_frame_config->reference_golden[sl] = 0;\n          ref_frame_config->reference_alt_ref[sl] = 0;\n          ref_frame_config->update_buffer_slot[sl] |=\n              1 << ref_frame_config->lst_fb_idx[sl];\n        } else {\n          if (is_key_frame) {\n            ref_frame_config->reference_last[sl] = 1;\n            ref_frame_config->reference_golden[sl] = 0;\n            ref_frame_config->reference_alt_ref[sl] = 0;\n            ref_frame_config->update_buffer_slot[sl] |=\n                1 << ref_frame_config->gld_fb_idx[sl];\n          } else {\n            ref_frame_config->reference_last[sl] = 1;\n            ref_frame_config->reference_golden[sl] = 0;\n            ref_frame_config->reference_alt_ref[sl] = 0;\n            ref_frame_config->update_buffer_slot[sl] |=\n                1 << ref_frame_config->lst_fb_idx[sl];\n          }\n        }\n      } else if (tl == 1) {\n        if (!sl) {\n          ref_frame_config->reference_last[sl] = 1;\n          ref_frame_config->reference_golden[sl] = 0;\n          ref_frame_config->reference_alt_ref[sl] = 0;\n          ref_frame_config->update_buffer_slot[sl] |=\n              1 << ref_frame_config->alt_fb_idx[sl];\n        } else {\n          ref_frame_config->reference_last[sl] = 1;\n          ref_frame_config->reference_golden[sl] = 0;\n          ref_frame_config->reference_alt_ref[sl] = 0;\n          ref_frame_config->update_buffer_slot[sl] |=\n              1 << ref_frame_config->alt_fb_idx[sl];\n        }\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              86,
              2
            ],
            [
              151,
              3
            ]
          ],
          "class_code": "b96b8206828665d92d8f9b8aae8446b8a5d62e8d87055aa8394aa6b2ee5cff0b",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              573,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "set_frame_flags_bypass_mode",
            "parameters": {
              "tl": "int",
              "num_spatial_layers": "int",
              "is_key_frame": "int",
              "ref_frame_config": "vpx_svc_ref_frame_config_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CheckLayerRateTargeting(int num_spatial_layers, int num_temporal_layers,\n                               double thresh_overshoot,\n                               double thresh_undershoot) const {\n    for (int sl = 0; sl < num_spatial_layers; ++sl)\n      for (int tl = 0; tl < num_temporal_layers; ++tl) {\n        const int layer = sl * num_temporal_layers + tl;\n        ASSERT_GE(cfg_.layer_target_bitrate[layer],\n                  file_datarate_[layer] * thresh_overshoot)\n            << \" The datarate for the file exceeds the target by too much!\";\n        ASSERT_LE(cfg_.layer_target_bitrate[layer],\n                  file_datarate_[layer] * thresh_undershoot)\n            << \" The datarate for the file is lower than the target by too \"\n               \"much!\";\n      }\n  }",
          "fn_code_pos": [
            [
              153,
              2
            ],
            [
              167,
              3
            ]
          ],
          "class_code": "b96b8206828665d92d8f9b8aae8446b8a5d62e8d87055aa8394aa6b2ee5cff0b",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              573,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckLayerRateTargeting",
            "parameters": {
              "num_spatial_layers": "int",
              "num_temporal_layers": "int",
              "thresh_overshoot": "double",
              "thresh_undershoot": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    PreEncodeFrameHookSetup(video, encoder);\n\n    if (video->frame() == 0) {\n      if (force_intra_only_frame_) {\n        // Decoder sets the color_space for Intra-only frames\n        // to BT_601 (see line 1810 in vp9_decodeframe.c).\n        // So set it here in these tess to avoid encoder-decoder\n        // mismatch check on color space setting.\n        encoder->Control(VP9E_SET_COLOR_SPACE, VPX_CS_BT_601);\n      }\n      encoder->Control(VP9E_SET_NOISE_SENSITIVITY, denoiser_on_);\n      encoder->Control(VP9E_SET_TUNE_CONTENT, tune_content_);\n      encoder->Control(VP9E_SET_SVC_INTER_LAYER_PRED, inter_layer_pred_mode_);\n\n      if (layer_framedrop_) {\n        vpx_svc_frame_drop_t svc_drop_frame;\n        svc_drop_frame.framedrop_mode = LAYER_DROP;\n        for (int i = 0; i < number_spatial_layers_; i++)\n          svc_drop_frame.framedrop_thresh[i] = 30;\n        svc_drop_frame.max_consec_drop = 30;\n        encoder->Control(VP9E_SET_SVC_FRAME_DROP_LAYER, &svc_drop_frame);\n      }\n\n      if (use_post_encode_drop_) {\n        encoder->Control(VP9E_SET_POSTENCODE_DROP, use_post_encode_drop_);\n      }\n    }\n\n    if (denoiser_off_on_) {\n      encoder->Control(VP9E_SET_AQ_MODE, 3);\n      // Set inter_layer_pred to INTER_LAYER_PRED_OFF_NONKEY (K-SVC).\n      encoder->Control(VP9E_SET_SVC_INTER_LAYER_PRED, 2);\n      if (!denoiser_enable_layers_) {\n        if (video->frame() == 0)\n          encoder->Control(VP9E_SET_NOISE_SENSITIVITY, 0);\n        else if (video->frame() == 100)\n          encoder->Control(VP9E_SET_NOISE_SENSITIVITY, 1);\n      } else {\n        // Cumulative bitrates for top spatial layers, for\n        // 3 temporal layers.\n        if (video->frame() == 0) {\n          encoder->Control(VP9E_SET_NOISE_SENSITIVITY, 0);\n          // Change layer bitrates to set top spatial layer to 0.\n          // This is for 3 spatial 3 temporal layers.\n          // This will trigger skip encoding/dropping of top spatial layer.\n          cfg_.rc_target_bitrate -= cfg_.layer_target_bitrate[8];\n          for (int i = 0; i < 3; i++)\n            bitrate_sl3_[i] = cfg_.layer_target_bitrate[i + 6];\n          cfg_.layer_target_bitrate[6] = 0;\n          cfg_.layer_target_bitrate[7] = 0;\n          cfg_.layer_target_bitrate[8] = 0;\n          encoder->Config(&cfg_);\n        } else if (video->frame() == 100) {\n          // Change layer bitrates to non-zero on top spatial layer.\n          // This will trigger skip encoding of top spatial layer\n          // on key frame (period = 100).\n          for (int i = 0; i < 3; i++)\n            cfg_.layer_target_bitrate[i + 6] = bitrate_sl3_[i];\n          cfg_.rc_target_bitrate += cfg_.layer_target_bitrate[8];\n          encoder->Config(&cfg_);\n        } else if (video->frame() == 120) {\n          // Enable denoiser and top spatial layer after key frame (period is\n          // 100).\n          encoder->Control(VP9E_SET_NOISE_SENSITIVITY, 1);\n        }\n      }\n    }\n\n    if (update_pattern_ && video->frame() >= 100) {\n      vpx_svc_layer_id_t layer_id;\n      if (video->frame() == 100) {\n        cfg_.temporal_layering_mode = VP9E_TEMPORAL_LAYERING_MODE_BYPASS;\n        encoder->Config(&cfg_);\n      }\n      // Set layer id since the pattern changed.\n      layer_id.spatial_layer_id = 0;\n      layer_id.temporal_layer_id = (video->frame() % 2 != 0);\n      temporal_layer_id_ = layer_id.temporal_layer_id;\n      for (int i = 0; i < number_spatial_layers_; i++)\n        layer_id.temporal_layer_id_per_spatial[i] = temporal_layer_id_;\n      encoder->Control(VP9E_SET_SVC_LAYER_ID, &layer_id);\n      set_frame_flags_bypass_mode(layer_id.temporal_layer_id,\n                                  number_spatial_layers_, 0, &ref_frame_config);\n      encoder->Control(VP9E_SET_SVC_REF_FRAME_CONFIG, &ref_frame_config);\n    }\n\n    if (change_bitrate_ && video->frame() == 200) {\n      duration_ = (last_pts_ + 1) * timebase_;\n      for (int sl = 0; sl < number_spatial_layers_; ++sl) {\n        for (int tl = 0; tl < number_temporal_layers_; ++tl) {\n          const int layer = sl * number_temporal_layers_ + tl;\n          const double file_size_in_kb = bits_total_[layer] / 1000.;\n          file_datarate_[layer] = file_size_in_kb / duration_;\n        }\n      }\n\n      CheckLayerRateTargeting(number_spatial_layers_, number_temporal_layers_,\n                              0.78, 1.15);\n\n      memset(file_datarate_, 0, sizeof(file_datarate_));\n      memset(bits_total_, 0, sizeof(bits_total_));\n      int64_t bits_in_buffer_model_tmp[VPX_MAX_LAYERS];\n      last_pts_ref_ = last_pts_;\n      // Set new target bitarate.\n      cfg_.rc_target_bitrate = cfg_.rc_target_bitrate >> 1;\n      // Buffer level should not reset on dynamic bitrate change.\n      memcpy(bits_in_buffer_model_tmp, bits_in_buffer_model_,\n             sizeof(bits_in_buffer_model_));\n      AssignLayerBitrates();\n      memcpy(bits_in_buffer_model_, bits_in_buffer_model_tmp,\n             sizeof(bits_in_buffer_model_));\n\n      // Change config to update encoder with new bitrate configuration.\n      encoder->Config(&cfg_);\n    }\n\n    if (dynamic_drop_layer_) {\n      // TODO(jian): Disable AQ Mode for this test for now.\n      encoder->Control(VP9E_SET_AQ_MODE, 0);\n      if (video->frame() == 0) {\n        // Change layer bitrates to set top layers to 0. This will trigger skip\n        // encoding/dropping of top two spatial layers.\n        cfg_.rc_target_bitrate -=\n            (cfg_.layer_target_bitrate[1] + cfg_.layer_target_bitrate[2]);\n        middle_bitrate_ = cfg_.layer_target_bitrate[1];\n        top_bitrate_ = cfg_.layer_target_bitrate[2];\n        cfg_.layer_target_bitrate[1] = 0;\n        cfg_.layer_target_bitrate[2] = 0;\n        encoder->Config(&cfg_);\n      } else if (video->frame() == 50) {\n        // Change layer bitrates to non-zero on two top spatial layers.\n        // This will trigger skip encoding of top two spatial layers.\n        cfg_.layer_target_bitrate[1] = middle_bitrate_;\n        cfg_.layer_target_bitrate[2] = top_bitrate_;\n        cfg_.rc_target_bitrate +=\n            cfg_.layer_target_bitrate[2] + cfg_.layer_target_bitrate[1];\n        encoder->Config(&cfg_);\n      } else if (video->frame() == 100) {\n        // Change layer bitrates to set top layers to 0. This will trigger skip\n        // encoding/dropping of top two spatial layers.\n        cfg_.rc_target_bitrate -=\n            (cfg_.layer_target_bitrate[1] + cfg_.layer_target_bitrate[2]);\n        middle_bitrate_ = cfg_.layer_target_bitrate[1];\n        top_bitrate_ = cfg_.layer_target_bitrate[2];\n        cfg_.layer_target_bitrate[1] = 0;\n        cfg_.layer_target_bitrate[2] = 0;\n        encoder->Config(&cfg_);\n      } else if (video->frame() == 150) {\n        // Change layer bitrate on second layer to non-zero to start\n        // encoding it again.\n        cfg_.layer_target_bitrate[1] = middle_bitrate_;\n        cfg_.rc_target_bitrate += cfg_.layer_target_bitrate[1];\n        encoder->Config(&cfg_);\n      } else if (video->frame() == 200) {\n        // Change layer bitrate on top layer to non-zero to start\n        // encoding it again.\n        cfg_.layer_target_bitrate[2] = top_bitrate_;\n        cfg_.rc_target_bitrate += cfg_.layer_target_bitrate[2];\n        encoder->Config(&cfg_);\n      }\n    }\n\n    if (force_key_test_ && force_key_) frame_flags_ = VPX_EFLAG_FORCE_KF;\n\n    if (insert_layer_sync_) {\n      vpx_svc_spatial_layer_sync_t svc_layer_sync;\n      svc_layer_sync.base_layer_intra_only = 0;\n      for (int i = 0; i < number_spatial_layers_; i++)\n        svc_layer_sync.spatial_layer_sync[i] = 0;\n      if (force_intra_only_frame_) {\n        superframe_has_intra_only_ = 0;\n        if (video->frame() == 0) {\n          svc_layer_sync.base_layer_intra_only = 1;\n          svc_layer_sync.spatial_layer_sync[0] = 1;\n          encoder->Control(VP9E_SET_SVC_SPATIAL_LAYER_SYNC, &svc_layer_sync);\n          superframe_has_intra_only_ = 1;\n        } else if (video->frame() == 100) {\n          svc_layer_sync.base_layer_intra_only = 1;\n          svc_layer_sync.spatial_layer_sync[0] = 1;\n          encoder->Control(VP9E_SET_SVC_SPATIAL_LAYER_SYNC, &svc_layer_sync);\n          superframe_has_intra_only_ = 1;\n        }\n      } else {\n        layer_sync_on_base_ = 0;\n        if (video->frame() == 150) {\n          svc_layer_sync.spatial_layer_sync[1] = 1;\n          encoder->Control(VP9E_SET_SVC_SPATIAL_LAYER_SYNC, &svc_layer_sync);\n        } else if (video->frame() == 240) {\n          svc_layer_sync.spatial_layer_sync[2] = 1;\n          encoder->Control(VP9E_SET_SVC_SPATIAL_LAYER_SYNC, &svc_layer_sync);\n        } else if (video->frame() == 320) {\n          svc_layer_sync.spatial_layer_sync[0] = 1;\n          layer_sync_on_base_ = 1;\n          encoder->Control(VP9E_SET_SVC_SPATIAL_LAYER_SYNC, &svc_layer_sync);\n        }\n      }\n    }\n\n    const vpx_rational_t tb = video->timebase();\n    timebase_ = static_cast<double>(tb.num) / tb.den;\n    duration_ = 0;\n  }",
          "fn_code_pos": [
            [
              169,
              2
            ],
            [
              372,
              3
            ]
          ],
          "class_code": "b96b8206828665d92d8f9b8aae8446b8a5d62e8d87055aa8394aa6b2ee5cff0b",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              573,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "vpx_codec_err_t parse_superframe_index(const uint8_t *data, size_t data_sz,\n                                         uint32_t sizes[8], int *count) {\n    uint8_t marker;\n    marker = *(data + data_sz - 1);\n    *count = 0;\n    if ((marker & 0xe0) == 0xc0) {\n      const uint32_t frames = (marker & 0x7) + 1;\n      const uint32_t mag = ((marker >> 3) & 0x3) + 1;\n      const size_t index_sz = 2 + mag * frames;\n      // This chunk is marked as having a superframe index but doesn't have\n      // enough data for it, thus it's an invalid superframe index.\n      if (data_sz < index_sz) return VPX_CODEC_CORRUPT_FRAME;\n      {\n        const uint8_t marker2 = *(data + data_sz - index_sz);\n        // This chunk is marked as having a superframe index but doesn't have\n        // the matching marker byte at the front of the index therefore it's an\n        // invalid chunk.\n        if (marker != marker2) return VPX_CODEC_CORRUPT_FRAME;\n      }\n      {\n        uint32_t i, j;\n        const uint8_t *x = &data[data_sz - index_sz + 1];\n        for (i = 0; i < frames; ++i) {\n          uint32_t this_sz = 0;\n\n          for (j = 0; j < mag; ++j) this_sz |= (*x++) << (j * 8);\n          sizes[i] = this_sz;\n        }\n        *count = frames;\n      }\n    }\n    return VPX_CODEC_OK;\n  }",
          "fn_code_pos": [
            [
              374,
              2
            ],
            [
              406,
              3
            ]
          ],
          "class_code": "b96b8206828665d92d8f9b8aae8446b8a5d62e8d87055aa8394aa6b2ee5cff0b",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              573,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "parse_superframe_index",
            "parameters": {
              "data": "uint8_t",
              "data_sz": "size_t",
              "sizes": "uint32_t",
              "count": "int"
            },
            "return_type": "vpx_codec_err_t"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    uint32_t sizes[8] = { 0 };\n    uint32_t sizes_parsed[8] = { 0 };\n    int count = 0;\n    int num_layers_encoded = 0;\n    last_pts_ = pkt->data.frame.pts;\n    const bool key_frame =\n        (pkt->data.frame.flags & VPX_FRAME_IS_KEY) ? true : false;\n    if (key_frame) {\n      // For test that inserts layer sync frames: requesting a layer_sync on\n      // the base layer must force key frame. So if any key frame occurs after\n      // first superframe it must due to layer sync on base spatial layer.\n      if (superframe_count_ > 0 && insert_layer_sync_ &&\n          !force_intra_only_frame_) {\n        ASSERT_EQ(layer_sync_on_base_, 1);\n      }\n      temporal_layer_id_ = 0;\n      superframe_count_ = 0;\n    }\n    parse_superframe_index(static_cast<const uint8_t *>(pkt->data.frame.buf),\n                           pkt->data.frame.sz, sizes_parsed, &count);\n    // Count may be less than number of spatial layers because of frame drops.\n    for (int sl = 0; sl < number_spatial_layers_; ++sl) {\n      if (pkt->data.frame.spatial_layer_encoded[sl]) {\n        sizes[sl] = sizes_parsed[num_layers_encoded];\n        num_layers_encoded++;\n      }\n    }\n    // For superframe with Intra-only count will be +1 larger\n    // because of no-show frame.\n    if (force_intra_only_frame_ && superframe_has_intra_only_)\n      ASSERT_EQ(count, num_layers_encoded + 1);\n    else\n      ASSERT_EQ(count, num_layers_encoded);\n\n    // In the constrained frame drop mode, if a given spatial is dropped all\n    // upper layers must be dropped too.\n    if (!layer_framedrop_) {\n      int num_layers_dropped = 0;\n      for (int sl = 0; sl < number_spatial_layers_; ++sl) {\n        if (!pkt->data.frame.spatial_layer_encoded[sl]) {\n          // Check that all upper layers are dropped.\n          num_layers_dropped++;\n          for (int sl2 = sl + 1; sl2 < number_spatial_layers_; ++sl2)\n            ASSERT_EQ(pkt->data.frame.spatial_layer_encoded[sl2], 0);\n        }\n      }\n      if (num_layers_dropped == number_spatial_layers_ - 1)\n        force_key_ = 1;\n      else\n        force_key_ = 0;\n    }\n    // Keep track of number of non-reference frames, needed for mismatch check.\n    // Non-reference frames are top spatial and temporal layer frames,\n    // for TL > 0.\n    if (temporal_layer_id_ == number_temporal_layers_ - 1 &&\n        temporal_layer_id_ > 0 &&\n        pkt->data.frame.spatial_layer_encoded[number_spatial_layers_ - 1])\n      num_nonref_frames_++;\n    for (int sl = 0; sl < number_spatial_layers_; ++sl) {\n      sizes[sl] = sizes[sl] << 3;\n      // Update the total encoded bits per layer.\n      // For temporal layers, update the cumulative encoded bits per layer.\n      for (int tl = temporal_layer_id_; tl < number_temporal_layers_; ++tl) {\n        const int layer = sl * number_temporal_layers_ + tl;\n        bits_total_[layer] += static_cast<int64_t>(sizes[sl]);\n        // Update the per-layer buffer level with the encoded frame size.\n        bits_in_buffer_model_[layer] -= static_cast<int64_t>(sizes[sl]);\n        // There should be no buffer underrun, except on the base\n        // temporal layer, since there may be key frames there.\n        // Fo short key frame spacing, buffer can underrun on individual frames.\n        if (!key_frame && tl > 0 && key_frame_spacing_ < 100) {\n          ASSERT_GE(bits_in_buffer_model_[layer], 0)\n              << \"Buffer Underrun at frame \" << pkt->data.frame.pts;\n        }\n      }\n\n      ASSERT_EQ(pkt->data.frame.width[sl],\n                top_sl_width_ * svc_params_.scaling_factor_num[sl] /\n                    svc_params_.scaling_factor_den[sl]);\n\n      ASSERT_EQ(pkt->data.frame.height[sl],\n                top_sl_height_ * svc_params_.scaling_factor_num[sl] /\n                    svc_params_.scaling_factor_den[sl]);\n    }\n  }",
          "fn_code_pos": [
            [
              408,
              2
            ],
            [
              493,
              3
            ]
          ],
          "class_code": "b96b8206828665d92d8f9b8aae8446b8a5d62e8d87055aa8394aa6b2ee5cff0b",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              573,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void EndPassHook(void) {\n    if (change_bitrate_) last_pts_ = last_pts_ - last_pts_ref_;\n    duration_ = (last_pts_ + 1) * timebase_;\n    for (int sl = 0; sl < number_spatial_layers_; ++sl) {\n      for (int tl = 0; tl < number_temporal_layers_; ++tl) {\n        const int layer = sl * number_temporal_layers_ + tl;\n        const double file_size_in_kb = bits_total_[layer] / 1000.;\n        file_datarate_[layer] = file_size_in_kb / duration_;\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              495,
              2
            ],
            [
              505,
              3
            ]
          ],
          "class_code": "b96b8206828665d92d8f9b8aae8446b8a5d62e8d87055aa8394aa6b2ee5cff0b",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              573,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EndPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void MismatchHook(const vpx_image_t *img1, const vpx_image_t *img2) {\n    double mismatch_psnr = compute_psnr(img1, img2);\n    mismatch_psnr_ += mismatch_psnr;\n    ++mismatch_nframes_;\n  }",
          "fn_code_pos": [
            [
              507,
              2
            ],
            [
              511,
              3
            ]
          ],
          "class_code": "b96b8206828665d92d8f9b8aae8446b8a5d62e8d87055aa8394aa6b2ee5cff0b",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              573,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MismatchHook",
            "parameters": {
              "img1": "vpx_image_t",
              "img2": "vpx_image_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "unsigned int GetMismatchFrames() { return mismatch_nframes_; }",
          "fn_code_pos": [
            [
              513,
              2
            ],
            [
              513,
              64
            ]
          ],
          "class_code": "b96b8206828665d92d8f9b8aae8446b8a5d62e8d87055aa8394aa6b2ee5cff0b",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              573,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetMismatchFrames",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned int GetNonRefFrames() { return num_nonref_frames_; }",
          "fn_code_pos": [
            [
              514,
              2
            ],
            [
              514,
              63
            ]
          ],
          "class_code": "b96b8206828665d92d8f9b8aae8446b8a5d62e8d87055aa8394aa6b2ee5cff0b",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              573,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetNonRefFrames",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetConfig(const int num_temporal_layer) {\n    cfg_.rc_end_usage = VPX_CBR;\n    cfg_.g_lag_in_frames = 0;\n    cfg_.g_error_resilient = 1;\n    if (num_temporal_layer == 3) {\n      cfg_.ts_rate_decimator[0] = 4;\n      cfg_.ts_rate_decimator[1] = 2;\n      cfg_.ts_rate_decimator[2] = 1;\n      cfg_.temporal_layering_mode = 3;\n    } else if (num_temporal_layer == 2) {\n      cfg_.ts_rate_decimator[0] = 2;\n      cfg_.ts_rate_decimator[1] = 1;\n      cfg_.temporal_layering_mode = 2;\n    } else if (num_temporal_layer == 1) {\n      cfg_.ts_rate_decimator[0] = 1;\n      cfg_.temporal_layering_mode = 0;\n    }\n  }",
          "fn_code_pos": [
            [
              552,
              2
            ],
            [
              569,
              3
            ]
          ],
          "class_code": "b96b8206828665d92d8f9b8aae8446b8a5d62e8d87055aa8394aa6b2ee5cff0b",
          "class_node_pos": [
            [
              37,
              0
            ],
            [
              573,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetConfig",
            "parameters": {
              "num_temporal_layer": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "DatarateOnePassCbrSvcSingleBR() : DatarateOnePassCbrSvc(GET_PARAM(0)) {\n    memset(&svc_params_, 0, sizeof(svc_params_));\n  }",
          "fn_code_pos": [
            [
              580,
              2
            ],
            [
              582,
              3
            ]
          ],
          "class_code": "2cb33f04d1c5ce7d1e5ae95d04a4f8a1a1f2e3fd7d75590c508d8a175e8369c6",
          "class_node_pos": [
            [
              576,
              0
            ],
            [
              592,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DatarateOnePassCbrSvcSingleBR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DatarateOnePassCbrSvcSingleBR() {}",
          "fn_code_pos": [
            [
              583,
              2
            ],
            [
              583,
              45
            ]
          ],
          "class_code": "2cb33f04d1c5ce7d1e5ae95d04a4f8a1a1f2e3fd7d75590c508d8a175e8369c6",
          "class_node_pos": [
            [
              576,
              0
            ],
            [
              592,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    speed_setting_ = GET_PARAM(1);\n    ResetModel();\n  }",
          "fn_code_pos": [
            [
              586,
              2
            ],
            [
              591,
              3
            ]
          ],
          "class_code": "2cb33f04d1c5ce7d1e5ae95d04a4f8a1a1f2e3fd7d75590c508d8a175e8369c6",
          "class_node_pos": [
            [
              576,
              0
            ],
            [
              592,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(DatarateOnePassCbrSvcSingleBR, OnePassCbrSvc2SL1TLScreenContent1) {\n  SetSvcConfig(2, 1);\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_threads = 1;\n  cfg_.rc_dropframe_thresh = 10;\n  cfg_.kf_max_dist = 9999;\n\n  ::libvpx_test::Y4mVideoSource video(\"niklas_1280_720_30.y4m\", 0, 60);\n  top_sl_width_ = 1280;\n  top_sl_height_ = 720;\n  cfg_.rc_target_bitrate = 500;\n  ResetModel();\n  tune_content_ = 1;\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  CheckLayerRateTargeting(number_spatial_layers_, number_temporal_layers_, 0.78,\n                          1.15);\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              597,
              0
            ],
            [
              623,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateOnePassCbrSvcSingleBR, OnePassCbrSvc3SL3TLForceKey) {\n  SetSvcConfig(3, 3);\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_threads = 1;\n  cfg_.rc_dropframe_thresh = 30;\n  cfg_.kf_max_dist = 9999;\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  top_sl_width_ = 640;\n  top_sl_height_ = 480;\n  cfg_.rc_target_bitrate = 100;\n  ResetModel();\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  CheckLayerRateTargeting(number_spatial_layers_, number_temporal_layers_, 0.78,\n                          1.25);\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              627,
              0
            ],
            [
              652,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateOnePassCbrSvcSingleBR, OnePassCbrSvc3SL2TLDynamicPatternChange) {\n  SetSvcConfig(3, 2);\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_threads = 1;\n  cfg_.rc_dropframe_thresh = 30;\n  cfg_.kf_max_dist = 9999;\n  // Change SVC pattern on the fly.\n  update_pattern_ = 1;\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  top_sl_width_ = 640;\n  top_sl_height_ = 480;\n  cfg_.rc_target_bitrate = 800;\n  ResetModel();\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  CheckLayerRateTargeting(number_spatial_layers_, number_temporal_layers_, 0.78,\n                          1.15);\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              658,
              0
            ],
            [
              685,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateOnePassCbrSvcSingleBR,\n       OnePassCbrSvc3SL3TL_DenoiserOffOnFixedLayers) {\n  SetSvcConfig(3, 3);\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_threads = 1;\n  cfg_.rc_dropframe_thresh = 30;\n  cfg_.kf_max_dist = 1000;\n  ::libvpx_test::I420VideoSource video(\"desktop_office1.1280_720-020.yuv\", 1280,\n                                       720, 30, 1, 0, 300);\n  top_sl_width_ = 1280;\n  top_sl_height_ = 720;\n  cfg_.rc_target_bitrate = 1000;\n  ResetModel();\n  denoiser_off_on_ = true;\n  denoiser_enable_layers_ = false;\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  // Don't check rate targeting on two top spatial layer since they will be\n  // skipped for part of the sequence.\n  CheckLayerRateTargeting(number_spatial_layers_ - 2, number_temporal_layers_,\n                          0.78, 1.15);\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              691,
              0
            ],
            [
              721,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateOnePassCbrSvcSingleBR,\n       OnePassCbrSvc3SL3TL_DenoiserOffOnEnableLayers) {\n  SetSvcConfig(3, 3);\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_threads = 1;\n  cfg_.rc_dropframe_thresh = 0;\n  cfg_.kf_max_dist = 100;\n  ::libvpx_test::I420VideoSource video(\"desktop_office1.1280_720-020.yuv\", 1280,\n                                       720, 30, 1, 0, 300);\n  top_sl_width_ = 1280;\n  top_sl_height_ = 720;\n  cfg_.rc_target_bitrate = 1000;\n  ResetModel();\n  denoiser_off_on_ = true;\n  denoiser_enable_layers_ = true;\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  // Don't check rate targeting on two top spatial layer since they will be\n  // skipped for part of the sequence.\n  CheckLayerRateTargeting(number_spatial_layers_ - 2, number_temporal_layers_,\n                          0.78, 1.15);\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              729,
              0
            ],
            [
              759,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateOnePassCbrSvcSingleBR, OnePassCbrSvc3SL_DisableEnableLayers) {\n  SetSvcConfig(3, 1);\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_threads = 1;\n  cfg_.temporal_layering_mode = 0;\n  cfg_.rc_dropframe_thresh = 30;\n  cfg_.kf_max_dist = 9999;\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  top_sl_width_ = 640;\n  top_sl_height_ = 480;\n  cfg_.rc_target_bitrate = 800;\n  ResetModel();\n  dynamic_drop_layer_ = true;\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  // Don't check rate targeting on two top spatial layer since they will be\n  // skipped for part of the sequence.\n  CheckLayerRateTargeting(number_spatial_layers_ - 2, number_temporal_layers_,\n                          0.78, 1.15);\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              765,
              0
            ],
            [
              794,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateOnePassCbrSvcSingleBR, OnePassCbrSvc2SL1TL5x5MultipleRuns) {\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_lag_in_frames = 0;\n  cfg_.ss_number_layers = 2;\n  cfg_.ts_number_layers = 1;\n  cfg_.ts_rate_decimator[0] = 1;\n  cfg_.g_error_resilient = 1;\n  cfg_.g_threads = 3;\n  cfg_.temporal_layering_mode = 0;\n  svc_params_.scaling_factor_num[0] = 256;\n  svc_params_.scaling_factor_den[0] = 1280;\n  svc_params_.scaling_factor_num[1] = 1280;\n  svc_params_.scaling_factor_den[1] = 1280;\n  cfg_.rc_dropframe_thresh = 10;\n  cfg_.kf_max_dist = 999999;\n  cfg_.kf_min_dist = 0;\n  cfg_.ss_target_bitrate[0] = 300;\n  cfg_.ss_target_bitrate[1] = 1400;\n  cfg_.layer_target_bitrate[0] = 300;\n  cfg_.layer_target_bitrate[1] = 1400;\n  cfg_.rc_target_bitrate = 1700;\n  number_spatial_layers_ = cfg_.ss_number_layers;\n  number_temporal_layers_ = cfg_.ts_number_layers;\n  ResetModel();\n  layer_target_avg_bandwidth_[0] = cfg_.layer_target_bitrate[0] * 1000 / 30;\n  bits_in_buffer_model_[0] =\n      cfg_.layer_target_bitrate[0] * cfg_.rc_buf_initial_sz;\n  layer_target_avg_bandwidth_[1] = cfg_.layer_target_bitrate[1] * 1000 / 30;\n  bits_in_buffer_model_[1] =\n      cfg_.layer_target_bitrate[1] * cfg_.rc_buf_initial_sz;\n  ::libvpx_test::Y4mVideoSource video(\"niklas_1280_720_30.y4m\", 0, 60);\n  top_sl_width_ = 1280;\n  top_sl_height_ = 720;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  CheckLayerRateTargeting(number_spatial_layers_, number_temporal_layers_, 0.78,\n                          1.15);\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              798,
              0
            ],
            [
              844,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DatarateOnePassCbrSvcMultiBR() : DatarateOnePassCbrSvc(GET_PARAM(0)) {\n    memset(&svc_params_, 0, sizeof(svc_params_));\n  }",
          "fn_code_pos": [
            [
              851,
              2
            ],
            [
              853,
              3
            ]
          ],
          "class_code": "e3df14809633e9572aff9d900ae60a34dd7bd64dfa5a818e2acc2383f8f7852d",
          "class_node_pos": [
            [
              847,
              0
            ],
            [
              863,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DatarateOnePassCbrSvcMultiBR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DatarateOnePassCbrSvcMultiBR() {}",
          "fn_code_pos": [
            [
              854,
              2
            ],
            [
              854,
              44
            ]
          ],
          "class_code": "e3df14809633e9572aff9d900ae60a34dd7bd64dfa5a818e2acc2383f8f7852d",
          "class_node_pos": [
            [
              847,
              0
            ],
            [
              863,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    speed_setting_ = GET_PARAM(1);\n    ResetModel();\n  }",
          "fn_code_pos": [
            [
              857,
              2
            ],
            [
              862,
              3
            ]
          ],
          "class_code": "e3df14809633e9572aff9d900ae60a34dd7bd64dfa5a818e2acc2383f8f7852d",
          "class_node_pos": [
            [
              847,
              0
            ],
            [
              863,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(DatarateOnePassCbrSvcMultiBR, OnePassCbrSvc2SL3TL) {\n  SetSvcConfig(2, 3);\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_threads = 1;\n  cfg_.rc_dropframe_thresh = 30;\n  cfg_.kf_max_dist = 9999;\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  top_sl_width_ = 640;\n  top_sl_height_ = 480;\n  const int bitrates[3] = { 200, 400, 600 };\n  // TODO(marpan): Check that effective_datarate for each layer hits the\n  // layer target_bitrate.\n  cfg_.rc_target_bitrate = bitrates[GET_PARAM(2)];\n  ResetModel();\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  CheckLayerRateTargeting(number_spatial_layers_, number_temporal_layers_, 0.75,\n                          1.2);\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              867,
              0
            ],
            [
              895,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DatarateOnePassCbrSvcFrameDropMultiBR()\n      : DatarateOnePassCbrSvc(GET_PARAM(0)) {\n    memset(&svc_params_, 0, sizeof(svc_params_));\n  }",
          "fn_code_pos": [
            [
              902,
              2
            ],
            [
              905,
              3
            ]
          ],
          "class_code": "f556e56a34f52ae4d4f21f4774c029620bfca5a176364ae0e08864a53eba27d5",
          "class_node_pos": [
            [
              898,
              0
            ],
            [
              915,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DatarateOnePassCbrSvcFrameDropMultiBR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DatarateOnePassCbrSvcFrameDropMultiBR() {}",
          "fn_code_pos": [
            [
              906,
              2
            ],
            [
              906,
              53
            ]
          ],
          "class_code": "f556e56a34f52ae4d4f21f4774c029620bfca5a176364ae0e08864a53eba27d5",
          "class_node_pos": [
            [
              898,
              0
            ],
            [
              915,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    speed_setting_ = GET_PARAM(1);\n    ResetModel();\n  }",
          "fn_code_pos": [
            [
              909,
              2
            ],
            [
              914,
              3
            ]
          ],
          "class_code": "f556e56a34f52ae4d4f21f4774c029620bfca5a176364ae0e08864a53eba27d5",
          "class_node_pos": [
            [
              898,
              0
            ],
            [
              915,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(DatarateOnePassCbrSvcFrameDropMultiBR, OnePassCbrSvc2SL3TL4Threads) {\n  SetSvcConfig(2, 3);\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_threads = 4;\n  cfg_.rc_dropframe_thresh = 30;\n  cfg_.kf_max_dist = 9999;\n  ::libvpx_test::Y4mVideoSource video(\"niklas_1280_720_30.y4m\", 0, 60);\n  top_sl_width_ = 1280;\n  top_sl_height_ = 720;\n  layer_framedrop_ = 0;\n  const int bitrates[3] = { 200, 400, 600 };\n  cfg_.rc_target_bitrate = bitrates[GET_PARAM(3)];\n  ResetModel();\n  layer_framedrop_ = GET_PARAM(2);\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  CheckLayerRateTargeting(number_spatial_layers_, number_temporal_layers_, 0.65,\n                          1.45);\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              919,
              0
            ],
            [
              946,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateOnePassCbrSvcFrameDropMultiBR, OnePassCbrSvc3SL3TL4Threads) {\n  SetSvcConfig(3, 3);\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_threads = 4;\n  cfg_.rc_dropframe_thresh = 30;\n  cfg_.kf_max_dist = 9999;\n  ::libvpx_test::Y4mVideoSource video(\"niklas_1280_720_30.y4m\", 0, 60);\n  top_sl_width_ = 1280;\n  top_sl_height_ = 720;\n  layer_framedrop_ = 0;\n  const int bitrates[3] = { 200, 400, 600 };\n  cfg_.rc_target_bitrate = bitrates[GET_PARAM(3)];\n  ResetModel();\n  layer_framedrop_ = GET_PARAM(2);\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  CheckLayerRateTargeting(number_spatial_layers_, number_temporal_layers_, 0.58,\n                          1.2);\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              950,
              0
            ],
            [
              977,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DatarateOnePassCbrSvcInterLayerPredSingleBR()\n      : DatarateOnePassCbrSvc(GET_PARAM(0)) {\n    memset(&svc_params_, 0, sizeof(svc_params_));\n  }",
          "fn_code_pos": [
            [
              984,
              2
            ],
            [
              987,
              3
            ]
          ],
          "class_code": "04a7b0d011300626d50fadbe568111d3bfc48d399cebbb71038d51698183a6f6",
          "class_node_pos": [
            [
              980,
              0
            ],
            [
              998,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DatarateOnePassCbrSvcInterLayerPredSingleBR",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DatarateOnePassCbrSvcInterLayerPredSingleBR() {}",
          "fn_code_pos": [
            [
              988,
              2
            ],
            [
              988,
              59
            ]
          ],
          "class_code": "04a7b0d011300626d50fadbe568111d3bfc48d399cebbb71038d51698183a6f6",
          "class_node_pos": [
            [
              980,
              0
            ],
            [
              998,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    speed_setting_ = GET_PARAM(1);\n    inter_layer_pred_mode_ = GET_PARAM(2);\n    ResetModel();\n  }",
          "fn_code_pos": [
            [
              991,
              2
            ],
            [
              997,
              3
            ]
          ],
          "class_code": "04a7b0d011300626d50fadbe568111d3bfc48d399cebbb71038d51698183a6f6",
          "class_node_pos": [
            [
              980,
              0
            ],
            [
              998,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(DatarateOnePassCbrSvcInterLayerPredSingleBR, OnePassCbrSvc3SL3TL) {\n  // Disable test for inter-layer pred off for now since simulcast_mode fails.\n  if (inter_layer_pred_mode_ == INTER_LAYER_PRED_OFF) return;\n  SetSvcConfig(3, 3);\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_threads = 1;\n  cfg_.temporal_layering_mode = 3;\n  cfg_.rc_dropframe_thresh = 30;\n  cfg_.kf_max_dist = 9999;\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  top_sl_width_ = 640;\n  top_sl_height_ = 480;\n  cfg_.rc_target_bitrate = 800;\n  ResetModel();\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  CheckLayerRateTargeting(number_spatial_layers_, number_temporal_layers_, 0.78,\n                          1.15);\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              1003,
              0
            ],
            [
              1031,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateOnePassCbrSvcSingleBR, OnePassCbrSvc3SL3TLDynamicBitrateChange) {\n  SetSvcConfig(3, 3);\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_threads = 1;\n  cfg_.rc_dropframe_thresh = 30;\n  cfg_.kf_max_dist = 9999;\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  top_sl_width_ = 640;\n  top_sl_height_ = 480;\n  cfg_.rc_target_bitrate = 800;\n  ResetModel();\n  change_bitrate_ = true;\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  CheckLayerRateTargeting(number_spatial_layers_, number_temporal_layers_, 0.78,\n                          1.15);\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              1036,
              0
            ],
            [
              1062,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DatarateOnePassCbrSvcDenoiser() : DatarateOnePassCbrSvc(GET_PARAM(0)) {\n    memset(&svc_params_, 0, sizeof(svc_params_));\n  }",
          "fn_code_pos": [
            [
              1070,
              2
            ],
            [
              1072,
              3
            ]
          ],
          "class_code": "1f1e5f8d7fe37c1e9d83ee0c267c8fd7b3a3670b57d8e3fb9b24b32800399b14",
          "class_node_pos": [
            [
              1066,
              0
            ],
            [
              1082,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DatarateOnePassCbrSvcDenoiser",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DatarateOnePassCbrSvcDenoiser() {}",
          "fn_code_pos": [
            [
              1073,
              2
            ],
            [
              1073,
              45
            ]
          ],
          "class_code": "1f1e5f8d7fe37c1e9d83ee0c267c8fd7b3a3670b57d8e3fb9b24b32800399b14",
          "class_node_pos": [
            [
              1066,
              0
            ],
            [
              1082,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    speed_setting_ = GET_PARAM(1);\n    ResetModel();\n  }",
          "fn_code_pos": [
            [
              1076,
              2
            ],
            [
              1081,
              3
            ]
          ],
          "class_code": "1f1e5f8d7fe37c1e9d83ee0c267c8fd7b3a3670b57d8e3fb9b24b32800399b14",
          "class_node_pos": [
            [
              1066,
              0
            ],
            [
              1082,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(DatarateOnePassCbrSvcDenoiser, OnePassCbrSvc2SL3TLDenoiserOn) {\n  SetSvcConfig(2, 3);\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_threads = 2;\n  cfg_.rc_dropframe_thresh = 30;\n  cfg_.kf_max_dist = 9999;\n  number_spatial_layers_ = cfg_.ss_number_layers;\n  number_temporal_layers_ = cfg_.ts_number_layers;\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  top_sl_width_ = 640;\n  top_sl_height_ = 480;\n  const int bitrates[3] = { 600, 800, 1000 };\n  // TODO(marpan): Check that effective_datarate for each layer hits the\n  // layer target_bitrate.\n  // For SVC, noise_sen = 1 means denoising only the top spatial layer\n  // noise_sen = 2 means denoising the two top spatial layers.\n  cfg_.rc_target_bitrate = bitrates[GET_PARAM(3)];\n  ResetModel();\n  denoiser_on_ = GET_PARAM(2);\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  CheckLayerRateTargeting(number_spatial_layers_, number_temporal_layers_, 0.78,\n                          1.15);\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              1086,
              0
            ],
            [
              1119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DatarateOnePassCbrSvcSmallKF() : DatarateOnePassCbrSvc(GET_PARAM(0)) {\n    memset(&svc_params_, 0, sizeof(svc_params_));\n  }",
          "fn_code_pos": [
            [
              1127,
              2
            ],
            [
              1129,
              3
            ]
          ],
          "class_code": "4e25056d534d934d87afa9d66c0a0f0790a21be0faa27d1ba855f3fa0448020e",
          "class_node_pos": [
            [
              1123,
              0
            ],
            [
              1139,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DatarateOnePassCbrSvcSmallKF",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DatarateOnePassCbrSvcSmallKF() {}",
          "fn_code_pos": [
            [
              1130,
              2
            ],
            [
              1130,
              44
            ]
          ],
          "class_code": "4e25056d534d934d87afa9d66c0a0f0790a21be0faa27d1ba855f3fa0448020e",
          "class_node_pos": [
            [
              1123,
              0
            ],
            [
              1139,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    speed_setting_ = GET_PARAM(1);\n    ResetModel();\n  }",
          "fn_code_pos": [
            [
              1133,
              2
            ],
            [
              1138,
              3
            ]
          ],
          "class_code": "4e25056d534d934d87afa9d66c0a0f0790a21be0faa27d1ba855f3fa0448020e",
          "class_node_pos": [
            [
              1123,
              0
            ],
            [
              1139,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(DatarateOnePassCbrSvcSmallKF, OnePassCbrSvc3SL3TLSmallKf) {\n  SetSvcConfig(3, 3);\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_threads = 1;\n  cfg_.rc_dropframe_thresh = 10;\n  cfg_.rc_target_bitrate = 800;\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  top_sl_width_ = 640;\n  top_sl_height_ = 480;\n  // For this 3 temporal layer case, pattern repeats every 4 frames, so choose\n  // 4 key neighboring key frame periods (so key frame will land on 0-2-1-2).\n  const int kf_dist = GET_PARAM(2);\n  cfg_.kf_max_dist = kf_dist;\n  key_frame_spacing_ = kf_dist;\n  ResetModel();\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  // TODO(jianj): webm:1554\n  CheckLayerRateTargeting(number_spatial_layers_, number_temporal_layers_, 0.70,\n                          1.15);\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              1143,
              0
            ],
            [
              1173,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateOnePassCbrSvcSmallKF, OnePassCbrSvc2SL3TLSmallKf) {\n  SetSvcConfig(2, 3);\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_threads = 1;\n  cfg_.rc_dropframe_thresh = 10;\n  cfg_.rc_target_bitrate = 400;\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  top_sl_width_ = 640;\n  top_sl_height_ = 480;\n  // For this 3 temporal layer case, pattern repeats every 4 frames, so choose\n  // 4 key neighboring key frame periods (so key frame will land on 0-2-1-2).\n  const int kf_dist = GET_PARAM(2) + 32;\n  cfg_.kf_max_dist = kf_dist;\n  key_frame_spacing_ = kf_dist;\n  ResetModel();\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  CheckLayerRateTargeting(number_spatial_layers_, number_temporal_layers_, 0.78,\n                          1.15);\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              1177,
              0
            ],
            [
              1206,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateOnePassCbrSvcSingleBR, OnePassCbrSvc3SL3TLSyncFrames) {\n  SetSvcConfig(3, 3);\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_threads = 1;\n  cfg_.kf_max_dist = 9999;\n  cfg_.rc_dropframe_thresh = 10;\n  cfg_.rc_target_bitrate = 400;\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  top_sl_width_ = 640;\n  top_sl_height_ = 480;\n  ResetModel();\n  insert_layer_sync_ = 1;\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  CheckLayerRateTargeting(number_spatial_layers_, number_temporal_layers_, 0.78,\n                          1.15);\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              1212,
              0
            ],
            [
              1238,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateOnePassCbrSvcSingleBR, OnePassCbrSvc3SL1TLSyncWithIntraOnly) {\n  SetSvcConfig(3, 1);\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 63;\n  cfg_.g_threads = 4;\n  cfg_.rc_dropframe_thresh = 30;\n  cfg_.kf_max_dist = 9999;\n  cfg_.rc_target_bitrate = 400;\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  top_sl_width_ = 640;\n  top_sl_height_ = 480;\n  ResetModel();\n  insert_layer_sync_ = 1;\n  // Use intra_only frame for sync on base layer.\n  force_intra_only_frame_ = 1;\n  AssignLayerBitrates();\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  CheckLayerRateTargeting(number_spatial_layers_, number_temporal_layers_, 0.73,\n                          1.2);\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              1243,
              0
            ],
            [
              1271,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DatarateOnePassCbrSvcSingleBR, OnePassCbrSvc2QL1TLScreen) {\n  cfg_.rc_buf_initial_sz = 500;\n  cfg_.rc_buf_optimal_sz = 500;\n  cfg_.rc_buf_sz = 1000;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 56;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_lag_in_frames = 0;\n  cfg_.ss_number_layers = 2;\n  cfg_.ts_number_layers = 1;\n  cfg_.ts_rate_decimator[0] = 1;\n  cfg_.temporal_layering_mode = 0;\n  cfg_.g_error_resilient = 1;\n  cfg_.g_threads = 2;\n  svc_params_.scaling_factor_num[0] = 1;\n  svc_params_.scaling_factor_den[0] = 1;\n  svc_params_.scaling_factor_num[1] = 1;\n  svc_params_.scaling_factor_den[1] = 1;\n  cfg_.rc_dropframe_thresh = 30;\n  cfg_.kf_max_dist = 9999;\n  number_spatial_layers_ = cfg_.ss_number_layers;\n  number_temporal_layers_ = cfg_.ts_number_layers;\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  top_sl_width_ = 640;\n  top_sl_height_ = 480;\n  ResetModel();\n  tune_content_ = 1;\n  // Set the layer bitrates, for 2 spatial layers, 1 temporal.\n  cfg_.rc_target_bitrate = 400;\n  cfg_.ss_target_bitrate[0] = 100;\n  cfg_.ss_target_bitrate[1] = 300;\n  cfg_.layer_target_bitrate[0] = 100;\n  cfg_.layer_target_bitrate[1] = 300;\n  for (int sl = 0; sl < 2; ++sl) {\n    float layer_framerate = 30.0;\n    layer_target_avg_bandwidth_[sl] = static_cast<int>(\n        cfg_.layer_target_bitrate[sl] * 1000.0 / layer_framerate);\n    bits_in_buffer_model_[sl] =\n        cfg_.layer_target_bitrate[sl] * cfg_.rc_buf_initial_sz;\n  }\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  CheckLayerRateTargeting(number_spatial_layers_, number_temporal_layers_, 0.73,\n                          1.25);\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              1275,
              0
            ],
            [
              1324,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DatarateOnePassCbrSvcPostencodeDrop() : DatarateOnePassCbrSvc(GET_PARAM(0)) {\n    memset(&svc_params_, 0, sizeof(svc_params_));\n  }",
          "fn_code_pos": [
            [
              1331,
              2
            ],
            [
              1333,
              3
            ]
          ],
          "class_code": "0f18b04e1e6a67201414cf5519168b0aab1dcb18334af38be163fa5e00880774",
          "class_node_pos": [
            [
              1327,
              0
            ],
            [
              1343,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DatarateOnePassCbrSvcPostencodeDrop",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DatarateOnePassCbrSvcPostencodeDrop() {}",
          "fn_code_pos": [
            [
              1334,
              2
            ],
            [
              1334,
              51
            ]
          ],
          "class_code": "0f18b04e1e6a67201414cf5519168b0aab1dcb18334af38be163fa5e00880774",
          "class_node_pos": [
            [
              1327,
              0
            ],
            [
              1343,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    speed_setting_ = GET_PARAM(1);\n    ResetModel();\n  }",
          "fn_code_pos": [
            [
              1337,
              2
            ],
            [
              1342,
              3
            ]
          ],
          "class_code": "0f18b04e1e6a67201414cf5519168b0aab1dcb18334af38be163fa5e00880774",
          "class_node_pos": [
            [
              1327,
              0
            ],
            [
              1343,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TEST_P(DatarateOnePassCbrSvcPostencodeDrop, OnePassCbrSvc2QL1TLScreen) {\n  cfg_.rc_buf_initial_sz = 200;\n  cfg_.rc_buf_optimal_sz = 200;\n  cfg_.rc_buf_sz = 400;\n  cfg_.rc_min_quantizer = 0;\n  cfg_.rc_max_quantizer = 52;\n  cfg_.rc_end_usage = VPX_CBR;\n  cfg_.g_lag_in_frames = 0;\n  cfg_.ss_number_layers = 2;\n  cfg_.ts_number_layers = 1;\n  cfg_.ts_rate_decimator[0] = 1;\n  cfg_.temporal_layering_mode = 0;\n  cfg_.g_error_resilient = 1;\n  cfg_.g_threads = 2;\n  svc_params_.scaling_factor_num[0] = 1;\n  svc_params_.scaling_factor_den[0] = 1;\n  svc_params_.scaling_factor_num[1] = 1;\n  svc_params_.scaling_factor_den[1] = 1;\n  cfg_.rc_dropframe_thresh = 30;\n  cfg_.kf_max_dist = 9999;\n  number_spatial_layers_ = cfg_.ss_number_layers;\n  number_temporal_layers_ = cfg_.ts_number_layers;\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 300);\n  top_sl_width_ = 352;\n  top_sl_height_ = 288;\n  ResetModel();\n  base_speed_setting_ = speed_setting_;\n  tune_content_ = 1;\n  use_post_encode_drop_ = 1;\n  // Set the layer bitrates, for 2 spatial layers, 1 temporal.\n  cfg_.rc_target_bitrate = 400;\n  cfg_.ss_target_bitrate[0] = 100;\n  cfg_.ss_target_bitrate[1] = 300;\n  cfg_.layer_target_bitrate[0] = 100;\n  cfg_.layer_target_bitrate[1] = 300;\n  for (int sl = 0; sl < 2; ++sl) {\n    float layer_framerate = 30.0;\n    layer_target_avg_bandwidth_[sl] = static_cast<int>(\n        cfg_.layer_target_bitrate[sl] * 1000.0 / layer_framerate);\n    bits_in_buffer_model_[sl] =\n        cfg_.layer_target_bitrate[sl] * cfg_.rc_buf_initial_sz;\n  }\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  CheckLayerRateTargeting(number_spatial_layers_, number_temporal_layers_, 0.73,\n                          1.25);\n#if CONFIG_VP9_DECODER\n  // The non-reference frames are expected to be mismatched frames as the\n  // encoder will avoid loopfilter on these frames.\n  EXPECT_EQ(GetNonRefFrames(), GetMismatchFrames());\n#endif\n}",
          "fn_code_pos": [
            [
              1347,
              0
            ],
            [
              1398,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "b96b8206828665d92d8f9b8aae8446b8a5d62e8d87055aa8394aa6b2ee5cff0b": {
          "class_code": "class DatarateOnePassCbrSvc : public OnePassCbrSvc {\n public:\n  explicit DatarateOnePassCbrSvc(const ::libvpx_test::CodecFactory *codec)\n      : OnePassCbrSvc(codec) {\n    inter_layer_pred_mode_ = 0;\n  }\n\n protected:\n  virtual ~DatarateOnePassCbrSvc() {}\n\n  virtual void ResetModel() {\n    last_pts_ = 0;\n    duration_ = 0.0;\n    mismatch_psnr_ = 0.0;\n    mismatch_nframes_ = 0;\n    denoiser_on_ = 0;\n    tune_content_ = 0;\n    base_speed_setting_ = 5;\n    spatial_layer_id_ = 0;\n    temporal_layer_id_ = 0;\n    update_pattern_ = 0;\n    memset(bits_in_buffer_model_, 0, sizeof(bits_in_buffer_model_));\n    memset(bits_total_, 0, sizeof(bits_total_));\n    memset(layer_target_avg_bandwidth_, 0, sizeof(layer_target_avg_bandwidth_));\n    dynamic_drop_layer_ = false;\n    change_bitrate_ = false;\n    last_pts_ref_ = 0;\n    middle_bitrate_ = 0;\n    top_bitrate_ = 0;\n    superframe_count_ = -1;\n    key_frame_spacing_ = 9999;\n    num_nonref_frames_ = 0;\n    layer_framedrop_ = 0;\n    force_key_ = 0;\n    force_key_test_ = 0;\n    insert_layer_sync_ = 0;\n    layer_sync_on_base_ = 0;\n    force_intra_only_frame_ = 0;\n    superframe_has_intra_only_ = 0;\n    use_post_encode_drop_ = 0;\n    denoiser_off_on_ = false;\n    denoiser_enable_layers_ = false;\n  }\n  virtual void BeginPassHook(unsigned int /*pass*/) {}\n\n  // Example pattern for spatial layers and 2 temporal layers used in the\n  // bypass/flexible mode. The pattern corresponds to the pattern\n  // VP9E_TEMPORAL_LAYERING_MODE_0101 (temporal_layering_mode == 2) used in\n  // non-flexible mode, except that we disable inter-layer prediction.\n  void set_frame_flags_bypass_mode(\n      int tl, int num_spatial_layers, int is_key_frame,\n      vpx_svc_ref_frame_config_t *ref_frame_config) {\n    for (int sl = 0; sl < num_spatial_layers; ++sl)\n      ref_frame_config->update_buffer_slot[sl] = 0;\n\n    for (int sl = 0; sl < num_spatial_layers; ++sl) {\n      if (tl == 0) {\n        ref_frame_config->lst_fb_idx[sl] = sl;\n        if (sl) {\n          if (is_key_frame) {\n            ref_frame_config->lst_fb_idx[sl] = sl - 1;\n            ref_frame_config->gld_fb_idx[sl] = sl;\n          } else {\n            ref_frame_config->gld_fb_idx[sl] = sl - 1;\n          }\n        } else {\n          ref_frame_config->gld_fb_idx[sl] = 0;\n        }\n        ref_frame_config->alt_fb_idx[sl] = 0;\n      } else if (tl == 1) {\n        ref_frame_config->lst_fb_idx[sl] = sl;\n        ref_frame_config->gld_fb_idx[sl] =\n            VPXMIN(REF_FRAMES - 1, num_spatial_layers + sl - 1);\n        ref_frame_config->alt_fb_idx[sl] =\n            VPXMIN(REF_FRAMES - 1, num_spatial_layers + sl);\n      }\n      if (!tl) {\n        if (!sl) {\n          ref_frame_config->reference_last[sl] = 1;\n          ref_frame_config->reference_golden[sl] = 0;\n          ref_frame_config->reference_alt_ref[sl] = 0;\n          ref_frame_config->update_buffer_slot[sl] |=\n              1 << ref_frame_config->lst_fb_idx[sl];\n        } else {\n          if (is_key_frame) {\n            ref_frame_config->reference_last[sl] = 1;\n            ref_frame_config->reference_golden[sl] = 0;\n            ref_frame_config->reference_alt_ref[sl] = 0;\n            ref_frame_config->update_buffer_slot[sl] |=\n                1 << ref_frame_config->gld_fb_idx[sl];\n          } else {\n            ref_frame_config->reference_last[sl] = 1;\n            ref_frame_config->reference_golden[sl] = 0;\n            ref_frame_config->reference_alt_ref[sl] = 0;\n            ref_frame_config->update_buffer_slot[sl] |=\n                1 << ref_frame_config->lst_fb_idx[sl];\n          }\n        }\n      } else if (tl == 1) {\n        if (!sl) {\n          ref_frame_config->reference_last[sl] = 1;\n          ref_frame_config->reference_golden[sl] = 0;\n          ref_frame_config->reference_alt_ref[sl] = 0;\n          ref_frame_config->update_buffer_slot[sl] |=\n              1 << ref_frame_config->alt_fb_idx[sl];\n        } else {\n          ref_frame_config->reference_last[sl] = 1;\n          ref_frame_config->reference_golden[sl] = 0;\n          ref_frame_config->reference_alt_ref[sl] = 0;\n          ref_frame_config->update_buffer_slot[sl] |=\n              1 << ref_frame_config->alt_fb_idx[sl];\n        }\n      }\n    }\n  }\n\n  void CheckLayerRateTargeting(int num_spatial_layers, int num_temporal_layers,\n                               double thresh_overshoot,\n                               double thresh_undershoot) const {\n    for (int sl = 0; sl < num_spatial_layers; ++sl)\n      for (int tl = 0; tl < num_temporal_layers; ++tl) {\n        const int layer = sl * num_temporal_layers + tl;\n        ASSERT_GE(cfg_.layer_target_bitrate[layer],\n                  file_datarate_[layer] * thresh_overshoot)\n            << \" The datarate for the file exceeds the target by too much!\";\n        ASSERT_LE(cfg_.layer_target_bitrate[layer],\n                  file_datarate_[layer] * thresh_undershoot)\n            << \" The datarate for the file is lower than the target by too \"\n               \"much!\";\n      }\n  }\n\n  virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                  ::libvpx_test::Encoder *encoder) {\n    PreEncodeFrameHookSetup(video, encoder);\n\n    if (video->frame() == 0) {\n      if (force_intra_only_frame_) {\n        // Decoder sets the color_space for Intra-only frames\n        // to BT_601 (see line 1810 in vp9_decodeframe.c).\n        // So set it here in these tess to avoid encoder-decoder\n        // mismatch check on color space setting.\n        encoder->Control(VP9E_SET_COLOR_SPACE, VPX_CS_BT_601);\n      }\n      encoder->Control(VP9E_SET_NOISE_SENSITIVITY, denoiser_on_);\n      encoder->Control(VP9E_SET_TUNE_CONTENT, tune_content_);\n      encoder->Control(VP9E_SET_SVC_INTER_LAYER_PRED, inter_layer_pred_mode_);\n\n      if (layer_framedrop_) {\n        vpx_svc_frame_drop_t svc_drop_frame;\n        svc_drop_frame.framedrop_mode = LAYER_DROP;\n        for (int i = 0; i < number_spatial_layers_; i++)\n          svc_drop_frame.framedrop_thresh[i] = 30;\n        svc_drop_frame.max_consec_drop = 30;\n        encoder->Control(VP9E_SET_SVC_FRAME_DROP_LAYER, &svc_drop_frame);\n      }\n\n      if (use_post_encode_drop_) {\n        encoder->Control(VP9E_SET_POSTENCODE_DROP, use_post_encode_drop_);\n      }\n    }\n\n    if (denoiser_off_on_) {\n      encoder->Control(VP9E_SET_AQ_MODE, 3);\n      // Set inter_layer_pred to INTER_LAYER_PRED_OFF_NONKEY (K-SVC).\n      encoder->Control(VP9E_SET_SVC_INTER_LAYER_PRED, 2);\n      if (!denoiser_enable_layers_) {\n        if (video->frame() == 0)\n          encoder->Control(VP9E_SET_NOISE_SENSITIVITY, 0);\n        else if (video->frame() == 100)\n          encoder->Control(VP9E_SET_NOISE_SENSITIVITY, 1);\n      } else {\n        // Cumulative bitrates for top spatial layers, for\n        // 3 temporal layers.\n        if (video->frame() == 0) {\n          encoder->Control(VP9E_SET_NOISE_SENSITIVITY, 0);\n          // Change layer bitrates to set top spatial layer to 0.\n          // This is for 3 spatial 3 temporal layers.\n          // This will trigger skip encoding/dropping of top spatial layer.\n          cfg_.rc_target_bitrate -= cfg_.layer_target_bitrate[8];\n          for (int i = 0; i < 3; i++)\n            bitrate_sl3_[i] = cfg_.layer_target_bitrate[i + 6];\n          cfg_.layer_target_bitrate[6] = 0;\n          cfg_.layer_target_bitrate[7] = 0;\n          cfg_.layer_target_bitrate[8] = 0;\n          encoder->Config(&cfg_);\n        } else if (video->frame() == 100) {\n          // Change layer bitrates to non-zero on top spatial layer.\n          // This will trigger skip encoding of top spatial layer\n          // on key frame (period = 100).\n          for (int i = 0; i < 3; i++)\n            cfg_.layer_target_bitrate[i + 6] = bitrate_sl3_[i];\n          cfg_.rc_target_bitrate += cfg_.layer_target_bitrate[8];\n          encoder->Config(&cfg_);\n        } else if (video->frame() == 120) {\n          // Enable denoiser and top spatial layer after key frame (period is\n          // 100).\n          encoder->Control(VP9E_SET_NOISE_SENSITIVITY, 1);\n        }\n      }\n    }\n\n    if (update_pattern_ && video->frame() >= 100) {\n      vpx_svc_layer_id_t layer_id;\n      if (video->frame() == 100) {\n        cfg_.temporal_layering_mode = VP9E_TEMPORAL_LAYERING_MODE_BYPASS;\n        encoder->Config(&cfg_);\n      }\n      // Set layer id since the pattern changed.\n      layer_id.spatial_layer_id = 0;\n      layer_id.temporal_layer_id = (video->frame() % 2 != 0);\n      temporal_layer_id_ = layer_id.temporal_layer_id;\n      for (int i = 0; i < number_spatial_layers_; i++)\n        layer_id.temporal_layer_id_per_spatial[i] = temporal_layer_id_;\n      encoder->Control(VP9E_SET_SVC_LAYER_ID, &layer_id);\n      set_frame_flags_bypass_mode(layer_id.temporal_layer_id,\n                                  number_spatial_layers_, 0, &ref_frame_config);\n      encoder->Control(VP9E_SET_SVC_REF_FRAME_CONFIG, &ref_frame_config);\n    }\n\n    if (change_bitrate_ && video->frame() == 200) {\n      duration_ = (last_pts_ + 1) * timebase_;\n      for (int sl = 0; sl < number_spatial_layers_; ++sl) {\n        for (int tl = 0; tl < number_temporal_layers_; ++tl) {\n          const int layer = sl * number_temporal_layers_ + tl;\n          const double file_size_in_kb = bits_total_[layer] / 1000.;\n          file_datarate_[layer] = file_size_in_kb / duration_;\n        }\n      }\n\n      CheckLayerRateTargeting(number_spatial_layers_, number_temporal_layers_,\n                              0.78, 1.15);\n\n      memset(file_datarate_, 0, sizeof(file_datarate_));\n      memset(bits_total_, 0, sizeof(bits_total_));\n      int64_t bits_in_buffer_model_tmp[VPX_MAX_LAYERS];\n      last_pts_ref_ = last_pts_;\n      // Set new target bitarate.\n      cfg_.rc_target_bitrate = cfg_.rc_target_bitrate >> 1;\n      // Buffer level should not reset on dynamic bitrate change.\n      memcpy(bits_in_buffer_model_tmp, bits_in_buffer_model_,\n             sizeof(bits_in_buffer_model_));\n      AssignLayerBitrates();\n      memcpy(bits_in_buffer_model_, bits_in_buffer_model_tmp,\n             sizeof(bits_in_buffer_model_));\n\n      // Change config to update encoder with new bitrate configuration.\n      encoder->Config(&cfg_);\n    }\n\n    if (dynamic_drop_layer_) {\n      // TODO(jian): Disable AQ Mode for this test for now.\n      encoder->Control(VP9E_SET_AQ_MODE, 0);\n      if (video->frame() == 0) {\n        // Change layer bitrates to set top layers to 0. This will trigger skip\n        // encoding/dropping of top two spatial layers.\n        cfg_.rc_target_bitrate -=\n            (cfg_.layer_target_bitrate[1] + cfg_.layer_target_bitrate[2]);\n        middle_bitrate_ = cfg_.layer_target_bitrate[1];\n        top_bitrate_ = cfg_.layer_target_bitrate[2];\n        cfg_.layer_target_bitrate[1] = 0;\n        cfg_.layer_target_bitrate[2] = 0;\n        encoder->Config(&cfg_);\n      } else if (video->frame() == 50) {\n        // Change layer bitrates to non-zero on two top spatial layers.\n        // This will trigger skip encoding of top two spatial layers.\n        cfg_.layer_target_bitrate[1] = middle_bitrate_;\n        cfg_.layer_target_bitrate[2] = top_bitrate_;\n        cfg_.rc_target_bitrate +=\n            cfg_.layer_target_bitrate[2] + cfg_.layer_target_bitrate[1];\n        encoder->Config(&cfg_);\n      } else if (video->frame() == 100) {\n        // Change layer bitrates to set top layers to 0. This will trigger skip\n        // encoding/dropping of top two spatial layers.\n        cfg_.rc_target_bitrate -=\n            (cfg_.layer_target_bitrate[1] + cfg_.layer_target_bitrate[2]);\n        middle_bitrate_ = cfg_.layer_target_bitrate[1];\n        top_bitrate_ = cfg_.layer_target_bitrate[2];\n        cfg_.layer_target_bitrate[1] = 0;\n        cfg_.layer_target_bitrate[2] = 0;\n        encoder->Config(&cfg_);\n      } else if (video->frame() == 150) {\n        // Change layer bitrate on second layer to non-zero to start\n        // encoding it again.\n        cfg_.layer_target_bitrate[1] = middle_bitrate_;\n        cfg_.rc_target_bitrate += cfg_.layer_target_bitrate[1];\n        encoder->Config(&cfg_);\n      } else if (video->frame() == 200) {\n        // Change layer bitrate on top layer to non-zero to start\n        // encoding it again.\n        cfg_.layer_target_bitrate[2] = top_bitrate_;\n        cfg_.rc_target_bitrate += cfg_.layer_target_bitrate[2];\n        encoder->Config(&cfg_);\n      }\n    }\n\n    if (force_key_test_ && force_key_) frame_flags_ = VPX_EFLAG_FORCE_KF;\n\n    if (insert_layer_sync_) {\n      vpx_svc_spatial_layer_sync_t svc_layer_sync;\n      svc_layer_sync.base_layer_intra_only = 0;\n      for (int i = 0; i < number_spatial_layers_; i++)\n        svc_layer_sync.spatial_layer_sync[i] = 0;\n      if (force_intra_only_frame_) {\n        superframe_has_intra_only_ = 0;\n        if (video->frame() == 0) {\n          svc_layer_sync.base_layer_intra_only = 1;\n          svc_layer_sync.spatial_layer_sync[0] = 1;\n          encoder->Control(VP9E_SET_SVC_SPATIAL_LAYER_SYNC, &svc_layer_sync);\n          superframe_has_intra_only_ = 1;\n        } else if (video->frame() == 100) {\n          svc_layer_sync.base_layer_intra_only = 1;\n          svc_layer_sync.spatial_layer_sync[0] = 1;\n          encoder->Control(VP9E_SET_SVC_SPATIAL_LAYER_SYNC, &svc_layer_sync);\n          superframe_has_intra_only_ = 1;\n        }\n      } else {\n        layer_sync_on_base_ = 0;\n        if (video->frame() == 150) {\n          svc_layer_sync.spatial_layer_sync[1] = 1;\n          encoder->Control(VP9E_SET_SVC_SPATIAL_LAYER_SYNC, &svc_layer_sync);\n        } else if (video->frame() == 240) {\n          svc_layer_sync.spatial_layer_sync[2] = 1;\n          encoder->Control(VP9E_SET_SVC_SPATIAL_LAYER_SYNC, &svc_layer_sync);\n        } else if (video->frame() == 320) {\n          svc_layer_sync.spatial_layer_sync[0] = 1;\n          layer_sync_on_base_ = 1;\n          encoder->Control(VP9E_SET_SVC_SPATIAL_LAYER_SYNC, &svc_layer_sync);\n        }\n      }\n    }\n\n    const vpx_rational_t tb = video->timebase();\n    timebase_ = static_cast<double>(tb.num) / tb.den;\n    duration_ = 0;\n  }\n\n  vpx_codec_err_t parse_superframe_index(const uint8_t *data, size_t data_sz,\n                                         uint32_t sizes[8], int *count) {\n    uint8_t marker;\n    marker = *(data + data_sz - 1);\n    *count = 0;\n    if ((marker & 0xe0) == 0xc0) {\n      const uint32_t frames = (marker & 0x7) + 1;\n      const uint32_t mag = ((marker >> 3) & 0x3) + 1;\n      const size_t index_sz = 2 + mag * frames;\n      // This chunk is marked as having a superframe index but doesn't have\n      // enough data for it, thus it's an invalid superframe index.\n      if (data_sz < index_sz) return VPX_CODEC_CORRUPT_FRAME;\n      {\n        const uint8_t marker2 = *(data + data_sz - index_sz);\n        // This chunk is marked as having a superframe index but doesn't have\n        // the matching marker byte at the front of the index therefore it's an\n        // invalid chunk.\n        if (marker != marker2) return VPX_CODEC_CORRUPT_FRAME;\n      }\n      {\n        uint32_t i, j;\n        const uint8_t *x = &data[data_sz - index_sz + 1];\n        for (i = 0; i < frames; ++i) {\n          uint32_t this_sz = 0;\n\n          for (j = 0; j < mag; ++j) this_sz |= (*x++) << (j * 8);\n          sizes[i] = this_sz;\n        }\n        *count = frames;\n      }\n    }\n    return VPX_CODEC_OK;\n  }\n\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    uint32_t sizes[8] = { 0 };\n    uint32_t sizes_parsed[8] = { 0 };\n    int count = 0;\n    int num_layers_encoded = 0;\n    last_pts_ = pkt->data.frame.pts;\n    const bool key_frame =\n        (pkt->data.frame.flags & VPX_FRAME_IS_KEY) ? true : false;\n    if (key_frame) {\n      // For test that inserts layer sync frames: requesting a layer_sync on\n      // the base layer must force key frame. So if any key frame occurs after\n      // first superframe it must due to layer sync on base spatial layer.\n      if (superframe_count_ > 0 && insert_layer_sync_ &&\n          !force_intra_only_frame_) {\n        ASSERT_EQ(layer_sync_on_base_, 1);\n      }\n      temporal_layer_id_ = 0;\n      superframe_count_ = 0;\n    }\n    parse_superframe_index(static_cast<const uint8_t *>(pkt->data.frame.buf),\n                           pkt->data.frame.sz, sizes_parsed, &count);\n    // Count may be less than number of spatial layers because of frame drops.\n    for (int sl = 0; sl < number_spatial_layers_; ++sl) {\n      if (pkt->data.frame.spatial_layer_encoded[sl]) {\n        sizes[sl] = sizes_parsed[num_layers_encoded];\n        num_layers_encoded++;\n      }\n    }\n    // For superframe with Intra-only count will be +1 larger\n    // because of no-show frame.\n    if (force_intra_only_frame_ && superframe_has_intra_only_)\n      ASSERT_EQ(count, num_layers_encoded + 1);\n    else\n      ASSERT_EQ(count, num_layers_encoded);\n\n    // In the constrained frame drop mode, if a given spatial is dropped all\n    // upper layers must be dropped too.\n    if (!layer_framedrop_) {\n      int num_layers_dropped = 0;\n      for (int sl = 0; sl < number_spatial_layers_; ++sl) {\n        if (!pkt->data.frame.spatial_layer_encoded[sl]) {\n          // Check that all upper layers are dropped.\n          num_layers_dropped++;\n          for (int sl2 = sl + 1; sl2 < number_spatial_layers_; ++sl2)\n            ASSERT_EQ(pkt->data.frame.spatial_layer_encoded[sl2], 0);\n        }\n      }\n      if (num_layers_dropped == number_spatial_layers_ - 1)\n        force_key_ = 1;\n      else\n        force_key_ = 0;\n    }\n    // Keep track of number of non-reference frames, needed for mismatch check.\n    // Non-reference frames are top spatial and temporal layer frames,\n    // for TL > 0.\n    if (temporal_layer_id_ == number_temporal_layers_ - 1 &&\n        temporal_layer_id_ > 0 &&\n        pkt->data.frame.spatial_layer_encoded[number_spatial_layers_ - 1])\n      num_nonref_frames_++;\n    for (int sl = 0; sl < number_spatial_layers_; ++sl) {\n      sizes[sl] = sizes[sl] << 3;\n      // Update the total encoded bits per layer.\n      // For temporal layers, update the cumulative encoded bits per layer.\n      for (int tl = temporal_layer_id_; tl < number_temporal_layers_; ++tl) {\n        const int layer = sl * number_temporal_layers_ + tl;\n        bits_total_[layer] += static_cast<int64_t>(sizes[sl]);\n        // Update the per-layer buffer level with the encoded frame size.\n        bits_in_buffer_model_[layer] -= static_cast<int64_t>(sizes[sl]);\n        // There should be no buffer underrun, except on the base\n        // temporal layer, since there may be key frames there.\n        // Fo short key frame spacing, buffer can underrun on individual frames.\n        if (!key_frame && tl > 0 && key_frame_spacing_ < 100) {\n          ASSERT_GE(bits_in_buffer_model_[layer], 0)\n              << \"Buffer Underrun at frame \" << pkt->data.frame.pts;\n        }\n      }\n\n      ASSERT_EQ(pkt->data.frame.width[sl],\n                top_sl_width_ * svc_params_.scaling_factor_num[sl] /\n                    svc_params_.scaling_factor_den[sl]);\n\n      ASSERT_EQ(pkt->data.frame.height[sl],\n                top_sl_height_ * svc_params_.scaling_factor_num[sl] /\n                    svc_params_.scaling_factor_den[sl]);\n    }\n  }\n\n  virtual void EndPassHook(void) {\n    if (change_bitrate_) last_pts_ = last_pts_ - last_pts_ref_;\n    duration_ = (last_pts_ + 1) * timebase_;\n    for (int sl = 0; sl < number_spatial_layers_; ++sl) {\n      for (int tl = 0; tl < number_temporal_layers_; ++tl) {\n        const int layer = sl * number_temporal_layers_ + tl;\n        const double file_size_in_kb = bits_total_[layer] / 1000.;\n        file_datarate_[layer] = file_size_in_kb / duration_;\n      }\n    }\n  }\n\n  virtual void MismatchHook(const vpx_image_t *img1, const vpx_image_t *img2) {\n    double mismatch_psnr = compute_psnr(img1, img2);\n    mismatch_psnr_ += mismatch_psnr;\n    ++mismatch_nframes_;\n  }\n\n  unsigned int GetMismatchFrames() { return mismatch_nframes_; }\n  unsigned int GetNonRefFrames() { return num_nonref_frames_; }\n\n  vpx_codec_pts_t last_pts_;\n  double timebase_;\n  int64_t bits_total_[VPX_MAX_LAYERS];\n  double duration_;\n  double file_datarate_[VPX_MAX_LAYERS];\n  size_t bits_in_last_frame_;\n  double mismatch_psnr_;\n  int denoiser_on_;\n  int tune_content_;\n  int spatial_layer_id_;\n  bool dynamic_drop_layer_;\n  unsigned int top_sl_width_;\n  unsigned int top_sl_height_;\n  vpx_svc_ref_frame_config_t ref_frame_config;\n  int update_pattern_;\n  bool change_bitrate_;\n  vpx_codec_pts_t last_pts_ref_;\n  int middle_bitrate_;\n  int top_bitrate_;\n  int key_frame_spacing_;\n  int layer_framedrop_;\n  int force_key_;\n  int force_key_test_;\n  int inter_layer_pred_mode_;\n  int insert_layer_sync_;\n  int layer_sync_on_base_;\n  int force_intra_only_frame_;\n  int superframe_has_intra_only_;\n  int use_post_encode_drop_;\n  int bitrate_sl3_[3];\n  // Denoiser switched on the fly.\n  bool denoiser_off_on_;\n  // Top layer enabled on the fly.\n  bool denoiser_enable_layers_;\n\n private:\n  virtual void SetConfig(const int num_temporal_layer) {\n    cfg_.rc_end_usage = VPX_CBR;\n    cfg_.g_lag_in_frames = 0;\n    cfg_.g_error_resilient = 1;\n    if (num_temporal_layer == 3) {\n      cfg_.ts_rate_decimator[0] = 4;\n      cfg_.ts_rate_decimator[1] = 2;\n      cfg_.ts_rate_decimator[2] = 1;\n      cfg_.temporal_layering_mode = 3;\n    } else if (num_temporal_layer == 2) {\n      cfg_.ts_rate_decimator[0] = 2;\n      cfg_.ts_rate_decimator[1] = 1;\n      cfg_.temporal_layering_mode = 2;\n    } else if (num_temporal_layer == 1) {\n      cfg_.ts_rate_decimator[0] = 1;\n      cfg_.temporal_layering_mode = 0;\n    }\n  }\n\n  unsigned int num_nonref_frames_;\n  unsigned int mismatch_nframes_;\n}",
          "class_name": "DatarateOnePassCbrSvc",
          "class_pos": [
            [
              37,
              0
            ],
            [
              573,
              1
            ]
          ]
        },
        "2cb33f04d1c5ce7d1e5ae95d04a4f8a1a1f2e3fd7d75590c508d8a175e8369c6": {
          "class_code": "class DatarateOnePassCbrSvcSingleBR\n    : public DatarateOnePassCbrSvc,\n      public ::libvpx_test::CodecTestWithParam<int> {\n public:\n  DatarateOnePassCbrSvcSingleBR() : DatarateOnePassCbrSvc(GET_PARAM(0)) {\n    memset(&svc_params_, 0, sizeof(svc_params_));\n  }\n  virtual ~DatarateOnePassCbrSvcSingleBR() {}\n\n protected:\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    speed_setting_ = GET_PARAM(1);\n    ResetModel();\n  }\n}",
          "class_name": "DatarateOnePassCbrSvcSingleBR",
          "class_pos": [
            [
              576,
              0
            ],
            [
              592,
              1
            ]
          ]
        },
        "e3df14809633e9572aff9d900ae60a34dd7bd64dfa5a818e2acc2383f8f7852d": {
          "class_code": "class DatarateOnePassCbrSvcMultiBR\n    : public DatarateOnePassCbrSvc,\n      public ::libvpx_test::CodecTestWith2Params<int, int> {\n public:\n  DatarateOnePassCbrSvcMultiBR() : DatarateOnePassCbrSvc(GET_PARAM(0)) {\n    memset(&svc_params_, 0, sizeof(svc_params_));\n  }\n  virtual ~DatarateOnePassCbrSvcMultiBR() {}\n\n protected:\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    speed_setting_ = GET_PARAM(1);\n    ResetModel();\n  }\n}",
          "class_name": "DatarateOnePassCbrSvcMultiBR",
          "class_pos": [
            [
              847,
              0
            ],
            [
              863,
              1
            ]
          ]
        },
        "f556e56a34f52ae4d4f21f4774c029620bfca5a176364ae0e08864a53eba27d5": {
          "class_code": "class DatarateOnePassCbrSvcFrameDropMultiBR\n    : public DatarateOnePassCbrSvc,\n      public ::libvpx_test::CodecTestWith3Params<int, int, int> {\n public:\n  DatarateOnePassCbrSvcFrameDropMultiBR()\n      : DatarateOnePassCbrSvc(GET_PARAM(0)) {\n    memset(&svc_params_, 0, sizeof(svc_params_));\n  }\n  virtual ~DatarateOnePassCbrSvcFrameDropMultiBR() {}\n\n protected:\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    speed_setting_ = GET_PARAM(1);\n    ResetModel();\n  }\n}",
          "class_name": "DatarateOnePassCbrSvcFrameDropMultiBR",
          "class_pos": [
            [
              898,
              0
            ],
            [
              915,
              1
            ]
          ]
        },
        "04a7b0d011300626d50fadbe568111d3bfc48d399cebbb71038d51698183a6f6": {
          "class_code": "class DatarateOnePassCbrSvcInterLayerPredSingleBR\n    : public DatarateOnePassCbrSvc,\n      public ::libvpx_test::CodecTestWith2Params<int, int> {\n public:\n  DatarateOnePassCbrSvcInterLayerPredSingleBR()\n      : DatarateOnePassCbrSvc(GET_PARAM(0)) {\n    memset(&svc_params_, 0, sizeof(svc_params_));\n  }\n  virtual ~DatarateOnePassCbrSvcInterLayerPredSingleBR() {}\n\n protected:\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    speed_setting_ = GET_PARAM(1);\n    inter_layer_pred_mode_ = GET_PARAM(2);\n    ResetModel();\n  }\n}",
          "class_name": "DatarateOnePassCbrSvcInterLayerPredSingleBR",
          "class_pos": [
            [
              980,
              0
            ],
            [
              998,
              1
            ]
          ]
        },
        "1f1e5f8d7fe37c1e9d83ee0c267c8fd7b3a3670b57d8e3fb9b24b32800399b14": {
          "class_code": "class DatarateOnePassCbrSvcDenoiser\n    : public DatarateOnePassCbrSvc,\n      public ::libvpx_test::CodecTestWith3Params<int, int, int> {\n public:\n  DatarateOnePassCbrSvcDenoiser() : DatarateOnePassCbrSvc(GET_PARAM(0)) {\n    memset(&svc_params_, 0, sizeof(svc_params_));\n  }\n  virtual ~DatarateOnePassCbrSvcDenoiser() {}\n\n protected:\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    speed_setting_ = GET_PARAM(1);\n    ResetModel();\n  }\n}",
          "class_name": "DatarateOnePassCbrSvcDenoiser",
          "class_pos": [
            [
              1066,
              0
            ],
            [
              1082,
              1
            ]
          ]
        },
        "4e25056d534d934d87afa9d66c0a0f0790a21be0faa27d1ba855f3fa0448020e": {
          "class_code": "class DatarateOnePassCbrSvcSmallKF\n    : public DatarateOnePassCbrSvc,\n      public ::libvpx_test::CodecTestWith2Params<int, int> {\n public:\n  DatarateOnePassCbrSvcSmallKF() : DatarateOnePassCbrSvc(GET_PARAM(0)) {\n    memset(&svc_params_, 0, sizeof(svc_params_));\n  }\n  virtual ~DatarateOnePassCbrSvcSmallKF() {}\n\n protected:\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    speed_setting_ = GET_PARAM(1);\n    ResetModel();\n  }\n}",
          "class_name": "DatarateOnePassCbrSvcSmallKF",
          "class_pos": [
            [
              1123,
              0
            ],
            [
              1139,
              1
            ]
          ]
        },
        "0f18b04e1e6a67201414cf5519168b0aab1dcb18334af38be163fa5e00880774": {
          "class_code": "class DatarateOnePassCbrSvcPostencodeDrop\n    : public DatarateOnePassCbrSvc,\n      public ::libvpx_test::CodecTestWithParam<int> {\n public:\n  DatarateOnePassCbrSvcPostencodeDrop() : DatarateOnePassCbrSvc(GET_PARAM(0)) {\n    memset(&svc_params_, 0, sizeof(svc_params_));\n  }\n  virtual ~DatarateOnePassCbrSvcPostencodeDrop() {}\n\n protected:\n  virtual void SetUp() {\n    InitializeConfig();\n    SetMode(::libvpx_test::kRealTime);\n    speed_setting_ = GET_PARAM(1);\n    ResetModel();\n  }\n}",
          "class_name": "DatarateOnePassCbrSvcPostencodeDrop",
          "class_pos": [
            [
              1327,
              0
            ],
            [
              1343,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"./vpx_config.h\"\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/svc_test.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/y4m_video_source.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"vp9/common/vp9_onyxc_int.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_codec.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"vpx_ports/bitops.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n  // Inter-layer prediction is on on all frames.\n  INTER_LAYER_PRED_ON,\n  // Inter-layer prediction is off on all frames.\n  INTER_LAYER_PRED_OFF,\n  // Inter-layer prediction is off on non-key frames and non-sync frames.\n  INTER_LAYER_PRED_OFF_NONKEY,\n  // Inter-layer prediction is on on all frames, but constrained such\n  // that any layer S (> 0) can only predict from previous spatial\n  // layer S-1, from the same superframe.\n  INTER_LAYER_PRED_ON_CONSTRAINED\n} INTER_LAYER_PRED;",
          {
            "INTER_LAYER_PRED_ON": "",
            "INTER_LAYER_PRED_OFF": "",
            "INTER_LAYER_PRED_OFF_NONKEY": "",
            "INTER_LAYER_PRED_ON_CONSTRAINED": ""
          },
          "INTER_LAYER_PRED",
          [
            24,
            0
          ],
          [
            35,
            19
          ]
        ]
      ]
    }
  },
  "head": {
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/third_party/googletest/src/include/gtest/gtest-death-test.h": {
      "fn_def_list": [
        {
          "fn_code": "class GTEST_API_ ExitedWithCode {\n public:\n  explicit ExitedWithCode(int exit_code);\n  bool operator()(int exit_status) const;\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ExitedWithCode& other);\n\n  const int exit_code_;\n}",
          "fn_code_pos": [
            [
              190,
              0
            ],
            [
              199,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "class GTEST_API_ KilledBySignal {\n public:\n  explicit KilledBySignal(int signum);\n  bool operator()(int exit_status) const;\n private:\n  const int signum_;\n}",
          "fn_code_pos": [
            [
              205,
              0
            ],
            [
              211,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "InDeathTestChild()",
          "fn_dec_pos": [
            [
              60,
              16
            ],
            [
              60,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "InDeathTestChild",
            "parameters": {},
            "return_type": "GTEST_API_"
          }
        },
        {
          "fn_code": "operator()(int exit_status) const",
          "fn_dec_pos": [
            [
              193,
              7
            ],
            [
              193,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "exit_status": "int"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "operator()(int exit_status) const",
          "fn_dec_pos": [
            [
              208,
              7
            ],
            [
              208,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "exit_status": "int"
            },
            "return_type": "bool"
          }
        }
      ],
      "class_node_list": {
        "e7eb1b74ccc94ca1d9bb58490e7676648a81702cd84cefa201d5ae5f328d939e": {
          "class_code": "class GTEST_API_",
          "class_name": "GTEST_API_",
          "class_pos": [
            [
              205,
              0
            ],
            [
              205,
              16
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"gtest/internal/gtest-death-test-internal.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/third_party/googletest/src/include/gtest/gtest_pred_impl.h": {
      "fn_def_list": [
        {
          "fn_code": "template <typename Pred,\n          typename T1>\nAssertionResult AssertPred1Helper(const char* pred_text,\n                                  const char* e1,\n                                  Pred pred,\n                                  const T1& v1) {\n  if (pred(v1)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1;\n}",
          "fn_code_pos": [
            [
              83,
              0
            ],
            [
              94,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename Pred,\n          typename T1,\n          typename T2>\nAssertionResult AssertPred2Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2) {\n  if (pred(v1, v2)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2;\n}",
          "fn_code_pos": [
            [
              124,
              0
            ],
            [
              140,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename Pred,\n          typename T1,\n          typename T2,\n          typename T3>\nAssertionResult AssertPred3Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  const char* e3,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2,\n                                  const T3& v3) {\n  if (pred(v1, v2, v3)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \", \"\n                            << e3 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2\n                            << \"\\n\" << e3 << \" evaluates to \" << v3;\n}",
          "fn_code_pos": [
            [
              172,
              0
            ],
            [
              193,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename Pred,\n          typename T1,\n          typename T2,\n          typename T3,\n          typename T4>\nAssertionResult AssertPred4Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  const char* e3,\n                                  const char* e4,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2,\n                                  const T3& v3,\n                                  const T4& v4) {\n  if (pred(v1, v2, v3, v4)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \", \"\n                            << e3 << \", \"\n                            << e4 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2\n                            << \"\\n\" << e3 << \" evaluates to \" << v3\n                            << \"\\n\" << e4 << \" evaluates to \" << v4;\n}",
          "fn_code_pos": [
            [
              227,
              0
            ],
            [
              253,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename Pred,\n          typename T1,\n          typename T2,\n          typename T3,\n          typename T4,\n          typename T5>\nAssertionResult AssertPred5Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  const char* e3,\n                                  const char* e4,\n                                  const char* e5,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2,\n                                  const T3& v3,\n                                  const T4& v4,\n                                  const T5& v5) {\n  if (pred(v1, v2, v3, v4, v5)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \", \"\n                            << e3 << \", \"\n                            << e4 << \", \"\n                            << e5 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2\n                            << \"\\n\" << e3 << \" evaluates to \" << v3\n                            << \"\\n\" << e4 << \" evaluates to \" << v4\n                            << \"\\n\" << e5 << \" evaluates to \" << v5;\n}",
          "fn_code_pos": [
            [
              289,
              0
            ],
            [
              320,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"gtest/gtest.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/third_party/googletest/src/include/gtest/gtest-test-part.h": {
      "fn_def_list": [
        {
          "fn_code": "class GTEST_API_ TestPartResult {\n public:\n  // The possible outcomes of a test part (i.e. an assertion or an\n  // explicit SUCCEED(), FAIL(), or ADD_FAILURE()).\n  enum Type {\n    kSuccess,          // Succeeded.\n    kNonFatalFailure,  // Failed but the test can continue.\n    kFatalFailure      // Failed and the test should be terminated.\n  };\n\n  // C'tor.  TestPartResult does NOT have a default constructor.\n  // Always use this constructor (with parameters) to create a\n  // TestPartResult object.\n  TestPartResult(Type a_type,\n                 const char* a_file_name,\n                 int a_line_number,\n                 const char* a_message)\n      : type_(a_type),\n        file_name_(a_file_name == NULL ? \"\" : a_file_name),\n        line_number_(a_line_number),\n        summary_(ExtractSummary(a_message)),\n        message_(a_message) {\n  }\n\n  // Gets the outcome of the test part.\n  Type type() const { return type_; }\n\n  // Gets the name of the source file where the test part took place, or\n  // NULL if it's unknown.\n  const char* file_name() const {\n    return file_name_.empty() ? NULL : file_name_.c_str();\n  }\n\n  // Gets the line in the source file where the test part took place,\n  // or -1 if it's unknown.\n  int line_number() const { return line_number_; }\n\n  // Gets the summary of the failure message.\n  const char* summary() const { return summary_.c_str(); }\n\n  // Gets the message associated with the test part.\n  const char* message() const { return message_.c_str(); }\n\n  // Returns true iff the test part passed.\n  bool passed() const { return type_ == kSuccess; }\n\n  // Returns true iff the test part failed.\n  bool failed() const { return type_ != kSuccess; }\n\n  // Returns true iff the test part non-fatally failed.\n  bool nonfatally_failed() const { return type_ == kNonFatalFailure; }\n\n  // Returns true iff the test part fatally failed.\n  bool fatally_failed() const { return type_ == kFatalFailure; }\n\n private:\n  Type type_;\n\n  // Gets the summary of the failure message by omitting the stack\n  // trace in it.\n  static std::string ExtractSummary(const char* message);\n\n  // The name of the source file where the test part took place, or\n  // \"\" if the source file is unknown.\n  std::string file_name_;\n  // The line in the source file where the test part took place, or -1\n  // if the line number is unknown.\n  int line_number_;\n  std::string summary_;  // The test failure summary.\n  std::string message_;  // The test failure message.\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TestPartResult(Type a_type,\n                 const char* a_file_name,\n                 int a_line_number,\n                 const char* a_message)\n      : type_(a_type),\n        file_name_(a_file_name == NULL ? \"\" : a_file_name),\n        line_number_(a_line_number),\n        summary_(ExtractSummary(a_message)),\n        message_(a_message) {\n  }",
          "fn_code_pos": [
            [
              61,
              2
            ],
            [
              70,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TestPartResult",
            "parameters": {
              "a_type": "Type",
              "a_file_name": "char",
              "a_line_number": "int",
              "a_message": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Type type() const { return type_; }",
          "fn_code_pos": [
            [
              73,
              2
            ],
            [
              73,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "type",
            "parameters": {},
            "return_type": "Type"
          }
        },
        {
          "fn_code": "const char* file_name() const {\n    return file_name_.empty() ? NULL : file_name_.c_str();\n  }",
          "fn_code_pos": [
            [
              77,
              2
            ],
            [
              79,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_name",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "int line_number() const { return line_number_; }",
          "fn_code_pos": [
            [
              83,
              2
            ],
            [
              83,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "line_number",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "const char* summary() const { return summary_.c_str(); }",
          "fn_code_pos": [
            [
              86,
              2
            ],
            [
              86,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "summary",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "const char* message() const { return message_.c_str(); }",
          "fn_code_pos": [
            [
              89,
              2
            ],
            [
              89,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "message",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "bool passed() const { return type_ == kSuccess; }",
          "fn_code_pos": [
            [
              92,
              2
            ],
            [
              92,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "passed",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "bool failed() const { return type_ != kSuccess; }",
          "fn_code_pos": [
            [
              95,
              2
            ],
            [
              95,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "failed",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "bool nonfatally_failed() const { return type_ == kNonFatalFailure; }",
          "fn_code_pos": [
            [
              98,
              2
            ],
            [
              98,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nonfatally_failed",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "bool fatally_failed() const { return type_ == kFatalFailure; }",
          "fn_code_pos": [
            [
              101,
              2
            ],
            [
              101,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fatally_failed",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "class GTEST_API_ TestPartResultArray {\n public:\n  TestPartResultArray() {}\n\n  // Appends the given TestPartResult to the array.\n  void Append(const TestPartResult& result);\n\n  // Returns the TestPartResult at the given index (0-based).\n  const TestPartResult& GetTestPartResult(int index) const;\n\n  // Returns the number of TestPartResult objects in the array.\n  int size() const;\n\n private:\n  std::vector<TestPartResult> array_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestPartResultArray);\n}",
          "fn_code_pos": [
            [
              127,
              0
            ],
            [
              144,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "class GTEST_API_ TestPartResultReporterInterface {\n public:\n  virtual ~TestPartResultReporterInterface() {}\n\n  virtual void ReportTestPartResult(const TestPartResult& result) = 0;\n}",
          "fn_code_pos": [
            [
              147,
              0
            ],
            [
              152,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "class GTEST_API_ HasNewFatalFailureHelper\n    : public TestPartResultReporterInterface {\n public:\n  HasNewFatalFailureHelper();\n  virtual ~HasNewFatalFailureHelper();\n  virtual void ReportTestPartResult(const TestPartResult& result);\n  bool has_new_fatal_failure() const { return has_new_fatal_failure_; }\n private:\n  bool has_new_fatal_failure_;\n  TestPartResultReporterInterface* original_reporter_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(HasNewFatalFailureHelper);\n}",
          "fn_code_pos": [
            [
              162,
              0
            ],
            [
              174,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "bool has_new_fatal_failure() const { return has_new_fatal_failure_; }",
          "fn_code_pos": [
            [
              168,
              2
            ],
            [
              168,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "has_new_fatal_failure",
            "parameters": {},
            "return_type": "bool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "file_name() const",
          "fn_dec_pos": [
            [
              77,
              14
            ],
            [
              77,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_name",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "summary() const",
          "fn_dec_pos": [
            [
              86,
              14
            ],
            [
              86,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "summary",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "message() const",
          "fn_dec_pos": [
            [
              89,
              14
            ],
            [
              89,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "message",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ExtractSummary(const char* message)",
          "fn_dec_pos": [
            [
              108,
              21
            ],
            [
              108,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExtractSummary",
            "parameters": {
              "message": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(std::ostream& os, const TestPartResult& result)",
          "fn_dec_pos": [
            [
              121,
              14
            ],
            [
              121,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "os": "std::ostream",
              "result": "TestPartResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Append(const TestPartResult& result)",
          "fn_dec_pos": [
            [
              132,
              7
            ],
            [
              132,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Append",
            "parameters": {
              "result": "TestPartResult"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "GetTestPartResult(int index) const",
          "fn_dec_pos": [
            [
              135,
              24
            ],
            [
              135,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetTestPartResult",
            "parameters": {
              "index": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "size() const",
          "fn_dec_pos": [
            [
              138,
              6
            ],
            [
              138,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "size",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "ReportTestPartResult(const TestPartResult& result)",
          "fn_dec_pos": [
            [
              151,
              15
            ],
            [
              151,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReportTestPartResult",
            "parameters": {
              "result": "TestPartResult"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~HasNewFatalFailureHelper()",
          "fn_dec_pos": [
            [
              166,
              10
            ],
            [
              166,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ReportTestPartResult(const TestPartResult& result)",
          "fn_dec_pos": [
            [
              167,
              15
            ],
            [
              167,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReportTestPartResult",
            "parameters": {
              "result": "TestPartResult"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {
        "e7eb1b74ccc94ca1d9bb58490e7676648a81702cd84cefa201d5ae5f328d939e": {
          "class_code": "class GTEST_API_",
          "class_name": "GTEST_API_",
          "class_pos": [
            [
              162,
              0
            ],
            [
              162,
              16
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <iosfwd>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"gtest/internal/gtest-internal.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"gtest/internal/gtest-string.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/third_party/googletest/src/include/gtest/gtest-param-test.h": {
      "fn_def_list": [
        {
          "fn_code": "template <typename T, typename IncrementT>\ninternal::ParamGenerator<T> Range(T start, T end, IncrementT step) {\n  return internal::ParamGenerator<T>(\n      new internal::RangeGenerator<T, IncrementT>(start, end, step));\n}",
          "fn_code_pos": [
            [
              234,
              0
            ],
            [
              238,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T>\ninternal::ParamGenerator<T> Range(T start, T end) {\n  return Range(start, end, 1);\n}",
          "fn_code_pos": [
            [
              240,
              0
            ],
            [
              243,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename ForwardIterator>\ninternal::ParamGenerator<\n  typename ::testing::internal::IteratorTraits<ForwardIterator>::value_type>\nValuesIn(ForwardIterator begin, ForwardIterator end) {\n  typedef typename ::testing::internal::IteratorTraits<ForwardIterator>\n      ::value_type ParamType;\n  return internal::ParamGenerator<ParamType>(\n      new internal::ValuesInIteratorRangeGenerator<ParamType>(begin, end));\n}",
          "fn_code_pos": [
            [
              300,
              0
            ],
            [
              308,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T, size_t N>\ninternal::ParamGenerator<T> ValuesIn(const T (&array)[N]) {\n  return ValuesIn(array, array + N);\n}",
          "fn_code_pos": [
            [
              310,
              0
            ],
            [
              313,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <class Container>\ninternal::ParamGenerator<typename Container::value_type> ValuesIn(\n    const Container& container) {\n  return ValuesIn(container.begin(), container.end());\n}",
          "fn_code_pos": [
            [
              315,
              0
            ],
            [
              319,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1>\ninternal::ValueArray1<T1> Values(T1 v1) {\n  return internal::ValueArray1<T1>(v1);\n}",
          "fn_code_pos": [
            [
              340,
              0
            ],
            [
              343,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2>\ninternal::ValueArray2<T1, T2> Values(T1 v1, T2 v2) {\n  return internal::ValueArray2<T1, T2>(v1, v2);\n}",
          "fn_code_pos": [
            [
              345,
              0
            ],
            [
              348,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3>\ninternal::ValueArray3<T1, T2, T3> Values(T1 v1, T2 v2, T3 v3) {\n  return internal::ValueArray3<T1, T2, T3>(v1, v2, v3);\n}",
          "fn_code_pos": [
            [
              350,
              0
            ],
            [
              353,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4>\ninternal::ValueArray4<T1, T2, T3, T4> Values(T1 v1, T2 v2, T3 v3, T4 v4) {\n  return internal::ValueArray4<T1, T2, T3, T4>(v1, v2, v3, v4);\n}",
          "fn_code_pos": [
            [
              355,
              0
            ],
            [
              358,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5>\ninternal::ValueArray5<T1, T2, T3, T4, T5> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5) {\n  return internal::ValueArray5<T1, T2, T3, T4, T5>(v1, v2, v3, v4, v5);\n}",
          "fn_code_pos": [
            [
              360,
              0
            ],
            [
              364,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\ninternal::ValueArray6<T1, T2, T3, T4, T5, T6> Values(T1 v1, T2 v2, T3 v3,\n    T4 v4, T5 v5, T6 v6) {\n  return internal::ValueArray6<T1, T2, T3, T4, T5, T6>(v1, v2, v3, v4, v5, v6);\n}",
          "fn_code_pos": [
            [
              366,
              0
            ],
            [
              371,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\ninternal::ValueArray7<T1, T2, T3, T4, T5, T6, T7> Values(T1 v1, T2 v2, T3 v3,\n    T4 v4, T5 v5, T6 v6, T7 v7) {\n  return internal::ValueArray7<T1, T2, T3, T4, T5, T6, T7>(v1, v2, v3, v4, v5,\n      v6, v7);\n}",
          "fn_code_pos": [
            [
              373,
              0
            ],
            [
              379,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\ninternal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8) {\n  return internal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8>(v1, v2, v3, v4,\n      v5, v6, v7, v8);\n}",
          "fn_code_pos": [
            [
              381,
              0
            ],
            [
              387,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\ninternal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9) {\n  return internal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9>(v1, v2, v3,\n      v4, v5, v6, v7, v8, v9);\n}",
          "fn_code_pos": [
            [
              389,
              0
            ],
            [
              395,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\ninternal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Values(T1 v1,\n    T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10) {\n  return internal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(v1,\n      v2, v3, v4, v5, v6, v7, v8, v9, v10);\n}",
          "fn_code_pos": [
            [
              397,
              0
            ],
            [
              403,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11>\ninternal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10,\n    T11> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11) {\n  return internal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10,\n      T11>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11);\n}",
          "fn_code_pos": [
            [
              405,
              0
            ],
            [
              413,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12>\ninternal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n    T12> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12) {\n  return internal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);\n}",
          "fn_code_pos": [
            [
              415,
              0
            ],
            [
              423,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13>\ninternal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n    T13> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13) {\n  return internal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);\n}",
          "fn_code_pos": [
            [
              425,
              0
            ],
            [
              433,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14>\ninternal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14) {\n  return internal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\n      v14);\n}",
          "fn_code_pos": [
            [
              435,
              0
            ],
            [
              444,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15>\ninternal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,\n    T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15) {\n  return internal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\n      v13, v14, v15);\n}",
          "fn_code_pos": [
            [
              446,
              0
            ],
            [
              455,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16>\ninternal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16) {\n  return internal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\n      v12, v13, v14, v15, v16);\n}",
          "fn_code_pos": [
            [
              457,
              0
            ],
            [
              468,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17>\ninternal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17) {\n  return internal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,\n      v11, v12, v13, v14, v15, v16, v17);\n}",
          "fn_code_pos": [
            [
              470,
              0
            ],
            [
              481,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18>\ninternal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,\n    T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18) {\n  return internal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18>(v1, v2, v3, v4, v5, v6, v7, v8, v9,\n      v10, v11, v12, v13, v14, v15, v16, v17, v18);\n}",
          "fn_code_pos": [
            [
              483,
              0
            ],
            [
              494,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19>\ninternal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,\n    T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,\n    T15 v15, T16 v16, T17 v17, T18 v18, T19 v19) {\n  return internal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19>(v1, v2, v3, v4, v5, v6, v7, v8,\n      v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19);\n}",
          "fn_code_pos": [
            [
              496,
              0
            ],
            [
              507,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20>\ninternal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20) {\n  return internal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20>(v1, v2, v3, v4, v5, v6, v7,\n      v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20);\n}",
          "fn_code_pos": [
            [
              509,
              0
            ],
            [
              520,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21>\ninternal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21) {\n  return internal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(v1, v2, v3, v4, v5, v6,\n      v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21);\n}",
          "fn_code_pos": [
            [
              522,
              0
            ],
            [
              534,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22>\ninternal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22> Values(T1 v1, T2 v2, T3 v3,\n    T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22) {\n  return internal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>(v1, v2, v3, v4,\n      v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22);\n}",
          "fn_code_pos": [
            [
              536,
              0
            ],
            [
              550,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23>\ninternal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23) {\n  return internal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23>(v1, v2, v3,\n      v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22, v23);\n}",
          "fn_code_pos": [
            [
              552,
              0
            ],
            [
              566,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24>\ninternal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23, T24 v24) {\n  return internal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24>(v1, v2,\n      v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\n      v19, v20, v21, v22, v23, v24);\n}",
          "fn_code_pos": [
            [
              568,
              0
            ],
            [
              582,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25>\ninternal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> Values(T1 v1,\n    T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11,\n    T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19,\n    T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25) {\n  return internal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25>(v1,\n      v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,\n      v18, v19, v20, v21, v22, v23, v24, v25);\n}",
          "fn_code_pos": [
            [
              584,
              0
            ],
            [
              598,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26>\ninternal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n    T26> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26) {\n  return internal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15,\n      v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26);\n}",
          "fn_code_pos": [
            [
              600,
              0
            ],
            [
              616,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27>\ninternal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n    T27> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27) {\n  return internal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\n      v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27);\n}",
          "fn_code_pos": [
            [
              618,
              0
            ],
            [
              634,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28>\ninternal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n    T28> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28) {\n  return internal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\n      v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27,\n      v28);\n}",
          "fn_code_pos": [
            [
              636,
              0
            ],
            [
              653,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29>\ninternal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29) {\n  return internal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\n      v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26,\n      v27, v28, v29);\n}",
          "fn_code_pos": [
            [
              655,
              0
            ],
            [
              672,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30>\ninternal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,\n    T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16,\n    T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24,\n    T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30) {\n  return internal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\n      v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25,\n      v26, v27, v28, v29, v30);\n}",
          "fn_code_pos": [
            [
              674,
              0
            ],
            [
              691,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31>\ninternal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31) {\n  return internal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,\n      v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24,\n      v25, v26, v27, v28, v29, v30, v31);\n}",
          "fn_code_pos": [
            [
              693,
              0
            ],
            [
              711,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32>\ninternal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32) {\n  return internal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32>(v1, v2, v3, v4, v5, v6, v7, v8, v9,\n      v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\n      v24, v25, v26, v27, v28, v29, v30, v31, v32);\n}",
          "fn_code_pos": [
            [
              713,
              0
            ],
            [
              732,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33>\ninternal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,\n    T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32, T33 v33) {\n  return internal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33>(v1, v2, v3, v4, v5, v6, v7, v8,\n      v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\n      v24, v25, v26, v27, v28, v29, v30, v31, v32, v33);\n}",
          "fn_code_pos": [
            [
              734,
              0
            ],
            [
              753,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34>\ninternal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,\n    T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,\n    T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22,\n    T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30,\n    T31 v31, T32 v32, T33 v33, T34 v34) {\n  return internal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34>(v1, v2, v3, v4, v5, v6, v7,\n      v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n      v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34);\n}",
          "fn_code_pos": [
            [
              755,
              0
            ],
            [
              774,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35>\ninternal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,\n    T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,\n    T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35) {\n  return internal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35>(v1, v2, v3, v4, v5, v6,\n      v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,\n      v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35);\n}",
          "fn_code_pos": [
            [
              776,
              0
            ],
            [
              795,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36>\ninternal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,\n    T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,\n    T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36) {\n  return internal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36>(v1, v2, v3, v4,\n      v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,\n      v34, v35, v36);\n}",
          "fn_code_pos": [
            [
              797,
              0
            ],
            [
              818,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37>\ninternal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37> Values(T1 v1, T2 v2, T3 v3,\n    T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,\n    T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,\n    T37 v37) {\n  return internal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37>(v1, v2, v3,\n      v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,\n      v34, v35, v36, v37);\n}",
          "fn_code_pos": [
            [
              820,
              0
            ],
            [
              842,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38>\ninternal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,\n    T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,\n    T37 v37, T38 v38) {\n  return internal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38>(v1, v2,\n      v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\n      v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32,\n      v33, v34, v35, v36, v37, v38);\n}",
          "fn_code_pos": [
            [
              844,
              0
            ],
            [
              866,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39>\ninternal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,\n    T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,\n    T37 v37, T38 v38, T39 v39) {\n  return internal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39>(v1,\n      v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,\n      v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31,\n      v32, v33, v34, v35, v36, v37, v38, v39);\n}",
          "fn_code_pos": [
            [
              868,
              0
            ],
            [
              890,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40>\ninternal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> Values(T1 v1,\n    T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11,\n    T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19,\n    T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27,\n    T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35,\n    T36 v36, T37 v37, T38 v38, T39 v39, T40 v40) {\n  return internal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15,\n      v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29,\n      v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40);\n}",
          "fn_code_pos": [
            [
              892,
              0
            ],
            [
              914,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41>\ninternal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n    T41> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41) {\n  return internal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\n      v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28,\n      v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41);\n}",
          "fn_code_pos": [
            [
              916,
              0
            ],
            [
              939,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42>\ninternal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n    T42> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n    T42 v42) {\n  return internal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\n      v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27,\n      v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41,\n      v42);\n}",
          "fn_code_pos": [
            [
              941,
              0
            ],
            [
              966,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43>\ninternal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n    T43> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n    T42 v42, T43 v43) {\n  return internal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\n      v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26,\n      v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40,\n      v41, v42, v43);\n}",
          "fn_code_pos": [
            [
              968,
              0
            ],
            [
              993,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44>\ninternal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n    T42 v42, T43 v43, T44 v44) {\n  return internal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\n      v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25,\n      v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39,\n      v40, v41, v42, v43, v44);\n}",
          "fn_code_pos": [
            [
              995,
              0
            ],
            [
              1020,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45>\ninternal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,\n    T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16,\n    T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24,\n    T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32,\n    T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40,\n    T41 v41, T42 v42, T43 v43, T44 v44, T45 v45) {\n  return internal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,\n      v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24,\n      v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38,\n      v39, v40, v41, v42, v43, v44, v45);\n}",
          "fn_code_pos": [
            [
              1022,
              0
            ],
            [
              1047,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46>\ninternal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,\n    T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46) {\n  return internal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46>(v1, v2, v3, v4, v5, v6, v7, v8, v9,\n      v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\n      v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37,\n      v38, v39, v40, v41, v42, v43, v44, v45, v46);\n}",
          "fn_code_pos": [
            [
              1049,
              0
            ],
            [
              1075,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47>\ninternal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46, T47> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,\n    T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47) {\n  return internal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46, T47>(v1, v2, v3, v4, v5, v6, v7, v8,\n      v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\n      v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37,\n      v38, v39, v40, v41, v42, v43, v44, v45, v46, v47);\n}",
          "fn_code_pos": [
            [
              1077,
              0
            ],
            [
              1103,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48>\ninternal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46, T47, T48> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,\n    T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,\n    T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47,\n    T48 v48) {\n  return internal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46, T47, T48>(v1, v2, v3, v4, v5, v6, v7,\n      v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n      v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36,\n      v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48);\n}",
          "fn_code_pos": [
            [
              1105,
              0
            ],
            [
              1132,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49>\ninternal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46, T47, T48, T49> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,\n    T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,\n    T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22,\n    T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30,\n    T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38,\n    T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46,\n    T47 v47, T48 v48, T49 v49) {\n  return internal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46, T47, T48, T49>(v1, v2, v3, v4, v5, v6,\n      v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,\n      v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35,\n      v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49);\n}",
          "fn_code_pos": [
            [
              1134,
              0
            ],
            [
              1161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49, typename T50>\ninternal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46, T47, T48, T49, T50> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,\n    T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,\n    T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37,\n    T38 v38, T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45,\n    T46 v46, T47 v47, T48 v48, T49 v49, T50 v50) {\n  return internal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46, T47, T48, T49, T50>(v1, v2, v3, v4,\n      v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,\n      v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47,\n      v48, v49, v50);\n}",
          "fn_code_pos": [
            [
              1163,
              0
            ],
            [
              1191,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename Generator1, typename Generator2>\ninternal::CartesianProductHolder2<Generator1, Generator2> Combine(\n    const Generator1& g1, const Generator2& g2) {\n  return internal::CartesianProductHolder2<Generator1, Generator2>(\n      g1, g2);\n}",
          "fn_code_pos": [
            [
              1266,
              0
            ],
            [
              1271,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename Generator1, typename Generator2, typename Generator3>\ninternal::CartesianProductHolder3<Generator1, Generator2, Generator3> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3) {\n  return internal::CartesianProductHolder3<Generator1, Generator2, Generator3>(\n      g1, g2, g3);\n}",
          "fn_code_pos": [
            [
              1273,
              0
            ],
            [
              1278,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4>\ninternal::CartesianProductHolder4<Generator1, Generator2, Generator3,\n    Generator4> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4) {\n  return internal::CartesianProductHolder4<Generator1, Generator2, Generator3,\n      Generator4>(\n      g1, g2, g3, g4);\n}",
          "fn_code_pos": [
            [
              1280,
              0
            ],
            [
              1289,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5>\ninternal::CartesianProductHolder5<Generator1, Generator2, Generator3,\n    Generator4, Generator5> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5) {\n  return internal::CartesianProductHolder5<Generator1, Generator2, Generator3,\n      Generator4, Generator5>(\n      g1, g2, g3, g4, g5);\n}",
          "fn_code_pos": [
            [
              1291,
              0
            ],
            [
              1300,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6>\ninternal::CartesianProductHolder6<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6) {\n  return internal::CartesianProductHolder6<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6>(\n      g1, g2, g3, g4, g5, g6);\n}",
          "fn_code_pos": [
            [
              1302,
              0
            ],
            [
              1311,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6,\n    typename Generator7>\ninternal::CartesianProductHolder7<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6, Generator7> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6,\n        const Generator7& g7) {\n  return internal::CartesianProductHolder7<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6, Generator7>(\n      g1, g2, g3, g4, g5, g6, g7);\n}",
          "fn_code_pos": [
            [
              1313,
              0
            ],
            [
              1324,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6,\n    typename Generator7, typename Generator8>\ninternal::CartesianProductHolder8<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6, Generator7, Generator8> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6,\n        const Generator7& g7, const Generator8& g8) {\n  return internal::CartesianProductHolder8<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6, Generator7, Generator8>(\n      g1, g2, g3, g4, g5, g6, g7, g8);\n}",
          "fn_code_pos": [
            [
              1326,
              0
            ],
            [
              1337,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6,\n    typename Generator7, typename Generator8, typename Generator9>\ninternal::CartesianProductHolder9<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6, Generator7, Generator8,\n    Generator9> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6,\n        const Generator7& g7, const Generator8& g8, const Generator9& g9) {\n  return internal::CartesianProductHolder9<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6, Generator7, Generator8, Generator9>(\n      g1, g2, g3, g4, g5, g6, g7, g8, g9);\n}",
          "fn_code_pos": [
            [
              1339,
              0
            ],
            [
              1351,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6,\n    typename Generator7, typename Generator8, typename Generator9,\n    typename Generator10>\ninternal::CartesianProductHolder10<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6, Generator7, Generator8, Generator9,\n    Generator10> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6,\n        const Generator7& g7, const Generator8& g8, const Generator9& g9,\n        const Generator10& g10) {\n  return internal::CartesianProductHolder10<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6, Generator7, Generator8, Generator9,\n      Generator10>(\n      g1, g2, g3, g4, g5, g6, g7, g8, g9, g10);\n}",
          "fn_code_pos": [
            [
              1353,
              0
            ],
            [
              1368,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(FooTest, DoesBlah) {\n  // Inside a test, access the test parameter with the GetParam() method\n  // of the TestWithParam<T> class:\n  EXPECT_TRUE(foo.Blah(GetParam()));\n  ...\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              71,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(FooTest, HasBlahBlah) {\n  ...\n}",
          "fn_code_pos": [
            [
              73,
              0
            ],
            [
              75,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_F(BaseTest, HasFoo) {\n  // This is an ordinary non-parameterized test.\n}",
          "fn_code_pos": [
            [
              169,
              0
            ],
            [
              171,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_F",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TEST_P(DerivedTest, DoesBlah) {\n  // GetParam works just the same here as if you inherit from TestWithParam.\n  EXPECT_TRUE(foo.Blah(GetParam()));\n}",
          "fn_code_pos": [
            [
              173,
              0
            ],
            [
              176,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "inline internal::ParamGenerator<bool> Bool() {\n  return Values(false, true);\n}",
          "fn_code_pos": [
            [
              1213,
              0
            ],
            [
              1215,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Bool",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "e8ad452becf5e0094c2f9c1326c317aad0bf903228c10713bf3771c036771c06": {
          "class_code": "class FooTest : public ::testing::TestWithParam<const char*> {\n  // You can implement all the usual class fixture members here.\n}",
          "class_name": "FooTest",
          "class_pos": [
            [
              58,
              0
            ],
            [
              60,
              1
            ]
          ]
        },
        "0bbd302ef7336ba8a33716a1e872a2cf95257e0b5c387959f5586ac512105c3d": {
          "class_code": "class BaseTest : public ::testing::Test {\n  // You can inherit all the usual members for a non-parameterized test\n  // fixture here.\n}",
          "class_name": "BaseTest",
          "class_pos": [
            [
              160,
              0
            ],
            [
              163,
              1
            ]
          ]
        },
        "2775aa607a40e4212893dfb004c4302be6e3cb9111c12fd3d5049e1c4006c98a": {
          "class_code": "class DerivedTest : public BaseTest, public ::testing::WithParamInterface<int> {\n  // The usual test fixture members go here too.\n}",
          "class_name": "DerivedTest",
          "class_pos": [
            [
              165,
              0
            ],
            [
              167,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"gtest/internal/gtest-port.h\"\n",
          [
            180,
            0
          ],
          [
            181,
            0
          ]
        ],
        [
          "# include <utility>\n",
          [
            183,
            0
          ],
          [
            184,
            0
          ]
        ],
        [
          "#include \"gtest/internal/gtest-internal.h\"\n",
          [
            186,
            0
          ],
          [
            187,
            0
          ]
        ],
        [
          "#include \"gtest/internal/gtest-param-util.h\"\n",
          [
            187,
            0
          ],
          [
            188,
            0
          ]
        ],
        [
          "#include \"gtest/internal/gtest-param-util-generated.h\"\n",
          [
            188,
            0
          ],
          [
            189,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/third_party/googletest/src/include/gtest/gtest_prod.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/third_party/googletest/src/include/gtest/gtest-typed-test.h": {
      "fn_def_list": [
        {
          "fn_code": "TYPED_TEST(FooTest, DoesBlah) {\n  // Inside a test, refer to TypeParam to get the type parameter.\n  // Since we are inside a derived class template, C++ requires use to\n  // visit the members of FooTest via 'this'.\n  TypeParam n = this->value_;\n\n  // To visit static members of the fixture, add the TestFixture::\n  // prefix.\n  n += TestFixture::shared_;\n\n  // To refer to typedefs in the fixture, add the \"typename\n  // TestFixture::\" prefix.\n  typename TestFixture::List values;\n  values.push_back(n);\n  ...\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              81,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TYPED_TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TYPED_TEST(FooTest, HasPropertyA) { ... }",
          "fn_code_pos": [
            [
              83,
              0
            ],
            [
              83,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TYPED_TEST",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TYPED_TEST_P(FooTest, DoesBlah) {\n  // Inside a test, refer to TypeParam to get the type parameter.\n  TypeParam n = 0;\n  ...\n}",
          "fn_code_pos": [
            [
              135,
              0
            ],
            [
              139,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TYPED_TEST_P",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TYPED_TEST_P(FooTest, HasPropertyA) { ... }",
          "fn_code_pos": [
            [
              141,
              0
            ],
            [
              141,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TYPED_TEST_P",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "8c2422727ce89a7f92db8aa75af56983a9971121d92aa06eb7415fa147febf84": {
          "class_code": "template <typename T>\nclass FooTest : public testing::Test {\n public:\n  ...\n  typedef std::list<T> List;\n  static T shared_;\n  T value_;\n};",
          "class_name": "FooTest",
          "class_pos": [
            [
              45,
              0
            ],
            [
              52,
              2
            ]
          ]
        },
        "1a660c06d320007501e8bd2da4cbe027ae6984ff3ce81277799725d27ce639ea": {
          "class_code": "template <typename T>\nclass FooTest : public testing::Test {\n  ...\n};",
          "class_name": "FooTest",
          "class_pos": [
            [
              123,
              0
            ],
            [
              126,
              2
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"gtest/internal/gtest-port.h\"\n",
          [
            172,
            0
          ],
          [
            173,
            0
          ]
        ],
        [
          "#include \"gtest/internal/gtest-type-util.h\"\n",
          [
            173,
            0
          ],
          [
            174,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/third_party/googletest/src/include/gtest/internal/gtest-death-test-internal.h": {
      "fn_def_list": [
        {
          "fn_code": "class GTEST_API_ DeathTest {\n public:\n  // Create returns false if there was an error determining the\n  // appropriate action to take for the current death test; for example,\n  // if the gtest_death_test_style flag is set to an invalid value.\n  // The LastMessage method will return a more detailed message in that\n  // case.  Otherwise, the DeathTest pointer pointed to by the \"test\"\n  // argument is set.  If the death test should be skipped, the pointer\n  // is set to NULL; otherwise, it is set to the address of a new concrete\n  // DeathTest object that controls the execution of the current test.\n  static bool Create(const char* statement, const RE* regex,\n                     const char* file, int line, DeathTest** test);\n  DeathTest();\n  virtual ~DeathTest() { }\n\n  // A helper class that aborts a death test when it's deleted.\n  class ReturnSentinel {\n   public:\n    explicit ReturnSentinel(DeathTest* test) : test_(test) { }\n    ~ReturnSentinel() { test_->Abort(TEST_ENCOUNTERED_RETURN_STATEMENT); }\n   private:\n    DeathTest* const test_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ReturnSentinel);\n  } GTEST_ATTRIBUTE_UNUSED_;\n\n  // An enumeration of possible roles that may be taken when a death\n  // test is encountered.  EXECUTE means that the death test logic should\n  // be executed immediately.  OVERSEE means that the program should prepare\n  // the appropriate environment for a child process to execute the death\n  // test, then wait for it to complete.\n  enum TestRole { OVERSEE_TEST, EXECUTE_TEST };\n\n  // An enumeration of the three reasons that a test might be aborted.\n  enum AbortReason {\n    TEST_ENCOUNTERED_RETURN_STATEMENT,\n    TEST_THREW_EXCEPTION,\n    TEST_DID_NOT_DIE\n  };\n\n  // Assumes one of the above roles.\n  virtual TestRole AssumeRole() = 0;\n\n  // Waits for the death test to finish and returns its status.\n  virtual int Wait() = 0;\n\n  // Returns true if the death test passed; that is, the test process\n  // exited during the test, its exit status matches a user-supplied\n  // predicate, and its stderr output matches a user-supplied regular\n  // expression.\n  // The user-supplied predicate may be a macro expression rather\n  // than a function pointer or functor, or else Wait and Passed could\n  // be combined.\n  virtual bool Passed(bool exit_status_ok) = 0;\n\n  // Signals that the death test did not die as expected.\n  virtual void Abort(AbortReason reason) = 0;\n\n  // Returns a human-readable outcome message regarding the outcome of\n  // the last death test.\n  static const char* LastMessage();\n\n  static void set_last_death_test_message(const std::string& message);\n\n private:\n  // A string containing a description of the outcome of the last death test.\n  static std::string last_death_test_message_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(DeathTest);\n}",
          "fn_code_pos": [
            [
              70,
              0
            ],
            [
              138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DeathTest() { }",
          "fn_code_pos": [
            [
              83,
              2
            ],
            [
              83,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "explicit ReturnSentinel(DeathTest* test) : test_(test) { }",
          "fn_code_pos": [
            [
              88,
              4
            ],
            [
              88,
              62
            ]
          ],
          "class_code": "91359494de82bb6a5c63e8e16edbd8ed1bd9743c60cf83e1d1f208bec9c522a3",
          "class_node_pos": [
            [
              86,
              2
            ],
            [
              93,
              3
            ]
          ],
          "fn_meta": {
            "identifier": "ReturnSentinel",
            "parameters": {
              "test": "DeathTest"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~ReturnSentinel() { test_->Abort(TEST_ENCOUNTERED_RETURN_STATEMENT); }",
          "fn_code_pos": [
            [
              89,
              4
            ],
            [
              89,
              74
            ]
          ],
          "class_code": "91359494de82bb6a5c63e8e16edbd8ed1bd9743c60cf83e1d1f208bec9c522a3",
          "class_node_pos": [
            [
              86,
              2
            ],
            [
              93,
              3
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DeathTestFactory() { }",
          "fn_code_pos": [
            [
              145,
              2
            ],
            [
              145,
              33
            ]
          ],
          "class_code": "8f000fcaf1801ff6ab7c1f2c5f31f50e915c3694abc9cc19f4bf8d204a20f811",
          "class_node_pos": [
            [
              143,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual bool Create(const char* statement, const RE* regex,\n                      const char* file, int line, DeathTest** test) = 0;",
          "fn_code_pos": [
            [
              146,
              2
            ],
            [
              147,
              72
            ]
          ],
          "class_code": "8f000fcaf1801ff6ab7c1f2c5f31f50e915c3694abc9cc19f4bf8d204a20f811",
          "class_node_pos": [
            [
              143,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Create",
            "parameters": {
              "statement": "char",
              "regex": "RE",
              "file": "char",
              "line": "int",
              "test": "DeathTest"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "InternalRunDeathTestFlag(const std::string& a_file,\n                           int a_line,\n                           int an_index,\n                           int a_write_fd)\n      : file_(a_file), line_(a_line), index_(an_index),\n        write_fd_(a_write_fd) {}",
          "fn_code_pos": [
            [
              243,
              2
            ],
            [
              248,
              32
            ]
          ],
          "class_code": "1ede65a9bf88dfc6418ae36d6aebfc2c3dc02011690be65ed7d458cdc0e937bd",
          "class_node_pos": [
            [
              241,
              0
            ],
            [
              267,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "InternalRunDeathTestFlag",
            "parameters": {
              "a_file": "std::string",
              "a_line": "int",
              "an_index": "int",
              "a_write_fd": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~InternalRunDeathTestFlag() {\n    if (write_fd_ >= 0)\n      posix::Close(write_fd_);\n  }",
          "fn_code_pos": [
            [
              250,
              2
            ],
            [
              253,
              3
            ]
          ],
          "class_code": "1ede65a9bf88dfc6418ae36d6aebfc2c3dc02011690be65ed7d458cdc0e937bd",
          "class_node_pos": [
            [
              241,
              0
            ],
            [
              267,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "const std::string& file() const { return file_; }",
          "fn_code_pos": [
            [
              255,
              2
            ],
            [
              255,
              51
            ]
          ],
          "class_code": "1ede65a9bf88dfc6418ae36d6aebfc2c3dc02011690be65ed7d458cdc0e937bd",
          "class_node_pos": [
            [
              241,
              0
            ],
            [
              267,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "int line() const { return line_; }",
          "fn_code_pos": [
            [
              256,
              2
            ],
            [
              256,
              36
            ]
          ],
          "class_code": "1ede65a9bf88dfc6418ae36d6aebfc2c3dc02011690be65ed7d458cdc0e937bd",
          "class_node_pos": [
            [
              241,
              0
            ],
            [
              267,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "line",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int index() const { return index_; }",
          "fn_code_pos": [
            [
              257,
              2
            ],
            [
              257,
              38
            ]
          ],
          "class_code": "1ede65a9bf88dfc6418ae36d6aebfc2c3dc02011690be65ed7d458cdc0e937bd",
          "class_node_pos": [
            [
              241,
              0
            ],
            [
              267,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "index",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int write_fd() const { return write_fd_; }",
          "fn_code_pos": [
            [
              258,
              2
            ],
            [
              258,
              44
            ]
          ],
          "class_code": "1ede65a9bf88dfc6418ae36d6aebfc2c3dc02011690be65ed7d458cdc0e937bd",
          "class_node_pos": [
            [
              241,
              0
            ],
            [
              267,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "write_fd",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "GTEST_DISALLOW_COPY_AND_ASSIGN_(ReturnSentinel)",
          "fn_dec_pos": [
            [
              92,
              4
            ],
            [
              92,
              51
            ]
          ],
          "class_code": "91359494de82bb6a5c63e8e16edbd8ed1bd9743c60cf83e1d1f208bec9c522a3",
          "class_node_pos": [
            [
              86,
              2
            ],
            [
              93,
              3
            ]
          ],
          "fn_meta": {
            "identifier": "GTEST_DISALLOW_COPY_AND_ASSIGN_",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "AssumeRole()",
          "fn_dec_pos": [
            [
              110,
              19
            ],
            [
              110,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AssumeRole",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "Wait()",
          "fn_dec_pos": [
            [
              113,
              14
            ],
            [
              113,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Wait",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "Passed(bool exit_status_ok)",
          "fn_dec_pos": [
            [
              122,
              15
            ],
            [
              122,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Passed",
            "parameters": {
              "exit_status_ok": "bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Abort(AbortReason reason)",
          "fn_dec_pos": [
            [
              125,
              15
            ],
            [
              125,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Abort",
            "parameters": {
              "reason": "AbortReason"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "LastMessage()",
          "fn_dec_pos": [
            [
              129,
              21
            ],
            [
              129,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LastMessage",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "set_last_death_test_message(const std::string& message)",
          "fn_dec_pos": [
            [
              131,
              14
            ],
            [
              131,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_last_death_test_message",
            "parameters": {
              "message": "std::string"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "Create(const char* statement, const RE* regex,\n                      const char* file, int line, DeathTest** test)",
          "fn_dec_pos": [
            [
              153,
              15
            ],
            [
              154,
              67
            ]
          ],
          "class_code": "525e4cd3a5f5567800b21fd0ab0f90c0b860e694a5b61d363261271f8300b8b5",
          "class_node_pos": [
            [
              151,
              0
            ],
            [
              155,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Create",
            "parameters": {
              "statement": "char",
              "regex": "RE",
              "file": "char",
              "line": "int",
              "test": "DeathTest"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "ExitedUnsuccessfully(int exit_status)",
          "fn_dec_pos": [
            [
              159,
              16
            ],
            [
              159,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExitedUnsuccessfully",
            "parameters": {
              "exit_status": "int"
            },
            "return_type": "GTEST_API_"
          }
        },
        {
          "fn_code": "file() const",
          "fn_dec_pos": [
            [
              255,
              21
            ],
            [
              255,
              33
            ]
          ],
          "class_code": "1ede65a9bf88dfc6418ae36d6aebfc2c3dc02011690be65ed7d458cdc0e937bd",
          "class_node_pos": [
            [
              241,
              0
            ],
            [
              267,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "file",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "GTEST_DISALLOW_COPY_AND_ASSIGN_(InternalRunDeathTestFlag)",
          "fn_dec_pos": [
            [
              266,
              2
            ],
            [
              266,
              59
            ]
          ],
          "class_code": "1ede65a9bf88dfc6418ae36d6aebfc2c3dc02011690be65ed7d458cdc0e937bd",
          "class_node_pos": [
            [
              241,
              0
            ],
            [
              267,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GTEST_DISALLOW_COPY_AND_ASSIGN_",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ParseInternalRunDeathTestFlag()",
          "fn_dec_pos": [
            [
              272,
              26
            ],
            [
              272,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ParseInternalRunDeathTestFlag",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "e7eb1b74ccc94ca1d9bb58490e7676648a81702cd84cefa201d5ae5f328d939e": {
          "class_code": "class GTEST_API_",
          "class_name": "GTEST_API_",
          "class_pos": [
            [
              70,
              0
            ],
            [
              70,
              16
            ]
          ]
        },
        "91359494de82bb6a5c63e8e16edbd8ed1bd9743c60cf83e1d1f208bec9c522a3": {
          "class_code": "class ReturnSentinel {\n   public:\n    explicit ReturnSentinel(DeathTest* test) : test_(test) { }\n    ~ReturnSentinel() { test_->Abort(TEST_ENCOUNTERED_RETURN_STATEMENT); }\n   private:\n    DeathTest* const test_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ReturnSentinel);\n  }",
          "class_name": "ReturnSentinel",
          "class_pos": [
            [
              86,
              2
            ],
            [
              93,
              3
            ]
          ]
        },
        "8f000fcaf1801ff6ab7c1f2c5f31f50e915c3694abc9cc19f4bf8d204a20f811": {
          "class_code": "class DeathTestFactory {\n public:\n  virtual ~DeathTestFactory() { }\n  virtual bool Create(const char* statement, const RE* regex,\n                      const char* file, int line, DeathTest** test) = 0;\n}",
          "class_name": "DeathTestFactory",
          "class_pos": [
            [
              143,
              0
            ],
            [
              148,
              1
            ]
          ]
        },
        "525e4cd3a5f5567800b21fd0ab0f90c0b860e694a5b61d363261271f8300b8b5": {
          "class_code": "class DefaultDeathTestFactory : public DeathTestFactory {\n public:\n  virtual bool Create(const char* statement, const RE* regex,\n                      const char* file, int line, DeathTest** test);\n}",
          "class_name": "DefaultDeathTestFactory",
          "class_pos": [
            [
              151,
              0
            ],
            [
              155,
              1
            ]
          ]
        },
        "1ede65a9bf88dfc6418ae36d6aebfc2c3dc02011690be65ed7d458cdc0e937bd": {
          "class_code": "class InternalRunDeathTestFlag {\n public:\n  InternalRunDeathTestFlag(const std::string& a_file,\n                           int a_line,\n                           int an_index,\n                           int a_write_fd)\n      : file_(a_file), line_(a_line), index_(an_index),\n        write_fd_(a_write_fd) {}\n\n  ~InternalRunDeathTestFlag() {\n    if (write_fd_ >= 0)\n      posix::Close(write_fd_);\n  }\n\n  const std::string& file() const { return file_; }\n  int line() const { return line_; }\n  int index() const { return index_; }\n  int write_fd() const { return write_fd_; }\n\n private:\n  std::string file_;\n  int line_;\n  int index_;\n  int write_fd_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(InternalRunDeathTestFlag);\n}",
          "class_name": "InternalRunDeathTestFlag",
          "class_pos": [
            [
              241,
              0
            ],
            [
              267,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"gtest/internal/gtest-internal.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "enum TestRole { OVERSEE_TEST, EXECUTE_TEST }",
          {
            "OVERSEE_TEST": "",
            "EXECUTE_TEST": ""
          },
          "TestRole",
          [
            100,
            2
          ],
          [
            100,
            46
          ]
        ],
        [
          "enum AbortReason {\n    TEST_ENCOUNTERED_RETURN_STATEMENT,\n    TEST_THREW_EXCEPTION,\n    TEST_DID_NOT_DIE\n  }",
          {
            "TEST_ENCOUNTERED_RETURN_STATEMENT": "",
            "TEST_THREW_EXCEPTION": "",
            "TEST_DID_NOT_DIE": ""
          },
          "AbortReason",
          [
            103,
            2
          ],
          [
            107,
            3
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/test_vectors.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"./vpx_config.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/encode_test_driver.h": {
      "fn_def_list": [
        {
          "fn_code": "explicit CxDataIterator(vpx_codec_ctx_t *encoder)\n      : encoder_(encoder), iter_(NULL) {}",
          "fn_code_pos": [
            [
              50,
              2
            ],
            [
              51,
              41
            ]
          ],
          "class_code": "4645d31ba0ee6eafeedeb19fb4c227b7910cb7b3ae6ff25ad6bbb0e3f66244a6",
          "class_node_pos": [
            [
              48,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CxDataIterator",
            "parameters": {
              "encoder": "vpx_codec_ctx_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "const vpx_codec_cx_pkt_t *Next() {\n    return vpx_codec_get_cx_data(encoder_, &iter_);\n  }",
          "fn_code_pos": [
            [
              53,
              2
            ],
            [
              55,
              3
            ]
          ],
          "class_code": "4645d31ba0ee6eafeedeb19fb4c227b7910cb7b3ae6ff25ad6bbb0e3f66244a6",
          "class_node_pos": [
            [
              48,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Next",
            "parameters": {},
            "return_type": "vpx_codec_cx_pkt_t"
          }
        },
        {
          "fn_code": "void Append(const vpx_codec_cx_pkt_t &pkt) {\n    buffer_.append(reinterpret_cast<char *>(pkt.data.twopass_stats.buf),\n                   pkt.data.twopass_stats.sz);\n  }",
          "fn_code_pos": [
            [
              65,
              2
            ],
            [
              68,
              3
            ]
          ],
          "class_code": "c78928cbedf7315a1c2bd104fbebae639e4dabea843758c4c21b221566281cb3",
          "class_node_pos": [
            [
              63,
              0
            ],
            [
              79,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Append",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "vpx_fixed_buf_t buf() {\n    const vpx_fixed_buf_t buf = { &buffer_[0], buffer_.size() };\n    return buf;\n  }",
          "fn_code_pos": [
            [
              70,
              2
            ],
            [
              73,
              3
            ]
          ],
          "class_code": "c78928cbedf7315a1c2bd104fbebae639e4dabea843758c4c21b221566281cb3",
          "class_node_pos": [
            [
              63,
              0
            ],
            [
              79,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "buf",
            "parameters": {},
            "return_type": "vpx_fixed_buf_t"
          }
        },
        {
          "fn_code": "void Reset() { buffer_.clear(); }",
          "fn_code_pos": [
            [
              75,
              2
            ],
            [
              75,
              35
            ]
          ],
          "class_code": "c78928cbedf7315a1c2bd104fbebae639e4dabea843758c4c21b221566281cb3",
          "class_node_pos": [
            [
              63,
              0
            ],
            [
              79,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Reset",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "Encoder(vpx_codec_enc_cfg_t cfg, unsigned long deadline,\n          const unsigned long init_flags, TwopassStatsStore *stats)\n      : cfg_(cfg), deadline_(deadline), init_flags_(init_flags), stats_(stats) {\n    memset(&encoder_, 0, sizeof(encoder_));\n  }",
          "fn_code_pos": [
            [
              88,
              2
            ],
            [
              92,
              3
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Encoder",
            "parameters": {
              "cfg": "vpx_codec_enc_cfg_t",
              "deadline": "unsigned long",
              "init_flags": "unsigned long",
              "stats": "TwopassStatsStore"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~Encoder() { vpx_codec_destroy(&encoder_); }",
          "fn_code_pos": [
            [
              94,
              2
            ],
            [
              94,
              54
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CxDataIterator GetCxData() { return CxDataIterator(&encoder_); }",
          "fn_code_pos": [
            [
              96,
              2
            ],
            [
              96,
              66
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetCxData",
            "parameters": {},
            "return_type": "CxDataIterator"
          }
        },
        {
          "fn_code": "const vpx_image_t *GetPreviewFrame() {\n    return vpx_codec_get_preview_frame(&encoder_);\n  }",
          "fn_code_pos": [
            [
              100,
              2
            ],
            [
              102,
              3
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetPreviewFrame",
            "parameters": {},
            "return_type": "vpx_image_t"
          }
        },
        {
          "fn_code": "void EncodeFrame(VideoSource *video) { EncodeFrame(video, 0); }",
          "fn_code_pos": [
            [
              108,
              2
            ],
            [
              108,
              65
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EncodeFrame",
            "parameters": {
              "video": "VideoSource"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Control(int ctrl_id, int arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }",
          "fn_code_pos": [
            [
              110,
              2
            ],
            [
              113,
              3
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Control",
            "parameters": {
              "ctrl_id": "int",
              "arg": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Control(int ctrl_id, int *arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }",
          "fn_code_pos": [
            [
              115,
              2
            ],
            [
              118,
              3
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Control",
            "parameters": {
              "ctrl_id": "int",
              "arg": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Control(int ctrl_id, struct vpx_scaling_mode *arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }",
          "fn_code_pos": [
            [
              120,
              2
            ],
            [
              123,
              3
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Control",
            "parameters": {
              "ctrl_id": "int",
              "arg": "struct vpx_scaling_mode"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Control(int ctrl_id, struct vpx_svc_layer_id *arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }",
          "fn_code_pos": [
            [
              125,
              2
            ],
            [
              128,
              3
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Control",
            "parameters": {
              "ctrl_id": "int",
              "arg": "struct vpx_svc_layer_id"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Control(int ctrl_id, struct vpx_svc_ref_frame_config *arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }",
          "fn_code_pos": [
            [
              130,
              2
            ],
            [
              133,
              3
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Control",
            "parameters": {
              "ctrl_id": "int",
              "arg": "struct vpx_svc_ref_frame_config"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Control(int ctrl_id, struct vpx_svc_parameters *arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }",
          "fn_code_pos": [
            [
              135,
              2
            ],
            [
              138,
              3
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Control",
            "parameters": {
              "ctrl_id": "int",
              "arg": "struct vpx_svc_parameters"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Control(int ctrl_id, struct vpx_svc_frame_drop *arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }",
          "fn_code_pos": [
            [
              140,
              2
            ],
            [
              143,
              3
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Control",
            "parameters": {
              "ctrl_id": "int",
              "arg": "struct vpx_svc_frame_drop"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Control(int ctrl_id, struct vpx_svc_spatial_layer_sync *arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }",
          "fn_code_pos": [
            [
              145,
              2
            ],
            [
              148,
              3
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Control",
            "parameters": {
              "ctrl_id": "int",
              "arg": "struct vpx_svc_spatial_layer_sync"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Control(int ctrl_id, vpx_active_map_t *arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }",
          "fn_code_pos": [
            [
              151,
              2
            ],
            [
              154,
              3
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Control",
            "parameters": {
              "ctrl_id": "int",
              "arg": "vpx_active_map_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Control(int ctrl_id, vpx_roi_map_t *arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }",
          "fn_code_pos": [
            [
              156,
              2
            ],
            [
              159,
              3
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Control",
            "parameters": {
              "ctrl_id": "int",
              "arg": "vpx_roi_map_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Config(const vpx_codec_enc_cfg_t *cfg) {\n    const vpx_codec_err_t res = vpx_codec_enc_config_set(&encoder_, cfg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n    cfg_ = *cfg;\n  }",
          "fn_code_pos": [
            [
              161,
              2
            ],
            [
              165,
              3
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Config",
            "parameters": {
              "cfg": "vpx_codec_enc_cfg_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void set_deadline(unsigned long deadline) { deadline_ = deadline; }",
          "fn_code_pos": [
            [
              167,
              2
            ],
            [
              167,
              69
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "set_deadline",
            "parameters": {
              "deadline": "unsigned long"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual vpx_codec_iface_t *CodecInterface() const = 0;",
          "fn_code_pos": [
            [
              170,
              2
            ],
            [
              170,
              56
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CodecInterface",
            "parameters": {},
            "return_type": "vpx_codec_iface_t"
          }
        },
        {
          "fn_code": "const char *EncoderError() {\n    const char *detail = vpx_codec_error_detail(&encoder_);\n    return detail ? detail : vpx_codec_error(&encoder_);\n  }",
          "fn_code_pos": [
            [
              172,
              2
            ],
            [
              175,
              3
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EncoderError",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "explicit EncoderTest(const CodecFactory *codec)\n      : codec_(codec), abort_(false), init_flags_(0), frame_flags_(0),\n        last_pts_(0) {\n    // Default to 1 thread.\n    cfg_.g_threads = 1;\n  }",
          "fn_code_pos": [
            [
              200,
              2
            ],
            [
              205,
              3
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EncoderTest",
            "parameters": {
              "codec": "CodecFactory"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~EncoderTest() {}",
          "fn_code_pos": [
            [
              207,
              2
            ],
            [
              207,
              27
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void set_init_flags(unsigned long flag) {  // NOLINT(runtime/int)\n    init_flags_ = flag;\n  }",
          "fn_code_pos": [
            [
              216,
              2
            ],
            [
              218,
              3
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "set_init_flags",
            "parameters": {
              "flag": "unsigned long"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void BeginPassHook(unsigned int /*pass*/) {}",
          "fn_code_pos": [
            [
              224,
              2
            ],
            [
              224,
              54
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BeginPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void EndPassHook() {}",
          "fn_code_pos": [
            [
              227,
              2
            ],
            [
              227,
              31
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EndPassHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(VideoSource * /*video*/) {}",
          "fn_code_pos": [
            [
              230,
              2
            ],
            [
              230,
              61
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreEncodeFrameHook(VideoSource * /*video*/,\n                                  Encoder * /*encoder*/) {}",
          "fn_code_pos": [
            [
              231,
              2
            ],
            [
              232,
              59
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreDecodeFrameHook(VideoSource * /*video*/,\n                                  Decoder * /*decoder*/) {}",
          "fn_code_pos": [
            [
              234,
              2
            ],
            [
              235,
              59
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreDecodeFrameHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PostEncodeFrameHook(Encoder * /*encoder*/) {}",
          "fn_code_pos": [
            [
              237,
              2
            ],
            [
              237,
              60
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PostEncodeFrameHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FramePktHook(const vpx_codec_cx_pkt_t * /*pkt*/) {}",
          "fn_code_pos": [
            [
              240,
              2
            ],
            [
              240,
              66
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FramePktHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PSNRPktHook(const vpx_codec_cx_pkt_t * /*pkt*/) {}",
          "fn_code_pos": [
            [
              243,
              2
            ],
            [
              243,
              65
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PSNRPktHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void StatsPktHook(const vpx_codec_cx_pkt_t * /*pkt*/) {}",
          "fn_code_pos": [
            [
              246,
              2
            ],
            [
              246,
              66
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "StatsPktHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual bool Continue() const {\n    return !(::testing::Test::HasFatalFailure() || abort_);\n  }",
          "fn_code_pos": [
            [
              249,
              2
            ],
            [
              251,
              3
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Continue",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "virtual bool DoDecode() const { return 1; }",
          "fn_code_pos": [
            [
              255,
              2
            ],
            [
              255,
              45
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DoDecode",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "virtual void DecompressedFrameHook(const vpx_image_t & /*img*/,\n                                     vpx_codec_pts_t /*pts*/) {}",
          "fn_code_pos": [
            [
              261,
              2
            ],
            [
              262,
              64
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecompressedFrameHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual bool HandleDecodeResult(const vpx_codec_err_t res_dec,\n                                  const VideoSource & /*video*/,\n                                  Decoder *decoder) {\n    EXPECT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();\n    return VPX_CODEC_OK == res_dec;\n  }",
          "fn_code_pos": [
            [
              265,
              2
            ],
            [
              270,
              3
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "HandleDecodeResult",
            "parameters": {
              "res_dec": "vpx_codec_err_t",
              "decoder": "Decoder"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "virtual const vpx_codec_cx_pkt_t *MutateEncoderOutputHook(\n      const vpx_codec_cx_pkt_t *pkt) {\n    return pkt;\n  }",
          "fn_code_pos": [
            [
              273,
              2
            ],
            [
              276,
              3
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MutateEncoderOutputHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": "vpx_codec_cx_pkt_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "Next()",
          "fn_dec_pos": [
            [
              53,
              28
            ],
            [
              53,
              34
            ]
          ],
          "class_code": "4645d31ba0ee6eafeedeb19fb4c227b7910cb7b3ae6ff25ad6bbb0e3f66244a6",
          "class_node_pos": [
            [
              48,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Next",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "InitEncoder(VideoSource *video)",
          "fn_dec_pos": [
            [
              98,
              7
            ],
            [
              98,
              38
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "InitEncoder",
            "parameters": {
              "video": "VideoSource"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "GetPreviewFrame()",
          "fn_dec_pos": [
            [
              100,
              21
            ],
            [
              100,
              38
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetPreviewFrame",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "EncodeFrame(VideoSource *video, const unsigned long frame_flags)",
          "fn_dec_pos": [
            [
              105,
              7
            ],
            [
              105,
              71
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EncodeFrame",
            "parameters": {
              "video": "VideoSource",
              "frame_flags": "unsigned long"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "CodecInterface() const",
          "fn_dec_pos": [
            [
              170,
              29
            ],
            [
              170,
              51
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CodecInterface",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "EncoderError()",
          "fn_dec_pos": [
            [
              172,
              14
            ],
            [
              172,
              28
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EncoderError",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "EncodeFrameInternal(const VideoSource &video,\n                           const unsigned long frame_flags)",
          "fn_dec_pos": [
            [
              178,
              7
            ],
            [
              179,
              59
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "EncodeFrameInternal",
            "parameters": {
              "video": "VideoSource",
              "frame_flags": "unsigned long"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "Flush()",
          "fn_dec_pos": [
            [
              182,
              7
            ],
            [
              182,
              14
            ]
          ],
          "class_code": "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7",
          "class_node_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Flush",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "InitializeConfig()",
          "fn_dec_pos": [
            [
              210,
              7
            ],
            [
              210,
              25
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "InitializeConfig",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "SetMode(TestMode mode)",
          "fn_dec_pos": [
            [
              213,
              7
            ],
            [
              213,
              29
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetMode",
            "parameters": {
              "mode": "TestMode"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "RunLoop(VideoSource *video)",
          "fn_dec_pos": [
            [
              221,
              15
            ],
            [
              221,
              42
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunLoop",
            "parameters": {
              "video": "VideoSource"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "MismatchHook(const vpx_image_t *img1, const vpx_image_t *img2)",
          "fn_dec_pos": [
            [
              258,
              15
            ],
            [
              258,
              77
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MismatchHook",
            "parameters": {
              "img1": "vpx_image_t",
              "img2": "vpx_image_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "MutateEncoderOutputHook(\n      const vpx_codec_cx_pkt_t *pkt)",
          "fn_dec_pos": [
            [
              273,
              36
            ],
            [
              274,
              36
            ]
          ],
          "class_code": "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93",
          "class_node_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MutateEncoderOutputHook",
            "parameters": {
              "pkt": "vpx_codec_cx_pkt_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "9aa9815939eefef6956520aca319a955d20f1d5d51b6daed1ca0365f724c27c9": {
          "class_code": "class CodecFactory",
          "class_name": "CodecFactory",
          "class_pos": [
            [
              25,
              0
            ],
            [
              25,
              18
            ]
          ]
        },
        "ae4d94b5ba50faa0eddf5fbb7db05b313f1ee5dc2bde28c44d2c9e2c74d9ac2a": {
          "class_code": "class VideoSource",
          "class_name": "VideoSource",
          "class_pos": [
            [
              26,
              0
            ],
            [
              26,
              17
            ]
          ]
        },
        "4645d31ba0ee6eafeedeb19fb4c227b7910cb7b3ae6ff25ad6bbb0e3f66244a6": {
          "class_code": "class CxDataIterator {\n public:\n  explicit CxDataIterator(vpx_codec_ctx_t *encoder)\n      : encoder_(encoder), iter_(NULL) {}\n\n  const vpx_codec_cx_pkt_t *Next() {\n    return vpx_codec_get_cx_data(encoder_, &iter_);\n  }\n\n private:\n  vpx_codec_ctx_t *encoder_;\n  vpx_codec_iter_t iter_;\n}",
          "class_name": "CxDataIterator",
          "class_pos": [
            [
              48,
              0
            ],
            [
              60,
              1
            ]
          ]
        },
        "c78928cbedf7315a1c2bd104fbebae639e4dabea843758c4c21b221566281cb3": {
          "class_code": "class TwopassStatsStore {\n public:\n  void Append(const vpx_codec_cx_pkt_t &pkt) {\n    buffer_.append(reinterpret_cast<char *>(pkt.data.twopass_stats.buf),\n                   pkt.data.twopass_stats.sz);\n  }\n\n  vpx_fixed_buf_t buf() {\n    const vpx_fixed_buf_t buf = { &buffer_[0], buffer_.size() };\n    return buf;\n  }\n\n  void Reset() { buffer_.clear(); }\n\n protected:\n  std::string buffer_;\n}",
          "class_name": "TwopassStatsStore",
          "class_pos": [
            [
              63,
              0
            ],
            [
              79,
              1
            ]
          ]
        },
        "585a44fbeb86d15f945f6c6edece57e95781713d29c487fbb72871e94bbfcab7": {
          "class_code": "class Encoder {\n public:\n  Encoder(vpx_codec_enc_cfg_t cfg, unsigned long deadline,\n          const unsigned long init_flags, TwopassStatsStore *stats)\n      : cfg_(cfg), deadline_(deadline), init_flags_(init_flags), stats_(stats) {\n    memset(&encoder_, 0, sizeof(encoder_));\n  }\n\n  virtual ~Encoder() { vpx_codec_destroy(&encoder_); }\n\n  CxDataIterator GetCxData() { return CxDataIterator(&encoder_); }\n\n  void InitEncoder(VideoSource *video);\n\n  const vpx_image_t *GetPreviewFrame() {\n    return vpx_codec_get_preview_frame(&encoder_);\n  }\n  // This is a thin wrapper around vpx_codec_encode(), so refer to\n  // vpx_encoder.h for its semantics.\n  void EncodeFrame(VideoSource *video, const unsigned long frame_flags);\n\n  // Convenience wrapper for EncodeFrame()\n  void EncodeFrame(VideoSource *video) { EncodeFrame(video, 0); }\n\n  void Control(int ctrl_id, int arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }\n\n  void Control(int ctrl_id, int *arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }\n\n  void Control(int ctrl_id, struct vpx_scaling_mode *arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }\n\n  void Control(int ctrl_id, struct vpx_svc_layer_id *arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }\n\n  void Control(int ctrl_id, struct vpx_svc_ref_frame_config *arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }\n\n  void Control(int ctrl_id, struct vpx_svc_parameters *arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }\n\n  void Control(int ctrl_id, struct vpx_svc_frame_drop *arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }\n\n  void Control(int ctrl_id, struct vpx_svc_spatial_layer_sync *arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }\n\n#if CONFIG_VP8_ENCODER || CONFIG_VP9_ENCODER\n  void Control(int ctrl_id, vpx_active_map_t *arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }\n\n  void Control(int ctrl_id, vpx_roi_map_t *arg) {\n    const vpx_codec_err_t res = vpx_codec_control_(&encoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }\n#endif\n  void Config(const vpx_codec_enc_cfg_t *cfg) {\n    const vpx_codec_err_t res = vpx_codec_enc_config_set(&encoder_, cfg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n    cfg_ = *cfg;\n  }\n\n  void set_deadline(unsigned long deadline) { deadline_ = deadline; }\n\n protected:\n  virtual vpx_codec_iface_t *CodecInterface() const = 0;\n\n  const char *EncoderError() {\n    const char *detail = vpx_codec_error_detail(&encoder_);\n    return detail ? detail : vpx_codec_error(&encoder_);\n  }\n\n  // Encode an image\n  void EncodeFrameInternal(const VideoSource &video,\n                           const unsigned long frame_flags);\n\n  // Flush the encoder on EOS\n  void Flush();\n\n  vpx_codec_ctx_t encoder_;\n  vpx_codec_enc_cfg_t cfg_;\n  unsigned long deadline_;\n  unsigned long init_flags_;\n  TwopassStatsStore *stats_;\n}",
          "class_name": "Encoder",
          "class_pos": [
            [
              86,
              0
            ],
            [
              189,
              1
            ]
          ]
        },
        "91a05f2de80c823f28ebe0e90d65b9c274fa10ed704a690ee076059b66b1fc93": {
          "class_code": "class EncoderTest {\n protected:\n  explicit EncoderTest(const CodecFactory *codec)\n      : codec_(codec), abort_(false), init_flags_(0), frame_flags_(0),\n        last_pts_(0) {\n    // Default to 1 thread.\n    cfg_.g_threads = 1;\n  }\n\n  virtual ~EncoderTest() {}\n\n  // Initialize the cfg_ member with the default configuration.\n  void InitializeConfig();\n\n  // Map the TestMode enum to the deadline_ and passes_ variables.\n  void SetMode(TestMode mode);\n\n  // Set encoder flag.\n  void set_init_flags(unsigned long flag) {  // NOLINT(runtime/int)\n    init_flags_ = flag;\n  }\n\n  // Main loop\n  virtual void RunLoop(VideoSource *video);\n\n  // Hook to be called at the beginning of a pass.\n  virtual void BeginPassHook(unsigned int /*pass*/) {}\n\n  // Hook to be called at the end of a pass.\n  virtual void EndPassHook() {}\n\n  // Hook to be called before encoding a frame.\n  virtual void PreEncodeFrameHook(VideoSource * /*video*/) {}\n  virtual void PreEncodeFrameHook(VideoSource * /*video*/,\n                                  Encoder * /*encoder*/) {}\n\n  virtual void PreDecodeFrameHook(VideoSource * /*video*/,\n                                  Decoder * /*decoder*/) {}\n\n  virtual void PostEncodeFrameHook(Encoder * /*encoder*/) {}\n\n  // Hook to be called on every compressed data packet.\n  virtual void FramePktHook(const vpx_codec_cx_pkt_t * /*pkt*/) {}\n\n  // Hook to be called on every PSNR packet.\n  virtual void PSNRPktHook(const vpx_codec_cx_pkt_t * /*pkt*/) {}\n\n  // Hook to be called on every first pass stats packet.\n  virtual void StatsPktHook(const vpx_codec_cx_pkt_t * /*pkt*/) {}\n\n  // Hook to determine whether the encode loop should continue.\n  virtual bool Continue() const {\n    return !(::testing::Test::HasFatalFailure() || abort_);\n  }\n\n  const CodecFactory *codec_;\n  // Hook to determine whether to decode frame after encoding\n  virtual bool DoDecode() const { return 1; }\n\n  // Hook to handle encode/decode mismatch\n  virtual void MismatchHook(const vpx_image_t *img1, const vpx_image_t *img2);\n\n  // Hook to be called on every decompressed frame.\n  virtual void DecompressedFrameHook(const vpx_image_t & /*img*/,\n                                     vpx_codec_pts_t /*pts*/) {}\n\n  // Hook to be called to handle decode result. Return true to continue.\n  virtual bool HandleDecodeResult(const vpx_codec_err_t res_dec,\n                                  const VideoSource & /*video*/,\n                                  Decoder *decoder) {\n    EXPECT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();\n    return VPX_CODEC_OK == res_dec;\n  }\n\n  // Hook that can modify the encoder's output data\n  virtual const vpx_codec_cx_pkt_t *MutateEncoderOutputHook(\n      const vpx_codec_cx_pkt_t *pkt) {\n    return pkt;\n  }\n\n  bool abort_;\n  vpx_codec_enc_cfg_t cfg_;\n  vpx_codec_dec_cfg_t dec_cfg_;\n  unsigned int passes_;\n  unsigned long deadline_;\n  TwopassStatsStore stats_;\n  unsigned long init_flags_;\n  unsigned long frame_flags_;\n  vpx_codec_pts_t last_pts_;\n}",
          "class_name": "EncoderTest",
          "class_pos": [
            [
              198,
              0
            ],
            [
              287,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct vpx_scaling_mode",
          {},
          "",
          [
            120,
            28
          ],
          [
            120,
            51
          ]
        ],
        [
          "struct vpx_svc_layer_id",
          {},
          "",
          [
            125,
            28
          ],
          [
            125,
            51
          ]
        ],
        [
          "struct vpx_svc_ref_frame_config",
          {},
          "",
          [
            130,
            28
          ],
          [
            130,
            59
          ]
        ],
        [
          "struct vpx_svc_parameters",
          {},
          "",
          [
            135,
            28
          ],
          [
            135,
            53
          ]
        ],
        [
          "struct vpx_svc_frame_drop",
          {},
          "",
          [
            140,
            28
          ],
          [
            140,
            53
          ]
        ],
        [
          "struct vpx_svc_spatial_layer_sync",
          {},
          "",
          [
            145,
            28
          ],
          [
            145,
            61
          ]
        ]
      ],
      "include_list": [
        [
          "#include <string>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <vector>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"vpx/vp8cx.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_encoder.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "enum TestMode {\n  kRealTime,\n  kOnePassGood,\n  kOnePassBest,\n  kTwoPassGood,\n  kTwoPassBest\n}",
          {
            "kRealTime": "",
            "kOnePassGood": "",
            "kOnePassBest": "",
            "kTwoPassGood": "",
            "kTwoPassBest": ""
          },
          "TestMode",
          [
            28,
            0
          ],
          [
            34,
            1
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/ivf_video_source.h": {
      "fn_def_list": [
        {
          "fn_code": "static unsigned int MemGetLe32(const uint8_t *mem) {\n  return (mem[3] << 24) | (mem[2] << 16) | (mem[1] << 8) | (mem[0]);\n}",
          "fn_code_pos": [
            [
              22,
              0
            ],
            [
              24,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MemGetLe32",
            "parameters": {
              "mem": "uint8_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "explicit IVFVideoSource(const std::string &file_name)\n      : file_name_(file_name), input_file_(NULL), compressed_frame_buf_(NULL),\n        frame_sz_(0), frame_(0), end_of_file_(false) {}",
          "fn_code_pos": [
            [
              30,
              2
            ],
            [
              32,
              55
            ]
          ],
          "class_code": "09e29d811177c7e5e349f029a10a3e86eed902eba8aeb77d07fc85fee88abe28",
          "class_node_pos": [
            [
              28,
              0
            ],
            [
              101,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "IVFVideoSource",
            "parameters": {
              "file_name": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~IVFVideoSource() {\n    delete[] compressed_frame_buf_;\n\n    if (input_file_) fclose(input_file_);\n  }",
          "fn_code_pos": [
            [
              34,
              2
            ],
            [
              38,
              3
            ]
          ],
          "class_code": "09e29d811177c7e5e349f029a10a3e86eed902eba8aeb77d07fc85fee88abe28",
          "class_node_pos": [
            [
              28,
              0
            ],
            [
              101,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void Init() {\n    // Allocate a buffer for read in the compressed video frame.\n    compressed_frame_buf_ = new uint8_t[libvpx_test::kCodeBufferSize];\n    ASSERT_TRUE(compressed_frame_buf_ != NULL)\n        << \"Allocate frame buffer failed\";\n  }",
          "fn_code_pos": [
            [
              40,
              2
            ],
            [
              45,
              3
            ]
          ],
          "class_code": "09e29d811177c7e5e349f029a10a3e86eed902eba8aeb77d07fc85fee88abe28",
          "class_node_pos": [
            [
              28,
              0
            ],
            [
              101,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Init",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void Begin() {\n    input_file_ = OpenTestDataFile(file_name_);\n    ASSERT_TRUE(input_file_ != NULL)\n        << \"Input file open failed. Filename: \" << file_name_;\n\n    // Read file header\n    uint8_t file_hdr[kIvfFileHdrSize];\n    ASSERT_EQ(kIvfFileHdrSize, fread(file_hdr, 1, kIvfFileHdrSize, input_file_))\n        << \"File header read failed.\";\n    // Check file header\n    ASSERT_TRUE(file_hdr[0] == 'D' && file_hdr[1] == 'K' &&\n                file_hdr[2] == 'I' && file_hdr[3] == 'F')\n        << \"Input is not an IVF file.\";\n\n    FillFrame();\n  }",
          "fn_code_pos": [
            [
              47,
              2
            ],
            [
              62,
              3
            ]
          ],
          "class_code": "09e29d811177c7e5e349f029a10a3e86eed902eba8aeb77d07fc85fee88abe28",
          "class_node_pos": [
            [
              28,
              0
            ],
            [
              101,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Begin",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void Next() {\n    ++frame_;\n    FillFrame();\n  }",
          "fn_code_pos": [
            [
              64,
              2
            ],
            [
              67,
              3
            ]
          ],
          "class_code": "09e29d811177c7e5e349f029a10a3e86eed902eba8aeb77d07fc85fee88abe28",
          "class_node_pos": [
            [
              28,
              0
            ],
            [
              101,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Next",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void FillFrame() {\n    ASSERT_TRUE(input_file_ != NULL);\n    uint8_t frame_hdr[kIvfFrameHdrSize];\n    // Check frame header and read a frame from input_file.\n    if (fread(frame_hdr, 1, kIvfFrameHdrSize, input_file_) !=\n        kIvfFrameHdrSize) {\n      end_of_file_ = true;\n    } else {\n      end_of_file_ = false;\n\n      frame_sz_ = MemGetLe32(frame_hdr);\n      ASSERT_LE(frame_sz_, kCodeBufferSize)\n          << \"Frame is too big for allocated code buffer\";\n      ASSERT_EQ(frame_sz_,\n                fread(compressed_frame_buf_, 1, frame_sz_, input_file_))\n          << \"Failed to read complete frame\";\n    }\n  }",
          "fn_code_pos": [
            [
              69,
              2
            ],
            [
              86,
              3
            ]
          ],
          "class_code": "09e29d811177c7e5e349f029a10a3e86eed902eba8aeb77d07fc85fee88abe28",
          "class_node_pos": [
            [
              28,
              0
            ],
            [
              101,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillFrame",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual const uint8_t *cxdata() const {\n    return end_of_file_ ? NULL : compressed_frame_buf_;\n  }",
          "fn_code_pos": [
            [
              88,
              2
            ],
            [
              90,
              3
            ]
          ],
          "class_code": "09e29d811177c7e5e349f029a10a3e86eed902eba8aeb77d07fc85fee88abe28",
          "class_node_pos": [
            [
              28,
              0
            ],
            [
              101,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "cxdata",
            "parameters": {},
            "return_type": "uint8_t"
          }
        },
        {
          "fn_code": "virtual size_t frame_size() const { return frame_sz_; }",
          "fn_code_pos": [
            [
              91,
              2
            ],
            [
              91,
              57
            ]
          ],
          "class_code": "09e29d811177c7e5e349f029a10a3e86eed902eba8aeb77d07fc85fee88abe28",
          "class_node_pos": [
            [
              28,
              0
            ],
            [
              101,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "frame_size",
            "parameters": {},
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "virtual unsigned int frame_number() const { return frame_; }",
          "fn_code_pos": [
            [
              92,
              2
            ],
            [
              92,
              62
            ]
          ],
          "class_code": "09e29d811177c7e5e349f029a10a3e86eed902eba8aeb77d07fc85fee88abe28",
          "class_node_pos": [
            [
              28,
              0
            ],
            [
              101,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "frame_number",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "cxdata() const",
          "fn_dec_pos": [
            [
              88,
              25
            ],
            [
              88,
              39
            ]
          ],
          "class_code": "09e29d811177c7e5e349f029a10a3e86eed902eba8aeb77d07fc85fee88abe28",
          "class_node_pos": [
            [
              28,
              0
            ],
            [
              101,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "cxdata",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "09e29d811177c7e5e349f029a10a3e86eed902eba8aeb77d07fc85fee88abe28": {
          "class_code": "class IVFVideoSource : public CompressedVideoSource {\n public:\n  explicit IVFVideoSource(const std::string &file_name)\n      : file_name_(file_name), input_file_(NULL), compressed_frame_buf_(NULL),\n        frame_sz_(0), frame_(0), end_of_file_(false) {}\n\n  virtual ~IVFVideoSource() {\n    delete[] compressed_frame_buf_;\n\n    if (input_file_) fclose(input_file_);\n  }\n\n  virtual void Init() {\n    // Allocate a buffer for read in the compressed video frame.\n    compressed_frame_buf_ = new uint8_t[libvpx_test::kCodeBufferSize];\n    ASSERT_TRUE(compressed_frame_buf_ != NULL)\n        << \"Allocate frame buffer failed\";\n  }\n\n  virtual void Begin() {\n    input_file_ = OpenTestDataFile(file_name_);\n    ASSERT_TRUE(input_file_ != NULL)\n        << \"Input file open failed. Filename: \" << file_name_;\n\n    // Read file header\n    uint8_t file_hdr[kIvfFileHdrSize];\n    ASSERT_EQ(kIvfFileHdrSize, fread(file_hdr, 1, kIvfFileHdrSize, input_file_))\n        << \"File header read failed.\";\n    // Check file header\n    ASSERT_TRUE(file_hdr[0] == 'D' && file_hdr[1] == 'K' &&\n                file_hdr[2] == 'I' && file_hdr[3] == 'F')\n        << \"Input is not an IVF file.\";\n\n    FillFrame();\n  }\n\n  virtual void Next() {\n    ++frame_;\n    FillFrame();\n  }\n\n  void FillFrame() {\n    ASSERT_TRUE(input_file_ != NULL);\n    uint8_t frame_hdr[kIvfFrameHdrSize];\n    // Check frame header and read a frame from input_file.\n    if (fread(frame_hdr, 1, kIvfFrameHdrSize, input_file_) !=\n        kIvfFrameHdrSize) {\n      end_of_file_ = true;\n    } else {\n      end_of_file_ = false;\n\n      frame_sz_ = MemGetLe32(frame_hdr);\n      ASSERT_LE(frame_sz_, kCodeBufferSize)\n          << \"Frame is too big for allocated code buffer\";\n      ASSERT_EQ(frame_sz_,\n                fread(compressed_frame_buf_, 1, frame_sz_, input_file_))\n          << \"Failed to read complete frame\";\n    }\n  }\n\n  virtual const uint8_t *cxdata() const {\n    return end_of_file_ ? NULL : compressed_frame_buf_;\n  }\n  virtual size_t frame_size() const { return frame_sz_; }\n  virtual unsigned int frame_number() const { return frame_; }\n\n protected:\n  std::string file_name_;\n  FILE *input_file_;\n  uint8_t *compressed_frame_buf_;\n  size_t frame_sz_;\n  unsigned int frame_;\n  bool end_of_file_;\n}",
          "class_name": "IVFVideoSource",
          "class_pos": [
            [
              28,
              0
            ],
            [
              101,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <cstdio>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <cstdlib>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <new>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/video_source.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/decode_test_driver.h": {
      "fn_def_list": [
        {
          "fn_code": "explicit DxDataIterator(vpx_codec_ctx_t *decoder)\n      : decoder_(decoder), iter_(NULL) {}",
          "fn_code_pos": [
            [
              25,
              2
            ],
            [
              26,
              41
            ]
          ],
          "class_code": "ddeadf5a79c305e1530bd06385f9549a6b0009b07e46396973c85ebcf90f3aae",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              33,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DxDataIterator",
            "parameters": {
              "decoder": "vpx_codec_ctx_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "const vpx_image_t *Next() { return vpx_codec_get_frame(decoder_, &iter_); }",
          "fn_code_pos": [
            [
              28,
              2
            ],
            [
              28,
              77
            ]
          ],
          "class_code": "ddeadf5a79c305e1530bd06385f9549a6b0009b07e46396973c85ebcf90f3aae",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              33,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Next",
            "parameters": {},
            "return_type": "vpx_image_t"
          }
        },
        {
          "fn_code": "explicit Decoder(vpx_codec_dec_cfg_t cfg)\n      : cfg_(cfg), flags_(0), init_done_(false) {\n    memset(&decoder_, 0, sizeof(decoder_));\n  }",
          "fn_code_pos": [
            [
              40,
              2
            ],
            [
              43,
              3
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Decoder",
            "parameters": {
              "cfg": "vpx_codec_dec_cfg_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Decoder(vpx_codec_dec_cfg_t cfg, const vpx_codec_flags_t flag)\n      : cfg_(cfg), flags_(flag), init_done_(false) {\n    memset(&decoder_, 0, sizeof(decoder_));\n  }",
          "fn_code_pos": [
            [
              45,
              2
            ],
            [
              48,
              3
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Decoder",
            "parameters": {
              "cfg": "vpx_codec_dec_cfg_t",
              "flag": "vpx_codec_flags_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~Decoder() { vpx_codec_destroy(&decoder_); }",
          "fn_code_pos": [
            [
              50,
              2
            ],
            [
              50,
              54
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DxDataIterator GetDxData() { return DxDataIterator(&decoder_); }",
          "fn_code_pos": [
            [
              60,
              2
            ],
            [
              60,
              66
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetDxData",
            "parameters": {},
            "return_type": "DxDataIterator"
          }
        },
        {
          "fn_code": "void Control(int ctrl_id, int arg) { Control(ctrl_id, arg, VPX_CODEC_OK); }",
          "fn_code_pos": [
            [
              62,
              2
            ],
            [
              62,
              77
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Control",
            "parameters": {
              "ctrl_id": "int",
              "arg": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Control(int ctrl_id, const void *arg) {\n    InitOnce();\n    const vpx_codec_err_t res = vpx_codec_control_(&decoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << DecodeError();\n  }",
          "fn_code_pos": [
            [
              64,
              2
            ],
            [
              68,
              3
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Control",
            "parameters": {
              "ctrl_id": "int",
              "arg": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Control(int ctrl_id, int arg, vpx_codec_err_t expected_value) {\n    InitOnce();\n    const vpx_codec_err_t res = vpx_codec_control_(&decoder_, ctrl_id, arg);\n    ASSERT_EQ(expected_value, res) << DecodeError();\n  }",
          "fn_code_pos": [
            [
              70,
              2
            ],
            [
              74,
              3
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Control",
            "parameters": {
              "ctrl_id": "int",
              "arg": "int",
              "expected_value": "vpx_codec_err_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "const char *DecodeError() {\n    const char *detail = vpx_codec_error_detail(&decoder_);\n    return detail ? detail : vpx_codec_error(&decoder_);\n  }",
          "fn_code_pos": [
            [
              76,
              2
            ],
            [
              79,
              3
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecodeError",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "vpx_codec_err_t SetFrameBufferFunctions(\n      vpx_get_frame_buffer_cb_fn_t cb_get,\n      vpx_release_frame_buffer_cb_fn_t cb_release, void *user_priv) {\n    InitOnce();\n    return vpx_codec_set_frame_buffer_functions(&decoder_, cb_get, cb_release,\n                                                user_priv);\n  }",
          "fn_code_pos": [
            [
              82,
              2
            ],
            [
              88,
              3
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetFrameBufferFunctions",
            "parameters": {
              "cb_get": "vpx_get_frame_buffer_cb_fn_t",
              "cb_release": "vpx_release_frame_buffer_cb_fn_t",
              "user_priv": "void"
            },
            "return_type": "vpx_codec_err_t"
          }
        },
        {
          "fn_code": "const char *GetDecoderName() const {\n    return vpx_codec_iface_name(CodecInterface());\n  }",
          "fn_code_pos": [
            [
              90,
              2
            ],
            [
              92,
              3
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetDecoderName",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "vpx_codec_ctx_t *GetDecoder() { return &decoder_; }",
          "fn_code_pos": [
            [
              96,
              2
            ],
            [
              96,
              53
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetDecoder",
            "parameters": {},
            "return_type": "vpx_codec_ctx_t"
          }
        },
        {
          "fn_code": "virtual vpx_codec_iface_t *CodecInterface() const = 0;",
          "fn_code_pos": [
            [
              99,
              2
            ],
            [
              99,
              56
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CodecInterface",
            "parameters": {},
            "return_type": "vpx_codec_iface_t"
          }
        },
        {
          "fn_code": "void InitOnce() {\n    if (!init_done_) {\n      const vpx_codec_err_t res =\n          vpx_codec_dec_init(&decoder_, CodecInterface(), &cfg_, flags_);\n      ASSERT_EQ(VPX_CODEC_OK, res) << DecodeError();\n      init_done_ = true;\n    }\n  }",
          "fn_code_pos": [
            [
              101,
              2
            ],
            [
              108,
              3
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "InitOnce",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void PreDecodeFrameHook(const CompressedVideoSource & /*video*/,\n                                  Decoder * /*decoder*/) {}",
          "fn_code_pos": [
            [
              128,
              2
            ],
            [
              129,
              59
            ]
          ],
          "class_code": "93338887a80170669c7234c4cd56dcc4633f4326de4ce906bab030645c736d1f",
          "class_node_pos": [
            [
              117,
              0
            ],
            [
              157,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreDecodeFrameHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual bool HandleDecodeResult(const vpx_codec_err_t res_dec,\n                                  const CompressedVideoSource & /*video*/,\n                                  Decoder *decoder) {\n    EXPECT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();\n    return VPX_CODEC_OK == res_dec;\n  }",
          "fn_code_pos": [
            [
              132,
              2
            ],
            [
              137,
              3
            ]
          ],
          "class_code": "93338887a80170669c7234c4cd56dcc4633f4326de4ce906bab030645c736d1f",
          "class_node_pos": [
            [
              117,
              0
            ],
            [
              157,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "HandleDecodeResult",
            "parameters": {
              "res_dec": "vpx_codec_err_t",
              "decoder": "Decoder"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "virtual void DecompressedFrameHook(const vpx_image_t & /*img*/,\n                                     const unsigned int /*frame_number*/) {}",
          "fn_code_pos": [
            [
              140,
              2
            ],
            [
              141,
              76
            ]
          ],
          "class_code": "93338887a80170669c7234c4cd56dcc4633f4326de4ce906bab030645c736d1f",
          "class_node_pos": [
            [
              117,
              0
            ],
            [
              157,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecompressedFrameHook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "explicit DecoderTest(const CodecFactory *codec)\n      : codec_(codec), cfg_(), flags_(0) {}",
          "fn_code_pos": [
            [
              149,
              2
            ],
            [
              150,
              43
            ]
          ],
          "class_code": "93338887a80170669c7234c4cd56dcc4633f4326de4ce906bab030645c736d1f",
          "class_node_pos": [
            [
              117,
              0
            ],
            [
              157,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecoderTest",
            "parameters": {
              "codec": "CodecFactory"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DecoderTest() {}",
          "fn_code_pos": [
            [
              152,
              2
            ],
            [
              152,
              27
            ]
          ],
          "class_code": "93338887a80170669c7234c4cd56dcc4633f4326de4ce906bab030645c736d1f",
          "class_node_pos": [
            [
              117,
              0
            ],
            [
              157,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "Next()",
          "fn_dec_pos": [
            [
              28,
              21
            ],
            [
              28,
              27
            ]
          ],
          "class_code": "ddeadf5a79c305e1530bd06385f9549a6b0009b07e46396973c85ebcf90f3aae",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              33,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Next",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "PeekStream(const uint8_t *cxdata, size_t size,\n                             vpx_codec_stream_info_t *stream_info)",
          "fn_dec_pos": [
            [
              52,
              18
            ],
            [
              53,
              66
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PeekStream",
            "parameters": {
              "cxdata": "uint8_t",
              "size": "size_t",
              "stream_info": "vpx_codec_stream_info_t"
            },
            "return_type": "vpx_codec_err_t"
          }
        },
        {
          "fn_code": "DecodeFrame(const uint8_t *cxdata, size_t size)",
          "fn_dec_pos": [
            [
              55,
              18
            ],
            [
              55,
              65
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecodeFrame",
            "parameters": {
              "cxdata": "uint8_t",
              "size": "size_t"
            },
            "return_type": "vpx_codec_err_t"
          }
        },
        {
          "fn_code": "DecodeFrame(const uint8_t *cxdata, size_t size,\n                              void *user_priv)",
          "fn_dec_pos": [
            [
              57,
              18
            ],
            [
              58,
              46
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecodeFrame",
            "parameters": {
              "cxdata": "uint8_t",
              "size": "size_t",
              "user_priv": "void"
            },
            "return_type": "vpx_codec_err_t"
          }
        },
        {
          "fn_code": "DecodeError()",
          "fn_dec_pos": [
            [
              76,
              14
            ],
            [
              76,
              27
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DecodeError",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "GetDecoderName() const",
          "fn_dec_pos": [
            [
              90,
              14
            ],
            [
              90,
              36
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetDecoderName",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "IsVP8() const",
          "fn_dec_pos": [
            [
              94,
              7
            ],
            [
              94,
              20
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "IsVP8",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "GetDecoder()",
          "fn_dec_pos": [
            [
              96,
              19
            ],
            [
              96,
              31
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "GetDecoder",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CodecInterface() const",
          "fn_dec_pos": [
            [
              99,
              29
            ],
            [
              99,
              51
            ]
          ],
          "class_code": "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1",
          "class_node_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CodecInterface",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "RunLoop(CompressedVideoSource *video)",
          "fn_dec_pos": [
            [
              120,
              15
            ],
            [
              120,
              52
            ]
          ],
          "class_code": "93338887a80170669c7234c4cd56dcc4633f4326de4ce906bab030645c736d1f",
          "class_node_pos": [
            [
              117,
              0
            ],
            [
              157,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunLoop",
            "parameters": {
              "video": "CompressedVideoSource"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "RunLoop(CompressedVideoSource *video,\n                       const vpx_codec_dec_cfg_t &dec_cfg)",
          "fn_dec_pos": [
            [
              121,
              15
            ],
            [
              122,
              58
            ]
          ],
          "class_code": "93338887a80170669c7234c4cd56dcc4633f4326de4ce906bab030645c736d1f",
          "class_node_pos": [
            [
              117,
              0
            ],
            [
              157,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunLoop",
            "parameters": {
              "video": "CompressedVideoSource",
              "dec_cfg": "vpx_codec_dec_cfg_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "set_cfg(const vpx_codec_dec_cfg_t &dec_cfg)",
          "fn_dec_pos": [
            [
              124,
              15
            ],
            [
              124,
              58
            ]
          ],
          "class_code": "93338887a80170669c7234c4cd56dcc4633f4326de4ce906bab030645c736d1f",
          "class_node_pos": [
            [
              117,
              0
            ],
            [
              157,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "set_cfg",
            "parameters": {
              "dec_cfg": "vpx_codec_dec_cfg_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "set_flags(const vpx_codec_flags_t flags)",
          "fn_dec_pos": [
            [
              125,
              15
            ],
            [
              125,
              55
            ]
          ],
          "class_code": "93338887a80170669c7234c4cd56dcc4633f4326de4ce906bab030645c736d1f",
          "class_node_pos": [
            [
              117,
              0
            ],
            [
              157,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "set_flags",
            "parameters": {
              "flags": "vpx_codec_flags_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "HandlePeekResult(Decoder *const decoder,\n                                CompressedVideoSource *video,\n                                const vpx_codec_err_t res_peek)",
          "fn_dec_pos": [
            [
              144,
              15
            ],
            [
              146,
              63
            ]
          ],
          "class_code": "93338887a80170669c7234c4cd56dcc4633f4326de4ce906bab030645c736d1f",
          "class_node_pos": [
            [
              117,
              0
            ],
            [
              157,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "HandlePeekResult",
            "parameters": {
              "decoder": "Decoder",
              "video": "CompressedVideoSource",
              "res_peek": "vpx_codec_err_t"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {
        "9aa9815939eefef6956520aca319a955d20f1d5d51b6daed1ca0365f724c27c9": {
          "class_code": "class CodecFactory",
          "class_name": "CodecFactory",
          "class_pos": [
            [
              19,
              0
            ],
            [
              19,
              18
            ]
          ]
        },
        "679b3b3af32d30287d5106777026e264a6967bf0fee050f7eba6c60bd858ef69": {
          "class_code": "class CompressedVideoSource",
          "class_name": "CompressedVideoSource",
          "class_pos": [
            [
              20,
              0
            ],
            [
              20,
              27
            ]
          ]
        },
        "ddeadf5a79c305e1530bd06385f9549a6b0009b07e46396973c85ebcf90f3aae": {
          "class_code": "class DxDataIterator {\n public:\n  explicit DxDataIterator(vpx_codec_ctx_t *decoder)\n      : decoder_(decoder), iter_(NULL) {}\n\n  const vpx_image_t *Next() { return vpx_codec_get_frame(decoder_, &iter_); }\n\n private:\n  vpx_codec_ctx_t *decoder_;\n  vpx_codec_iter_t iter_;\n}",
          "class_name": "DxDataIterator",
          "class_pos": [
            [
              23,
              0
            ],
            [
              33,
              1
            ]
          ]
        },
        "06baaba0b59dea9b707e579370ea1011b5e393bcaeb76f067e1407457d73eaf1": {
          "class_code": "class Decoder {\n public:\n  explicit Decoder(vpx_codec_dec_cfg_t cfg)\n      : cfg_(cfg), flags_(0), init_done_(false) {\n    memset(&decoder_, 0, sizeof(decoder_));\n  }\n\n  Decoder(vpx_codec_dec_cfg_t cfg, const vpx_codec_flags_t flag)\n      : cfg_(cfg), flags_(flag), init_done_(false) {\n    memset(&decoder_, 0, sizeof(decoder_));\n  }\n\n  virtual ~Decoder() { vpx_codec_destroy(&decoder_); }\n\n  vpx_codec_err_t PeekStream(const uint8_t *cxdata, size_t size,\n                             vpx_codec_stream_info_t *stream_info);\n\n  vpx_codec_err_t DecodeFrame(const uint8_t *cxdata, size_t size);\n\n  vpx_codec_err_t DecodeFrame(const uint8_t *cxdata, size_t size,\n                              void *user_priv);\n\n  DxDataIterator GetDxData() { return DxDataIterator(&decoder_); }\n\n  void Control(int ctrl_id, int arg) { Control(ctrl_id, arg, VPX_CODEC_OK); }\n\n  void Control(int ctrl_id, const void *arg) {\n    InitOnce();\n    const vpx_codec_err_t res = vpx_codec_control_(&decoder_, ctrl_id, arg);\n    ASSERT_EQ(VPX_CODEC_OK, res) << DecodeError();\n  }\n\n  void Control(int ctrl_id, int arg, vpx_codec_err_t expected_value) {\n    InitOnce();\n    const vpx_codec_err_t res = vpx_codec_control_(&decoder_, ctrl_id, arg);\n    ASSERT_EQ(expected_value, res) << DecodeError();\n  }\n\n  const char *DecodeError() {\n    const char *detail = vpx_codec_error_detail(&decoder_);\n    return detail ? detail : vpx_codec_error(&decoder_);\n  }\n\n  // Passes the external frame buffer information to libvpx.\n  vpx_codec_err_t SetFrameBufferFunctions(\n      vpx_get_frame_buffer_cb_fn_t cb_get,\n      vpx_release_frame_buffer_cb_fn_t cb_release, void *user_priv) {\n    InitOnce();\n    return vpx_codec_set_frame_buffer_functions(&decoder_, cb_get, cb_release,\n                                                user_priv);\n  }\n\n  const char *GetDecoderName() const {\n    return vpx_codec_iface_name(CodecInterface());\n  }\n\n  bool IsVP8() const;\n\n  vpx_codec_ctx_t *GetDecoder() { return &decoder_; }\n\n protected:\n  virtual vpx_codec_iface_t *CodecInterface() const = 0;\n\n  void InitOnce() {\n    if (!init_done_) {\n      const vpx_codec_err_t res =\n          vpx_codec_dec_init(&decoder_, CodecInterface(), &cfg_, flags_);\n      ASSERT_EQ(VPX_CODEC_OK, res) << DecodeError();\n      init_done_ = true;\n    }\n  }\n\n  vpx_codec_ctx_t decoder_;\n  vpx_codec_dec_cfg_t cfg_;\n  vpx_codec_flags_t flags_;\n  bool init_done_;\n}",
          "class_name": "Decoder",
          "class_pos": [
            [
              38,
              0
            ],
            [
              114,
              1
            ]
          ]
        },
        "93338887a80170669c7234c4cd56dcc4633f4326de4ce906bab030645c736d1f": {
          "class_code": "class DecoderTest {\n public:\n  // Main decoding loop\n  virtual void RunLoop(CompressedVideoSource *video);\n  virtual void RunLoop(CompressedVideoSource *video,\n                       const vpx_codec_dec_cfg_t &dec_cfg);\n\n  virtual void set_cfg(const vpx_codec_dec_cfg_t &dec_cfg);\n  virtual void set_flags(const vpx_codec_flags_t flags);\n\n  // Hook to be called before decompressing every frame.\n  virtual void PreDecodeFrameHook(const CompressedVideoSource & /*video*/,\n                                  Decoder * /*decoder*/) {}\n\n  // Hook to be called to handle decode result. Return true to continue.\n  virtual bool HandleDecodeResult(const vpx_codec_err_t res_dec,\n                                  const CompressedVideoSource & /*video*/,\n                                  Decoder *decoder) {\n    EXPECT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();\n    return VPX_CODEC_OK == res_dec;\n  }\n\n  // Hook to be called on every decompressed frame.\n  virtual void DecompressedFrameHook(const vpx_image_t & /*img*/,\n                                     const unsigned int /*frame_number*/) {}\n\n  // Hook to be called on peek result\n  virtual void HandlePeekResult(Decoder *const decoder,\n                                CompressedVideoSource *video,\n                                const vpx_codec_err_t res_peek);\n\n protected:\n  explicit DecoderTest(const CodecFactory *codec)\n      : codec_(codec), cfg_(), flags_(0) {}\n\n  virtual ~DecoderTest() {}\n\n  const CodecFactory *codec_;\n  vpx_codec_dec_cfg_t cfg_;\n  vpx_codec_flags_t flags_;\n}",
          "class_name": "DecoderTest",
          "class_pos": [
            [
              117,
              0
            ],
            [
              157,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <cstring>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_decoder.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/codec_factory.h": {
      "fn_def_list": [
        {
          "fn_code": "CodecFactory() {}",
          "fn_code_pos": [
            [
              32,
              2
            ],
            [
              32,
              19
            ]
          ],
          "class_code": "6862dda723ed0b3a49eefb80115cc14db821f8e7c573ae5bb4ef0828cb13993c",
          "class_node_pos": [
            [
              30,
              0
            ],
            [
              48,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CodecFactory",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~CodecFactory() {}",
          "fn_code_pos": [
            [
              34,
              2
            ],
            [
              34,
              28
            ]
          ],
          "class_code": "6862dda723ed0b3a49eefb80115cc14db821f8e7c573ae5bb4ef0828cb13993c",
          "class_node_pos": [
            [
              30,
              0
            ],
            [
              48,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual Decoder *CreateDecoder(vpx_codec_dec_cfg_t cfg) const = 0;",
          "fn_code_pos": [
            [
              36,
              2
            ],
            [
              36,
              68
            ]
          ],
          "class_code": "6862dda723ed0b3a49eefb80115cc14db821f8e7c573ae5bb4ef0828cb13993c",
          "class_node_pos": [
            [
              30,
              0
            ],
            [
              48,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CreateDecoder",
            "parameters": {
              "cfg": "vpx_codec_dec_cfg_t"
            },
            "return_type": "Decoder"
          }
        },
        {
          "fn_code": "virtual Decoder *CreateDecoder(vpx_codec_dec_cfg_t cfg,\n                                 const vpx_codec_flags_t flags) const = 0;",
          "fn_code_pos": [
            [
              38,
              2
            ],
            [
              39,
              74
            ]
          ],
          "class_code": "6862dda723ed0b3a49eefb80115cc14db821f8e7c573ae5bb4ef0828cb13993c",
          "class_node_pos": [
            [
              30,
              0
            ],
            [
              48,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CreateDecoder",
            "parameters": {
              "cfg": "vpx_codec_dec_cfg_t",
              "flags": "vpx_codec_flags_t"
            },
            "return_type": "Decoder"
          }
        },
        {
          "fn_code": "virtual Encoder *CreateEncoder(vpx_codec_enc_cfg_t cfg,\n                                 unsigned long deadline,\n                                 const unsigned long init_flags,\n                                 TwopassStatsStore *stats) const = 0;",
          "fn_code_pos": [
            [
              41,
              2
            ],
            [
              44,
              69
            ]
          ],
          "class_code": "6862dda723ed0b3a49eefb80115cc14db821f8e7c573ae5bb4ef0828cb13993c",
          "class_node_pos": [
            [
              30,
              0
            ],
            [
              48,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CreateEncoder",
            "parameters": {
              "cfg": "vpx_codec_enc_cfg_t",
              "deadline": "unsigned long",
              "init_flags": "unsigned long",
              "stats": "TwopassStatsStore"
            },
            "return_type": "Encoder"
          }
        },
        {
          "fn_code": "virtual vpx_codec_err_t DefaultEncoderConfig(vpx_codec_enc_cfg_t *cfg,\n                                               int usage) const = 0;",
          "fn_code_pos": [
            [
              46,
              2
            ],
            [
              47,
              68
            ]
          ],
          "class_code": "6862dda723ed0b3a49eefb80115cc14db821f8e7c573ae5bb4ef0828cb13993c",
          "class_node_pos": [
            [
              30,
              0
            ],
            [
              48,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DefaultEncoderConfig",
            "parameters": {
              "cfg": "vpx_codec_enc_cfg_t",
              "usage": "int"
            },
            "return_type": "vpx_codec_err_t"
          }
        },
        {
          "fn_code": "explicit VP8Decoder(vpx_codec_dec_cfg_t cfg) : Decoder(cfg) {}",
          "fn_code_pos": [
            [
              80,
              2
            ],
            [
              80,
              64
            ]
          ],
          "class_code": "ab8d2bf5d0c03d369b02a41828c4e147d550443467218081dcdb880250f879f4",
          "class_node_pos": [
            [
              78,
              0
            ],
            [
              93,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VP8Decoder",
            "parameters": {
              "cfg": "vpx_codec_dec_cfg_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "VP8Decoder(vpx_codec_dec_cfg_t cfg, const vpx_codec_flags_t flag)\n      : Decoder(cfg, flag) {}",
          "fn_code_pos": [
            [
              82,
              2
            ],
            [
              83,
              29
            ]
          ],
          "class_code": "ab8d2bf5d0c03d369b02a41828c4e147d550443467218081dcdb880250f879f4",
          "class_node_pos": [
            [
              78,
              0
            ],
            [
              93,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VP8Decoder",
            "parameters": {
              "cfg": "vpx_codec_dec_cfg_t",
              "flag": "vpx_codec_flags_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual vpx_codec_iface_t *CodecInterface() const {\n#if CONFIG_VP8_DECODER\n    return &vpx_codec_vp8_dx_algo;\n#else\n    return NULL;\n#endif\n  }",
          "fn_code_pos": [
            [
              86,
              2
            ],
            [
              92,
              3
            ]
          ],
          "class_code": "ab8d2bf5d0c03d369b02a41828c4e147d550443467218081dcdb880250f879f4",
          "class_node_pos": [
            [
              78,
              0
            ],
            [
              93,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CodecInterface",
            "parameters": {},
            "return_type": "vpx_codec_iface_t"
          }
        },
        {
          "fn_code": "VP8Encoder(vpx_codec_enc_cfg_t cfg, unsigned long deadline,\n             const unsigned long init_flags, TwopassStatsStore *stats)\n      : Encoder(cfg, deadline, init_flags, stats) {}",
          "fn_code_pos": [
            [
              97,
              2
            ],
            [
              99,
              52
            ]
          ],
          "class_code": "dcfb6a72661f34b80ebc25c83dd03cf5f7f28e7fe311bde08a0eb73bef712f2f",
          "class_node_pos": [
            [
              95,
              0
            ],
            [
              109,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VP8Encoder",
            "parameters": {
              "cfg": "vpx_codec_enc_cfg_t",
              "deadline": "unsigned long",
              "init_flags": "unsigned long",
              "stats": "TwopassStatsStore"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual vpx_codec_iface_t *CodecInterface() const {\n#if CONFIG_VP8_ENCODER\n    return &vpx_codec_vp8_cx_algo;\n#else\n    return NULL;\n#endif\n  }",
          "fn_code_pos": [
            [
              102,
              2
            ],
            [
              108,
              3
            ]
          ],
          "class_code": "dcfb6a72661f34b80ebc25c83dd03cf5f7f28e7fe311bde08a0eb73bef712f2f",
          "class_node_pos": [
            [
              95,
              0
            ],
            [
              109,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CodecInterface",
            "parameters": {},
            "return_type": "vpx_codec_iface_t"
          }
        },
        {
          "fn_code": "VP8CodecFactory() : CodecFactory() {}",
          "fn_code_pos": [
            [
              113,
              2
            ],
            [
              113,
              39
            ]
          ],
          "class_code": "1bf05cd58409b0ff0a581c00a06a8abf90418bab1ba5e706322ca556d641cdee",
          "class_node_pos": [
            [
              111,
              0
            ],
            [
              155,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VP8CodecFactory",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual Decoder *CreateDecoder(vpx_codec_dec_cfg_t cfg) const {\n    return CreateDecoder(cfg, 0);\n  }",
          "fn_code_pos": [
            [
              115,
              2
            ],
            [
              117,
              3
            ]
          ],
          "class_code": "1bf05cd58409b0ff0a581c00a06a8abf90418bab1ba5e706322ca556d641cdee",
          "class_node_pos": [
            [
              111,
              0
            ],
            [
              155,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CreateDecoder",
            "parameters": {
              "cfg": "vpx_codec_dec_cfg_t"
            },
            "return_type": "Decoder"
          }
        },
        {
          "fn_code": "virtual Decoder *CreateDecoder(vpx_codec_dec_cfg_t cfg,\n                                 const vpx_codec_flags_t flags) const {\n#if CONFIG_VP8_DECODER\n    return new VP8Decoder(cfg, flags);\n#else\n    (void)cfg;\n    (void)flags;\n    return NULL;\n#endif\n  }",
          "fn_code_pos": [
            [
              119,
              2
            ],
            [
              128,
              3
            ]
          ],
          "class_code": "1bf05cd58409b0ff0a581c00a06a8abf90418bab1ba5e706322ca556d641cdee",
          "class_node_pos": [
            [
              111,
              0
            ],
            [
              155,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CreateDecoder",
            "parameters": {
              "cfg": "vpx_codec_dec_cfg_t",
              "flags": "vpx_codec_flags_t"
            },
            "return_type": "Decoder"
          }
        },
        {
          "fn_code": "virtual Encoder *CreateEncoder(vpx_codec_enc_cfg_t cfg,\n                                 unsigned long deadline,\n                                 const unsigned long init_flags,\n                                 TwopassStatsStore *stats) const {\n#if CONFIG_VP8_ENCODER\n    return new VP8Encoder(cfg, deadline, init_flags, stats);\n#else\n    (void)cfg;\n    (void)deadline;\n    (void)init_flags;\n    (void)stats;\n    return NULL;\n#endif\n  }",
          "fn_code_pos": [
            [
              130,
              2
            ],
            [
              143,
              3
            ]
          ],
          "class_code": "1bf05cd58409b0ff0a581c00a06a8abf90418bab1ba5e706322ca556d641cdee",
          "class_node_pos": [
            [
              111,
              0
            ],
            [
              155,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CreateEncoder",
            "parameters": {
              "cfg": "vpx_codec_enc_cfg_t",
              "deadline": "unsigned long",
              "init_flags": "unsigned long",
              "stats": "TwopassStatsStore"
            },
            "return_type": "Encoder"
          }
        },
        {
          "fn_code": "virtual vpx_codec_err_t DefaultEncoderConfig(vpx_codec_enc_cfg_t *cfg,\n                                               int usage) const {\n#if CONFIG_VP8_ENCODER\n    return vpx_codec_enc_config_default(&vpx_codec_vp8_cx_algo, cfg, usage);\n#else\n    (void)cfg;\n    (void)usage;\n    return VPX_CODEC_INCAPABLE;\n#endif\n  }",
          "fn_code_pos": [
            [
              145,
              2
            ],
            [
              154,
              3
            ]
          ],
          "class_code": "1bf05cd58409b0ff0a581c00a06a8abf90418bab1ba5e706322ca556d641cdee",
          "class_node_pos": [
            [
              111,
              0
            ],
            [
              155,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DefaultEncoderConfig",
            "parameters": {
              "cfg": "vpx_codec_enc_cfg_t",
              "usage": "int"
            },
            "return_type": "vpx_codec_err_t"
          }
        },
        {
          "fn_code": "explicit VP9Decoder(vpx_codec_dec_cfg_t cfg) : Decoder(cfg) {}",
          "fn_code_pos": [
            [
              176,
              2
            ],
            [
              176,
              64
            ]
          ],
          "class_code": "8bfbf67d5469d1707a26de4d2c14b58069cc670cc17cc3824aad64f53851acb4",
          "class_node_pos": [
            [
              174,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VP9Decoder",
            "parameters": {
              "cfg": "vpx_codec_dec_cfg_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "VP9Decoder(vpx_codec_dec_cfg_t cfg, const vpx_codec_flags_t flag)\n      : Decoder(cfg, flag) {}",
          "fn_code_pos": [
            [
              178,
              2
            ],
            [
              179,
              29
            ]
          ],
          "class_code": "8bfbf67d5469d1707a26de4d2c14b58069cc670cc17cc3824aad64f53851acb4",
          "class_node_pos": [
            [
              174,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VP9Decoder",
            "parameters": {
              "cfg": "vpx_codec_dec_cfg_t",
              "flag": "vpx_codec_flags_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual vpx_codec_iface_t *CodecInterface() const {\n#if CONFIG_VP9_DECODER\n    return &vpx_codec_vp9_dx_algo;\n#else\n    return NULL;\n#endif\n  }",
          "fn_code_pos": [
            [
              182,
              2
            ],
            [
              188,
              3
            ]
          ],
          "class_code": "8bfbf67d5469d1707a26de4d2c14b58069cc670cc17cc3824aad64f53851acb4",
          "class_node_pos": [
            [
              174,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CodecInterface",
            "parameters": {},
            "return_type": "vpx_codec_iface_t"
          }
        },
        {
          "fn_code": "VP9Encoder(vpx_codec_enc_cfg_t cfg, unsigned long deadline,\n             const unsigned long init_flags, TwopassStatsStore *stats)\n      : Encoder(cfg, deadline, init_flags, stats) {}",
          "fn_code_pos": [
            [
              193,
              2
            ],
            [
              195,
              52
            ]
          ],
          "class_code": "84431c79d5ef59d8c900b347c4e582f72bfc984bab69c3c5b2e9906def82d2db",
          "class_node_pos": [
            [
              191,
              0
            ],
            [
              205,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VP9Encoder",
            "parameters": {
              "cfg": "vpx_codec_enc_cfg_t",
              "deadline": "unsigned long",
              "init_flags": "unsigned long",
              "stats": "TwopassStatsStore"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual vpx_codec_iface_t *CodecInterface() const {\n#if CONFIG_VP9_ENCODER\n    return &vpx_codec_vp9_cx_algo;\n#else\n    return NULL;\n#endif\n  }",
          "fn_code_pos": [
            [
              198,
              2
            ],
            [
              204,
              3
            ]
          ],
          "class_code": "84431c79d5ef59d8c900b347c4e582f72bfc984bab69c3c5b2e9906def82d2db",
          "class_node_pos": [
            [
              191,
              0
            ],
            [
              205,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CodecInterface",
            "parameters": {},
            "return_type": "vpx_codec_iface_t"
          }
        },
        {
          "fn_code": "VP9CodecFactory() : CodecFactory() {}",
          "fn_code_pos": [
            [
              209,
              2
            ],
            [
              209,
              39
            ]
          ],
          "class_code": "b7d741e4a9f62422747d86a25f33452949ae1f90e5cf06aee7af25b402e47ef4",
          "class_node_pos": [
            [
              207,
              0
            ],
            [
              251,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "VP9CodecFactory",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual Decoder *CreateDecoder(vpx_codec_dec_cfg_t cfg) const {\n    return CreateDecoder(cfg, 0);\n  }",
          "fn_code_pos": [
            [
              211,
              2
            ],
            [
              213,
              3
            ]
          ],
          "class_code": "b7d741e4a9f62422747d86a25f33452949ae1f90e5cf06aee7af25b402e47ef4",
          "class_node_pos": [
            [
              207,
              0
            ],
            [
              251,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CreateDecoder",
            "parameters": {
              "cfg": "vpx_codec_dec_cfg_t"
            },
            "return_type": "Decoder"
          }
        },
        {
          "fn_code": "virtual Decoder *CreateDecoder(vpx_codec_dec_cfg_t cfg,\n                                 const vpx_codec_flags_t flags) const {\n#if CONFIG_VP9_DECODER\n    return new VP9Decoder(cfg, flags);\n#else\n    (void)cfg;\n    (void)flags;\n    return NULL;\n#endif\n  }",
          "fn_code_pos": [
            [
              215,
              2
            ],
            [
              224,
              3
            ]
          ],
          "class_code": "b7d741e4a9f62422747d86a25f33452949ae1f90e5cf06aee7af25b402e47ef4",
          "class_node_pos": [
            [
              207,
              0
            ],
            [
              251,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CreateDecoder",
            "parameters": {
              "cfg": "vpx_codec_dec_cfg_t",
              "flags": "vpx_codec_flags_t"
            },
            "return_type": "Decoder"
          }
        },
        {
          "fn_code": "virtual Encoder *CreateEncoder(vpx_codec_enc_cfg_t cfg,\n                                 unsigned long deadline,\n                                 const unsigned long init_flags,\n                                 TwopassStatsStore *stats) const {\n#if CONFIG_VP9_ENCODER\n    return new VP9Encoder(cfg, deadline, init_flags, stats);\n#else\n    (void)cfg;\n    (void)deadline;\n    (void)init_flags;\n    (void)stats;\n    return NULL;\n#endif\n  }",
          "fn_code_pos": [
            [
              226,
              2
            ],
            [
              239,
              3
            ]
          ],
          "class_code": "b7d741e4a9f62422747d86a25f33452949ae1f90e5cf06aee7af25b402e47ef4",
          "class_node_pos": [
            [
              207,
              0
            ],
            [
              251,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CreateEncoder",
            "parameters": {
              "cfg": "vpx_codec_enc_cfg_t",
              "deadline": "unsigned long",
              "init_flags": "unsigned long",
              "stats": "TwopassStatsStore"
            },
            "return_type": "Encoder"
          }
        },
        {
          "fn_code": "virtual vpx_codec_err_t DefaultEncoderConfig(vpx_codec_enc_cfg_t *cfg,\n                                               int usage) const {\n#if CONFIG_VP9_ENCODER\n    return vpx_codec_enc_config_default(&vpx_codec_vp9_cx_algo, cfg, usage);\n#else\n    (void)cfg;\n    (void)usage;\n    return VPX_CODEC_INCAPABLE;\n#endif\n  }",
          "fn_code_pos": [
            [
              241,
              2
            ],
            [
              250,
              3
            ]
          ],
          "class_code": "b7d741e4a9f62422747d86a25f33452949ae1f90e5cf06aee7af25b402e47ef4",
          "class_node_pos": [
            [
              207,
              0
            ],
            [
              251,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DefaultEncoderConfig",
            "parameters": {
              "cfg": "vpx_codec_enc_cfg_t",
              "usage": "int"
            },
            "return_type": "vpx_codec_err_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "CreateDecoder(vpx_codec_dec_cfg_t cfg) const",
          "fn_dec_pos": [
            [
              36,
              19
            ],
            [
              36,
              63
            ]
          ],
          "class_code": "6862dda723ed0b3a49eefb80115cc14db821f8e7c573ae5bb4ef0828cb13993c",
          "class_node_pos": [
            [
              30,
              0
            ],
            [
              48,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CreateDecoder",
            "parameters": {
              "cfg": "vpx_codec_dec_cfg_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CreateDecoder(vpx_codec_dec_cfg_t cfg,\n                                 const vpx_codec_flags_t flags) const",
          "fn_dec_pos": [
            [
              38,
              19
            ],
            [
              39,
              69
            ]
          ],
          "class_code": "6862dda723ed0b3a49eefb80115cc14db821f8e7c573ae5bb4ef0828cb13993c",
          "class_node_pos": [
            [
              30,
              0
            ],
            [
              48,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CreateDecoder",
            "parameters": {
              "cfg": "vpx_codec_dec_cfg_t",
              "flags": "vpx_codec_flags_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CreateEncoder(vpx_codec_enc_cfg_t cfg,\n                                 unsigned long deadline,\n                                 const unsigned long init_flags,\n                                 TwopassStatsStore *stats) const",
          "fn_dec_pos": [
            [
              41,
              19
            ],
            [
              44,
              64
            ]
          ],
          "class_code": "6862dda723ed0b3a49eefb80115cc14db821f8e7c573ae5bb4ef0828cb13993c",
          "class_node_pos": [
            [
              30,
              0
            ],
            [
              48,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CreateEncoder",
            "parameters": {
              "cfg": "vpx_codec_enc_cfg_t",
              "deadline": "unsigned long",
              "init_flags": "unsigned long",
              "stats": "TwopassStatsStore"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CodecInterface() const",
          "fn_dec_pos": [
            [
              86,
              29
            ],
            [
              86,
              51
            ]
          ],
          "class_code": "ab8d2bf5d0c03d369b02a41828c4e147d550443467218081dcdb880250f879f4",
          "class_node_pos": [
            [
              78,
              0
            ],
            [
              93,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CodecInterface",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CodecInterface() const",
          "fn_dec_pos": [
            [
              102,
              29
            ],
            [
              102,
              51
            ]
          ],
          "class_code": "dcfb6a72661f34b80ebc25c83dd03cf5f7f28e7fe311bde08a0eb73bef712f2f",
          "class_node_pos": [
            [
              95,
              0
            ],
            [
              109,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CodecInterface",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CreateDecoder(vpx_codec_dec_cfg_t cfg) const",
          "fn_dec_pos": [
            [
              115,
              19
            ],
            [
              115,
              63
            ]
          ],
          "class_code": "1bf05cd58409b0ff0a581c00a06a8abf90418bab1ba5e706322ca556d641cdee",
          "class_node_pos": [
            [
              111,
              0
            ],
            [
              155,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CreateDecoder",
            "parameters": {
              "cfg": "vpx_codec_dec_cfg_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CreateDecoder(vpx_codec_dec_cfg_t cfg,\n                                 const vpx_codec_flags_t flags) const",
          "fn_dec_pos": [
            [
              119,
              19
            ],
            [
              120,
              69
            ]
          ],
          "class_code": "1bf05cd58409b0ff0a581c00a06a8abf90418bab1ba5e706322ca556d641cdee",
          "class_node_pos": [
            [
              111,
              0
            ],
            [
              155,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CreateDecoder",
            "parameters": {
              "cfg": "vpx_codec_dec_cfg_t",
              "flags": "vpx_codec_flags_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CreateEncoder(vpx_codec_enc_cfg_t cfg,\n                                 unsigned long deadline,\n                                 const unsigned long init_flags,\n                                 TwopassStatsStore *stats) const",
          "fn_dec_pos": [
            [
              130,
              19
            ],
            [
              133,
              64
            ]
          ],
          "class_code": "1bf05cd58409b0ff0a581c00a06a8abf90418bab1ba5e706322ca556d641cdee",
          "class_node_pos": [
            [
              111,
              0
            ],
            [
              155,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CreateEncoder",
            "parameters": {
              "cfg": "vpx_codec_enc_cfg_t",
              "deadline": "unsigned long",
              "init_flags": "unsigned long",
              "stats": "TwopassStatsStore"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CodecInterface() const",
          "fn_dec_pos": [
            [
              182,
              29
            ],
            [
              182,
              51
            ]
          ],
          "class_code": "8bfbf67d5469d1707a26de4d2c14b58069cc670cc17cc3824aad64f53851acb4",
          "class_node_pos": [
            [
              174,
              0
            ],
            [
              189,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CodecInterface",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CodecInterface() const",
          "fn_dec_pos": [
            [
              198,
              29
            ],
            [
              198,
              51
            ]
          ],
          "class_code": "84431c79d5ef59d8c900b347c4e582f72bfc984bab69c3c5b2e9906def82d2db",
          "class_node_pos": [
            [
              191,
              0
            ],
            [
              205,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CodecInterface",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CreateDecoder(vpx_codec_dec_cfg_t cfg) const",
          "fn_dec_pos": [
            [
              211,
              19
            ],
            [
              211,
              63
            ]
          ],
          "class_code": "b7d741e4a9f62422747d86a25f33452949ae1f90e5cf06aee7af25b402e47ef4",
          "class_node_pos": [
            [
              207,
              0
            ],
            [
              251,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CreateDecoder",
            "parameters": {
              "cfg": "vpx_codec_dec_cfg_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CreateDecoder(vpx_codec_dec_cfg_t cfg,\n                                 const vpx_codec_flags_t flags) const",
          "fn_dec_pos": [
            [
              215,
              19
            ],
            [
              216,
              69
            ]
          ],
          "class_code": "b7d741e4a9f62422747d86a25f33452949ae1f90e5cf06aee7af25b402e47ef4",
          "class_node_pos": [
            [
              207,
              0
            ],
            [
              251,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CreateDecoder",
            "parameters": {
              "cfg": "vpx_codec_dec_cfg_t",
              "flags": "vpx_codec_flags_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CreateEncoder(vpx_codec_enc_cfg_t cfg,\n                                 unsigned long deadline,\n                                 const unsigned long init_flags,\n                                 TwopassStatsStore *stats) const",
          "fn_dec_pos": [
            [
              226,
              19
            ],
            [
              229,
              64
            ]
          ],
          "class_code": "b7d741e4a9f62422747d86a25f33452949ae1f90e5cf06aee7af25b402e47ef4",
          "class_node_pos": [
            [
              207,
              0
            ],
            [
              251,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CreateEncoder",
            "parameters": {
              "cfg": "vpx_codec_enc_cfg_t",
              "deadline": "unsigned long",
              "init_flags": "unsigned long",
              "stats": "TwopassStatsStore"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "6862dda723ed0b3a49eefb80115cc14db821f8e7c573ae5bb4ef0828cb13993c": {
          "class_code": "class CodecFactory {\n public:\n  CodecFactory() {}\n\n  virtual ~CodecFactory() {}\n\n  virtual Decoder *CreateDecoder(vpx_codec_dec_cfg_t cfg) const = 0;\n\n  virtual Decoder *CreateDecoder(vpx_codec_dec_cfg_t cfg,\n                                 const vpx_codec_flags_t flags) const = 0;\n\n  virtual Encoder *CreateEncoder(vpx_codec_enc_cfg_t cfg,\n                                 unsigned long deadline,\n                                 const unsigned long init_flags,\n                                 TwopassStatsStore *stats) const = 0;\n\n  virtual vpx_codec_err_t DefaultEncoderConfig(vpx_codec_enc_cfg_t *cfg,\n                                               int usage) const = 0;\n}",
          "class_name": "CodecFactory",
          "class_pos": [
            [
              30,
              0
            ],
            [
              48,
              1
            ]
          ]
        },
        "9967cd7a3a988adcb6c9248fb4da269de2b9890abbecb395cb41f7dd856b931e": {
          "class_code": "template <class T1>\nclass CodecTestWithParam\n    : public ::testing::TestWithParam<\n          std::tuple<const libvpx_test::CodecFactory *, T1> > {};",
          "class_name": "CodecTestWithParam",
          "class_pos": [
            [
              54,
              0
            ],
            [
              57,
              65
            ]
          ]
        },
        "3cb3bf458b5979da7c8ba39d3722a0f3064ed312e4118fa025321e8b8aa52f7c": {
          "class_code": "template <class T1, class T2>\nclass CodecTestWith2Params\n    : public ::testing::TestWithParam<\n          std::tuple<const libvpx_test::CodecFactory *, T1, T2> > {};",
          "class_name": "CodecTestWith2Params",
          "class_pos": [
            [
              59,
              0
            ],
            [
              62,
              69
            ]
          ]
        },
        "dacb0f246d2881cdad7e172ce5702f2bbed62214a251977a733ae309f3adad58": {
          "class_code": "template <class T1, class T2, class T3>\nclass CodecTestWith3Params\n    : public ::testing::TestWithParam<\n          std::tuple<const libvpx_test::CodecFactory *, T1, T2, T3> > {};",
          "class_name": "CodecTestWith3Params",
          "class_pos": [
            [
              64,
              0
            ],
            [
              67,
              73
            ]
          ]
        },
        "ed049688a14e616efe71f73288744eb060a03cd7d5364315315543be46d21eea": {
          "class_code": "template <class T1, class T2, class T3, class T4>\nclass CodecTestWith4Params\n    : public ::testing::TestWithParam<\n          std::tuple<const libvpx_test::CodecFactory *, T1, T2, T3, T4> > {};",
          "class_name": "CodecTestWith4Params",
          "class_pos": [
            [
              69,
              0
            ],
            [
              72,
              77
            ]
          ]
        },
        "ab8d2bf5d0c03d369b02a41828c4e147d550443467218081dcdb880250f879f4": {
          "class_code": "class VP8Decoder : public Decoder {\n public:\n  explicit VP8Decoder(vpx_codec_dec_cfg_t cfg) : Decoder(cfg) {}\n\n  VP8Decoder(vpx_codec_dec_cfg_t cfg, const vpx_codec_flags_t flag)\n      : Decoder(cfg, flag) {}\n\n protected:\n  virtual vpx_codec_iface_t *CodecInterface() const {\n#if CONFIG_VP8_DECODER\n    return &vpx_codec_vp8_dx_algo;\n#else\n    return NULL;\n#endif\n  }\n}",
          "class_name": "VP8Decoder",
          "class_pos": [
            [
              78,
              0
            ],
            [
              93,
              1
            ]
          ]
        },
        "dcfb6a72661f34b80ebc25c83dd03cf5f7f28e7fe311bde08a0eb73bef712f2f": {
          "class_code": "class VP8Encoder : public Encoder {\n public:\n  VP8Encoder(vpx_codec_enc_cfg_t cfg, unsigned long deadline,\n             const unsigned long init_flags, TwopassStatsStore *stats)\n      : Encoder(cfg, deadline, init_flags, stats) {}\n\n protected:\n  virtual vpx_codec_iface_t *CodecInterface() const {\n#if CONFIG_VP8_ENCODER\n    return &vpx_codec_vp8_cx_algo;\n#else\n    return NULL;\n#endif\n  }\n}",
          "class_name": "VP8Encoder",
          "class_pos": [
            [
              95,
              0
            ],
            [
              109,
              1
            ]
          ]
        },
        "1bf05cd58409b0ff0a581c00a06a8abf90418bab1ba5e706322ca556d641cdee": {
          "class_code": "class VP8CodecFactory : public CodecFactory {\n public:\n  VP8CodecFactory() : CodecFactory() {}\n\n  virtual Decoder *CreateDecoder(vpx_codec_dec_cfg_t cfg) const {\n    return CreateDecoder(cfg, 0);\n  }\n\n  virtual Decoder *CreateDecoder(vpx_codec_dec_cfg_t cfg,\n                                 const vpx_codec_flags_t flags) const {\n#if CONFIG_VP8_DECODER\n    return new VP8Decoder(cfg, flags);\n#else\n    (void)cfg;\n    (void)flags;\n    return NULL;\n#endif\n  }\n\n  virtual Encoder *CreateEncoder(vpx_codec_enc_cfg_t cfg,\n                                 unsigned long deadline,\n                                 const unsigned long init_flags,\n                                 TwopassStatsStore *stats) const {\n#if CONFIG_VP8_ENCODER\n    return new VP8Encoder(cfg, deadline, init_flags, stats);\n#else\n    (void)cfg;\n    (void)deadline;\n    (void)init_flags;\n    (void)stats;\n    return NULL;\n#endif\n  }\n\n  virtual vpx_codec_err_t DefaultEncoderConfig(vpx_codec_enc_cfg_t *cfg,\n                                               int usage) const {\n#if CONFIG_VP8_ENCODER\n    return vpx_codec_enc_config_default(&vpx_codec_vp8_cx_algo, cfg, usage);\n#else\n    (void)cfg;\n    (void)usage;\n    return VPX_CODEC_INCAPABLE;\n#endif\n  }\n}",
          "class_name": "VP8CodecFactory",
          "class_pos": [
            [
              111,
              0
            ],
            [
              155,
              1
            ]
          ]
        },
        "8bfbf67d5469d1707a26de4d2c14b58069cc670cc17cc3824aad64f53851acb4": {
          "class_code": "class VP9Decoder : public Decoder {\n public:\n  explicit VP9Decoder(vpx_codec_dec_cfg_t cfg) : Decoder(cfg) {}\n\n  VP9Decoder(vpx_codec_dec_cfg_t cfg, const vpx_codec_flags_t flag)\n      : Decoder(cfg, flag) {}\n\n protected:\n  virtual vpx_codec_iface_t *CodecInterface() const {\n#if CONFIG_VP9_DECODER\n    return &vpx_codec_vp9_dx_algo;\n#else\n    return NULL;\n#endif\n  }\n}",
          "class_name": "VP9Decoder",
          "class_pos": [
            [
              174,
              0
            ],
            [
              189,
              1
            ]
          ]
        },
        "84431c79d5ef59d8c900b347c4e582f72bfc984bab69c3c5b2e9906def82d2db": {
          "class_code": "class VP9Encoder : public Encoder {\n public:\n  VP9Encoder(vpx_codec_enc_cfg_t cfg, unsigned long deadline,\n             const unsigned long init_flags, TwopassStatsStore *stats)\n      : Encoder(cfg, deadline, init_flags, stats) {}\n\n protected:\n  virtual vpx_codec_iface_t *CodecInterface() const {\n#if CONFIG_VP9_ENCODER\n    return &vpx_codec_vp9_cx_algo;\n#else\n    return NULL;\n#endif\n  }\n}",
          "class_name": "VP9Encoder",
          "class_pos": [
            [
              191,
              0
            ],
            [
              205,
              1
            ]
          ]
        },
        "b7d741e4a9f62422747d86a25f33452949ae1f90e5cf06aee7af25b402e47ef4": {
          "class_code": "class VP9CodecFactory : public CodecFactory {\n public:\n  VP9CodecFactory() : CodecFactory() {}\n\n  virtual Decoder *CreateDecoder(vpx_codec_dec_cfg_t cfg) const {\n    return CreateDecoder(cfg, 0);\n  }\n\n  virtual Decoder *CreateDecoder(vpx_codec_dec_cfg_t cfg,\n                                 const vpx_codec_flags_t flags) const {\n#if CONFIG_VP9_DECODER\n    return new VP9Decoder(cfg, flags);\n#else\n    (void)cfg;\n    (void)flags;\n    return NULL;\n#endif\n  }\n\n  virtual Encoder *CreateEncoder(vpx_codec_enc_cfg_t cfg,\n                                 unsigned long deadline,\n                                 const unsigned long init_flags,\n                                 TwopassStatsStore *stats) const {\n#if CONFIG_VP9_ENCODER\n    return new VP9Encoder(cfg, deadline, init_flags, stats);\n#else\n    (void)cfg;\n    (void)deadline;\n    (void)init_flags;\n    (void)stats;\n    return NULL;\n#endif\n  }\n\n  virtual vpx_codec_err_t DefaultEncoderConfig(vpx_codec_enc_cfg_t *cfg,\n                                               int usage) const {\n#if CONFIG_VP9_ENCODER\n    return vpx_codec_enc_config_default(&vpx_codec_vp9_cx_algo, cfg, usage);\n#else\n    (void)cfg;\n    (void)usage;\n    return VPX_CODEC_INCAPABLE;\n#endif\n  }\n}",
          "class_name": "VP9CodecFactory",
          "class_pos": [
            [
              207,
              0
            ],
            [
              251,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <tuple>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_decoder.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_encoder.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"vpx/vp8cx.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"vpx/vp8dx.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"test/decode_test_driver.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/md5_helper.h": {
      "fn_def_list": [
        {
          "fn_code": "MD5() { MD5Init(&md5_); }",
          "fn_code_pos": [
            [
              19,
              2
            ],
            [
              19,
              27
            ]
          ],
          "class_code": "3f4d2efa4c5afb0afc1eb798a048706024175d6e02576714217b03ffd54c5b02",
          "class_node_pos": [
            [
              17,
              0
            ],
            [
              70,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MD5",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void Add(const vpx_image_t *img) {\n    for (int plane = 0; plane < 3; ++plane) {\n      const uint8_t *buf = img->planes[plane];\n      // Calculate the width and height to do the md5 check. For the chroma\n      // plane, we never want to round down and thus skip a pixel so if\n      // we are shifting by 1 (chroma_shift) we add 1 before doing the shift.\n      // This works only for chroma_shift of 0 and 1.\n      const int bytes_per_sample =\n          (img->fmt & VPX_IMG_FMT_HIGHBITDEPTH) ? 2 : 1;\n      const int h =\n          plane ? (img->d_h + img->y_chroma_shift) >> img->y_chroma_shift\n                : img->d_h;\n      const int w =\n          (plane ? (img->d_w + img->x_chroma_shift) >> img->x_chroma_shift\n                 : img->d_w) *\n          bytes_per_sample;\n\n      for (int y = 0; y < h; ++y) {\n        MD5Update(&md5_, buf, w);\n        buf += img->stride[plane];\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              21,
              2
            ],
            [
              43,
              3
            ]
          ],
          "class_code": "3f4d2efa4c5afb0afc1eb798a048706024175d6e02576714217b03ffd54c5b02",
          "class_node_pos": [
            [
              17,
              0
            ],
            [
              70,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Add",
            "parameters": {
              "img": "vpx_image_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void Add(const uint8_t *data, size_t size) {\n    MD5Update(&md5_, data, static_cast<uint32_t>(size));\n  }",
          "fn_code_pos": [
            [
              45,
              2
            ],
            [
              47,
              3
            ]
          ],
          "class_code": "3f4d2efa4c5afb0afc1eb798a048706024175d6e02576714217b03ffd54c5b02",
          "class_node_pos": [
            [
              17,
              0
            ],
            [
              70,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Add",
            "parameters": {
              "data": "uint8_t",
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "const char *Get(void) {\n    static const char hex[16] = {\n      '0', '1', '2', '3', '4', '5', '6', '7',\n      '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',\n    };\n    uint8_t tmp[16];\n    MD5Context ctx_tmp = md5_;\n\n    MD5Final(tmp, &ctx_tmp);\n    for (int i = 0; i < 16; i++) {\n      res_[i * 2 + 0] = hex[tmp[i] >> 4];\n      res_[i * 2 + 1] = hex[tmp[i] & 0xf];\n    }\n    res_[32] = 0;\n\n    return res_;\n  }",
          "fn_code_pos": [
            [
              49,
              2
            ],
            [
              65,
              3
            ]
          ],
          "class_code": "3f4d2efa4c5afb0afc1eb798a048706024175d6e02576714217b03ffd54c5b02",
          "class_node_pos": [
            [
              17,
              0
            ],
            [
              70,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Get",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "Get(void)",
          "fn_dec_pos": [
            [
              49,
              14
            ],
            [
              49,
              23
            ]
          ],
          "class_code": "3f4d2efa4c5afb0afc1eb798a048706024175d6e02576714217b03ffd54c5b02",
          "class_node_pos": [
            [
              17,
              0
            ],
            [
              70,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Get",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "3f4d2efa4c5afb0afc1eb798a048706024175d6e02576714217b03ffd54c5b02": {
          "class_code": "class MD5 {\n public:\n  MD5() { MD5Init(&md5_); }\n\n  void Add(const vpx_image_t *img) {\n    for (int plane = 0; plane < 3; ++plane) {\n      const uint8_t *buf = img->planes[plane];\n      // Calculate the width and height to do the md5 check. For the chroma\n      // plane, we never want to round down and thus skip a pixel so if\n      // we are shifting by 1 (chroma_shift) we add 1 before doing the shift.\n      // This works only for chroma_shift of 0 and 1.\n      const int bytes_per_sample =\n          (img->fmt & VPX_IMG_FMT_HIGHBITDEPTH) ? 2 : 1;\n      const int h =\n          plane ? (img->d_h + img->y_chroma_shift) >> img->y_chroma_shift\n                : img->d_h;\n      const int w =\n          (plane ? (img->d_w + img->x_chroma_shift) >> img->x_chroma_shift\n                 : img->d_w) *\n          bytes_per_sample;\n\n      for (int y = 0; y < h; ++y) {\n        MD5Update(&md5_, buf, w);\n        buf += img->stride[plane];\n      }\n    }\n  }\n\n  void Add(const uint8_t *data, size_t size) {\n    MD5Update(&md5_, data, static_cast<uint32_t>(size));\n  }\n\n  const char *Get(void) {\n    static const char hex[16] = {\n      '0', '1', '2', '3', '4', '5', '6', '7',\n      '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',\n    };\n    uint8_t tmp[16];\n    MD5Context ctx_tmp = md5_;\n\n    MD5Final(tmp, &ctx_tmp);\n    for (int i = 0; i < 16; i++) {\n      res_[i * 2 + 0] = hex[tmp[i] >> 4];\n      res_[i * 2 + 1] = hex[tmp[i] & 0xf];\n    }\n    res_[32] = 0;\n\n    return res_;\n  }\n\n protected:\n  char res_[33];\n  MD5Context md5_;\n}",
          "class_name": "MD5",
          "class_pos": [
            [
              17,
              0
            ],
            [
              70,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"./md5_utils.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_decoder.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/i420_video_source.h": {
      "fn_def_list": [
        {
          "fn_code": "I420VideoSource(const std::string &file_name, unsigned int width,\n                  unsigned int height, int rate_numerator, int rate_denominator,\n                  unsigned int start, int limit)\n      : YUVVideoSource(file_name, VPX_IMG_FMT_I420, width, height,\n                       rate_numerator, rate_denominator, start, limit) {}",
          "fn_code_pos": [
            [
              23,
              2
            ],
            [
              27,
              73
            ]
          ],
          "class_code": "9ea8ee66b7f02b1186461302454735db9f42d9766cdfe69cf0cf0216e7b88434",
          "class_node_pos": [
            [
              21,
              0
            ],
            [
              28,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "I420VideoSource",
            "parameters": {
              "file_name": "std::string",
              "width": "unsigned int",
              "height": "unsigned int",
              "rate_numerator": "int",
              "rate_denominator": "int",
              "start": "unsigned int",
              "limit": "int"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "9ea8ee66b7f02b1186461302454735db9f42d9766cdfe69cf0cf0216e7b88434": {
          "class_code": "class I420VideoSource : public YUVVideoSource {\n public:\n  I420VideoSource(const std::string &file_name, unsigned int width,\n                  unsigned int height, int rate_numerator, int rate_denominator,\n                  unsigned int start, int limit)\n      : YUVVideoSource(file_name, VPX_IMG_FMT_I420, width, height,\n                       rate_numerator, rate_denominator, start, limit) {}\n}",
          "class_name": "I420VideoSource",
          "class_pos": [
            [
              21,
              0
            ],
            [
              28,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <cstdio>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <cstdlib>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/yuv_video_source.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/acm_random.h": {
      "fn_def_list": [
        {
          "fn_code": "ACMRandom() : random_(DeterministicSeed()) {}",
          "fn_code_pos": [
            [
              25,
              2
            ],
            [
              25,
              47
            ]
          ],
          "class_code": "93fd18e9209a909dc69a4458cbd97900b2bca663b90accf336b7e66feb613a7c",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              89,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ACMRandom",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "explicit ACMRandom(int seed) : random_(seed) {}",
          "fn_code_pos": [
            [
              27,
              2
            ],
            [
              27,
              49
            ]
          ],
          "class_code": "93fd18e9209a909dc69a4458cbd97900b2bca663b90accf336b7e66feb613a7c",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              89,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ACMRandom",
            "parameters": {
              "seed": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void Reset(int seed) { random_.Reseed(seed); }",
          "fn_code_pos": [
            [
              29,
              2
            ],
            [
              29,
              48
            ]
          ],
          "class_code": "93fd18e9209a909dc69a4458cbd97900b2bca663b90accf336b7e66feb613a7c",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              89,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Reset",
            "parameters": {
              "seed": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "uint16_t Rand16(void) {\n    const uint32_t value =\n        random_.Generate(testing::internal::Random::kMaxRange);\n    return (value >> 15) & 0xffff;\n  }",
          "fn_code_pos": [
            [
              30,
              2
            ],
            [
              34,
              3
            ]
          ],
          "class_code": "93fd18e9209a909dc69a4458cbd97900b2bca663b90accf336b7e66feb613a7c",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              89,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Rand16",
            "parameters": {},
            "return_type": "uint16_t"
          }
        },
        {
          "fn_code": "int32_t Rand20Signed(void) {\n    // Use 20 bits: values between 524287 and -524288.\n    const uint32_t value = random_.Generate(1048576);\n    return static_cast<int32_t>(value) - 524288;\n  }",
          "fn_code_pos": [
            [
              36,
              2
            ],
            [
              40,
              3
            ]
          ],
          "class_code": "93fd18e9209a909dc69a4458cbd97900b2bca663b90accf336b7e66feb613a7c",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              89,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Rand20Signed",
            "parameters": {},
            "return_type": "int32_t"
          }
        },
        {
          "fn_code": "int16_t Rand16Signed(void) {\n    // Use 16 bits: values between 32767 and -32768.\n    const uint32_t value = random_.Generate(65536);\n    return static_cast<int16_t>(value) - 32768;\n  }",
          "fn_code_pos": [
            [
              42,
              2
            ],
            [
              46,
              3
            ]
          ],
          "class_code": "93fd18e9209a909dc69a4458cbd97900b2bca663b90accf336b7e66feb613a7c",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              89,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Rand16Signed",
            "parameters": {},
            "return_type": "int16_t"
          }
        },
        {
          "fn_code": "int16_t Rand13Signed(void) {\n    // Use 13 bits: values between 4095 and -4096.\n    const uint32_t value = random_.Generate(8192);\n    return static_cast<int16_t>(value) - 4096;\n  }",
          "fn_code_pos": [
            [
              48,
              2
            ],
            [
              52,
              3
            ]
          ],
          "class_code": "93fd18e9209a909dc69a4458cbd97900b2bca663b90accf336b7e66feb613a7c",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              89,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Rand13Signed",
            "parameters": {},
            "return_type": "int16_t"
          }
        },
        {
          "fn_code": "int16_t Rand9Signed(void) {\n    // Use 9 bits: values between 255 (0x0FF) and -256 (0x100).\n    const uint32_t value = random_.Generate(512);\n    return static_cast<int16_t>(value) - 256;\n  }",
          "fn_code_pos": [
            [
              54,
              2
            ],
            [
              58,
              3
            ]
          ],
          "class_code": "93fd18e9209a909dc69a4458cbd97900b2bca663b90accf336b7e66feb613a7c",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              89,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Rand9Signed",
            "parameters": {},
            "return_type": "int16_t"
          }
        },
        {
          "fn_code": "uint8_t Rand8(void) {\n    const uint32_t value =\n        random_.Generate(testing::internal::Random::kMaxRange);\n    // There's a bit more entropy in the upper bits of this implementation.\n    return (value >> 23) & 0xff;\n  }",
          "fn_code_pos": [
            [
              60,
              2
            ],
            [
              65,
              3
            ]
          ],
          "class_code": "93fd18e9209a909dc69a4458cbd97900b2bca663b90accf336b7e66feb613a7c",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              89,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Rand8",
            "parameters": {},
            "return_type": "uint8_t"
          }
        },
        {
          "fn_code": "uint8_t Rand8Extremes(void) {\n    // Returns a random value near 0 or near 255, to better exercise\n    // saturation behavior.\n    const uint8_t r = Rand8();\n    return r < 128 ? r << 4 : r >> 4;\n  }",
          "fn_code_pos": [
            [
              67,
              2
            ],
            [
              72,
              3
            ]
          ],
          "class_code": "93fd18e9209a909dc69a4458cbd97900b2bca663b90accf336b7e66feb613a7c",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              89,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Rand8Extremes",
            "parameters": {},
            "return_type": "uint8_t"
          }
        },
        {
          "fn_code": "uint32_t RandRange(const uint32_t range) {\n    // testing::internal::Random::Generate provides values in the range\n    // testing::internal::Random::kMaxRange.\n    assert(range <= testing::internal::Random::kMaxRange);\n    return random_.Generate(range);\n  }",
          "fn_code_pos": [
            [
              74,
              2
            ],
            [
              79,
              3
            ]
          ],
          "class_code": "93fd18e9209a909dc69a4458cbd97900b2bca663b90accf336b7e66feb613a7c",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              89,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RandRange",
            "parameters": {
              "range": "uint32_t"
            },
            "return_type": "uint32_t"
          }
        },
        {
          "fn_code": "int PseudoUniform(int range) { return random_.Generate(range); }",
          "fn_code_pos": [
            [
              81,
              2
            ],
            [
              81,
              66
            ]
          ],
          "class_code": "93fd18e9209a909dc69a4458cbd97900b2bca663b90accf336b7e66feb613a7c",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              89,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PseudoUniform",
            "parameters": {
              "range": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int operator()(int n) { return PseudoUniform(n); }",
          "fn_code_pos": [
            [
              83,
              2
            ],
            [
              83,
              52
            ]
          ],
          "class_code": "93fd18e9209a909dc69a4458cbd97900b2bca663b90accf336b7e66feb613a7c",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              89,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "n": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int DeterministicSeed(void) { return 0xbaba; }",
          "fn_code_pos": [
            [
              85,
              2
            ],
            [
              85,
              55
            ]
          ],
          "class_code": "93fd18e9209a909dc69a4458cbd97900b2bca663b90accf336b7e66feb613a7c",
          "class_node_pos": [
            [
              23,
              0
            ],
            [
              89,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DeterministicSeed",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "93fd18e9209a909dc69a4458cbd97900b2bca663b90accf336b7e66feb613a7c": {
          "class_code": "class ACMRandom {\n public:\n  ACMRandom() : random_(DeterministicSeed()) {}\n\n  explicit ACMRandom(int seed) : random_(seed) {}\n\n  void Reset(int seed) { random_.Reseed(seed); }\n  uint16_t Rand16(void) {\n    const uint32_t value =\n        random_.Generate(testing::internal::Random::kMaxRange);\n    return (value >> 15) & 0xffff;\n  }\n\n  int32_t Rand20Signed(void) {\n    // Use 20 bits: values between 524287 and -524288.\n    const uint32_t value = random_.Generate(1048576);\n    return static_cast<int32_t>(value) - 524288;\n  }\n\n  int16_t Rand16Signed(void) {\n    // Use 16 bits: values between 32767 and -32768.\n    const uint32_t value = random_.Generate(65536);\n    return static_cast<int16_t>(value) - 32768;\n  }\n\n  int16_t Rand13Signed(void) {\n    // Use 13 bits: values between 4095 and -4096.\n    const uint32_t value = random_.Generate(8192);\n    return static_cast<int16_t>(value) - 4096;\n  }\n\n  int16_t Rand9Signed(void) {\n    // Use 9 bits: values between 255 (0x0FF) and -256 (0x100).\n    const uint32_t value = random_.Generate(512);\n    return static_cast<int16_t>(value) - 256;\n  }\n\n  uint8_t Rand8(void) {\n    const uint32_t value =\n        random_.Generate(testing::internal::Random::kMaxRange);\n    // There's a bit more entropy in the upper bits of this implementation.\n    return (value >> 23) & 0xff;\n  }\n\n  uint8_t Rand8Extremes(void) {\n    // Returns a random value near 0 or near 255, to better exercise\n    // saturation behavior.\n    const uint8_t r = Rand8();\n    return r < 128 ? r << 4 : r >> 4;\n  }\n\n  uint32_t RandRange(const uint32_t range) {\n    // testing::internal::Random::Generate provides values in the range\n    // testing::internal::Random::kMaxRange.\n    assert(range <= testing::internal::Random::kMaxRange);\n    return random_.Generate(range);\n  }\n\n  int PseudoUniform(int range) { return random_.Generate(range); }\n\n  int operator()(int n) { return PseudoUniform(n); }\n\n  static int DeterministicSeed(void) { return 0xbaba; }\n\n private:\n  testing::internal::Random random_;\n}",
          "class_name": "ACMRandom",
          "class_pos": [
            [
              23,
              0
            ],
            [
              89,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <assert.h>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <limits>\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/svc_test.h": {
      "fn_def_list": [
        {
          "fn_code": "explicit OnePassCbrSvc(const ::libvpx_test::CodecFactory *codec)\n      : EncoderTest(codec), base_speed_setting_(0), speed_setting_(0),\n        superframe_count_(0), temporal_layer_id_(0), number_temporal_layers_(0),\n        number_spatial_layers_(0) {\n    memset(&svc_params_, 0, sizeof(svc_params_));\n    memset(bits_in_buffer_model_, 0,\n           sizeof(bits_in_buffer_model_[0]) * VPX_MAX_LAYERS);\n    memset(layer_target_avg_bandwidth_, 0,\n           sizeof(layer_target_avg_bandwidth_[0]) * VPX_MAX_LAYERS);\n  }",
          "fn_code_pos": [
            [
              26,
              2
            ],
            [
              35,
              3
            ]
          ],
          "class_code": "eff1d7b42c5f0a0cba2d1a57422e51c68f7b8f04f0160d14df11fc8a0860c56f",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              63,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "OnePassCbrSvc",
            "parameters": {
              "codec": "::libvpx_test::CodecFactory"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~OnePassCbrSvc() {}",
          "fn_code_pos": [
            [
              38,
              2
            ],
            [
              38,
              29
            ]
          ],
          "class_code": "eff1d7b42c5f0a0cba2d1a57422e51c68f7b8f04f0160d14df11fc8a0860c56f",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              63,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetConfig(const int num_temporal_layer) = 0;",
          "fn_code_pos": [
            [
              40,
              2
            ],
            [
              40,
              59
            ]
          ],
          "class_code": "eff1d7b42c5f0a0cba2d1a57422e51c68f7b8f04f0160d14df11fc8a0860c56f",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              63,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetConfig",
            "parameters": {
              "num_temporal_layer": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void MismatchHook(const vpx_image_t *, const vpx_image_t *) {}",
          "fn_code_pos": [
            [
              52,
              2
            ],
            [
              52,
              72
            ]
          ],
          "class_code": "eff1d7b42c5f0a0cba2d1a57422e51c68f7b8f04f0160d14df11fc8a0860c56f",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              63,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "MismatchHook",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "SetSvcConfig(const int num_spatial_layer,\n                            const int num_temporal_layer)",
          "fn_dec_pos": [
            [
              42,
              15
            ],
            [
              43,
              57
            ]
          ],
          "class_code": "eff1d7b42c5f0a0cba2d1a57422e51c68f7b8f04f0160d14df11fc8a0860c56f",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              63,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetSvcConfig",
            "parameters": {
              "num_spatial_layer": "int",
              "num_temporal_layer": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "PreEncodeFrameHookSetup(::libvpx_test::VideoSource *video,\n                                       ::libvpx_test::Encoder *encoder)",
          "fn_dec_pos": [
            [
              45,
              15
            ],
            [
              46,
              71
            ]
          ],
          "class_code": "eff1d7b42c5f0a0cba2d1a57422e51c68f7b8f04f0160d14df11fc8a0860c56f",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              63,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PreEncodeFrameHookSetup",
            "parameters": {
              "video": "::libvpx_test::VideoSource",
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "PostEncodeFrameHook(::libvpx_test::Encoder *encoder)",
          "fn_dec_pos": [
            [
              48,
              15
            ],
            [
              48,
              67
            ]
          ],
          "class_code": "eff1d7b42c5f0a0cba2d1a57422e51c68f7b8f04f0160d14df11fc8a0860c56f",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              63,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PostEncodeFrameHook",
            "parameters": {
              "encoder": "::libvpx_test::Encoder"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "AssignLayerBitrates()",
          "fn_dec_pos": [
            [
              50,
              15
            ],
            [
              50,
              36
            ]
          ],
          "class_code": "eff1d7b42c5f0a0cba2d1a57422e51c68f7b8f04f0160d14df11fc8a0860c56f",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              63,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "AssignLayerBitrates",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {
        "eff1d7b42c5f0a0cba2d1a57422e51c68f7b8f04f0160d14df11fc8a0860c56f": {
          "class_code": "class OnePassCbrSvc : public ::libvpx_test::EncoderTest {\n public:\n  explicit OnePassCbrSvc(const ::libvpx_test::CodecFactory *codec)\n      : EncoderTest(codec), base_speed_setting_(0), speed_setting_(0),\n        superframe_count_(0), temporal_layer_id_(0), number_temporal_layers_(0),\n        number_spatial_layers_(0) {\n    memset(&svc_params_, 0, sizeof(svc_params_));\n    memset(bits_in_buffer_model_, 0,\n           sizeof(bits_in_buffer_model_[0]) * VPX_MAX_LAYERS);\n    memset(layer_target_avg_bandwidth_, 0,\n           sizeof(layer_target_avg_bandwidth_[0]) * VPX_MAX_LAYERS);\n  }\n\n protected:\n  virtual ~OnePassCbrSvc() {}\n\n  virtual void SetConfig(const int num_temporal_layer) = 0;\n\n  virtual void SetSvcConfig(const int num_spatial_layer,\n                            const int num_temporal_layer);\n\n  virtual void PreEncodeFrameHookSetup(::libvpx_test::VideoSource *video,\n                                       ::libvpx_test::Encoder *encoder);\n\n  virtual void PostEncodeFrameHook(::libvpx_test::Encoder *encoder);\n\n  virtual void AssignLayerBitrates();\n\n  virtual void MismatchHook(const vpx_image_t *, const vpx_image_t *) {}\n\n  vpx_svc_extra_cfg_t svc_params_;\n  int64_t bits_in_buffer_model_[VPX_MAX_LAYERS];\n  int layer_target_avg_bandwidth_[VPX_MAX_LAYERS];\n  int base_speed_setting_;\n  int speed_setting_;\n  int superframe_count_;\n  int temporal_layer_id_;\n  int number_temporal_layers_;\n  int number_spatial_layers_;\n}",
          "class_name": "OnePassCbrSvc",
          "class_pos": [
            [
              24,
              0
            ],
            [
              63,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"./vpx_config.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/codec_factory.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"test/encode_test_driver.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/i420_video_source.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/util.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/y4m_video_source.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_codec.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"vpx_ports/bitops.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/register_state_check.h": {
      "fn_def_list": [
        {
          "fn_code": "inline bool operator==(const M128A &lhs, const M128A &rhs) {\n  return (lhs.Low == rhs.Low && lhs.High == rhs.High);\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              42,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "lhs": "M128A",
              "rhs": "M128A"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "RegisterStateCheck() { initialized_ = StoreRegisters(&pre_context_); }",
          "fn_code_pos": [
            [
              51,
              2
            ],
            [
              51,
              72
            ]
          ],
          "class_code": "2f9fb7de0845911a4b8f302c7eac8595a15bf1b1ea496240622b8a3ca23cffec",
          "class_node_pos": [
            [
              49,
              0
            ],
            [
              81,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RegisterStateCheck",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~RegisterStateCheck() { Check(); }",
          "fn_code_pos": [
            [
              52,
              2
            ],
            [
              52,
              36
            ]
          ],
          "class_code": "2f9fb7de0845911a4b8f302c7eac8595a15bf1b1ea496240622b8a3ca23cffec",
          "class_node_pos": [
            [
              49,
              0
            ],
            [
              81,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static bool StoreRegisters(CONTEXT *const context) {\n    const HANDLE this_thread = GetCurrentThread();\n    EXPECT_TRUE(this_thread != NULL);\n    context->ContextFlags = CONTEXT_FLOATING_POINT;\n    const bool context_saved = GetThreadContext(this_thread, context) == TRUE;\n    EXPECT_TRUE(context_saved) << \"GetLastError: \" << GetLastError();\n    return context_saved;\n  }",
          "fn_code_pos": [
            [
              55,
              2
            ],
            [
              62,
              3
            ]
          ],
          "class_code": "2f9fb7de0845911a4b8f302c7eac8595a15bf1b1ea496240622b8a3ca23cffec",
          "class_node_pos": [
            [
              49,
              0
            ],
            [
              81,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "StoreRegisters",
            "parameters": {
              "context": "CONTEXT"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "void Check() const {\n    ASSERT_TRUE(initialized_);\n    CONTEXT post_context;\n    ASSERT_TRUE(StoreRegisters(&post_context));\n\n    const M128A *xmm_pre = &pre_context_.Xmm6;\n    const M128A *xmm_post = &post_context.Xmm6;\n    for (int i = 6; i <= 15; ++i) {\n      EXPECT_EQ(*xmm_pre, *xmm_post) << \"xmm\" << i << \" has been modified!\";\n      ++xmm_pre;\n      ++xmm_post;\n    }\n  }",
          "fn_code_pos": [
            [
              65,
              2
            ],
            [
              77,
              3
            ]
          ],
          "class_code": "2f9fb7de0845911a4b8f302c7eac8595a15bf1b1ea496240622b8a3ca23cffec",
          "class_node_pos": [
            [
              49,
              0
            ],
            [
              81,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Check",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "RegisterStateCheck() { vpx_push_neon(pre_store_); }",
          "fn_code_pos": [
            [
              106,
              2
            ],
            [
              106,
              53
            ]
          ],
          "class_code": "6b5fbaa0a03a3f8795c5fc834562d494850c69807556d066a22b1fa9de2a8950",
          "class_node_pos": [
            [
              104,
              0
            ],
            [
              121,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RegisterStateCheck",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~RegisterStateCheck() { Check(); }",
          "fn_code_pos": [
            [
              107,
              2
            ],
            [
              107,
              36
            ]
          ],
          "class_code": "6b5fbaa0a03a3f8795c5fc834562d494850c69807556d066a22b1fa9de2a8950",
          "class_node_pos": [
            [
              104,
              0
            ],
            [
              121,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void Check() const {\n    int64_t post_store[8];\n    vpx_push_neon(post_store);\n    for (int i = 0; i < 8; ++i) {\n      EXPECT_EQ(pre_store_[i], post_store[i])\n          << \"d\" << i + 8 << \" has been modified\";\n    }\n  }",
          "fn_code_pos": [
            [
              111,
              2
            ],
            [
              118,
              3
            ]
          ],
          "class_code": "6b5fbaa0a03a3f8795c5fc834562d494850c69807556d066a22b1fa9de2a8950",
          "class_node_pos": [
            [
              104,
              0
            ],
            [
              121,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Check",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "RegisterStateCheckMMX() {\n    __asm__ volatile(\"fstenv %0\" : \"=rm\"(pre_fpu_env_));\n  }",
          "fn_code_pos": [
            [
              150,
              2
            ],
            [
              152,
              3
            ]
          ],
          "class_code": "974ee54107f7c639ce2d7b73344759b33e78c3159761d16b580f54bcdea618e1",
          "class_node_pos": [
            [
              148,
              0
            ],
            [
              169,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RegisterStateCheckMMX",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~RegisterStateCheckMMX() { Check(); }",
          "fn_code_pos": [
            [
              153,
              2
            ],
            [
              153,
              39
            ]
          ],
          "class_code": "974ee54107f7c639ce2d7b73344759b33e78c3159761d16b580f54bcdea618e1",
          "class_node_pos": [
            [
              148,
              0
            ],
            [
              169,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void Check() const {\n    EXPECT_EQ(0xffff, pre_fpu_env_[4])\n        << \"FPU was in an inconsistent state prior to call\";\n\n    uint16_t post_fpu_env[14];\n    __asm__ volatile(\"fstenv %0\" : \"=rm\"(post_fpu_env));\n    EXPECT_EQ(0xffff, post_fpu_env[4])\n        << \"FPU was left in an inconsistent state after call\";\n  }",
          "fn_code_pos": [
            [
              158,
              2
            ],
            [
              166,
              3
            ]
          ],
          "class_code": "974ee54107f7c639ce2d7b73344759b33e78c3159761d16b580f54bcdea618e1",
          "class_node_pos": [
            [
              148,
              0
            ],
            [
              169,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Check",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "vpx_push_neon(int64_t *store)",
          "fn_dec_pos": [
            [
              96,
              5
            ],
            [
              96,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "vpx_push_neon",
            "parameters": {
              "store": "int64_t"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {
        "2f9fb7de0845911a4b8f302c7eac8595a15bf1b1ea496240622b8a3ca23cffec": {
          "class_code": "class RegisterStateCheck {\n public:\n  RegisterStateCheck() { initialized_ = StoreRegisters(&pre_context_); }\n  ~RegisterStateCheck() { Check(); }\n\n private:\n  static bool StoreRegisters(CONTEXT *const context) {\n    const HANDLE this_thread = GetCurrentThread();\n    EXPECT_TRUE(this_thread != NULL);\n    context->ContextFlags = CONTEXT_FLOATING_POINT;\n    const bool context_saved = GetThreadContext(this_thread, context) == TRUE;\n    EXPECT_TRUE(context_saved) << \"GetLastError: \" << GetLastError();\n    return context_saved;\n  }\n\n  // Compares the register state. Returns true if the states match.\n  void Check() const {\n    ASSERT_TRUE(initialized_);\n    CONTEXT post_context;\n    ASSERT_TRUE(StoreRegisters(&post_context));\n\n    const M128A *xmm_pre = &pre_context_.Xmm6;\n    const M128A *xmm_post = &post_context.Xmm6;\n    for (int i = 6; i <= 15; ++i) {\n      EXPECT_EQ(*xmm_pre, *xmm_post) << \"xmm\" << i << \" has been modified!\";\n      ++xmm_pre;\n      ++xmm_post;\n    }\n  }\n\n  bool initialized_;\n  CONTEXT pre_context_;\n}",
          "class_name": "RegisterStateCheck",
          "class_pos": [
            [
              49,
              0
            ],
            [
              81,
              1
            ]
          ]
        },
        "6b5fbaa0a03a3f8795c5fc834562d494850c69807556d066a22b1fa9de2a8950": {
          "class_code": "class RegisterStateCheck {\n public:\n  RegisterStateCheck() { vpx_push_neon(pre_store_); }\n  ~RegisterStateCheck() { Check(); }\n\n private:\n  // Compares the register state. Returns true if the states match.\n  void Check() const {\n    int64_t post_store[8];\n    vpx_push_neon(post_store);\n    for (int i = 0; i < 8; ++i) {\n      EXPECT_EQ(pre_store_[i], post_store[i])\n          << \"d\" << i + 8 << \" has been modified\";\n    }\n  }\n\n  int64_t pre_store_[8];\n}",
          "class_name": "RegisterStateCheck",
          "class_pos": [
            [
              104,
              0
            ],
            [
              121,
              1
            ]
          ]
        },
        "b63ce753e37bb60244e059a9559b56f2f8df3c330834eb7068900bf6b6a12c46": {
          "class_code": "class RegisterStateCheck {}",
          "class_name": "RegisterStateCheck",
          "class_pos": [
            [
              135,
              0
            ],
            [
              135,
              27
            ]
          ]
        },
        "974ee54107f7c639ce2d7b73344759b33e78c3159761d16b580f54bcdea618e1": {
          "class_code": "class RegisterStateCheckMMX {\n public:\n  RegisterStateCheckMMX() {\n    __asm__ volatile(\"fstenv %0\" : \"=rm\"(pre_fpu_env_));\n  }\n  ~RegisterStateCheckMMX() { Check(); }\n\n private:\n  // Checks the FPU tag word pre/post execution, returning false if not cleared\n  // to 0xffff.\n  void Check() const {\n    EXPECT_EQ(0xffff, pre_fpu_env_[4])\n        << \"FPU was in an inconsistent state prior to call\";\n\n    uint16_t post_fpu_env[14];\n    __asm__ volatile(\"fstenv %0\" : \"=rm\"(post_fpu_env));\n    EXPECT_EQ(0xffff, post_fpu_env[4])\n        << \"FPU was left in an inconsistent state after call\";\n  }\n\n  uint16_t pre_fpu_env_[14];\n}",
          "class_name": "RegisterStateCheckMMX",
          "class_pos": [
            [
              148,
              0
            ],
            [
              169,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include <windows.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <winnt.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/buffer.h": {
      "fn_def_list": [
        {
          "fn_code": "template <typename T>\nT *Buffer<T>::TopLeftPixel() const {\n  if (!raw_buffer_) return NULL;\n  return raw_buffer_ + (top_padding_ * stride_) + left_padding_;\n}",
          "fn_code_pos": [
            [
              150,
              0
            ],
            [
              154,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T>\nvoid Buffer<T>::Set(const T value) {\n  if (!raw_buffer_) return;\n  T *src = TopLeftPixel();\n  for (int height = 0; height < height_; ++height) {\n    for (int width = 0; width < width_; ++width) {\n      src[width] = value;\n    }\n    src += stride_;\n  }\n}",
          "fn_code_pos": [
            [
              156,
              0
            ],
            [
              166,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T>\nvoid Buffer<T>::Set(ACMRandom *rand_class, T (ACMRandom::*rand_func)()) {\n  if (!raw_buffer_) return;\n  T *src = TopLeftPixel();\n  for (int height = 0; height < height_; ++height) {\n    for (int width = 0; width < width_; ++width) {\n      src[width] = (*rand_class.*rand_func)();\n    }\n    src += stride_;\n  }\n}",
          "fn_code_pos": [
            [
              168,
              0
            ],
            [
              178,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T>\nvoid Buffer<T>::Set(ACMRandom *rand_class, const T low, const T high) {\n  if (!raw_buffer_) return;\n\n  EXPECT_LE(low, high);\n  EXPECT_LE(static_cast<int64_t>(high) - low,\n            std::numeric_limits<int32_t>::max());\n\n  T *src = TopLeftPixel();\n  for (int height = 0; height < height_; ++height) {\n    for (int width = 0; width < width_; ++width) {\n      // 'low' will be promoted to unsigned given the return type of RandRange.\n      // Store the value as an int to avoid unsigned overflow warnings when\n      // 'low' is negative.\n      const int32_t value =\n          static_cast<int32_t>((*rand_class).RandRange(high - low));\n      src[width] = static_cast<T>(value + low);\n    }\n    src += stride_;\n  }\n}",
          "fn_code_pos": [
            [
              180,
              0
            ],
            [
              200,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T>\nvoid Buffer<T>::CopyFrom(const Buffer<T> &a) {\n  if (!raw_buffer_) return;\n  if (!BufferSizesMatch(a)) return;\n\n  T *a_src = a.TopLeftPixel();\n  T *b_src = this->TopLeftPixel();\n  for (int height = 0; height < height_; ++height) {\n    for (int width = 0; width < width_; ++width) {\n      b_src[width] = a_src[width];\n    }\n    a_src += a.stride();\n    b_src += this->stride();\n  }\n}",
          "fn_code_pos": [
            [
              202,
              0
            ],
            [
              216,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T>\nvoid Buffer<T>::DumpBuffer() const {\n  if (!raw_buffer_) return;\n  for (int height = 0; height < height_ + top_padding_ + bottom_padding_;\n       ++height) {\n    for (int width = 0; width < stride_; ++width) {\n      printf(\"%4d\", raw_buffer_[height + width * stride_]);\n    }\n    printf(\"\\n\");\n  }\n}",
          "fn_code_pos": [
            [
              218,
              0
            ],
            [
              228,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T>\nbool Buffer<T>::HasPadding() const {\n  if (!raw_buffer_) return false;\n  return top_padding_ || left_padding_ || right_padding_ || bottom_padding_;\n}",
          "fn_code_pos": [
            [
              230,
              0
            ],
            [
              234,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T>\nvoid Buffer<T>::PrintDifference(const Buffer<T> &a) const {\n  if (!raw_buffer_) return;\n  if (!BufferSizesMatch(a)) return;\n\n  T *a_src = a.TopLeftPixel();\n  T *b_src = TopLeftPixel();\n\n  printf(\"This buffer:\\n\");\n  for (int height = 0; height < height_; ++height) {\n    for (int width = 0; width < width_; ++width) {\n      if (a_src[width] != b_src[width]) {\n        printf(\"*%3d\", b_src[width]);\n      } else {\n        printf(\"%4d\", b_src[width]);\n      }\n    }\n    printf(\"\\n\");\n    a_src += a.stride();\n    b_src += this->stride();\n  }\n\n  a_src = a.TopLeftPixel();\n  b_src = TopLeftPixel();\n\n  printf(\"Reference buffer:\\n\");\n  for (int height = 0; height < height_; ++height) {\n    for (int width = 0; width < width_; ++width) {\n      if (a_src[width] != b_src[width]) {\n        printf(\"*%3d\", a_src[width]);\n      } else {\n        printf(\"%4d\", a_src[width]);\n      }\n    }\n    printf(\"\\n\");\n    a_src += a.stride();\n    b_src += this->stride();\n  }\n}",
          "fn_code_pos": [
            [
              236,
              0
            ],
            [
              274,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T>\nvoid Buffer<T>::SetPadding(const T padding_value) {\n  if (!raw_buffer_) return;\n  padding_value_ = padding_value;\n\n  T *src = raw_buffer_;\n  for (int i = 0; i < num_elements_; ++i) {\n    src[i] = padding_value;\n  }\n}",
          "fn_code_pos": [
            [
              276,
              0
            ],
            [
              285,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T>\nbool Buffer<T>::CheckValues(const T value) const {\n  if (!raw_buffer_) return false;\n  T *src = TopLeftPixel();\n  for (int height = 0; height < height_; ++height) {\n    for (int width = 0; width < width_; ++width) {\n      if (value != src[width]) {\n        return false;\n      }\n    }\n    src += stride_;\n  }\n  return true;\n}",
          "fn_code_pos": [
            [
              287,
              0
            ],
            [
              300,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T>\nbool Buffer<T>::CheckPadding() const {\n  if (!raw_buffer_) return false;\n  if (!HasPadding()) return true;\n\n  // Top padding.\n  T const *top = raw_buffer_;\n  for (int i = 0; i < stride_ * top_padding_; ++i) {\n    if (padding_value_ != top[i]) {\n      return false;\n    }\n  }\n\n  // Left padding.\n  T const *left = TopLeftPixel() - left_padding_;\n  for (int height = 0; height < height_; ++height) {\n    for (int width = 0; width < left_padding_; ++width) {\n      if (padding_value_ != left[width]) {\n        return false;\n      }\n    }\n    left += stride_;\n  }\n\n  // Right padding.\n  T const *right = TopLeftPixel() + width_;\n  for (int height = 0; height < height_; ++height) {\n    for (int width = 0; width < right_padding_; ++width) {\n      if (padding_value_ != right[width]) {\n        return false;\n      }\n    }\n    right += stride_;\n  }\n\n  // Bottom padding\n  T const *bottom = raw_buffer_ + (top_padding_ + height_) * stride_;\n  for (int i = 0; i < stride_ * bottom_padding_; ++i) {\n    if (padding_value_ != bottom[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}",
          "fn_code_pos": [
            [
              302,
              0
            ],
            [
              346,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T>\nbool Buffer<T>::CheckValues(const Buffer<T> &a) const {\n  if (!raw_buffer_) return false;\n  if (!BufferSizesMatch(a)) return false;\n\n  T *a_src = a.TopLeftPixel();\n  T *b_src = this->TopLeftPixel();\n  for (int height = 0; height < height_; ++height) {\n    for (int width = 0; width < width_; ++width) {\n      if (a_src[width] != b_src[width]) {\n        return false;\n      }\n    }\n    a_src += a.stride();\n    b_src += this->stride();\n  }\n  return true;\n}",
          "fn_code_pos": [
            [
              348,
              0
            ],
            [
              365,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <typename T>\nbool Buffer<T>::BufferSizesMatch(const Buffer<T> &a) const {\n  if (!raw_buffer_) return false;\n  if (a.width_ != this->width_ || a.height_ != this->height_) {\n    printf(\n        \"Reference buffer of size %dx%d does not match this buffer which is \"\n        \"size %dx%d\\n\",\n        a.width_, a.height_, this->width_, this->height_);\n    return false;\n  }\n\n  return true;\n}",
          "fn_code_pos": [
            [
              367,
              0
            ],
            [
              379,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "Buffer(int width, int height, int top_padding, int left_padding,\n         int right_padding, int bottom_padding)\n      : width_(width), height_(height), top_padding_(top_padding),\n        left_padding_(left_padding), right_padding_(right_padding),\n        bottom_padding_(bottom_padding), alignment_(0), padding_value_(0),\n        stride_(0), raw_size_(0), num_elements_(0), raw_buffer_(NULL) {}",
          "fn_code_pos": [
            [
              28,
              2
            ],
            [
              33,
              72
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Buffer",
            "parameters": {
              "width": "int",
              "height": "int",
              "top_padding": "int",
              "left_padding": "int",
              "right_padding": "int",
              "bottom_padding": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Buffer(int width, int height, int top_padding, int left_padding,\n         int right_padding, int bottom_padding, unsigned int alignment)\n      : width_(width), height_(height), top_padding_(top_padding),\n        left_padding_(left_padding), right_padding_(right_padding),\n        bottom_padding_(bottom_padding), alignment_(alignment),\n        padding_value_(0), stride_(0), raw_size_(0), num_elements_(0),\n        raw_buffer_(NULL) {}",
          "fn_code_pos": [
            [
              35,
              2
            ],
            [
              41,
              28
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Buffer",
            "parameters": {
              "width": "int",
              "height": "int",
              "top_padding": "int",
              "left_padding": "int",
              "right_padding": "int",
              "bottom_padding": "int",
              "alignment": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Buffer(int width, int height, int padding)\n      : width_(width), height_(height), top_padding_(padding),\n        left_padding_(padding), right_padding_(padding),\n        bottom_padding_(padding), alignment_(0), padding_value_(0), stride_(0),\n        raw_size_(0), num_elements_(0), raw_buffer_(NULL) {}",
          "fn_code_pos": [
            [
              43,
              2
            ],
            [
              47,
              60
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Buffer",
            "parameters": {
              "width": "int",
              "height": "int",
              "padding": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Buffer(int width, int height, int padding, unsigned int alignment)\n      : width_(width), height_(height), top_padding_(padding),\n        left_padding_(padding), right_padding_(padding),\n        bottom_padding_(padding), alignment_(alignment), padding_value_(0),\n        stride_(0), raw_size_(0), num_elements_(0), raw_buffer_(NULL) {}",
          "fn_code_pos": [
            [
              49,
              2
            ],
            [
              53,
              72
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Buffer",
            "parameters": {
              "width": "int",
              "height": "int",
              "padding": "int",
              "alignment": "unsigned int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~Buffer() {\n    if (alignment_) {\n      vpx_free(raw_buffer_);\n    } else {\n      delete[] raw_buffer_;\n    }\n  }",
          "fn_code_pos": [
            [
              55,
              2
            ],
            [
              61,
              3
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "int stride() const { return stride_; }",
          "fn_code_pos": [
            [
              65,
              2
            ],
            [
              65,
              40
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "stride",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "bool Init() {\n    if (raw_buffer_ != NULL) return false;\n    EXPECT_GT(width_, 0);\n    EXPECT_GT(height_, 0);\n    EXPECT_GE(top_padding_, 0);\n    EXPECT_GE(left_padding_, 0);\n    EXPECT_GE(right_padding_, 0);\n    EXPECT_GE(bottom_padding_, 0);\n    stride_ = left_padding_ + width_ + right_padding_;\n    num_elements_ = stride_ * (top_padding_ + height_ + bottom_padding_);\n    raw_size_ = num_elements_ * sizeof(T);\n    if (alignment_) {\n      EXPECT_GE(alignment_, sizeof(T));\n      // Ensure alignment of the first value will be preserved.\n      EXPECT_EQ((left_padding_ * sizeof(T)) % alignment_, 0u);\n      // Ensure alignment of the subsequent rows will be preserved when there is\n      // a stride.\n      if (stride_ != width_) {\n        EXPECT_EQ((stride_ * sizeof(T)) % alignment_, 0u);\n      }\n      raw_buffer_ = reinterpret_cast<T *>(vpx_memalign(alignment_, raw_size_));\n    } else {\n      raw_buffer_ = new (std::nothrow) T[num_elements_];\n    }\n    EXPECT_TRUE(raw_buffer_ != NULL);\n    SetPadding(std::numeric_limits<T>::max());\n    return !::testing::Test::HasFailure();\n  }",
          "fn_code_pos": [
            [
              104,
              2
            ],
            [
              131,
              3
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Init",
            "parameters": {},
            "return_type": "bool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TopLeftPixel() const",
          "fn_dec_pos": [
            [
              63,
              5
            ],
            [
              63,
              25
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TopLeftPixel",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "Set(const T value)",
          "fn_dec_pos": [
            [
              68,
              7
            ],
            [
              68,
              25
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Set",
            "parameters": {
              "value": "T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "Set(ACMRandom *rand_class, T (ACMRandom::*rand_func)())",
          "fn_dec_pos": [
            [
              72,
              7
            ],
            [
              72,
              62
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Set",
            "parameters": {
              "rand_class": "ACMRandom"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(ACMRandom::*rand_func)()",
          "fn_dec_pos": [
            [
              72,
              36
            ],
            [
              72,
              61
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "T"
          }
        },
        {
          "fn_code": "Set(ACMRandom *rand_class, const T low, const T high)",
          "fn_dec_pos": [
            [
              79,
              7
            ],
            [
              79,
              60
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Set",
            "parameters": {
              "rand_class": "ACMRandom",
              "low": "T",
              "high": "T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "CopyFrom(const Buffer<T> &a)",
          "fn_dec_pos": [
            [
              82,
              7
            ],
            [
              82,
              35
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CopyFrom",
            "parameters": {
              "a": "Buffer<T>"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "DumpBuffer() const",
          "fn_dec_pos": [
            [
              84,
              7
            ],
            [
              84,
              25
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DumpBuffer",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PrintDifference(const Buffer<T> &a) const",
          "fn_dec_pos": [
            [
              87,
              7
            ],
            [
              87,
              48
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PrintDifference",
            "parameters": {
              "a": "Buffer<T>"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "HasPadding() const",
          "fn_dec_pos": [
            [
              89,
              7
            ],
            [
              89,
              25
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "HasPadding",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "SetPadding(const T padding_value)",
          "fn_dec_pos": [
            [
              92,
              7
            ],
            [
              92,
              40
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetPadding",
            "parameters": {
              "padding_value": "T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "CheckValues(const T value) const",
          "fn_dec_pos": [
            [
              96,
              7
            ],
            [
              96,
              39
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckValues",
            "parameters": {
              "value": "T"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "CheckPadding() const",
          "fn_dec_pos": [
            [
              99,
              7
            ],
            [
              99,
              27
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckPadding",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "CheckValues(const Buffer<T> &a) const",
          "fn_dec_pos": [
            [
              102,
              7
            ],
            [
              102,
              44
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CheckValues",
            "parameters": {
              "a": "Buffer<T>"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "BufferSizesMatch(const Buffer<T> &a) const",
          "fn_dec_pos": [
            [
              134,
              7
            ],
            [
              134,
              49
            ]
          ],
          "class_code": "d9e9f932069641807f37cb1f3d78a03ecec360a3389aa29d6404fcf24527afd6",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              148,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "BufferSizesMatch",
            "parameters": {
              "a": "Buffer<T>"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "Buffer<T>::TopLeftPixel() const",
          "fn_dec_pos": [
            [
              151,
              3
            ],
            [
              151,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Buffer<T>::TopLeftPixel",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "(ACMRandom::*rand_func)()",
          "fn_dec_pos": [
            [
              169,
              45
            ],
            [
              169,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "T"
          }
        }
      ],
      "class_node_list": {
        "779c3ec7575d060d45294638d4d69acbba61c89f7c3b2ab48ba1dbce3c31517f": {
          "class_code": "template <typename T>\nclass Buffer {\n public:\n  Buffer(int width, int height, int top_padding, int left_padding,\n         int right_padding, int bottom_padding)\n      : width_(width), height_(height), top_padding_(top_padding),\n        left_padding_(left_padding), right_padding_(right_padding),\n        bottom_padding_(bottom_padding), alignment_(0), padding_value_(0),\n        stride_(0), raw_size_(0), num_elements_(0), raw_buffer_(NULL) {}\n\n  Buffer(int width, int height, int top_padding, int left_padding,\n         int right_padding, int bottom_padding, unsigned int alignment)\n      : width_(width), height_(height), top_padding_(top_padding),\n        left_padding_(left_padding), right_padding_(right_padding),\n        bottom_padding_(bottom_padding), alignment_(alignment),\n        padding_value_(0), stride_(0), raw_size_(0), num_elements_(0),\n        raw_buffer_(NULL) {}\n\n  Buffer(int width, int height, int padding)\n      : width_(width), height_(height), top_padding_(padding),\n        left_padding_(padding), right_padding_(padding),\n        bottom_padding_(padding), alignment_(0), padding_value_(0), stride_(0),\n        raw_size_(0), num_elements_(0), raw_buffer_(NULL) {}\n\n  Buffer(int width, int height, int padding, unsigned int alignment)\n      : width_(width), height_(height), top_padding_(padding),\n        left_padding_(padding), right_padding_(padding),\n        bottom_padding_(padding), alignment_(alignment), padding_value_(0),\n        stride_(0), raw_size_(0), num_elements_(0), raw_buffer_(NULL) {}\n\n  ~Buffer() {\n    if (alignment_) {\n      vpx_free(raw_buffer_);\n    } else {\n      delete[] raw_buffer_;\n    }\n  }\n\n  T *TopLeftPixel() const;\n\n  int stride() const { return stride_; }\n\n  // Set the buffer (excluding padding) to 'value'.\n  void Set(const T value);\n\n  // Set the buffer (excluding padding) to the output of ACMRandom function\n  // 'rand_func'.\n  void Set(ACMRandom *rand_class, T (ACMRandom::*rand_func)());\n\n  // Set the buffer (excluding padding) to the output of ACMRandom function\n  // 'RandRange' with range 'low' to 'high' which typically must be within\n  // testing::internal::Random::kMaxRange (1u << 31). However, because we want\n  // to allow negative low (and high) values, it is restricted to INT32_MAX\n  // here.\n  void Set(ACMRandom *rand_class, const T low, const T high);\n\n  // Copy the contents of Buffer 'a' (excluding padding).\n  void CopyFrom(const Buffer<T> &a);\n\n  void DumpBuffer() const;\n\n  // Highlight the differences between two buffers if they are the same size.\n  void PrintDifference(const Buffer<T> &a) const;\n\n  bool HasPadding() const;\n\n  // Sets all the values in the buffer to 'padding_value'.\n  void SetPadding(const T padding_value);\n\n  // Checks if all the values (excluding padding) are equal to 'value' if the\n  // Buffers are the same size.\n  bool CheckValues(const T value) const;\n\n  // Check that padding matches the expected value or there is no padding.\n  bool CheckPadding() const;\n\n  // Compare the non-padding portion of two buffers if they are the same size.\n  bool CheckValues(const Buffer<T> &a) const;\n\n  bool Init() {\n    if (raw_buffer_ != NULL) return false;\n    EXPECT_GT(width_, 0);\n    EXPECT_GT(height_, 0);\n    EXPECT_GE(top_padding_, 0);\n    EXPECT_GE(left_padding_, 0);\n    EXPECT_GE(right_padding_, 0);\n    EXPECT_GE(bottom_padding_, 0);\n    stride_ = left_padding_ + width_ + right_padding_;\n    num_elements_ = stride_ * (top_padding_ + height_ + bottom_padding_);\n    raw_size_ = num_elements_ * sizeof(T);\n    if (alignment_) {\n      EXPECT_GE(alignment_, sizeof(T));\n      // Ensure alignment of the first value will be preserved.\n      EXPECT_EQ((left_padding_ * sizeof(T)) % alignment_, 0u);\n      // Ensure alignment of the subsequent rows will be preserved when there is\n      // a stride.\n      if (stride_ != width_) {\n        EXPECT_EQ((stride_ * sizeof(T)) % alignment_, 0u);\n      }\n      raw_buffer_ = reinterpret_cast<T *>(vpx_memalign(alignment_, raw_size_));\n    } else {\n      raw_buffer_ = new (std::nothrow) T[num_elements_];\n    }\n    EXPECT_TRUE(raw_buffer_ != NULL);\n    SetPadding(std::numeric_limits<T>::max());\n    return !::testing::Test::HasFailure();\n  }\n\n private:\n  bool BufferSizesMatch(const Buffer<T> &a) const;\n\n  const int width_;\n  const int height_;\n  const int top_padding_;\n  const int left_padding_;\n  const int right_padding_;\n  const int bottom_padding_;\n  const unsigned int alignment_;\n  T padding_value_;\n  int stride_;\n  int raw_size_;\n  int num_elements_;\n  T *raw_buffer_;\n};",
          "class_name": "Buffer",
          "class_pos": [
            [
              25,
              0
            ],
            [
              148,
              2
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <limits>\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_integer.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/webm_video_source.h": {
      "fn_def_list": [
        {
          "fn_code": "explicit WebMVideoSource(const std::string &file_name)\n      : file_name_(file_name), vpx_ctx_(new VpxInputContext()),\n        webm_ctx_(new WebmInputContext()), buf_(NULL), buf_sz_(0), frame_(0),\n        end_of_file_(false) {}",
          "fn_code_pos": [
            [
              26,
              2
            ],
            [
              29,
              30
            ]
          ],
          "class_code": "99e68b2293cc48b107d34392ba61d045653bebba4668dc005896bbfab617e60b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              88,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "WebMVideoSource",
            "parameters": {
              "file_name": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~WebMVideoSource() {\n    if (vpx_ctx_->file != NULL) fclose(vpx_ctx_->file);\n    webm_free(webm_ctx_);\n    delete vpx_ctx_;\n    delete webm_ctx_;\n  }",
          "fn_code_pos": [
            [
              31,
              2
            ],
            [
              36,
              3
            ]
          ],
          "class_code": "99e68b2293cc48b107d34392ba61d045653bebba4668dc005896bbfab617e60b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              88,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void Init() {}",
          "fn_code_pos": [
            [
              38,
              2
            ],
            [
              38,
              24
            ]
          ],
          "class_code": "99e68b2293cc48b107d34392ba61d045653bebba4668dc005896bbfab617e60b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              88,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Init",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void Begin() {\n    vpx_ctx_->file = OpenTestDataFile(file_name_);\n    ASSERT_TRUE(vpx_ctx_->file != NULL)\n        << \"Input file open failed. Filename: \" << file_name_;\n\n    ASSERT_EQ(file_is_webm(webm_ctx_, vpx_ctx_), 1) << \"file is not WebM\";\n\n    FillFrame();\n  }",
          "fn_code_pos": [
            [
              40,
              2
            ],
            [
              48,
              3
            ]
          ],
          "class_code": "99e68b2293cc48b107d34392ba61d045653bebba4668dc005896bbfab617e60b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              88,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Begin",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void Next() {\n    ++frame_;\n    FillFrame();\n  }",
          "fn_code_pos": [
            [
              50,
              2
            ],
            [
              53,
              3
            ]
          ],
          "class_code": "99e68b2293cc48b107d34392ba61d045653bebba4668dc005896bbfab617e60b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              88,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Next",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void FillFrame() {\n    ASSERT_TRUE(vpx_ctx_->file != NULL);\n    const int status = webm_read_frame(webm_ctx_, &buf_, &buf_sz_);\n    ASSERT_GE(status, 0) << \"webm_read_frame failed\";\n    if (status == 1) {\n      end_of_file_ = true;\n    }\n  }",
          "fn_code_pos": [
            [
              55,
              2
            ],
            [
              62,
              3
            ]
          ],
          "class_code": "99e68b2293cc48b107d34392ba61d045653bebba4668dc005896bbfab617e60b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              88,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillFrame",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SeekToNextKeyFrame() {\n    ASSERT_TRUE(vpx_ctx_->file != NULL);\n    do {\n      const int status = webm_read_frame(webm_ctx_, &buf_, &buf_sz_);\n      ASSERT_GE(status, 0) << \"webm_read_frame failed\";\n      ++frame_;\n      if (status == 1) {\n        end_of_file_ = true;\n      }\n    } while (!webm_ctx_->is_key_frame && !end_of_file_);\n  }",
          "fn_code_pos": [
            [
              64,
              2
            ],
            [
              74,
              3
            ]
          ],
          "class_code": "99e68b2293cc48b107d34392ba61d045653bebba4668dc005896bbfab617e60b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              88,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SeekToNextKeyFrame",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual const uint8_t *cxdata() const { return end_of_file_ ? NULL : buf_; }",
          "fn_code_pos": [
            [
              76,
              2
            ],
            [
              76,
              78
            ]
          ],
          "class_code": "99e68b2293cc48b107d34392ba61d045653bebba4668dc005896bbfab617e60b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              88,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "cxdata",
            "parameters": {},
            "return_type": "uint8_t"
          }
        },
        {
          "fn_code": "virtual size_t frame_size() const { return buf_sz_; }",
          "fn_code_pos": [
            [
              77,
              2
            ],
            [
              77,
              55
            ]
          ],
          "class_code": "99e68b2293cc48b107d34392ba61d045653bebba4668dc005896bbfab617e60b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              88,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "frame_size",
            "parameters": {},
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "virtual unsigned int frame_number() const { return frame_; }",
          "fn_code_pos": [
            [
              78,
              2
            ],
            [
              78,
              62
            ]
          ],
          "class_code": "99e68b2293cc48b107d34392ba61d045653bebba4668dc005896bbfab617e60b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              88,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "frame_number",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "cxdata() const",
          "fn_dec_pos": [
            [
              76,
              25
            ],
            [
              76,
              39
            ]
          ],
          "class_code": "99e68b2293cc48b107d34392ba61d045653bebba4668dc005896bbfab617e60b",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              88,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "cxdata",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "99e68b2293cc48b107d34392ba61d045653bebba4668dc005896bbfab617e60b": {
          "class_code": "class WebMVideoSource : public CompressedVideoSource {\n public:\n  explicit WebMVideoSource(const std::string &file_name)\n      : file_name_(file_name), vpx_ctx_(new VpxInputContext()),\n        webm_ctx_(new WebmInputContext()), buf_(NULL), buf_sz_(0), frame_(0),\n        end_of_file_(false) {}\n\n  virtual ~WebMVideoSource() {\n    if (vpx_ctx_->file != NULL) fclose(vpx_ctx_->file);\n    webm_free(webm_ctx_);\n    delete vpx_ctx_;\n    delete webm_ctx_;\n  }\n\n  virtual void Init() {}\n\n  virtual void Begin() {\n    vpx_ctx_->file = OpenTestDataFile(file_name_);\n    ASSERT_TRUE(vpx_ctx_->file != NULL)\n        << \"Input file open failed. Filename: \" << file_name_;\n\n    ASSERT_EQ(file_is_webm(webm_ctx_, vpx_ctx_), 1) << \"file is not WebM\";\n\n    FillFrame();\n  }\n\n  virtual void Next() {\n    ++frame_;\n    FillFrame();\n  }\n\n  void FillFrame() {\n    ASSERT_TRUE(vpx_ctx_->file != NULL);\n    const int status = webm_read_frame(webm_ctx_, &buf_, &buf_sz_);\n    ASSERT_GE(status, 0) << \"webm_read_frame failed\";\n    if (status == 1) {\n      end_of_file_ = true;\n    }\n  }\n\n  void SeekToNextKeyFrame() {\n    ASSERT_TRUE(vpx_ctx_->file != NULL);\n    do {\n      const int status = webm_read_frame(webm_ctx_, &buf_, &buf_sz_);\n      ASSERT_GE(status, 0) << \"webm_read_frame failed\";\n      ++frame_;\n      if (status == 1) {\n        end_of_file_ = true;\n      }\n    } while (!webm_ctx_->is_key_frame && !end_of_file_);\n  }\n\n  virtual const uint8_t *cxdata() const { return end_of_file_ ? NULL : buf_; }\n  virtual size_t frame_size() const { return buf_sz_; }\n  virtual unsigned int frame_number() const { return frame_; }\n\n protected:\n  std::string file_name_;\n  VpxInputContext *vpx_ctx_;\n  WebmInputContext *webm_ctx_;\n  uint8_t *buf_;\n  size_t buf_sz_;\n  unsigned int frame_;\n  bool end_of_file_;\n}",
          "class_name": "WebMVideoSource",
          "class_pos": [
            [
              24,
              0
            ],
            [
              88,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <cstdarg>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <cstdio>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <cstdlib>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <new>\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"../tools_common.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"../webmdec.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/video_source.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/bench.h": {
      "fn_def_list": [
        {
          "fn_code": "virtual void Run() = 0;",
          "fn_code_pos": [
            [
              23,
              2
            ],
            [
              23,
              25
            ]
          ],
          "class_code": "2910df20dcdb52c58bb42b7e5620974ed70a235144781ee3cd4636e7613ac707",
          "class_node_pos": [
            [
              16,
              0
            ],
            [
              27,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Run",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "RunNTimes(int n)",
          "fn_dec_pos": [
            [
              18,
              7
            ],
            [
              18,
              23
            ]
          ],
          "class_code": "2910df20dcdb52c58bb42b7e5620974ed70a235144781ee3cd4636e7613ac707",
          "class_node_pos": [
            [
              16,
              0
            ],
            [
              27,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RunNTimes",
            "parameters": {
              "n": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "PrintMedian(const char *title)",
          "fn_dec_pos": [
            [
              19,
              7
            ],
            [
              19,
              37
            ]
          ],
          "class_code": "2910df20dcdb52c58bb42b7e5620974ed70a235144781ee3cd4636e7613ac707",
          "class_node_pos": [
            [
              16,
              0
            ],
            [
              27,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "PrintMedian",
            "parameters": {
              "title": "char"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {
        "2910df20dcdb52c58bb42b7e5620974ed70a235144781ee3cd4636e7613ac707": {
          "class_code": "class AbstractBench {\n public:\n  void RunNTimes(int n);\n  void PrintMedian(const char *title);\n\n protected:\n  // Implement this method and put the code to benchmark in it.\n  virtual void Run() = 0;\n\n private:\n  int times_[VPX_BENCH_ROBUST_ITER];\n}",
          "class_name": "AbstractBench",
          "class_pos": [
            [
              16,
              0
            ],
            [
              27,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/video_source.h": {
      "fn_def_list": [
        {
          "fn_code": "static std::string GetDataPath() {\n  const char *const data_path = getenv(\"LIBVPX_TEST_DATA_PATH\");\n  if (data_path == NULL) {\n#ifdef LIBVPX_TEST_DATA_PATH\n    // In some environments, we cannot set environment variables\n    // Instead, we set the data path by using a preprocessor symbol\n    // which can be set from make files\n    return STRINGIFY(LIBVPX_TEST_DATA_PATH);\n#else\n    return \".\";\n#endif\n  }\n  return data_path;\n}",
          "fn_code_pos": [
            [
              36,
              0
            ],
            [
              49,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetDataPath",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "inline FILE *OpenTestDataFile(const std::string &file_name) {\n  const std::string path_to_source = GetDataPath() + \"/\" + file_name;\n  return fopen(path_to_source.c_str(), \"rb\");\n}",
          "fn_code_pos": [
            [
              55,
              0
            ],
            [
              58,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OpenTestDataFile",
            "parameters": {
              "file_name": "std::string"
            },
            "return_type": "FILE"
          }
        },
        {
          "fn_code": "static FILE *GetTempOutFile(std::string *file_name) {\n  file_name->clear();\n#if defined(_WIN32)\n  char fname[MAX_PATH];\n  char tmppath[MAX_PATH];\n  if (GetTempPathA(MAX_PATH, tmppath)) {\n    // Assume for now that the filename generated is unique per process\n    if (GetTempFileNameA(tmppath, \"lvx\", 0, fname)) {\n      file_name->assign(fname);\n      return fopen(fname, \"wb+\");\n    }\n  }\n  return NULL;\n#else\n  return tmpfile();\n#endif\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              76,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetTempOutFile",
            "parameters": {
              "file_name": "std::string"
            },
            "return_type": "FILE"
          }
        },
        {
          "fn_code": "TempOutFile() { file_ = GetTempOutFile(&file_name_); }",
          "fn_code_pos": [
            [
              80,
              2
            ],
            [
              80,
              56
            ]
          ],
          "class_code": "7ac45eee6d380b006233470016c9427412f3bfa996919f751c288373b4013116",
          "class_node_pos": [
            [
              78,
              0
            ],
            [
              99,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TempOutFile",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~TempOutFile() {\n    CloseFile();\n    if (!file_name_.empty()) {\n      EXPECT_EQ(0, remove(file_name_.c_str()));\n    }\n  }",
          "fn_code_pos": [
            [
              81,
              2
            ],
            [
              86,
              3
            ]
          ],
          "class_code": "7ac45eee6d380b006233470016c9427412f3bfa996919f751c288373b4013116",
          "class_node_pos": [
            [
              78,
              0
            ],
            [
              99,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "FILE *file() { return file_; }",
          "fn_code_pos": [
            [
              87,
              2
            ],
            [
              87,
              32
            ]
          ],
          "class_code": "7ac45eee6d380b006233470016c9427412f3bfa996919f751c288373b4013116",
          "class_node_pos": [
            [
              78,
              0
            ],
            [
              99,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "file",
            "parameters": {},
            "return_type": "FILE"
          }
        },
        {
          "fn_code": "const std::string &file_name() { return file_name_; }",
          "fn_code_pos": [
            [
              88,
              2
            ],
            [
              88,
              55
            ]
          ],
          "class_code": "7ac45eee6d380b006233470016c9427412f3bfa996919f751c288373b4013116",
          "class_node_pos": [
            [
              78,
              0
            ],
            [
              99,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void CloseFile() {\n    if (file_) {\n      fclose(file_);\n      file_ = NULL;\n    }\n  }",
          "fn_code_pos": [
            [
              91,
              2
            ],
            [
              96,
              3
            ]
          ],
          "class_code": "7ac45eee6d380b006233470016c9427412f3bfa996919f751c288373b4013116",
          "class_node_pos": [
            [
              78,
              0
            ],
            [
              99,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CloseFile",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual ~VideoSource() {}",
          "fn_code_pos": [
            [
              105,
              2
            ],
            [
              105,
              27
            ]
          ],
          "class_code": "980256a8f197b77dc968fd5f3fe145abdf5cf0ae1e31a3757776e318680f0849",
          "class_node_pos": [
            [
              103,
              0
            ],
            [
              130,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void Begin() = 0;",
          "fn_code_pos": [
            [
              108,
              2
            ],
            [
              108,
              27
            ]
          ],
          "class_code": "980256a8f197b77dc968fd5f3fe145abdf5cf0ae1e31a3757776e318680f0849",
          "class_node_pos": [
            [
              103,
              0
            ],
            [
              130,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Begin",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void Next() = 0;",
          "fn_code_pos": [
            [
              111,
              2
            ],
            [
              111,
              26
            ]
          ],
          "class_code": "980256a8f197b77dc968fd5f3fe145abdf5cf0ae1e31a3757776e318680f0849",
          "class_node_pos": [
            [
              103,
              0
            ],
            [
              130,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Next",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual vpx_image_t *img() const = 0;",
          "fn_code_pos": [
            [
              114,
              2
            ],
            [
              114,
              39
            ]
          ],
          "class_code": "980256a8f197b77dc968fd5f3fe145abdf5cf0ae1e31a3757776e318680f0849",
          "class_node_pos": [
            [
              103,
              0
            ],
            [
              130,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "img",
            "parameters": {},
            "return_type": "vpx_image_t"
          }
        },
        {
          "fn_code": "virtual vpx_codec_pts_t pts() const = 0;",
          "fn_code_pos": [
            [
              117,
              2
            ],
            [
              117,
              42
            ]
          ],
          "class_code": "980256a8f197b77dc968fd5f3fe145abdf5cf0ae1e31a3757776e318680f0849",
          "class_node_pos": [
            [
              103,
              0
            ],
            [
              130,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "pts",
            "parameters": {},
            "return_type": "vpx_codec_pts_t"
          }
        },
        {
          "fn_code": "virtual unsigned long duration() const = 0;",
          "fn_code_pos": [
            [
              120,
              2
            ],
            [
              120,
              45
            ]
          ],
          "class_code": "980256a8f197b77dc968fd5f3fe145abdf5cf0ae1e31a3757776e318680f0849",
          "class_node_pos": [
            [
              103,
              0
            ],
            [
              130,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "duration",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual vpx_rational_t timebase() const = 0;",
          "fn_code_pos": [
            [
              123,
              2
            ],
            [
              123,
              46
            ]
          ],
          "class_code": "980256a8f197b77dc968fd5f3fe145abdf5cf0ae1e31a3757776e318680f0849",
          "class_node_pos": [
            [
              103,
              0
            ],
            [
              130,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "timebase",
            "parameters": {},
            "return_type": "vpx_rational_t"
          }
        },
        {
          "fn_code": "virtual unsigned int frame() const = 0;",
          "fn_code_pos": [
            [
              126,
              2
            ],
            [
              126,
              41
            ]
          ],
          "class_code": "980256a8f197b77dc968fd5f3fe145abdf5cf0ae1e31a3757776e318680f0849",
          "class_node_pos": [
            [
              103,
              0
            ],
            [
              130,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "frame",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual unsigned int limit() const = 0;",
          "fn_code_pos": [
            [
              129,
              2
            ],
            [
              129,
              41
            ]
          ],
          "class_code": "980256a8f197b77dc968fd5f3fe145abdf5cf0ae1e31a3757776e318680f0849",
          "class_node_pos": [
            [
              103,
              0
            ],
            [
              130,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "limit",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DummyVideoSource()\n      : img_(NULL), limit_(100), width_(80), height_(64),\n        format_(VPX_IMG_FMT_I420) {\n    ReallocImage();\n  }",
          "fn_code_pos": [
            [
              134,
              2
            ],
            [
              138,
              3
            ]
          ],
          "class_code": "592589d02719805d14fc08c262adc5240733a29c6c2b1a35d62a8f9126d4f354",
          "class_node_pos": [
            [
              132,
              0
            ],
            [
              203,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DummyVideoSource",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~DummyVideoSource() { vpx_img_free(img_); }",
          "fn_code_pos": [
            [
              140,
              2
            ],
            [
              140,
              53
            ]
          ],
          "class_code": "592589d02719805d14fc08c262adc5240733a29c6c2b1a35d62a8f9126d4f354",
          "class_node_pos": [
            [
              132,
              0
            ],
            [
              203,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void Begin() {\n    frame_ = 0;\n    FillFrame();\n  }",
          "fn_code_pos": [
            [
              142,
              2
            ],
            [
              145,
              3
            ]
          ],
          "class_code": "592589d02719805d14fc08c262adc5240733a29c6c2b1a35d62a8f9126d4f354",
          "class_node_pos": [
            [
              132,
              0
            ],
            [
              203,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Begin",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void Next() {\n    ++frame_;\n    FillFrame();\n  }",
          "fn_code_pos": [
            [
              147,
              2
            ],
            [
              150,
              3
            ]
          ],
          "class_code": "592589d02719805d14fc08c262adc5240733a29c6c2b1a35d62a8f9126d4f354",
          "class_node_pos": [
            [
              132,
              0
            ],
            [
              203,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Next",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual vpx_image_t *img() const { return (frame_ < limit_) ? img_ : NULL; }",
          "fn_code_pos": [
            [
              152,
              2
            ],
            [
              152,
              78
            ]
          ],
          "class_code": "592589d02719805d14fc08c262adc5240733a29c6c2b1a35d62a8f9126d4f354",
          "class_node_pos": [
            [
              132,
              0
            ],
            [
              203,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "img",
            "parameters": {},
            "return_type": "vpx_image_t"
          }
        },
        {
          "fn_code": "virtual vpx_codec_pts_t pts() const { return frame_; }",
          "fn_code_pos": [
            [
              155,
              2
            ],
            [
              155,
              56
            ]
          ],
          "class_code": "592589d02719805d14fc08c262adc5240733a29c6c2b1a35d62a8f9126d4f354",
          "class_node_pos": [
            [
              132,
              0
            ],
            [
              203,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "pts",
            "parameters": {},
            "return_type": "vpx_codec_pts_t"
          }
        },
        {
          "fn_code": "virtual unsigned long duration() const { return 1; }",
          "fn_code_pos": [
            [
              157,
              2
            ],
            [
              157,
              54
            ]
          ],
          "class_code": "592589d02719805d14fc08c262adc5240733a29c6c2b1a35d62a8f9126d4f354",
          "class_node_pos": [
            [
              132,
              0
            ],
            [
              203,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "duration",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual vpx_rational_t timebase() const {\n    const vpx_rational_t t = { 1, 30 };\n    return t;\n  }",
          "fn_code_pos": [
            [
              159,
              2
            ],
            [
              162,
              3
            ]
          ],
          "class_code": "592589d02719805d14fc08c262adc5240733a29c6c2b1a35d62a8f9126d4f354",
          "class_node_pos": [
            [
              132,
              0
            ],
            [
              203,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "timebase",
            "parameters": {},
            "return_type": "vpx_rational_t"
          }
        },
        {
          "fn_code": "virtual unsigned int frame() const { return frame_; }",
          "fn_code_pos": [
            [
              164,
              2
            ],
            [
              164,
              55
            ]
          ],
          "class_code": "592589d02719805d14fc08c262adc5240733a29c6c2b1a35d62a8f9126d4f354",
          "class_node_pos": [
            [
              132,
              0
            ],
            [
              203,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "frame",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual unsigned int limit() const { return limit_; }",
          "fn_code_pos": [
            [
              166,
              2
            ],
            [
              166,
              55
            ]
          ],
          "class_code": "592589d02719805d14fc08c262adc5240733a29c6c2b1a35d62a8f9126d4f354",
          "class_node_pos": [
            [
              132,
              0
            ],
            [
              203,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "limit",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void set_limit(unsigned int limit) { limit_ = limit; }",
          "fn_code_pos": [
            [
              168,
              2
            ],
            [
              168,
              56
            ]
          ],
          "class_code": "592589d02719805d14fc08c262adc5240733a29c6c2b1a35d62a8f9126d4f354",
          "class_node_pos": [
            [
              132,
              0
            ],
            [
              203,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "set_limit",
            "parameters": {
              "limit": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SetSize(unsigned int width, unsigned int height) {\n    if (width != width_ || height != height_) {\n      width_ = width;\n      height_ = height;\n      ReallocImage();\n    }\n  }",
          "fn_code_pos": [
            [
              170,
              2
            ],
            [
              176,
              3
            ]
          ],
          "class_code": "592589d02719805d14fc08c262adc5240733a29c6c2b1a35d62a8f9126d4f354",
          "class_node_pos": [
            [
              132,
              0
            ],
            [
              203,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetSize",
            "parameters": {
              "width": "unsigned int",
              "height": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SetImageFormat(vpx_img_fmt_t format) {\n    if (format_ != format) {\n      format_ = format;\n      ReallocImage();\n    }\n  }",
          "fn_code_pos": [
            [
              178,
              2
            ],
            [
              183,
              3
            ]
          ],
          "class_code": "592589d02719805d14fc08c262adc5240733a29c6c2b1a35d62a8f9126d4f354",
          "class_node_pos": [
            [
              132,
              0
            ],
            [
              203,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetImageFormat",
            "parameters": {
              "format": "vpx_img_fmt_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FillFrame() {\n    if (img_) memset(img_->img_data, 0, raw_sz_);\n  }",
          "fn_code_pos": [
            [
              186,
              2
            ],
            [
              188,
              3
            ]
          ],
          "class_code": "592589d02719805d14fc08c262adc5240733a29c6c2b1a35d62a8f9126d4f354",
          "class_node_pos": [
            [
              132,
              0
            ],
            [
              203,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillFrame",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ReallocImage() {\n    vpx_img_free(img_);\n    img_ = vpx_img_alloc(NULL, format_, width_, height_, 32);\n    raw_sz_ = ((img_->w + 31) & ~31) * img_->h * img_->bps / 8;\n  }",
          "fn_code_pos": [
            [
              190,
              2
            ],
            [
              194,
              3
            ]
          ],
          "class_code": "592589d02719805d14fc08c262adc5240733a29c6c2b1a35d62a8f9126d4f354",
          "class_node_pos": [
            [
              132,
              0
            ],
            [
              203,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ReallocImage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "RandomVideoSource(int seed = ACMRandom::DeterministicSeed())\n      : rnd_(seed), seed_(seed) {}",
          "fn_code_pos": [
            [
              207,
              2
            ],
            [
              208,
              34
            ]
          ],
          "class_code": "695132c6bfbb12f177c146241f3c0b10d2e0e597b93e5cc26a0efa8b32414916",
          "class_node_pos": [
            [
              205,
              0
            ],
            [
              232,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "RandomVideoSource",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void Begin() {\n    frame_ = 0;\n    rnd_.Reset(seed_);\n    FillFrame();\n  }",
          "fn_code_pos": [
            [
              212,
              2
            ],
            [
              216,
              3
            ]
          ],
          "class_code": "695132c6bfbb12f177c146241f3c0b10d2e0e597b93e5cc26a0efa8b32414916",
          "class_node_pos": [
            [
              205,
              0
            ],
            [
              232,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Begin",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FillFrame() {\n    if (img_) {\n      if (frame_ % 30 < 15) {\n        for (size_t i = 0; i < raw_sz_; ++i) img_->img_data[i] = rnd_.Rand8();\n      } else {\n        memset(img_->img_data, 0, raw_sz_);\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              220,
              2
            ],
            [
              228,
              3
            ]
          ],
          "class_code": "695132c6bfbb12f177c146241f3c0b10d2e0e597b93e5cc26a0efa8b32414916",
          "class_node_pos": [
            [
              205,
              0
            ],
            [
              232,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillFrame",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual ~CompressedVideoSource() {}",
          "fn_code_pos": [
            [
              238,
              2
            ],
            [
              238,
              37
            ]
          ],
          "class_code": "d0bc567b8763a4ad9666f9f2ad6bc046aa1da8ddb1da09c3109f91229e0c0bc3",
          "class_node_pos": [
            [
              236,
              0
            ],
            [
              253,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void Init() = 0;",
          "fn_code_pos": [
            [
              240,
              2
            ],
            [
              240,
              26
            ]
          ],
          "class_code": "d0bc567b8763a4ad9666f9f2ad6bc046aa1da8ddb1da09c3109f91229e0c0bc3",
          "class_node_pos": [
            [
              236,
              0
            ],
            [
              253,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Init",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void Begin() = 0;",
          "fn_code_pos": [
            [
              243,
              2
            ],
            [
              243,
              27
            ]
          ],
          "class_code": "d0bc567b8763a4ad9666f9f2ad6bc046aa1da8ddb1da09c3109f91229e0c0bc3",
          "class_node_pos": [
            [
              236,
              0
            ],
            [
              253,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Begin",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void Next() = 0;",
          "fn_code_pos": [
            [
              246,
              2
            ],
            [
              246,
              26
            ]
          ],
          "class_code": "d0bc567b8763a4ad9666f9f2ad6bc046aa1da8ddb1da09c3109f91229e0c0bc3",
          "class_node_pos": [
            [
              236,
              0
            ],
            [
              253,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Next",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual const uint8_t *cxdata() const = 0;",
          "fn_code_pos": [
            [
              248,
              2
            ],
            [
              248,
              44
            ]
          ],
          "class_code": "d0bc567b8763a4ad9666f9f2ad6bc046aa1da8ddb1da09c3109f91229e0c0bc3",
          "class_node_pos": [
            [
              236,
              0
            ],
            [
              253,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "cxdata",
            "parameters": {},
            "return_type": "uint8_t"
          }
        },
        {
          "fn_code": "virtual size_t frame_size() const = 0;",
          "fn_code_pos": [
            [
              250,
              2
            ],
            [
              250,
              40
            ]
          ],
          "class_code": "d0bc567b8763a4ad9666f9f2ad6bc046aa1da8ddb1da09c3109f91229e0c0bc3",
          "class_node_pos": [
            [
              236,
              0
            ],
            [
              253,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "frame_size",
            "parameters": {},
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "virtual unsigned int frame_number() const = 0;",
          "fn_code_pos": [
            [
              252,
              2
            ],
            [
              252,
              48
            ]
          ],
          "class_code": "d0bc567b8763a4ad9666f9f2ad6bc046aa1da8ddb1da09c3109f91229e0c0bc3",
          "class_node_pos": [
            [
              236,
              0
            ],
            [
              253,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "frame_number",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "OpenTestDataFile(const std::string &file_name)",
          "fn_dec_pos": [
            [
              55,
              13
            ],
            [
              55,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OpenTestDataFile",
            "parameters": {
              "file_name": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "GetTempOutFile(std::string *file_name)",
          "fn_dec_pos": [
            [
              60,
              13
            ],
            [
              60,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetTempOutFile",
            "parameters": {
              "file_name": "std::string"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "file()",
          "fn_dec_pos": [
            [
              87,
              8
            ],
            [
              87,
              14
            ]
          ],
          "class_code": "7ac45eee6d380b006233470016c9427412f3bfa996919f751c288373b4013116",
          "class_node_pos": [
            [
              78,
              0
            ],
            [
              99,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "file",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "file_name()",
          "fn_dec_pos": [
            [
              88,
              21
            ],
            [
              88,
              32
            ]
          ],
          "class_code": "7ac45eee6d380b006233470016c9427412f3bfa996919f751c288373b4013116",
          "class_node_pos": [
            [
              78,
              0
            ],
            [
              99,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "file_name",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "img() const",
          "fn_dec_pos": [
            [
              114,
              23
            ],
            [
              114,
              34
            ]
          ],
          "class_code": "980256a8f197b77dc968fd5f3fe145abdf5cf0ae1e31a3757776e318680f0849",
          "class_node_pos": [
            [
              103,
              0
            ],
            [
              130,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "img",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "img() const",
          "fn_dec_pos": [
            [
              152,
              23
            ],
            [
              152,
              34
            ]
          ],
          "class_code": "592589d02719805d14fc08c262adc5240733a29c6c2b1a35d62a8f9126d4f354",
          "class_node_pos": [
            [
              132,
              0
            ],
            [
              203,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "img",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "cxdata() const",
          "fn_dec_pos": [
            [
              248,
              25
            ],
            [
              248,
              39
            ]
          ],
          "class_code": "d0bc567b8763a4ad9666f9f2ad6bc046aa1da8ddb1da09c3109f91229e0c0bc3",
          "class_node_pos": [
            [
              236,
              0
            ],
            [
              253,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "cxdata",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "7ac45eee6d380b006233470016c9427412f3bfa996919f751c288373b4013116": {
          "class_code": "class TempOutFile {\n public:\n  TempOutFile() { file_ = GetTempOutFile(&file_name_); }\n  ~TempOutFile() {\n    CloseFile();\n    if (!file_name_.empty()) {\n      EXPECT_EQ(0, remove(file_name_.c_str()));\n    }\n  }\n  FILE *file() { return file_; }\n  const std::string &file_name() { return file_name_; }\n\n protected:\n  void CloseFile() {\n    if (file_) {\n      fclose(file_);\n      file_ = NULL;\n    }\n  }\n  FILE *file_;\n  std::string file_name_;\n}",
          "class_name": "TempOutFile",
          "class_pos": [
            [
              78,
              0
            ],
            [
              99,
              1
            ]
          ]
        },
        "980256a8f197b77dc968fd5f3fe145abdf5cf0ae1e31a3757776e318680f0849": {
          "class_code": "class VideoSource {\n public:\n  virtual ~VideoSource() {}\n\n  // Prepare the stream for reading, rewind/open as necessary.\n  virtual void Begin() = 0;\n\n  // Advance the cursor to the next frame\n  virtual void Next() = 0;\n\n  // Get the current video frame, or NULL on End-Of-Stream.\n  virtual vpx_image_t *img() const = 0;\n\n  // Get the presentation timestamp of the current frame.\n  virtual vpx_codec_pts_t pts() const = 0;\n\n  // Get the current frame's duration\n  virtual unsigned long duration() const = 0;\n\n  // Get the timebase for the stream\n  virtual vpx_rational_t timebase() const = 0;\n\n  // Get the current frame counter, starting at 0.\n  virtual unsigned int frame() const = 0;\n\n  // Get the current file limit.\n  virtual unsigned int limit() const = 0;\n}",
          "class_name": "VideoSource",
          "class_pos": [
            [
              103,
              0
            ],
            [
              130,
              1
            ]
          ]
        },
        "592589d02719805d14fc08c262adc5240733a29c6c2b1a35d62a8f9126d4f354": {
          "class_code": "class DummyVideoSource : public VideoSource {\n public:\n  DummyVideoSource()\n      : img_(NULL), limit_(100), width_(80), height_(64),\n        format_(VPX_IMG_FMT_I420) {\n    ReallocImage();\n  }\n\n  virtual ~DummyVideoSource() { vpx_img_free(img_); }\n\n  virtual void Begin() {\n    frame_ = 0;\n    FillFrame();\n  }\n\n  virtual void Next() {\n    ++frame_;\n    FillFrame();\n  }\n\n  virtual vpx_image_t *img() const { return (frame_ < limit_) ? img_ : NULL; }\n\n  // Models a stream where Timebase = 1/FPS, so pts == frame.\n  virtual vpx_codec_pts_t pts() const { return frame_; }\n\n  virtual unsigned long duration() const { return 1; }\n\n  virtual vpx_rational_t timebase() const {\n    const vpx_rational_t t = { 1, 30 };\n    return t;\n  }\n\n  virtual unsigned int frame() const { return frame_; }\n\n  virtual unsigned int limit() const { return limit_; }\n\n  void set_limit(unsigned int limit) { limit_ = limit; }\n\n  void SetSize(unsigned int width, unsigned int height) {\n    if (width != width_ || height != height_) {\n      width_ = width;\n      height_ = height;\n      ReallocImage();\n    }\n  }\n\n  void SetImageFormat(vpx_img_fmt_t format) {\n    if (format_ != format) {\n      format_ = format;\n      ReallocImage();\n    }\n  }\n\n protected:\n  virtual void FillFrame() {\n    if (img_) memset(img_->img_data, 0, raw_sz_);\n  }\n\n  void ReallocImage() {\n    vpx_img_free(img_);\n    img_ = vpx_img_alloc(NULL, format_, width_, height_, 32);\n    raw_sz_ = ((img_->w + 31) & ~31) * img_->h * img_->bps / 8;\n  }\n\n  vpx_image_t *img_;\n  size_t raw_sz_;\n  unsigned int limit_;\n  unsigned int frame_;\n  unsigned int width_;\n  unsigned int height_;\n  vpx_img_fmt_t format_;\n}",
          "class_name": "DummyVideoSource",
          "class_pos": [
            [
              132,
              0
            ],
            [
              203,
              1
            ]
          ]
        },
        "695132c6bfbb12f177c146241f3c0b10d2e0e597b93e5cc26a0efa8b32414916": {
          "class_code": "class RandomVideoSource : public DummyVideoSource {\n public:\n  RandomVideoSource(int seed = ACMRandom::DeterministicSeed())\n      : rnd_(seed), seed_(seed) {}\n\n protected:\n  // Reset the RNG to get a matching stream for the second pass\n  virtual void Begin() {\n    frame_ = 0;\n    rnd_.Reset(seed_);\n    FillFrame();\n  }\n\n  // 15 frames of noise, followed by 15 static frames. Reset to 0 rather\n  // than holding previous frames to encourage keyframes to be thrown.\n  virtual void FillFrame() {\n    if (img_) {\n      if (frame_ % 30 < 15) {\n        for (size_t i = 0; i < raw_sz_; ++i) img_->img_data[i] = rnd_.Rand8();\n      } else {\n        memset(img_->img_data, 0, raw_sz_);\n      }\n    }\n  }\n\n  ACMRandom rnd_;\n  int seed_;\n}",
          "class_name": "RandomVideoSource",
          "class_pos": [
            [
              205,
              0
            ],
            [
              232,
              1
            ]
          ]
        },
        "d0bc567b8763a4ad9666f9f2ad6bc046aa1da8ddb1da09c3109f91229e0c0bc3": {
          "class_code": "class CompressedVideoSource {\n public:\n  virtual ~CompressedVideoSource() {}\n\n  virtual void Init() = 0;\n\n  // Prepare the stream for reading, rewind/open as necessary.\n  virtual void Begin() = 0;\n\n  // Advance the cursor to the next frame\n  virtual void Next() = 0;\n\n  virtual const uint8_t *cxdata() const = 0;\n\n  virtual size_t frame_size() const = 0;\n\n  virtual unsigned int frame_number() const = 0;\n}",
          "class_name": "CompressedVideoSource",
          "class_pos": [
            [
              236,
              0
            ],
            [
              253,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <windows.h>\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include <cstdio>\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include <cstdlib>\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_encoder.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/vpx_scale_test.h": {
      "fn_def_list": [
        {
          "fn_code": "virtual ~VpxScaleBase() { libvpx_test::ClearSystemState(); }",
          "fn_code_pos": [
            [
              29,
              2
            ],
            [
              29,
              62
            ]
          ],
          "class_code": "8f34d5300c13e44e4de8fc229fd20cd1b198b058b59f5b4d81f8ad15f073b69c",
          "class_node_pos": [
            [
              27,
              0
            ],
            [
              196,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void ResetImage(YV12_BUFFER_CONFIG *const img, const int width,\n                  const int height) {\n    memset(img, 0, sizeof(*img));\n    ASSERT_EQ(\n        0, vp8_yv12_alloc_frame_buffer(img, width, height, VP8BORDERINPIXELS))\n        << \"for width: \" << width << \" height: \" << height;\n    memset(img->buffer_alloc, kBufFiller, img->frame_size);\n  }",
          "fn_code_pos": [
            [
              31,
              2
            ],
            [
              38,
              3
            ]
          ],
          "class_code": "8f34d5300c13e44e4de8fc229fd20cd1b198b058b59f5b4d81f8ad15f073b69c",
          "class_node_pos": [
            [
              27,
              0
            ],
            [
              196,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ResetImage",
            "parameters": {
              "img": "YV12_BUFFER_CONFIG",
              "width": "int",
              "height": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ResetImages(const int width, const int height) {\n    ResetImage(&img_, width, height);\n    ResetImage(&ref_img_, width, height);\n    ResetImage(&dst_img_, width, height);\n\n    FillPlane(img_.y_buffer, img_.y_crop_width, img_.y_crop_height,\n              img_.y_stride);\n    FillPlane(img_.u_buffer, img_.uv_crop_width, img_.uv_crop_height,\n              img_.uv_stride);\n    FillPlane(img_.v_buffer, img_.uv_crop_width, img_.uv_crop_height,\n              img_.uv_stride);\n  }",
          "fn_code_pos": [
            [
              40,
              2
            ],
            [
              51,
              3
            ]
          ],
          "class_code": "8f34d5300c13e44e4de8fc229fd20cd1b198b058b59f5b4d81f8ad15f073b69c",
          "class_node_pos": [
            [
              27,
              0
            ],
            [
              196,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ResetImages",
            "parameters": {
              "width": "int",
              "height": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ResetScaleImage(YV12_BUFFER_CONFIG *const img, const int width,\n                       const int height) {\n    memset(img, 0, sizeof(*img));\n#if CONFIG_VP9_HIGHBITDEPTH\n    ASSERT_EQ(0, vpx_alloc_frame_buffer(img, width, height, 1, 1, 0,\n                                        VP9_ENC_BORDER_IN_PIXELS, 0));\n#else\n    ASSERT_EQ(0, vpx_alloc_frame_buffer(img, width, height, 1, 1,\n                                        VP9_ENC_BORDER_IN_PIXELS, 0));\n#endif\n    memset(img->buffer_alloc, kBufFiller, img->frame_size);\n  }",
          "fn_code_pos": [
            [
              53,
              2
            ],
            [
              64,
              3
            ]
          ],
          "class_code": "8f34d5300c13e44e4de8fc229fd20cd1b198b058b59f5b4d81f8ad15f073b69c",
          "class_node_pos": [
            [
              27,
              0
            ],
            [
              196,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ResetScaleImage",
            "parameters": {
              "img": "YV12_BUFFER_CONFIG",
              "width": "int",
              "height": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ResetScaleImages(const int src_width, const int src_height,\n                        const int dst_width, const int dst_height) {\n    ResetScaleImage(&img_, src_width, src_height);\n    ResetScaleImage(&ref_img_, dst_width, dst_height);\n    ResetScaleImage(&dst_img_, dst_width, dst_height);\n    FillPlaneExtreme(img_.y_buffer, img_.y_crop_width, img_.y_crop_height,\n                     img_.y_stride);\n    FillPlaneExtreme(img_.u_buffer, img_.uv_crop_width, img_.uv_crop_height,\n                     img_.uv_stride);\n    FillPlaneExtreme(img_.v_buffer, img_.uv_crop_width, img_.uv_crop_height,\n                     img_.uv_stride);\n  }",
          "fn_code_pos": [
            [
              66,
              2
            ],
            [
              77,
              3
            ]
          ],
          "class_code": "8f34d5300c13e44e4de8fc229fd20cd1b198b058b59f5b4d81f8ad15f073b69c",
          "class_node_pos": [
            [
              27,
              0
            ],
            [
              196,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ResetScaleImages",
            "parameters": {
              "src_width": "int",
              "src_height": "int",
              "dst_width": "int",
              "dst_height": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void DeallocImages() {\n    vp8_yv12_de_alloc_frame_buffer(&img_);\n    vp8_yv12_de_alloc_frame_buffer(&ref_img_);\n    vp8_yv12_de_alloc_frame_buffer(&dst_img_);\n  }",
          "fn_code_pos": [
            [
              79,
              2
            ],
            [
              83,
              3
            ]
          ],
          "class_code": "8f34d5300c13e44e4de8fc229fd20cd1b198b058b59f5b4d81f8ad15f073b69c",
          "class_node_pos": [
            [
              27,
              0
            ],
            [
              196,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DeallocImages",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void DeallocScaleImages() {\n    vpx_free_frame_buffer(&img_);\n    vpx_free_frame_buffer(&ref_img_);\n    vpx_free_frame_buffer(&dst_img_);\n  }",
          "fn_code_pos": [
            [
              85,
              2
            ],
            [
              89,
              3
            ]
          ],
          "class_code": "8f34d5300c13e44e4de8fc229fd20cd1b198b058b59f5b4d81f8ad15f073b69c",
          "class_node_pos": [
            [
              27,
              0
            ],
            [
              196,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "DeallocScaleImages",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void FillPlane(uint8_t *const buf, const int width, const int height,\n                        const int stride) {\n    for (int y = 0; y < height; ++y) {\n      for (int x = 0; x < width; ++x) {\n        buf[x + (y * stride)] = (x + (width * y)) % kBufMax;\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              95,
              2
            ],
            [
              102,
              3
            ]
          ],
          "class_code": "8f34d5300c13e44e4de8fc229fd20cd1b198b058b59f5b4d81f8ad15f073b69c",
          "class_node_pos": [
            [
              27,
              0
            ],
            [
              196,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillPlane",
            "parameters": {
              "buf": "uint8_t",
              "width": "int",
              "height": "int",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void FillPlaneExtreme(uint8_t *const buf, const int width,\n                               const int height, const int stride) {\n    ACMRandom rnd;\n    for (int y = 0; y < height; ++y) {\n      for (int x = 0; x < width; ++x) {\n        buf[x + (y * stride)] = rnd.Rand8() % 2 ? 255 : 0;\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              104,
              2
            ],
            [
              112,
              3
            ]
          ],
          "class_code": "8f34d5300c13e44e4de8fc229fd20cd1b198b058b59f5b4d81f8ad15f073b69c",
          "class_node_pos": [
            [
              27,
              0
            ],
            [
              196,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillPlaneExtreme",
            "parameters": {
              "buf": "uint8_t",
              "width": "int",
              "height": "int",
              "stride": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void ExtendPlane(uint8_t *buf, int crop_width, int crop_height,\n                          int width, int height, int stride, int padding) {\n    // Copy the outermost visible pixel to a distance of at least 'padding.'\n    // The buffers are allocated such that there may be excess space outside the\n    // padding. As long as the minimum amount of padding is achieved it is not\n    // necessary to fill this space as well.\n    uint8_t *left = buf - padding;\n    uint8_t *right = buf + crop_width;\n    const int right_extend = padding + (width - crop_width);\n    const int bottom_extend = padding + (height - crop_height);\n\n    // Fill the border pixels from the nearest image pixel.\n    for (int y = 0; y < crop_height; ++y) {\n      memset(left, left[padding], padding);\n      memset(right, right[-1], right_extend);\n      left += stride;\n      right += stride;\n    }\n\n    left = buf - padding;\n    uint8_t *top = left - (stride * padding);\n    // The buffer does not always extend as far as the stride.\n    // Equivalent to padding + width + padding.\n    const int extend_width = padding + crop_width + right_extend;\n\n    // The first row was already extended to the left and right. Copy it up.\n    for (int y = 0; y < padding; ++y) {\n      memcpy(top, left, extend_width);\n      top += stride;\n    }\n\n    uint8_t *bottom = left + (crop_height * stride);\n    for (int y = 0; y < bottom_extend; ++y) {\n      memcpy(bottom, left + (crop_height - 1) * stride, extend_width);\n      bottom += stride;\n    }\n  }",
          "fn_code_pos": [
            [
              114,
              2
            ],
            [
              150,
              3
            ]
          ],
          "class_code": "8f34d5300c13e44e4de8fc229fd20cd1b198b058b59f5b4d81f8ad15f073b69c",
          "class_node_pos": [
            [
              27,
              0
            ],
            [
              196,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ExtendPlane",
            "parameters": {
              "buf": "uint8_t",
              "crop_width": "int",
              "crop_height": "int",
              "width": "int",
              "height": "int",
              "stride": "int",
              "padding": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ReferenceExtendBorder() {\n    ExtendPlane(ref_img_.y_buffer, ref_img_.y_crop_width,\n                ref_img_.y_crop_height, ref_img_.y_width, ref_img_.y_height,\n                ref_img_.y_stride, ref_img_.border);\n    ExtendPlane(ref_img_.u_buffer, ref_img_.uv_crop_width,\n                ref_img_.uv_crop_height, ref_img_.uv_width, ref_img_.uv_height,\n                ref_img_.uv_stride, ref_img_.border / 2);\n    ExtendPlane(ref_img_.v_buffer, ref_img_.uv_crop_width,\n                ref_img_.uv_crop_height, ref_img_.uv_width, ref_img_.uv_height,\n                ref_img_.uv_stride, ref_img_.border / 2);\n  }",
          "fn_code_pos": [
            [
              152,
              2
            ],
            [
              162,
              3
            ]
          ],
          "class_code": "8f34d5300c13e44e4de8fc229fd20cd1b198b058b59f5b4d81f8ad15f073b69c",
          "class_node_pos": [
            [
              27,
              0
            ],
            [
              196,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ReferenceExtendBorder",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ReferenceCopyFrame() {\n    // Copy img_ to ref_img_ and extend frame borders. This will be used for\n    // verifying extend_fn_ as well as copy_frame_fn_.\n    EXPECT_EQ(ref_img_.frame_size, img_.frame_size);\n    for (int y = 0; y < img_.y_crop_height; ++y) {\n      for (int x = 0; x < img_.y_crop_width; ++x) {\n        ref_img_.y_buffer[x + y * ref_img_.y_stride] =\n            img_.y_buffer[x + y * img_.y_stride];\n      }\n    }\n\n    for (int y = 0; y < img_.uv_crop_height; ++y) {\n      for (int x = 0; x < img_.uv_crop_width; ++x) {\n        ref_img_.u_buffer[x + y * ref_img_.uv_stride] =\n            img_.u_buffer[x + y * img_.uv_stride];\n        ref_img_.v_buffer[x + y * ref_img_.uv_stride] =\n            img_.v_buffer[x + y * img_.uv_stride];\n      }\n    }\n\n    ReferenceExtendBorder();\n  }",
          "fn_code_pos": [
            [
              164,
              2
            ],
            [
              185,
              3
            ]
          ],
          "class_code": "8f34d5300c13e44e4de8fc229fd20cd1b198b058b59f5b4d81f8ad15f073b69c",
          "class_node_pos": [
            [
              27,
              0
            ],
            [
              196,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ReferenceCopyFrame",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CompareImages(const YV12_BUFFER_CONFIG actual) {\n    EXPECT_EQ(ref_img_.frame_size, actual.frame_size);\n    EXPECT_EQ(0, memcmp(ref_img_.buffer_alloc, actual.buffer_alloc,\n                        ref_img_.frame_size));\n  }",
          "fn_code_pos": [
            [
              187,
              2
            ],
            [
              191,
              3
            ]
          ],
          "class_code": "8f34d5300c13e44e4de8fc229fd20cd1b198b058b59f5b4d81f8ad15f073b69c",
          "class_node_pos": [
            [
              27,
              0
            ],
            [
              196,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CompareImages",
            "parameters": {
              "actual": "YV12_BUFFER_CONFIG"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {
        "8f34d5300c13e44e4de8fc229fd20cd1b198b058b59f5b4d81f8ad15f073b69c": {
          "class_code": "class VpxScaleBase {\n public:\n  virtual ~VpxScaleBase() { libvpx_test::ClearSystemState(); }\n\n  void ResetImage(YV12_BUFFER_CONFIG *const img, const int width,\n                  const int height) {\n    memset(img, 0, sizeof(*img));\n    ASSERT_EQ(\n        0, vp8_yv12_alloc_frame_buffer(img, width, height, VP8BORDERINPIXELS))\n        << \"for width: \" << width << \" height: \" << height;\n    memset(img->buffer_alloc, kBufFiller, img->frame_size);\n  }\n\n  void ResetImages(const int width, const int height) {\n    ResetImage(&img_, width, height);\n    ResetImage(&ref_img_, width, height);\n    ResetImage(&dst_img_, width, height);\n\n    FillPlane(img_.y_buffer, img_.y_crop_width, img_.y_crop_height,\n              img_.y_stride);\n    FillPlane(img_.u_buffer, img_.uv_crop_width, img_.uv_crop_height,\n              img_.uv_stride);\n    FillPlane(img_.v_buffer, img_.uv_crop_width, img_.uv_crop_height,\n              img_.uv_stride);\n  }\n\n  void ResetScaleImage(YV12_BUFFER_CONFIG *const img, const int width,\n                       const int height) {\n    memset(img, 0, sizeof(*img));\n#if CONFIG_VP9_HIGHBITDEPTH\n    ASSERT_EQ(0, vpx_alloc_frame_buffer(img, width, height, 1, 1, 0,\n                                        VP9_ENC_BORDER_IN_PIXELS, 0));\n#else\n    ASSERT_EQ(0, vpx_alloc_frame_buffer(img, width, height, 1, 1,\n                                        VP9_ENC_BORDER_IN_PIXELS, 0));\n#endif\n    memset(img->buffer_alloc, kBufFiller, img->frame_size);\n  }\n\n  void ResetScaleImages(const int src_width, const int src_height,\n                        const int dst_width, const int dst_height) {\n    ResetScaleImage(&img_, src_width, src_height);\n    ResetScaleImage(&ref_img_, dst_width, dst_height);\n    ResetScaleImage(&dst_img_, dst_width, dst_height);\n    FillPlaneExtreme(img_.y_buffer, img_.y_crop_width, img_.y_crop_height,\n                     img_.y_stride);\n    FillPlaneExtreme(img_.u_buffer, img_.uv_crop_width, img_.uv_crop_height,\n                     img_.uv_stride);\n    FillPlaneExtreme(img_.v_buffer, img_.uv_crop_width, img_.uv_crop_height,\n                     img_.uv_stride);\n  }\n\n  void DeallocImages() {\n    vp8_yv12_de_alloc_frame_buffer(&img_);\n    vp8_yv12_de_alloc_frame_buffer(&ref_img_);\n    vp8_yv12_de_alloc_frame_buffer(&dst_img_);\n  }\n\n  void DeallocScaleImages() {\n    vpx_free_frame_buffer(&img_);\n    vpx_free_frame_buffer(&ref_img_);\n    vpx_free_frame_buffer(&dst_img_);\n  }\n\n protected:\n  static const int kBufFiller = 123;\n  static const int kBufMax = kBufFiller - 1;\n\n  static void FillPlane(uint8_t *const buf, const int width, const int height,\n                        const int stride) {\n    for (int y = 0; y < height; ++y) {\n      for (int x = 0; x < width; ++x) {\n        buf[x + (y * stride)] = (x + (width * y)) % kBufMax;\n      }\n    }\n  }\n\n  static void FillPlaneExtreme(uint8_t *const buf, const int width,\n                               const int height, const int stride) {\n    ACMRandom rnd;\n    for (int y = 0; y < height; ++y) {\n      for (int x = 0; x < width; ++x) {\n        buf[x + (y * stride)] = rnd.Rand8() % 2 ? 255 : 0;\n      }\n    }\n  }\n\n  static void ExtendPlane(uint8_t *buf, int crop_width, int crop_height,\n                          int width, int height, int stride, int padding) {\n    // Copy the outermost visible pixel to a distance of at least 'padding.'\n    // The buffers are allocated such that there may be excess space outside the\n    // padding. As long as the minimum amount of padding is achieved it is not\n    // necessary to fill this space as well.\n    uint8_t *left = buf - padding;\n    uint8_t *right = buf + crop_width;\n    const int right_extend = padding + (width - crop_width);\n    const int bottom_extend = padding + (height - crop_height);\n\n    // Fill the border pixels from the nearest image pixel.\n    for (int y = 0; y < crop_height; ++y) {\n      memset(left, left[padding], padding);\n      memset(right, right[-1], right_extend);\n      left += stride;\n      right += stride;\n    }\n\n    left = buf - padding;\n    uint8_t *top = left - (stride * padding);\n    // The buffer does not always extend as far as the stride.\n    // Equivalent to padding + width + padding.\n    const int extend_width = padding + crop_width + right_extend;\n\n    // The first row was already extended to the left and right. Copy it up.\n    for (int y = 0; y < padding; ++y) {\n      memcpy(top, left, extend_width);\n      top += stride;\n    }\n\n    uint8_t *bottom = left + (crop_height * stride);\n    for (int y = 0; y < bottom_extend; ++y) {\n      memcpy(bottom, left + (crop_height - 1) * stride, extend_width);\n      bottom += stride;\n    }\n  }\n\n  void ReferenceExtendBorder() {\n    ExtendPlane(ref_img_.y_buffer, ref_img_.y_crop_width,\n                ref_img_.y_crop_height, ref_img_.y_width, ref_img_.y_height,\n                ref_img_.y_stride, ref_img_.border);\n    ExtendPlane(ref_img_.u_buffer, ref_img_.uv_crop_width,\n                ref_img_.uv_crop_height, ref_img_.uv_width, ref_img_.uv_height,\n                ref_img_.uv_stride, ref_img_.border / 2);\n    ExtendPlane(ref_img_.v_buffer, ref_img_.uv_crop_width,\n                ref_img_.uv_crop_height, ref_img_.uv_width, ref_img_.uv_height,\n                ref_img_.uv_stride, ref_img_.border / 2);\n  }\n\n  void ReferenceCopyFrame() {\n    // Copy img_ to ref_img_ and extend frame borders. This will be used for\n    // verifying extend_fn_ as well as copy_frame_fn_.\n    EXPECT_EQ(ref_img_.frame_size, img_.frame_size);\n    for (int y = 0; y < img_.y_crop_height; ++y) {\n      for (int x = 0; x < img_.y_crop_width; ++x) {\n        ref_img_.y_buffer[x + y * ref_img_.y_stride] =\n            img_.y_buffer[x + y * img_.y_stride];\n      }\n    }\n\n    for (int y = 0; y < img_.uv_crop_height; ++y) {\n      for (int x = 0; x < img_.uv_crop_width; ++x) {\n        ref_img_.u_buffer[x + y * ref_img_.uv_stride] =\n            img_.u_buffer[x + y * img_.uv_stride];\n        ref_img_.v_buffer[x + y * ref_img_.uv_stride] =\n            img_.v_buffer[x + y * img_.uv_stride];\n      }\n    }\n\n    ReferenceExtendBorder();\n  }\n\n  void CompareImages(const YV12_BUFFER_CONFIG actual) {\n    EXPECT_EQ(ref_img_.frame_size, actual.frame_size);\n    EXPECT_EQ(0, memcmp(ref_img_.buffer_alloc, actual.buffer_alloc,\n                        ref_img_.frame_size));\n  }\n\n  YV12_BUFFER_CONFIG img_;\n  YV12_BUFFER_CONFIG ref_img_;\n  YV12_BUFFER_CONFIG dst_img_;\n}",
          "class_name": "VpxScaleBase",
          "class_pos": [
            [
              27,
              0
            ],
            [
              196,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"./vpx_config.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./vpx_scale_rtcd.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"test/acm_random.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"test/clear_system_state.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"test/register_state_check.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"vpx_mem/vpx_mem.h\"\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"vpx_scale/yv12config.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/yuv_video_source.h": {
      "fn_def_list": [
        {
          "fn_code": "YUVVideoSource(const std::string &file_name, vpx_img_fmt format,\n                 unsigned int width, unsigned int height, int rate_numerator,\n                 int rate_denominator, unsigned int start, int limit)\n      : file_name_(file_name), input_file_(NULL), img_(NULL), start_(start),\n        limit_(limit), frame_(0), width_(0), height_(0),\n        format_(VPX_IMG_FMT_NONE), framerate_numerator_(rate_numerator),\n        framerate_denominator_(rate_denominator) {\n    // This initializes format_, raw_size_, width_, height_ and allocates img.\n    SetSize(width, height, format);\n  }",
          "fn_code_pos": [
            [
              26,
              2
            ],
            [
              35,
              3
            ]
          ],
          "class_code": "9149a01973eb5c856287b94a5ec6a708b0c150e141c84ec6c3c22b17c67743b0",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              120,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "YUVVideoSource",
            "parameters": {
              "file_name": "std::string",
              "format": "vpx_img_fmt",
              "width": "unsigned int",
              "height": "unsigned int",
              "rate_numerator": "int",
              "rate_denominator": "int",
              "start": "unsigned int",
              "limit": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~YUVVideoSource() {\n    vpx_img_free(img_);\n    if (input_file_) fclose(input_file_);\n  }",
          "fn_code_pos": [
            [
              37,
              2
            ],
            [
              40,
              3
            ]
          ],
          "class_code": "9149a01973eb5c856287b94a5ec6a708b0c150e141c84ec6c3c22b17c67743b0",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              120,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void Begin() {\n    if (input_file_) fclose(input_file_);\n    input_file_ = OpenTestDataFile(file_name_);\n    ASSERT_TRUE(input_file_ != NULL)\n        << \"Input file open failed. Filename: \" << file_name_;\n    if (start_) {\n      fseek(input_file_, static_cast<unsigned>(raw_size_) * start_, SEEK_SET);\n    }\n\n    frame_ = start_;\n    FillFrame();\n  }",
          "fn_code_pos": [
            [
              42,
              2
            ],
            [
              53,
              3
            ]
          ],
          "class_code": "9149a01973eb5c856287b94a5ec6a708b0c150e141c84ec6c3c22b17c67743b0",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              120,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Begin",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void Next() {\n    ++frame_;\n    FillFrame();\n  }",
          "fn_code_pos": [
            [
              55,
              2
            ],
            [
              58,
              3
            ]
          ],
          "class_code": "9149a01973eb5c856287b94a5ec6a708b0c150e141c84ec6c3c22b17c67743b0",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              120,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Next",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual vpx_image_t *img() const { return (frame_ < limit_) ? img_ : NULL; }",
          "fn_code_pos": [
            [
              60,
              2
            ],
            [
              60,
              78
            ]
          ],
          "class_code": "9149a01973eb5c856287b94a5ec6a708b0c150e141c84ec6c3c22b17c67743b0",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              120,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "img",
            "parameters": {},
            "return_type": "vpx_image_t"
          }
        },
        {
          "fn_code": "virtual vpx_codec_pts_t pts() const { return frame_; }",
          "fn_code_pos": [
            [
              63,
              2
            ],
            [
              63,
              56
            ]
          ],
          "class_code": "9149a01973eb5c856287b94a5ec6a708b0c150e141c84ec6c3c22b17c67743b0",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              120,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "pts",
            "parameters": {},
            "return_type": "vpx_codec_pts_t"
          }
        },
        {
          "fn_code": "virtual unsigned long duration() const { return 1; }",
          "fn_code_pos": [
            [
              65,
              2
            ],
            [
              65,
              54
            ]
          ],
          "class_code": "9149a01973eb5c856287b94a5ec6a708b0c150e141c84ec6c3c22b17c67743b0",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              120,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "duration",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual vpx_rational_t timebase() const {\n    const vpx_rational_t t = { framerate_denominator_, framerate_numerator_ };\n    return t;\n  }",
          "fn_code_pos": [
            [
              67,
              2
            ],
            [
              70,
              3
            ]
          ],
          "class_code": "9149a01973eb5c856287b94a5ec6a708b0c150e141c84ec6c3c22b17c67743b0",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              120,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "timebase",
            "parameters": {},
            "return_type": "vpx_rational_t"
          }
        },
        {
          "fn_code": "virtual unsigned int frame() const { return frame_; }",
          "fn_code_pos": [
            [
              72,
              2
            ],
            [
              72,
              55
            ]
          ],
          "class_code": "9149a01973eb5c856287b94a5ec6a708b0c150e141c84ec6c3c22b17c67743b0",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              120,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "frame",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual unsigned int limit() const { return limit_; }",
          "fn_code_pos": [
            [
              74,
              2
            ],
            [
              74,
              55
            ]
          ],
          "class_code": "9149a01973eb5c856287b94a5ec6a708b0c150e141c84ec6c3c22b17c67743b0",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              120,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "limit",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void SetSize(unsigned int width, unsigned int height,\n                       vpx_img_fmt format) {\n    if (width != width_ || height != height_ || format != format_) {\n      vpx_img_free(img_);\n      img_ = vpx_img_alloc(NULL, format, width, height, 1);\n      ASSERT_TRUE(img_ != NULL);\n      width_ = width;\n      height_ = height;\n      format_ = format;\n      switch (format) {\n        case VPX_IMG_FMT_I420: raw_size_ = width * height * 3 / 2; break;\n        case VPX_IMG_FMT_I422: raw_size_ = width * height * 2; break;\n        case VPX_IMG_FMT_I440: raw_size_ = width * height * 2; break;\n        case VPX_IMG_FMT_I444: raw_size_ = width * height * 3; break;\n        case VPX_IMG_FMT_I42016: raw_size_ = width * height * 3; break;\n        case VPX_IMG_FMT_I42216: raw_size_ = width * height * 4; break;\n        case VPX_IMG_FMT_I44016: raw_size_ = width * height * 4; break;\n        case VPX_IMG_FMT_I44416: raw_size_ = width * height * 6; break;\n        default: ASSERT_TRUE(0);\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              76,
              2
            ],
            [
              97,
              3
            ]
          ],
          "class_code": "9149a01973eb5c856287b94a5ec6a708b0c150e141c84ec6c3c22b17c67743b0",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              120,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SetSize",
            "parameters": {
              "width": "unsigned int",
              "height": "unsigned int",
              "format": "vpx_img_fmt"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void FillFrame() {\n    ASSERT_TRUE(input_file_ != NULL);\n    // Read a frame from input_file.\n    if (fread(img_->img_data, raw_size_, 1, input_file_) == 0) {\n      limit_ = frame_;\n    }\n  }",
          "fn_code_pos": [
            [
              99,
              2
            ],
            [
              105,
              3
            ]
          ],
          "class_code": "9149a01973eb5c856287b94a5ec6a708b0c150e141c84ec6c3c22b17c67743b0",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              120,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillFrame",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "img() const",
          "fn_dec_pos": [
            [
              60,
              23
            ],
            [
              60,
              34
            ]
          ],
          "class_code": "9149a01973eb5c856287b94a5ec6a708b0c150e141c84ec6c3c22b17c67743b0",
          "class_node_pos": [
            [
              24,
              0
            ],
            [
              120,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "img",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "9149a01973eb5c856287b94a5ec6a708b0c150e141c84ec6c3c22b17c67743b0": {
          "class_code": "class YUVVideoSource : public VideoSource {\n public:\n  YUVVideoSource(const std::string &file_name, vpx_img_fmt format,\n                 unsigned int width, unsigned int height, int rate_numerator,\n                 int rate_denominator, unsigned int start, int limit)\n      : file_name_(file_name), input_file_(NULL), img_(NULL), start_(start),\n        limit_(limit), frame_(0), width_(0), height_(0),\n        format_(VPX_IMG_FMT_NONE), framerate_numerator_(rate_numerator),\n        framerate_denominator_(rate_denominator) {\n    // This initializes format_, raw_size_, width_, height_ and allocates img.\n    SetSize(width, height, format);\n  }\n\n  virtual ~YUVVideoSource() {\n    vpx_img_free(img_);\n    if (input_file_) fclose(input_file_);\n  }\n\n  virtual void Begin() {\n    if (input_file_) fclose(input_file_);\n    input_file_ = OpenTestDataFile(file_name_);\n    ASSERT_TRUE(input_file_ != NULL)\n        << \"Input file open failed. Filename: \" << file_name_;\n    if (start_) {\n      fseek(input_file_, static_cast<unsigned>(raw_size_) * start_, SEEK_SET);\n    }\n\n    frame_ = start_;\n    FillFrame();\n  }\n\n  virtual void Next() {\n    ++frame_;\n    FillFrame();\n  }\n\n  virtual vpx_image_t *img() const { return (frame_ < limit_) ? img_ : NULL; }\n\n  // Models a stream where Timebase = 1/FPS, so pts == frame.\n  virtual vpx_codec_pts_t pts() const { return frame_; }\n\n  virtual unsigned long duration() const { return 1; }\n\n  virtual vpx_rational_t timebase() const {\n    const vpx_rational_t t = { framerate_denominator_, framerate_numerator_ };\n    return t;\n  }\n\n  virtual unsigned int frame() const { return frame_; }\n\n  virtual unsigned int limit() const { return limit_; }\n\n  virtual void SetSize(unsigned int width, unsigned int height,\n                       vpx_img_fmt format) {\n    if (width != width_ || height != height_ || format != format_) {\n      vpx_img_free(img_);\n      img_ = vpx_img_alloc(NULL, format, width, height, 1);\n      ASSERT_TRUE(img_ != NULL);\n      width_ = width;\n      height_ = height;\n      format_ = format;\n      switch (format) {\n        case VPX_IMG_FMT_I420: raw_size_ = width * height * 3 / 2; break;\n        case VPX_IMG_FMT_I422: raw_size_ = width * height * 2; break;\n        case VPX_IMG_FMT_I440: raw_size_ = width * height * 2; break;\n        case VPX_IMG_FMT_I444: raw_size_ = width * height * 3; break;\n        case VPX_IMG_FMT_I42016: raw_size_ = width * height * 3; break;\n        case VPX_IMG_FMT_I42216: raw_size_ = width * height * 4; break;\n        case VPX_IMG_FMT_I44016: raw_size_ = width * height * 4; break;\n        case VPX_IMG_FMT_I44416: raw_size_ = width * height * 6; break;\n        default: ASSERT_TRUE(0);\n      }\n    }\n  }\n\n  virtual void FillFrame() {\n    ASSERT_TRUE(input_file_ != NULL);\n    // Read a frame from input_file.\n    if (fread(img_->img_data, raw_size_, 1, input_file_) == 0) {\n      limit_ = frame_;\n    }\n  }\n\n protected:\n  std::string file_name_;\n  FILE *input_file_;\n  vpx_image_t *img_;\n  size_t raw_size_;\n  unsigned int start_;\n  unsigned int limit_;\n  unsigned int frame_;\n  unsigned int width_;\n  unsigned int height_;\n  vpx_img_fmt format_;\n  int framerate_numerator_;\n  int framerate_denominator_;\n}",
          "class_name": "YUVVideoSource",
          "class_pos": [
            [
              24,
              0
            ],
            [
              120,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <cstdio>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <cstdlib>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"test/video_source.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_image.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/clear_system_state.h": {
      "fn_def_list": [
        {
          "fn_code": "inline void ClearSystemState() { vpx_clear_system_state(); }",
          "fn_code_pos": [
            [
              19,
              0
            ],
            [
              19,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ClearSystemState",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"./vpx_config.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"vpx_ports/system_state.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/y4m_video_source.h": {
      "fn_def_list": [
        {
          "fn_code": "Y4mVideoSource(const std::string &file_name, unsigned int start, int limit)\n      : file_name_(file_name), input_file_(NULL), img_(new vpx_image_t()),\n        start_(start), limit_(limit), frame_(0), framerate_numerator_(0),\n        framerate_denominator_(0), y4m_() {}",
          "fn_code_pos": [
            [
              24,
              2
            ],
            [
              27,
              44
            ]
          ],
          "class_code": "e5c99904a94360efddb1c30da22048cc33459e823561634f14efd80895133a38",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              118,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Y4mVideoSource",
            "parameters": {
              "file_name": "std::string",
              "start": "unsigned int",
              "limit": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "virtual ~Y4mVideoSource() {\n    vpx_img_free(img_.get());\n    CloseSource();\n  }",
          "fn_code_pos": [
            [
              29,
              2
            ],
            [
              32,
              3
            ]
          ],
          "class_code": "e5c99904a94360efddb1c30da22048cc33459e823561634f14efd80895133a38",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              118,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void OpenSource() {\n    CloseSource();\n    input_file_ = OpenTestDataFile(file_name_);\n    ASSERT_TRUE(input_file_ != NULL)\n        << \"Input file open failed. Filename: \" << file_name_;\n  }",
          "fn_code_pos": [
            [
              34,
              2
            ],
            [
              39,
              3
            ]
          ],
          "class_code": "e5c99904a94360efddb1c30da22048cc33459e823561634f14efd80895133a38",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              118,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "OpenSource",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void ReadSourceToStart() {\n    ASSERT_TRUE(input_file_ != NULL);\n    ASSERT_FALSE(y4m_input_open(&y4m_, input_file_, NULL, 0, 0));\n    framerate_numerator_ = y4m_.fps_n;\n    framerate_denominator_ = y4m_.fps_d;\n    frame_ = 0;\n    for (unsigned int i = 0; i < start_; i++) {\n      Next();\n    }\n    FillFrame();\n  }",
          "fn_code_pos": [
            [
              41,
              2
            ],
            [
              51,
              3
            ]
          ],
          "class_code": "e5c99904a94360efddb1c30da22048cc33459e823561634f14efd80895133a38",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              118,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ReadSourceToStart",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void Begin() {\n    OpenSource();\n    ReadSourceToStart();\n  }",
          "fn_code_pos": [
            [
              53,
              2
            ],
            [
              56,
              3
            ]
          ],
          "class_code": "e5c99904a94360efddb1c30da22048cc33459e823561634f14efd80895133a38",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              118,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Begin",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual void Next() {\n    ++frame_;\n    FillFrame();\n  }",
          "fn_code_pos": [
            [
              58,
              2
            ],
            [
              61,
              3
            ]
          ],
          "class_code": "e5c99904a94360efddb1c30da22048cc33459e823561634f14efd80895133a38",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              118,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "Next",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "virtual vpx_image_t *img() const {\n    return (frame_ < limit_) ? img_.get() : NULL;\n  }",
          "fn_code_pos": [
            [
              63,
              2
            ],
            [
              65,
              3
            ]
          ],
          "class_code": "e5c99904a94360efddb1c30da22048cc33459e823561634f14efd80895133a38",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              118,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "img",
            "parameters": {},
            "return_type": "vpx_image_t"
          }
        },
        {
          "fn_code": "virtual vpx_codec_pts_t pts() const { return frame_; }",
          "fn_code_pos": [
            [
              68,
              2
            ],
            [
              68,
              56
            ]
          ],
          "class_code": "e5c99904a94360efddb1c30da22048cc33459e823561634f14efd80895133a38",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              118,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "pts",
            "parameters": {},
            "return_type": "vpx_codec_pts_t"
          }
        },
        {
          "fn_code": "virtual unsigned long duration() const { return 1; }",
          "fn_code_pos": [
            [
              70,
              2
            ],
            [
              70,
              54
            ]
          ],
          "class_code": "e5c99904a94360efddb1c30da22048cc33459e823561634f14efd80895133a38",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              118,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "duration",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual vpx_rational_t timebase() const {\n    const vpx_rational_t t = { framerate_denominator_, framerate_numerator_ };\n    return t;\n  }",
          "fn_code_pos": [
            [
              72,
              2
            ],
            [
              75,
              3
            ]
          ],
          "class_code": "e5c99904a94360efddb1c30da22048cc33459e823561634f14efd80895133a38",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              118,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "timebase",
            "parameters": {},
            "return_type": "vpx_rational_t"
          }
        },
        {
          "fn_code": "virtual unsigned int frame() const { return frame_; }",
          "fn_code_pos": [
            [
              77,
              2
            ],
            [
              77,
              55
            ]
          ],
          "class_code": "e5c99904a94360efddb1c30da22048cc33459e823561634f14efd80895133a38",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              118,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "frame",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual unsigned int limit() const { return limit_; }",
          "fn_code_pos": [
            [
              79,
              2
            ],
            [
              79,
              55
            ]
          ],
          "class_code": "e5c99904a94360efddb1c30da22048cc33459e823561634f14efd80895133a38",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              118,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "limit",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "virtual void FillFrame() {\n    ASSERT_TRUE(input_file_ != NULL);\n    // Read a frame from input_file.\n    y4m_input_fetch_frame(&y4m_, input_file_, img_.get());\n  }",
          "fn_code_pos": [
            [
              81,
              2
            ],
            [
              85,
              3
            ]
          ],
          "class_code": "e5c99904a94360efddb1c30da22048cc33459e823561634f14efd80895133a38",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              118,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "FillFrame",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SwapBuffers(Y4mVideoSource *other) {\n    std::swap(other->y4m_.dst_buf, y4m_.dst_buf);\n    vpx_image_t *tmp;\n    tmp = other->img_.release();\n    other->img_.reset(img_.release());\n    img_.reset(tmp);\n  }",
          "fn_code_pos": [
            [
              91,
              2
            ],
            [
              97,
              3
            ]
          ],
          "class_code": "e5c99904a94360efddb1c30da22048cc33459e823561634f14efd80895133a38",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              118,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "SwapBuffers",
            "parameters": {
              "other": "Y4mVideoSource"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void CloseSource() {\n    y4m_input_close(&y4m_);\n    y4m_ = y4m_input();\n    if (input_file_ != NULL) {\n      fclose(input_file_);\n      input_file_ = NULL;\n    }\n  }",
          "fn_code_pos": [
            [
              100,
              2
            ],
            [
              107,
              3
            ]
          ],
          "class_code": "e5c99904a94360efddb1c30da22048cc33459e823561634f14efd80895133a38",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              118,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "CloseSource",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "img() const",
          "fn_dec_pos": [
            [
              63,
              23
            ],
            [
              63,
              34
            ]
          ],
          "class_code": "e5c99904a94360efddb1c30da22048cc33459e823561634f14efd80895133a38",
          "class_node_pos": [
            [
              22,
              0
            ],
            [
              118,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "img",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "e5c99904a94360efddb1c30da22048cc33459e823561634f14efd80895133a38": {
          "class_code": "class Y4mVideoSource : public VideoSource {\n public:\n  Y4mVideoSource(const std::string &file_name, unsigned int start, int limit)\n      : file_name_(file_name), input_file_(NULL), img_(new vpx_image_t()),\n        start_(start), limit_(limit), frame_(0), framerate_numerator_(0),\n        framerate_denominator_(0), y4m_() {}\n\n  virtual ~Y4mVideoSource() {\n    vpx_img_free(img_.get());\n    CloseSource();\n  }\n\n  virtual void OpenSource() {\n    CloseSource();\n    input_file_ = OpenTestDataFile(file_name_);\n    ASSERT_TRUE(input_file_ != NULL)\n        << \"Input file open failed. Filename: \" << file_name_;\n  }\n\n  virtual void ReadSourceToStart() {\n    ASSERT_TRUE(input_file_ != NULL);\n    ASSERT_FALSE(y4m_input_open(&y4m_, input_file_, NULL, 0, 0));\n    framerate_numerator_ = y4m_.fps_n;\n    framerate_denominator_ = y4m_.fps_d;\n    frame_ = 0;\n    for (unsigned int i = 0; i < start_; i++) {\n      Next();\n    }\n    FillFrame();\n  }\n\n  virtual void Begin() {\n    OpenSource();\n    ReadSourceToStart();\n  }\n\n  virtual void Next() {\n    ++frame_;\n    FillFrame();\n  }\n\n  virtual vpx_image_t *img() const {\n    return (frame_ < limit_) ? img_.get() : NULL;\n  }\n\n  // Models a stream where Timebase = 1/FPS, so pts == frame.\n  virtual vpx_codec_pts_t pts() const { return frame_; }\n\n  virtual unsigned long duration() const { return 1; }\n\n  virtual vpx_rational_t timebase() const {\n    const vpx_rational_t t = { framerate_denominator_, framerate_numerator_ };\n    return t;\n  }\n\n  virtual unsigned int frame() const { return frame_; }\n\n  virtual unsigned int limit() const { return limit_; }\n\n  virtual void FillFrame() {\n    ASSERT_TRUE(input_file_ != NULL);\n    // Read a frame from input_file.\n    y4m_input_fetch_frame(&y4m_, input_file_, img_.get());\n  }\n\n  // Swap buffers with another y4m source. This allows reading a new frame\n  // while keeping the old frame around. A whole Y4mSource is required and\n  // not just a vpx_image_t because of how the y4m reader manipulates\n  // vpx_image_t internals,\n  void SwapBuffers(Y4mVideoSource *other) {\n    std::swap(other->y4m_.dst_buf, y4m_.dst_buf);\n    vpx_image_t *tmp;\n    tmp = other->img_.release();\n    other->img_.reset(img_.release());\n    img_.reset(tmp);\n  }\n\n protected:\n  void CloseSource() {\n    y4m_input_close(&y4m_);\n    y4m_ = y4m_input();\n    if (input_file_ != NULL) {\n      fclose(input_file_);\n      input_file_ = NULL;\n    }\n  }\n\n  std::string file_name_;\n  FILE *input_file_;\n  std::unique_ptr<vpx_image_t> img_;\n  unsigned int start_;\n  unsigned int limit_;\n  unsigned int frame_;\n  int framerate_numerator_;\n  int framerate_denominator_;\n  y4m_input y4m_;\n}",
          "class_name": "Y4mVideoSource",
          "class_pos": [
            [
              22,
              0
            ],
            [
              118,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <algorithm>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <memory>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <string>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"test/video_source.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"./y4minput.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libvpx/test/util.h": {
      "fn_def_list": [
        {
          "fn_code": "inline double compute_psnr(const vpx_image_t *img1, const vpx_image_t *img2) {\n  assert((img1->fmt == img2->fmt) && (img1->d_w == img2->d_w) &&\n         (img1->d_h == img2->d_h));\n\n  const unsigned int width_y = img1->d_w;\n  const unsigned int height_y = img1->d_h;\n  unsigned int i, j;\n\n  int64_t sqrerr = 0;\n  for (i = 0; i < height_y; ++i) {\n    for (j = 0; j < width_y; ++j) {\n      int64_t d = img1->planes[VPX_PLANE_Y][i * img1->stride[VPX_PLANE_Y] + j] -\n                  img2->planes[VPX_PLANE_Y][i * img2->stride[VPX_PLANE_Y] + j];\n      sqrerr += d * d;\n    }\n  }\n  double mse = static_cast<double>(sqrerr) / (width_y * height_y);\n  double psnr = 100.0;\n  if (mse > 0.0) {\n    psnr = 10 * log10(255.0 * 255.0 / mse);\n  }\n  return psnr;\n}",
          "fn_code_pos": [
            [
              23,
              0
            ],
            [
              45,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compute_psnr",
            "parameters": {
              "img1": "vpx_image_t",
              "img2": "vpx_image_t"
            },
            "return_type": "double"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include <tuple>\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"third_party/googletest/src/include/gtest/gtest.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"vpx/vpx_image.h\"\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    }
  }
}