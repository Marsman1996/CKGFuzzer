{
  "src": {
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/test.c": {
      "fn_def_list": [
        {
          "fn_code": "static int print_preallocated(cJSON *root)\n{\n    /* declarations */\n    char *out = NULL;\n    char *buf = NULL;\n    char *buf_fail = NULL;\n    size_t len = 0;\n    size_t len_fail = 0;\n\n    /* formatted print */\n    out = cJSON_Print(root);\n\n    /* create buffer to succeed */\n    /* the extra 5 bytes are because of inaccuracies when reserving memory */\n    len = strlen(out) + 5;\n    buf = (char*)malloc(len);\n    if (buf == NULL)\n    {\n        printf(\"Failed to allocate memory.\\n\");\n        exit(1);\n    }\n\n    /* create buffer to fail */\n    len_fail = strlen(out);\n    buf_fail = (char*)malloc(len_fail);\n    if (buf_fail == NULL)\n    {\n        printf(\"Failed to allocate memory.\\n\");\n        exit(1);\n    }\n\n    /* Print to buffer */\n    if (!cJSON_PrintPreallocated(root, buf, (int)len, 1)) {\n        printf(\"cJSON_PrintPreallocated failed!\\n\");\n        if (strcmp(out, buf) != 0) {\n            printf(\"cJSON_PrintPreallocated not the same as cJSON_Print!\\n\");\n            printf(\"cJSON_Print result:\\n%s\\n\", out);\n            printf(\"cJSON_PrintPreallocated result:\\n%s\\n\", buf);\n        }\n        free(out);\n        free(buf_fail);\n        free(buf);\n        return -1;\n    }\n\n    /* success */\n    printf(\"%s\\n\", buf);\n\n    /* force it to fail */\n    if (cJSON_PrintPreallocated(root, buf_fail, (int)len_fail, 1)) {\n        printf(\"cJSON_PrintPreallocated failed to show error with insufficient memory!\\n\");\n        printf(\"cJSON_Print result:\\n%s\\n\", out);\n        printf(\"cJSON_PrintPreallocated result:\\n%s\\n\", buf_fail);\n        free(out);\n        free(buf_fail);\n        free(buf);\n        return -1;\n    }\n\n    free(out);\n    free(buf_fail);\n    free(buf);\n    return 0;\n}",
          "fn_code_pos": [
            [
              42,
              0
            ],
            [
              105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_preallocated",
            "parameters": {
              "root": "cJSON"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void create_objects(void)\n{\n    /* declare a few. */\n    cJSON *root = NULL;\n    cJSON *fmt = NULL;\n    cJSON *img = NULL;\n    cJSON *thm = NULL;\n    cJSON *fld = NULL;\n    int i = 0;\n\n    /* Our \"days of the week\" array: */\n    const char *strings[7] =\n    {\n        \"Sunday\",\n        \"Monday\",\n        \"Tuesday\",\n        \"Wednesday\",\n        \"Thursday\",\n        \"Friday\",\n        \"Saturday\"\n    };\n    /* Our matrix: */\n    int numbers[3][3] =\n    {\n        {0, -1, 0},\n        {1, 0, 0},\n        {0 ,0, 1}\n    };\n    /* Our \"gallery\" item: */\n    int ids[4] = { 116, 943, 234, 38793 };\n    /* Our array of \"records\": */\n    struct record fields[2] =\n    {\n        {\n            \"zip\",\n            37.7668,\n            -1.223959e+2,\n            \"\",\n            \"SAN FRANCISCO\",\n            \"CA\",\n            \"94107\",\n            \"US\"\n        },\n        {\n            \"zip\",\n            37.371991,\n            -1.22026e+2,\n            \"\",\n            \"SUNNYVALE\",\n            \"CA\",\n            \"94085\",\n            \"US\"\n        }\n    };\n    volatile double zero = 0.0;\n\n    /* Here we construct some JSON standards, from the JSON site. */\n\n    /* Our \"Video\" datatype: */\n    root = cJSON_CreateObject();\n    cJSON_AddItemToObject(root, \"name\", cJSON_CreateString(\"Jack (\\\"Bee\\\") Nimble\"));\n    cJSON_AddItemToObject(root, \"format\", fmt = cJSON_CreateObject());\n    cJSON_AddStringToObject(fmt, \"type\", \"rect\");\n    cJSON_AddNumberToObject(fmt, \"width\", 1920);\n    cJSON_AddNumberToObject(fmt, \"height\", 1080);\n    cJSON_AddFalseToObject (fmt, \"interlace\");\n    cJSON_AddNumberToObject(fmt, \"frame rate\", 24);\n\n    /* Print to text */\n    if (print_preallocated(root) != 0) {\n        cJSON_Delete(root);\n        exit(EXIT_FAILURE);\n    }\n    cJSON_Delete(root);\n\n    /* Our \"days of the week\" array: */\n    root = cJSON_CreateStringArray(strings, 7);\n\n    if (print_preallocated(root) != 0) {\n        cJSON_Delete(root);\n        exit(EXIT_FAILURE);\n    }\n    cJSON_Delete(root);\n\n    /* Our matrix: */\n    root = cJSON_CreateArray();\n    for (i = 0; i < 3; i++)\n    {\n        cJSON_AddItemToArray(root, cJSON_CreateIntArray(numbers[i], 3));\n    }\n\n    /* cJSON_ReplaceItemInArray(root, 1, cJSON_CreateString(\"Replacement\")); */\n\n    if (print_preallocated(root) != 0) {\n        cJSON_Delete(root);\n        exit(EXIT_FAILURE);\n    }\n    cJSON_Delete(root);\n\n    /* Our \"gallery\" item: */\n    root = cJSON_CreateObject();\n    cJSON_AddItemToObject(root, \"Image\", img = cJSON_CreateObject());\n    cJSON_AddNumberToObject(img, \"Width\", 800);\n    cJSON_AddNumberToObject(img, \"Height\", 600);\n    cJSON_AddStringToObject(img, \"Title\", \"View from 15th Floor\");\n    cJSON_AddItemToObject(img, \"Thumbnail\", thm = cJSON_CreateObject());\n    cJSON_AddStringToObject(thm, \"Url\", \"http:/*www.example.com/image/481989943\");\n    cJSON_AddNumberToObject(thm, \"Height\", 125);\n    cJSON_AddStringToObject(thm, \"Width\", \"100\");\n    cJSON_AddItemToObject(img, \"IDs\", cJSON_CreateIntArray(ids, 4));\n\n    if (print_preallocated(root) != 0) {\n        cJSON_Delete(root);\n        exit(EXIT_FAILURE);\n    }\n    cJSON_Delete(root);\n\n    /* Our array of \"records\": */\n    root = cJSON_CreateArray();\n    for (i = 0; i < 2; i++)\n    {\n        cJSON_AddItemToArray(root, fld = cJSON_CreateObject());\n        cJSON_AddStringToObject(fld, \"precision\", fields[i].precision);\n        cJSON_AddNumberToObject(fld, \"Latitude\", fields[i].lat);\n        cJSON_AddNumberToObject(fld, \"Longitude\", fields[i].lon);\n        cJSON_AddStringToObject(fld, \"Address\", fields[i].address);\n        cJSON_AddStringToObject(fld, \"City\", fields[i].city);\n        cJSON_AddStringToObject(fld, \"State\", fields[i].state);\n        cJSON_AddStringToObject(fld, \"Zip\", fields[i].zip);\n        cJSON_AddStringToObject(fld, \"Country\", fields[i].country);\n    }\n\n    /* cJSON_ReplaceItemInObject(cJSON_GetArrayItem(root, 1), \"City\", cJSON_CreateIntArray(ids, 4)); */\n\n    if (print_preallocated(root) != 0) {\n        cJSON_Delete(root);\n        exit(EXIT_FAILURE);\n    }\n    cJSON_Delete(root);\n\n    root = cJSON_CreateObject();\n    cJSON_AddNumberToObject(root, \"number\", 1.0 / zero);\n\n    if (print_preallocated(root) != 0) {\n        cJSON_Delete(root);\n        exit(EXIT_FAILURE);\n    }\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              108,
              0
            ],
            [
              256,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "create_objects",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int CJSON_CDECL main(void)\n{\n    /* print the version */\n    printf(\"Version: %s\\n\", cJSON_Version());\n\n    /* Now some samplecode for building objects concisely: */\n    create_objects();\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              258,
              0
            ],
            [
              267,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct record\n{\n    const char *precision;\n    double lat;\n    double lon;\n    const char *address;\n    const char *city;\n    const char *state;\n    const char *zip;\n    const char *country;\n}",
          {
            "char": "const",
            "lat": "double",
            "lon": "double"
          },
          "record",
          [
            28,
            0
          ],
          [
            38,
            1
          ]
        ],
        [
          "struct record\n{\n    const char *precision;\n    double lat;\n    double lon;\n    const char *address;\n    const char *city;\n    const char *state;\n    const char *zip;\n    const char *country;\n}",
          {
            "char": "const",
            "lat": "double",
            "lon": "double"
          },
          "record",
          [
            28,
            0
          ],
          [
            38,
            1
          ]
        ],
        [
          "struct record",
          {},
          "",
          [
            139,
            4
          ],
          [
            139,
            17
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"cJSON.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/cJSON_Utils.c": {
      "fn_def_list": [
        {
          "fn_code": "static unsigned char* cJSONUtils_strdup(const unsigned char* const string)\n{\n    size_t length = 0;\n    unsigned char *copy = NULL;\n\n    length = strlen((const char*)string) + sizeof(\"\");\n    copy = (unsigned char*) cJSON_malloc(length);\n    if (copy == NULL)\n    {\n        return NULL;\n    }\n    memcpy(copy, string, length);\n\n    return copy;\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_strdup",
            "parameters": {
              "string": "unsigned char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static int compare_strings(const unsigned char *string1, const unsigned char *string2, const cJSON_bool case_sensitive)\n{\n    if ((string1 == NULL) || (string2 == NULL))\n    {\n        return 1;\n    }\n\n    if (string1 == string2)\n    {\n        return 0;\n    }\n\n    if (case_sensitive)\n    {\n        return strcmp((const char*)string1, (const char*)string2);\n    }\n\n    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)\n    {\n        if (*string1 == '\\0')\n        {\n            return 0;\n        }\n    }\n\n    return tolower(*string1) - tolower(*string2);\n}",
          "fn_code_pos": [
            [
              82,
              0
            ],
            [
              108,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compare_strings",
            "parameters": {
              "string1": "unsigned char",
              "string2": "unsigned char",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static cJSON_bool compare_double(double a, double b)\n{\n    double maxVal = fabs(a) > fabs(b) ? fabs(a) : fabs(b);\n    return (fabs(a - b) <= maxVal * DBL_EPSILON);\n}",
          "fn_code_pos": [
            [
              111,
              0
            ],
            [
              115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compare_double",
            "parameters": {
              "a": "double",
              "b": "double"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "static cJSON_bool compare_pointers(const unsigned char *name, const unsigned char *pointer, const cJSON_bool case_sensitive)\n{\n    if ((name == NULL) || (pointer == NULL))\n    {\n        return false;\n    }\n\n    for (; (*name != '\\0') && (*pointer != '\\0') && (*pointer != '/'); (void)name++, pointer++) /* compare until next '/' */\n    {\n        if (*pointer == '~')\n        {\n            /* check for escaped '~' (~0) and '/' (~1) */\n            if (((pointer[1] != '0') || (*name != '~')) && ((pointer[1] != '1') || (*name != '/')))\n            {\n                /* invalid escape sequence or wrong character in *name */\n                return false;\n            }\n            else\n            {\n                pointer++;\n            }\n        }\n        else if ((!case_sensitive && (tolower(*name) != tolower(*pointer))) || (case_sensitive && (*name != *pointer)))\n        {\n            return false;\n        }\n    }\n    if (((*pointer != 0) && (*pointer != '/')) != (*name != 0))\n    {\n        /* one string has ended, the other not */\n        return false;;\n    }\n\n    return true;\n}",
          "fn_code_pos": [
            [
              119,
              0
            ],
            [
              153,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compare_pointers",
            "parameters": {
              "name": "unsigned char",
              "pointer": "unsigned char",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "static size_t pointer_encoded_length(const unsigned char *string)\n{\n    size_t length;\n    for (length = 0; *string != '\\0'; (void)string++, length++)\n    {\n        /* character needs to be escaped? */\n        if ((*string == '~') || (*string == '/'))\n        {\n            length++;\n        }\n    }\n\n    return length;\n}",
          "fn_code_pos": [
            [
              156,
              0
            ],
            [
              169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pointer_encoded_length",
            "parameters": {
              "string": "unsigned char"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "static void encode_string_as_pointer(unsigned char *destination, const unsigned char *source)\n{\n    for (; source[0] != '\\0'; (void)source++, destination++)\n    {\n        if (source[0] == '/')\n        {\n            destination[0] = '~';\n            destination[1] = '1';\n            destination++;\n        }\n        else if (source[0] == '~')\n        {\n            destination[0] = '~';\n            destination[1] = '0';\n            destination++;\n        }\n        else\n        {\n            destination[0] = source[0];\n        }\n    }\n\n    destination[0] = '\\0';\n}",
          "fn_code_pos": [
            [
              172,
              0
            ],
            [
              195,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "encode_string_as_pointer",
            "parameters": {
              "destination": "unsigned char",
              "source": "unsigned char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cJSONUtils_FindPointerFromObjectTo(const cJSON * const object, const cJSON * const target)\n{\n    size_t child_index = 0;\n    cJSON *current_child = 0;\n\n    if ((object == NULL) || (target == NULL))\n    {\n        return NULL;\n    }\n\n    if (object == target)\n    {\n        /* found */\n        return (char*)cJSONUtils_strdup((const unsigned char*)\"\");\n    }\n\n    /* recursively search all children of the object or array */\n    for (current_child = object->child; current_child != NULL; (void)(current_child = current_child->next), child_index++)\n    {\n        unsigned char *target_pointer = (unsigned char*)cJSONUtils_FindPointerFromObjectTo(current_child, target);\n        /* found the target? */\n        if (target_pointer != NULL)\n        {\n            if (cJSON_IsArray(object))\n            {\n                /* reserve enough memory for a 64 bit integer + '/' and '\\0' */\n                unsigned char *full_pointer = (unsigned char*)cJSON_malloc(strlen((char*)target_pointer) + 20 + sizeof(\"/\"));\n                /* check if conversion to unsigned long is valid\n                 * This should be eliminated at compile time by dead code elimination\n                 * if size_t is an alias of unsigned long, or if it is bigger */\n                if (child_index > ULONG_MAX)\n                {\n                    cJSON_free(target_pointer);\n                    cJSON_free(full_pointer);\n                    return NULL;\n                }\n                sprintf((char*)full_pointer, \"/%lu%s\", (unsigned long)child_index, target_pointer); /* /<array_index><path> */\n                cJSON_free(target_pointer);\n\n                return (char*)full_pointer;\n            }\n\n            if (cJSON_IsObject(object))\n            {\n                unsigned char *full_pointer = (unsigned char*)cJSON_malloc(strlen((char*)target_pointer) + pointer_encoded_length((unsigned char*)current_child->string) + 2);\n                full_pointer[0] = '/';\n                encode_string_as_pointer(full_pointer + 1, (unsigned char*)current_child->string);\n                strcat((char*)full_pointer, (char*)target_pointer);\n                cJSON_free(target_pointer);\n\n                return (char*)full_pointer;\n            }\n\n            /* reached leaf of the tree, found nothing */\n            cJSON_free(target_pointer);\n            return NULL;\n        }\n    }\n\n    /* not found */\n    return NULL;\n}",
          "fn_code_pos": [
            [
              197,
              21
            ],
            [
              258,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_FindPointerFromObjectTo",
            "parameters": {
              "object": "cJSON",
              "target": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static cJSON *get_array_item(const cJSON *array, size_t item)\n{\n    cJSON *child = array ? array->child : NULL;\n    while ((child != NULL) && (item > 0))\n    {\n        item--;\n        child = child->next;\n    }\n\n    return child;\n}",
          "fn_code_pos": [
            [
              261,
              0
            ],
            [
              271,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_array_item",
            "parameters": {
              "array": "cJSON",
              "item": "size_t"
            },
            "return_type": "cJSON"
          }
        },
        {
          "fn_code": "static cJSON_bool decode_array_index_from_pointer(const unsigned char * const pointer, size_t * const index)\n{\n    size_t parsed_index = 0;\n    size_t position = 0;\n\n    if ((pointer[0] == '0') && ((pointer[1] != '\\0') && (pointer[1] != '/')))\n    {\n        /* leading zeroes are not permitted */\n        return 0;\n    }\n\n    for (position = 0; (pointer[position] >= '0') && (pointer[0] <= '9'); position++)\n    {\n        parsed_index = (10 * parsed_index) + (size_t)(pointer[position] - '0');\n\n    }\n\n    if ((pointer[position] != '\\0') && (pointer[position] != '/'))\n    {\n        return 0;\n    }\n\n    *index = parsed_index;\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              273,
              0
            ],
            [
              298,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "decode_array_index_from_pointer",
            "parameters": {
              "pointer": "unsigned char",
              "index": "size_t"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "static cJSON *get_item_from_pointer(cJSON * const object, const char * pointer, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = object;\n\n    if (pointer == NULL)\n    {\n        return NULL;\n    }\n\n    /* follow path of the pointer */\n    while ((pointer[0] == '/') && (current_element != NULL))\n    {\n        pointer++;\n        if (cJSON_IsArray(current_element))\n        {\n            size_t index = 0;\n            if (!decode_array_index_from_pointer((const unsigned char*)pointer, &index))\n            {\n                return NULL;\n            }\n\n            current_element = get_array_item(current_element, index);\n        }\n        else if (cJSON_IsObject(current_element))\n        {\n            current_element = current_element->child;\n            /* GetObjectItem. */\n            while ((current_element != NULL) && !compare_pointers((unsigned char*)current_element->string, (const unsigned char*)pointer, case_sensitive))\n            {\n                current_element = current_element->next;\n            }\n        }\n        else\n        {\n            return NULL;\n        }\n\n        /* skip to the next path token or end of string */\n        while ((pointer[0] != '\\0') && (pointer[0] != '/'))\n        {\n            pointer++;\n        }\n    }\n\n    return current_element;\n}",
          "fn_code_pos": [
            [
              300,
              0
            ],
            [
              345,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_item_from_pointer",
            "parameters": {
              "object": "cJSON",
              "pointer": "char",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": "cJSON"
          }
        },
        {
          "fn_code": "cJSONUtils_GetPointer(cJSON * const object, const char *pointer)\n{\n    return get_item_from_pointer(object, pointer, false);\n}",
          "fn_code_pos": [
            [
              347,
              22
            ],
            [
              350,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_GetPointer",
            "parameters": {
              "object": "cJSON",
              "pointer": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_GetPointerCaseSensitive(cJSON * const object, const char *pointer)\n{\n    return get_item_from_pointer(object, pointer, true);\n}",
          "fn_code_pos": [
            [
              352,
              22
            ],
            [
              355,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_GetPointerCaseSensitive",
            "parameters": {
              "object": "cJSON",
              "pointer": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void decode_pointer_inplace(unsigned char *string)\n{\n    unsigned char *decoded_string = string;\n\n    if (string == NULL) {\n        return;\n    }\n\n    for (; *string; (void)decoded_string++, string++)\n    {\n        if (string[0] == '~')\n        {\n            if (string[1] == '0')\n            {\n                decoded_string[0] = '~';\n            }\n            else if (string[1] == '1')\n            {\n                decoded_string[1] = '/';\n            }\n            else\n            {\n                /* invalid escape sequence */\n                return;\n            }\n\n            string++;\n        }\n    }\n\n    decoded_string[0] = '\\0';\n}",
          "fn_code_pos": [
            [
              358,
              0
            ],
            [
              389,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "decode_pointer_inplace",
            "parameters": {
              "string": "unsigned char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static cJSON *detach_item_from_array(cJSON *array, size_t which)\n{\n    cJSON *c = array->child;\n    while (c && (which > 0))\n    {\n        c = c->next;\n        which--;\n    }\n    if (!c)\n    {\n        /* item doesn't exist */\n        return NULL;\n    }\n    if (c != array->child)\n    {\n        /* not the first element */\n        c->prev->next = c->next;\n    }\n    if (c->next)\n    {\n        c->next->prev = c->prev;\n    }\n    if (c == array->child)\n    {\n        array->child = c->next;\n    }\n    else if (c->next == NULL)\n    {\n        array->child->prev = c->prev;\n    }\n    /* make sure the detached item doesn't point anywhere anymore */\n    c->prev = c->next = NULL;\n\n    return c;\n}",
          "fn_code_pos": [
            [
              392,
              0
            ],
            [
              426,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "detach_item_from_array",
            "parameters": {
              "array": "cJSON",
              "which": "size_t"
            },
            "return_type": "cJSON"
          }
        },
        {
          "fn_code": "static cJSON *detach_path(cJSON *object, const unsigned char *path, const cJSON_bool case_sensitive)\n{\n    unsigned char *parent_pointer = NULL;\n    unsigned char *child_pointer = NULL;\n    cJSON *parent = NULL;\n    cJSON *detached_item = NULL;\n\n    /* copy path and split it in parent and child */\n    parent_pointer = cJSONUtils_strdup(path);\n    if (parent_pointer == NULL) {\n        goto cleanup;\n    }\n\n    child_pointer = (unsigned char*)strrchr((char*)parent_pointer, '/'); /* last '/' */\n    if (child_pointer == NULL)\n    {\n        goto cleanup;\n    }\n    /* split strings */\n    child_pointer[0] = '\\0';\n    child_pointer++;\n\n    parent = get_item_from_pointer(object, (char*)parent_pointer, case_sensitive);\n    decode_pointer_inplace(child_pointer);\n\n    if (cJSON_IsArray(parent))\n    {\n        size_t index = 0;\n        if (!decode_array_index_from_pointer(child_pointer, &index))\n        {\n            goto cleanup;\n        }\n        detached_item = detach_item_from_array(parent, index);\n    }\n    else if (cJSON_IsObject(parent))\n    {\n        detached_item = cJSON_DetachItemFromObject(parent, (char*)child_pointer);\n    }\n    else\n    {\n        /* Couldn't find object to remove child from. */\n        goto cleanup;\n    }\n\ncleanup:\n    if (parent_pointer != NULL)\n    {\n        cJSON_free(parent_pointer);\n    }\n\n    return detached_item;\n}",
          "fn_code_pos": [
            [
              429,
              0
            ],
            [
              480,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "detach_path",
            "parameters": {
              "object": "cJSON",
              "path": "unsigned char",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": "cJSON"
          }
        },
        {
          "fn_code": "static cJSON *sort_list(cJSON *list, const cJSON_bool case_sensitive)\n{\n    cJSON *first = list;\n    cJSON *second = list;\n    cJSON *current_item = list;\n    cJSON *result = list;\n    cJSON *result_tail = NULL;\n\n    if ((list == NULL) || (list->next == NULL))\n    {\n        /* One entry is sorted already. */\n        return result;\n    }\n\n    while ((current_item != NULL) && (current_item->next != NULL) && (compare_strings((unsigned char*)current_item->string, (unsigned char*)current_item->next->string, case_sensitive) < 0))\n    {\n        /* Test for list sorted. */\n        current_item = current_item->next;\n    }\n    if ((current_item == NULL) || (current_item->next == NULL))\n    {\n        /* Leave sorted lists unmodified. */\n        return result;\n    }\n\n    /* reset pointer to the beginning */\n    current_item = list;\n    while (current_item != NULL)\n    {\n        /* Walk two pointers to find the middle. */\n        second = second->next;\n        current_item = current_item->next;\n        /* advances current_item two steps at a time */\n        if (current_item != NULL)\n        {\n            current_item = current_item->next;\n        }\n    }\n    if ((second != NULL) && (second->prev != NULL))\n    {\n        /* Split the lists */\n        second->prev->next = NULL;\n        second->prev = NULL;\n    }\n\n    /* Recursively sort the sub-lists. */\n    first = sort_list(first, case_sensitive);\n    second = sort_list(second, case_sensitive);\n    result = NULL;\n\n    /* Merge the sub-lists */\n    while ((first != NULL) && (second != NULL))\n    {\n        cJSON *smaller = NULL;\n        if (compare_strings((unsigned char*)first->string, (unsigned char*)second->string, case_sensitive) < 0)\n        {\n            smaller = first;\n        }\n        else\n        {\n            smaller = second;\n        }\n\n        if (result == NULL)\n        {\n            /* start merged list with the smaller element */\n            result_tail = smaller;\n            result = smaller;\n        }\n        else\n        {\n            /* add smaller element to the list */\n            result_tail->next = smaller;\n            smaller->prev = result_tail;\n            result_tail = smaller;\n        }\n\n        if (first == smaller)\n        {\n            first = first->next;\n        }\n        else\n        {\n            second = second->next;\n        }\n    }\n\n    if (first != NULL)\n    {\n        /* Append rest of first list. */\n        if (result == NULL)\n        {\n            return first;\n        }\n        result_tail->next = first;\n        first->prev = result_tail;\n    }\n    if (second != NULL)\n    {\n        /* Append rest of second list */\n        if (result == NULL)\n        {\n            return second;\n        }\n        result_tail->next = second;\n        second->prev = result_tail;\n    }\n\n    return result;\n}",
          "fn_code_pos": [
            [
              483,
              0
            ],
            [
              592,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sort_list",
            "parameters": {
              "list": "cJSON",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": "cJSON"
          }
        },
        {
          "fn_code": "static void sort_object(cJSON * const object, const cJSON_bool case_sensitive)\n{\n    if (object == NULL)\n    {\n        return;\n    }\n    object->child = sort_list(object->child, case_sensitive);\n}",
          "fn_code_pos": [
            [
              594,
              0
            ],
            [
              601,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sort_object",
            "parameters": {
              "object": "cJSON",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static cJSON_bool compare_json(cJSON *a, cJSON *b, const cJSON_bool case_sensitive)\n{\n    if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)))\n    {\n        /* mismatched type. */\n        return false;\n    }\n    switch (a->type & 0xFF)\n    {\n        case cJSON_Number:\n            /* numeric mismatch. */\n            if ((a->valueint != b->valueint) || (!compare_double(a->valuedouble, b->valuedouble)))\n            {\n                return false;\n            }\n            else\n            {\n                return true;\n            }\n\n        case cJSON_String:\n            /* string mismatch. */\n            if (strcmp(a->valuestring, b->valuestring) != 0)\n            {\n                return false;\n            }\n            else\n            {\n                return true;\n            }\n\n        case cJSON_Array:\n            for ((void)(a = a->child), b = b->child; (a != NULL) && (b != NULL); (void)(a = a->next), b = b->next)\n            {\n                cJSON_bool identical = compare_json(a, b, case_sensitive);\n                if (!identical)\n                {\n                    return false;\n                }\n            }\n\n            /* array size mismatch? (one of both children is not NULL) */\n            if ((a != NULL) || (b != NULL))\n            {\n                return false;\n            }\n            else\n            {\n                return true;\n            }\n\n        case cJSON_Object:\n            sort_object(a, case_sensitive);\n            sort_object(b, case_sensitive);\n            for ((void)(a = a->child), b = b->child; (a != NULL) && (b != NULL); (void)(a = a->next), b = b->next)\n            {\n                cJSON_bool identical = false;\n                /* compare object keys */\n                if (compare_strings((unsigned char*)a->string, (unsigned char*)b->string, case_sensitive))\n                {\n                    /* missing member */\n                    return false;\n                }\n                identical = compare_json(a, b, case_sensitive);\n                if (!identical)\n                {\n                    return false;\n                }\n            }\n\n            /* object length mismatch (one of both children is not null) */\n            if ((a != NULL) || (b != NULL))\n            {\n                return false;\n            }\n            else\n            {\n                return true;\n            }\n\n        default:\n            break;\n    }\n\n    /* null, true or false */\n    return true;\n}",
          "fn_code_pos": [
            [
              603,
              0
            ],
            [
              689,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compare_json",
            "parameters": {
              "a": "cJSON",
              "b": "cJSON",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "static cJSON_bool insert_item_in_array(cJSON *array, size_t which, cJSON *newitem)\n{\n    cJSON *child = array->child;\n    while (child && (which > 0))\n    {\n        child = child->next;\n        which--;\n    }\n    if (which > 0)\n    {\n        /* item is after the end of the array */\n        return 0;\n    }\n    if (child == NULL)\n    {\n        cJSON_AddItemToArray(array, newitem);\n        return 1;\n    }\n\n    /* insert into the linked list */\n    newitem->next = child;\n    newitem->prev = child->prev;\n    child->prev = newitem;\n\n    /* was it at the beginning */\n    if (child == array->child)\n    {\n        array->child = newitem;\n    }\n    else\n    {\n        newitem->prev->next = newitem;\n    }\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              692,
              0
            ],
            [
              727,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "insert_item_in_array",
            "parameters": {
              "array": "cJSON",
              "which": "size_t",
              "newitem": "cJSON"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "static cJSON *get_object_item(const cJSON * const object, const char* name, const cJSON_bool case_sensitive)\n{\n    if (case_sensitive)\n    {\n        return cJSON_GetObjectItemCaseSensitive(object, name);\n    }\n\n    return cJSON_GetObjectItem(object, name);\n}",
          "fn_code_pos": [
            [
              729,
              0
            ],
            [
              737,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_object_item",
            "parameters": {
              "object": "cJSON",
              "name": "char",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": "cJSON"
          }
        },
        {
          "fn_code": "static enum patch_operation decode_patch_operation(const cJSON * const patch, const cJSON_bool case_sensitive)\n{\n    cJSON *operation = get_object_item(patch, \"op\", case_sensitive);\n    if (!cJSON_IsString(operation))\n    {\n        return INVALID;\n    }\n\n    if (strcmp(operation->valuestring, \"add\") == 0)\n    {\n        return ADD;\n    }\n\n    if (strcmp(operation->valuestring, \"remove\") == 0)\n    {\n        return REMOVE;\n    }\n\n    if (strcmp(operation->valuestring, \"replace\") == 0)\n    {\n        return REPLACE;\n    }\n\n    if (strcmp(operation->valuestring, \"move\") == 0)\n    {\n        return MOVE;\n    }\n\n    if (strcmp(operation->valuestring, \"copy\") == 0)\n    {\n        return COPY;\n    }\n\n    if (strcmp(operation->valuestring, \"test\") == 0)\n    {\n        return TEST;\n    }\n\n    return INVALID;\n}",
          "fn_code_pos": [
            [
              741,
              0
            ],
            [
              780,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "decode_patch_operation",
            "parameters": {
              "patch": "cJSON",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void overwrite_item(cJSON * const root, const cJSON replacement)\n{\n    if (root == NULL)\n    {\n        return;\n    }\n\n    if (root->string != NULL)\n    {\n        cJSON_free(root->string);\n    }\n    if (root->valuestring != NULL)\n    {\n        cJSON_free(root->valuestring);\n    }\n    if (root->child != NULL)\n    {\n        cJSON_Delete(root->child);\n    }\n\n    memcpy(root, &replacement, sizeof(cJSON));\n}",
          "fn_code_pos": [
            [
              783,
              0
            ],
            [
              804,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "overwrite_item",
            "parameters": {
              "root": "cJSON",
              "replacement": "cJSON"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int apply_patch(cJSON *object, const cJSON *patch, const cJSON_bool case_sensitive)\n{\n    cJSON *path = NULL;\n    cJSON *value = NULL;\n    cJSON *parent = NULL;\n    enum patch_operation opcode = INVALID;\n    unsigned char *parent_pointer = NULL;\n    unsigned char *child_pointer = NULL;\n    int status = 0;\n\n    path = get_object_item(patch, \"path\", case_sensitive);\n    if (!cJSON_IsString(path))\n    {\n        /* malformed patch. */\n        status = 2;\n        goto cleanup;\n    }\n\n    opcode = decode_patch_operation(patch, case_sensitive);\n    if (opcode == INVALID)\n    {\n        status = 3;\n        goto cleanup;\n    }\n    else if (opcode == TEST)\n    {\n        /* compare value: {...} with the given path */\n        status = !compare_json(get_item_from_pointer(object, path->valuestring, case_sensitive), get_object_item(patch, \"value\", case_sensitive), case_sensitive);\n        goto cleanup;\n    }\n\n    /* special case for replacing the root */\n    if (path->valuestring[0] == '\\0')\n    {\n        if (opcode == REMOVE)\n        {\n            static const cJSON invalid = { NULL, NULL, NULL, cJSON_Invalid, NULL, 0, 0, NULL};\n\n            overwrite_item(object, invalid);\n\n            status = 0;\n            goto cleanup;\n        }\n\n        if ((opcode == REPLACE) || (opcode == ADD))\n        {\n            value = get_object_item(patch, \"value\", case_sensitive);\n            if (value == NULL)\n            {\n                /* missing \"value\" for add/replace. */\n                status = 7;\n                goto cleanup;\n            }\n\n            value = cJSON_Duplicate(value, 1);\n            if (value == NULL)\n            {\n                /* out of memory for add/replace. */\n                status = 8;\n                goto cleanup;\n            }\n\n            overwrite_item(object, *value);\n\n            /* delete the duplicated value */\n            cJSON_free(value);\n            value = NULL;\n\n            /* the string \"value\" isn't needed */\n            if (object->string != NULL)\n            {\n                cJSON_free(object->string);\n                object->string = NULL;\n            }\n\n            status = 0;\n            goto cleanup;\n        }\n    }\n\n    if ((opcode == REMOVE) || (opcode == REPLACE))\n    {\n        /* Get rid of old. */\n        cJSON *old_item = detach_path(object, (unsigned char*)path->valuestring, case_sensitive);\n        if (old_item == NULL)\n        {\n            status = 13;\n            goto cleanup;\n        }\n        cJSON_Delete(old_item);\n        if (opcode == REMOVE)\n        {\n            /* For Remove, this job is done. */\n            status = 0;\n            goto cleanup;\n        }\n    }\n\n    /* Copy/Move uses \"from\". */\n    if ((opcode == MOVE) || (opcode == COPY))\n    {\n        cJSON *from = get_object_item(patch, \"from\", case_sensitive);\n        if (from == NULL)\n        {\n            /* missing \"from\" for copy/move. */\n            status = 4;\n            goto cleanup;\n        }\n\n        if (opcode == MOVE)\n        {\n            value = detach_path(object, (unsigned char*)from->valuestring, case_sensitive);\n        }\n        if (opcode == COPY)\n        {\n            value = get_item_from_pointer(object, from->valuestring, case_sensitive);\n        }\n        if (value == NULL)\n        {\n            /* missing \"from\" for copy/move. */\n            status = 5;\n            goto cleanup;\n        }\n        if (opcode == COPY)\n        {\n            value = cJSON_Duplicate(value, 1);\n        }\n        if (value == NULL)\n        {\n            /* out of memory for copy/move. */\n            status = 6;\n            goto cleanup;\n        }\n    }\n    else /* Add/Replace uses \"value\". */\n    {\n        value = get_object_item(patch, \"value\", case_sensitive);\n        if (value == NULL)\n        {\n            /* missing \"value\" for add/replace. */\n            status = 7;\n            goto cleanup;\n        }\n        value = cJSON_Duplicate(value, 1);\n        if (value == NULL)\n        {\n            /* out of memory for add/replace. */\n            status = 8;\n            goto cleanup;\n        }\n    }\n\n    /* Now, just add \"value\" to \"path\". */\n\n    /* split pointer in parent and child */\n    parent_pointer = cJSONUtils_strdup((unsigned char*)path->valuestring);\n    if (parent_pointer) {\n        child_pointer = (unsigned char*)strrchr((char*)parent_pointer, '/');\n    }\n    if (child_pointer != NULL)\n    {\n        child_pointer[0] = '\\0';\n        child_pointer++;\n    }\n    parent = get_item_from_pointer(object, (char*)parent_pointer, case_sensitive);\n    decode_pointer_inplace(child_pointer);\n\n    /* add, remove, replace, move, copy, test. */\n    if ((parent == NULL) || (child_pointer == NULL))\n    {\n        /* Couldn't find object to add to. */\n        status = 9;\n        goto cleanup;\n    }\n    else if (cJSON_IsArray(parent))\n    {\n        if (strcmp((char*)child_pointer, \"-\") == 0)\n        {\n            cJSON_AddItemToArray(parent, value);\n            value = NULL;\n        }\n        else\n        {\n            size_t index = 0;\n            if (!decode_array_index_from_pointer(child_pointer, &index))\n            {\n                status = 11;\n                goto cleanup;\n            }\n\n            if (!insert_item_in_array(parent, index, value))\n            {\n                status = 10;\n                goto cleanup;\n            }\n            value = NULL;\n        }\n    }\n    else if (cJSON_IsObject(parent))\n    {\n        if (case_sensitive)\n        {\n            cJSON_DeleteItemFromObjectCaseSensitive(parent, (char*)child_pointer);\n        }\n        else\n        {\n            cJSON_DeleteItemFromObject(parent, (char*)child_pointer);\n        }\n        cJSON_AddItemToObject(parent, (char*)child_pointer, value);\n        value = NULL;\n    }\n    else /* parent is not an object */\n    {\n        /* Couldn't find object to add to. */\n        status = 9;\n        goto cleanup;\n    }\n\ncleanup:\n    if (value != NULL)\n    {\n        cJSON_Delete(value);\n    }\n    if (parent_pointer != NULL)\n    {\n        cJSON_free(parent_pointer);\n    }\n\n    return status;\n}",
          "fn_code_pos": [
            [
              806,
              0
            ],
            [
              1035,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "apply_patch",
            "parameters": {
              "object": "cJSON",
              "patch": "cJSON",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "cJSONUtils_ApplyPatches(cJSON * const object, const cJSON * const patches)\n{\n    const cJSON *current_patch = NULL;\n    int status = 0;\n\n    if (!cJSON_IsArray(patches))\n    {\n        /* malformed patches. */\n        return 1;\n    }\n\n    if (patches != NULL)\n    {\n        current_patch = patches->child;\n    }\n\n    while (current_patch != NULL)\n    {\n        status = apply_patch(object, current_patch, false);\n        if (status != 0)\n        {\n            return status;\n        }\n        current_patch = current_patch->next;\n    }\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              1037,
              18
            ],
            [
              1064,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_ApplyPatches",
            "parameters": {
              "object": "cJSON",
              "patches": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_ApplyPatchesCaseSensitive(cJSON * const object, const cJSON * const patches)\n{\n    const cJSON *current_patch = NULL;\n    int status = 0;\n\n    if (!cJSON_IsArray(patches))\n    {\n        /* malformed patches. */\n        return 1;\n    }\n\n    if (patches != NULL)\n    {\n        current_patch = patches->child;\n    }\n\n    while (current_patch != NULL)\n    {\n        status = apply_patch(object, current_patch, true);\n        if (status != 0)\n        {\n            return status;\n        }\n        current_patch = current_patch->next;\n    }\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              1066,
              18
            ],
            [
              1093,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_ApplyPatchesCaseSensitive",
            "parameters": {
              "object": "cJSON",
              "patches": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void compose_patch(cJSON * const patches, const unsigned char * const operation, const unsigned char * const path, const unsigned char *suffix, const cJSON * const value)\n{\n    cJSON *patch = NULL;\n\n    if ((patches == NULL) || (operation == NULL) || (path == NULL))\n    {\n        return;\n    }\n\n    patch = cJSON_CreateObject();\n    if (patch == NULL)\n    {\n        return;\n    }\n    cJSON_AddItemToObject(patch, \"op\", cJSON_CreateString((const char*)operation));\n\n    if (suffix == NULL)\n    {\n        cJSON_AddItemToObject(patch, \"path\", cJSON_CreateString((const char*)path));\n    }\n    else\n    {\n        size_t suffix_length = pointer_encoded_length(suffix);\n        size_t path_length = strlen((const char*)path);\n        unsigned char *full_path = (unsigned char*)cJSON_malloc(path_length + suffix_length + sizeof(\"/\"));\n\n        sprintf((char*)full_path, \"%s/\", (const char*)path);\n        encode_string_as_pointer(full_path + path_length + 1, suffix);\n\n        cJSON_AddItemToObject(patch, \"path\", cJSON_CreateString((const char*)full_path));\n        cJSON_free(full_path);\n    }\n\n    if (value != NULL)\n    {\n        cJSON_AddItemToObject(patch, \"value\", cJSON_Duplicate(value, 1));\n    }\n    cJSON_AddItemToArray(patches, patch);\n}",
          "fn_code_pos": [
            [
              1095,
              0
            ],
            [
              1133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compose_patch",
            "parameters": {
              "patches": "cJSON",
              "operation": "unsigned char",
              "path": "unsigned char",
              "suffix": "unsigned char",
              "value": "cJSON"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cJSONUtils_AddPatchToArray(cJSON * const array, const char * const operation, const char * const path, const cJSON * const value)\n{\n    compose_patch(array, (const unsigned char*)operation, (const unsigned char*)path, NULL, value);\n}",
          "fn_code_pos": [
            [
              1135,
              19
            ],
            [
              1138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_AddPatchToArray",
            "parameters": {
              "array": "cJSON",
              "operation": "char",
              "path": "char",
              "value": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void create_patches(cJSON * const patches, const unsigned char * const path, cJSON * const from, cJSON * const to, const cJSON_bool case_sensitive)\n{\n    if ((from == NULL) || (to == NULL))\n    {\n        return;\n    }\n\n    if ((from->type & 0xFF) != (to->type & 0xFF))\n    {\n        compose_patch(patches, (const unsigned char*)\"replace\", path, 0, to);\n        return;\n    }\n\n    switch (from->type & 0xFF)\n    {\n        case cJSON_Number:\n            if ((from->valueint != to->valueint) || !compare_double(from->valuedouble, to->valuedouble))\n            {\n                compose_patch(patches, (const unsigned char*)\"replace\", path, NULL, to);\n            }\n            return;\n\n        case cJSON_String:\n            if (strcmp(from->valuestring, to->valuestring) != 0)\n            {\n                compose_patch(patches, (const unsigned char*)\"replace\", path, NULL, to);\n            }\n            return;\n\n        case cJSON_Array:\n        {\n            size_t index = 0;\n            cJSON *from_child = from->child;\n            cJSON *to_child = to->child;\n            unsigned char *new_path = (unsigned char*)cJSON_malloc(strlen((const char*)path) + 20 + sizeof(\"/\")); /* Allow space for 64bit int. log10(2^64) = 20 */\n\n            /* generate patches for all array elements that exist in both \"from\" and \"to\" */\n            for (index = 0; (from_child != NULL) && (to_child != NULL); (void)(from_child = from_child->next), (void)(to_child = to_child->next), index++)\n            {\n                /* check if conversion to unsigned long is valid\n                 * This should be eliminated at compile time by dead code elimination\n                 * if size_t is an alias of unsigned long, or if it is bigger */\n                if (index > ULONG_MAX)\n                {\n                    cJSON_free(new_path);\n                    return;\n                }\n                sprintf((char*)new_path, \"%s/%lu\", path, (unsigned long)index); /* path of the current array element */\n                create_patches(patches, new_path, from_child, to_child, case_sensitive);\n            }\n\n            /* remove leftover elements from 'from' that are not in 'to' */\n            for (; (from_child != NULL); (void)(from_child = from_child->next))\n            {\n                /* check if conversion to unsigned long is valid\n                 * This should be eliminated at compile time by dead code elimination\n                 * if size_t is an alias of unsigned long, or if it is bigger */\n                if (index > ULONG_MAX)\n                {\n                    cJSON_free(new_path);\n                    return;\n                }\n                sprintf((char*)new_path, \"%lu\", (unsigned long)index);\n                compose_patch(patches, (const unsigned char*)\"remove\", path, new_path, NULL);\n            }\n            /* add new elements in 'to' that were not in 'from' */\n            for (; (to_child != NULL); (void)(to_child = to_child->next), index++)\n            {\n                compose_patch(patches, (const unsigned char*)\"add\", path, (const unsigned char*)\"-\", to_child);\n            }\n            cJSON_free(new_path);\n            return;\n        }\n\n        case cJSON_Object:\n        {\n            cJSON *from_child = NULL;\n            cJSON *to_child = NULL;\n            sort_object(from, case_sensitive);\n            sort_object(to, case_sensitive);\n\n            from_child = from->child;\n            to_child = to->child;\n            /* for all object values in the object with more of them */\n            while ((from_child != NULL) || (to_child != NULL))\n            {\n                int diff;\n                if (from_child == NULL)\n                {\n                    diff = 1;\n                }\n                else if (to_child == NULL)\n                {\n                    diff = -1;\n                }\n                else\n                {\n                    diff = compare_strings((unsigned char*)from_child->string, (unsigned char*)to_child->string, case_sensitive);\n                }\n\n                if (diff == 0)\n                {\n                    /* both object keys are the same */\n                    size_t path_length = strlen((const char*)path);\n                    size_t from_child_name_length = pointer_encoded_length((unsigned char*)from_child->string);\n                    unsigned char *new_path = (unsigned char*)cJSON_malloc(path_length + from_child_name_length + sizeof(\"/\"));\n\n                    sprintf((char*)new_path, \"%s/\", path);\n                    encode_string_as_pointer(new_path + path_length + 1, (unsigned char*)from_child->string);\n\n                    /* create a patch for the element */\n                    create_patches(patches, new_path, from_child, to_child, case_sensitive);\n                    cJSON_free(new_path);\n\n                    from_child = from_child->next;\n                    to_child = to_child->next;\n                }\n                else if (diff < 0)\n                {\n                    /* object element doesn't exist in 'to' --> remove it */\n                    compose_patch(patches, (const unsigned char*)\"remove\", path, (unsigned char*)from_child->string, NULL);\n\n                    from_child = from_child->next;\n                }\n                else\n                {\n                    /* object element doesn't exist in 'from' --> add it */\n                    compose_patch(patches, (const unsigned char*)\"add\", path, (unsigned char*)to_child->string, to_child);\n\n                    to_child = to_child->next;\n                }\n            }\n            return;\n        }\n\n        default:\n            break;\n    }\n}",
          "fn_code_pos": [
            [
              1140,
              0
            ],
            [
              1278,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "create_patches",
            "parameters": {
              "patches": "cJSON",
              "path": "unsigned char",
              "from": "cJSON",
              "to": "cJSON",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cJSONUtils_GeneratePatches(cJSON * const from, cJSON * const to)\n{\n    cJSON *patches = NULL;\n\n    if ((from == NULL) || (to == NULL))\n    {\n        return NULL;\n    }\n\n    patches = cJSON_CreateArray();\n    create_patches(patches, (const unsigned char*)\"\", from, to, false);\n\n    return patches;\n}",
          "fn_code_pos": [
            [
              1280,
              22
            ],
            [
              1293,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_GeneratePatches",
            "parameters": {
              "from": "cJSON",
              "to": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_GeneratePatchesCaseSensitive(cJSON * const from, cJSON * const to)\n{\n    cJSON *patches = NULL;\n\n    if ((from == NULL) || (to == NULL))\n    {\n        return NULL;\n    }\n\n    patches = cJSON_CreateArray();\n    create_patches(patches, (const unsigned char*)\"\", from, to, true);\n\n    return patches;\n}",
          "fn_code_pos": [
            [
              1295,
              22
            ],
            [
              1308,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_GeneratePatchesCaseSensitive",
            "parameters": {
              "from": "cJSON",
              "to": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_SortObject(cJSON * const object)\n{\n    sort_object(object, false);\n}",
          "fn_code_pos": [
            [
              1310,
              19
            ],
            [
              1313,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_SortObject",
            "parameters": {
              "object": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_SortObjectCaseSensitive(cJSON * const object)\n{\n    sort_object(object, true);\n}",
          "fn_code_pos": [
            [
              1315,
              19
            ],
            [
              1318,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_SortObjectCaseSensitive",
            "parameters": {
              "object": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static cJSON *merge_patch(cJSON *target, const cJSON * const patch, const cJSON_bool case_sensitive)\n{\n    cJSON *patch_child = NULL;\n\n    if (!cJSON_IsObject(patch))\n    {\n        /* scalar value, array or NULL, just duplicate */\n        cJSON_Delete(target);\n        return cJSON_Duplicate(patch, 1);\n    }\n\n    if (!cJSON_IsObject(target))\n    {\n        cJSON_Delete(target);\n        target = cJSON_CreateObject();\n    }\n\n    patch_child = patch->child;\n    while (patch_child != NULL)\n    {\n        if (cJSON_IsNull(patch_child))\n        {\n            /* NULL is the indicator to remove a value, see RFC7396 */\n            if (case_sensitive)\n            {\n                cJSON_DeleteItemFromObjectCaseSensitive(target, patch_child->string);\n            }\n            else\n            {\n                cJSON_DeleteItemFromObject(target, patch_child->string);\n            }\n        }\n        else\n        {\n            cJSON *replace_me = NULL;\n            cJSON *replacement = NULL;\n\n            if (case_sensitive)\n            {\n                replace_me = cJSON_DetachItemFromObjectCaseSensitive(target, patch_child->string);\n            }\n            else\n            {\n                replace_me = cJSON_DetachItemFromObject(target, patch_child->string);\n            }\n\n            replacement = merge_patch(replace_me, patch_child, case_sensitive);\n            if (replacement == NULL)\n            {\n                cJSON_Delete(target);\n                return NULL;\n            }\n\n            cJSON_AddItemToObject(target, patch_child->string, replacement);\n        }\n        patch_child = patch_child->next;\n    }\n    return target;\n}",
          "fn_code_pos": [
            [
              1320,
              0
            ],
            [
              1378,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "merge_patch",
            "parameters": {
              "target": "cJSON",
              "patch": "cJSON",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": "cJSON"
          }
        },
        {
          "fn_code": "cJSONUtils_MergePatch(cJSON *target, const cJSON * const patch)\n{\n    return merge_patch(target, patch, false);\n}",
          "fn_code_pos": [
            [
              1380,
              22
            ],
            [
              1383,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_MergePatch",
            "parameters": {
              "target": "cJSON",
              "patch": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_MergePatchCaseSensitive(cJSON *target, const cJSON * const patch)\n{\n    return merge_patch(target, patch, true);\n}",
          "fn_code_pos": [
            [
              1385,
              22
            ],
            [
              1388,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_MergePatchCaseSensitive",
            "parameters": {
              "target": "cJSON",
              "patch": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static cJSON *generate_merge_patch(cJSON * const from, cJSON * const to, const cJSON_bool case_sensitive)\n{\n    cJSON *from_child = NULL;\n    cJSON *to_child = NULL;\n    cJSON *patch = NULL;\n    if (to == NULL)\n    {\n        /* patch to delete everything */\n        return cJSON_CreateNull();\n    }\n    if (!cJSON_IsObject(to) || !cJSON_IsObject(from))\n    {\n        return cJSON_Duplicate(to, 1);\n    }\n\n    sort_object(from, case_sensitive);\n    sort_object(to, case_sensitive);\n\n    from_child = from->child;\n    to_child = to->child;\n    patch = cJSON_CreateObject();\n    if (patch == NULL)\n    {\n        return NULL;\n    }\n    while (from_child || to_child)\n    {\n        int diff;\n        if (from_child != NULL)\n        {\n            if (to_child != NULL)\n            {\n                diff = strcmp(from_child->string, to_child->string);\n            }\n            else\n            {\n                diff = -1;\n            }\n        }\n        else\n        {\n            diff = 1;\n        }\n\n        if (diff < 0)\n        {\n            /* from has a value that to doesn't have -> remove */\n            cJSON_AddItemToObject(patch, from_child->string, cJSON_CreateNull());\n\n            from_child = from_child->next;\n        }\n        else if (diff > 0)\n        {\n            /* to has a value that from doesn't have -> add to patch */\n            cJSON_AddItemToObject(patch, to_child->string, cJSON_Duplicate(to_child, 1));\n\n            to_child = to_child->next;\n        }\n        else\n        {\n            /* object key exists in both objects */\n            if (!compare_json(from_child, to_child, case_sensitive))\n            {\n                /* not identical --> generate a patch */\n                cJSON_AddItemToObject(patch, to_child->string, cJSONUtils_GenerateMergePatch(from_child, to_child));\n            }\n\n            /* next key in the object */\n            from_child = from_child->next;\n            to_child = to_child->next;\n        }\n    }\n    if (patch->child == NULL)\n    {\n        /* no patch generated */\n        cJSON_Delete(patch);\n        return NULL;\n    }\n\n    return patch;\n}",
          "fn_code_pos": [
            [
              1390,
              0
            ],
            [
              1470,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "generate_merge_patch",
            "parameters": {
              "from": "cJSON",
              "to": "cJSON",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": "cJSON"
          }
        },
        {
          "fn_code": "cJSONUtils_GenerateMergePatch(cJSON * const from, cJSON * const to)\n{\n    return generate_merge_patch(from, to, false);\n}",
          "fn_code_pos": [
            [
              1472,
              22
            ],
            [
              1475,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_GenerateMergePatch",
            "parameters": {
              "from": "cJSON",
              "to": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_GenerateMergePatchCaseSensitive(cJSON * const from, cJSON * const to)\n{\n    return generate_merge_patch(from, to, true);\n}",
          "fn_code_pos": [
            [
              1477,
              22
            ],
            [
              1480,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_GenerateMergePatchCaseSensitive",
            "parameters": {
              "from": "cJSON",
              "to": "cJSON"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "cJSONUtils_strdup(const unsigned char* const string)",
          "fn_dec_pos": [
            [
              65,
              22
            ],
            [
              65,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_strdup",
            "parameters": {
              "string": "unsigned char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(char *)",
          "fn_dec_pos": [
            [
              197,
              0
            ],
            [
              197,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "get_array_item(const cJSON *array, size_t item)",
          "fn_dec_pos": [
            [
              261,
              14
            ],
            [
              261,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_array_item",
            "parameters": {
              "array": "cJSON",
              "item": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "get_item_from_pointer(cJSON * const object, const char * pointer, const cJSON_bool case_sensitive)",
          "fn_dec_pos": [
            [
              300,
              14
            ],
            [
              300,
              112
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_item_from_pointer",
            "parameters": {
              "object": "cJSON",
              "pointer": "char",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              347,
              0
            ],
            [
              347,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              352,
              0
            ],
            [
              352,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "detach_item_from_array(cJSON *array, size_t which)",
          "fn_dec_pos": [
            [
              392,
              14
            ],
            [
              392,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "detach_item_from_array",
            "parameters": {
              "array": "cJSON",
              "which": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "detach_path(cJSON *object, const unsigned char *path, const cJSON_bool case_sensitive)",
          "fn_dec_pos": [
            [
              429,
              14
            ],
            [
              429,
              100
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "detach_path",
            "parameters": {
              "object": "cJSON",
              "path": "unsigned char",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "sort_list(cJSON *list, const cJSON_bool case_sensitive)",
          "fn_dec_pos": [
            [
              483,
              14
            ],
            [
              483,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sort_list",
            "parameters": {
              "list": "cJSON",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "get_object_item(const cJSON * const object, const char* name, const cJSON_bool case_sensitive)",
          "fn_dec_pos": [
            [
              729,
              14
            ],
            [
              729,
              108
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_object_item",
            "parameters": {
              "object": "cJSON",
              "name": "char",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(int)",
          "fn_dec_pos": [
            [
              1037,
              0
            ],
            [
              1037,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(int)",
          "fn_dec_pos": [
            [
              1066,
              0
            ],
            [
              1066,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              1135,
              0
            ],
            [
              1135,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              1280,
              0
            ],
            [
              1280,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              1295,
              0
            ],
            [
              1295,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              1310,
              0
            ],
            [
              1310,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              1315,
              0
            ],
            [
              1315,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "merge_patch(cJSON *target, const cJSON * const patch, const cJSON_bool case_sensitive)",
          "fn_dec_pos": [
            [
              1320,
              14
            ],
            [
              1320,
              100
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "merge_patch",
            "parameters": {
              "target": "cJSON",
              "patch": "cJSON",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              1380,
              0
            ],
            [
              1380,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              1385,
              0
            ],
            [
              1385,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "generate_merge_patch(cJSON * const from, cJSON * const to, const cJSON_bool case_sensitive)",
          "fn_dec_pos": [
            [
              1390,
              14
            ],
            [
              1390,
              105
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "generate_merge_patch",
            "parameters": {
              "from": "cJSON",
              "to": "cJSON",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              1472,
              0
            ],
            [
              1472,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              1477,
              0
            ],
            [
              1477,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <ctype.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <float.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include \"cJSON_Utils.h\"\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "enum patch_operation { INVALID, ADD, REMOVE, REPLACE, MOVE, COPY, TEST }",
          {
            "INVALID": "",
            "ADD": "",
            "REMOVE": "",
            "REPLACE": "",
            "MOVE": "",
            "COPY": "",
            "TEST": ""
          },
          "patch_operation",
          [
            739,
            0
          ],
          [
            739,
            72
          ]
        ],
        [
          "enum patch_operation",
          {},
          "",
          [
            741,
            7
          ],
          [
            741,
            27
          ]
        ],
        [
          "enum patch_operation",
          {},
          "",
          [
            811,
            4
          ],
          [
            811,
            24
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/cJSON.c": {
      "fn_def_list": [
        {
          "fn_code": "cJSON_GetErrorPtr(void)\n{\n    return (const char*) (global_error.json + global_error.position);\n}",
          "fn_code_pos": [
            [
              93,
              27
            ],
            [
              96,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_GetErrorPtr",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_GetStringValue(const cJSON * const item)\n{\n    if (!cJSON_IsString(item))\n    {\n        return NULL;\n    }\n\n    return item->valuestring;\n}",
          "fn_code_pos": [
            [
              98,
              21
            ],
            [
              106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_GetStringValue",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_GetNumberValue(const cJSON * const item)\n{\n    if (!cJSON_IsNumber(item))\n    {\n        return (double) NAN;\n    }\n\n    return item->valuedouble;\n}",
          "fn_code_pos": [
            [
              108,
              21
            ],
            [
              116,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_GetNumberValue",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_Version(void)\n{\n    static char version[15];\n    sprintf(version, \"%i.%i.%i\", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);\n\n    return version;\n}",
          "fn_code_pos": [
            [
              123,
              26
            ],
            [
              129,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_Version",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)\n{\n    if ((string1 == NULL) || (string2 == NULL))\n    {\n        return 1;\n    }\n\n    if (string1 == string2)\n    {\n        return 0;\n    }\n\n    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)\n    {\n        if (*string1 == '\\0')\n        {\n            return 0;\n        }\n    }\n\n    return tolower(*string1) - tolower(*string2);\n}",
          "fn_code_pos": [
            [
              132,
              0
            ],
            [
              153,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "case_insensitive_strcmp",
            "parameters": {
              "string1": "unsigned char",
              "string2": "unsigned char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void * CJSON_CDECL internal_malloc(size_t size)\n{\n    return malloc(size);\n}",
          "fn_code_pos": [
            [
              164,
              0
            ],
            [
              167,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL internal_malloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void CJSON_CDECL internal_free(void *pointer)\n{\n    free(pointer);\n}",
          "fn_code_pos": [
            [
              168,
              0
            ],
            [
              171,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL internal_free",
            "parameters": {
              "pointer": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void * CJSON_CDECL internal_realloc(void *pointer, size_t size)\n{\n    return realloc(pointer, size);\n}",
          "fn_code_pos": [
            [
              172,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL internal_realloc",
            "parameters": {
              "pointer": "void",
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)\n{\n    size_t length = 0;\n    unsigned char *copy = NULL;\n\n    if (string == NULL)\n    {\n        return NULL;\n    }\n\n    length = strlen((const char*)string) + sizeof(\"\");\n    copy = (unsigned char*)hooks->allocate(length);\n    if (copy == NULL)\n    {\n        return NULL;\n    }\n    memcpy(copy, string, length);\n\n    return copy;\n}",
          "fn_code_pos": [
            [
              187,
              0
            ],
            [
              206,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_strdup",
            "parameters": {
              "string": "unsigned char",
              "hooks": "internal_hooks"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_InitHooks(cJSON_Hooks* hooks)\n{\n    if (hooks == NULL)\n    {\n        /* Reset hooks */\n        global_hooks.allocate = malloc;\n        global_hooks.deallocate = free;\n        global_hooks.reallocate = realloc;\n        return;\n    }\n\n    global_hooks.allocate = malloc;\n    if (hooks->malloc_fn != NULL)\n    {\n        global_hooks.allocate = hooks->malloc_fn;\n    }\n\n    global_hooks.deallocate = free;\n    if (hooks->free_fn != NULL)\n    {\n        global_hooks.deallocate = hooks->free_fn;\n    }\n\n    /* use realloc only if both free and malloc are used */\n    global_hooks.reallocate = NULL;\n    if ((global_hooks.allocate == malloc) && (global_hooks.deallocate == free))\n    {\n        global_hooks.reallocate = realloc;\n    }\n}",
          "fn_code_pos": [
            [
              208,
              19
            ],
            [
              237,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_InitHooks",
            "parameters": {
              "hooks": "cJSON_Hooks"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static cJSON *cJSON_New_Item(const internal_hooks * const hooks)\n{\n    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));\n    if (node)\n    {\n        memset(node, '\\0', sizeof(cJSON));\n    }\n\n    return node;\n}",
          "fn_code_pos": [
            [
              240,
              0
            ],
            [
              249,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_New_Item",
            "parameters": {
              "hooks": "internal_hooks"
            },
            "return_type": "cJSON"
          }
        },
        {
          "fn_code": "cJSON_Delete(cJSON *item)\n{\n    cJSON *next = NULL;\n    while (item != NULL)\n    {\n        next = item->next;\n        if (!(item->type & cJSON_IsReference) && (item->child != NULL))\n        {\n            cJSON_Delete(item->child);\n        }\n        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))\n        {\n            global_hooks.deallocate(item->valuestring);\n            item->valuestring = NULL;\n        }\n        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))\n        {\n            global_hooks.deallocate(item->string);\n            item->string = NULL;\n        }\n        global_hooks.deallocate(item);\n        item = next;\n    }\n}",
          "fn_code_pos": [
            [
              252,
              19
            ],
            [
              275,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_Delete",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static unsigned char get_decimal_point(void)\n{\n#ifdef ENABLE_LOCALES\n    struct lconv *lconv = localeconv();\n    return (unsigned char) lconv->decimal_point[0];\n#else\n    return '.';\n#endif\n}",
          "fn_code_pos": [
            [
              278,
              0
            ],
            [
              286,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_decimal_point",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)\n{\n    double number = 0;\n    unsigned char *after_end = NULL;\n    unsigned char number_c_string[64];\n    unsigned char decimal_point = get_decimal_point();\n    size_t i = 0;\n\n    if ((input_buffer == NULL) || (input_buffer->content == NULL))\n    {\n        return false;\n    }\n\n    /* copy the number into a temporary buffer and replace '.' with the decimal point\n     * of the current locale (for strtod)\n     * This also takes care of '\\0' not necessarily being available for marking the end of the input */\n    for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)\n    {\n        switch (buffer_at_offset(input_buffer)[i])\n        {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case '+':\n            case '-':\n            case 'e':\n            case 'E':\n                number_c_string[i] = buffer_at_offset(input_buffer)[i];\n                break;\n\n            case '.':\n                number_c_string[i] = decimal_point;\n                break;\n\n            default:\n                goto loop_end;\n        }\n    }\nloop_end:\n    number_c_string[i] = '\\0';\n\n    number = strtod((const char*)number_c_string, (char**)&after_end);\n    if (number_c_string == after_end)\n    {\n        return false; /* parse_error */\n    }\n\n    item->valuedouble = number;\n\n    /* use saturation in case of overflow */\n    if (number >= INT_MAX)\n    {\n        item->valueint = INT_MAX;\n    }\n    else if (number <= (double)INT_MIN)\n    {\n        item->valueint = INT_MIN;\n    }\n    else\n    {\n        item->valueint = (int)number;\n    }\n\n    item->type = cJSON_Number;\n\n    input_buffer->offset += (size_t)(after_end - number_c_string);\n    return true;\n}",
          "fn_code_pos": [
            [
              306,
              0
            ],
            [
              380,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_number",
            "parameters": {
              "item": "cJSON",
              "input_buffer": "parse_buffer"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "cJSON_SetNumberHelper(cJSON *object, double number)\n{\n    if (number >= INT_MAX)\n    {\n        object->valueint = INT_MAX;\n    }\n    else if (number <= (double)INT_MIN)\n    {\n        object->valueint = INT_MIN;\n    }\n    else\n    {\n        object->valueint = (int)number;\n    }\n\n    return object->valuedouble = number;\n}",
          "fn_code_pos": [
            [
              383,
              21
            ],
            [
              399,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_SetNumberHelper",
            "parameters": {
              "object": "cJSON",
              "number": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_SetValuestring(cJSON *object, const char *valuestring)\n{\n    char *copy = NULL;\n    size_t v1_len;\n    size_t v2_len;\n    /* if object's type is not cJSON_String or is cJSON_IsReference, it should not set valuestring */\n    if ((object == NULL) || !(object->type & cJSON_String) || (object->type & cJSON_IsReference))\n    {\n        return NULL;\n    }\n    /* return NULL if the object is corrupted or valuestring is NULL */\n    if (object->valuestring == NULL || valuestring == NULL)\n    {\n        return NULL;\n    }\n\n    v1_len = strlen(valuestring);\n    v2_len = strlen(object->valuestring);\n\n    if (v1_len <= v2_len)\n    {\n        /* strcpy does not handle overlapping string: [X1, X2] [Y1, Y2] => X2 < Y1 or Y2 < X1 */\n        if (!( valuestring + v1_len < object->valuestring || object->valuestring + v2_len < valuestring ))\n        {\n            return NULL;\n        }\n        strcpy(object->valuestring, valuestring);\n        return object->valuestring;\n    }\n    copy = (char*) cJSON_strdup((const unsigned char*)valuestring, &global_hooks);\n    if (copy == NULL)\n    {\n        return NULL;\n    }\n    if (object->valuestring != NULL)\n    {\n        cJSON_free(object->valuestring);\n    }\n    object->valuestring = copy;\n\n    return copy;\n}",
          "fn_code_pos": [
            [
              402,
              20
            ],
            [
              443,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_SetValuestring",
            "parameters": {
              "object": "cJSON",
              "valuestring": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static unsigned char* ensure(printbuffer * const p, size_t needed)\n{\n    unsigned char *newbuffer = NULL;\n    size_t newsize = 0;\n\n    if ((p == NULL) || (p->buffer == NULL))\n    {\n        return NULL;\n    }\n\n    if ((p->length > 0) && (p->offset >= p->length))\n    {\n        /* make sure that offset is valid */\n        return NULL;\n    }\n\n    if (needed > INT_MAX)\n    {\n        /* sizes bigger than INT_MAX are currently not supported */\n        return NULL;\n    }\n\n    needed += p->offset + 1;\n    if (needed <= p->length)\n    {\n        return p->buffer + p->offset;\n    }\n\n    if (p->noalloc) {\n        return NULL;\n    }\n\n    /* calculate new buffer size */\n    if (needed > (INT_MAX / 2))\n    {\n        /* overflow of int, use INT_MAX if possible */\n        if (needed <= INT_MAX)\n        {\n            newsize = INT_MAX;\n        }\n        else\n        {\n            return NULL;\n        }\n    }\n    else\n    {\n        newsize = needed * 2;\n    }\n\n    if (p->hooks.reallocate != NULL)\n    {\n        /* reallocate with realloc if available */\n        newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);\n        if (newbuffer == NULL)\n        {\n            p->hooks.deallocate(p->buffer);\n            p->length = 0;\n            p->buffer = NULL;\n\n            return NULL;\n        }\n    }\n    else\n    {\n        /* otherwise reallocate manually */\n        newbuffer = (unsigned char*)p->hooks.allocate(newsize);\n        if (!newbuffer)\n        {\n            p->hooks.deallocate(p->buffer);\n            p->length = 0;\n            p->buffer = NULL;\n\n            return NULL;\n        }\n\n        memcpy(newbuffer, p->buffer, p->offset + 1);\n        p->hooks.deallocate(p->buffer);\n    }\n    p->length = newsize;\n    p->buffer = newbuffer;\n\n    return newbuffer + p->offset;\n}",
          "fn_code_pos": [
            [
              457,
              0
            ],
            [
              540,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ensure",
            "parameters": {
              "p": "printbuffer",
              "needed": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void update_offset(printbuffer * const buffer)\n{\n    const unsigned char *buffer_pointer = NULL;\n    if ((buffer == NULL) || (buffer->buffer == NULL))\n    {\n        return;\n    }\n    buffer_pointer = buffer->buffer + buffer->offset;\n\n    buffer->offset += strlen((const char*)buffer_pointer);\n}",
          "fn_code_pos": [
            [
              543,
              0
            ],
            [
              553,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "update_offset",
            "parameters": {
              "buffer": "printbuffer"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static cJSON_bool compare_double(double a, double b)\n{\n    double maxVal = fabs(a) > fabs(b) ? fabs(a) : fabs(b);\n    return (fabs(a - b) <= maxVal * DBL_EPSILON);\n}",
          "fn_code_pos": [
            [
              556,
              0
            ],
            [
              560,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compare_double",
            "parameters": {
              "a": "double",
              "b": "double"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output_pointer = NULL;\n    double d = item->valuedouble;\n    int length = 0;\n    size_t i = 0;\n    unsigned char number_buffer[26] = {0}; /* temporary buffer to print the number into */\n    unsigned char decimal_point = get_decimal_point();\n    double test = 0.0;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* This checks for NaN and Infinity */\n    if (isnan(d) || isinf(d))\n    {\n        length = sprintf((char*)number_buffer, \"null\");\n    }\n    else if(d == (double)item->valueint)\n    {\n        length = sprintf((char*)number_buffer, \"%d\", item->valueint);\n    }\n    else\n    {\n        /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */\n        length = sprintf((char*)number_buffer, \"%1.15g\", d);\n\n        /* Check whether the original double can be recovered */\n        if ((sscanf((char*)number_buffer, \"%lg\", &test) != 1) || !compare_double((double)test, d))\n        {\n            /* If not, print with 17 decimal places of precision */\n            length = sprintf((char*)number_buffer, \"%1.17g\", d);\n        }\n    }\n\n    /* sprintf failed or buffer overrun occurred */\n    if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1)))\n    {\n        return false;\n    }\n\n    /* reserve appropriate space in the output */\n    output_pointer = ensure(output_buffer, (size_t)length + sizeof(\"\"));\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n\n    /* copy the printed number to the output and replace locale\n     * dependent decimal point with '.' */\n    for (i = 0; i < ((size_t)length); i++)\n    {\n        if (number_buffer[i] == decimal_point)\n        {\n            output_pointer[i] = '.';\n            continue;\n        }\n\n        output_pointer[i] = number_buffer[i];\n    }\n    output_pointer[i] = '\\0';\n\n    output_buffer->offset += (size_t)length;\n\n    return true;\n}",
          "fn_code_pos": [
            [
              563,
              0
            ],
            [
              630,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_number",
            "parameters": {
              "item": "cJSON",
              "output_buffer": "printbuffer"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "static unsigned parse_hex4(const unsigned char * const input)\n{\n    unsigned int h = 0;\n    size_t i = 0;\n\n    for (i = 0; i < 4; i++)\n    {\n        /* parse digit */\n        if ((input[i] >= '0') && (input[i] <= '9'))\n        {\n            h += (unsigned int) input[i] - '0';\n        }\n        else if ((input[i] >= 'A') && (input[i] <= 'F'))\n        {\n            h += (unsigned int) 10 + input[i] - 'A';\n        }\n        else if ((input[i] >= 'a') && (input[i] <= 'f'))\n        {\n            h += (unsigned int) 10 + input[i] - 'a';\n        }\n        else /* invalid */\n        {\n            return 0;\n        }\n\n        if (i < 3)\n        {\n            /* shift left to make place for the next nibble */\n            h = h << 4;\n        }\n    }\n\n    return h;\n}",
          "fn_code_pos": [
            [
              633,
              0
            ],
            [
              666,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_hex4",
            "parameters": {
              "input": "unsigned char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)\n{\n    long unsigned int codepoint = 0;\n    unsigned int first_code = 0;\n    const unsigned char *first_sequence = input_pointer;\n    unsigned char utf8_length = 0;\n    unsigned char utf8_position = 0;\n    unsigned char sequence_length = 0;\n    unsigned char first_byte_mark = 0;\n\n    if ((input_end - first_sequence) < 6)\n    {\n        /* input ends unexpectedly */\n        goto fail;\n    }\n\n    /* get the first utf16 sequence */\n    first_code = parse_hex4(first_sequence + 2);\n\n    /* check that the code is valid */\n    if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))\n    {\n        goto fail;\n    }\n\n    /* UTF16 surrogate pair */\n    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))\n    {\n        const unsigned char *second_sequence = first_sequence + 6;\n        unsigned int second_code = 0;\n        sequence_length = 12; /* \\uXXXX\\uXXXX */\n\n        if ((input_end - second_sequence) < 6)\n        {\n            /* input ends unexpectedly */\n            goto fail;\n        }\n\n        if ((second_sequence[0] != '\\\\') || (second_sequence[1] != 'u'))\n        {\n            /* missing second half of the surrogate pair */\n            goto fail;\n        }\n\n        /* get the second utf16 sequence */\n        second_code = parse_hex4(second_sequence + 2);\n        /* check that the code is valid */\n        if ((second_code < 0xDC00) || (second_code > 0xDFFF))\n        {\n            /* invalid second half of the surrogate pair */\n            goto fail;\n        }\n\n\n        /* calculate the unicode codepoint from the surrogate pair */\n        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));\n    }\n    else\n    {\n        sequence_length = 6; /* \\uXXXX */\n        codepoint = first_code;\n    }\n\n    /* encode as UTF-8\n     * takes at maximum 4 bytes to encode:\n     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */\n    if (codepoint < 0x80)\n    {\n        /* normal ascii, encoding 0xxxxxxx */\n        utf8_length = 1;\n    }\n    else if (codepoint < 0x800)\n    {\n        /* two bytes, encoding 110xxxxx 10xxxxxx */\n        utf8_length = 2;\n        first_byte_mark = 0xC0; /* 11000000 */\n    }\n    else if (codepoint < 0x10000)\n    {\n        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */\n        utf8_length = 3;\n        first_byte_mark = 0xE0; /* 11100000 */\n    }\n    else if (codepoint <= 0x10FFFF)\n    {\n        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */\n        utf8_length = 4;\n        first_byte_mark = 0xF0; /* 11110000 */\n    }\n    else\n    {\n        /* invalid unicode codepoint */\n        goto fail;\n    }\n\n    /* encode as utf8 */\n    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)\n    {\n        /* 10xxxxxx */\n        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);\n        codepoint >>= 6;\n    }\n    /* encode first byte */\n    if (utf8_length > 1)\n    {\n        (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);\n    }\n    else\n    {\n        (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);\n    }\n\n    *output_pointer += utf8_length;\n\n    return sequence_length;\n\nfail:\n    return 0;\n}",
          "fn_code_pos": [
            [
              670,
              0
            ],
            [
              788,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "utf16_literal_to_utf8",
            "parameters": {
              "input_pointer": "unsigned char",
              "input_end": "unsigned char",
              "output_pointer": "unsigned char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)\n{\n    const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;\n    const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;\n    unsigned char *output_pointer = NULL;\n    unsigned char *output = NULL;\n\n    /* not a string */\n    if (buffer_at_offset(input_buffer)[0] != '\\\"')\n    {\n        goto fail;\n    }\n\n    {\n        /* calculate approximate size of the output (overestimate) */\n        size_t allocation_length = 0;\n        size_t skipped_bytes = 0;\n        while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\\\"'))\n        {\n            /* is escape sequence */\n            if (input_end[0] == '\\\\')\n            {\n                if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)\n                {\n                    /* prevent buffer overflow when last input character is a backslash */\n                    goto fail;\n                }\n                skipped_bytes++;\n                input_end++;\n            }\n            input_end++;\n        }\n        if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\\\"'))\n        {\n            goto fail; /* string ended unexpectedly */\n        }\n\n        /* This is at most how much we need for the output */\n        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;\n        output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(\"\"));\n        if (output == NULL)\n        {\n            goto fail; /* allocation failure */\n        }\n    }\n\n    output_pointer = output;\n    /* loop through the string literal */\n    while (input_pointer < input_end)\n    {\n        if (*input_pointer != '\\\\')\n        {\n            *output_pointer++ = *input_pointer++;\n        }\n        /* escape sequence */\n        else\n        {\n            unsigned char sequence_length = 2;\n            if ((input_end - input_pointer) < 1)\n            {\n                goto fail;\n            }\n\n            switch (input_pointer[1])\n            {\n                case 'b':\n                    *output_pointer++ = '\\b';\n                    break;\n                case 'f':\n                    *output_pointer++ = '\\f';\n                    break;\n                case 'n':\n                    *output_pointer++ = '\\n';\n                    break;\n                case 'r':\n                    *output_pointer++ = '\\r';\n                    break;\n                case 't':\n                    *output_pointer++ = '\\t';\n                    break;\n                case '\\\"':\n                case '\\\\':\n                case '/':\n                    *output_pointer++ = input_pointer[1];\n                    break;\n\n                /* UTF-16 literal */\n                case 'u':\n                    sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);\n                    if (sequence_length == 0)\n                    {\n                        /* failed to convert UTF16-literal to UTF-8 */\n                        goto fail;\n                    }\n                    break;\n\n                default:\n                    goto fail;\n            }\n            input_pointer += sequence_length;\n        }\n    }\n\n    /* zero terminate the output */\n    *output_pointer = '\\0';\n\n    item->type = cJSON_String;\n    item->valuestring = (char*)output;\n\n    input_buffer->offset = (size_t) (input_end - input_buffer->content);\n    input_buffer->offset++;\n\n    return true;\n\nfail:\n    if (output != NULL)\n    {\n        input_buffer->hooks.deallocate(output);\n        output = NULL;\n    }\n\n    if (input_pointer != NULL)\n    {\n        input_buffer->offset = (size_t)(input_pointer - input_buffer->content);\n    }\n\n    return false;\n}",
          "fn_code_pos": [
            [
              791,
              0
            ],
            [
              918,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_string",
            "parameters": {
              "item": "cJSON",
              "input_buffer": "parse_buffer"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)\n{\n    const unsigned char *input_pointer = NULL;\n    unsigned char *output = NULL;\n    unsigned char *output_pointer = NULL;\n    size_t output_length = 0;\n    /* numbers of additional characters needed for escaping */\n    size_t escape_characters = 0;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* empty string */\n    if (input == NULL)\n    {\n        output = ensure(output_buffer, sizeof(\"\\\"\\\"\"));\n        if (output == NULL)\n        {\n            return false;\n        }\n        strcpy((char*)output, \"\\\"\\\"\");\n\n        return true;\n    }\n\n    /* set \"flag\" to 1 if something needs to be escaped */\n    for (input_pointer = input; *input_pointer; input_pointer++)\n    {\n        switch (*input_pointer)\n        {\n            case '\\\"':\n            case '\\\\':\n            case '\\b':\n            case '\\f':\n            case '\\n':\n            case '\\r':\n            case '\\t':\n                /* one character escape sequence */\n                escape_characters++;\n                break;\n            default:\n                if (*input_pointer < 32)\n                {\n                    /* UTF-16 escape sequence uXXXX */\n                    escape_characters += 5;\n                }\n                break;\n        }\n    }\n    output_length = (size_t)(input_pointer - input) + escape_characters;\n\n    output = ensure(output_buffer, output_length + sizeof(\"\\\"\\\"\"));\n    if (output == NULL)\n    {\n        return false;\n    }\n\n    /* no characters have to be escaped */\n    if (escape_characters == 0)\n    {\n        output[0] = '\\\"';\n        memcpy(output + 1, input, output_length);\n        output[output_length + 1] = '\\\"';\n        output[output_length + 2] = '\\0';\n\n        return true;\n    }\n\n    output[0] = '\\\"';\n    output_pointer = output + 1;\n    /* copy the string */\n    for (input_pointer = input; *input_pointer != '\\0'; (void)input_pointer++, output_pointer++)\n    {\n        if ((*input_pointer > 31) && (*input_pointer != '\\\"') && (*input_pointer != '\\\\'))\n        {\n            /* normal character, copy */\n            *output_pointer = *input_pointer;\n        }\n        else\n        {\n            /* character needs to be escaped */\n            *output_pointer++ = '\\\\';\n            switch (*input_pointer)\n            {\n                case '\\\\':\n                    *output_pointer = '\\\\';\n                    break;\n                case '\\\"':\n                    *output_pointer = '\\\"';\n                    break;\n                case '\\b':\n                    *output_pointer = 'b';\n                    break;\n                case '\\f':\n                    *output_pointer = 'f';\n                    break;\n                case '\\n':\n                    *output_pointer = 'n';\n                    break;\n                case '\\r':\n                    *output_pointer = 'r';\n                    break;\n                case '\\t':\n                    *output_pointer = 't';\n                    break;\n                default:\n                    /* escape and print as unicode codepoint */\n                    sprintf((char*)output_pointer, \"u%04x\", *input_pointer);\n                    output_pointer += 4;\n                    break;\n            }\n        }\n    }\n    output[output_length + 1] = '\\\"';\n    output[output_length + 2] = '\\0';\n\n    return true;\n}",
          "fn_code_pos": [
            [
              921,
              0
            ],
            [
              1040,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_string_ptr",
            "parameters": {
              "input": "unsigned char",
              "output_buffer": "printbuffer"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "static cJSON_bool print_string(const cJSON * const item, printbuffer * const p)\n{\n    return print_string_ptr((unsigned char*)item->valuestring, p);\n}",
          "fn_code_pos": [
            [
              1043,
              0
            ],
            [
              1046,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_string",
            "parameters": {
              "item": "cJSON",
              "p": "printbuffer"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)\n{\n    if ((buffer == NULL) || (buffer->content == NULL))\n    {\n        return NULL;\n    }\n\n    if (cannot_access_at_index(buffer, 0))\n    {\n        return buffer;\n    }\n\n    while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))\n    {\n       buffer->offset++;\n    }\n\n    if (buffer->offset == buffer->length)\n    {\n        buffer->offset--;\n    }\n\n    return buffer;\n}",
          "fn_code_pos": [
            [
              1057,
              0
            ],
            [
              1080,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "buffer_skip_whitespace",
            "parameters": {
              "buffer": "parse_buffer"
            },
            "return_type": "parse_buffer"
          }
        },
        {
          "fn_code": "static parse_buffer *skip_utf8_bom(parse_buffer * const buffer)\n{\n    if ((buffer == NULL) || (buffer->content == NULL) || (buffer->offset != 0))\n    {\n        return NULL;\n    }\n\n    if (can_access_at_index(buffer, 4) && (strncmp((const char*)buffer_at_offset(buffer), \"\\xEF\\xBB\\xBF\", 3) == 0))\n    {\n        buffer->offset += 3;\n    }\n\n    return buffer;\n}",
          "fn_code_pos": [
            [
              1083,
              0
            ],
            [
              1096,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "skip_utf8_bom",
            "parameters": {
              "buffer": "parse_buffer"
            },
            "return_type": "parse_buffer"
          }
        },
        {
          "fn_code": "cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)\n{\n    size_t buffer_length;\n\n    if (NULL == value)\n    {\n        return NULL;\n    }\n\n    /* Adding null character size due to require_null_terminated. */\n    buffer_length = strlen(value) + sizeof(\"\");\n\n    return cJSON_ParseWithLengthOpts(value, buffer_length, return_parse_end, require_null_terminated);\n}",
          "fn_code_pos": [
            [
              1098,
              22
            ],
            [
              1111,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ParseWithOpts",
            "parameters": {
              "value": "char",
              "return_parse_end": "char",
              "require_null_terminated": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated)\n{\n    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };\n    cJSON *item = NULL;\n\n    /* reset error position */\n    global_error.json = NULL;\n    global_error.position = 0;\n\n    if (value == NULL || 0 == buffer_length)\n    {\n        goto fail;\n    }\n\n    buffer.content = (const unsigned char*)value;\n    buffer.length = buffer_length;\n    buffer.offset = 0;\n    buffer.hooks = global_hooks;\n\n    item = cJSON_New_Item(&global_hooks);\n    if (item == NULL) /* memory fail */\n    {\n        goto fail;\n    }\n\n    if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&buffer))))\n    {\n        /* parse failure. ep is set. */\n        goto fail;\n    }\n\n    /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */\n    if (require_null_terminated)\n    {\n        buffer_skip_whitespace(&buffer);\n        if ((buffer.offset >= buffer.length) || buffer_at_offset(&buffer)[0] != '\\0')\n        {\n            goto fail;\n        }\n    }\n    if (return_parse_end)\n    {\n        *return_parse_end = (const char*)buffer_at_offset(&buffer);\n    }\n\n    return item;\n\nfail:\n    if (item != NULL)\n    {\n        cJSON_Delete(item);\n    }\n\n    if (value != NULL)\n    {\n        error local_error;\n        local_error.json = (const unsigned char*)value;\n        local_error.position = 0;\n\n        if (buffer.offset < buffer.length)\n        {\n            local_error.position = buffer.offset;\n        }\n        else if (buffer.length > 0)\n        {\n            local_error.position = buffer.length - 1;\n        }\n\n        if (return_parse_end != NULL)\n        {\n            *return_parse_end = (const char*)local_error.json + local_error.position;\n        }\n\n        global_error = local_error;\n    }\n\n    return NULL;\n}",
          "fn_code_pos": [
            [
              1114,
              22
            ],
            [
              1191,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ParseWithLengthOpts",
            "parameters": {
              "value": "char",
              "buffer_length": "size_t",
              "return_parse_end": "char",
              "require_null_terminated": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_Parse(const char *value)\n{\n    return cJSON_ParseWithOpts(value, 0, 0);\n}",
          "fn_code_pos": [
            [
              1194,
              22
            ],
            [
              1197,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_Parse",
            "parameters": {
              "value": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_ParseWithLength(const char *value, size_t buffer_length)\n{\n    return cJSON_ParseWithLengthOpts(value, buffer_length, 0, 0);\n}",
          "fn_code_pos": [
            [
              1199,
              22
            ],
            [
              1202,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ParseWithLength",
            "parameters": {
              "value": "char",
              "buffer_length": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)\n{\n    static const size_t default_buffer_size = 256;\n    printbuffer buffer[1];\n    unsigned char *printed = NULL;\n\n    memset(buffer, 0, sizeof(buffer));\n\n    /* create buffer */\n    buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);\n    buffer->length = default_buffer_size;\n    buffer->format = format;\n    buffer->hooks = *hooks;\n    if (buffer->buffer == NULL)\n    {\n        goto fail;\n    }\n\n    /* print the value */\n    if (!print_value(item, buffer))\n    {\n        goto fail;\n    }\n    update_offset(buffer);\n\n    /* check if reallocate is available */\n    if (hooks->reallocate != NULL)\n    {\n        printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);\n        if (printed == NULL) {\n            goto fail;\n        }\n        buffer->buffer = NULL;\n    }\n    else /* otherwise copy the JSON over to a new buffer */\n    {\n        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);\n        if (printed == NULL)\n        {\n            goto fail;\n        }\n        memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));\n        printed[buffer->offset] = '\\0'; /* just to be sure */\n\n        /* free the buffer */\n        hooks->deallocate(buffer->buffer);\n        buffer->buffer = NULL;\n    }\n\n    return printed;\n\nfail:\n    if (buffer->buffer != NULL)\n    {\n        hooks->deallocate(buffer->buffer);\n        buffer->buffer = NULL;\n    }\n\n    if (printed != NULL)\n    {\n        hooks->deallocate(printed);\n        printed = NULL;\n    }\n\n    return NULL;\n}",
          "fn_code_pos": [
            [
              1206,
              0
            ],
            [
              1271,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print",
            "parameters": {
              "item": "cJSON",
              "format": "cJSON_bool",
              "hooks": "internal_hooks"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_Print(const cJSON *item)\n{\n    return (char*)print(item, true, &global_hooks);\n}",
          "fn_code_pos": [
            [
              1274,
              21
            ],
            [
              1277,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_Print",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_PrintUnformatted(const cJSON *item)\n{\n    return (char*)print(item, false, &global_hooks);\n}",
          "fn_code_pos": [
            [
              1279,
              21
            ],
            [
              1282,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_PrintUnformatted",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)\n{\n    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };\n\n    if (prebuffer < 0)\n    {\n        return NULL;\n    }\n\n    p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);\n    if (!p.buffer)\n    {\n        return NULL;\n    }\n\n    p.length = (size_t)prebuffer;\n    p.offset = 0;\n    p.noalloc = false;\n    p.format = fmt;\n    p.hooks = global_hooks;\n\n    if (!print_value(item, &p))\n    {\n        global_hooks.deallocate(p.buffer);\n        p.buffer = NULL;\n        return NULL;\n    }\n\n    return (char*)p.buffer;\n}",
          "fn_code_pos": [
            [
              1284,
              21
            ],
            [
              1313,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_PrintBuffered",
            "parameters": {
              "item": "cJSON",
              "prebuffer": "int",
              "fmt": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format)\n{\n    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };\n\n    if ((length < 0) || (buffer == NULL))\n    {\n        return false;\n    }\n\n    p.buffer = (unsigned char*)buffer;\n    p.length = (size_t)length;\n    p.offset = 0;\n    p.noalloc = true;\n    p.format = format;\n    p.hooks = global_hooks;\n\n    return print_value(item, &p);\n}",
          "fn_code_pos": [
            [
              1315,
              25
            ],
            [
              1332,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_PrintPreallocated",
            "parameters": {
              "item": "cJSON",
              "buffer": "char",
              "length": "int",
              "format": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)\n{\n    if ((input_buffer == NULL) || (input_buffer->content == NULL))\n    {\n        return false; /* no input */\n    }\n\n    /* parse the different types of values */\n    /* null */\n    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), \"null\", 4) == 0))\n    {\n        item->type = cJSON_NULL;\n        input_buffer->offset += 4;\n        return true;\n    }\n    /* false */\n    if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), \"false\", 5) == 0))\n    {\n        item->type = cJSON_False;\n        input_buffer->offset += 5;\n        return true;\n    }\n    /* true */\n    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), \"true\", 4) == 0))\n    {\n        item->type = cJSON_True;\n        item->valueint = 1;\n        input_buffer->offset += 4;\n        return true;\n    }\n    /* string */\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\\\"'))\n    {\n        return parse_string(item, input_buffer);\n    }\n    /* number */\n    if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))\n    {\n        return parse_number(item, input_buffer);\n    }\n    /* array */\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))\n    {\n        return parse_array(item, input_buffer);\n    }\n    /* object */\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))\n    {\n        return parse_object(item, input_buffer);\n    }\n\n    return false;\n}",
          "fn_code_pos": [
            [
              1335,
              0
            ],
            [
              1387,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_value",
            "parameters": {
              "item": "cJSON",
              "input_buffer": "parse_buffer"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output = NULL;\n\n    if ((item == NULL) || (output_buffer == NULL))\n    {\n        return false;\n    }\n\n    switch ((item->type) & 0xFF)\n    {\n        case cJSON_NULL:\n            output = ensure(output_buffer, 5);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"null\");\n            return true;\n\n        case cJSON_False:\n            output = ensure(output_buffer, 6);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"false\");\n            return true;\n\n        case cJSON_True:\n            output = ensure(output_buffer, 5);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"true\");\n            return true;\n\n        case cJSON_Number:\n            return print_number(item, output_buffer);\n\n        case cJSON_Raw:\n        {\n            size_t raw_length = 0;\n            if (item->valuestring == NULL)\n            {\n                return false;\n            }\n\n            raw_length = strlen(item->valuestring) + sizeof(\"\");\n            output = ensure(output_buffer, raw_length);\n            if (output == NULL)\n            {\n                return false;\n            }\n            memcpy(output, item->valuestring, raw_length);\n            return true;\n        }\n\n        case cJSON_String:\n            return print_string(item, output_buffer);\n\n        case cJSON_Array:\n            return print_array(item, output_buffer);\n\n        case cJSON_Object:\n            return print_object(item, output_buffer);\n\n        default:\n            return false;\n    }\n}",
          "fn_code_pos": [
            [
              1390,
              0
            ],
            [
              1461,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_value",
            "parameters": {
              "item": "cJSON",
              "output_buffer": "printbuffer"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)\n{\n    cJSON *head = NULL; /* head of the linked list */\n    cJSON *current_item = NULL;\n\n    if (input_buffer->depth >= CJSON_NESTING_LIMIT)\n    {\n        return false; /* to deeply nested */\n    }\n    input_buffer->depth++;\n\n    if (buffer_at_offset(input_buffer)[0] != '[')\n    {\n        /* not an array */\n        goto fail;\n    }\n\n    input_buffer->offset++;\n    buffer_skip_whitespace(input_buffer);\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']'))\n    {\n        /* empty array */\n        goto success;\n    }\n\n    /* check if we skipped to the end of the buffer */\n    if (cannot_access_at_index(input_buffer, 0))\n    {\n        input_buffer->offset--;\n        goto fail;\n    }\n\n    /* step back to character in front of the first element */\n    input_buffer->offset--;\n    /* loop through the comma separated array elements */\n    do\n    {\n        /* allocate next item */\n        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));\n        if (new_item == NULL)\n        {\n            goto fail; /* allocation failure */\n        }\n\n        /* attach next item to list */\n        if (head == NULL)\n        {\n            /* start the linked list */\n            current_item = head = new_item;\n        }\n        else\n        {\n            /* add to the end and advance */\n            current_item->next = new_item;\n            new_item->prev = current_item;\n            current_item = new_item;\n        }\n\n        /* parse next value */\n        input_buffer->offset++;\n        buffer_skip_whitespace(input_buffer);\n        if (!parse_value(current_item, input_buffer))\n        {\n            goto fail; /* failed to parse value */\n        }\n        buffer_skip_whitespace(input_buffer);\n    }\n    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));\n\n    if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')\n    {\n        goto fail; /* expected end of array */\n    }\n\nsuccess:\n    input_buffer->depth--;\n\n    if (head != NULL) {\n        head->prev = current_item;\n    }\n\n    item->type = cJSON_Array;\n    item->child = head;\n\n    input_buffer->offset++;\n\n    return true;\n\nfail:\n    if (head != NULL)\n    {\n        cJSON_Delete(head);\n    }\n\n    return false;\n}",
          "fn_code_pos": [
            [
              1464,
              0
            ],
            [
              1559,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_array",
            "parameters": {
              "item": "cJSON",
              "input_buffer": "parse_buffer"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output_pointer = NULL;\n    size_t length = 0;\n    cJSON *current_element = item->child;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* Compose the output array. */\n    /* opening square bracket */\n    output_pointer = ensure(output_buffer, 1);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n\n    *output_pointer = '[';\n    output_buffer->offset++;\n    output_buffer->depth++;\n\n    while (current_element != NULL)\n    {\n        if (!print_value(current_element, output_buffer))\n        {\n            return false;\n        }\n        update_offset(output_buffer);\n        if (current_element->next)\n        {\n            length = (size_t) (output_buffer->format ? 2 : 1);\n            output_pointer = ensure(output_buffer, length + 1);\n            if (output_pointer == NULL)\n            {\n                return false;\n            }\n            *output_pointer++ = ',';\n            if(output_buffer->format)\n            {\n                *output_pointer++ = ' ';\n            }\n            *output_pointer = '\\0';\n            output_buffer->offset += length;\n        }\n        current_element = current_element->next;\n    }\n\n    output_pointer = ensure(output_buffer, 2);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n    *output_pointer++ = ']';\n    *output_pointer = '\\0';\n    output_buffer->depth--;\n\n    return true;\n}",
          "fn_code_pos": [
            [
              1562,
              0
            ],
            [
              1621,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_array",
            "parameters": {
              "item": "cJSON",
              "output_buffer": "printbuffer"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)\n{\n    cJSON *head = NULL; /* linked list head */\n    cJSON *current_item = NULL;\n\n    if (input_buffer->depth >= CJSON_NESTING_LIMIT)\n    {\n        return false; /* to deeply nested */\n    }\n    input_buffer->depth++;\n\n    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))\n    {\n        goto fail; /* not an object */\n    }\n\n    input_buffer->offset++;\n    buffer_skip_whitespace(input_buffer);\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}'))\n    {\n        goto success; /* empty object */\n    }\n\n    /* check if we skipped to the end of the buffer */\n    if (cannot_access_at_index(input_buffer, 0))\n    {\n        input_buffer->offset--;\n        goto fail;\n    }\n\n    /* step back to character in front of the first element */\n    input_buffer->offset--;\n    /* loop through the comma separated array elements */\n    do\n    {\n        /* allocate next item */\n        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));\n        if (new_item == NULL)\n        {\n            goto fail; /* allocation failure */\n        }\n\n        /* attach next item to list */\n        if (head == NULL)\n        {\n            /* start the linked list */\n            current_item = head = new_item;\n        }\n        else\n        {\n            /* add to the end and advance */\n            current_item->next = new_item;\n            new_item->prev = current_item;\n            current_item = new_item;\n        }\n\n        if (cannot_access_at_index(input_buffer, 1))\n        {\n            goto fail; /* nothing comes after the comma */\n        }\n\n        /* parse the name of the child */\n        input_buffer->offset++;\n        buffer_skip_whitespace(input_buffer);\n        if (!parse_string(current_item, input_buffer))\n        {\n            goto fail; /* failed to parse name */\n        }\n        buffer_skip_whitespace(input_buffer);\n\n        /* swap valuestring and string, because we parsed the name */\n        current_item->string = current_item->valuestring;\n        current_item->valuestring = NULL;\n\n        if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))\n        {\n            goto fail; /* invalid object */\n        }\n\n        /* parse the value */\n        input_buffer->offset++;\n        buffer_skip_whitespace(input_buffer);\n        if (!parse_value(current_item, input_buffer))\n        {\n            goto fail; /* failed to parse value */\n        }\n        buffer_skip_whitespace(input_buffer);\n    }\n    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));\n\n    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))\n    {\n        goto fail; /* expected end of object */\n    }\n\nsuccess:\n    input_buffer->depth--;\n\n    if (head != NULL) {\n        head->prev = current_item;\n    }\n\n    item->type = cJSON_Object;\n    item->child = head;\n\n    input_buffer->offset++;\n    return true;\n\nfail:\n    if (head != NULL)\n    {\n        cJSON_Delete(head);\n    }\n\n    return false;\n}",
          "fn_code_pos": [
            [
              1624,
              0
            ],
            [
              1739,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_object",
            "parameters": {
              "item": "cJSON",
              "input_buffer": "parse_buffer"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output_pointer = NULL;\n    size_t length = 0;\n    cJSON *current_item = item->child;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* Compose the output: */\n    length = (size_t) (output_buffer->format ? 2 : 1); /* fmt: {\\n */\n    output_pointer = ensure(output_buffer, length + 1);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n\n    *output_pointer++ = '{';\n    output_buffer->depth++;\n    if (output_buffer->format)\n    {\n        *output_pointer++ = '\\n';\n    }\n    output_buffer->offset += length;\n\n    while (current_item)\n    {\n        if (output_buffer->format)\n        {\n            size_t i;\n            output_pointer = ensure(output_buffer, output_buffer->depth);\n            if (output_pointer == NULL)\n            {\n                return false;\n            }\n            for (i = 0; i < output_buffer->depth; i++)\n            {\n                *output_pointer++ = '\\t';\n            }\n            output_buffer->offset += output_buffer->depth;\n        }\n\n        /* print key */\n        if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))\n        {\n            return false;\n        }\n        update_offset(output_buffer);\n\n        length = (size_t) (output_buffer->format ? 2 : 1);\n        output_pointer = ensure(output_buffer, length);\n        if (output_pointer == NULL)\n        {\n            return false;\n        }\n        *output_pointer++ = ':';\n        if (output_buffer->format)\n        {\n            *output_pointer++ = '\\t';\n        }\n        output_buffer->offset += length;\n\n        /* print value */\n        if (!print_value(current_item, output_buffer))\n        {\n            return false;\n        }\n        update_offset(output_buffer);\n\n        /* print comma if not last */\n        length = ((size_t)(output_buffer->format ? 1 : 0) + (size_t)(current_item->next ? 1 : 0));\n        output_pointer = ensure(output_buffer, length + 1);\n        if (output_pointer == NULL)\n        {\n            return false;\n        }\n        if (current_item->next)\n        {\n            *output_pointer++ = ',';\n        }\n\n        if (output_buffer->format)\n        {\n            *output_pointer++ = '\\n';\n        }\n        *output_pointer = '\\0';\n        output_buffer->offset += length;\n\n        current_item = current_item->next;\n    }\n\n    output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n    if (output_buffer->format)\n    {\n        size_t i;\n        for (i = 0; i < (output_buffer->depth - 1); i++)\n        {\n            *output_pointer++ = '\\t';\n        }\n    }\n    *output_pointer++ = '}';\n    *output_pointer = '\\0';\n    output_buffer->depth--;\n\n    return true;\n}",
          "fn_code_pos": [
            [
              1742,
              0
            ],
            [
              1853,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_object",
            "parameters": {
              "item": "cJSON",
              "output_buffer": "printbuffer"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "cJSON_GetArraySize(const cJSON *array)\n{\n    cJSON *child = NULL;\n    size_t size = 0;\n\n    if (array == NULL)\n    {\n        return 0;\n    }\n\n    child = array->child;\n\n    while(child != NULL)\n    {\n        size++;\n        child = child->next;\n    }\n\n    /* FIXME: Can overflow here. Cannot be fixed without breaking the API */\n\n    return (int)size;\n}",
          "fn_code_pos": [
            [
              1856,
              18
            ],
            [
              1877,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_GetArraySize",
            "parameters": {
              "array": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static cJSON* get_array_item(const cJSON *array, size_t index)\n{\n    cJSON *current_child = NULL;\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    current_child = array->child;\n    while ((current_child != NULL) && (index > 0))\n    {\n        index--;\n        current_child = current_child->next;\n    }\n\n    return current_child;\n}",
          "fn_code_pos": [
            [
              1879,
              0
            ],
            [
              1896,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_array_item",
            "parameters": {
              "array": "cJSON",
              "index": "size_t"
            },
            "return_type": "cJSON"
          }
        },
        {
          "fn_code": "cJSON_GetArrayItem(const cJSON *array, int index)\n{\n    if (index < 0)\n    {\n        return NULL;\n    }\n\n    return get_array_item(array, (size_t)index);\n}",
          "fn_code_pos": [
            [
              1898,
              22
            ],
            [
              1906,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_GetArrayItem",
            "parameters": {
              "array": "cJSON",
              "index": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n\n    current_element = object->child;\n    if (case_sensitive)\n    {\n        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n\n    if ((current_element == NULL) || (current_element->string == NULL)) {\n        return NULL;\n    }\n\n    return current_element;\n}",
          "fn_code_pos": [
            [
              1908,
              0
            ],
            [
              1938,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_object_item",
            "parameters": {
              "object": "cJSON",
              "name": "char",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": "cJSON"
          }
        },
        {
          "fn_code": "cJSON_GetObjectItem(const cJSON * const object, const char * const string)\n{\n    return get_object_item(object, string, false);\n}",
          "fn_code_pos": [
            [
              1940,
              22
            ],
            [
              1943,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_GetObjectItem",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)\n{\n    return get_object_item(object, string, true);\n}",
          "fn_code_pos": [
            [
              1945,
              22
            ],
            [
              1948,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_GetObjectItemCaseSensitive",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_HasObjectItem(const cJSON *object, const char *string)\n{\n    return cJSON_GetObjectItem(object, string) ? 1 : 0;\n}",
          "fn_code_pos": [
            [
              1950,
              25
            ],
            [
              1953,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_HasObjectItem",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void suffix_object(cJSON *prev, cJSON *item)\n{\n    prev->next = item;\n    item->prev = prev;\n}",
          "fn_code_pos": [
            [
              1956,
              0
            ],
            [
              1960,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "suffix_object",
            "parameters": {
              "prev": "cJSON",
              "item": "cJSON"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)\n{\n    cJSON *reference = NULL;\n    if (item == NULL)\n    {\n        return NULL;\n    }\n\n    reference = cJSON_New_Item(hooks);\n    if (reference == NULL)\n    {\n        return NULL;\n    }\n\n    memcpy(reference, item, sizeof(cJSON));\n    reference->string = NULL;\n    reference->type |= cJSON_IsReference;\n    reference->next = reference->prev = NULL;\n    return reference;\n}",
          "fn_code_pos": [
            [
              1963,
              0
            ],
            [
              1982,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "create_reference",
            "parameters": {
              "item": "cJSON",
              "hooks": "internal_hooks"
            },
            "return_type": "cJSON"
          }
        },
        {
          "fn_code": "static cJSON_bool add_item_to_array(cJSON *array, cJSON *item)\n{\n    cJSON *child = NULL;\n\n    if ((item == NULL) || (array == NULL) || (array == item))\n    {\n        return false;\n    }\n\n    child = array->child;\n    /*\n     * To find the last item in array quickly, we use prev in array\n     */\n    if (child == NULL)\n    {\n        /* list is empty, start new one */\n        array->child = item;\n        item->prev = item;\n        item->next = NULL;\n    }\n    else\n    {\n        /* append to the end */\n        if (child->prev)\n        {\n            suffix_object(child->prev, item);\n            array->child->prev = item;\n        }\n    }\n\n    return true;\n}",
          "fn_code_pos": [
            [
              1984,
              0
            ],
            [
              2015,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_item_to_array",
            "parameters": {
              "array": "cJSON",
              "item": "cJSON"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "cJSON_AddItemToArray(cJSON *array, cJSON *item)\n{\n    return add_item_to_array(array, item);\n}",
          "fn_code_pos": [
            [
              2018,
              25
            ],
            [
              2021,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddItemToArray",
            "parameters": {
              "array": "cJSON",
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void* cast_away_const(const void* string)\n{\n    return (void*)string;\n}",
          "fn_code_pos": [
            [
              2030,
              0
            ],
            [
              2033,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cast_away_const",
            "parameters": {
              "string": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)\n{\n    char *new_key = NULL;\n    int new_type = cJSON_Invalid;\n\n    if ((object == NULL) || (string == NULL) || (item == NULL) || (object == item))\n    {\n        return false;\n    }\n\n    if (constant_key)\n    {\n        new_key = (char*)cast_away_const(string);\n        new_type = item->type | cJSON_StringIsConst;\n    }\n    else\n    {\n        new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);\n        if (new_key == NULL)\n        {\n            return false;\n        }\n\n        new_type = item->type & ~cJSON_StringIsConst;\n    }\n\n    if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))\n    {\n        hooks->deallocate(item->string);\n    }\n\n    item->string = new_key;\n    item->type = new_type;\n\n    return add_item_to_array(object, item);\n}",
          "fn_code_pos": [
            [
              2039,
              0
            ],
            [
              2074,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_item_to_object",
            "parameters": {
              "object": "cJSON",
              "string": "char",
              "item": "cJSON",
              "hooks": "internal_hooks",
              "constant_key": "cJSON_bool"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)\n{\n    return add_item_to_object(object, string, item, &global_hooks, false);\n}",
          "fn_code_pos": [
            [
              2076,
              25
            ],
            [
              2079,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddItemToObject",
            "parameters": {
              "object": "cJSON",
              "string": "char",
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)\n{\n    return add_item_to_object(object, string, item, &global_hooks, true);\n}",
          "fn_code_pos": [
            [
              2082,
              25
            ],
            [
              2085,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddItemToObjectCS",
            "parameters": {
              "object": "cJSON",
              "string": "char",
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)\n{\n    if (array == NULL)\n    {\n        return false;\n    }\n\n    return add_item_to_array(array, create_reference(item, &global_hooks));\n}",
          "fn_code_pos": [
            [
              2087,
              25
            ],
            [
              2095,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddItemReferenceToArray",
            "parameters": {
              "array": "cJSON",
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)\n{\n    if ((object == NULL) || (string == NULL))\n    {\n        return false;\n    }\n\n    return add_item_to_object(object, string, create_reference(item, &global_hooks), &global_hooks, false);\n}",
          "fn_code_pos": [
            [
              2097,
              25
            ],
            [
              2105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddItemReferenceToObject",
            "parameters": {
              "object": "cJSON",
              "string": "char",
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddNullToObject(cJSON * const object, const char * const name)\n{\n    cJSON *null = cJSON_CreateNull();\n    if (add_item_to_object(object, name, null, &global_hooks, false))\n    {\n        return null;\n    }\n\n    cJSON_Delete(null);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              2107,
              21
            ],
            [
              2117,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddNullToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddTrueToObject(cJSON * const object, const char * const name)\n{\n    cJSON *true_item = cJSON_CreateTrue();\n    if (add_item_to_object(object, name, true_item, &global_hooks, false))\n    {\n        return true_item;\n    }\n\n    cJSON_Delete(true_item);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              2119,
              21
            ],
            [
              2129,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddTrueToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddFalseToObject(cJSON * const object, const char * const name)\n{\n    cJSON *false_item = cJSON_CreateFalse();\n    if (add_item_to_object(object, name, false_item, &global_hooks, false))\n    {\n        return false_item;\n    }\n\n    cJSON_Delete(false_item);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              2131,
              21
            ],
            [
              2141,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddFalseToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean)\n{\n    cJSON *bool_item = cJSON_CreateBool(boolean);\n    if (add_item_to_object(object, name, bool_item, &global_hooks, false))\n    {\n        return bool_item;\n    }\n\n    cJSON_Delete(bool_item);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              2143,
              21
            ],
            [
              2153,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddBoolToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char",
              "boolean": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)\n{\n    cJSON *number_item = cJSON_CreateNumber(number);\n    if (add_item_to_object(object, name, number_item, &global_hooks, false))\n    {\n        return number_item;\n    }\n\n    cJSON_Delete(number_item);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              2155,
              21
            ],
            [
              2165,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddNumberToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char",
              "number": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)\n{\n    cJSON *string_item = cJSON_CreateString(string);\n    if (add_item_to_object(object, name, string_item, &global_hooks, false))\n    {\n        return string_item;\n    }\n\n    cJSON_Delete(string_item);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              2167,
              21
            ],
            [
              2177,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddStringToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw)\n{\n    cJSON *raw_item = cJSON_CreateRaw(raw);\n    if (add_item_to_object(object, name, raw_item, &global_hooks, false))\n    {\n        return raw_item;\n    }\n\n    cJSON_Delete(raw_item);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              2179,
              21
            ],
            [
              2189,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddRawToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char",
              "raw": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddObjectToObject(cJSON * const object, const char * const name)\n{\n    cJSON *object_item = cJSON_CreateObject();\n    if (add_item_to_object(object, name, object_item, &global_hooks, false))\n    {\n        return object_item;\n    }\n\n    cJSON_Delete(object_item);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              2191,
              21
            ],
            [
              2201,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddObjectToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddArrayToObject(cJSON * const object, const char * const name)\n{\n    cJSON *array = cJSON_CreateArray();\n    if (add_item_to_object(object, name, array, &global_hooks, false))\n    {\n        return array;\n    }\n\n    cJSON_Delete(array);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              2203,
              21
            ],
            [
              2213,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddArrayToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)\n{\n    if ((parent == NULL) || (item == NULL) || (item != parent->child && item->prev == NULL))\n    {\n        return NULL;\n    }\n\n    if (item != parent->child)\n    {\n        /* not the first element */\n        item->prev->next = item->next;\n    }\n    if (item->next != NULL)\n    {\n        /* not the last element */\n        item->next->prev = item->prev;\n    }\n\n    if (item == parent->child)\n    {\n        /* first element */\n        parent->child = item->next;\n    }\n    else if (item->next == NULL)\n    {\n        /* last element */\n        parent->child->prev = item->prev;\n    }\n\n    /* make sure the detached item doesn't point anywhere anymore */\n    item->prev = NULL;\n    item->next = NULL;\n\n    return item;\n}",
          "fn_code_pos": [
            [
              2215,
              22
            ],
            [
              2249,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DetachItemViaPointer",
            "parameters": {
              "parent": "cJSON",
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_DetachItemFromArray(cJSON *array, int which)\n{\n    if (which < 0)\n    {\n        return NULL;\n    }\n\n    return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));\n}",
          "fn_code_pos": [
            [
              2251,
              22
            ],
            [
              2259,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DetachItemFromArray",
            "parameters": {
              "array": "cJSON",
              "which": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_DeleteItemFromArray(cJSON *array, int which)\n{\n    cJSON_Delete(cJSON_DetachItemFromArray(array, which));\n}",
          "fn_code_pos": [
            [
              2261,
              19
            ],
            [
              2264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DeleteItemFromArray",
            "parameters": {
              "array": "cJSON",
              "which": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_DetachItemFromObject(cJSON *object, const char *string)\n{\n    cJSON *to_detach = cJSON_GetObjectItem(object, string);\n\n    return cJSON_DetachItemViaPointer(object, to_detach);\n}",
          "fn_code_pos": [
            [
              2266,
              22
            ],
            [
              2271,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DetachItemFromObject",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string)\n{\n    cJSON *to_detach = cJSON_GetObjectItemCaseSensitive(object, string);\n\n    return cJSON_DetachItemViaPointer(object, to_detach);\n}",
          "fn_code_pos": [
            [
              2273,
              22
            ],
            [
              2278,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DetachItemFromObjectCaseSensitive",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_DeleteItemFromObject(cJSON *object, const char *string)\n{\n    cJSON_Delete(cJSON_DetachItemFromObject(object, string));\n}",
          "fn_code_pos": [
            [
              2280,
              19
            ],
            [
              2283,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DeleteItemFromObject",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)\n{\n    cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));\n}",
          "fn_code_pos": [
            [
              2285,
              19
            ],
            [
              2288,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DeleteItemFromObjectCaseSensitive",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)\n{\n    cJSON *after_inserted = NULL;\n\n    if (which < 0 || newitem == NULL)\n    {\n        return false;\n    }\n\n    after_inserted = get_array_item(array, (size_t)which);\n    if (after_inserted == NULL)\n    {\n        return add_item_to_array(array, newitem);\n    }\n\n    if (after_inserted != array->child && after_inserted->prev == NULL) {\n        /* return false if after_inserted is a corrupted array item */\n        return false;\n    }\n\n    newitem->next = after_inserted;\n    newitem->prev = after_inserted->prev;\n    after_inserted->prev = newitem;\n    if (after_inserted == array->child)\n    {\n        array->child = newitem;\n    }\n    else\n    {\n        newitem->prev->next = newitem;\n    }\n    return true;\n}",
          "fn_code_pos": [
            [
              2291,
              25
            ],
            [
              2323,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_InsertItemInArray",
            "parameters": {
              "array": "cJSON",
              "which": "int",
              "newitem": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)\n{\n    if ((parent == NULL) || (parent->child == NULL) || (replacement == NULL) || (item == NULL))\n    {\n        return false;\n    }\n\n    if (replacement == item)\n    {\n        return true;\n    }\n\n    replacement->next = item->next;\n    replacement->prev = item->prev;\n\n    if (replacement->next != NULL)\n    {\n        replacement->next->prev = replacement;\n    }\n    if (parent->child == item)\n    {\n        if (parent->child->prev == parent->child)\n        {\n            replacement->prev = replacement;\n        }\n        parent->child = replacement;\n    }\n    else\n    {   /*\n         * To find the last item in array quickly, we use prev in array.\n         * We can't modify the last item's next pointer where this item was the parent's child\n         */\n        if (replacement->prev != NULL)\n        {\n            replacement->prev->next = replacement;\n        }\n        if (replacement->next == NULL)\n        {\n            parent->child->prev = replacement;\n        }\n    }\n\n    item->next = NULL;\n    item->prev = NULL;\n    cJSON_Delete(item);\n\n    return true;\n}",
          "fn_code_pos": [
            [
              2325,
              25
            ],
            [
              2372,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ReplaceItemViaPointer",
            "parameters": {
              "parent": "cJSON",
              "item": "cJSON",
              "replacement": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)\n{\n    if (which < 0)\n    {\n        return false;\n    }\n\n    return cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);\n}",
          "fn_code_pos": [
            [
              2374,
              25
            ],
            [
              2382,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ReplaceItemInArray",
            "parameters": {
              "array": "cJSON",
              "which": "int",
              "newitem": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement, cJSON_bool case_sensitive)\n{\n    if ((replacement == NULL) || (string == NULL))\n    {\n        return false;\n    }\n\n    /* replace the name in the replacement */\n    if (!(replacement->type & cJSON_StringIsConst) && (replacement->string != NULL))\n    {\n        cJSON_free(replacement->string);\n    }\n    replacement->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);\n    if (replacement->string == NULL)\n    {\n        return false;\n    }\n\n    replacement->type &= ~cJSON_StringIsConst;\n\n    return cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);\n}",
          "fn_code_pos": [
            [
              2384,
              0
            ],
            [
              2405,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "replace_item_in_object",
            "parameters": {
              "object": "cJSON",
              "string": "char",
              "replacement": "cJSON",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)\n{\n    return replace_item_in_object(object, string, newitem, false);\n}",
          "fn_code_pos": [
            [
              2407,
              25
            ],
            [
              2410,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ReplaceItemInObject",
            "parameters": {
              "object": "cJSON",
              "string": "char",
              "newitem": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object, const char *string, cJSON *newitem)\n{\n    return replace_item_in_object(object, string, newitem, true);\n}",
          "fn_code_pos": [
            [
              2412,
              25
            ],
            [
              2415,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ReplaceItemInObjectCaseSensitive",
            "parameters": {
              "object": "cJSON",
              "string": "char",
              "newitem": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateNull(void)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_NULL;\n    }\n\n    return item;\n}",
          "fn_code_pos": [
            [
              2418,
              22
            ],
            [
              2427,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateNull",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateTrue(void)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_True;\n    }\n\n    return item;\n}",
          "fn_code_pos": [
            [
              2429,
              22
            ],
            [
              2438,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateTrue",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateFalse(void)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_False;\n    }\n\n    return item;\n}",
          "fn_code_pos": [
            [
              2440,
              22
            ],
            [
              2449,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateFalse",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateBool(cJSON_bool boolean)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = boolean ? cJSON_True : cJSON_False;\n    }\n\n    return item;\n}",
          "fn_code_pos": [
            [
              2451,
              22
            ],
            [
              2460,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateBool",
            "parameters": {
              "boolean": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateNumber(double num)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_Number;\n        item->valuedouble = num;\n\n        /* use saturation in case of overflow */\n        if (num >= INT_MAX)\n        {\n            item->valueint = INT_MAX;\n        }\n        else if (num <= (double)INT_MIN)\n        {\n            item->valueint = INT_MIN;\n        }\n        else\n        {\n            item->valueint = (int)num;\n        }\n    }\n\n    return item;\n}",
          "fn_code_pos": [
            [
              2462,
              22
            ],
            [
              2486,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateNumber",
            "parameters": {
              "num": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateString(const char *string)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_String;\n        item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);\n        if(!item->valuestring)\n        {\n            cJSON_Delete(item);\n            return NULL;\n        }\n    }\n\n    return item;\n}",
          "fn_code_pos": [
            [
              2488,
              22
            ],
            [
              2503,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateString",
            "parameters": {
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateStringReference(const char *string)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if (item != NULL)\n    {\n        item->type = cJSON_String | cJSON_IsReference;\n        item->valuestring = (char*)cast_away_const(string);\n    }\n\n    return item;\n}",
          "fn_code_pos": [
            [
              2505,
              22
            ],
            [
              2515,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateStringReference",
            "parameters": {
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateObjectReference(const cJSON *child)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if (item != NULL) {\n        item->type = cJSON_Object | cJSON_IsReference;\n        item->child = (cJSON*)cast_away_const(child);\n    }\n\n    return item;\n}",
          "fn_code_pos": [
            [
              2517,
              22
            ],
            [
              2526,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateObjectReference",
            "parameters": {
              "child": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateArrayReference(const cJSON *child) {\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if (item != NULL) {\n        item->type = cJSON_Array | cJSON_IsReference;\n        item->child = (cJSON*)cast_away_const(child);\n    }\n\n    return item;\n}",
          "fn_code_pos": [
            [
              2528,
              22
            ],
            [
              2536,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateArrayReference",
            "parameters": {
              "child": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateRaw(const char *raw)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_Raw;\n        item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);\n        if(!item->valuestring)\n        {\n            cJSON_Delete(item);\n            return NULL;\n        }\n    }\n\n    return item;\n}",
          "fn_code_pos": [
            [
              2538,
              22
            ],
            [
              2553,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateRaw",
            "parameters": {
              "raw": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateArray(void)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type=cJSON_Array;\n    }\n\n    return item;\n}",
          "fn_code_pos": [
            [
              2555,
              22
            ],
            [
              2564,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateArray",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateObject(void)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if (item)\n    {\n        item->type = cJSON_Object;\n    }\n\n    return item;\n}",
          "fn_code_pos": [
            [
              2566,
              22
            ],
            [
              2575,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateObject",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateIntArray(const int *numbers, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count < 0) || (numbers == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n\n    for(i = 0; a && (i < (size_t)count); i++)\n    {\n        n = cJSON_CreateNumber(numbers[i]);\n        if (!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a->child = n;\n        }\n        else\n        {\n            suffix_object(p, n);\n        }\n        p = n;\n    }\n\n    if (a && a->child) {\n        a->child->prev = n;\n    }\n\n    return a;\n}",
          "fn_code_pos": [
            [
              2578,
              22
            ],
            [
              2616,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateIntArray",
            "parameters": {
              "numbers": "int",
              "count": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateFloatArray(const float *numbers, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count < 0) || (numbers == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n\n    for(i = 0; a && (i < (size_t)count); i++)\n    {\n        n = cJSON_CreateNumber((double)numbers[i]);\n        if(!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a->child = n;\n        }\n        else\n        {\n            suffix_object(p, n);\n        }\n        p = n;\n    }\n\n    if (a && a->child) {\n        a->child->prev = n;\n    }\n\n    return a;\n}",
          "fn_code_pos": [
            [
              2618,
              22
            ],
            [
              2656,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateFloatArray",
            "parameters": {
              "numbers": "float",
              "count": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateDoubleArray(const double *numbers, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count < 0) || (numbers == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n\n    for(i = 0; a && (i < (size_t)count); i++)\n    {\n        n = cJSON_CreateNumber(numbers[i]);\n        if(!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a->child = n;\n        }\n        else\n        {\n            suffix_object(p, n);\n        }\n        p = n;\n    }\n\n    if (a && a->child) {\n        a->child->prev = n;\n    }\n\n    return a;\n}",
          "fn_code_pos": [
            [
              2658,
              22
            ],
            [
              2696,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateDoubleArray",
            "parameters": {
              "numbers": "double",
              "count": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateStringArray(const char *const *strings, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count < 0) || (strings == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n\n    for (i = 0; a && (i < (size_t)count); i++)\n    {\n        n = cJSON_CreateString(strings[i]);\n        if(!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a->child = n;\n        }\n        else\n        {\n            suffix_object(p,n);\n        }\n        p = n;\n    }\n\n    if (a && a->child) {\n        a->child->prev = n;\n    }\n\n    return a;\n}",
          "fn_code_pos": [
            [
              2698,
              22
            ],
            [
              2736,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateStringArray",
            "parameters": {
              "strings": "char",
              "count": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)\n{\n    cJSON *newitem = NULL;\n    cJSON *child = NULL;\n    cJSON *next = NULL;\n    cJSON *newchild = NULL;\n\n    /* Bail on bad ptr */\n    if (!item)\n    {\n        goto fail;\n    }\n    /* Create new item */\n    newitem = cJSON_New_Item(&global_hooks);\n    if (!newitem)\n    {\n        goto fail;\n    }\n    /* Copy over all vars */\n    newitem->type = item->type & (~cJSON_IsReference);\n    newitem->valueint = item->valueint;\n    newitem->valuedouble = item->valuedouble;\n    if (item->valuestring)\n    {\n        newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);\n        if (!newitem->valuestring)\n        {\n            goto fail;\n        }\n    }\n    if (item->string)\n    {\n        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);\n        if (!newitem->string)\n        {\n            goto fail;\n        }\n    }\n    /* If non-recursive, then we're done! */\n    if (!recurse)\n    {\n        return newitem;\n    }\n    /* Walk the ->next chain for the child. */\n    child = item->child;\n    while (child != NULL)\n    {\n        newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */\n        if (!newchild)\n        {\n            goto fail;\n        }\n        if (next != NULL)\n        {\n            /* If newitem->child already set, then crosswire ->prev and ->next and move on */\n            next->next = newchild;\n            newchild->prev = next;\n            next = newchild;\n        }\n        else\n        {\n            /* Set newitem->child and move to it */\n            newitem->child = newchild;\n            next = newchild;\n        }\n        child = child->next;\n    }\n    if (newitem && newitem->child)\n    {\n        newitem->child->prev = newchild;\n    }\n\n    return newitem;\n\nfail:\n    if (newitem != NULL)\n    {\n        cJSON_Delete(newitem);\n    }\n\n    return NULL;\n}",
          "fn_code_pos": [
            [
              2739,
              22
            ],
            [
              2820,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_Duplicate",
            "parameters": {
              "item": "cJSON",
              "recurse": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void skip_oneline_comment(char **input)\n{\n    *input += static_strlen(\"//\");\n\n    for (; (*input)[0] != '\\0'; ++(*input))\n    {\n        if ((*input)[0] == '\\n') {\n            *input += static_strlen(\"\\n\");\n            return;\n        }\n    }\n}",
          "fn_code_pos": [
            [
              2822,
              0
            ],
            [
              2833,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "skip_oneline_comment",
            "parameters": {
              "input": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void skip_multiline_comment(char **input)\n{\n    *input += static_strlen(\"/*\");\n\n    for (; (*input)[0] != '\\0'; ++(*input))\n    {\n        if (((*input)[0] == '*') && ((*input)[1] == '/'))\n        {\n            *input += static_strlen(\"*/\");\n            return;\n        }\n    }\n}",
          "fn_code_pos": [
            [
              2835,
              0
            ],
            [
              2847,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "skip_multiline_comment",
            "parameters": {
              "input": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void minify_string(char **input, char **output) {\n    (*output)[0] = (*input)[0];\n    *input += static_strlen(\"\\\"\");\n    *output += static_strlen(\"\\\"\");\n\n\n    for (; (*input)[0] != '\\0'; (void)++(*input), ++(*output)) {\n        (*output)[0] = (*input)[0];\n\n        if ((*input)[0] == '\\\"') {\n            (*output)[0] = '\\\"';\n            *input += static_strlen(\"\\\"\");\n            *output += static_strlen(\"\\\"\");\n            return;\n        } else if (((*input)[0] == '\\\\') && ((*input)[1] == '\\\"')) {\n            (*output)[1] = (*input)[1];\n            *input += static_strlen(\"\\\"\");\n            *output += static_strlen(\"\\\"\");\n        }\n    }\n}",
          "fn_code_pos": [
            [
              2849,
              0
            ],
            [
              2869,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "minify_string",
            "parameters": {
              "input": "char",
              "output": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "cJSON_Minify(char *json)\n{\n    char *into = json;\n\n    if (json == NULL)\n    {\n        return;\n    }\n\n    while (json[0] != '\\0')\n    {\n        switch (json[0])\n        {\n            case ' ':\n            case '\\t':\n            case '\\r':\n            case '\\n':\n                json++;\n                break;\n\n            case '/':\n                if (json[1] == '/')\n                {\n                    skip_oneline_comment(&json);\n                }\n                else if (json[1] == '*')\n                {\n                    skip_multiline_comment(&json);\n                } else {\n                    json++;\n                }\n                break;\n\n            case '\\\"':\n                minify_string(&json, (char**)&into);\n                break;\n\n            default:\n                into[0] = json[0];\n                json++;\n                into++;\n        }\n    }\n\n    /* and null-terminate. */\n    *into = '\\0';\n}",
          "fn_code_pos": [
            [
              2871,
              19
            ],
            [
              2917,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_Minify",
            "parameters": {
              "json": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsInvalid(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_Invalid;\n}",
          "fn_code_pos": [
            [
              2919,
              25
            ],
            [
              2927,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsInvalid",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsFalse(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_False;\n}",
          "fn_code_pos": [
            [
              2929,
              25
            ],
            [
              2937,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsFalse",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsTrue(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xff) == cJSON_True;\n}",
          "fn_code_pos": [
            [
              2939,
              25
            ],
            [
              2947,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsTrue",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsBool(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & (cJSON_True | cJSON_False)) != 0;\n}",
          "fn_code_pos": [
            [
              2950,
              25
            ],
            [
              2958,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsBool",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsNull(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_NULL;\n}",
          "fn_code_pos": [
            [
              2959,
              25
            ],
            [
              2967,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsNull",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsNumber(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_Number;\n}",
          "fn_code_pos": [
            [
              2969,
              25
            ],
            [
              2977,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsNumber",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsString(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_String;\n}",
          "fn_code_pos": [
            [
              2979,
              25
            ],
            [
              2987,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsString",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsArray(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_Array;\n}",
          "fn_code_pos": [
            [
              2989,
              25
            ],
            [
              2997,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsArray",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsObject(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_Object;\n}",
          "fn_code_pos": [
            [
              2999,
              25
            ],
            [
              3007,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsObject",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsRaw(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_Raw;\n}",
          "fn_code_pos": [
            [
              3009,
              25
            ],
            [
              3017,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsRaw",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)\n{\n    if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)))\n    {\n        return false;\n    }\n\n    /* check if type is valid */\n    switch (a->type & 0xFF)\n    {\n        case cJSON_False:\n        case cJSON_True:\n        case cJSON_NULL:\n        case cJSON_Number:\n        case cJSON_String:\n        case cJSON_Raw:\n        case cJSON_Array:\n        case cJSON_Object:\n            break;\n\n        default:\n            return false;\n    }\n\n    /* identical objects are equal */\n    if (a == b)\n    {\n        return true;\n    }\n\n    switch (a->type & 0xFF)\n    {\n        /* in these cases and equal type is enough */\n        case cJSON_False:\n        case cJSON_True:\n        case cJSON_NULL:\n            return true;\n\n        case cJSON_Number:\n            if (compare_double(a->valuedouble, b->valuedouble))\n            {\n                return true;\n            }\n            return false;\n\n        case cJSON_String:\n        case cJSON_Raw:\n            if ((a->valuestring == NULL) || (b->valuestring == NULL))\n            {\n                return false;\n            }\n            if (strcmp(a->valuestring, b->valuestring) == 0)\n            {\n                return true;\n            }\n\n            return false;\n\n        case cJSON_Array:\n        {\n            cJSON *a_element = a->child;\n            cJSON *b_element = b->child;\n\n            for (; (a_element != NULL) && (b_element != NULL);)\n            {\n                if (!cJSON_Compare(a_element, b_element, case_sensitive))\n                {\n                    return false;\n                }\n\n                a_element = a_element->next;\n                b_element = b_element->next;\n            }\n\n            /* one of the arrays is longer than the other */\n            if (a_element != b_element) {\n                return false;\n            }\n\n            return true;\n        }\n\n        case cJSON_Object:\n        {\n            cJSON *a_element = NULL;\n            cJSON *b_element = NULL;\n            cJSON_ArrayForEach(a_element, a)\n            {\n                /* TODO This has O(n^2) runtime, which is horrible! */\n                b_element = get_object_item(b, a_element->string, case_sensitive);\n                if (b_element == NULL)\n                {\n                    return false;\n                }\n\n                if (!cJSON_Compare(a_element, b_element, case_sensitive))\n                {\n                    return false;\n                }\n            }\n\n            /* doing this twice, once on a and b to prevent true comparison if a subset of b\n             * TODO: Do this the proper way, this is just a fix for now */\n            cJSON_ArrayForEach(b_element, b)\n            {\n                a_element = get_object_item(a, b_element->string, case_sensitive);\n                if (a_element == NULL)\n                {\n                    return false;\n                }\n\n                if (!cJSON_Compare(b_element, a_element, case_sensitive))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        default:\n            return false;\n    }\n}",
          "fn_code_pos": [
            [
              3019,
              25
            ],
            [
              3142,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_Compare",
            "parameters": {
              "a": "cJSON",
              "b": "cJSON",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_ArrayForEach(a_element, a)\n            {\n                /* TODO This has O(n^2) runtime, which is horrible! */\n                b_element = get_object_item(b, a_element->string, case_sensitive);\n                if (b_element == NULL)\n                {\n                    return false;\n                }\n\n                if (!cJSON_Compare(a_element, b_element, case_sensitive))\n                {\n                    return false;\n                }\n            }",
          "fn_code_pos": [
            [
              3105,
              12
            ],
            [
              3118,
              13
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ArrayForEach",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_ArrayForEach(b_element, b)\n            {\n                a_element = get_object_item(a, b_element->string, case_sensitive);\n                if (a_element == NULL)\n                {\n                    return false;\n                }\n\n                if (!cJSON_Compare(b_element, a_element, case_sensitive))\n                {\n                    return false;\n                }\n            }",
          "fn_code_pos": [
            [
              3122,
              12
            ],
            [
              3134,
              13
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ArrayForEach",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_malloc(size_t size)\n{\n    return global_hooks.allocate(size);\n}",
          "fn_code_pos": [
            [
              3144,
              21
            ],
            [
              3147,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_malloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_free(void *object)\n{\n    global_hooks.deallocate(object);\n    object = NULL;\n}",
          "fn_code_pos": [
            [
              3149,
              19
            ],
            [
              3153,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_free",
            "parameters": {
              "object": "void"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "CJSON_PUBLIC(const char *)",
          "fn_dec_pos": [
            [
              93,
              0
            ],
            [
              93,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(char *)",
          "fn_dec_pos": [
            [
              98,
              0
            ],
            [
              98,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(double)",
          "fn_dec_pos": [
            [
              108,
              0
            ],
            [
              108,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(const char*)",
          "fn_dec_pos": [
            [
              123,
              0
            ],
            [
              123,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "(CJSON_CDECL *allocate)(size_t size)",
          "fn_dec_pos": [
            [
              157,
              10
            ],
            [
              157,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(CJSON_CDECL *deallocate)(void *pointer)",
          "fn_dec_pos": [
            [
              158,
              9
            ],
            [
              158,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "pointer": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(CJSON_CDECL *reallocate)(void *pointer, size_t size)",
          "fn_dec_pos": [
            [
              159,
              10
            ],
            [
              159,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "pointer": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_CDECL internal_malloc(size_t size)",
          "fn_dec_pos": [
            [
              164,
              14
            ],
            [
              164,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL internal_malloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_CDECL internal_realloc(void *pointer, size_t size)",
          "fn_dec_pos": [
            [
              172,
              14
            ],
            [
              172,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL internal_realloc",
            "parameters": {
              "pointer": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)",
          "fn_dec_pos": [
            [
              187,
              22
            ],
            [
              187,
              99
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_strdup",
            "parameters": {
              "string": "unsigned char",
              "hooks": "internal_hooks"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              208,
              0
            ],
            [
              208,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_New_Item(const internal_hooks * const hooks)",
          "fn_dec_pos": [
            [
              240,
              14
            ],
            [
              240,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_New_Item",
            "parameters": {
              "hooks": "internal_hooks"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              252,
              0
            ],
            [
              252,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(double)",
          "fn_dec_pos": [
            [
              383,
              0
            ],
            [
              383,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(char*)",
          "fn_dec_pos": [
            [
              402,
              0
            ],
            [
              402,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ensure(printbuffer * const p, size_t needed)",
          "fn_dec_pos": [
            [
              457,
              22
            ],
            [
              457,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ensure",
            "parameters": {
              "p": "printbuffer",
              "needed": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "parse_value(cJSON * const item, parse_buffer * const input_buffer)",
          "fn_dec_pos": [
            [
              1049,
              18
            ],
            [
              1049,
              84
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_value",
            "parameters": {
              "item": "cJSON",
              "input_buffer": "parse_buffer"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "print_value(const cJSON * const item, printbuffer * const output_buffer)",
          "fn_dec_pos": [
            [
              1050,
              18
            ],
            [
              1050,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_value",
            "parameters": {
              "item": "cJSON",
              "output_buffer": "printbuffer"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "parse_array(cJSON * const item, parse_buffer * const input_buffer)",
          "fn_dec_pos": [
            [
              1051,
              18
            ],
            [
              1051,
              84
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_array",
            "parameters": {
              "item": "cJSON",
              "input_buffer": "parse_buffer"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "print_array(const cJSON * const item, printbuffer * const output_buffer)",
          "fn_dec_pos": [
            [
              1052,
              18
            ],
            [
              1052,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_array",
            "parameters": {
              "item": "cJSON",
              "output_buffer": "printbuffer"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "parse_object(cJSON * const item, parse_buffer * const input_buffer)",
          "fn_dec_pos": [
            [
              1053,
              18
            ],
            [
              1053,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_object",
            "parameters": {
              "item": "cJSON",
              "input_buffer": "parse_buffer"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "print_object(const cJSON * const item, printbuffer * const output_buffer)",
          "fn_dec_pos": [
            [
              1054,
              18
            ],
            [
              1054,
              91
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_object",
            "parameters": {
              "item": "cJSON",
              "output_buffer": "printbuffer"
            },
            "return_type": "cJSON_bool"
          }
        },
        {
          "fn_code": "buffer_skip_whitespace(parse_buffer * const buffer)",
          "fn_dec_pos": [
            [
              1057,
              21
            ],
            [
              1057,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "buffer_skip_whitespace",
            "parameters": {
              "buffer": "parse_buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "skip_utf8_bom(parse_buffer * const buffer)",
          "fn_dec_pos": [
            [
              1083,
              21
            ],
            [
              1083,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "skip_utf8_bom",
            "parameters": {
              "buffer": "parse_buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              1098,
              0
            ],
            [
              1098,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              1114,
              0
            ],
            [
              1114,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              1194,
              0
            ],
            [
              1194,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              1199,
              0
            ],
            [
              1199,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)",
          "fn_dec_pos": [
            [
              1206,
              22
            ],
            [
              1206,
              108
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print",
            "parameters": {
              "item": "cJSON",
              "format": "cJSON_bool",
              "hooks": "internal_hooks"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(char *)",
          "fn_dec_pos": [
            [
              1274,
              0
            ],
            [
              1274,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(char *)",
          "fn_dec_pos": [
            [
              1279,
              0
            ],
            [
              1279,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(char *)",
          "fn_dec_pos": [
            [
              1284,
              0
            ],
            [
              1284,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(int)",
          "fn_dec_pos": [
            [
              1856,
              0
            ],
            [
              1856,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "get_array_item(const cJSON *array, size_t index)",
          "fn_dec_pos": [
            [
              1879,
              14
            ],
            [
              1879,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_array_item",
            "parameters": {
              "array": "cJSON",
              "index": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              1898,
              0
            ],
            [
              1898,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)",
          "fn_dec_pos": [
            [
              1908,
              14
            ],
            [
              1908,
              115
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_object_item",
            "parameters": {
              "object": "cJSON",
              "name": "char",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              1940,
              0
            ],
            [
              1940,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              1945,
              0
            ],
            [
              1945,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "create_reference(const cJSON *item, const internal_hooks * const hooks)",
          "fn_dec_pos": [
            [
              1963,
              14
            ],
            [
              1963,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "create_reference",
            "parameters": {
              "item": "cJSON",
              "hooks": "internal_hooks"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cast_away_const(const void* string)",
          "fn_dec_pos": [
            [
              2030,
              13
            ],
            [
              2030,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cast_away_const",
            "parameters": {
              "string": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON*)",
          "fn_dec_pos": [
            [
              2107,
              0
            ],
            [
              2107,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON*)",
          "fn_dec_pos": [
            [
              2119,
              0
            ],
            [
              2119,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON*)",
          "fn_dec_pos": [
            [
              2131,
              0
            ],
            [
              2131,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON*)",
          "fn_dec_pos": [
            [
              2143,
              0
            ],
            [
              2143,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON*)",
          "fn_dec_pos": [
            [
              2155,
              0
            ],
            [
              2155,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON*)",
          "fn_dec_pos": [
            [
              2167,
              0
            ],
            [
              2167,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON*)",
          "fn_dec_pos": [
            [
              2179,
              0
            ],
            [
              2179,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON*)",
          "fn_dec_pos": [
            [
              2191,
              0
            ],
            [
              2191,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON*)",
          "fn_dec_pos": [
            [
              2203,
              0
            ],
            [
              2203,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2215,
              0
            ],
            [
              2215,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2251,
              0
            ],
            [
              2251,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              2261,
              0
            ],
            [
              2261,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2266,
              0
            ],
            [
              2266,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2273,
              0
            ],
            [
              2273,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              2280,
              0
            ],
            [
              2280,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              2285,
              0
            ],
            [
              2285,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2418,
              0
            ],
            [
              2418,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2429,
              0
            ],
            [
              2429,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2440,
              0
            ],
            [
              2440,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2451,
              0
            ],
            [
              2451,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2462,
              0
            ],
            [
              2462,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2488,
              0
            ],
            [
              2488,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2505,
              0
            ],
            [
              2505,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2517,
              0
            ],
            [
              2517,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2528,
              0
            ],
            [
              2528,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2538,
              0
            ],
            [
              2538,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2555,
              0
            ],
            [
              2555,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2566,
              0
            ],
            [
              2566,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2578,
              0
            ],
            [
              2578,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2618,
              0
            ],
            [
              2618,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2658,
              0
            ],
            [
              2658,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2698,
              0
            ],
            [
              2698,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              2739,
              0
            ],
            [
              2739,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              2871,
              0
            ],
            [
              2871,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void *)",
          "fn_dec_pos": [
            [
              3144,
              0
            ],
            [
              3144,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              3149,
              0
            ],
            [
              3149,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n    const unsigned char *json;\n    size_t position;\n} error;",
          {
            "unsigned char": "const",
            "position": "size_t"
          },
          "error",
          [
            87,
            0
          ],
          [
            90,
            8
          ]
        ],
        [
          "typedef struct internal_hooks\n{\n    void *(CJSON_CDECL *allocate)(size_t size);\n    void (CJSON_CDECL *deallocate)(void *pointer);\n    void *(CJSON_CDECL *reallocate)(void *pointer, size_t size);\n} internal_hooks;",
          {
            "*(CJSON_CDECL *allocate)(size_t size)": "void",
            "(CJSON_CDECL *deallocate)(void *pointer)": "void",
            "*(CJSON_CDECL *reallocate)(void *pointer, size_t size)": "void"
          },
          "internal_hooks",
          [
            155,
            0
          ],
          [
            160,
            17
          ]
        ],
        [
          "typedef struct\n{\n    const unsigned char *content;\n    size_t length;\n    size_t offset;\n    size_t depth; /* How deeply nested (in arrays/objects) is the input at the current offset. */\n    internal_hooks hooks;\n} parse_buffer;",
          {
            "unsigned char": "const",
            "length": "size_t",
            "offset": "size_t",
            "depth": "size_t",
            "hooks": "internal_hooks"
          },
          "parse_buffer",
          [
            288,
            0
          ],
          [
            295,
            15
          ]
        ],
        [
          "typedef struct\n{\n    unsigned char *buffer;\n    size_t length;\n    size_t offset;\n    size_t depth; /* current nesting depth (for formatted printing) */\n    cJSON_bool noalloc;\n    cJSON_bool format; /* is this print a formatted print */\n    internal_hooks hooks;\n} printbuffer;",
          {
            "*buffer": "unsigned char",
            "length": "size_t",
            "offset": "size_t",
            "depth": "size_t",
            "noalloc": "cJSON_bool",
            "format": "cJSON_bool",
            "hooks": "internal_hooks"
          },
          "printbuffer",
          [
            445,
            0
          ],
          [
            454,
            14
          ]
        ],
        [
          "typedef struct {\n    const unsigned char *json;\n    size_t position;\n} error;",
          {
            "unsigned char": "const",
            "position": "size_t"
          },
          "error",
          [
            87,
            0
          ],
          [
            90,
            8
          ]
        ],
        [
          "typedef struct internal_hooks\n{\n    void *(CJSON_CDECL *allocate)(size_t size);\n    void (CJSON_CDECL *deallocate)(void *pointer);\n    void *(CJSON_CDECL *reallocate)(void *pointer, size_t size);\n} internal_hooks;",
          {
            "*(CJSON_CDECL *allocate)(size_t size)": "void",
            "(CJSON_CDECL *deallocate)(void *pointer)": "void",
            "*(CJSON_CDECL *reallocate)(void *pointer, size_t size)": "void"
          },
          "internal_hooks",
          [
            155,
            0
          ],
          [
            160,
            17
          ]
        ],
        [
          "struct lconv",
          {},
          "",
          [
            281,
            4
          ],
          [
            281,
            16
          ]
        ],
        [
          "typedef struct\n{\n    const unsigned char *content;\n    size_t length;\n    size_t offset;\n    size_t depth; /* How deeply nested (in arrays/objects) is the input at the current offset. */\n    internal_hooks hooks;\n} parse_buffer;",
          {
            "unsigned char": "const",
            "length": "size_t",
            "offset": "size_t",
            "depth": "size_t",
            "hooks": "internal_hooks"
          },
          "parse_buffer",
          [
            288,
            0
          ],
          [
            295,
            15
          ]
        ],
        [
          "typedef struct\n{\n    unsigned char *buffer;\n    size_t length;\n    size_t offset;\n    size_t depth; /* current nesting depth (for formatted printing) */\n    cJSON_bool noalloc;\n    cJSON_bool format; /* is this print a formatted print */\n    internal_hooks hooks;\n} printbuffer;",
          {
            "*buffer": "unsigned char",
            "length": "size_t",
            "offset": "size_t",
            "depth": "size_t",
            "noalloc": "cJSON_bool",
            "format": "cJSON_bool",
            "hooks": "internal_hooks"
          },
          "printbuffer",
          [
            445,
            0
          ],
          [
            454,
            14
          ]
        ]
      ],
      "include_list": [
        [
          "#include <string.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <float.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <locale.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include \"cJSON.h\"\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/print_string.c": {
      "fn_def_list": [
        {
          "fn_code": "static void assert_print_string(const char *expected, const char *input)\n{\n    unsigned char printed[1024];\n    printbuffer buffer = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };\n    buffer.buffer = printed;\n    buffer.length = sizeof(printed);\n    buffer.offset = 0;\n    buffer.noalloc = true;\n    buffer.hooks = global_hooks;\n\n    TEST_ASSERT_TRUE_MESSAGE(print_string_ptr((const unsigned char*)input, &buffer), \"Failed to print string.\");\n    TEST_ASSERT_EQUAL_STRING_MESSAGE(expected, printed, \"The printed string isn't as expected.\");\n}",
          "fn_code_pos": [
            [
              26,
              0
            ],
            [
              38,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "assert_print_string",
            "parameters": {
              "expected": "char",
              "input": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_string_should_print_empty_strings(void)\n{\n    assert_print_string(\"\\\"\\\"\", \"\");\n    assert_print_string(\"\\\"\\\"\", NULL);\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              44,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_string_should_print_empty_strings",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_string_should_print_ascii(void)\n{\n    char ascii[0x7F];\n    size_t i = 1;\n\n    /* create ascii table */\n    for (i = 1; i < 0x7F; i++)\n    {\n        ascii[i-1] = (char)i;\n    }\n    ascii[0x7F-1] = '\\0';\n\n    assert_print_string(\"\\\"\\\\u0001\\\\u0002\\\\u0003\\\\u0004\\\\u0005\\\\u0006\\\\u0007\\\\b\\\\t\\\\n\\\\u000b\\\\f\\\\r\\\\u000e\\\\u000f\\\\u0010\\\\u0011\\\\u0012\\\\u0013\\\\u0014\\\\u0015\\\\u0016\\\\u0017\\\\u0018\\\\u0019\\\\u001a\\\\u001b\\\\u001c\\\\u001d\\\\u001e\\\\u001f !\\\\\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\\"\",\n            ascii);\n}",
          "fn_code_pos": [
            [
              46,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_string_should_print_ascii",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_string_should_print_utf8(void)\n{\n    assert_print_string(\"\\\"\u00fc\u732b\u6155\\\"\", \"\u00fc\u732b\u6155\");\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_string_should_print_utf8",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int CJSON_CDECL main(void)\n{\n    /* initialize cJSON item */\n    UNITY_BEGIN();\n\n    RUN_TEST(print_string_should_print_empty_strings);\n    RUN_TEST(print_string_should_print_ascii);\n    RUN_TEST(print_string_should_print_utf8);\n\n    return UNITY_END();\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              77,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"unity/examples/unity_config.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"unity/src/unity.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"common.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/parse_string.c": {
      "fn_def_list": [
        {
          "fn_code": "static void assert_is_string(cJSON *string_item)\n{\n    TEST_ASSERT_NOT_NULL_MESSAGE(string_item, \"Item is NULL.\");\n\n    assert_not_in_list(string_item);\n    assert_has_no_child(string_item);\n    assert_has_type(string_item, cJSON_String);\n    assert_has_no_reference(string_item);\n    assert_has_no_const_string(string_item);\n    assert_has_valuestring(string_item);\n    assert_has_no_string(string_item);\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              43,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "assert_is_string",
            "parameters": {
              "string_item": "cJSON"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void assert_parse_string(const char *string, const char *expected)\n{\n    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };\n    buffer.content = (const unsigned char*)string;\n    buffer.length = strlen(string) + sizeof(\"\");\n    buffer.hooks = global_hooks;\n\n    TEST_ASSERT_TRUE_MESSAGE(parse_string(item, &buffer), \"Couldn't parse string.\");\n    assert_is_string(item);\n    TEST_ASSERT_EQUAL_STRING_MESSAGE(expected, item->valuestring, \"The parsed result isn't as expected.\");\n    global_hooks.deallocate(item->valuestring);\n    item->valuestring = NULL;\n}",
          "fn_code_pos": [
            [
              45,
              0
            ],
            [
              57,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "assert_parse_string",
            "parameters": {
              "string": "char",
              "expected": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void assert_not_parse_string(const char * const string)\n{\n    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };\n    buffer.content = (const unsigned char*)string;\n    buffer.length = strlen(string) + sizeof(\"\");\n    buffer.hooks = global_hooks;\n\n    TEST_ASSERT_FALSE_MESSAGE(parse_string(item, &buffer), \"Malformed string should not be accepted.\");\n    assert_is_invalid(item);\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              68,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "assert_not_parse_string",
            "parameters": {
              "string": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_string_should_parse_strings(void)\n{\n    assert_parse_string(\"\\\"\\\"\", \"\");\n    assert_parse_string(\n        \"\\\" !\\\\\\\"#$%&'()*+,-./\\\\/0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\\\\\]^_'abcdefghijklmnopqrstuvwxyz{|}~\\\"\",\n        \" !\\\"#$%&'()*+,-.//0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_'abcdefghijklmnopqrstuvwxyz{|}~\");\n    assert_parse_string(\n        \"\\\"\\\\\\\"\\\\\\\\\\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u20AC\\\\u732b\\\"\",\n        \"\\\"\\\\/\\b\\f\\n\\r\\t\u20ac\u732b\");\n    reset(item);\n    assert_parse_string(\"\\\"\\b\\f\\n\\r\\t\\\"\", \"\\b\\f\\n\\r\\t\");\n    reset(item);\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_string_should_parse_strings",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_string_should_parse_utf16_surrogate_pairs(void)\n{\n    assert_parse_string(\"\\\"\\\\uD83D\\\\udc31\\\"\", \"\ud83d\udc31\");\n    reset(item);\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              90,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_string_should_parse_utf16_surrogate_pairs",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_string_should_not_parse_non_strings(void)\n{\n    assert_not_parse_string(\"this\\\" is not a string\\\"\");\n    reset(item);\n    assert_not_parse_string(\"\");\n    reset(item);\n}",
          "fn_code_pos": [
            [
              92,
              0
            ],
            [
              98,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_string_should_not_parse_non_strings",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_string_should_not_parse_invalid_backslash(void)\n{\n    assert_not_parse_string(\"Abcdef\\\\123\");\n    reset(item);\n    assert_not_parse_string(\"Abcdef\\\\e23\");\n    reset(item);\n}",
          "fn_code_pos": [
            [
              100,
              0
            ],
            [
              106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_string_should_not_parse_invalid_backslash",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_string_should_not_overflow_with_closing_backslash(void)\n{\n    assert_not_parse_string(\"\\\"000000000000000000\\\\\");\n    reset(item);\n}",
          "fn_code_pos": [
            [
              108,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_string_should_not_overflow_with_closing_backslash",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_string_should_parse_bug_94(void)\n{\n    const char string[] = \"\\\"~!@\\\\\\\\#$%^&*()\\\\\\\\\\\\\\\\-\\\\\\\\+{}[]:\\\\\\\\;\\\\\\\\\\\\\\\"\\\\\\\\<\\\\\\\\>?/.,DC=ad,DC=com\\\"\";\n    assert_parse_string(string, \"~!@\\\\#$%^&*()\\\\\\\\-\\\\+{}[]:\\\\;\\\\\\\"\\\\<\\\\>?/.,DC=ad,DC=com\");\n    reset(item);\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_string_should_parse_bug_94",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int CJSON_CDECL main(void)\n{\n    /* initialize cJSON item and error pointer */\n    memset(item, 0, sizeof(cJSON));\n\n    UNITY_BEGIN();\n    RUN_TEST(parse_string_should_parse_strings);\n    RUN_TEST(parse_string_should_parse_utf16_surrogate_pairs);\n    RUN_TEST(parse_string_should_not_parse_non_strings);\n    RUN_TEST(parse_string_should_not_parse_invalid_backslash);\n    RUN_TEST(parse_string_should_parse_bug_94);\n    RUN_TEST(parse_string_should_not_overflow_with_closing_backslash);\n    return UNITY_END();\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              134,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"unity/examples/unity_config.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"unity/src/unity.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"common.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/print_object.c": {
      "fn_def_list": [
        {
          "fn_code": "static void assert_print_object(const char * const expected, const char * const input)\n{\n    unsigned char printed_unformatted[1024];\n    unsigned char printed_formatted[1024];\n\n    cJSON item[1];\n\n    printbuffer formatted_buffer = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };\n    printbuffer unformatted_buffer = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };\n    parse_buffer parsebuffer = { 0, 0, 0, 0, { 0, 0, 0 } };\n\n    /* buffer for parsing */\n    parsebuffer.content = (const unsigned char*)input;\n    parsebuffer.length = strlen(input) + sizeof(\"\");\n    parsebuffer.hooks = global_hooks;\n\n    /* buffer for formatted printing */\n    formatted_buffer.buffer = printed_formatted;\n    formatted_buffer.length = sizeof(printed_formatted);\n    formatted_buffer.offset = 0;\n    formatted_buffer.noalloc = true;\n    formatted_buffer.hooks = global_hooks;\n\n    /* buffer for unformatted printing */\n    unformatted_buffer.buffer = printed_unformatted;\n    unformatted_buffer.length = sizeof(printed_unformatted);\n    unformatted_buffer.offset = 0;\n    unformatted_buffer.noalloc = true;\n    unformatted_buffer.hooks = global_hooks;\n\n    memset(item, 0, sizeof(item));\n    TEST_ASSERT_TRUE_MESSAGE(parse_object(item, &parsebuffer), \"Failed to parse object.\");\n\n    unformatted_buffer.format = false;\n    TEST_ASSERT_TRUE_MESSAGE(print_object(item, &unformatted_buffer), \"Failed to print unformatted string.\");\n    TEST_ASSERT_EQUAL_STRING_MESSAGE(input, printed_unformatted, \"Unformatted object is not correct.\");\n\n    formatted_buffer.format = true;\n    TEST_ASSERT_TRUE_MESSAGE(print_object(item, &formatted_buffer), \"Failed to print formatted string.\");\n    TEST_ASSERT_EQUAL_STRING_MESSAGE(expected, printed_formatted, \"Formatted object is not correct.\");\n\n    reset(item);\n}",
          "fn_code_pos": [
            [
              26,
              0
            ],
            [
              68,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "assert_print_object",
            "parameters": {
              "expected": "char",
              "input": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_object_should_print_empty_objects(void)\n{\n    assert_print_object(\"{\\n}\", \"{}\");\n}",
          "fn_code_pos": [
            [
              70,
              0
            ],
            [
              73,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_object_should_print_empty_objects",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_object_should_print_objects_with_one_element(void)\n{\n\n    assert_print_object(\"{\\n\\t\\\"one\\\":\\t1\\n}\", \"{\\\"one\\\":1}\");\n    assert_print_object(\"{\\n\\t\\\"hello\\\":\\t\\\"world!\\\"\\n}\", \"{\\\"hello\\\":\\\"world!\\\"}\");\n    assert_print_object(\"{\\n\\t\\\"array\\\":\\t[]\\n}\", \"{\\\"array\\\":[]}\");\n    assert_print_object(\"{\\n\\t\\\"null\\\":\\tnull\\n}\", \"{\\\"null\\\":null}\");\n}",
          "fn_code_pos": [
            [
              75,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_object_should_print_objects_with_one_element",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_object_should_print_objects_with_multiple_elements(void)\n{\n    assert_print_object(\"{\\n\\t\\\"one\\\":\\t1,\\n\\t\\\"two\\\":\\t2,\\n\\t\\\"three\\\":\\t3\\n}\", \"{\\\"one\\\":1,\\\"two\\\":2,\\\"three\\\":3}\");\n    assert_print_object(\"{\\n\\t\\\"one\\\":\\t1,\\n\\t\\\"NULL\\\":\\tnull,\\n\\t\\\"TRUE\\\":\\ttrue,\\n\\t\\\"FALSE\\\":\\tfalse,\\n\\t\\\"array\\\":\\t[],\\n\\t\\\"world\\\":\\t\\\"hello\\\",\\n\\t\\\"object\\\":\\t{\\n\\t}\\n}\", \"{\\\"one\\\":1,\\\"NULL\\\":null,\\\"TRUE\\\":true,\\\"FALSE\\\":false,\\\"array\\\":[],\\\"world\\\":\\\"hello\\\",\\\"object\\\":{}}\");\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              88,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_object_should_print_objects_with_multiple_elements",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int CJSON_CDECL main(void)\n{\n    /* initialize cJSON item */\n    UNITY_BEGIN();\n\n    RUN_TEST(print_object_should_print_empty_objects);\n    RUN_TEST(print_object_should_print_objects_with_one_element);\n    RUN_TEST(print_object_should_print_objects_with_multiple_elements);\n\n    return UNITY_END();\n}",
          "fn_code_pos": [
            [
              90,
              0
            ],
            [
              100,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"unity/examples/unity_config.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"unity/src/unity.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"common.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/parse_examples.c": {
      "fn_def_list": [
        {
          "fn_code": "static cJSON *parse_file(const char *filename)\n{\n    cJSON *parsed = NULL;\n    char *content = read_file(filename);\n\n    parsed = cJSON_Parse(content);\n\n    if (content != NULL)\n    {\n        free(content);\n    }\n\n    return parsed;\n}",
          "fn_code_pos": [
            [
              30,
              0
            ],
            [
              43,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_file",
            "parameters": {
              "filename": "char"
            },
            "return_type": "cJSON"
          }
        },
        {
          "fn_code": "static void do_test(const char *test_name)\n{\n    char *expected = NULL;\n    char *actual = NULL;\n    cJSON *tree = NULL;\n\n    size_t test_name_length = 0;\n    /* path of the test input */\n    char *test_path = NULL;\n    /* path of the expected output */\n    char *expected_path = NULL;\n\n    test_name_length = strlen(test_name);\n\n    /* allocate file paths */\n#define TEST_DIR_PATH \"inputs/\"\n    test_path = (char*)malloc(sizeof(TEST_DIR_PATH) + test_name_length);\n    TEST_ASSERT_NOT_NULL_MESSAGE(test_path, \"Failed to allocate test_path buffer.\");\n    expected_path = (char*)malloc(sizeof(TEST_DIR_PATH) + test_name_length + sizeof(\".expected\"));\n    TEST_ASSERT_NOT_NULL_MESSAGE(expected_path, \"Failed to allocate expected_path buffer.\");\n\n    /* create file paths */\n    sprintf(test_path, TEST_DIR_PATH\"%s\", test_name);\n    sprintf(expected_path, TEST_DIR_PATH\"%s.expected\", test_name);\n\n    /* read expected output */\n    expected = read_file(expected_path);\n    TEST_ASSERT_NOT_NULL_MESSAGE(expected, \"Failed to read expected output.\");\n\n    /* read and parse test */\n    tree = parse_file(test_path);\n    TEST_ASSERT_NOT_NULL_MESSAGE(tree, \"Failed to read of parse test.\");\n\n    /* print the parsed tree */\n    actual = cJSON_Print(tree);\n    TEST_ASSERT_NOT_NULL_MESSAGE(actual, \"Failed to print tree back to JSON.\");\n\n\n    TEST_ASSERT_EQUAL_STRING(expected, actual);\n\n    /* cleanup resources */\n    if (expected != NULL)\n    {\n        free(expected);\n    }\n    if (tree != NULL)\n    {\n        cJSON_Delete(tree);\n    }\n    if (actual != NULL)\n    {\n        free(actual);\n    }\n    if (test_path != NULL)\n    {\n        free(test_path);\n    }\n    if (expected_path != NULL)\n    {\n        free(expected_path);\n    }\n}",
          "fn_code_pos": [
            [
              45,
              0
            ],
            [
              106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "do_test",
            "parameters": {
              "test_name": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void file_test1_should_be_parsed_and_printed(void)\n{\n    do_test(\"test1\");\n}",
          "fn_code_pos": [
            [
              108,
              0
            ],
            [
              111,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_test1_should_be_parsed_and_printed",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void file_test2_should_be_parsed_and_printed(void)\n{\n    do_test(\"test2\");\n}",
          "fn_code_pos": [
            [
              113,
              0
            ],
            [
              116,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_test2_should_be_parsed_and_printed",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void file_test3_should_be_parsed_and_printed(void)\n{\n    do_test(\"test3\");\n}",
          "fn_code_pos": [
            [
              118,
              0
            ],
            [
              121,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_test3_should_be_parsed_and_printed",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void file_test4_should_be_parsed_and_printed(void)\n{\n    do_test(\"test4\");\n}",
          "fn_code_pos": [
            [
              123,
              0
            ],
            [
              126,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_test4_should_be_parsed_and_printed",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void file_test5_should_be_parsed_and_printed(void)\n{\n    do_test(\"test5\");\n}",
          "fn_code_pos": [
            [
              128,
              0
            ],
            [
              131,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_test5_should_be_parsed_and_printed",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void file_test6_should_not_be_parsed(void)\n{\n    char *test6 = NULL;\n    cJSON *tree = NULL;\n\n    test6 = read_file(\"inputs/test6\");\n    TEST_ASSERT_NOT_NULL_MESSAGE(test6, \"Failed to read test6 data.\");\n\n    tree = cJSON_Parse(test6);\n    TEST_ASSERT_NULL_MESSAGE(tree, \"Should fail to parse what is not JSON.\");\n\n    TEST_ASSERT_EQUAL_PTR_MESSAGE(test6, cJSON_GetErrorPtr(), \"Error pointer is incorrect.\");\n\n    if (test6 != NULL)\n    {\n        free(test6);\n    }\n    if (tree != NULL)\n    {\n        cJSON_Delete(tree);\n    }\n}",
          "fn_code_pos": [
            [
              133,
              0
            ],
            [
              154,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_test6_should_not_be_parsed",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void file_test7_should_be_parsed_and_printed(void)\n{\n    do_test(\"test7\");\n}",
          "fn_code_pos": [
            [
              156,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_test7_should_be_parsed_and_printed",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void file_test8_should_be_parsed_and_printed(void)\n{\n    do_test(\"test8\");\n}",
          "fn_code_pos": [
            [
              161,
              0
            ],
            [
              164,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_test8_should_be_parsed_and_printed",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void file_test9_should_be_parsed_and_printed(void)\n{\n    do_test(\"test9\");\n}",
          "fn_code_pos": [
            [
              166,
              0
            ],
            [
              169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_test9_should_be_parsed_and_printed",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void file_test10_should_be_parsed_and_printed(void)\n{\n    do_test(\"test10\");\n}",
          "fn_code_pos": [
            [
              171,
              0
            ],
            [
              174,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_test10_should_be_parsed_and_printed",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void file_test11_should_be_parsed_and_printed(void)\n{\n    do_test(\"test11\");\n}",
          "fn_code_pos": [
            [
              176,
              0
            ],
            [
              179,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_test11_should_be_parsed_and_printed",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void test12_should_not_be_parsed(void)\n{\n    const char *test12 = \"{ \\\"name\\\": \";\n    cJSON *tree = NULL;\n\n    tree = cJSON_Parse(test12);\n    TEST_ASSERT_NULL_MESSAGE(tree, \"Should fail to parse incomplete JSON.\");\n\n    TEST_ASSERT_EQUAL_PTR_MESSAGE(test12 + strlen(test12), cJSON_GetErrorPtr(), \"Error pointer is incorrect.\");\n\n    if (tree != NULL)\n    {\n        cJSON_Delete(tree);\n    }\n}",
          "fn_code_pos": [
            [
              181,
              0
            ],
            [
              195,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "test12_should_not_be_parsed",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void test13_should_be_parsed_without_null_termination(void)\n{\n    cJSON *tree = NULL;\n    const char test_13[] = \"{\" \\\n                                \"\\\"Image\\\":{\" \\\n                                    \"\\\"Width\\\":800,\" \\\n                                    \"\\\"Height\\\":600,\" \\\n                                    \"\\\"Title\\\":\\\"Viewfrom15thFloor\\\",\" \\\n                                    \"\\\"Thumbnail\\\":{\" \\\n                                        \"\\\"Url\\\":\\\"http:/*www.example.com/image/481989943\\\",\" \\\n                                        \"\\\"Height\\\":125,\" \\\n                                        \"\\\"Width\\\":\\\"100\\\"\" \\\n                                    \"},\" \\\n                                    \"\\\"IDs\\\":[116,943,234,38793]\" \\\n                                \"}\" \\\n                            \"}\";\n\n    char test_13_wo_null[sizeof(test_13) - 1];\n    memcpy(test_13_wo_null, test_13, sizeof(test_13) - 1);\n\n    tree = cJSON_ParseWithLength(test_13_wo_null, sizeof(test_13) - 1);\n    TEST_ASSERT_NOT_NULL_MESSAGE(tree, \"Failed to parse valid json.\");\n\n    if (tree != NULL)\n    {\n        cJSON_Delete(tree);\n    }\n}",
          "fn_code_pos": [
            [
              197,
              0
            ],
            [
              224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "test13_should_be_parsed_without_null_termination",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void test14_should_not_be_parsed(void)\n{\n    cJSON *tree = NULL;\n    const char test_14[] = \"{\" \\\n                                \"\\\"Image\\\":{\" \\\n                                    \"\\\"Width\\\":800,\" \\\n                                    \"\\\"Height\\\":600,\" \\\n                                    \"\\\"Title\\\":\\\"Viewfrom15thFloor\\\",\" \\\n                                    \"\\\"Thumbnail\\\":{\" \\\n                                        \"\\\"Url\\\":\\\"http:/*www.example.com/image/481989943\\\",\" \\\n                                        \"\\\"Height\\\":125,\" \\\n                                        \"\\\"Width\\\":\\\"100\\\"\" \\\n                                    \"},\" \\\n                                    \"\\\"IDs\\\":[116,943,234,38793]\" \\\n                                \"}\" \\\n                            \"}\";\n\n    tree = cJSON_ParseWithLength(test_14, sizeof(test_14) - 2);\n    TEST_ASSERT_NULL_MESSAGE(tree, \"Should not continue after buffer_length is reached.\");\n\n    if (tree != NULL)\n    {\n        cJSON_Delete(tree);\n    }\n}",
          "fn_code_pos": [
            [
              226,
              0
            ],
            [
              250,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "test14_should_not_be_parsed",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void test15_should_not_heap_buffer_overflow(void)\n{\n    const char *strings[] = {\n        \"{\\\"1\\\":1,\",\n        \"{\\\"1\\\":1, \",\n    };\n\n    size_t i;\n\n    for (i = 0; i < sizeof(strings) / sizeof(strings[0]); i+=1)\n    {\n        const char *json_string = strings[i];\n        size_t len = strlen(json_string);\n        cJSON *json = NULL;\n\n        char *exact_size_heap = (char*)malloc(len);\n        TEST_ASSERT_NOT_NULL(exact_size_heap);\n\n        memcpy(exact_size_heap, json_string, len);\n        json = cJSON_ParseWithLength(exact_size_heap, len);\n\n        cJSON_Delete(json);\n        free(exact_size_heap);\n    }\n}",
          "fn_code_pos": [
            [
              253,
              0
            ],
            [
              277,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "test15_should_not_heap_buffer_overflow",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int CJSON_CDECL main(void)\n{\n    UNITY_BEGIN();\n    RUN_TEST(file_test1_should_be_parsed_and_printed);\n    RUN_TEST(file_test2_should_be_parsed_and_printed);\n    RUN_TEST(file_test3_should_be_parsed_and_printed);\n    RUN_TEST(file_test4_should_be_parsed_and_printed);\n    RUN_TEST(file_test5_should_be_parsed_and_printed);\n    RUN_TEST(file_test6_should_not_be_parsed);\n    RUN_TEST(file_test7_should_be_parsed_and_printed);\n    RUN_TEST(file_test8_should_be_parsed_and_printed);\n    RUN_TEST(file_test9_should_be_parsed_and_printed);\n    RUN_TEST(file_test10_should_be_parsed_and_printed);\n    RUN_TEST(file_test11_should_be_parsed_and_printed);\n    RUN_TEST(test12_should_not_be_parsed);\n    RUN_TEST(test13_should_be_parsed_without_null_termination);\n    RUN_TEST(test14_should_not_be_parsed);\n    RUN_TEST(test15_should_not_heap_buffer_overflow);\n    return UNITY_END();\n}",
          "fn_code_pos": [
            [
              279,
              0
            ],
            [
              298,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "parse_file(const char *filename)",
          "fn_dec_pos": [
            [
              30,
              14
            ],
            [
              30,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_file",
            "parameters": {
              "filename": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"unity/examples/unity_config.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"unity/src/unity.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"common.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/parse_with_opts.c": {
      "fn_def_list": [
        {
          "fn_code": "static void parse_with_opts_should_handle_null(void)\n{\n    const char *error_pointer = NULL;\n    cJSON *item = NULL;\n    TEST_ASSERT_NULL_MESSAGE(cJSON_ParseWithOpts(NULL, &error_pointer, false), \"Failed to handle NULL input.\");\n    item = cJSON_ParseWithOpts(\"{}\", NULL, false);\n    TEST_ASSERT_NOT_NULL_MESSAGE(item, \"Failed to handle NULL error pointer.\");\n    cJSON_Delete(item);\n    TEST_ASSERT_NULL_MESSAGE(cJSON_ParseWithOpts(NULL, NULL, false), \"Failed to handle both NULL.\");\n    TEST_ASSERT_NULL_MESSAGE(cJSON_ParseWithOpts(\"{\", NULL, false), \"Failed to handle NULL error pointer with parse error.\");\n}",
          "fn_code_pos": [
            [
              26,
              0
            ],
            [
              36,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_with_opts_should_handle_null",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_with_opts_should_handle_empty_strings(void)\n{\n    const char empty_string[] = \"\";\n    const char *error_pointer = NULL;\n\n    TEST_ASSERT_NULL(cJSON_ParseWithOpts(empty_string, NULL, false));\n    TEST_ASSERT_EQUAL_PTR(empty_string, cJSON_GetErrorPtr());\n\n    TEST_ASSERT_NULL(cJSON_ParseWithOpts(empty_string, &error_pointer, false));\n    TEST_ASSERT_EQUAL_PTR(empty_string, error_pointer);\n    TEST_ASSERT_EQUAL_PTR(empty_string, cJSON_GetErrorPtr());\n}",
          "fn_code_pos": [
            [
              38,
              0
            ],
            [
              49,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_with_opts_should_handle_empty_strings",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_with_opts_should_handle_incomplete_json(void)\n{\n    const char json[] = \"{ \\\"name\\\": \";\n    const char *parse_end = NULL;\n\n    TEST_ASSERT_NULL(cJSON_ParseWithOpts(json, &parse_end, false));\n    TEST_ASSERT_EQUAL_PTR(json + strlen(json), parse_end);\n    TEST_ASSERT_EQUAL_PTR(json + strlen(json), cJSON_GetErrorPtr());\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              59,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_with_opts_should_handle_incomplete_json",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_with_opts_should_require_null_if_requested(void)\n{\n    cJSON *item = cJSON_ParseWithOpts(\"{}\", NULL, true);\n    TEST_ASSERT_NOT_NULL(item);\n    cJSON_Delete(item);\n    item = cJSON_ParseWithOpts(\"{} \\n\", NULL, true);\n    TEST_ASSERT_NOT_NULL(item);\n    cJSON_Delete(item);\n    TEST_ASSERT_NULL(cJSON_ParseWithOpts(\"{}x\", NULL, true));\n}",
          "fn_code_pos": [
            [
              61,
              0
            ],
            [
              70,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_with_opts_should_require_null_if_requested",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_with_opts_should_return_parse_end(void)\n{\n    const char json[] = \"[] empty array XD\";\n    const char *parse_end = NULL;\n\n    cJSON *item = cJSON_ParseWithOpts(json, &parse_end, false);\n    TEST_ASSERT_NOT_NULL(item);\n    TEST_ASSERT_EQUAL_PTR(json + 2, parse_end);\n    cJSON_Delete(item);\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              81,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_with_opts_should_return_parse_end",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_with_opts_should_parse_utf8_bom(void)\n{\n    cJSON *with_bom = NULL;\n    cJSON *without_bom = NULL;\n\n    with_bom = cJSON_ParseWithOpts(\"\\xEF\\xBB\\xBF{}\", NULL, true);\n    TEST_ASSERT_NOT_NULL(with_bom);\n    without_bom = cJSON_ParseWithOpts(\"{}\", NULL, true);\n    TEST_ASSERT_NOT_NULL(with_bom);\n\n    TEST_ASSERT_TRUE(cJSON_Compare(with_bom, without_bom, true));\n\n    cJSON_Delete(with_bom);\n    cJSON_Delete(without_bom);\n}",
          "fn_code_pos": [
            [
              83,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_with_opts_should_parse_utf8_bom",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int CJSON_CDECL main(void)\n{\n    UNITY_BEGIN();\n\n    RUN_TEST(parse_with_opts_should_handle_null);\n    RUN_TEST(parse_with_opts_should_handle_empty_strings);\n    RUN_TEST(parse_with_opts_should_handle_incomplete_json);\n    RUN_TEST(parse_with_opts_should_require_null_if_requested);\n    RUN_TEST(parse_with_opts_should_return_parse_end);\n    RUN_TEST(parse_with_opts_should_parse_utf8_bom);\n\n    return UNITY_END();\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              111,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"unity/examples/unity_config.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"unity/src/unity.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"common.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/print_array.c": {
      "fn_def_list": [
        {
          "fn_code": "static void assert_print_array(const char * const expected, const char * const input)\n{\n    unsigned char printed_unformatted[1024];\n    unsigned char printed_formatted[1024];\n\n    cJSON item[1];\n\n    printbuffer formatted_buffer = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };\n    printbuffer unformatted_buffer = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };\n\n    parse_buffer parsebuffer = { 0, 0, 0, 0, { 0, 0, 0 } };\n    parsebuffer.content = (const unsigned char*)input;\n    parsebuffer.length = strlen(input) + sizeof(\"\");\n    parsebuffer.hooks = global_hooks;\n\n    /* buffer for formatted printing */\n    formatted_buffer.buffer = printed_formatted;\n    formatted_buffer.length = sizeof(printed_formatted);\n    formatted_buffer.offset = 0;\n    formatted_buffer.noalloc = true;\n    formatted_buffer.hooks = global_hooks;\n\n    /* buffer for unformatted printing */\n    unformatted_buffer.buffer = printed_unformatted;\n    unformatted_buffer.length = sizeof(printed_unformatted);\n    unformatted_buffer.offset = 0;\n    unformatted_buffer.noalloc = true;\n    unformatted_buffer.hooks = global_hooks;\n\n    memset(item, 0, sizeof(item));\n    TEST_ASSERT_TRUE_MESSAGE(parse_array(item, &parsebuffer), \"Failed to parse array.\");\n\n    unformatted_buffer.format = false;\n    TEST_ASSERT_TRUE_MESSAGE(print_array(item, &unformatted_buffer), \"Failed to print unformatted string.\");\n    TEST_ASSERT_EQUAL_STRING_MESSAGE(input, printed_unformatted, \"Unformatted array is not correct.\");\n\n    formatted_buffer.format = true;\n    TEST_ASSERT_TRUE_MESSAGE(print_array(item, &formatted_buffer), \"Failed to print formatted string.\");\n    TEST_ASSERT_EQUAL_STRING_MESSAGE(expected, printed_formatted, \"Formatted array is not correct.\");\n\n    reset(item);\n}",
          "fn_code_pos": [
            [
              26,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "assert_print_array",
            "parameters": {
              "expected": "char",
              "input": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_array_should_print_empty_arrays(void)\n{\n    assert_print_array(\"[]\", \"[]\");\n}",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              72,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_array_should_print_empty_arrays",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_array_should_print_arrays_with_one_element(void)\n{\n\n    assert_print_array(\"[1]\", \"[1]\");\n    assert_print_array(\"[\\\"hello!\\\"]\", \"[\\\"hello!\\\"]\");\n    assert_print_array(\"[[]]\", \"[[]]\");\n    assert_print_array(\"[null]\", \"[null]\");\n}",
          "fn_code_pos": [
            [
              74,
              0
            ],
            [
              81,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_array_should_print_arrays_with_one_element",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_array_should_print_arrays_with_multiple_elements(void)\n{\n    assert_print_array(\"[1, 2, 3]\", \"[1,2,3]\");\n    assert_print_array(\"[1, null, true, false, [], \\\"hello\\\", {\\n\\t}]\", \"[1,null,true,false,[],\\\"hello\\\",{}]\");\n}",
          "fn_code_pos": [
            [
              83,
              0
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_array_should_print_arrays_with_multiple_elements",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int CJSON_CDECL main(void)\n{\n    /* initialize cJSON item */\n    UNITY_BEGIN();\n\n    RUN_TEST(print_array_should_print_empty_arrays);\n    RUN_TEST(print_array_should_print_arrays_with_one_element);\n    RUN_TEST(print_array_should_print_arrays_with_multiple_elements);\n\n    return UNITY_END();\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              99,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"unity/examples/unity_config.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"unity/src/unity.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"common.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/parse_object.c": {
      "fn_def_list": [
        {
          "fn_code": "static void assert_is_object(cJSON *object_item)\n{\n    TEST_ASSERT_NOT_NULL_MESSAGE(object_item, \"Item is NULL.\");\n\n    assert_not_in_list(object_item);\n    assert_has_type(object_item, cJSON_Object);\n    assert_has_no_reference(object_item);\n    assert_has_no_const_string(object_item);\n    assert_has_no_valuestring(object_item);\n    assert_has_no_string(object_item);\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              42,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "assert_is_object",
            "parameters": {
              "object_item": "cJSON"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void assert_is_child(cJSON *child_item, const char *name, int type)\n{\n    TEST_ASSERT_NOT_NULL_MESSAGE(child_item, \"Child item is NULL.\");\n    TEST_ASSERT_NOT_NULL_MESSAGE(child_item->string, \"Child item doesn't have a name.\");\n    TEST_ASSERT_EQUAL_STRING_MESSAGE(name, child_item->string, \"Child item has the wrong name.\");\n    TEST_ASSERT_BITS(0xFF, type, child_item->type);\n}",
          "fn_code_pos": [
            [
              44,
              0
            ],
            [
              50,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "assert_is_child",
            "parameters": {
              "child_item": "cJSON",
              "name": "char",
              "type": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void assert_not_object(const char *json)\n{\n    parse_buffer parsebuffer = { 0, 0, 0, 0, { 0, 0, 0 } };\n    parsebuffer.content = (const unsigned char*)json;\n    parsebuffer.length = strlen(json) + sizeof(\"\");\n    parsebuffer.hooks = global_hooks;\n\n    TEST_ASSERT_FALSE(parse_object(item, &parsebuffer));\n    assert_is_invalid(item);\n    reset(item);\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              62,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "assert_not_object",
            "parameters": {
              "json": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void assert_parse_object(const char *json)\n{\n    parse_buffer parsebuffer = { 0, 0, 0, 0, { 0, 0, 0 } };\n    parsebuffer.content = (const unsigned char*)json;\n    parsebuffer.length = strlen(json) + sizeof(\"\");\n    parsebuffer.hooks = global_hooks;\n\n    TEST_ASSERT_TRUE(parse_object(item, &parsebuffer));\n    assert_is_object(item);\n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              73,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "assert_parse_object",
            "parameters": {
              "json": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_object_should_parse_empty_objects(void)\n{\n    assert_parse_object(\"{}\");\n    assert_has_no_child(item);\n    reset(item);\n\n    assert_parse_object(\"{\\n\\t}\");\n    assert_has_no_child(item);\n    reset(item);\n}",
          "fn_code_pos": [
            [
              75,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_object_should_parse_empty_objects",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_object_should_parse_objects_with_one_element(void)\n{\n\n    assert_parse_object(\"{\\\"one\\\":1}\");\n    assert_is_child(item->child, \"one\", cJSON_Number);\n    reset(item);\n\n    assert_parse_object(\"{\\\"hello\\\":\\\"world!\\\"}\");\n    assert_is_child(item->child, \"hello\", cJSON_String);\n    reset(item);\n\n    assert_parse_object(\"{\\\"array\\\":[]}\");\n    assert_is_child(item->child, \"array\", cJSON_Array);\n    reset(item);\n\n    assert_parse_object(\"{\\\"null\\\":null}\");\n    assert_is_child(item->child, \"null\", cJSON_NULL);\n    reset(item);\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              104,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_object_should_parse_objects_with_one_element",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_object_should_parse_objects_with_multiple_elements(void)\n{\n    assert_parse_object(\"{\\\"one\\\":1\\t,\\t\\\"two\\\"\\n:2, \\\"three\\\":3}\");\n    assert_is_child(item->child, \"one\", cJSON_Number);\n    assert_is_child(item->child->next, \"two\", cJSON_Number);\n    assert_is_child(item->child->next->next, \"three\", cJSON_Number);\n    reset(item);\n\n    {\n        size_t i = 0;\n        cJSON *node = NULL;\n        int expected_types[7] =\n        {\n            cJSON_Number,\n            cJSON_NULL,\n            cJSON_True,\n            cJSON_False,\n            cJSON_Array,\n            cJSON_String,\n            cJSON_Object\n        };\n        const char *expected_names[7] =\n        {\n            \"one\",\n            \"NULL\",\n            \"TRUE\",\n            \"FALSE\",\n            \"array\",\n            \"world\",\n            \"object\"\n        };\n        assert_parse_object(\"{\\\"one\\\":1, \\\"NULL\\\":null, \\\"TRUE\\\":true, \\\"FALSE\\\":false, \\\"array\\\":[], \\\"world\\\":\\\"hello\\\", \\\"object\\\":{}}\");\n\n        node = item->child;\n        for (\n                i = 0;\n                (i < (sizeof(expected_types)/sizeof(int)))\n                && (node != NULL);\n                (void)i++, node = node->next)\n        {\n            assert_is_child(node, expected_names[i], expected_types[i]);\n        }\n        TEST_ASSERT_EQUAL_INT(i, 7);\n        reset(item);\n    }\n}",
          "fn_code_pos": [
            [
              106,
              0
            ],
            [
              151,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_object_should_parse_objects_with_multiple_elements",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_object_should_not_parse_non_objects(void)\n{\n    assert_not_object(\"\");\n    assert_not_object(\"{\");\n    assert_not_object(\"}\");\n    assert_not_object(\"[\\\"hello\\\",{}]\");\n    assert_not_object(\"42\");\n    assert_not_object(\"3.14\");\n    assert_not_object(\"\\\"{}hello world!\\n\\\"\");\n}",
          "fn_code_pos": [
            [
              153,
              0
            ],
            [
              162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_object_should_not_parse_non_objects",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int CJSON_CDECL main(void)\n{\n    /* initialize cJSON item */\n    memset(item, 0, sizeof(cJSON));\n\n    UNITY_BEGIN();\n    RUN_TEST(parse_object_should_parse_empty_objects);\n    RUN_TEST(parse_object_should_not_parse_non_objects);\n    RUN_TEST(parse_object_should_parse_objects_with_multiple_elements);\n    RUN_TEST(parse_object_should_parse_objects_with_one_element);\n    return UNITY_END();\n}",
          "fn_code_pos": [
            [
              164,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"unity/examples/unity_config.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"unity/src/unity.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"common.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/cjson_add.c": {
      "fn_def_list": [
        {
          "fn_code": "static void * CJSON_CDECL failing_malloc(size_t size)\n{\n    (void)size;\n    return NULL;\n}",
          "fn_code_pos": [
            [
              30,
              0
            ],
            [
              34,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL failing_malloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void CJSON_CDECL normal_free(void *pointer)\n{\n    free(pointer);\n}",
          "fn_code_pos": [
            [
              37,
              0
            ],
            [
              40,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL normal_free",
            "parameters": {
              "pointer": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_null_should_add_null(void)\n{\n    cJSON *root = cJSON_CreateObject();\n    cJSON *null = NULL;\n\n    cJSON_AddNullToObject(root, \"null\");\n\n    TEST_ASSERT_NOT_NULL(null = cJSON_GetObjectItemCaseSensitive(root, \"null\"));\n    TEST_ASSERT_EQUAL_INT(null->type, cJSON_NULL);\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              58,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_null_should_add_null",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_null_should_fail_with_null_pointers(void)\n{\n    cJSON *root = cJSON_CreateObject();\n\n    TEST_ASSERT_NULL(cJSON_AddNullToObject(NULL, \"null\"));\n    TEST_ASSERT_NULL(cJSON_AddNullToObject(root, NULL));\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              68,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_null_should_fail_with_null_pointers",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_null_should_fail_on_allocation_failure(void)\n{\n    cJSON *root = cJSON_CreateObject();\n\n    cJSON_InitHooks(&failing_hooks);\n\n    TEST_ASSERT_NULL(cJSON_AddNullToObject(root, \"null\"));\n\n    cJSON_InitHooks(NULL);\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              70,
              0
            ],
            [
              81,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_null_should_fail_on_allocation_failure",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_true_should_add_true(void)\n{\n    cJSON *root = cJSON_CreateObject();\n    cJSON *true_item = NULL;\n\n    cJSON_AddTrueToObject(root, \"true\");\n\n    TEST_ASSERT_NOT_NULL(true_item = cJSON_GetObjectItemCaseSensitive(root, \"true\"));\n    TEST_ASSERT_EQUAL_INT(true_item->type, cJSON_True);\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              83,
              0
            ],
            [
              94,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_true_should_add_true",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_true_should_fail_with_null_pointers(void)\n{\n    cJSON *root = cJSON_CreateObject();\n\n    TEST_ASSERT_NULL(cJSON_AddTrueToObject(NULL, \"true\"));\n    TEST_ASSERT_NULL(cJSON_AddTrueToObject(root, NULL));\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              96,
              0
            ],
            [
              104,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_true_should_fail_with_null_pointers",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_true_should_fail_on_allocation_failure(void)\n{\n    cJSON *root = cJSON_CreateObject();\n\n    cJSON_InitHooks(&failing_hooks);\n\n    TEST_ASSERT_NULL(cJSON_AddTrueToObject(root, \"true\"));\n\n    cJSON_InitHooks(NULL);\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              106,
              0
            ],
            [
              117,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_true_should_fail_on_allocation_failure",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_create_int_array_should_fail_on_allocation_failure(void)\n{\n    int numbers[] = {1, 2, 3};\n\n    cJSON_InitHooks(&failing_hooks);\n\n    TEST_ASSERT_NULL(cJSON_CreateIntArray(numbers, 3));\n\n    cJSON_InitHooks(NULL);\n}",
          "fn_code_pos": [
            [
              119,
              0
            ],
            [
              128,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_create_int_array_should_fail_on_allocation_failure",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_create_float_array_should_fail_on_allocation_failure(void)\n{\n    float numbers[] = {1.0f, 2.0f, 3.0f};\n\n    cJSON_InitHooks(&failing_hooks);\n\n    TEST_ASSERT_NULL(cJSON_CreateFloatArray(numbers, 3));\n\n    cJSON_InitHooks(NULL);\n}",
          "fn_code_pos": [
            [
              130,
              0
            ],
            [
              139,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_create_float_array_should_fail_on_allocation_failure",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_create_double_array_should_fail_on_allocation_failure(void)\n{\n    double numbers[] = {1.0, 2.0, 3.0};\n\n    cJSON_InitHooks(&failing_hooks);\n\n    TEST_ASSERT_NULL(cJSON_CreateDoubleArray(numbers, 3));\n\n    cJSON_InitHooks(NULL);\n}",
          "fn_code_pos": [
            [
              141,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_create_double_array_should_fail_on_allocation_failure",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_create_string_array_should_fail_on_allocation_failure(void)\n{\n    const char* strings[] = {\"1\", \"2\", \"3\"};\n\n    cJSON_InitHooks(&failing_hooks);\n\n    TEST_ASSERT_NULL(cJSON_CreateStringArray(strings, 3));\n\n    cJSON_InitHooks(NULL);\n}",
          "fn_code_pos": [
            [
              152,
              0
            ],
            [
              161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_create_string_array_should_fail_on_allocation_failure",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_false_should_add_false(void)\n{\n    cJSON *root = cJSON_CreateObject();\n    cJSON *false_item = NULL;\n\n    cJSON_AddFalseToObject(root, \"false\");\n\n    TEST_ASSERT_NOT_NULL(false_item = cJSON_GetObjectItemCaseSensitive(root, \"false\"));\n    TEST_ASSERT_EQUAL_INT(false_item->type, cJSON_False);\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              163,
              0
            ],
            [
              174,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_false_should_add_false",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_false_should_fail_with_null_pointers(void)\n{\n    cJSON *root = cJSON_CreateObject();\n\n    TEST_ASSERT_NULL(cJSON_AddFalseToObject(NULL, \"false\"));\n    TEST_ASSERT_NULL(cJSON_AddFalseToObject(root, NULL));\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              176,
              0
            ],
            [
              184,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_false_should_fail_with_null_pointers",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_false_should_fail_on_allocation_failure(void)\n{\n    cJSON *root = cJSON_CreateObject();\n\n    cJSON_InitHooks(&failing_hooks);\n\n    TEST_ASSERT_NULL(cJSON_AddFalseToObject(root, \"false\"));\n\n    cJSON_InitHooks(NULL);\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              186,
              0
            ],
            [
              197,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_false_should_fail_on_allocation_failure",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_bool_should_add_bool(void)\n{\n    cJSON *root = cJSON_CreateObject();\n    cJSON *true_item = NULL;\n    cJSON *false_item = NULL;\n\n    /* true */\n    cJSON_AddBoolToObject(root, \"true\", true);\n    TEST_ASSERT_NOT_NULL(true_item = cJSON_GetObjectItemCaseSensitive(root, \"true\"));\n    TEST_ASSERT_EQUAL_INT(true_item->type, cJSON_True);\n\n    /* false */\n    cJSON_AddBoolToObject(root, \"false\", false);\n    TEST_ASSERT_NOT_NULL(false_item = cJSON_GetObjectItemCaseSensitive(root, \"false\"));\n    TEST_ASSERT_EQUAL_INT(false_item->type, cJSON_False);\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              199,
              0
            ],
            [
              216,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_bool_should_add_bool",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_bool_should_fail_with_null_pointers(void)\n{\n    cJSON *root = cJSON_CreateObject();\n\n    TEST_ASSERT_NULL(cJSON_AddBoolToObject(NULL, \"false\", false));\n    TEST_ASSERT_NULL(cJSON_AddBoolToObject(root, NULL, false));\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              218,
              0
            ],
            [
              226,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_bool_should_fail_with_null_pointers",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_bool_should_fail_on_allocation_failure(void)\n{\n    cJSON *root = cJSON_CreateObject();\n\n    cJSON_InitHooks(&failing_hooks);\n\n    TEST_ASSERT_NULL(cJSON_AddBoolToObject(root, \"false\", false));\n\n    cJSON_InitHooks(NULL);\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              228,
              0
            ],
            [
              239,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_bool_should_fail_on_allocation_failure",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_number_should_add_number(void)\n{\n    cJSON *root = cJSON_CreateObject();\n    cJSON *number = NULL;\n\n    cJSON_AddNumberToObject(root, \"number\", 42);\n\n    TEST_ASSERT_NOT_NULL(number = cJSON_GetObjectItemCaseSensitive(root, \"number\"));\n\n    TEST_ASSERT_EQUAL_INT(number->type, cJSON_Number);\n    TEST_ASSERT_EQUAL_DOUBLE(number->valuedouble, 42);\n    TEST_ASSERT_EQUAL_INT(number->valueint, 42);\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              241,
              0
            ],
            [
              255,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_number_should_add_number",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_number_should_fail_with_null_pointers(void)\n{\n    cJSON *root = cJSON_CreateObject();\n\n    TEST_ASSERT_NULL(cJSON_AddNumberToObject(NULL, \"number\", 42));\n    TEST_ASSERT_NULL(cJSON_AddNumberToObject(root, NULL, 42));\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              257,
              0
            ],
            [
              265,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_number_should_fail_with_null_pointers",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_number_should_fail_on_allocation_failure(void)\n{\n    cJSON *root = cJSON_CreateObject();\n\n    cJSON_InitHooks(&failing_hooks);\n\n    TEST_ASSERT_NULL(cJSON_AddNumberToObject(root, \"number\", 42));\n\n    cJSON_InitHooks(NULL);\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              267,
              0
            ],
            [
              278,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_number_should_fail_on_allocation_failure",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_string_should_add_string(void)\n{\n    cJSON *root = cJSON_CreateObject();\n    cJSON *string = NULL;\n\n    cJSON_AddStringToObject(root, \"string\", \"Hello World!\");\n\n    TEST_ASSERT_NOT_NULL(string = cJSON_GetObjectItemCaseSensitive(root, \"string\"));\n    TEST_ASSERT_EQUAL_INT(string->type, cJSON_String);\n    TEST_ASSERT_EQUAL_STRING(string->valuestring, \"Hello World!\");\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              280,
              0
            ],
            [
              292,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_string_should_add_string",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_string_should_fail_with_null_pointers(void)\n{\n    cJSON *root = cJSON_CreateObject();\n\n    TEST_ASSERT_NULL(cJSON_AddStringToObject(NULL, \"string\", \"string\"));\n    TEST_ASSERT_NULL(cJSON_AddStringToObject(root, NULL, \"string\"));\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              294,
              0
            ],
            [
              302,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_string_should_fail_with_null_pointers",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_string_should_fail_on_allocation_failure(void)\n{\n    cJSON *root = cJSON_CreateObject();\n\n    cJSON_InitHooks(&failing_hooks);\n\n    TEST_ASSERT_NULL(cJSON_AddStringToObject(root, \"string\", \"string\"));\n\n    cJSON_InitHooks(NULL);\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              304,
              0
            ],
            [
              315,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_string_should_fail_on_allocation_failure",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_raw_should_add_raw(void)\n{\n    cJSON *root = cJSON_CreateObject();\n    cJSON *raw = NULL;\n\n    cJSON_AddRawToObject(root, \"raw\", \"{}\");\n\n    TEST_ASSERT_NOT_NULL(raw = cJSON_GetObjectItemCaseSensitive(root, \"raw\"));\n    TEST_ASSERT_EQUAL_INT(raw->type, cJSON_Raw);\n    TEST_ASSERT_EQUAL_STRING(raw->valuestring, \"{}\");\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              317,
              0
            ],
            [
              329,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_raw_should_add_raw",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_raw_should_fail_with_null_pointers(void)\n{\n    cJSON *root = cJSON_CreateObject();\n\n    TEST_ASSERT_NULL(cJSON_AddRawToObject(NULL, \"raw\", \"{}\"));\n    TEST_ASSERT_NULL(cJSON_AddRawToObject(root, NULL, \"{}\"));\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              331,
              0
            ],
            [
              339,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_raw_should_fail_with_null_pointers",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_raw_should_fail_on_allocation_failure(void)\n{\n    cJSON *root = cJSON_CreateObject();\n\n    cJSON_InitHooks(&failing_hooks);\n\n    TEST_ASSERT_NULL(cJSON_AddRawToObject(root, \"raw\", \"{}\"));\n\n    cJSON_InitHooks(NULL);\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              341,
              0
            ],
            [
              352,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_raw_should_fail_on_allocation_failure",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cJSON_add_object_should_add_object(void)\n{\n    cJSON *root = cJSON_CreateObject();\n    cJSON *object = NULL;\n\n    cJSON_AddObjectToObject(root, \"object\");\n    TEST_ASSERT_NOT_NULL(object = cJSON_GetObjectItemCaseSensitive(root, \"object\"));\n    TEST_ASSERT_EQUAL_INT(object->type, cJSON_Object);\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              354,
              0
            ],
            [
              364,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_add_object_should_add_object",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_object_should_fail_with_null_pointers(void)\n{\n    cJSON *root = cJSON_CreateObject();\n\n    TEST_ASSERT_NULL(cJSON_AddObjectToObject(NULL, \"object\"));\n    TEST_ASSERT_NULL(cJSON_AddObjectToObject(root, NULL));\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              366,
              0
            ],
            [
              374,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_object_should_fail_with_null_pointers",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_object_should_fail_on_allocation_failure(void)\n{\n    cJSON *root = cJSON_CreateObject();\n\n    cJSON_InitHooks(&failing_hooks);\n\n    TEST_ASSERT_NULL(cJSON_AddObjectToObject(root, \"object\"));\n\n    cJSON_InitHooks(NULL);\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              376,
              0
            ],
            [
              387,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_object_should_fail_on_allocation_failure",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cJSON_add_array_should_add_array(void)\n{\n    cJSON *root = cJSON_CreateObject();\n    cJSON *array = NULL;\n\n    cJSON_AddArrayToObject(root, \"array\");\n    TEST_ASSERT_NOT_NULL(array = cJSON_GetObjectItemCaseSensitive(root, \"array\"));\n    TEST_ASSERT_EQUAL_INT(array->type, cJSON_Array);\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              389,
              0
            ],
            [
              399,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_add_array_should_add_array",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_array_should_fail_with_null_pointers(void)\n{\n    cJSON *root = cJSON_CreateObject();\n\n    TEST_ASSERT_NULL(cJSON_AddArrayToObject(NULL, \"array\"));\n    TEST_ASSERT_NULL(cJSON_AddArrayToObject(root, NULL));\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              401,
              0
            ],
            [
              409,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_array_should_fail_with_null_pointers",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void cjson_add_array_should_fail_on_allocation_failure(void)\n{\n    cJSON *root = cJSON_CreateObject();\n\n    cJSON_InitHooks(&failing_hooks);\n\n    TEST_ASSERT_NULL(cJSON_AddArrayToObject(root, \"array\"));\n\n    cJSON_InitHooks(NULL);\n\n    cJSON_Delete(root);\n}",
          "fn_code_pos": [
            [
              411,
              0
            ],
            [
              422,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cjson_add_array_should_fail_on_allocation_failure",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int CJSON_CDECL main(void)\n{\n    UNITY_BEGIN();\n\n    RUN_TEST(cjson_add_null_should_add_null);\n    RUN_TEST(cjson_add_null_should_fail_with_null_pointers);\n    RUN_TEST(cjson_add_null_should_fail_on_allocation_failure);\n\n    RUN_TEST(cjson_add_true_should_add_true);\n    RUN_TEST(cjson_add_true_should_fail_with_null_pointers);\n    RUN_TEST(cjson_add_true_should_fail_on_allocation_failure);\n\n    RUN_TEST(cjson_create_int_array_should_fail_on_allocation_failure);\n    RUN_TEST(cjson_create_float_array_should_fail_on_allocation_failure);\n    RUN_TEST(cjson_create_double_array_should_fail_on_allocation_failure);\n    RUN_TEST(cjson_create_string_array_should_fail_on_allocation_failure);\n\n    RUN_TEST(cjson_add_false_should_add_false);\n    RUN_TEST(cjson_add_false_should_fail_with_null_pointers);\n    RUN_TEST(cjson_add_false_should_fail_on_allocation_failure);\n\n    RUN_TEST(cjson_add_bool_should_add_bool);\n    RUN_TEST(cjson_add_bool_should_fail_with_null_pointers);\n    RUN_TEST(cjson_add_bool_should_fail_on_allocation_failure);\n\n    RUN_TEST(cjson_add_number_should_add_number);\n    RUN_TEST(cjson_add_number_should_fail_with_null_pointers);\n    RUN_TEST(cjson_add_number_should_fail_on_allocation_failure);\n\n    RUN_TEST(cjson_add_string_should_add_string);\n    RUN_TEST(cjson_add_string_should_fail_with_null_pointers);\n    RUN_TEST(cjson_add_string_should_fail_on_allocation_failure);\n\n    RUN_TEST(cjson_add_raw_should_add_raw);\n    RUN_TEST(cjson_add_raw_should_fail_with_null_pointers);\n    RUN_TEST(cjson_add_raw_should_fail_on_allocation_failure);\n\n    RUN_TEST(cJSON_add_object_should_add_object);\n    RUN_TEST(cjson_add_object_should_fail_with_null_pointers);\n    RUN_TEST(cjson_add_object_should_fail_on_allocation_failure);\n\n    RUN_TEST(cJSON_add_array_should_add_array);\n    RUN_TEST(cjson_add_array_should_fail_with_null_pointers);\n    RUN_TEST(cjson_add_array_should_fail_on_allocation_failure);\n\n    return UNITY_END();\n}",
          "fn_code_pos": [
            [
              424,
              0
            ],
            [
              470,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "CJSON_CDECL failing_malloc(size_t size)",
          "fn_dec_pos": [
            [
              30,
              14
            ],
            [
              30,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL failing_malloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"unity/examples/unity_config.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"unity/src/unity.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"common.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/readme_examples.c": {
      "fn_def_list": [
        {
          "fn_code": "static char* create_monitor(void)\n{\n    const unsigned int resolution_numbers[3][2] = {\n        {1280, 720},\n        {1920, 1080},\n        {3840, 2160}\n    };\n    char *string = NULL;\n    cJSON *name = NULL;\n    cJSON *resolutions = NULL;\n    cJSON *resolution = NULL;\n    cJSON *width = NULL;\n    cJSON *height = NULL;\n    size_t index = 0;\n\n    cJSON *monitor = cJSON_CreateObject();\n    if (monitor == NULL)\n    {\n        goto end;\n    }\n\n    name = cJSON_CreateString(\"Awesome 4K\");\n    if (name == NULL)\n    {\n        goto end;\n    }\n    /* after creation was successful, immediately add it to the monitor,\n     * thereby transferring ownership of the pointer to it */\n    cJSON_AddItemToObject(monitor, \"name\", name);\n\n    resolutions = cJSON_CreateArray();\n    if (resolutions == NULL)\n    {\n        goto end;\n    }\n    cJSON_AddItemToObject(monitor, \"resolutions\", resolutions);\n\n    for (index = 0; index < (sizeof(resolution_numbers) / (2 * sizeof(int))); ++index)\n    {\n        resolution = cJSON_CreateObject();\n        if (resolution == NULL)\n        {\n            goto end;\n        }\n        cJSON_AddItemToArray(resolutions, resolution);\n\n        width = cJSON_CreateNumber(resolution_numbers[index][0]);\n        if (width == NULL)\n        {\n            goto end;\n        }\n        cJSON_AddItemToObject(resolution, \"width\", width);\n\n        height = cJSON_CreateNumber(resolution_numbers[index][1]);\n        if (height == NULL)\n        {\n            goto end;\n        }\n        cJSON_AddItemToObject(resolution, \"height\", height);\n    }\n\n    string = cJSON_Print(monitor);\n    if (string == NULL)\n    {\n        fprintf(stderr, \"Failed to print monitor.\\n\");\n    }\n\nend:\n    cJSON_Delete(monitor);\n    return string;\n}",
          "fn_code_pos": [
            [
              44,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "create_monitor",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "static char *create_monitor_with_helpers(void)\n{\n    const unsigned int resolution_numbers[3][2] = {\n        {1280, 720},\n        {1920, 1080},\n        {3840, 2160}\n    };\n    char *string = NULL;\n    cJSON *resolutions = NULL;\n    size_t index = 0;\n\n    cJSON *monitor = cJSON_CreateObject();\n\n    if (cJSON_AddStringToObject(monitor, \"name\", \"Awesome 4K\") == NULL)\n    {\n        goto end;\n    }\n\n    resolutions = cJSON_AddArrayToObject(monitor, \"resolutions\");\n    if (resolutions == NULL)\n    {\n        goto end;\n    }\n\n    for (index = 0; index < (sizeof(resolution_numbers) / (2 * sizeof(int))); ++index)\n    {\n        cJSON *resolution = cJSON_CreateObject();\n\n        if (cJSON_AddNumberToObject(resolution, \"width\", resolution_numbers[index][0]) == NULL)\n        {\n            goto end;\n        }\n\n        if(cJSON_AddNumberToObject(resolution, \"height\", resolution_numbers[index][1]) == NULL)\n        {\n            goto end;\n        }\n\n        cJSON_AddItemToArray(resolutions, resolution);\n    }\n\n    string = cJSON_Print(monitor);\n    if (string == NULL) {\n        fprintf(stderr, \"Failed to print monitor.\\n\");\n    }\n\nend:\n    cJSON_Delete(monitor);\n    return string;\n}",
          "fn_code_pos": [
            [
              116,
              0
            ],
            [
              165,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "create_monitor_with_helpers",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "static int supports_full_hd(const char * const monitor)\n{\n    const cJSON *resolution = NULL;\n    const cJSON *resolutions = NULL;\n    const cJSON *name = NULL;\n    int status = 0;\n    cJSON *monitor_json = cJSON_Parse(monitor);\n    if (monitor_json == NULL)\n    {\n        const char *error_ptr = cJSON_GetErrorPtr();\n        if (error_ptr != NULL)\n        {\n            fprintf(stderr, \"Error before: %s\\n\", error_ptr);\n        }\n        status = 0;\n        goto end;\n    }\n\n    name = cJSON_GetObjectItemCaseSensitive(monitor_json, \"name\");\n    if (cJSON_IsString(name) && (name->valuestring != NULL))\n    {\n        printf(\"Checking monitor \\\"%s\\\"\\n\", name->valuestring);\n    }\n\n    resolutions = cJSON_GetObjectItemCaseSensitive(monitor_json, \"resolutions\");\n    cJSON_ArrayForEach(resolution, resolutions)\n    {\n        cJSON *width = cJSON_GetObjectItemCaseSensitive(resolution, \"width\");\n        cJSON *height = cJSON_GetObjectItemCaseSensitive(resolution, \"height\");\n\n        if (!cJSON_IsNumber(width) || !cJSON_IsNumber(height))\n        {\n            status = 0;\n            goto end;\n        }\n\n        if (compare_double(width->valuedouble, 1920) && compare_double(height->valuedouble, 1080))\n        {\n            status = 1;\n            goto end;\n        }\n    }\n\nend:\n    cJSON_Delete(monitor_json);\n    return status;\n}",
          "fn_code_pos": [
            [
              168,
              0
            ],
            [
              214,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "supports_full_hd",
            "parameters": {
              "monitor": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "cJSON_ArrayForEach(resolution, resolutions)\n    {\n        cJSON *width = cJSON_GetObjectItemCaseSensitive(resolution, \"width\");\n        cJSON *height = cJSON_GetObjectItemCaseSensitive(resolution, \"height\");\n\n        if (!cJSON_IsNumber(width) || !cJSON_IsNumber(height))\n        {\n            status = 0;\n            goto end;\n        }\n\n        if (compare_double(width->valuedouble, 1920) && compare_double(height->valuedouble, 1080))\n        {\n            status = 1;\n            goto end;\n        }\n    }",
          "fn_code_pos": [
            [
              193,
              4
            ],
            [
              209,
              5
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ArrayForEach",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static void create_monitor_should_create_a_monitor(void)\n{\n    char *monitor = create_monitor();\n\n    TEST_ASSERT_EQUAL_STRING(monitor, json);\n\n    free(monitor);\n}",
          "fn_code_pos": [
            [
              216,
              0
            ],
            [
              223,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "create_monitor_should_create_a_monitor",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void create_monitor_with_helpers_should_create_a_monitor(void)\n{\n    char *monitor = create_monitor_with_helpers();\n\n    TEST_ASSERT_EQUAL_STRING(json, monitor);\n\n    free(monitor);\n}",
          "fn_code_pos": [
            [
              225,
              0
            ],
            [
              232,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "create_monitor_with_helpers_should_create_a_monitor",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void supports_full_hd_should_check_for_full_hd_support(void)\n{\n    static const char *monitor_without_hd = \"{\\n\\\n\\t\\t\\\"name\\\": \\\"lame monitor\\\",\\n\\\n\\t\\t\\\"resolutions\\\":\\t[{\\n\\\n\\t\\t\\t\\\"width\\\":\\t640,\\n\\\n\\t\\t\\t\\\"height\\\":\\t480\\n\\\n\\t\\t}]\\n\\\n}\";\n\n    TEST_ASSERT(supports_full_hd(json));\n    TEST_ASSERT_FALSE(supports_full_hd(monitor_without_hd));\n}",
          "fn_code_pos": [
            [
              234,
              0
            ],
            [
              246,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "supports_full_hd_should_check_for_full_hd_support",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int CJSON_CDECL main(void)\n{\n    UNITY_BEGIN();\n\n    RUN_TEST(create_monitor_should_create_a_monitor);\n    RUN_TEST(create_monitor_with_helpers_should_create_a_monitor);\n    RUN_TEST(supports_full_hd_should_check_for_full_hd_support);\n\n    return UNITY_END();\n}",
          "fn_code_pos": [
            [
              248,
              0
            ],
            [
              257,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "create_monitor(void)",
          "fn_dec_pos": [
            [
              44,
              13
            ],
            [
              44,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "create_monitor",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "create_monitor_with_helpers(void)",
          "fn_dec_pos": [
            [
              116,
              13
            ],
            [
              116,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "create_monitor_with_helpers",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"unity/examples/unity_config.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"unity/src/unity.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"common.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/print_number.c": {
      "fn_def_list": [
        {
          "fn_code": "static void assert_print_number(const char *expected, double input)\n{\n    unsigned char printed[1024];\n    unsigned char new_buffer[26];\n    unsigned int i = 0;\n    cJSON item[1];\n    printbuffer buffer = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };\n    buffer.buffer = printed;\n    buffer.length = sizeof(printed);\n    buffer.offset = 0;\n    buffer.noalloc = true;\n    buffer.hooks = global_hooks;\n    buffer.buffer = new_buffer;\n\n    memset(item, 0, sizeof(item));\n    memset(new_buffer, 0, sizeof(new_buffer));\n    cJSON_SetNumberValue(item, input);\n    TEST_ASSERT_TRUE_MESSAGE(print_number(item, &buffer), \"Failed to print number.\");\n    \n    /* In MinGW or visual studio(before 2015),the exponten is represented using three digits,like:\"1e-009\",\"1e+017\"\n     * remove extra \"0\" to output \"1e-09\" or \"1e+17\",which makes testcase PASS */\n    for(i = 0;i <sizeof(new_buffer);i++)\n    {\n        if(i >3 && new_buffer[i] =='0')\n        {\n            if((new_buffer[i-3] =='e' && new_buffer[i-2] == '-' && new_buffer[i] =='0') ||(new_buffer[i-2] =='e' && new_buffer[i-1] =='+'))\n            {\n                while(new_buffer[i] !='\\0')\n                {\n                    new_buffer[i] = new_buffer[i+1];\n                    i++;\n                }\n            }        \n        }  \n    }    \n    TEST_ASSERT_EQUAL_STRING_MESSAGE(expected, buffer.buffer, \"Printed number is not as expected.\");\n}",
          "fn_code_pos": [
            [
              26,
              0
            ],
            [
              62,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "assert_print_number",
            "parameters": {
              "expected": "char",
              "input": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_number_should_print_zero(void)\n{\n    assert_print_number(\"0\", 0);\n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_number_should_print_zero",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_number_should_print_negative_integers(void)\n{\n    assert_print_number(\"-1\", -1.0);\n    assert_print_number(\"-32768\", -32768.0);\n    assert_print_number(\"-2147483648\", -2147483648.0);\n}",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              74,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_number_should_print_negative_integers",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_number_should_print_positive_integers(void)\n{\n    assert_print_number(\"1\", 1.0);\n    assert_print_number(\"32767\", 32767.0);\n    assert_print_number(\"2147483647\", 2147483647.0);\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              81,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_number_should_print_positive_integers",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_number_should_print_positive_reals(void)\n{\n    assert_print_number(\"0.123\", 0.123);\n    assert_print_number(\"1e-09\", 10e-10);\n    assert_print_number(\"1000000000000\", 10e11);\n    assert_print_number(\"1.23e+129\", 123e+127);\n    assert_print_number(\"1.23e-126\", 123e-128);\n    assert_print_number(\"3.1415926535897931\", 3.1415926535897931);\n}",
          "fn_code_pos": [
            [
              83,
              0
            ],
            [
              91,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_number_should_print_positive_reals",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_number_should_print_negative_reals(void)\n{\n    assert_print_number(\"-0.0123\", -0.0123);\n    assert_print_number(\"-1e-09\", -10e-10);\n    assert_print_number(\"-1e+21\", -10e20);\n    assert_print_number(\"-1.23e+129\", -123e+127);\n    assert_print_number(\"-1.23e-126\", -123e-128);\n}",
          "fn_code_pos": [
            [
              93,
              0
            ],
            [
              100,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_number_should_print_negative_reals",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_number_should_print_non_number(void)\n{\n    TEST_IGNORE();\n    /* FIXME: Cannot test this easily in C89! */\n    /* assert_print_number(\"null\", NaN); */\n    /* assert_print_number(\"null\", INFTY); */\n    /* assert_print_number(\"null\", -INFTY); */\n}",
          "fn_code_pos": [
            [
              102,
              0
            ],
            [
              109,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_number_should_print_non_number",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int CJSON_CDECL main(void)\n{\n    /* initialize cJSON item */\n    UNITY_BEGIN();\n\n    RUN_TEST(print_number_should_print_zero);\n    RUN_TEST(print_number_should_print_negative_integers);\n    RUN_TEST(print_number_should_print_positive_integers);\n    RUN_TEST(print_number_should_print_positive_reals);\n    RUN_TEST(print_number_should_print_negative_reals);\n    RUN_TEST(print_number_should_print_non_number);\n\n    return UNITY_END();\n}",
          "fn_code_pos": [
            [
              111,
              0
            ],
            [
              124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"unity/examples/unity_config.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"unity/src/unity.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"common.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/parse_hex4.c": {
      "fn_def_list": [
        {
          "fn_code": "static void parse_hex4_should_parse_all_combinations(void)\n{\n    unsigned int number = 0;\n    unsigned char digits_lower[6];\n    unsigned char digits_upper[6];\n    /* test all combinations */\n    for (number = 0; number <= 0xFFFF; number++)\n    {\n        TEST_ASSERT_EQUAL_INT_MESSAGE(4, sprintf((char*)digits_lower, \"%.4x\", number), \"sprintf failed.\");\n        TEST_ASSERT_EQUAL_INT_MESSAGE(4, sprintf((char*)digits_upper, \"%.4X\", number), \"sprintf failed.\");\n\n        TEST_ASSERT_EQUAL_INT_MESSAGE(number, parse_hex4(digits_lower), \"Failed to parse lowercase digits.\");\n        TEST_ASSERT_EQUAL_INT_MESSAGE(number, parse_hex4(digits_upper), \"Failed to parse uppercase digits.\");\n    }\n}",
          "fn_code_pos": [
            [
              30,
              0
            ],
            [
              44,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_hex4_should_parse_all_combinations",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_hex4_should_parse_mixed_case(void)\n{\n    TEST_ASSERT_EQUAL_INT(0xBEEF, parse_hex4((const unsigned char*)\"beef\"));\n    TEST_ASSERT_EQUAL_INT(0xBEEF, parse_hex4((const unsigned char*)\"beeF\"));\n    TEST_ASSERT_EQUAL_INT(0xBEEF, parse_hex4((const unsigned char*)\"beEf\"));\n    TEST_ASSERT_EQUAL_INT(0xBEEF, parse_hex4((const unsigned char*)\"beEF\"));\n    TEST_ASSERT_EQUAL_INT(0xBEEF, parse_hex4((const unsigned char*)\"bEef\"));\n    TEST_ASSERT_EQUAL_INT(0xBEEF, parse_hex4((const unsigned char*)\"bEeF\"));\n    TEST_ASSERT_EQUAL_INT(0xBEEF, parse_hex4((const unsigned char*)\"bEEf\"));\n    TEST_ASSERT_EQUAL_INT(0xBEEF, parse_hex4((const unsigned char*)\"bEEF\"));\n    TEST_ASSERT_EQUAL_INT(0xBEEF, parse_hex4((const unsigned char*)\"Beef\"));\n    TEST_ASSERT_EQUAL_INT(0xBEEF, parse_hex4((const unsigned char*)\"BeeF\"));\n    TEST_ASSERT_EQUAL_INT(0xBEEF, parse_hex4((const unsigned char*)\"BeEf\"));\n    TEST_ASSERT_EQUAL_INT(0xBEEF, parse_hex4((const unsigned char*)\"BeEF\"));\n    TEST_ASSERT_EQUAL_INT(0xBEEF, parse_hex4((const unsigned char*)\"BEef\"));\n    TEST_ASSERT_EQUAL_INT(0xBEEF, parse_hex4((const unsigned char*)\"BEeF\"));\n    TEST_ASSERT_EQUAL_INT(0xBEEF, parse_hex4((const unsigned char*)\"BEEf\"));\n    TEST_ASSERT_EQUAL_INT(0xBEEF, parse_hex4((const unsigned char*)\"BEEF\"));\n}",
          "fn_code_pos": [
            [
              46,
              0
            ],
            [
              64,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_hex4_should_parse_mixed_case",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int CJSON_CDECL main(void)\n{\n    UNITY_BEGIN();\n    RUN_TEST(parse_hex4_should_parse_all_combinations);\n    RUN_TEST(parse_hex4_should_parse_mixed_case);\n    return UNITY_END();\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              72,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"unity/examples/unity_config.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"unity/src/unity.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"common.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/parse_number.c": {
      "fn_def_list": [
        {
          "fn_code": "static void assert_is_number(cJSON *number_item)\n{\n    TEST_ASSERT_NOT_NULL_MESSAGE(number_item, \"Item is NULL.\");\n\n    assert_not_in_list(number_item);\n    assert_has_no_child(number_item);\n    assert_has_type(number_item, cJSON_Number);\n    assert_has_no_reference(number_item);\n    assert_has_no_const_string(number_item);\n    assert_has_no_valuestring(number_item);\n    assert_has_no_string(number_item);\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              43,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "assert_is_number",
            "parameters": {
              "number_item": "cJSON"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void assert_parse_number(const char *string, int integer, double real)\n{\n    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };\n    buffer.content = (const unsigned char*)string;\n    buffer.length = strlen(string) + sizeof(\"\");\n\n    TEST_ASSERT_TRUE(parse_number(item, &buffer));\n    assert_is_number(item);\n    TEST_ASSERT_EQUAL_INT(integer, item->valueint);\n    TEST_ASSERT_EQUAL_DOUBLE(real, item->valuedouble);\n}",
          "fn_code_pos": [
            [
              45,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "assert_parse_number",
            "parameters": {
              "string": "char",
              "integer": "int",
              "real": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_number_should_parse_zero(void)\n{\n    assert_parse_number(\"0\", 0, 0);\n    assert_parse_number(\"0.0\", 0, 0.0);\n    assert_parse_number(\"-0\", 0, -0.0);\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              62,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_number_should_parse_zero",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_number_should_parse_negative_integers(void)\n{\n    assert_parse_number(\"-1\", -1, -1);\n    assert_parse_number(\"-32768\", -32768, -32768.0);\n    assert_parse_number(\"-2147483648\", (int)-2147483648.0, -2147483648.0);\n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              69,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_number_should_parse_negative_integers",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_number_should_parse_positive_integers(void)\n{\n    assert_parse_number(\"1\", 1, 1);\n    assert_parse_number(\"32767\", 32767, 32767.0);\n    assert_parse_number(\"2147483647\", (int)2147483647.0, 2147483647.0);\n}",
          "fn_code_pos": [
            [
              71,
              0
            ],
            [
              76,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_number_should_parse_positive_integers",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_number_should_parse_positive_reals(void)\n{\n    assert_parse_number(\"0.001\", 0, 0.001);\n    assert_parse_number(\"10e-10\", 0, 10e-10);\n    assert_parse_number(\"10E-10\", 0, 10e-10);\n    assert_parse_number(\"10e10\", INT_MAX, 10e10);\n    assert_parse_number(\"123e+127\", INT_MAX, 123e127);\n    assert_parse_number(\"123e-128\", 0, 123e-128);\n}",
          "fn_code_pos": [
            [
              78,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_number_should_parse_positive_reals",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_number_should_parse_negative_reals(void)\n{\n    assert_parse_number(\"-0.001\", 0, -0.001);\n    assert_parse_number(\"-10e-10\", 0, -10e-10);\n    assert_parse_number(\"-10E-10\", 0, -10e-10);\n    assert_parse_number(\"-10e20\", INT_MIN, -10e20);\n    assert_parse_number(\"-123e+127\", INT_MIN, -123e127);\n    assert_parse_number(\"-123e-128\", 0, -123e-128);\n}",
          "fn_code_pos": [
            [
              88,
              0
            ],
            [
              96,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_number_should_parse_negative_reals",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int CJSON_CDECL main(void)\n{\n    /* initialize cJSON item */\n    memset(item, 0, sizeof(cJSON));\n    UNITY_BEGIN();\n    RUN_TEST(parse_number_should_parse_zero);\n    RUN_TEST(parse_number_should_parse_negative_integers);\n    RUN_TEST(parse_number_should_parse_positive_integers);\n    RUN_TEST(parse_number_should_parse_positive_reals);\n    RUN_TEST(parse_number_should_parse_negative_reals);\n    return UNITY_END();\n}",
          "fn_code_pos": [
            [
              98,
              0
            ],
            [
              109,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"unity/examples/unity_config.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"unity/src/unity.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"common.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/print_value.c": {
      "fn_def_list": [
        {
          "fn_code": "static void assert_print_value(const char *input)\n{\n    unsigned char printed[1024];\n    cJSON item[1];\n    printbuffer buffer = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };\n    parse_buffer parsebuffer = { 0, 0, 0, 0, { 0, 0, 0 } };\n    buffer.buffer = printed;\n    buffer.length = sizeof(printed);\n    buffer.offset = 0;\n    buffer.noalloc = true;\n    buffer.hooks = global_hooks;\n\n    parsebuffer.content = (const unsigned char*)input;\n    parsebuffer.length = strlen(input) + sizeof(\"\");\n    parsebuffer.hooks = global_hooks;\n\n    memset(item, 0, sizeof(item));\n\n    TEST_ASSERT_TRUE_MESSAGE(parse_value(item, &parsebuffer), \"Failed to parse value.\");\n\n    TEST_ASSERT_TRUE_MESSAGE(print_value(item, &buffer), \"Failed to print value.\");\n    TEST_ASSERT_EQUAL_STRING_MESSAGE(input, buffer.buffer, \"Printed value is not as expected.\");\n\n    reset(item);\n}",
          "fn_code_pos": [
            [
              30,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "assert_print_value",
            "parameters": {
              "input": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_value_should_print_null(void)\n{\n    assert_print_value(\"null\");\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              59,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_value_should_print_null",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_value_should_print_true(void)\n{\n    assert_print_value(\"true\");\n}",
          "fn_code_pos": [
            [
              61,
              0
            ],
            [
              64,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_value_should_print_true",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_value_should_print_false(void)\n{\n    assert_print_value(\"false\");\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              69,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_value_should_print_false",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_value_should_print_number(void)\n{\n    assert_print_value(\"1.5\");\n}",
          "fn_code_pos": [
            [
              71,
              0
            ],
            [
              74,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_value_should_print_number",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_value_should_print_string(void)\n{\n    assert_print_value(\"\\\"\\\"\");\n    assert_print_value(\"\\\"hello\\\"\");\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              80,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_value_should_print_string",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_value_should_print_array(void)\n{\n    assert_print_value(\"[]\");\n}",
          "fn_code_pos": [
            [
              82,
              0
            ],
            [
              85,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_value_should_print_array",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void print_value_should_print_object(void)\n{\n    assert_print_value(\"{}\");\n}",
          "fn_code_pos": [
            [
              87,
              0
            ],
            [
              90,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "print_value_should_print_object",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int CJSON_CDECL main(void)\n{\n    /* initialize cJSON item */\n    UNITY_BEGIN();\n\n    RUN_TEST(print_value_should_print_null);\n    RUN_TEST(print_value_should_print_true);\n    RUN_TEST(print_value_should_print_false);\n    RUN_TEST(print_value_should_print_number);\n    RUN_TEST(print_value_should_print_string);\n    RUN_TEST(print_value_should_print_array);\n    RUN_TEST(print_value_should_print_object);\n\n    return UNITY_END();\n}",
          "fn_code_pos": [
            [
              92,
              0
            ],
            [
              106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"unity/examples/unity_config.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"unity/src/unity.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"common.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity_setup.c": {
      "fn_def_list": [
        {
          "fn_code": "void setUp(void) { }",
          "fn_code_pos": [
            [
              1,
              0
            ],
            [
              1,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void tearDown(void) { }",
          "fn_code_pos": [
            [
              2,
              0
            ],
            [
              2,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tearDown",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/parse_value.c": {
      "fn_def_list": [
        {
          "fn_code": "static void assert_is_value(cJSON *value_item, int type)\n{\n    TEST_ASSERT_NOT_NULL_MESSAGE(value_item, \"Item is NULL.\");\n\n    assert_not_in_list(value_item);\n    assert_has_type(value_item, type);\n    assert_has_no_reference(value_item);\n    assert_has_no_const_string(value_item);\n    assert_has_no_string(value_item);\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              41,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "assert_is_value",
            "parameters": {
              "value_item": "cJSON",
              "type": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void assert_parse_value(const char *string, int type)\n{\n    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };\n    buffer.content = (const unsigned char*) string;\n    buffer.length = strlen(string) + sizeof(\"\");\n    buffer.hooks = global_hooks;\n\n    TEST_ASSERT_TRUE(parse_value(item, &buffer));\n    assert_is_value(item, type);\n}",
          "fn_code_pos": [
            [
              43,
              0
            ],
            [
              52,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "assert_parse_value",
            "parameters": {
              "string": "char",
              "type": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_value_should_parse_null(void)\n{\n    assert_parse_value(\"null\", cJSON_NULL);\n    reset(item);\n}",
          "fn_code_pos": [
            [
              54,
              0
            ],
            [
              58,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_value_should_parse_null",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_value_should_parse_true(void)\n{\n    assert_parse_value(\"true\", cJSON_True);\n    reset(item);\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              64,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_value_should_parse_true",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_value_should_parse_false(void)\n{\n    assert_parse_value(\"false\", cJSON_False);\n    reset(item);\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              70,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_value_should_parse_false",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_value_should_parse_number(void)\n{\n    assert_parse_value(\"1.5\", cJSON_Number);\n    reset(item);\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              76,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_value_should_parse_number",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_value_should_parse_string(void)\n{\n    assert_parse_value(\"\\\"\\\"\", cJSON_String);\n    reset(item);\n    assert_parse_value(\"\\\"hello\\\"\", cJSON_String);\n    reset(item);\n}",
          "fn_code_pos": [
            [
              78,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_value_should_parse_string",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_value_should_parse_array(void)\n{\n    assert_parse_value(\"[]\", cJSON_Array);\n    reset(item);\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              90,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_value_should_parse_array",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_value_should_parse_object(void)\n{\n    assert_parse_value(\"{}\", cJSON_Object);\n    reset(item);\n}",
          "fn_code_pos": [
            [
              92,
              0
            ],
            [
              96,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_value_should_parse_object",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int CJSON_CDECL main(void)\n{\n    /* initialize cJSON item */\n    memset(item, 0, sizeof(cJSON));\n    UNITY_BEGIN();\n    RUN_TEST(parse_value_should_parse_null);\n    RUN_TEST(parse_value_should_parse_true);\n    RUN_TEST(parse_value_should_parse_false);\n    RUN_TEST(parse_value_should_parse_number);\n    RUN_TEST(parse_value_should_parse_string);\n    RUN_TEST(parse_value_should_parse_array);\n    RUN_TEST(parse_value_should_parse_object);\n    return UNITY_END();\n}",
          "fn_code_pos": [
            [
              98,
              0
            ],
            [
              111,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"unity/examples/unity_config.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"unity/src/unity.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"common.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/parse_array.c": {
      "fn_def_list": [
        {
          "fn_code": "static void assert_is_array(cJSON *array_item)\n{\n    TEST_ASSERT_NOT_NULL_MESSAGE(array_item, \"Item is NULL.\");\n\n    assert_not_in_list(array_item);\n    assert_has_type(array_item, cJSON_Array);\n    assert_has_no_reference(array_item);\n    assert_has_no_const_string(array_item);\n    assert_has_no_valuestring(array_item);\n    assert_has_no_string(array_item);\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              42,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "assert_is_array",
            "parameters": {
              "array_item": "cJSON"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void assert_not_array(const char *json)\n{\n    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };\n    buffer.content = (const unsigned char*)json;\n    buffer.length = strlen(json) + sizeof(\"\");\n    buffer.hooks = global_hooks;\n\n    TEST_ASSERT_FALSE(parse_array(item, &buffer));\n    assert_is_invalid(item);\n}",
          "fn_code_pos": [
            [
              44,
              0
            ],
            [
              53,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "assert_not_array",
            "parameters": {
              "json": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void assert_parse_array(const char *json)\n{\n    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };\n    buffer.content = (const unsigned char*)json;\n    buffer.length = strlen(json) + sizeof(\"\");\n    buffer.hooks = global_hooks;\n\n    TEST_ASSERT_TRUE(parse_array(item, &buffer));\n    assert_is_array(item);\n}",
          "fn_code_pos": [
            [
              55,
              0
            ],
            [
              64,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "assert_parse_array",
            "parameters": {
              "json": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_array_should_parse_empty_arrays(void)\n{\n    assert_parse_array(\"[]\");\n    assert_has_no_child(item);\n\n    assert_parse_array(\"[\\n\\t]\");\n    assert_has_no_child(item);\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              73,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_array_should_parse_empty_arrays",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_array_should_parse_arrays_with_one_element(void)\n{\n\n    assert_parse_array(\"[1]\");\n    assert_has_child(item);\n    assert_has_type(item->child, cJSON_Number);\n    reset(item);\n\n    assert_parse_array(\"[\\\"hello!\\\"]\");\n    assert_has_child(item);\n    assert_has_type(item->child, cJSON_String);\n    TEST_ASSERT_EQUAL_STRING(\"hello!\", item->child->valuestring);\n    reset(item);\n\n    assert_parse_array(\"[[]]\");\n    assert_has_child(item);\n    TEST_ASSERT_NOT_NULL(item->child);\n    assert_has_type(item->child, cJSON_Array);\n    assert_has_no_child(item->child);\n    reset(item);\n\n    assert_parse_array(\"[null]\");\n    assert_has_child(item);\n    assert_has_type(item->child, cJSON_NULL);\n    reset(item);\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              101,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_array_should_parse_arrays_with_one_element",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_array_should_parse_arrays_with_multiple_elements(void)\n{\n    assert_parse_array(\"[1\\t,\\n2, 3]\");\n    assert_has_child(item);\n    TEST_ASSERT_NOT_NULL(item->child->next);\n    TEST_ASSERT_NOT_NULL(item->child->next->next);\n    TEST_ASSERT_NULL(item->child->next->next->next);\n    assert_has_type(item->child, cJSON_Number);\n    assert_has_type(item->child->next, cJSON_Number);\n    assert_has_type(item->child->next->next, cJSON_Number);\n    reset(item);\n\n    {\n        size_t i = 0;\n        cJSON *node = NULL;\n        int expected_types[7] =\n        {\n            cJSON_Number,\n            cJSON_NULL,\n            cJSON_True,\n            cJSON_False,\n            cJSON_Array,\n            cJSON_String,\n            cJSON_Object\n        };\n        assert_parse_array(\"[1, null, true, false, [], \\\"hello\\\", {}]\");\n\n        node = item->child;\n        for (\n                i = 0;\n                (i < (sizeof(expected_types)/sizeof(int)))\n                && (node != NULL);\n                (void)i++, node = node->next)\n        {\n            TEST_ASSERT_BITS(0xFF, expected_types[i], node->type);\n        }\n        TEST_ASSERT_EQUAL_INT(i, 7);\n        reset(item);\n    }\n}",
          "fn_code_pos": [
            [
              103,
              0
            ],
            [
              142,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_array_should_parse_arrays_with_multiple_elements",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void parse_array_should_not_parse_non_arrays(void)\n{\n    assert_not_array(\"\");\n    assert_not_array(\"[\");\n    assert_not_array(\"]\");\n    assert_not_array(\"{\\\"hello\\\":[]}\");\n    assert_not_array(\"42\");\n    assert_not_array(\"3.14\");\n    assert_not_array(\"\\\"[]hello world!\\n\\\"\");\n}",
          "fn_code_pos": [
            [
              144,
              0
            ],
            [
              153,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_array_should_not_parse_non_arrays",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int CJSON_CDECL main(void)\n{\n    /* initialize cJSON item */\n    memset(item, 0, sizeof(cJSON));\n\n    UNITY_BEGIN();\n    RUN_TEST(parse_array_should_parse_empty_arrays);\n    RUN_TEST(parse_array_should_parse_arrays_with_one_element);\n    RUN_TEST(parse_array_should_parse_arrays_with_multiple_elements);\n    RUN_TEST(parse_array_should_not_parse_non_arrays);\n    return UNITY_END();\n}",
          "fn_code_pos": [
            [
              155,
              0
            ],
            [
              166,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_CDECL main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"unity/examples/unity_config.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"unity/src/unity.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"common.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/src/unity.c": {
      "fn_def_list": [
        {
          "fn_code": "void UnityPrint(const char* string)\n{\n    const char* pch = string;\n\n    if (pch != NULL)\n    {\n        while (*pch)\n        {\n            /* printable characters plus CR & LF are printed */\n            if ((*pch <= 126) && (*pch >= 32))\n            {\n                UNITY_OUTPUT_CHAR(*pch);\n            }\n            /* write escaped carriage returns */\n            else if (*pch == 13)\n            {\n                UNITY_OUTPUT_CHAR('\\\\');\n                UNITY_OUTPUT_CHAR('r');\n            }\n            /* write escaped line feeds */\n            else if (*pch == 10)\n            {\n                UNITY_OUTPUT_CHAR('\\\\');\n                UNITY_OUTPUT_CHAR('n');\n            }\n#ifdef UNITY_OUTPUT_COLOR\n            /* print ANSI escape code */\n            else if (*pch == 27 && *(pch + 1) == '[')\n            {\n                while (*pch && *pch != 'm')\n                {\n                    UNITY_OUTPUT_CHAR(*pch);\n                    pch++;\n                }\n                UNITY_OUTPUT_CHAR('m');\n            }\n#endif\n            /* unprintable characters are shown as codes */\n            else\n            {\n                UNITY_OUTPUT_CHAR('\\\\');\n                UNITY_OUTPUT_CHAR('x');\n                UnityPrintNumberHex((UNITY_UINT)*pch, 2);\n            }\n            pch++;\n        }\n    }",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              115,
              5
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPrint",
            "parameters": {
              "string": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityPrintLen(const char* string, const UNITY_UINT32 length)\n{\n    const char* pch = string;\n\n    if (pch != NULL)\n    {\n        while (*pch && (UNITY_UINT32)(pch - string) < length)\n        {\n            /* printable characters plus CR & LF are printed */\n            if ((*pch <= 126) && (*pch >= 32))\n            {\n                UNITY_OUTPUT_CHAR(*pch);\n            }\n            /* write escaped carriage returns */\n            else if (*pch == 13)\n            {\n                UNITY_OUTPUT_CHAR('\\\\');\n                UNITY_OUTPUT_CHAR('r');\n            }\n            /* write escaped line feeds */\n            else if (*pch == 10)\n            {\n                UNITY_OUTPUT_CHAR('\\\\');\n                UNITY_OUTPUT_CHAR('n');\n            }\n            /* unprintable characters are shown as codes */\n            else\n            {\n                UNITY_OUTPUT_CHAR('\\\\');\n                UNITY_OUTPUT_CHAR('x');\n                UnityPrintNumberHex((UNITY_UINT)*pch, 2);\n            }\n            pch++;\n        }\n    }\n}",
          "fn_code_pos": [
            [
              118,
              0
            ],
            [
              153,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPrintLen",
            "parameters": {
              "string": "char",
              "length": "UNITY_UINT32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityPrintNumberByStyle(const UNITY_INT number, const UNITY_DISPLAY_STYLE_T style)\n{\n    if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)\n    {\n        UnityPrintNumber(number);\n    }\n    else if ((style & UNITY_DISPLAY_RANGE_UINT) == UNITY_DISPLAY_RANGE_UINT)\n    {\n        UnityPrintNumberUnsigned((UNITY_UINT)number);\n    }\n    else\n    {\n        UNITY_OUTPUT_CHAR('0');\n        UNITY_OUTPUT_CHAR('x');\n        UnityPrintNumberHex((UNITY_UINT)number, (char)((style & 0xF) * 2));\n    }\n}",
          "fn_code_pos": [
            [
              156,
              0
            ],
            [
              172,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPrintNumberByStyle",
            "parameters": {
              "number": "UNITY_INT",
              "style": "UNITY_DISPLAY_STYLE_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityPrintNumber(const UNITY_INT number_to_print)\n{\n    UNITY_UINT number = (UNITY_UINT)number_to_print;\n\n    if (number_to_print < 0)\n    {\n        /* A negative number, including MIN negative */\n        UNITY_OUTPUT_CHAR('-');\n        number = (UNITY_UINT)(-number_to_print);\n    }\n    UnityPrintNumberUnsigned(number);\n}",
          "fn_code_pos": [
            [
              175,
              0
            ],
            [
              186,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPrintNumber",
            "parameters": {
              "number_to_print": "UNITY_INT"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityPrintNumberUnsigned(const UNITY_UINT number)\n{\n    UNITY_UINT divisor = 1;\n\n    /* figure out initial divisor */\n    while (number / divisor > 9)\n    {\n        divisor *= 10;\n    }\n\n    /* now mod and print, then divide divisor */\n    do\n    {\n        UNITY_OUTPUT_CHAR((char)('0' + (number / divisor % 10)));\n        divisor /= 10;\n    } while (divisor > 0);\n}",
          "fn_code_pos": [
            [
              190,
              0
            ],
            [
              206,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPrintNumberUnsigned",
            "parameters": {
              "number": "UNITY_UINT"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityPrintNumberHex(const UNITY_UINT number, const char nibbles_to_print)\n{\n    int nibble;\n    char nibbles = nibbles_to_print;\n    if ((unsigned)nibbles > (2 * sizeof(number)))\n        nibbles = 2 * sizeof(number);\n\n    while (nibbles > 0)\n    {\n        nibbles--;\n        nibble = (int)(number >> (nibbles * 4)) & 0x0F;\n        if (nibble <= 9)\n        {\n            UNITY_OUTPUT_CHAR((char)('0' + nibble));\n        }\n        else\n        {\n            UNITY_OUTPUT_CHAR((char)('A' - 10 + nibble));\n        }\n    }\n}",
          "fn_code_pos": [
            [
              209,
              0
            ],
            [
              229,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPrintNumberHex",
            "parameters": {
              "number": "UNITY_UINT",
              "nibbles_to_print": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityPrintMask(const UNITY_UINT mask, const UNITY_UINT number)\n{\n    UNITY_UINT current_bit = (UNITY_UINT)1 << (UNITY_INT_WIDTH - 1);\n    UNITY_INT32 i;\n\n    for (i = 0; i < UNITY_INT_WIDTH; i++)\n    {\n        if (current_bit & mask)\n        {\n            if (current_bit & number)\n            {\n                UNITY_OUTPUT_CHAR('1');\n            }\n            else\n            {\n                UNITY_OUTPUT_CHAR('0');\n            }\n        }\n        else\n        {\n            UNITY_OUTPUT_CHAR('X');\n        }\n        current_bit = current_bit >> 1;\n    }\n}",
          "fn_code_pos": [
            [
              232,
              0
            ],
            [
              256,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPrintMask",
            "parameters": {
              "mask": "UNITY_UINT",
              "number": "UNITY_UINT"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityPrintFloat(const UNITY_DOUBLE input_number)\n{\n    UNITY_DOUBLE number = input_number;\n\n    /* print minus sign (including for negative zero) */\n    if (number < (double)0.0f || (number == (double)0.0f && (double)1.0f / number < (double)0.0f))\n    {\n        UNITY_OUTPUT_CHAR('-');\n        number = -number;\n    }\n\n    /* handle zero, NaN, and +/- infinity */\n    if (number == (double)0.0f) UnityPrint(\"0\");\n    else if (isnan(number)) UnityPrint(\"nan\");\n    else if (isinf(number)) UnityPrint(\"inf\");\n    else\n    {\n        int exponent = 0;\n        int decimals, digits;\n        UNITY_INT32 n;\n        char buf[16];\n\n        /* scale up or down by powers of 10 */\n        while (number < (double)(100000.0f / 1e6f))  { number *= (double)1e6f; exponent -= 6; }\n        while (number < (double)100000.0f)         { number *= (double)10.0f; exponent--; }\n        while (number > (double)(1000000.0f * 1e6f)) { number /= (double)1e6f; exponent += 6; }\n        while (number > (double)1000000.0f)        { number /= (double)10.0f; exponent++; }\n\n        /* round to nearest integer */\n        n = ((UNITY_INT32)(number + number) + 1) / 2;\n        if (n > 999999)\n        {\n            n = 100000;\n            exponent++;\n        }\n\n        /* determine where to place decimal point */\n        decimals = (exponent <= 0 && exponent >= -9) ? -exponent : 5;\n        exponent += decimals;\n\n        /* truncate trailing zeroes after decimal point */\n        while (decimals > 0 && n % 10 == 0)\n        {\n            n /= 10;\n            decimals--;\n        }\n\n        /* build up buffer in reverse order */\n        digits = 0;\n        while (n != 0 || digits < decimals + 1)\n        {\n            buf[digits++] = (char)('0' + n % 10);\n            n /= 10;\n        }\n        while (digits > 0)\n        {\n            if(digits == decimals) UNITY_OUTPUT_CHAR('.');\n            UNITY_OUTPUT_CHAR(buf[--digits]);\n        }\n\n        /* print exponent if needed */\n        if (exponent != 0)\n        {\n            UNITY_OUTPUT_CHAR('e');\n\n            if(exponent < 0)\n            {\n                UNITY_OUTPUT_CHAR('-');\n                exponent = -exponent;\n            }\n            else\n            {\n                UNITY_OUTPUT_CHAR('+');\n            }\n\n            digits = 0;\n            while (exponent != 0 || digits < 2)\n            {\n                buf[digits++] = (char)('0' + exponent % 10);\n                exponent /= 10;\n            }\n            while (digits > 0)\n            {\n                UNITY_OUTPUT_CHAR(buf[--digits]);\n            }\n        }\n    }\n}",
          "fn_code_pos": [
            [
              265,
              0
            ],
            [
              352,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPrintFloat",
            "parameters": {
              "input_number": "UNITY_DOUBLE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void UnityTestResultsBegin(const char* file, const UNITY_LINE_TYPE line)\n{\n    UnityPrint(file);\n    UNITY_OUTPUT_CHAR(':');\n    UnityPrintNumber((UNITY_INT)line);\n    UNITY_OUTPUT_CHAR(':');\n    UnityPrint(Unity.CurrentTestName);\n    UNITY_OUTPUT_CHAR(':');\n}",
          "fn_code_pos": [
            [
              356,
              0
            ],
            [
              364,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityTestResultsBegin",
            "parameters": {
              "file": "char",
              "line": "UNITY_LINE_TYPE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void UnityTestResultsFailBegin(const UNITY_LINE_TYPE line)\n{\n    UnityTestResultsBegin(Unity.TestFile, line);\n    UnityPrint(UnityStrFail);\n    UNITY_OUTPUT_CHAR(':');\n}",
          "fn_code_pos": [
            [
              367,
              0
            ],
            [
              372,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityTestResultsFailBegin",
            "parameters": {
              "line": "UNITY_LINE_TYPE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityConcludeTest(void)\n{\n    if (Unity.CurrentTestIgnored)\n    {\n        Unity.TestIgnores++;\n    }\n    else if (!Unity.CurrentTestFailed)\n    {\n        UnityTestResultsBegin(Unity.TestFile, Unity.CurrentTestLineNumber);\n        UnityPrint(UnityStrPass);\n    }\n    else\n    {\n        Unity.TestFailures++;\n    }\n\n    Unity.CurrentTestFailed = 0;\n    Unity.CurrentTestIgnored = 0;\n    UNITY_PRINT_EOL();\n    UNITY_FLUSH_CALL();\n}",
          "fn_code_pos": [
            [
              375,
              0
            ],
            [
              395,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityConcludeTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void UnityAddMsgIfSpecified(const char* msg)\n{\n    if (msg)\n    {\n        UnityPrint(UnityStrSpacer);\n#ifndef UNITY_EXCLUDE_DETAILS\n        if (Unity.CurrentDetail1)\n        {\n            UnityPrint(UnityStrDetail1Name);\n            UnityPrint(Unity.CurrentDetail1);\n            if (Unity.CurrentDetail2)\n            {\n                UnityPrint(UnityStrDetail2Name);\n                UnityPrint(Unity.CurrentDetail2);\n            }\n            UnityPrint(UnityStrSpacer);\n        }\n#endif\n        UnityPrint(msg);\n    }\n}",
          "fn_code_pos": [
            [
              398,
              0
            ],
            [
              418,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAddMsgIfSpecified",
            "parameters": {
              "msg": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void UnityPrintExpectedAndActualStrings(const char* expected, const char* actual)\n{\n    UnityPrint(UnityStrExpected);\n    if (expected != NULL)\n    {\n        UNITY_OUTPUT_CHAR('\\'');\n        UnityPrint(expected);\n        UNITY_OUTPUT_CHAR('\\'');\n    }\n    else\n    {\n        UnityPrint(UnityStrNull);\n    }\n    UnityPrint(UnityStrWas);\n    if (actual != NULL)\n    {\n        UNITY_OUTPUT_CHAR('\\'');\n        UnityPrint(actual);\n        UNITY_OUTPUT_CHAR('\\'');\n    }\n    else\n    {\n        UnityPrint(UnityStrNull);\n    }\n}",
          "fn_code_pos": [
            [
              421,
              0
            ],
            [
              445,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPrintExpectedAndActualStrings",
            "parameters": {
              "expected": "char",
              "actual": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void UnityPrintExpectedAndActualStringsLen(const char* expected,\n                                                  const char* actual,\n                                                  const UNITY_UINT32 length)\n{\n    UnityPrint(UnityStrExpected);\n    if (expected != NULL)\n    {\n        UNITY_OUTPUT_CHAR('\\'');\n        UnityPrintLen(expected, length);\n        UNITY_OUTPUT_CHAR('\\'');\n    }\n    else\n    {\n        UnityPrint(UnityStrNull);\n    }\n    UnityPrint(UnityStrWas);\n    if (actual != NULL)\n    {\n        UNITY_OUTPUT_CHAR('\\'');\n        UnityPrintLen(actual, length);\n        UNITY_OUTPUT_CHAR('\\'');\n    }\n    else\n    {\n        UnityPrint(UnityStrNull);\n    }\n}",
          "fn_code_pos": [
            [
              448,
              0
            ],
            [
              474,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPrintExpectedAndActualStringsLen",
            "parameters": {
              "expected": "char",
              "actual": "char",
              "length": "UNITY_UINT32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int UnityIsOneArrayNull(UNITY_INTERNAL_PTR expected,\n                               UNITY_INTERNAL_PTR actual,\n                               const UNITY_LINE_TYPE lineNumber,\n                               const char* msg)\n{\n    if (expected == actual) return 0; /* Both are NULL or same pointer */\n\n    /* print and return true if just expected is NULL */\n    if (expected == NULL)\n    {\n        UnityTestResultsFailBegin(lineNumber);\n        UnityPrint(UnityStrNullPointerForExpected);\n        UnityAddMsgIfSpecified(msg);\n        return 1;\n    }\n\n    /* print and return true if just actual is NULL */\n    if (actual == NULL)\n    {\n        UnityTestResultsFailBegin(lineNumber);\n        UnityPrint(UnityStrNullPointerForActual);\n        UnityAddMsgIfSpecified(msg);\n        return 1;\n    }\n\n    return 0; /* return false if neither is NULL */\n}",
          "fn_code_pos": [
            [
              480,
              0
            ],
            [
              506,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityIsOneArrayNull",
            "parameters": {
              "expected": "UNITY_INTERNAL_PTR",
              "actual": "UNITY_INTERNAL_PTR",
              "lineNumber": "UNITY_LINE_TYPE",
              "msg": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void UnityAssertBits(const UNITY_INT mask,\n                     const UNITY_INT expected,\n                     const UNITY_INT actual,\n                     const char* msg,\n                     const UNITY_LINE_TYPE lineNumber)\n{\n    RETURN_IF_FAIL_OR_IGNORE;\n\n    if ((mask & expected) != (mask & actual))\n    {\n        UnityTestResultsFailBegin(lineNumber);\n        UnityPrint(UnityStrExpected);\n        UnityPrintMask((UNITY_UINT)mask, (UNITY_UINT)expected);\n        UnityPrint(UnityStrWas);\n        UnityPrintMask((UNITY_UINT)mask, (UNITY_UINT)actual);\n        UnityAddMsgIfSpecified(msg);\n        UNITY_FAIL_AND_BAIL;\n    }\n}",
          "fn_code_pos": [
            [
              512,
              0
            ],
            [
              530,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertBits",
            "parameters": {
              "mask": "UNITY_INT",
              "expected": "UNITY_INT",
              "actual": "UNITY_INT",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityAssertEqualNumber(const UNITY_INT expected,\n                            const UNITY_INT actual,\n                            const char* msg,\n                            const UNITY_LINE_TYPE lineNumber,\n                            const UNITY_DISPLAY_STYLE_T style)\n{\n    RETURN_IF_FAIL_OR_IGNORE;\n\n    if (expected != actual)\n    {\n        UnityTestResultsFailBegin(lineNumber);\n        UnityPrint(UnityStrExpected);\n        UnityPrintNumberByStyle(expected, style);\n        UnityPrint(UnityStrWas);\n        UnityPrintNumberByStyle(actual, style);\n        UnityAddMsgIfSpecified(msg);\n        UNITY_FAIL_AND_BAIL;\n    }\n}",
          "fn_code_pos": [
            [
              533,
              0
            ],
            [
              551,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertEqualNumber",
            "parameters": {
              "expected": "UNITY_INT",
              "actual": "UNITY_INT",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "style": "UNITY_DISPLAY_STYLE_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityAssertGreaterOrLessOrEqualNumber(const UNITY_INT threshold,\n                                           const UNITY_INT actual,\n                                           const UNITY_COMPARISON_T compare,\n                                           const char *msg,\n                                           const UNITY_LINE_TYPE lineNumber,\n                                           const UNITY_DISPLAY_STYLE_T style)\n{\n    int failed = 0;\n    RETURN_IF_FAIL_OR_IGNORE;\n\n    if (threshold == actual && compare & UNITY_EQUAL_TO) return;\n    if (threshold == actual) failed = 1;\n\n    if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)\n    {\n        if (actual > threshold && compare & UNITY_SMALLER_THAN) failed = 1;\n        if (actual < threshold && compare & UNITY_GREATER_THAN) failed = 1;\n    }\n    else /* UINT or HEX */\n    {\n        if ((UNITY_UINT)actual > (UNITY_UINT)threshold && compare & UNITY_SMALLER_THAN) failed = 1;\n        if ((UNITY_UINT)actual < (UNITY_UINT)threshold && compare & UNITY_GREATER_THAN) failed = 1;\n    }\n\n    if (failed)\n    {\n        UnityTestResultsFailBegin(lineNumber);\n        UnityPrint(UnityStrExpected);\n        UnityPrintNumberByStyle(actual, style);\n        if (compare & UNITY_GREATER_THAN) UnityPrint(UnityStrGt);\n        if (compare & UNITY_SMALLER_THAN) UnityPrint(UnityStrLt);\n        if (compare & UNITY_EQUAL_TO)     UnityPrint(UnityStrOrEqual);\n        UnityPrintNumberByStyle(threshold, style);\n        UnityAddMsgIfSpecified(msg);\n        UNITY_FAIL_AND_BAIL;\n    }\n}",
          "fn_code_pos": [
            [
              554,
              0
            ],
            [
              590,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertGreaterOrLessOrEqualNumber",
            "parameters": {
              "threshold": "UNITY_INT",
              "actual": "UNITY_INT",
              "compare": "UNITY_COMPARISON_T",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "style": "UNITY_DISPLAY_STYLE_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityAssertEqualIntArray(UNITY_INTERNAL_PTR expected,\n                              UNITY_INTERNAL_PTR actual,\n                              const UNITY_UINT32 num_elements,\n                              const char* msg,\n                              const UNITY_LINE_TYPE lineNumber,\n                              const UNITY_DISPLAY_STYLE_T style,\n                              const UNITY_FLAGS_T flags)\n{\n    UNITY_UINT32 elements = num_elements;\n    unsigned int length   = style & 0xF;\n\n    RETURN_IF_FAIL_OR_IGNORE;\n\n    if (num_elements == 0)\n    {\n        UnityPrintPointlessAndBail();\n    }\n\n    if (expected == actual) return; /* Both are NULL or same pointer */\n    if (UnityIsOneArrayNull(expected, actual, lineNumber, msg))\n        UNITY_FAIL_AND_BAIL;\n\n    while (elements--)\n    {\n        UNITY_INT expect_val;\n        UNITY_INT actual_val;\n        switch (length)\n        {\n            case 1:\n                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT8*)expected;\n                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT8*)actual;\n                break;\n            case 2:\n                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT16*)expected;\n                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT16*)actual;\n                break;\n#ifdef UNITY_SUPPORT_64\n            case 8:\n                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT64*)expected;\n                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT64*)actual;\n                break;\n#endif\n            default: /* length 4 bytes */\n                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT32*)expected;\n                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT32*)actual;\n                length = 4;\n                break;\n        }\n\n        if (expect_val != actual_val)\n        {\n            if (style & UNITY_DISPLAY_RANGE_UINT && length < sizeof(expect_val))\n            {   /* For UINT, remove sign extension (padding 1's) from signed type casts above */\n                UNITY_INT mask = 1;\n                mask = (mask << 8 * length) - 1;\n                expect_val &= mask;\n                actual_val &= mask;\n            }\n            UnityTestResultsFailBegin(lineNumber);\n            UnityPrint(UnityStrElement);\n            UnityPrintNumberUnsigned(num_elements - elements - 1);\n            UnityPrint(UnityStrExpected);\n            UnityPrintNumberByStyle(expect_val, style);\n            UnityPrint(UnityStrWas);\n            UnityPrintNumberByStyle(actual_val, style);\n            UnityAddMsgIfSpecified(msg);\n            UNITY_FAIL_AND_BAIL;\n        }\n        if (flags == UNITY_ARRAY_TO_ARRAY)\n        {\n            expected = (UNITY_INTERNAL_PTR)(length + (const char*)expected);\n        }\n        actual   = (UNITY_INTERNAL_PTR)(length + (const char*)actual);\n    }\n}",
          "fn_code_pos": [
            [
              600,
              0
            ],
            [
              674,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertEqualIntArray",
            "parameters": {
              "expected": "UNITY_INTERNAL_PTR",
              "actual": "UNITY_INTERNAL_PTR",
              "num_elements": "UNITY_UINT32",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "style": "UNITY_DISPLAY_STYLE_T",
              "flags": "UNITY_FLAGS_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int UnityFloatsWithin(UNITY_FLOAT delta, UNITY_FLOAT expected, UNITY_FLOAT actual)\n{\n    UNITY_FLOAT diff;\n    UNITY_FLOAT_OR_DOUBLE_WITHIN(delta, expected, actual, diff);\n}",
          "fn_code_pos": [
            [
              705,
              0
            ],
            [
              709,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityFloatsWithin",
            "parameters": {
              "delta": "UNITY_FLOAT",
              "expected": "UNITY_FLOAT",
              "actual": "UNITY_FLOAT"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void UnityAssertEqualFloatArray(UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* expected,\n                                UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* actual,\n                                const UNITY_UINT32 num_elements,\n                                const char* msg,\n                                const UNITY_LINE_TYPE lineNumber,\n                                const UNITY_FLAGS_T flags)\n{\n    UNITY_UINT32 elements = num_elements;\n    UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* ptr_expected = expected;\n    UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* ptr_actual = actual;\n\n    RETURN_IF_FAIL_OR_IGNORE;\n\n    if (elements == 0)\n    {\n        UnityPrintPointlessAndBail();\n    }\n\n    if (expected == actual) return; /* Both are NULL or same pointer */\n    if (UnityIsOneArrayNull((UNITY_INTERNAL_PTR)expected, (UNITY_INTERNAL_PTR)actual, lineNumber, msg))\n        UNITY_FAIL_AND_BAIL;\n\n    while (elements--)\n    {\n        if (!UnityFloatsWithin(*ptr_expected * UNITY_FLOAT_PRECISION, *ptr_expected, *ptr_actual))\n        {\n            UnityTestResultsFailBegin(lineNumber);\n            UnityPrint(UnityStrElement);\n            UnityPrintNumberUnsigned(num_elements - elements - 1);\n            UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT((UNITY_DOUBLE)*ptr_expected, (UNITY_DOUBLE)*ptr_actual);\n            UnityAddMsgIfSpecified(msg);\n            UNITY_FAIL_AND_BAIL;\n        }\n        if (flags == UNITY_ARRAY_TO_ARRAY)\n        {\n            ptr_expected++;\n        }\n        ptr_actual++;\n    }\n}",
          "fn_code_pos": [
            [
              711,
              0
            ],
            [
              750,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertEqualFloatArray",
            "parameters": {
              "num_elements": "UNITY_UINT32",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "flags": "UNITY_FLAGS_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityAssertFloatsWithin(const UNITY_FLOAT delta,\n                             const UNITY_FLOAT expected,\n                             const UNITY_FLOAT actual,\n                             const char* msg,\n                             const UNITY_LINE_TYPE lineNumber)\n{\n    RETURN_IF_FAIL_OR_IGNORE;\n\n\n    if (!UnityFloatsWithin(delta, expected, actual))\n    {\n        UnityTestResultsFailBegin(lineNumber);\n        UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT((UNITY_DOUBLE)expected, (UNITY_DOUBLE)actual);\n        UnityAddMsgIfSpecified(msg);\n        UNITY_FAIL_AND_BAIL;\n    }\n}",
          "fn_code_pos": [
            [
              753,
              0
            ],
            [
              769,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertFloatsWithin",
            "parameters": {
              "delta": "UNITY_FLOAT",
              "expected": "UNITY_FLOAT",
              "actual": "UNITY_FLOAT",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityAssertFloatSpecial(const UNITY_FLOAT actual,\n                             const char* msg,\n                             const UNITY_LINE_TYPE lineNumber,\n                             const UNITY_FLOAT_TRAIT_T style)\n{\n    const char* trait_names[] = {UnityStrInf, UnityStrNegInf, UnityStrNaN, UnityStrDet};\n    UNITY_INT should_be_trait = ((UNITY_INT)style & 1);\n    UNITY_INT is_trait        = !should_be_trait;\n    UNITY_INT trait_index     = (UNITY_INT)(style >> 1);\n\n    RETURN_IF_FAIL_OR_IGNORE;\n\n    switch (style)\n    {\n        case UNITY_FLOAT_IS_INF:\n        case UNITY_FLOAT_IS_NOT_INF:\n            is_trait = isinf(actual) && (actual > 0);\n            break;\n        case UNITY_FLOAT_IS_NEG_INF:\n        case UNITY_FLOAT_IS_NOT_NEG_INF:\n            is_trait = isinf(actual) && (actual < 0);\n            break;\n\n        case UNITY_FLOAT_IS_NAN:\n        case UNITY_FLOAT_IS_NOT_NAN:\n            is_trait = isnan(actual) ? 1 : 0;\n            break;\n\n        case UNITY_FLOAT_IS_DET: /* A determinate number is non infinite and not NaN. */\n        case UNITY_FLOAT_IS_NOT_DET:\n            is_trait = !isinf(actual) && !isnan(actual);\n            break;\n\n        default:\n            trait_index = 0;\n            trait_names[0] = UnityStrInvalidFloatTrait;\n            break;\n    }\n\n    if (is_trait != should_be_trait)\n    {\n        UnityTestResultsFailBegin(lineNumber);\n        UnityPrint(UnityStrExpected);\n        if (!should_be_trait)\n            UnityPrint(UnityStrNot);\n        UnityPrint(trait_names[trait_index]);\n        UnityPrint(UnityStrWas);\n#ifndef UNITY_EXCLUDE_FLOAT_PRINT\n        UnityPrintFloat((UNITY_DOUBLE)actual);\n#else\n        if (should_be_trait)\n            UnityPrint(UnityStrNot);\n        UnityPrint(trait_names[trait_index]);\n#endif\n        UnityAddMsgIfSpecified(msg);\n        UNITY_FAIL_AND_BAIL;\n    }\n}",
          "fn_code_pos": [
            [
              772,
              0
            ],
            [
              829,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertFloatSpecial",
            "parameters": {
              "actual": "UNITY_FLOAT",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "style": "UNITY_FLOAT_TRAIT_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int UnityDoublesWithin(UNITY_DOUBLE delta, UNITY_DOUBLE expected, UNITY_DOUBLE actual)\n{\n    UNITY_DOUBLE diff;\n    UNITY_FLOAT_OR_DOUBLE_WITHIN(delta, expected, actual, diff);\n}",
          "fn_code_pos": [
            [
              835,
              0
            ],
            [
              839,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityDoublesWithin",
            "parameters": {
              "delta": "UNITY_DOUBLE",
              "expected": "UNITY_DOUBLE",
              "actual": "UNITY_DOUBLE"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void UnityAssertEqualDoubleArray(UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* expected,\n                                 UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* actual,\n                                 const UNITY_UINT32 num_elements,\n                                 const char* msg,\n                                 const UNITY_LINE_TYPE lineNumber,\n                                 const UNITY_FLAGS_T flags)\n{\n    UNITY_UINT32 elements = num_elements;\n    UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* ptr_expected = expected;\n    UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* ptr_actual = actual;\n\n    RETURN_IF_FAIL_OR_IGNORE;\n\n    if (elements == 0)\n    {\n        UnityPrintPointlessAndBail();\n    }\n\n    if (expected == actual) return; /* Both are NULL or same pointer */\n    if (UnityIsOneArrayNull((UNITY_INTERNAL_PTR)expected, (UNITY_INTERNAL_PTR)actual, lineNumber, msg))\n        UNITY_FAIL_AND_BAIL;\n\n    while (elements--)\n    {\n        if (!UnityDoublesWithin(*ptr_expected * UNITY_DOUBLE_PRECISION, *ptr_expected, *ptr_actual))\n        {\n            UnityTestResultsFailBegin(lineNumber);\n            UnityPrint(UnityStrElement);\n            UnityPrintNumberUnsigned(num_elements - elements - 1);\n            UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT(*ptr_expected, *ptr_actual);\n            UnityAddMsgIfSpecified(msg);\n            UNITY_FAIL_AND_BAIL;\n        }\n        if (flags == UNITY_ARRAY_TO_ARRAY)\n        {\n            ptr_expected++;\n        }\n        ptr_actual++;\n    }\n}",
          "fn_code_pos": [
            [
              841,
              0
            ],
            [
              880,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertEqualDoubleArray",
            "parameters": {
              "num_elements": "UNITY_UINT32",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "flags": "UNITY_FLAGS_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityAssertDoublesWithin(const UNITY_DOUBLE delta,\n                              const UNITY_DOUBLE expected,\n                              const UNITY_DOUBLE actual,\n                              const char* msg,\n                              const UNITY_LINE_TYPE lineNumber)\n{\n    RETURN_IF_FAIL_OR_IGNORE;\n\n    if (!UnityDoublesWithin(delta, expected, actual))\n    {\n        UnityTestResultsFailBegin(lineNumber);\n        UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT(expected, actual);\n        UnityAddMsgIfSpecified(msg);\n        UNITY_FAIL_AND_BAIL;\n    }\n}",
          "fn_code_pos": [
            [
              883,
              0
            ],
            [
              898,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertDoublesWithin",
            "parameters": {
              "delta": "UNITY_DOUBLE",
              "expected": "UNITY_DOUBLE",
              "actual": "UNITY_DOUBLE",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityAssertDoubleSpecial(const UNITY_DOUBLE actual,\n                              const char* msg,\n                              const UNITY_LINE_TYPE lineNumber,\n                              const UNITY_FLOAT_TRAIT_T style)\n{\n    const char* trait_names[] = {UnityStrInf, UnityStrNegInf, UnityStrNaN, UnityStrDet};\n    UNITY_INT should_be_trait = ((UNITY_INT)style & 1);\n    UNITY_INT is_trait        = !should_be_trait;\n    UNITY_INT trait_index     = (UNITY_INT)(style >> 1);\n\n    RETURN_IF_FAIL_OR_IGNORE;\n\n    switch (style)\n    {\n        case UNITY_FLOAT_IS_INF:\n        case UNITY_FLOAT_IS_NOT_INF:\n            is_trait = isinf(actual) && (actual > 0);\n            break;\n        case UNITY_FLOAT_IS_NEG_INF:\n        case UNITY_FLOAT_IS_NOT_NEG_INF:\n            is_trait = isinf(actual) && (actual < 0);\n            break;\n\n        case UNITY_FLOAT_IS_NAN:\n        case UNITY_FLOAT_IS_NOT_NAN:\n            is_trait = isnan(actual) ? 1 : 0;\n            break;\n\n        case UNITY_FLOAT_IS_DET: /* A determinate number is non infinite and not NaN. */\n        case UNITY_FLOAT_IS_NOT_DET:\n            is_trait = !isinf(actual) && !isnan(actual);\n            break;\n\n        default:\n            trait_index = 0;\n            trait_names[0] = UnityStrInvalidFloatTrait;\n            break;\n    }\n\n    if (is_trait != should_be_trait)\n    {\n        UnityTestResultsFailBegin(lineNumber);\n        UnityPrint(UnityStrExpected);\n        if (!should_be_trait)\n            UnityPrint(UnityStrNot);\n        UnityPrint(trait_names[trait_index]);\n        UnityPrint(UnityStrWas);\n#ifndef UNITY_EXCLUDE_FLOAT_PRINT\n        UnityPrintFloat(actual);\n#else\n        if (should_be_trait)\n            UnityPrint(UnityStrNot);\n        UnityPrint(trait_names[trait_index]);\n#endif\n        UnityAddMsgIfSpecified(msg);\n        UNITY_FAIL_AND_BAIL;\n    }\n}",
          "fn_code_pos": [
            [
              902,
              0
            ],
            [
              959,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertDoubleSpecial",
            "parameters": {
              "actual": "UNITY_DOUBLE",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "style": "UNITY_FLOAT_TRAIT_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityAssertNumbersWithin(const UNITY_UINT delta,\n                              const UNITY_INT expected,\n                              const UNITY_INT actual,\n                              const char* msg,\n                              const UNITY_LINE_TYPE lineNumber,\n                              const UNITY_DISPLAY_STYLE_T style)\n{\n    RETURN_IF_FAIL_OR_IGNORE;\n\n    if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)\n    {\n        if (actual > expected)\n          Unity.CurrentTestFailed = (UNITY_UINT)((UNITY_UINT)(actual - expected) > delta);\n        else\n            Unity.CurrentTestFailed = (UNITY_UINT)((UNITY_UINT)(expected - actual) > delta);\n    }\n    else\n    {\n        if ((UNITY_UINT)actual > (UNITY_UINT)expected)\n            Unity.CurrentTestFailed = (UNITY_UINT)((UNITY_UINT)(actual - expected) > delta);\n        else\n            Unity.CurrentTestFailed = (UNITY_UINT)((UNITY_UINT)(expected - actual) > delta);\n    }\n\n    if (Unity.CurrentTestFailed)\n    {\n        UnityTestResultsFailBegin(lineNumber);\n        UnityPrint(UnityStrDelta);\n        UnityPrintNumberByStyle((UNITY_INT)delta, style);\n        UnityPrint(UnityStrExpected);\n        UnityPrintNumberByStyle(expected, style);\n        UnityPrint(UnityStrWas);\n        UnityPrintNumberByStyle(actual, style);\n        UnityAddMsgIfSpecified(msg);\n        UNITY_FAIL_AND_BAIL;\n    }\n}",
          "fn_code_pos": [
            [
              964,
              0
            ],
            [
              1000,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertNumbersWithin",
            "parameters": {
              "delta": "UNITY_UINT",
              "expected": "UNITY_INT",
              "actual": "UNITY_INT",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "style": "UNITY_DISPLAY_STYLE_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityAssertEqualString(const char* expected,\n                            const char* actual,\n                            const char* msg,\n                            const UNITY_LINE_TYPE lineNumber)\n{\n    UNITY_UINT32 i;\n\n    RETURN_IF_FAIL_OR_IGNORE;\n\n    /* if both pointers not null compare the strings */\n    if (expected && actual)\n    {\n        for (i = 0; expected[i] || actual[i]; i++)\n        {\n            if (expected[i] != actual[i])\n            {\n                Unity.CurrentTestFailed = 1;\n                break;\n            }\n        }\n    }\n    else\n    { /* handle case of one pointers being null (if both null, test should pass) */\n        if (expected != actual)\n        {\n            Unity.CurrentTestFailed = 1;\n        }\n    }\n\n    if (Unity.CurrentTestFailed)\n    {\n        UnityTestResultsFailBegin(lineNumber);\n        UnityPrintExpectedAndActualStrings(expected, actual);\n        UnityAddMsgIfSpecified(msg);\n        UNITY_FAIL_AND_BAIL;\n    }\n}",
          "fn_code_pos": [
            [
              1003,
              0
            ],
            [
              1039,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertEqualString",
            "parameters": {
              "expected": "char",
              "actual": "char",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityAssertEqualStringLen(const char* expected,\n                               const char* actual,\n                               const UNITY_UINT32 length,\n                               const char* msg,\n                               const UNITY_LINE_TYPE lineNumber)\n{\n    UNITY_UINT32 i;\n\n    RETURN_IF_FAIL_OR_IGNORE;\n\n    /* if both pointers not null compare the strings */\n    if (expected && actual)\n    {\n        for (i = 0; (i < length) && (expected[i] || actual[i]); i++)\n        {\n            if (expected[i] != actual[i])\n            {\n                Unity.CurrentTestFailed = 1;\n                break;\n            }\n        }\n    }\n    else\n    { /* handle case of one pointers being null (if both null, test should pass) */\n        if (expected != actual)\n        {\n            Unity.CurrentTestFailed = 1;\n        }\n    }\n\n    if (Unity.CurrentTestFailed)\n    {\n        UnityTestResultsFailBegin(lineNumber);\n        UnityPrintExpectedAndActualStringsLen(expected, actual, length);\n        UnityAddMsgIfSpecified(msg);\n        UNITY_FAIL_AND_BAIL;\n    }\n}",
          "fn_code_pos": [
            [
              1042,
              0
            ],
            [
              1079,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertEqualStringLen",
            "parameters": {
              "expected": "char",
              "actual": "char",
              "length": "UNITY_UINT32",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityAssertEqualStringArray(UNITY_INTERNAL_PTR expected,\n                                 const char** actual,\n                                 const UNITY_UINT32 num_elements,\n                                 const char* msg,\n                                 const UNITY_LINE_TYPE lineNumber,\n                                 const UNITY_FLAGS_T flags)\n{\n    UNITY_UINT32 i = 0;\n    UNITY_UINT32 j = 0;\n    const char* expd = NULL;\n    const char* act = NULL;\n\n    RETURN_IF_FAIL_OR_IGNORE;\n\n    /* if no elements, it's an error */\n    if (num_elements == 0)\n    {\n        UnityPrintPointlessAndBail();\n    }\n\n    if ((const void*)expected == (const void*)actual)\n    {\n        return; /* Both are NULL or same pointer */\n    }\n\n    if (UnityIsOneArrayNull((UNITY_INTERNAL_PTR)expected, (UNITY_INTERNAL_PTR)actual, lineNumber, msg))\n    {\n        UNITY_FAIL_AND_BAIL;\n    }\n\n    if (flags != UNITY_ARRAY_TO_ARRAY)\n    {\n        expd = (const char*)expected;\n    }\n\n    do\n    {\n        act = actual[j];\n        if (flags == UNITY_ARRAY_TO_ARRAY)\n        {\n            expd = ((const char* const*)expected)[j];\n        }\n\n        /* if both pointers not null compare the strings */\n        if (expd && act)\n        {\n            for (i = 0; expd[i] || act[i]; i++)\n            {\n                if (expd[i] != act[i])\n                {\n                    Unity.CurrentTestFailed = 1;\n                    break;\n                }\n            }\n        }\n        else\n        { /* handle case of one pointers being null (if both null, test should pass) */\n            if (expd != act)\n            {\n                Unity.CurrentTestFailed = 1;\n            }\n        }\n\n        if (Unity.CurrentTestFailed)\n        {\n            UnityTestResultsFailBegin(lineNumber);\n            if (num_elements > 1)\n            {\n                UnityPrint(UnityStrElement);\n                UnityPrintNumberUnsigned(j);\n            }\n            UnityPrintExpectedAndActualStrings(expd, act);\n            UnityAddMsgIfSpecified(msg);\n            UNITY_FAIL_AND_BAIL;\n        }\n    } while (++j < num_elements);\n}",
          "fn_code_pos": [
            [
              1082,
              0
            ],
            [
              1158,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertEqualStringArray",
            "parameters": {
              "expected": "UNITY_INTERNAL_PTR",
              "actual": "char",
              "num_elements": "UNITY_UINT32",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "flags": "UNITY_FLAGS_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityAssertEqualMemory(UNITY_INTERNAL_PTR expected,\n                            UNITY_INTERNAL_PTR actual,\n                            const UNITY_UINT32 length,\n                            const UNITY_UINT32 num_elements,\n                            const char* msg,\n                            const UNITY_LINE_TYPE lineNumber,\n                            const UNITY_FLAGS_T flags)\n{\n    UNITY_PTR_ATTRIBUTE const unsigned char* ptr_exp = (UNITY_PTR_ATTRIBUTE const unsigned char*)expected;\n    UNITY_PTR_ATTRIBUTE const unsigned char* ptr_act = (UNITY_PTR_ATTRIBUTE const unsigned char*)actual;\n    UNITY_UINT32 elements = num_elements;\n    UNITY_UINT32 bytes;\n\n    RETURN_IF_FAIL_OR_IGNORE;\n\n    if ((elements == 0) || (length == 0))\n    {\n        UnityPrintPointlessAndBail();\n    }\n\n    if (expected == actual) return; /* Both are NULL or same pointer */\n    if (UnityIsOneArrayNull(expected, actual, lineNumber, msg))\n        UNITY_FAIL_AND_BAIL;\n\n    while (elements--)\n    {\n        bytes = length;\n        while (bytes--)\n        {\n            if (*ptr_exp != *ptr_act)\n            {\n                UnityTestResultsFailBegin(lineNumber);\n                UnityPrint(UnityStrMemory);\n                if (num_elements > 1)\n                {\n                    UnityPrint(UnityStrElement);\n                    UnityPrintNumberUnsigned(num_elements - elements - 1);\n                }\n                UnityPrint(UnityStrByte);\n                UnityPrintNumberUnsigned(length - bytes - 1);\n                UnityPrint(UnityStrExpected);\n                UnityPrintNumberByStyle(*ptr_exp, UNITY_DISPLAY_STYLE_HEX8);\n                UnityPrint(UnityStrWas);\n                UnityPrintNumberByStyle(*ptr_act, UNITY_DISPLAY_STYLE_HEX8);\n                UnityAddMsgIfSpecified(msg);\n                UNITY_FAIL_AND_BAIL;\n            }\n            ptr_exp++;\n            ptr_act++;\n        }\n        if (flags == UNITY_ARRAY_TO_VAL)\n        {\n            ptr_exp = (UNITY_PTR_ATTRIBUTE const unsigned char*)expected;\n        }\n    }\n}",
          "fn_code_pos": [
            [
              1161,
              0
            ],
            [
              1216,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertEqualMemory",
            "parameters": {
              "expected": "UNITY_INTERNAL_PTR",
              "actual": "UNITY_INTERNAL_PTR",
              "length": "UNITY_UINT32",
              "num_elements": "UNITY_UINT32",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "flags": "UNITY_FLAGS_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UNITY_INTERNAL_PTR UnityNumToPtr(const UNITY_INT num, const UNITY_UINT8 size)\n{\n    switch(size)\n    {\n        case 1:\n          UnityQuickCompare.i8 = (UNITY_INT8)num;\n          return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i8);\n\n        case 2:\n          UnityQuickCompare.i16 = (UNITY_INT16)num;\n          return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i16);\n\n#ifdef UNITY_SUPPORT_64\n        case 8:\n          UnityQuickCompare.i64 = (UNITY_INT64)num;\n          return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i64);\n#endif\n        default: /* 4 bytes */\n          UnityQuickCompare.i32 = (UNITY_INT32)num;\n          return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i32);\n    }\n}",
          "fn_code_pos": [
            [
              1236,
              0
            ],
            [
              1257,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityNumToPtr",
            "parameters": {
              "num": "UNITY_INT",
              "size": "UNITY_UINT8"
            },
            "return_type": "UNITY_INTERNAL_PTR"
          }
        },
        {
          "fn_code": "UNITY_INTERNAL_PTR UnityFloatToPtr(const float num)\n{\n    UnityQuickCompare.f = num;\n    return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.f);\n}",
          "fn_code_pos": [
            [
              1260,
              0
            ],
            [
              1264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityFloatToPtr",
            "parameters": {
              "num": "float"
            },
            "return_type": "UNITY_INTERNAL_PTR"
          }
        },
        {
          "fn_code": "UNITY_INTERNAL_PTR UnityDoubleToPtr(const double num)\n{\n    UnityQuickCompare.d = num;\n    return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.d);\n}",
          "fn_code_pos": [
            [
              1268,
              0
            ],
            [
              1272,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityDoubleToPtr",
            "parameters": {
              "num": "double"
            },
            "return_type": "UNITY_INTERNAL_PTR"
          }
        },
        {
          "fn_code": "void UnityFail(const char* msg, const UNITY_LINE_TYPE line)\n{\n    RETURN_IF_FAIL_OR_IGNORE;\n\n    UnityTestResultsBegin(Unity.TestFile, line);\n    UnityPrint(UnityStrFail);\n    if (msg != NULL)\n    {\n        UNITY_OUTPUT_CHAR(':');\n\n#ifndef UNITY_EXCLUDE_DETAILS\n        if (Unity.CurrentDetail1)\n        {\n            UnityPrint(UnityStrDetail1Name);\n            UnityPrint(Unity.CurrentDetail1);\n            if (Unity.CurrentDetail2)\n            {\n                UnityPrint(UnityStrDetail2Name);\n                UnityPrint(Unity.CurrentDetail2);\n            }\n            UnityPrint(UnityStrSpacer);\n        }\n#endif\n        if (msg[0] != ' ')\n        {\n            UNITY_OUTPUT_CHAR(' ');\n        }\n        UnityPrint(msg);\n    }\n\n    UNITY_FAIL_AND_BAIL;\n}",
          "fn_code_pos": [
            [
              1279,
              0
            ],
            [
              1310,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityFail",
            "parameters": {
              "msg": "char",
              "line": "UNITY_LINE_TYPE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityIgnore(const char* msg, const UNITY_LINE_TYPE line)\n{\n    RETURN_IF_FAIL_OR_IGNORE;\n\n    UnityTestResultsBegin(Unity.TestFile, line);\n    UnityPrint(UnityStrIgnore);\n    if (msg != NULL)\n    {\n        UNITY_OUTPUT_CHAR(':');\n        UNITY_OUTPUT_CHAR(' ');\n        UnityPrint(msg);\n    }\n    UNITY_IGNORE_AND_BAIL;\n}",
          "fn_code_pos": [
            [
              1313,
              0
            ],
            [
              1326,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityIgnore",
            "parameters": {
              "msg": "char",
              "line": "UNITY_LINE_TYPE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityDefaultTestRun(UnityTestFunction Func, const char* FuncName, const int FuncLineNum)\n{\n    Unity.CurrentTestName = FuncName;\n    Unity.CurrentTestLineNumber = (UNITY_LINE_TYPE)FuncLineNum;\n    Unity.NumberOfTests++;\n    UNITY_CLR_DETAILS();\n    if (TEST_PROTECT())\n    {\n        setUp();\n        Func();\n    }\n    if (TEST_PROTECT())\n    {\n        tearDown();\n    }\n    UnityConcludeTest();\n}",
          "fn_code_pos": [
            [
              1329,
              0
            ],
            [
              1345,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityDefaultTestRun",
            "parameters": {
              "Func": "UnityTestFunction",
              "FuncName": "char",
              "FuncLineNum": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityBegin(const char* filename)\n{\n    Unity.TestFile = filename;\n    Unity.CurrentTestName = NULL;\n    Unity.CurrentTestLineNumber = 0;\n    Unity.NumberOfTests = 0;\n    Unity.TestFailures = 0;\n    Unity.TestIgnores = 0;\n    Unity.CurrentTestFailed = 0;\n    Unity.CurrentTestIgnored = 0;\n\n    UNITY_CLR_DETAILS();\n    UNITY_OUTPUT_START();\n}",
          "fn_code_pos": [
            [
              1348,
              0
            ],
            [
              1361,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityBegin",
            "parameters": {
              "filename": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int UnityEnd(void)\n{\n    UNITY_PRINT_EOL();\n    UnityPrint(UnityStrBreaker);\n    UNITY_PRINT_EOL();\n    UnityPrintNumber((UNITY_INT)(Unity.NumberOfTests));\n    UnityPrint(UnityStrResultsTests);\n    UnityPrintNumber((UNITY_INT)(Unity.TestFailures));\n    UnityPrint(UnityStrResultsFailures);\n    UnityPrintNumber((UNITY_INT)(Unity.TestIgnores));\n    UnityPrint(UnityStrResultsIgnored);\n    UNITY_PRINT_EOL();\n    if (Unity.TestFailures == 0U)\n    {\n        UnityPrint(UnityStrOk);\n    }\n    else\n    {\n        UnityPrint(UnityStrFail);\n#ifdef UNITY_DIFFERENTIATE_FINAL_FAIL\n        UNITY_OUTPUT_CHAR('E'); UNITY_OUTPUT_CHAR('D');\n#endif\n    }\n    UNITY_PRINT_EOL();\n    UNITY_FLUSH_CALL();\n    UNITY_OUTPUT_COMPLETE();\n    return (int)(Unity.TestFailures);\n}",
          "fn_code_pos": [
            [
              1364,
              0
            ],
            [
              1391,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityEnd",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int UnityParseOptions(int argc, char** argv)\n{\n    UnityOptionIncludeNamed = NULL;\n    UnityOptionExcludeNamed = NULL;\n\n    for (int i = 1; i < argc; i++)\n    {\n        if (argv[i][0] == '-')\n        {\n            switch (argv[i][1])\n            {\n                case 'l': /* list tests */\n                    return -1;\n                case 'n': /* include tests with name including this string */\n                case 'f': /* an alias for -n */\n                    if (argv[i][2] == '=')\n                        UnityOptionIncludeNamed = &argv[i][3];\n                    else if (++i < argc)\n                        UnityOptionIncludeNamed = argv[i];\n                    else\n                    {\n                        UnityPrint(\"ERROR: No Test String to Include Matches For\");\n                        UNITY_PRINT_EOL();\n                        return 1;\n                    }\n                    break;\n                case 'q': /* quiet */\n                    UnityVerbosity = 0;\n                    break;\n                case 'v': /* verbose */\n                    UnityVerbosity = 2;\n                    break;\n                case 'x': /* exclude tests with name including this string */\n                    if (argv[i][2] == '=')\n                        UnityOptionExcludeNamed = &argv[i][3];\n                    else if (++i < argc)\n                        UnityOptionExcludeNamed = argv[i];\n                    else\n                    {\n                        UnityPrint(\"ERROR: No Test String to Exclude Matches For\");\n                        UNITY_PRINT_EOL();\n                        return 1;\n                    }\n                    break;\n                default:\n                    UnityPrint(\"ERROR: Unknown Option \");\n                    UNITY_OUTPUT_CHAR(argv[i][1]);\n                    UNITY_PRINT_EOL();\n                    return 1;\n            }\n        }\n    }\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              1402,
              0
            ],
            [
              1456,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityParseOptions",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int IsStringInBiggerString(const char* longstring, const char* shortstring)\n{\n    const char* lptr = longstring;\n    const char* sptr = shortstring;\n    const char* lnext = lptr;\n\n    if (*sptr == '*')\n        return 1;\n\n    while (*lptr)\n    {\n        lnext = lptr + 1;\n\n        /* If they current bytes match, go on to the next bytes */\n        while (*lptr && *sptr && (*lptr == *sptr))\n        {\n            lptr++;\n            sptr++;\n\n            /* We're done if we match the entire string or up to a wildcard */\n            if (*sptr == '*')\n                return 1;\n            if (*sptr == ',')\n                return 1;\n            if (*sptr == '\"')\n                return 1;\n            if (*sptr == '\\'')\n                return 1;\n            if (*sptr == ':')\n                return 2;\n            if (*sptr == 0)\n                return 1;\n        }\n\n        /* Otherwise we start in the long pointer 1 character further and try again */\n        lptr = lnext;\n        sptr = shortstring;\n    }\n    return 0;\n}",
          "fn_code_pos": [
            [
              1458,
              0
            ],
            [
              1497,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "IsStringInBiggerString",
            "parameters": {
              "longstring": "char",
              "shortstring": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int UnityStringArgumentMatches(const char* str)\n{\n    int retval;\n    const char* ptr1;\n    const char* ptr2;\n    const char* ptrf;\n\n    /* Go through the options and get the substrings for matching one at a time */\n    ptr1 = str;\n    while (ptr1[0] != 0)\n    {\n        if ((ptr1[0] == '\"') || (ptr1[0] == '\\''))\n            ptr1++;\n\n        /* look for the start of the next partial */\n        ptr2 = ptr1;\n        ptrf = 0;\n        do\n        {\n            ptr2++;\n            if ((ptr2[0] == ':') && (ptr2[1] != 0) && (ptr2[0] != '\\'') && (ptr2[0] != '\"') && (ptr2[0] != ','))\n                ptrf = &ptr2[1];\n        } while ((ptr2[0] != 0) && (ptr2[0] != '\\'') && (ptr2[0] != '\"') && (ptr2[0] != ','));\n        while ((ptr2[0] != 0) && ((ptr2[0] == ':') || (ptr2[0] == '\\'') || (ptr2[0] == '\"') || (ptr2[0] == ',')))\n            ptr2++;\n\n        /* done if complete filename match */\n        retval = IsStringInBiggerString(Unity.TestFile, ptr1);\n        if (retval == 1)\n            return retval;\n\n        /* done if testname match after filename partial match */\n        if ((retval == 2) && (ptrf != 0))\n        {\n            if (IsStringInBiggerString(Unity.CurrentTestName, ptrf))\n                return 1;\n        }\n\n        /* done if complete testname match */\n        if (IsStringInBiggerString(Unity.CurrentTestName, ptr1) == 1)\n            return 1;\n\n        ptr1 = ptr2;\n    }\n\n    /* we couldn't find a match for any substrings */\n    return 0;\n}",
          "fn_code_pos": [
            [
              1499,
              0
            ],
            [
              1546,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityStringArgumentMatches",
            "parameters": {
              "str": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int UnityTestMatches(void)\n{\n    /* Check if this test name matches the included test pattern */\n    int retval;\n    if (UnityOptionIncludeNamed)\n    {\n        retval = UnityStringArgumentMatches(UnityOptionIncludeNamed);\n    }\n    else\n        retval = 1;\n\n    /* Check if this test name matches the excluded test pattern */\n    if (UnityOptionExcludeNamed)\n    {\n        if (UnityStringArgumentMatches(UnityOptionExcludeNamed))\n            retval = 0;\n    }\n    return retval;\n}",
          "fn_code_pos": [
            [
              1548,
              0
            ],
            [
              1566,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityTestMatches",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "UNITY_OUTPUT_CHAR(int)",
          "fn_dec_pos": [
            [
              12,
              5
            ],
            [
              12,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UNITY_OUTPUT_CHAR",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct UNITY_STORAGE_T",
          {},
          "",
          [
            20,
            0
          ],
          [
            20,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"unity.h\"\n",
          [
            7,
            0
          ],
          [
            8,
            0
          ]
        ],
        [
          "#include <stddef.h>\n",
          [
            8,
            0
          ],
          [
            9,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/examples/example_2/src/ProductionCode.c": {
      "fn_def_list": [
        {
          "fn_code": "int FindFunction_WhichIsBroken(int NumberToFind)\n{\n    int i = 0;\n    while (i <= 8) //Notice I should have been in braces\n        i++;\n        if (NumbersToFind[i] == NumberToFind) //Yikes!  I'm getting run after the loop finishes instead of during it!\n            return i;\n    return 0;\n}",
          "fn_code_pos": [
            [
              10,
              0
            ],
            [
              18,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FindFunction_WhichIsBroken",
            "parameters": {
              "NumberToFind": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int FunctionWhichReturnsLocalVariable(void)\n{\n    return Counter;\n}",
          "fn_code_pos": [
            [
              20,
              0
            ],
            [
              23,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FunctionWhichReturnsLocalVariable",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ProductionCode.h\"\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/examples/example_2/src/ProductionCode2.c": {
      "fn_def_list": [
        {
          "fn_code": "char* ThisFunctionHasNotBeenTested(int Poor, char* LittleFunction)\n{\n  (void)Poor;\n  (void)LittleFunction;\n  //Since There Are No Tests Yet, This Function Could Be Empty For All We Know.\n  // Which isn't terribly useful... but at least we put in a TEST_IGNORE so we won't forget\n  return (char*)0;\n}",
          "fn_code_pos": [
            [
              3,
              0
            ],
            [
              10,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ThisFunctionHasNotBeenTested",
            "parameters": {
              "Poor": "int",
              "LittleFunction": "char"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ThisFunctionHasNotBeenTested(int Poor, char* LittleFunction)",
          "fn_dec_pos": [
            [
              3,
              6
            ],
            [
              3,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ThisFunctionHasNotBeenTested",
            "parameters": {
              "Poor": "int",
              "LittleFunction": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ProductionCode2.h\"\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/examples/example_3/src/ProductionCode.c": {
      "fn_def_list": [
        {
          "fn_code": "int FindFunction_WhichIsBroken(int NumberToFind)\n{\n    int i = 0;\n    while (i <= 8) //Notice I should have been in braces\n        i++;\n        if (NumbersToFind[i] == NumberToFind) //Yikes!  I'm getting run after the loop finishes instead of during it!\n            return i;\n    return 0;\n}",
          "fn_code_pos": [
            [
              10,
              0
            ],
            [
              18,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FindFunction_WhichIsBroken",
            "parameters": {
              "NumberToFind": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int FunctionWhichReturnsLocalVariable(void)\n{\n    return Counter;\n}",
          "fn_code_pos": [
            [
              20,
              0
            ],
            [
              23,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FunctionWhichReturnsLocalVariable",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ProductionCode.h\"\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/examples/example_3/src/ProductionCode2.c": {
      "fn_def_list": [
        {
          "fn_code": "char* ThisFunctionHasNotBeenTested(int Poor, char* LittleFunction)\n{\n  (void)Poor;\n  (void)LittleFunction;\n  //Since There Are No Tests Yet, This Function Could Be Empty For All We Know.\n  // Which isn't terribly useful... but at least we put in a TEST_IGNORE so we won't forget\n  return (char*)0;\n}",
          "fn_code_pos": [
            [
              3,
              0
            ],
            [
              10,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ThisFunctionHasNotBeenTested",
            "parameters": {
              "Poor": "int",
              "LittleFunction": "char"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ThisFunctionHasNotBeenTested(int Poor, char* LittleFunction)",
          "fn_dec_pos": [
            [
              3,
              6
            ],
            [
              3,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ThisFunctionHasNotBeenTested",
            "parameters": {
              "Poor": "int",
              "LittleFunction": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ProductionCode2.h\"\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/examples/example_3/helper/UnityHelper.c": {
      "fn_def_list": [
        {
          "fn_code": "void AssertEqualExampleStruct(const EXAMPLE_STRUCT_T expected, const EXAMPLE_STRUCT_T actual, const unsigned short line)\n{\n    UNITY_TEST_ASSERT_EQUAL_INT(expected.x, actual.x, line, \"Example Struct Failed For Field x\");\n    UNITY_TEST_ASSERT_EQUAL_INT(expected.y, actual.y, line, \"Example Struct Failed For Field y\");\n}",
          "fn_code_pos": [
            [
              5,
              0
            ],
            [
              9,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AssertEqualExampleStruct",
            "parameters": {
              "expected": "EXAMPLE_STRUCT_T",
              "actual": "EXAMPLE_STRUCT_T",
              "line": "unsigned short"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"unity.h\"\n",
          [
            0,
            0
          ],
          [
            1,
            0
          ]
        ],
        [
          "#include \"UnityHelper.h\"\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            2,
            0
          ],
          [
            3,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            3,
            0
          ],
          [
            4,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/examples/example_1/src/ProductionCode.c": {
      "fn_def_list": [
        {
          "fn_code": "int FindFunction_WhichIsBroken(int NumberToFind)\n{\n    int i = 0;\n    while (i <= 8) /* Notice I should have been in braces */\n        i++;\n        if (NumbersToFind[i] == NumberToFind) /* Yikes!  I'm getting run after the loop finishes instead of during it! */\n            return i;\n    return 0;\n}",
          "fn_code_pos": [
            [
              10,
              0
            ],
            [
              18,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FindFunction_WhichIsBroken",
            "parameters": {
              "NumberToFind": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int FunctionWhichReturnsLocalVariable(void)\n{\n    return Counter;\n}",
          "fn_code_pos": [
            [
              20,
              0
            ],
            [
              23,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FunctionWhichReturnsLocalVariable",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ProductionCode.h\"\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/examples/example_1/src/ProductionCode2.c": {
      "fn_def_list": [
        {
          "fn_code": "char* ThisFunctionHasNotBeenTested(int Poor, char* LittleFunction)\n{\n  (void)Poor;\n  (void)LittleFunction;\n  /* Since There Are No Tests Yet, This Function Could Be Empty For All We Know.\n   * Which isn't terribly useful... but at least we put in a TEST_IGNORE so we won't forget */\n  return (char*)0;\n}",
          "fn_code_pos": [
            [
              3,
              0
            ],
            [
              10,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ThisFunctionHasNotBeenTested",
            "parameters": {
              "Poor": "int",
              "LittleFunction": "char"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ThisFunctionHasNotBeenTested(int Poor, char* LittleFunction)",
          "fn_dec_pos": [
            [
              3,
              6
            ],
            [
              3,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ThisFunctionHasNotBeenTested",
            "parameters": {
              "Poor": "int",
              "LittleFunction": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ProductionCode2.h\"\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/extras/fixture/src/unity_fixture.c": {
      "fn_def_list": [
        {
          "fn_code": "void setUp(void)    { /*does nothing*/ }",
          "fn_code_pos": [
            [
              18,
              0
            ],
            [
              18,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void tearDown(void) { /*does nothing*/ }",
          "fn_code_pos": [
            [
              19,
              0
            ],
            [
              19,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void announceTestRun(unsigned int runNumber)\n{\n    UnityPrint(\"Unity test run \");\n    UnityPrintNumberUnsigned(runNumber+1);\n    UnityPrint(\" of \");\n    UnityPrintNumberUnsigned(UnityFixture.RepeatCount);\n    UNITY_PRINT_EOL();\n}",
          "fn_code_pos": [
            [
              22,
              0
            ],
            [
              29,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "announceTestRun",
            "parameters": {
              "runNumber": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int UnityMain(int argc, const char* argv[], void (*runAllTests)(void))\n{\n    int result = UnityGetCommandLineOptions(argc, argv);\n    unsigned int r;\n    if (result != 0)\n        return result;\n\n    for (r = 0; r < UnityFixture.RepeatCount; r++)\n    {\n        UnityBegin(argv[0]);\n        announceTestRun(r);\n        runAllTests();\n        if (!UnityFixture.Verbose) UNITY_PRINT_EOL();\n        UnityEnd();\n    }\n\n    return (int)Unity.TestFailures;\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              48,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityMain",
            "parameters": {
              "argc": "int",
              "argv": "char",
              "runAllTests": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int selected(const char* filter, const char* name)\n{\n    if (filter == 0)\n        return 1;\n    return strstr(name, filter) ? 1 : 0;\n}",
          "fn_code_pos": [
            [
              50,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "selected",
            "parameters": {
              "filter": "char",
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int testSelected(const char* test)\n{\n    return selected(UnityFixture.NameFilter, test);\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "testSelected",
            "parameters": {
              "test": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int groupSelected(const char* group)\n{\n    return selected(UnityFixture.GroupFilter, group);\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "groupSelected",
            "parameters": {
              "group": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void UnityTestRunner(unityfunction* setup,\n                     unityfunction* testBody,\n                     unityfunction* teardown,\n                     const char* printableName,\n                     const char* group,\n                     const char* name,\n                     const char* file,\n                     unsigned int line)\n{\n    if (testSelected(name) && groupSelected(group))\n    {\n        Unity.TestFile = file;\n        Unity.CurrentTestName = printableName;\n        Unity.CurrentTestLineNumber = line;\n        if (!UnityFixture.Verbose)\n            UNITY_OUTPUT_CHAR('.');\n        else\n        {\n            UnityPrint(printableName);\n        #ifndef UNITY_REPEAT_TEST_NAME\n            Unity.CurrentTestName = NULL;\n        #endif\n        }\n\n        Unity.NumberOfTests++;\n        UnityMalloc_StartTest();\n        UnityPointer_Init();\n\n        if (TEST_PROTECT())\n        {\n            setup();\n            testBody();\n        }\n        if (TEST_PROTECT())\n        {\n            teardown();\n        }\n        if (TEST_PROTECT())\n        {\n            UnityPointer_UndoAllSets();\n            if (!Unity.CurrentTestFailed)\n                UnityMalloc_EndTest();\n        }\n        UnityConcludeFixtureTest();\n    }\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityTestRunner",
            "parameters": {
              "setup": "unityfunction",
              "testBody": "unityfunction",
              "teardown": "unityfunction",
              "printableName": "char",
              "group": "char",
              "name": "char",
              "file": "char",
              "line": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityIgnoreTest(const char* printableName, const char* group, const char* name)\n{\n    if (testSelected(name) && groupSelected(group))\n    {\n        Unity.NumberOfTests++;\n        Unity.TestIgnores++;\n        if (!UnityFixture.Verbose)\n            UNITY_OUTPUT_CHAR('!');\n        else\n        {\n            UnityPrint(printableName);\n            UNITY_PRINT_EOL();\n        }\n    }\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              128,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityIgnoreTest",
            "parameters": {
              "printableName": "char",
              "group": "char",
              "name": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityMalloc_StartTest(void)\n{\n    malloc_count = 0;\n    malloc_fail_countdown = MALLOC_DONT_FAIL;\n}",
          "fn_code_pos": [
            [
              137,
              0
            ],
            [
              141,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityMalloc_StartTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityMalloc_EndTest(void)\n{\n    malloc_fail_countdown = MALLOC_DONT_FAIL;\n    if (malloc_count != 0)\n    {\n        UNITY_TEST_FAIL(Unity.CurrentTestLineNumber, \"This test leaks!\");\n    }\n}",
          "fn_code_pos": [
            [
              143,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityMalloc_EndTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityMalloc_MakeMallocFailAfterCount(int countdown)\n{\n    malloc_fail_countdown = countdown;\n}",
          "fn_code_pos": [
            [
              152,
              0
            ],
            [
              155,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityMalloc_MakeMallocFailAfterCount",
            "parameters": {
              "countdown": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void* unity_malloc(size_t size)\n{\n    char* mem;\n    Guard* guard;\n    size_t total_size = size + sizeof(Guard) + sizeof(end);\n\n    if (malloc_fail_countdown != MALLOC_DONT_FAIL)\n    {\n        if (malloc_fail_countdown == 0)\n            return NULL;\n        malloc_fail_countdown--;\n    }\n\n    if (size == 0) return NULL;\n#ifdef UNITY_EXCLUDE_STDLIB_MALLOC\n    if (heap_index + total_size > UNITY_INTERNAL_HEAP_SIZE_BYTES)\n    {\n        guard = NULL;\n    }\n    else\n    {\n        guard = (Guard*)&unity_heap[heap_index];\n        heap_index += total_size;\n    }\n#else\n    guard = (Guard*)UNITY_FIXTURE_MALLOC(total_size);\n#endif\n    if (guard == NULL) return NULL;\n    malloc_count++;\n    guard->size = size;\n    guard->guard_space = 0;\n    mem = (char*)&(guard[1]);\n    memcpy(&mem[size], end, sizeof(end));\n\n    return (void*)mem;\n}",
          "fn_code_pos": [
            [
              180,
              0
            ],
            [
              215,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unity_malloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int isOverrun(void* mem)\n{\n    Guard* guard = (Guard*)mem;\n    char* memAsChar = (char*)mem;\n    guard--;\n\n    return guard->guard_space != 0 || strcmp(&memAsChar[guard->size], end) != 0;\n}",
          "fn_code_pos": [
            [
              217,
              0
            ],
            [
              224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "isOverrun",
            "parameters": {
              "mem": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void release_memory(void* mem)\n{\n    Guard* guard = (Guard*)mem;\n    guard--;\n\n    malloc_count--;\n#ifdef UNITY_EXCLUDE_STDLIB_MALLOC\n    if (mem == unity_heap + heap_index - guard->size - sizeof(end))\n    {\n        heap_index -= (guard->size + sizeof(Guard) + sizeof(end));\n    }\n#else\n    UNITY_FIXTURE_FREE(guard);\n#endif\n}",
          "fn_code_pos": [
            [
              226,
              0
            ],
            [
              240,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "release_memory",
            "parameters": {
              "mem": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void unity_free(void* mem)\n{\n    int overrun;\n\n    if (mem == NULL)\n    {\n        return;\n    }\n\n    overrun = isOverrun(mem);\n    release_memory(mem);\n    if (overrun)\n    {\n        UNITY_TEST_FAIL(Unity.CurrentTestLineNumber, \"Buffer overrun detected during free()\");\n    }\n}",
          "fn_code_pos": [
            [
              242,
              0
            ],
            [
              257,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unity_free",
            "parameters": {
              "mem": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void* unity_calloc(size_t num, size_t size)\n{\n    void* mem = unity_malloc(num * size);\n    if (mem == NULL) return NULL;\n    memset(mem, 0, num * size);\n    return mem;\n}",
          "fn_code_pos": [
            [
              259,
              0
            ],
            [
              265,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unity_calloc",
            "parameters": {
              "num": "size_t",
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void* unity_realloc(void* oldMem, size_t size)\n{\n    Guard* guard = (Guard*)oldMem;\n    void* newMem;\n\n    if (oldMem == NULL) return unity_malloc(size);\n\n    guard--;\n    if (isOverrun(oldMem))\n    {\n        release_memory(oldMem);\n        UNITY_TEST_FAIL(Unity.CurrentTestLineNumber, \"Buffer overrun detected during realloc()\");\n    }\n\n    if (size == 0)\n    {\n        release_memory(oldMem);\n        return NULL;\n    }\n\n    if (guard->size >= size) return oldMem;\n\n#ifdef UNITY_EXCLUDE_STDLIB_MALLOC /* Optimization if memory is expandable */\n    if (oldMem == unity_heap + heap_index - guard->size - sizeof(end) &&\n        heap_index + size - guard->size <= UNITY_INTERNAL_HEAP_SIZE_BYTES)\n    {\n        release_memory(oldMem);    /* Not thread-safe, like unity_heap generally */\n        return unity_malloc(size); /* No memcpy since data is in place */\n    }\n#endif\n    newMem = unity_malloc(size);\n    if (newMem == NULL) return NULL; /* Do not release old memory */\n    memcpy(newMem, oldMem, guard->size);\n    release_memory(oldMem);\n    return newMem;\n}",
          "fn_code_pos": [
            [
              267,
              0
            ],
            [
              302,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unity_realloc",
            "parameters": {
              "oldMem": "void",
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityPointer_Init(void)\n{\n    pointer_index = 0;\n}",
          "fn_code_pos": [
            [
              316,
              0
            ],
            [
              319,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPointer_Init",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityPointer_Set(void** pointer, void* newValue, UNITY_LINE_TYPE line)\n{\n    if (pointer_index >= UNITY_MAX_POINTERS)\n    {\n        UNITY_TEST_FAIL(line, \"Too many pointers set\");\n    }\n    else\n    {\n        pointer_store[pointer_index].pointer = pointer;\n        pointer_store[pointer_index].old_value = *pointer;\n        *pointer = newValue;\n        pointer_index++;\n    }\n}",
          "fn_code_pos": [
            [
              321,
              0
            ],
            [
              334,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPointer_Set",
            "parameters": {
              "pointer": "void",
              "newValue": "void",
              "line": "UNITY_LINE_TYPE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void UnityPointer_UndoAllSets(void)\n{\n    while (pointer_index > 0)\n    {\n        pointer_index--;\n        *(pointer_store[pointer_index].pointer) =\n            pointer_store[pointer_index].old_value;\n    }\n}",
          "fn_code_pos": [
            [
              336,
              0
            ],
            [
              344,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPointer_UndoAllSets",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int UnityGetCommandLineOptions(int argc, const char* argv[])\n{\n    int i;\n    UnityFixture.Verbose = 0;\n    UnityFixture.GroupFilter = 0;\n    UnityFixture.NameFilter = 0;\n    UnityFixture.RepeatCount = 1;\n\n    if (argc == 1)\n        return 0;\n\n    for (i = 1; i < argc; )\n    {\n        if (strcmp(argv[i], \"-v\") == 0)\n        {\n            UnityFixture.Verbose = 1;\n            i++;\n        }\n        else if (strcmp(argv[i], \"-g\") == 0)\n        {\n            i++;\n            if (i >= argc)\n                return 1;\n            UnityFixture.GroupFilter = argv[i];\n            i++;\n        }\n        else if (strcmp(argv[i], \"-n\") == 0)\n        {\n            i++;\n            if (i >= argc)\n                return 1;\n            UnityFixture.NameFilter = argv[i];\n            i++;\n        }\n        else if (strcmp(argv[i], \"-r\") == 0)\n        {\n            UnityFixture.RepeatCount = 2;\n            i++;\n            if (i < argc)\n            {\n                if (*(argv[i]) >= '0' && *(argv[i]) <= '9')\n                {\n                    unsigned int digit = 0;\n                    UnityFixture.RepeatCount = 0;\n                    while (argv[i][digit] >= '0' && argv[i][digit] <= '9')\n                    {\n                        UnityFixture.RepeatCount *= 10;\n                        UnityFixture.RepeatCount += (unsigned int)argv[i][digit++] - '0';\n                    }\n                    i++;\n                }\n            }\n        }\n        else\n        {\n            /* ignore unknown parameter */\n            i++;\n        }\n    }\n    return 0;\n}",
          "fn_code_pos": [
            [
              346,
              0
            ],
            [
              406,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityGetCommandLineOptions",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void UnityConcludeFixtureTest(void)\n{\n    if (Unity.CurrentTestIgnored)\n    {\n        Unity.TestIgnores++;\n        UNITY_PRINT_EOL();\n    }\n    else if (!Unity.CurrentTestFailed)\n    {\n        if (UnityFixture.Verbose)\n        {\n            UnityPrint(\" PASS\");\n            UNITY_PRINT_EOL();\n        }\n    }\n    else /* Unity.CurrentTestFailed */\n    {\n        Unity.TestFailures++;\n        UNITY_PRINT_EOL();\n    }\n\n    Unity.CurrentTestFailed = 0;\n    Unity.CurrentTestIgnored = 0;\n}",
          "fn_code_pos": [
            [
              408,
              0
            ],
            [
              431,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityConcludeFixtureTest",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*runAllTests)(void)",
          "fn_dec_pos": [
            [
              31,
              49
            ],
            [
              31,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "unity_malloc(size_t size)",
          "fn_dec_pos": [
            [
              180,
              6
            ],
            [
              180,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unity_malloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unity_calloc(size_t num, size_t size)",
          "fn_dec_pos": [
            [
              259,
              6
            ],
            [
              259,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unity_calloc",
            "parameters": {
              "num": "size_t",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unity_realloc(void* oldMem, size_t size)",
          "fn_dec_pos": [
            [
              267,
              6
            ],
            [
              267,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unity_realloc",
            "parameters": {
              "oldMem": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct GuardBytes\n{\n    size_t size;\n    size_t guard_space;\n} Guard;",
          {
            "size": "size_t",
            "guard_space": "size_t"
          },
          "Guard",
          [
            171,
            0
          ],
          [
            175,
            8
          ]
        ],
        [
          "struct PointerPair\n{\n    void** pointer;\n    void* old_value;\n}",
          {
            "** pointer": "void",
            "* old_value": "void"
          },
          "PointerPair",
          [
            307,
            0
          ],
          [
            311,
            1
          ]
        ],
        [
          "struct UNITY_FIXTURE_T",
          {},
          "",
          [
            11,
            0
          ],
          [
            11,
            22
          ]
        ],
        [
          "typedef struct GuardBytes\n{\n    size_t size;\n    size_t guard_space;\n} Guard;",
          {
            "size": "size_t",
            "guard_space": "size_t"
          },
          "Guard",
          [
            171,
            0
          ],
          [
            175,
            8
          ]
        ],
        [
          "struct PointerPair\n{\n    void** pointer;\n    void* old_value;\n}",
          {
            "** pointer": "void",
            "* old_value": "void"
          },
          "PointerPair",
          [
            307,
            0
          ],
          [
            311,
            1
          ]
        ],
        [
          "struct PointerPair",
          {},
          "",
          [
            313,
            7
          ],
          [
            313,
            25
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"unity_fixture.h\"\n",
          [
            7,
            0
          ],
          [
            8,
            0
          ]
        ],
        [
          "#include \"unity_internals.h\"\n",
          [
            8,
            0
          ],
          [
            9,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            168,
            0
          ],
          [
            169,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/fuzzing/cjson_read_fuzzer.c": {
      "fn_def_list": [
        {
          "fn_code": "int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)\n{\n    cJSON *json;\n    size_t offset = 4;\n    unsigned char *copied;\n    char *printed_json = NULL;\n    int minify, require_termination, formatted, buffered;\n\n\n    if(size <= offset) return 0;\n    if(data[size-1] != '\\0') return 0;\n    if(data[0] != '1' && data[0] != '0') return 0;\n    if(data[1] != '1' && data[1] != '0') return 0;\n    if(data[2] != '1' && data[2] != '0') return 0;\n    if(data[3] != '1' && data[3] != '0') return 0;\n\n    minify              = data[0] == '1' ? 1 : 0;\n    require_termination = data[1] == '1' ? 1 : 0;\n    formatted           = data[2] == '1' ? 1 : 0;\n    buffered            = data[3] == '1' ? 1 : 0;\n\n    json = cJSON_ParseWithOpts((const char*)data + offset, NULL, require_termination);\n\n    if(json == NULL) return 0;\n\n    if(buffered)\n    {\n        printed_json = cJSON_PrintBuffered(json, 1, formatted);\n    }\n    else\n    {\n        /* unbuffered printing */\n        if(formatted)\n        {\n            printed_json = cJSON_Print(json);\n        }\n        else\n        {\n            printed_json = cJSON_PrintUnformatted(json);\n        }\n    }\n\n    if(printed_json != NULL) free(printed_json);\n\n    if(minify)\n    {\n        copied = (unsigned char*)malloc(size);\n        if(copied == NULL) return 0;\n\n        memcpy(copied, data, size);\n\n        cJSON_Minify((char*)copied + offset);\n\n        free(copied);\n    }\n\n    cJSON_Delete(json);\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              12,
              0
            ],
            [
              71,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "data": "uint8_t",
              "size": "size_t"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)",
          "fn_dec_pos": [
            [
              10,
              4
            ],
            [
              10,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "data": "uint8_t",
              "size": "size_t"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdlib.h>\n",
          [
            0,
            0
          ],
          [
            1,
            0
          ]
        ],
        [
          "#include <stdint.h>\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            2,
            0
          ],
          [
            3,
            0
          ]
        ],
        [
          "#include \"../cJSON.h\"\n",
          [
            8,
            0
          ],
          [
            9,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/fuzzing/fuzz_main.c": {
      "fn_def_list": [
        {
          "fn_code": "int main(int argc, char **argv)\n{\n    FILE *f;\n    char *buf = NULL;\n    long siz_buf;\n\n    if(argc < 2)\n    {\n        fprintf(stderr, \"no input file\\n\");\n        goto err;\n    }\n\n    f = fopen(argv[1], \"rb\");\n    if(f == NULL)\n    {\n        fprintf(stderr, \"error opening input file %s\\n\", argv[1]);\n        goto err;\n    }\n\n    fseek(f, 0, SEEK_END);\n\n    siz_buf = ftell(f);\n    rewind(f);\n\n    if(siz_buf < 1) goto err;\n\n    buf = (char*)malloc((size_t)siz_buf);\n    if(buf == NULL)\n    {\n        fprintf(stderr, \"malloc() failed\\n\");\n        goto err;\n    }\n\n    if(fread(buf, (size_t)siz_buf, 1, f) != 1)\n    {\n        fprintf(stderr, \"fread() failed\\n\");\n        goto err;\n    }\n\n    (void)LLVMFuzzerTestOneInput((uint8_t*)buf, (size_t)siz_buf);\n\nerr:\n    free(buf);\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              8,
              0
            ],
            [
              53,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)",
          "fn_dec_pos": [
            [
              4,
              4
            ],
            [
              4,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "data": "uint8_t",
              "size": "size_t"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdint.h>\n",
          [
            0,
            0
          ],
          [
            1,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            2,
            0
          ],
          [
            3,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/fuzzing/afl.c": {
      "fn_def_list": [
        {
          "fn_code": "static char *read_file(const char *filename)\n{\n    FILE *file = NULL;\n    long length = 0;\n    char *content = NULL;\n    size_t read_chars = 0;\n\n    /* open in read binary mode */\n    file = fopen(filename, \"rb\");\n    if (file == NULL)\n    {\n        goto cleanup;\n    }\n\n    /* get the length */\n    if (fseek(file, 0, SEEK_END) != 0)\n    {\n        goto cleanup;\n    }\n    length = ftell(file);\n    if (length < 0)\n    {\n        goto cleanup;\n    }\n    if (fseek(file, 0, SEEK_SET) != 0)\n    {\n        goto cleanup;\n    }\n\n    /* allocate content buffer */\n    content = (char*)malloc((size_t)length + sizeof(\"\"));\n    if (content == NULL)\n    {\n        goto cleanup;\n    }\n\n    /* read the file into memory */\n    read_chars = fread(content, sizeof(char), (size_t)length, file);\n    if ((long)read_chars != length)\n    {\n        free(content);\n        content = NULL;\n        goto cleanup;\n    }\n    content[read_chars] = '\\0';\n\n\ncleanup:\n    if (file != NULL)\n    {\n        fclose(file);\n    }\n\n    return content;\n}",
          "fn_code_pos": [
            [
              28,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_file",
            "parameters": {
              "filename": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "int main(int argc, char** argv)\n{\n    const char *filename = NULL;\n    cJSON *item = NULL;\n    char *json = NULL;\n    int status = EXIT_FAILURE;\n    char *printed_json = NULL;\n\n    if ((argc < 2) || (argc > 3))\n    {\n        printf(\"Usage:\\n\");\n        printf(\"%s input_file [enable_printing]\\n\", argv[0]);\n        printf(\"\\t input_file: file containing the test data\\n\");\n        printf(\"\\t enable_printing: print after parsing, 'yes' or 'no', defaults to 'no'\\n\");\n        goto cleanup;\n    }\n\n    filename = argv[1];\n\n#if __AFL_HAVE_MANUAL_CONTROL\n    while (__AFL_LOOP(1000))\n    {\n#endif\n    status = EXIT_SUCCESS;\n\n    json = read_file(filename);\n    if ((json == NULL) || (json[0] == '\\0') || (json[1] == '\\0'))\n    {\n        status = EXIT_FAILURE;\n        goto cleanup;\n    }\n    item = cJSON_Parse(json + 2);\n    if (item == NULL)\n    {\n        goto cleanup;\n    }\n\n    if ((argc == 3) && (strncmp(argv[2], \"yes\", 3) == 0))\n    {\n        int do_format = 0;\n        if (json[1] == 'f')\n        {\n            do_format = 1;\n        }\n\n        if (json[0] == 'b')\n        {\n            /* buffered printing */\n            printed_json = cJSON_PrintBuffered(item, 1, do_format);\n        }\n        else\n        {\n            /* unbuffered printing */\n            if (do_format)\n            {\n                printed_json = cJSON_Print(item);\n            }\n            else\n            {\n                printed_json = cJSON_PrintUnformatted(item);\n            }\n        }\n        if (printed_json == NULL)\n        {\n            status = EXIT_FAILURE;\n            goto cleanup;\n        }\n        printf(\"%s\\n\", printed_json);\n    }\n\ncleanup:\n    if (item != NULL)\n    {\n        cJSON_Delete(item);\n        item = NULL;\n    }\n    if (json != NULL)\n    {\n        free(json);\n        json = NULL;\n    }\n    if (printed_json != NULL)\n    {\n        free(printed_json);\n        printed_json = NULL;\n    }\n#if __AFL_HAVE_MANUAL_CONTROL\n    }\n#endif\n\n    return status;\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "read_file(const char *filename)",
          "fn_dec_pos": [
            [
              28,
              13
            ],
            [
              28,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_file",
            "parameters": {
              "filename": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"../cJSON.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    }
  },
  "head": {
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/cJSON_Utils.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              33,
              0
            ],
            [
              33,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_GetPointer",
            "parameters": {
              "object": "cJSON",
              "pointer": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_GetPointer(cJSON * const object, const char *pointer)",
          "fn_dec_pos": [
            [
              33,
              22
            ],
            [
              33,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_GetPointer",
            "parameters": {
              "object": "cJSON",
              "pointer": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              34,
              0
            ],
            [
              34,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_GetPointerCaseSensitive",
            "parameters": {
              "object": "cJSON",
              "pointer": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_GetPointerCaseSensitive(cJSON * const object, const char *pointer)",
          "fn_dec_pos": [
            [
              34,
              22
            ],
            [
              34,
              99
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_GetPointerCaseSensitive",
            "parameters": {
              "object": "cJSON",
              "pointer": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              38,
              0
            ],
            [
              38,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_GeneratePatches",
            "parameters": {
              "from": "cJSON",
              "to": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_GeneratePatches(cJSON * const from, cJSON * const to)",
          "fn_dec_pos": [
            [
              38,
              22
            ],
            [
              38,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_GeneratePatches",
            "parameters": {
              "from": "cJSON",
              "to": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              39,
              0
            ],
            [
              39,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_GeneratePatchesCaseSensitive",
            "parameters": {
              "from": "cJSON",
              "to": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_GeneratePatchesCaseSensitive(cJSON * const from, cJSON * const to)",
          "fn_dec_pos": [
            [
              39,
              22
            ],
            [
              39,
              99
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_GeneratePatchesCaseSensitive",
            "parameters": {
              "from": "cJSON",
              "to": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              41,
              0
            ],
            [
              41,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_AddPatchToArray",
            "parameters": {
              "array": "cJSON",
              "operation": "char",
              "path": "char",
              "value": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_AddPatchToArray(cJSON * const array, const char * const operation, const char * const path, const cJSON * const value)",
          "fn_dec_pos": [
            [
              41,
              19
            ],
            [
              41,
              148
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_AddPatchToArray",
            "parameters": {
              "array": "cJSON",
              "operation": "char",
              "path": "char",
              "value": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(int)",
          "fn_dec_pos": [
            [
              43,
              0
            ],
            [
              43,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_ApplyPatches",
            "parameters": {
              "object": "cJSON",
              "patches": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_ApplyPatches(cJSON * const object, const cJSON * const patches)",
          "fn_dec_pos": [
            [
              43,
              18
            ],
            [
              43,
              92
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_ApplyPatches",
            "parameters": {
              "object": "cJSON",
              "patches": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(int)",
          "fn_dec_pos": [
            [
              44,
              0
            ],
            [
              44,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_ApplyPatchesCaseSensitive",
            "parameters": {
              "object": "cJSON",
              "patches": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_ApplyPatchesCaseSensitive(cJSON * const object, const cJSON * const patches)",
          "fn_dec_pos": [
            [
              44,
              18
            ],
            [
              44,
              105
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_ApplyPatchesCaseSensitive",
            "parameters": {
              "object": "cJSON",
              "patches": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              69,
              0
            ],
            [
              69,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_MergePatch",
            "parameters": {
              "target": "cJSON",
              "patch": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_MergePatch(cJSON *target, const cJSON * const patch)",
          "fn_dec_pos": [
            [
              69,
              22
            ],
            [
              69,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_MergePatch",
            "parameters": {
              "target": "cJSON",
              "patch": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              70,
              0
            ],
            [
              70,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_MergePatchCaseSensitive",
            "parameters": {
              "target": "cJSON",
              "patch": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_MergePatchCaseSensitive(cJSON *target, const cJSON * const patch)",
          "fn_dec_pos": [
            [
              70,
              22
            ],
            [
              70,
              98
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_MergePatchCaseSensitive",
            "parameters": {
              "target": "cJSON",
              "patch": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              73,
              0
            ],
            [
              73,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_GenerateMergePatch",
            "parameters": {
              "from": "cJSON",
              "to": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_GenerateMergePatch(cJSON * const from, cJSON * const to)",
          "fn_dec_pos": [
            [
              73,
              22
            ],
            [
              73,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_GenerateMergePatch",
            "parameters": {
              "from": "cJSON",
              "to": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              74,
              0
            ],
            [
              74,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_GenerateMergePatchCaseSensitive",
            "parameters": {
              "from": "cJSON",
              "to": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_GenerateMergePatchCaseSensitive(cJSON * const from, cJSON * const to)",
          "fn_dec_pos": [
            [
              74,
              22
            ],
            [
              74,
              102
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_GenerateMergePatchCaseSensitive",
            "parameters": {
              "from": "cJSON",
              "to": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(char *)",
          "fn_dec_pos": [
            [
              77,
              0
            ],
            [
              77,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_FindPointerFromObjectTo",
            "parameters": {
              "object": "cJSON",
              "target": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_FindPointerFromObjectTo(const cJSON * const object, const cJSON * const target)",
          "fn_dec_pos": [
            [
              77,
              21
            ],
            [
              77,
              111
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_FindPointerFromObjectTo",
            "parameters": {
              "object": "cJSON",
              "target": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              80,
              0
            ],
            [
              80,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_SortObject",
            "parameters": {
              "object": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_SortObject(cJSON * const object)",
          "fn_dec_pos": [
            [
              80,
              19
            ],
            [
              80,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_SortObject",
            "parameters": {
              "object": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              81,
              0
            ],
            [
              81,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_SortObjectCaseSensitive",
            "parameters": {
              "object": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSONUtils_SortObjectCaseSensitive(cJSON * const object)",
          "fn_dec_pos": [
            [
              81,
              19
            ],
            [
              81,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSONUtils_SortObjectCaseSensitive",
            "parameters": {
              "object": "cJSON"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"cJSON.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/cJSON.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(CJSON_CDECL *malloc_fn)(size_t sz)",
          "fn_dec_pos": [
            [
              127,
              12
            ],
            [
              127,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "sz": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(CJSON_CDECL *free_fn)(void *ptr)",
          "fn_dec_pos": [
            [
              128,
              11
            ],
            [
              128,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(const char*)",
          "fn_dec_pos": [
            [
              140,
              0
            ],
            [
              140,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              143,
              0
            ],
            [
              143,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              147,
              0
            ],
            [
              147,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_Parse",
            "parameters": {
              "value": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_Parse(const char *value)",
          "fn_dec_pos": [
            [
              147,
              22
            ],
            [
              147,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_Parse",
            "parameters": {
              "value": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              148,
              0
            ],
            [
              148,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ParseWithLength",
            "parameters": {
              "value": "char",
              "buffer_length": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_ParseWithLength(const char *value, size_t buffer_length)",
          "fn_dec_pos": [
            [
              148,
              22
            ],
            [
              148,
              84
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ParseWithLength",
            "parameters": {
              "value": "char",
              "buffer_length": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              151,
              0
            ],
            [
              151,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ParseWithOpts",
            "parameters": {
              "value": "char",
              "return_parse_end": "char",
              "require_null_terminated": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)",
          "fn_dec_pos": [
            [
              151,
              22
            ],
            [
              151,
              127
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ParseWithOpts",
            "parameters": {
              "value": "char",
              "return_parse_end": "char",
              "require_null_terminated": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              152,
              0
            ],
            [
              152,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ParseWithLengthOpts",
            "parameters": {
              "value": "char",
              "buffer_length": "size_t",
              "return_parse_end": "char",
              "require_null_terminated": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated)",
          "fn_dec_pos": [
            [
              152,
              22
            ],
            [
              152,
              155
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ParseWithLengthOpts",
            "parameters": {
              "value": "char",
              "buffer_length": "size_t",
              "return_parse_end": "char",
              "require_null_terminated": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(char *)",
          "fn_dec_pos": [
            [
              155,
              0
            ],
            [
              155,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_Print",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_Print(const cJSON *item)",
          "fn_dec_pos": [
            [
              155,
              21
            ],
            [
              155,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_Print",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(char *)",
          "fn_dec_pos": [
            [
              157,
              0
            ],
            [
              157,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_PrintUnformatted",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_PrintUnformatted(const cJSON *item)",
          "fn_dec_pos": [
            [
              157,
              21
            ],
            [
              157,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_PrintUnformatted",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(char *)",
          "fn_dec_pos": [
            [
              159,
              0
            ],
            [
              159,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_PrintBuffered",
            "parameters": {
              "item": "cJSON",
              "prebuffer": "int",
              "fmt": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)",
          "fn_dec_pos": [
            [
              159,
              21
            ],
            [
              159,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_PrintBuffered",
            "parameters": {
              "item": "cJSON",
              "prebuffer": "int",
              "fmt": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format)",
          "fn_dec_pos": [
            [
              162,
              25
            ],
            [
              162,
              118
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_PrintPreallocated",
            "parameters": {
              "item": "cJSON",
              "buffer": "char",
              "length": "int",
              "format": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              164,
              0
            ],
            [
              164,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(int)",
          "fn_dec_pos": [
            [
              167,
              0
            ],
            [
              167,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_GetArraySize",
            "parameters": {
              "array": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_GetArraySize(const cJSON *array)",
          "fn_dec_pos": [
            [
              167,
              18
            ],
            [
              167,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_GetArraySize",
            "parameters": {
              "array": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              169,
              0
            ],
            [
              169,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_GetArrayItem",
            "parameters": {
              "array": "cJSON",
              "index": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_GetArrayItem(const cJSON *array, int index)",
          "fn_dec_pos": [
            [
              169,
              22
            ],
            [
              169,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_GetArrayItem",
            "parameters": {
              "array": "cJSON",
              "index": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              171,
              0
            ],
            [
              171,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_GetObjectItem",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_GetObjectItem(const cJSON * const object, const char * const string)",
          "fn_dec_pos": [
            [
              171,
              22
            ],
            [
              171,
              96
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_GetObjectItem",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              172,
              0
            ],
            [
              172,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_GetObjectItemCaseSensitive",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)",
          "fn_dec_pos": [
            [
              172,
              22
            ],
            [
              172,
              109
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_GetObjectItemCaseSensitive",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_HasObjectItem(const cJSON *object, const char *string)",
          "fn_dec_pos": [
            [
              173,
              25
            ],
            [
              173,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_HasObjectItem",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(const char *)",
          "fn_dec_pos": [
            [
              175,
              0
            ],
            [
              175,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(char *)",
          "fn_dec_pos": [
            [
              178,
              0
            ],
            [
              178,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_GetStringValue",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_GetStringValue(const cJSON * const item)",
          "fn_dec_pos": [
            [
              178,
              21
            ],
            [
              178,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_GetStringValue",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(double)",
          "fn_dec_pos": [
            [
              179,
              0
            ],
            [
              179,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_GetNumberValue",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_GetNumberValue(const cJSON * const item)",
          "fn_dec_pos": [
            [
              179,
              21
            ],
            [
              179,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_GetNumberValue",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsInvalid(const cJSON * const item)",
          "fn_dec_pos": [
            [
              182,
              25
            ],
            [
              182,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsInvalid",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsFalse(const cJSON * const item)",
          "fn_dec_pos": [
            [
              183,
              25
            ],
            [
              183,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsFalse",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsTrue(const cJSON * const item)",
          "fn_dec_pos": [
            [
              184,
              25
            ],
            [
              184,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsTrue",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsBool(const cJSON * const item)",
          "fn_dec_pos": [
            [
              185,
              25
            ],
            [
              185,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsBool",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsNull(const cJSON * const item)",
          "fn_dec_pos": [
            [
              186,
              25
            ],
            [
              186,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsNull",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsNumber(const cJSON * const item)",
          "fn_dec_pos": [
            [
              187,
              25
            ],
            [
              187,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsNumber",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsString(const cJSON * const item)",
          "fn_dec_pos": [
            [
              188,
              25
            ],
            [
              188,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsString",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsArray(const cJSON * const item)",
          "fn_dec_pos": [
            [
              189,
              25
            ],
            [
              189,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsArray",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsObject(const cJSON * const item)",
          "fn_dec_pos": [
            [
              190,
              25
            ],
            [
              190,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsObject",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_IsRaw(const cJSON * const item)",
          "fn_dec_pos": [
            [
              191,
              25
            ],
            [
              191,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_IsRaw",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              194,
              0
            ],
            [
              194,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              195,
              0
            ],
            [
              195,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              196,
              0
            ],
            [
              196,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              197,
              0
            ],
            [
              197,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateBool",
            "parameters": {
              "boolean": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateBool(cJSON_bool boolean)",
          "fn_dec_pos": [
            [
              197,
              22
            ],
            [
              197,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateBool",
            "parameters": {
              "boolean": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              198,
              0
            ],
            [
              198,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateNumber",
            "parameters": {
              "num": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateNumber(double num)",
          "fn_dec_pos": [
            [
              198,
              22
            ],
            [
              198,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateNumber",
            "parameters": {
              "num": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              199,
              0
            ],
            [
              199,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateString",
            "parameters": {
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateString(const char *string)",
          "fn_dec_pos": [
            [
              199,
              22
            ],
            [
              199,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateString",
            "parameters": {
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              201,
              0
            ],
            [
              201,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateRaw",
            "parameters": {
              "raw": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateRaw(const char *raw)",
          "fn_dec_pos": [
            [
              201,
              22
            ],
            [
              201,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateRaw",
            "parameters": {
              "raw": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              202,
              0
            ],
            [
              202,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              203,
              0
            ],
            [
              203,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CJSON_PUBLIC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              207,
              0
            ],
            [
              207,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateStringReference",
            "parameters": {
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateStringReference(const char *string)",
          "fn_dec_pos": [
            [
              207,
              22
            ],
            [
              207,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateStringReference",
            "parameters": {
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              210,
              0
            ],
            [
              210,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateObjectReference",
            "parameters": {
              "child": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateObjectReference(const cJSON *child)",
          "fn_dec_pos": [
            [
              210,
              22
            ],
            [
              210,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateObjectReference",
            "parameters": {
              "child": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              211,
              0
            ],
            [
              211,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateArrayReference",
            "parameters": {
              "child": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateArrayReference(const cJSON *child)",
          "fn_dec_pos": [
            [
              211,
              22
            ],
            [
              211,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateArrayReference",
            "parameters": {
              "child": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              215,
              0
            ],
            [
              215,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateIntArray",
            "parameters": {
              "numbers": "int",
              "count": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateIntArray(const int *numbers, int count)",
          "fn_dec_pos": [
            [
              215,
              22
            ],
            [
              215,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateIntArray",
            "parameters": {
              "numbers": "int",
              "count": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              216,
              0
            ],
            [
              216,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateFloatArray",
            "parameters": {
              "numbers": "float",
              "count": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateFloatArray(const float *numbers, int count)",
          "fn_dec_pos": [
            [
              216,
              22
            ],
            [
              216,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateFloatArray",
            "parameters": {
              "numbers": "float",
              "count": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              217,
              0
            ],
            [
              217,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateDoubleArray",
            "parameters": {
              "numbers": "double",
              "count": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateDoubleArray(const double *numbers, int count)",
          "fn_dec_pos": [
            [
              217,
              22
            ],
            [
              217,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateDoubleArray",
            "parameters": {
              "numbers": "double",
              "count": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              218,
              0
            ],
            [
              218,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateStringArray",
            "parameters": {
              "strings": "char",
              "count": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_CreateStringArray(const char *const *strings, int count)",
          "fn_dec_pos": [
            [
              218,
              22
            ],
            [
              218,
              84
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_CreateStringArray",
            "parameters": {
              "strings": "char",
              "count": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)",
          "fn_dec_pos": [
            [
              222,
              25
            ],
            [
              222,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddItemToObject",
            "parameters": {
              "object": "cJSON",
              "string": "char",
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)",
          "fn_dec_pos": [
            [
              226,
              25
            ],
            [
              226,
              96
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddItemToObjectCS",
            "parameters": {
              "object": "cJSON",
              "string": "char",
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)",
          "fn_dec_pos": [
            [
              229,
              25
            ],
            [
              229,
              103
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddItemReferenceToObject",
            "parameters": {
              "object": "cJSON",
              "string": "char",
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              232,
              0
            ],
            [
              232,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DetachItemViaPointer",
            "parameters": {
              "parent": "cJSON",
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)",
          "fn_dec_pos": [
            [
              232,
              22
            ],
            [
              232,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DetachItemViaPointer",
            "parameters": {
              "parent": "cJSON",
              "item": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              233,
              0
            ],
            [
              233,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DetachItemFromArray",
            "parameters": {
              "array": "cJSON",
              "which": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_DetachItemFromArray(cJSON *array, int which)",
          "fn_dec_pos": [
            [
              233,
              22
            ],
            [
              233,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DetachItemFromArray",
            "parameters": {
              "array": "cJSON",
              "which": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              234,
              0
            ],
            [
              234,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DeleteItemFromArray",
            "parameters": {
              "array": "cJSON",
              "which": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_DeleteItemFromArray(cJSON *array, int which)",
          "fn_dec_pos": [
            [
              234,
              19
            ],
            [
              234,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DeleteItemFromArray",
            "parameters": {
              "array": "cJSON",
              "which": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              235,
              0
            ],
            [
              235,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DetachItemFromObject",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_DetachItemFromObject(cJSON *object, const char *string)",
          "fn_dec_pos": [
            [
              235,
              22
            ],
            [
              235,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DetachItemFromObject",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              236,
              0
            ],
            [
              236,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DetachItemFromObjectCaseSensitive",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string)",
          "fn_dec_pos": [
            [
              236,
              22
            ],
            [
              236,
              96
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DetachItemFromObjectCaseSensitive",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              237,
              0
            ],
            [
              237,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DeleteItemFromObject",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_DeleteItemFromObject(cJSON *object, const char *string)",
          "fn_dec_pos": [
            [
              237,
              19
            ],
            [
              237,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DeleteItemFromObject",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              238,
              0
            ],
            [
              238,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DeleteItemFromObjectCaseSensitive",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)",
          "fn_dec_pos": [
            [
              238,
              19
            ],
            [
              238,
              93
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_DeleteItemFromObjectCaseSensitive",
            "parameters": {
              "object": "cJSON",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)",
          "fn_dec_pos": [
            [
              241,
              25
            ],
            [
              241,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_InsertItemInArray",
            "parameters": {
              "array": "cJSON",
              "which": "int",
              "newitem": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)",
          "fn_dec_pos": [
            [
              242,
              25
            ],
            [
              242,
              115
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ReplaceItemViaPointer",
            "parameters": {
              "parent": "cJSON",
              "item": "cJSON",
              "replacement": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)",
          "fn_dec_pos": [
            [
              243,
              25
            ],
            [
              243,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ReplaceItemInArray",
            "parameters": {
              "array": "cJSON",
              "which": "int",
              "newitem": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem)",
          "fn_dec_pos": [
            [
              244,
              25
            ],
            [
              244,
              99
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ReplaceItemInObject",
            "parameters": {
              "object": "cJSON",
              "string": "char",
              "newitem": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object,const char *string,cJSON *newitem)",
          "fn_dec_pos": [
            [
              245,
              25
            ],
            [
              245,
              112
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_ReplaceItemInObjectCaseSensitive",
            "parameters": {
              "object": "cJSON",
              "string": "char",
              "newitem": "cJSON"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON *)",
          "fn_dec_pos": [
            [
              248,
              0
            ],
            [
              248,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_Duplicate",
            "parameters": {
              "item": "cJSON",
              "recurse": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)",
          "fn_dec_pos": [
            [
              248,
              22
            ],
            [
              248,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_Duplicate",
            "parameters": {
              "item": "cJSON",
              "recurse": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)",
          "fn_dec_pos": [
            [
              254,
              25
            ],
            [
              254,
              117
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_Compare",
            "parameters": {
              "a": "cJSON",
              "b": "cJSON",
              "case_sensitive": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              259,
              0
            ],
            [
              259,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_Minify",
            "parameters": {
              "json": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_Minify(char *json)",
          "fn_dec_pos": [
            [
              259,
              19
            ],
            [
              259,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_Minify",
            "parameters": {
              "json": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON*)",
          "fn_dec_pos": [
            [
              263,
              0
            ],
            [
              263,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddNullToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddNullToObject(cJSON * const object, const char * const name)",
          "fn_dec_pos": [
            [
              263,
              21
            ],
            [
              263,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddNullToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON*)",
          "fn_dec_pos": [
            [
              264,
              0
            ],
            [
              264,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddTrueToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddTrueToObject(cJSON * const object, const char * const name)",
          "fn_dec_pos": [
            [
              264,
              21
            ],
            [
              264,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddTrueToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON*)",
          "fn_dec_pos": [
            [
              265,
              0
            ],
            [
              265,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddFalseToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddFalseToObject(cJSON * const object, const char * const name)",
          "fn_dec_pos": [
            [
              265,
              21
            ],
            [
              265,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddFalseToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON*)",
          "fn_dec_pos": [
            [
              266,
              0
            ],
            [
              266,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddBoolToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char",
              "boolean": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean)",
          "fn_dec_pos": [
            [
              266,
              21
            ],
            [
              266,
              115
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddBoolToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char",
              "boolean": "cJSON_bool"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON*)",
          "fn_dec_pos": [
            [
              267,
              0
            ],
            [
              267,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddNumberToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char",
              "number": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)",
          "fn_dec_pos": [
            [
              267,
              21
            ],
            [
              267,
              112
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddNumberToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char",
              "number": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON*)",
          "fn_dec_pos": [
            [
              268,
              0
            ],
            [
              268,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddStringToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)",
          "fn_dec_pos": [
            [
              268,
              21
            ],
            [
              268,
              118
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddStringToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char",
              "string": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON*)",
          "fn_dec_pos": [
            [
              269,
              0
            ],
            [
              269,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddRawToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char",
              "raw": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw)",
          "fn_dec_pos": [
            [
              269,
              21
            ],
            [
              269,
              112
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddRawToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char",
              "raw": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON*)",
          "fn_dec_pos": [
            [
              270,
              0
            ],
            [
              270,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddObjectToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddObjectToObject(cJSON * const object, const char * const name)",
          "fn_dec_pos": [
            [
              270,
              21
            ],
            [
              270,
              91
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddObjectToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(cJSON*)",
          "fn_dec_pos": [
            [
              271,
              0
            ],
            [
              271,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddArrayToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_AddArrayToObject(cJSON * const object, const char * const name)",
          "fn_dec_pos": [
            [
              271,
              21
            ],
            [
              271,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_AddArrayToObject",
            "parameters": {
              "object": "cJSON",
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(double)",
          "fn_dec_pos": [
            [
              276,
              0
            ],
            [
              276,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_SetNumberHelper",
            "parameters": {
              "object": "cJSON",
              "number": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_SetNumberHelper(cJSON *object, double number)",
          "fn_dec_pos": [
            [
              276,
              21
            ],
            [
              276,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_SetNumberHelper",
            "parameters": {
              "object": "cJSON",
              "number": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(char*)",
          "fn_dec_pos": [
            [
              279,
              0
            ],
            [
              279,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_SetValuestring",
            "parameters": {
              "object": "cJSON",
              "valuestring": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_SetValuestring(cJSON *object, const char *valuestring)",
          "fn_dec_pos": [
            [
              279,
              20
            ],
            [
              279,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_SetValuestring",
            "parameters": {
              "object": "cJSON",
              "valuestring": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void *)",
          "fn_dec_pos": [
            [
              292,
              0
            ],
            [
              292,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_malloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_malloc(size_t size)",
          "fn_dec_pos": [
            [
              292,
              21
            ],
            [
              292,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_malloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "CJSON_PUBLIC(void)",
          "fn_dec_pos": [
            [
              293,
              0
            ],
            [
              293,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_free",
            "parameters": {
              "object": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "cJSON_free(void *object)",
          "fn_dec_pos": [
            [
              293,
              19
            ],
            [
              293,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cJSON_free",
            "parameters": {
              "object": "void"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct cJSON\n{\n    /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */\n    struct cJSON *next;\n    struct cJSON *prev;\n    /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */\n    struct cJSON *child;\n\n    /* The type of the item, as above. */\n    int type;\n\n    /* The item's string, if type==cJSON_String  and type == cJSON_Raw */\n    char *valuestring;\n    /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */\n    int valueint;\n    /* The item's number, if type==cJSON_Number */\n    double valuedouble;\n\n    /* The item's name string, if this item is the child of, or is in the list of subitems of an object. */\n    char *string;\n} cJSON;",
          {
            "*next": "struct cJSON",
            "*prev": "struct cJSON",
            "*child": "struct cJSON",
            "type": "int",
            "*valuestring": "char",
            "valueint": "int",
            "valuedouble": "double",
            "*string": "char"
          },
          "cJSON",
          [
            102,
            0
          ],
          [
            122,
            8
          ]
        ],
        [
          "typedef struct cJSON_Hooks\n{\n      /* malloc/free are CDECL on Windows regardless of the default calling convention of the compiler, so ensure the hooks allow passing those functions directly. */\n      void *(CJSON_CDECL *malloc_fn)(size_t sz);\n      void (CJSON_CDECL *free_fn)(void *ptr);\n} cJSON_Hooks;",
          {
            "*(CJSON_CDECL *malloc_fn)(size_t sz)": "void",
            "(CJSON_CDECL *free_fn)(void *ptr)": "void"
          },
          "cJSON_Hooks",
          [
            124,
            0
          ],
          [
            129,
            14
          ]
        ],
        [
          "typedef struct cJSON\n{\n    /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */\n    struct cJSON *next;\n    struct cJSON *prev;\n    /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */\n    struct cJSON *child;\n\n    /* The type of the item, as above. */\n    int type;\n\n    /* The item's string, if type==cJSON_String  and type == cJSON_Raw */\n    char *valuestring;\n    /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */\n    int valueint;\n    /* The item's number, if type==cJSON_Number */\n    double valuedouble;\n\n    /* The item's name string, if this item is the child of, or is in the list of subitems of an object. */\n    char *string;\n} cJSON;",
          {
            "*next": "struct cJSON",
            "*prev": "struct cJSON",
            "*child": "struct cJSON",
            "type": "int",
            "*valuestring": "char",
            "valueint": "int",
            "valuedouble": "double",
            "*string": "char"
          },
          "cJSON",
          [
            102,
            0
          ],
          [
            122,
            8
          ]
        ],
        [
          "struct cJSON",
          {},
          "",
          [
            105,
            4
          ],
          [
            105,
            16
          ]
        ],
        [
          "struct cJSON",
          {},
          "",
          [
            106,
            4
          ],
          [
            106,
            16
          ]
        ],
        [
          "struct cJSON",
          {},
          "",
          [
            108,
            4
          ],
          [
            108,
            16
          ]
        ],
        [
          "typedef struct cJSON_Hooks\n{\n      /* malloc/free are CDECL on Windows regardless of the default calling convention of the compiler, so ensure the hooks allow passing those functions directly. */\n      void *(CJSON_CDECL *malloc_fn)(size_t sz);\n      void (CJSON_CDECL *free_fn)(void *ptr);\n} cJSON_Hooks;",
          {
            "*(CJSON_CDECL *malloc_fn)(size_t sz)": "void",
            "(CJSON_CDECL *free_fn)(void *ptr)": "void"
          },
          "cJSON_Hooks",
          [
            124,
            0
          ],
          [
            129,
            14
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stddef.h>\n",
          [
            85,
            0
          ],
          [
            86,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/common.h": {
      "fn_def_list": [
        {
          "fn_code": "void reset(cJSON *item) {\n    if ((item != NULL) && (item->child != NULL))\n    {\n        cJSON_Delete(item->child);\n    }\n    if ((item->valuestring != NULL) && !(item->type & cJSON_IsReference))\n    {\n        global_hooks.deallocate(item->valuestring);\n    }\n    if ((item->string != NULL) && !(item->type & cJSON_StringIsConst))\n    {\n        global_hooks.deallocate(item->string);\n    }\n\n    memset(item, 0, sizeof(cJSON));\n}",
          "fn_code_pos": [
            [
              28,
              0
            ],
            [
              43,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reset",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "char* read_file(const char *filename) {\n    FILE *file = NULL;\n    long length = 0;\n    char *content = NULL;\n    size_t read_chars = 0;\n\n    /* open in read binary mode */\n    file = fopen(filename, \"rb\");\n    if (file == NULL)\n    {\n        goto cleanup;\n    }\n\n    /* get the length */\n    if (fseek(file, 0, SEEK_END) != 0)\n    {\n        goto cleanup;\n    }\n    length = ftell(file);\n    if (length < 0)\n    {\n        goto cleanup;\n    }\n    if (fseek(file, 0, SEEK_SET) != 0)\n    {\n        goto cleanup;\n    }\n\n    /* allocate content buffer */\n    content = (char*)malloc((size_t)length + sizeof(\"\"));\n    if (content == NULL)\n    {\n        goto cleanup;\n    }\n\n    /* read the file into memory */\n    read_chars = fread(content, sizeof(char), (size_t)length, file);\n    if ((long)read_chars != length)\n    {\n        free(content);\n        content = NULL;\n        goto cleanup;\n    }\n    content[read_chars] = '\\0';\n\n\ncleanup:\n    if (file != NULL)\n    {\n        fclose(file);\n    }\n\n    return content;\n}",
          "fn_code_pos": [
            [
              46,
              0
            ],
            [
              99,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_file",
            "parameters": {
              "filename": "char"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "reset(cJSON *item)",
          "fn_dec_pos": [
            [
              27,
              5
            ],
            [
              27,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reset",
            "parameters": {
              "item": "cJSON"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "read_file(const char *filename)",
          "fn_dec_pos": [
            [
              45,
              6
            ],
            [
              45,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_file",
            "parameters": {
              "filename": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "read_file(const char *filename)",
          "fn_dec_pos": [
            [
              46,
              6
            ],
            [
              46,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_file",
            "parameters": {
              "filename": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"../cJSON.c\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/src/unity.h": {
      "fn_def_list": [
        {
          "fn_code": "UNITY_WEAK_ATTRIBUTE void setUp(void) { }",
          "fn_code_pos": [
            [
              38,
              4
            ],
            [
              38,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setUp",
            "parameters": {},
            "return_type": "UNITY_WEAK_ATTRIBUTE"
          }
        },
        {
          "fn_code": "UNITY_WEAK_ATTRIBUTE void tearDown(void) { }",
          "fn_code_pos": [
            [
              39,
              4
            ],
            [
              39,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tearDown",
            "parameters": {},
            "return_type": "UNITY_WEAK_ATTRIBUTE"
          }
        },
        {
          "fn_code": "UNITY_WEAK_ATTRIBUTE void suiteSetUp(void) { }",
          "fn_code_pos": [
            [
              40,
              4
            ],
            [
              40,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "suiteSetUp",
            "parameters": {},
            "return_type": "UNITY_WEAK_ATTRIBUTE"
          }
        },
        {
          "fn_code": "UNITY_WEAK_ATTRIBUTE int suiteTearDown(int num_failures) { return num_failures; }",
          "fn_code_pos": [
            [
              41,
              4
            ],
            [
              41,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "suiteTearDown",
            "parameters": {
              "num_failures": "int"
            },
            "return_type": "UNITY_WEAK_ATTRIBUTE"
          }
        },
        {
          "fn_code": "void setUp(void) { }",
          "fn_code_pos": [
            [
              44,
              4
            ],
            [
              44,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void tearDown(void) { }",
          "fn_code_pos": [
            [
              46,
              4
            ],
            [
              46,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void suiteSetUp(void) { }",
          "fn_code_pos": [
            [
              48,
              4
            ],
            [
              48,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "suiteSetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int suiteTearDown(int num_failures) { return num_failures; }",
          "fn_code_pos": [
            [
              50,
              4
            ],
            [
              50,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "suiteTearDown",
            "parameters": {
              "num_failures": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "setUp(void)",
          "fn_dec_pos": [
            [
              22,
              5
            ],
            [
              22,
              16
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "tearDown(void)",
          "fn_dec_pos": [
            [
              23,
              5
            ],
            [
              23,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tearDown",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "suiteSetUp(void)",
          "fn_dec_pos": [
            [
              28,
              5
            ],
            [
              28,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "suiteSetUp",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "suiteTearDown(int num_failures)",
          "fn_dec_pos": [
            [
              29,
              4
            ],
            [
              29,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "suiteTearDown",
            "parameters": {
              "num_failures": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"unity_internals.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/src/unity_internals.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*UnityTestFunction)(void)",
          "fn_dec_pos": [
            [
              318,
              13
            ],
            [
              318,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityBegin(const char* filename)",
          "fn_dec_pos": [
            [
              407,
              5
            ],
            [
              407,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityBegin",
            "parameters": {
              "filename": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityEnd(void)",
          "fn_dec_pos": [
            [
              408,
              5
            ],
            [
              408,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityEnd",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "UnityConcludeTest(void)",
          "fn_dec_pos": [
            [
              409,
              5
            ],
            [
              409,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityConcludeTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityDefaultTestRun(UnityTestFunction Func, const char* FuncName, const int FuncLineNum)",
          "fn_dec_pos": [
            [
              410,
              5
            ],
            [
              410,
              93
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityDefaultTestRun",
            "parameters": {
              "Func": "UnityTestFunction",
              "FuncName": "char",
              "FuncLineNum": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityPrint(const char* string)",
          "fn_dec_pos": [
            [
              438,
              5
            ],
            [
              438,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPrint",
            "parameters": {
              "string": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityPrintLen(const char* string, const UNITY_UINT32 length)",
          "fn_dec_pos": [
            [
              439,
              5
            ],
            [
              439,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPrintLen",
            "parameters": {
              "string": "char",
              "length": "UNITY_UINT32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityPrintMask(const UNITY_UINT mask, const UNITY_UINT number)",
          "fn_dec_pos": [
            [
              440,
              5
            ],
            [
              440,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPrintMask",
            "parameters": {
              "mask": "UNITY_UINT",
              "number": "UNITY_UINT"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityPrintNumberByStyle(const UNITY_INT number, const UNITY_DISPLAY_STYLE_T style)",
          "fn_dec_pos": [
            [
              441,
              5
            ],
            [
              441,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPrintNumberByStyle",
            "parameters": {
              "number": "UNITY_INT",
              "style": "UNITY_DISPLAY_STYLE_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityPrintNumber(const UNITY_INT number)",
          "fn_dec_pos": [
            [
              442,
              5
            ],
            [
              442,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPrintNumber",
            "parameters": {
              "number": "UNITY_INT"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityPrintNumberUnsigned(const UNITY_UINT number)",
          "fn_dec_pos": [
            [
              443,
              5
            ],
            [
              443,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPrintNumberUnsigned",
            "parameters": {
              "number": "UNITY_UINT"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityPrintNumberHex(const UNITY_UINT number, const char nibbles)",
          "fn_dec_pos": [
            [
              444,
              5
            ],
            [
              444,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPrintNumberHex",
            "parameters": {
              "number": "UNITY_UINT",
              "nibbles": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityPrintFloat(const UNITY_DOUBLE input_number)",
          "fn_dec_pos": [
            [
              447,
              5
            ],
            [
              447,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPrintFloat",
            "parameters": {
              "input_number": "UNITY_DOUBLE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityAssertEqualNumber(const UNITY_INT expected,\n                            const UNITY_INT actual,\n                            const char* msg,\n                            const UNITY_LINE_TYPE lineNumber,\n                            const UNITY_DISPLAY_STYLE_T style)",
          "fn_dec_pos": [
            [
              458,
              5
            ],
            [
              462,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertEqualNumber",
            "parameters": {
              "expected": "UNITY_INT",
              "actual": "UNITY_INT",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "style": "UNITY_DISPLAY_STYLE_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityAssertGreaterOrLessOrEqualNumber(const UNITY_INT threshold,\n                                           const UNITY_INT actual,\n                                           const UNITY_COMPARISON_T compare,\n                                           const char *msg,\n                                           const UNITY_LINE_TYPE lineNumber,\n                                           const UNITY_DISPLAY_STYLE_T style)",
          "fn_dec_pos": [
            [
              464,
              5
            ],
            [
              469,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertGreaterOrLessOrEqualNumber",
            "parameters": {
              "threshold": "UNITY_INT",
              "actual": "UNITY_INT",
              "compare": "UNITY_COMPARISON_T",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "style": "UNITY_DISPLAY_STYLE_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityAssertEqualIntArray(UNITY_INTERNAL_PTR expected,\n                              UNITY_INTERNAL_PTR actual,\n                              const UNITY_UINT32 num_elements,\n                              const char* msg,\n                              const UNITY_LINE_TYPE lineNumber,\n                              const UNITY_DISPLAY_STYLE_T style,\n                              const UNITY_FLAGS_T flags)",
          "fn_dec_pos": [
            [
              471,
              5
            ],
            [
              477,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertEqualIntArray",
            "parameters": {
              "expected": "UNITY_INTERNAL_PTR",
              "actual": "UNITY_INTERNAL_PTR",
              "num_elements": "UNITY_UINT32",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "style": "UNITY_DISPLAY_STYLE_T",
              "flags": "UNITY_FLAGS_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityAssertBits(const UNITY_INT mask,\n                     const UNITY_INT expected,\n                     const UNITY_INT actual,\n                     const char* msg,\n                     const UNITY_LINE_TYPE lineNumber)",
          "fn_dec_pos": [
            [
              479,
              5
            ],
            [
              483,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertBits",
            "parameters": {
              "mask": "UNITY_INT",
              "expected": "UNITY_INT",
              "actual": "UNITY_INT",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityAssertEqualString(const char* expected,\n                            const char* actual,\n                            const char* msg,\n                            const UNITY_LINE_TYPE lineNumber)",
          "fn_dec_pos": [
            [
              485,
              5
            ],
            [
              488,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertEqualString",
            "parameters": {
              "expected": "char",
              "actual": "char",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityAssertEqualStringLen(const char* expected,\n                            const char* actual,\n                            const UNITY_UINT32 length,\n                            const char* msg,\n                            const UNITY_LINE_TYPE lineNumber)",
          "fn_dec_pos": [
            [
              490,
              5
            ],
            [
              494,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertEqualStringLen",
            "parameters": {
              "expected": "char",
              "actual": "char",
              "length": "UNITY_UINT32",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityAssertEqualStringArray( UNITY_INTERNAL_PTR expected,\n                                  const char** actual,\n                                  const UNITY_UINT32 num_elements,\n                                  const char* msg,\n                                  const UNITY_LINE_TYPE lineNumber,\n                                  const UNITY_FLAGS_T flags)",
          "fn_dec_pos": [
            [
              496,
              5
            ],
            [
              501,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertEqualStringArray",
            "parameters": {
              "expected": "UNITY_INTERNAL_PTR",
              "actual": "char",
              "num_elements": "UNITY_UINT32",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "flags": "UNITY_FLAGS_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityAssertEqualMemory( UNITY_INTERNAL_PTR expected,\n                             UNITY_INTERNAL_PTR actual,\n                             const UNITY_UINT32 length,\n                             const UNITY_UINT32 num_elements,\n                             const char* msg,\n                             const UNITY_LINE_TYPE lineNumber,\n                             const UNITY_FLAGS_T flags)",
          "fn_dec_pos": [
            [
              503,
              5
            ],
            [
              509,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertEqualMemory",
            "parameters": {
              "expected": "UNITY_INTERNAL_PTR",
              "actual": "UNITY_INTERNAL_PTR",
              "length": "UNITY_UINT32",
              "num_elements": "UNITY_UINT32",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "flags": "UNITY_FLAGS_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityAssertNumbersWithin(const UNITY_UINT delta,\n                              const UNITY_INT expected,\n                              const UNITY_INT actual,\n                              const char* msg,\n                              const UNITY_LINE_TYPE lineNumber,\n                              const UNITY_DISPLAY_STYLE_T style)",
          "fn_dec_pos": [
            [
              511,
              5
            ],
            [
              516,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertNumbersWithin",
            "parameters": {
              "delta": "UNITY_UINT",
              "expected": "UNITY_INT",
              "actual": "UNITY_INT",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "style": "UNITY_DISPLAY_STYLE_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityFail(const char* message, const UNITY_LINE_TYPE line)",
          "fn_dec_pos": [
            [
              518,
              5
            ],
            [
              518,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityFail",
            "parameters": {
              "message": "char",
              "line": "UNITY_LINE_TYPE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityIgnore(const char* message, const UNITY_LINE_TYPE line)",
          "fn_dec_pos": [
            [
              520,
              5
            ],
            [
              520,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityIgnore",
            "parameters": {
              "message": "char",
              "line": "UNITY_LINE_TYPE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityAssertFloatsWithin(const UNITY_FLOAT delta,\n                             const UNITY_FLOAT expected,\n                             const UNITY_FLOAT actual,\n                             const char* msg,\n                             const UNITY_LINE_TYPE lineNumber)",
          "fn_dec_pos": [
            [
              523,
              5
            ],
            [
              527,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertFloatsWithin",
            "parameters": {
              "delta": "UNITY_FLOAT",
              "expected": "UNITY_FLOAT",
              "actual": "UNITY_FLOAT",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityAssertEqualFloatArray(UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* expected,\n                                UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* actual,\n                                const UNITY_UINT32 num_elements,\n                                const char* msg,\n                                const UNITY_LINE_TYPE lineNumber,\n                                const UNITY_FLAGS_T flags)",
          "fn_dec_pos": [
            [
              529,
              5
            ],
            [
              534,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertEqualFloatArray",
            "parameters": {
              "num_elements": "UNITY_UINT32",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "flags": "UNITY_FLAGS_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityAssertFloatSpecial(const UNITY_FLOAT actual,\n                             const char* msg,\n                             const UNITY_LINE_TYPE lineNumber,\n                             const UNITY_FLOAT_TRAIT_T style)",
          "fn_dec_pos": [
            [
              536,
              5
            ],
            [
              539,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertFloatSpecial",
            "parameters": {
              "actual": "UNITY_FLOAT",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "style": "UNITY_FLOAT_TRAIT_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityAssertDoublesWithin(const UNITY_DOUBLE delta,\n                              const UNITY_DOUBLE expected,\n                              const UNITY_DOUBLE actual,\n                              const char* msg,\n                              const UNITY_LINE_TYPE lineNumber)",
          "fn_dec_pos": [
            [
              543,
              5
            ],
            [
              547,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertDoublesWithin",
            "parameters": {
              "delta": "UNITY_DOUBLE",
              "expected": "UNITY_DOUBLE",
              "actual": "UNITY_DOUBLE",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityAssertEqualDoubleArray(UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* expected,\n                                 UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* actual,\n                                 const UNITY_UINT32 num_elements,\n                                 const char* msg,\n                                 const UNITY_LINE_TYPE lineNumber,\n                                 const UNITY_FLAGS_T flags)",
          "fn_dec_pos": [
            [
              549,
              5
            ],
            [
              554,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertEqualDoubleArray",
            "parameters": {
              "num_elements": "UNITY_UINT32",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "flags": "UNITY_FLAGS_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityAssertDoubleSpecial(const UNITY_DOUBLE actual,\n                              const char* msg,\n                              const UNITY_LINE_TYPE lineNumber,\n                              const UNITY_FLOAT_TRAIT_T style)",
          "fn_dec_pos": [
            [
              556,
              5
            ],
            [
              559,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityAssertDoubleSpecial",
            "parameters": {
              "actual": "UNITY_DOUBLE",
              "msg": "char",
              "lineNumber": "UNITY_LINE_TYPE",
              "style": "UNITY_FLOAT_TRAIT_T"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityNumToPtr(const UNITY_INT num, const UNITY_UINT8 size)",
          "fn_dec_pos": [
            [
              566,
              19
            ],
            [
              566,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityNumToPtr",
            "parameters": {
              "num": "UNITY_INT",
              "size": "UNITY_UINT8"
            },
            "return_type": "UNITY_INTERNAL_PTR"
          }
        },
        {
          "fn_code": "UnityFloatToPtr(const float num)",
          "fn_dec_pos": [
            [
              568,
              19
            ],
            [
              568,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityFloatToPtr",
            "parameters": {
              "num": "float"
            },
            "return_type": "UNITY_INTERNAL_PTR"
          }
        },
        {
          "fn_code": "UnityDoubleToPtr(const double num)",
          "fn_dec_pos": [
            [
              571,
              19
            ],
            [
              571,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityDoubleToPtr",
            "parameters": {
              "num": "double"
            },
            "return_type": "UNITY_INTERNAL_PTR"
          }
        },
        {
          "fn_code": "UnityParseOptions(int argc, char** argv)",
          "fn_dec_pos": [
            [
              636,
              4
            ],
            [
              636,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityParseOptions",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "UnityTestMatches(void)",
          "fn_dec_pos": [
            [
              637,
              4
            ],
            [
              637,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityTestMatches",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct UNITY_STORAGE_T\n{\n    const char* TestFile;\n    const char* CurrentTestName;\n#ifndef UNITY_EXCLUDE_DETAILS\n    const char* CurrentDetail1;\n    const char* CurrentDetail2;\n#endif\n    UNITY_LINE_TYPE CurrentTestLineNumber;\n    UNITY_COUNTER_TYPE NumberOfTests;\n    UNITY_COUNTER_TYPE TestFailures;\n    UNITY_COUNTER_TYPE TestIgnores;\n    UNITY_COUNTER_TYPE CurrentTestFailed;\n    UNITY_COUNTER_TYPE CurrentTestIgnored;\n#ifndef UNITY_EXCLUDE_SETJMP_H\n    jmp_buf AbortFrame;\n#endif\n}",
          {
            "char": "const",
            "CurrentTestLineNumber": "UNITY_LINE_TYPE",
            "NumberOfTests": "UNITY_COUNTER_TYPE",
            "TestFailures": "UNITY_COUNTER_TYPE",
            "TestIgnores": "UNITY_COUNTER_TYPE",
            "CurrentTestFailed": "UNITY_COUNTER_TYPE",
            "CurrentTestIgnored": "UNITY_COUNTER_TYPE",
            "AbortFrame": "jmp_buf"
          },
          "UNITY_STORAGE_T",
          [
            382,
            0
          ],
          [
            399,
            1
          ]
        ],
        [
          "struct UNITY_STORAGE_T\n{\n    const char* TestFile;\n    const char* CurrentTestName;\n#ifndef UNITY_EXCLUDE_DETAILS\n    const char* CurrentDetail1;\n    const char* CurrentDetail2;\n#endif\n    UNITY_LINE_TYPE CurrentTestLineNumber;\n    UNITY_COUNTER_TYPE NumberOfTests;\n    UNITY_COUNTER_TYPE TestFailures;\n    UNITY_COUNTER_TYPE TestIgnores;\n    UNITY_COUNTER_TYPE CurrentTestFailed;\n    UNITY_COUNTER_TYPE CurrentTestIgnored;\n#ifndef UNITY_EXCLUDE_SETJMP_H\n    jmp_buf AbortFrame;\n#endif\n}",
          {
            "char": "const",
            "CurrentTestLineNumber": "UNITY_LINE_TYPE",
            "NumberOfTests": "UNITY_COUNTER_TYPE",
            "TestFailures": "UNITY_COUNTER_TYPE",
            "TestIgnores": "UNITY_COUNTER_TYPE",
            "CurrentTestFailed": "UNITY_COUNTER_TYPE",
            "CurrentTestIgnored": "UNITY_COUNTER_TYPE",
            "AbortFrame": "jmp_buf"
          },
          "UNITY_STORAGE_T",
          [
            382,
            0
          ],
          [
            399,
            1
          ]
        ],
        [
          "struct UNITY_STORAGE_T",
          {},
          "",
          [
            401,
            7
          ],
          [
            401,
            29
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"../examples/unity_config.h\"\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include <setjmp.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include <stdint.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            242,
            0
          ],
          [
            243,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            254,
            0
          ],
          [
            255,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum\n{\nUNITY_DISPLAY_STYLE_INT = sizeof(int)+ UNITY_DISPLAY_RANGE_INT,\n    UNITY_DISPLAY_STYLE_INT8     = 1 + UNITY_DISPLAY_RANGE_INT,\n    UNITY_DISPLAY_STYLE_INT16    = 2 + UNITY_DISPLAY_RANGE_INT,\n    UNITY_DISPLAY_STYLE_INT32    = 4 + UNITY_DISPLAY_RANGE_INT,\n#ifdef UNITY_SUPPORT_64\n    UNITY_DISPLAY_STYLE_INT64    = 8 + UNITY_DISPLAY_RANGE_INT,\n#endif\n\nUNITY_DISPLAY_STYLE_UINT = sizeof(unsigned) + UNITY_DISPLAY_RANGE_UINT,\n    UNITY_DISPLAY_STYLE_UINT8    = 1 + UNITY_DISPLAY_RANGE_UINT,\n    UNITY_DISPLAY_STYLE_UINT16   = 2 + UNITY_DISPLAY_RANGE_UINT,\n    UNITY_DISPLAY_STYLE_UINT32   = 4 + UNITY_DISPLAY_RANGE_UINT,\n#ifdef UNITY_SUPPORT_64\n    UNITY_DISPLAY_STYLE_UINT64   = 8 + UNITY_DISPLAY_RANGE_UINT,\n#endif\n\n    UNITY_DISPLAY_STYLE_HEX8     = 1 + UNITY_DISPLAY_RANGE_HEX,\n    UNITY_DISPLAY_STYLE_HEX16    = 2 + UNITY_DISPLAY_RANGE_HEX,\n    UNITY_DISPLAY_STYLE_HEX32    = 4 + UNITY_DISPLAY_RANGE_HEX,\n#ifdef UNITY_SUPPORT_64\n    UNITY_DISPLAY_STYLE_HEX64    = 8 + UNITY_DISPLAY_RANGE_HEX,\n#endif\n\n    UNITY_DISPLAY_STYLE_UNKNOWN\n} UNITY_DISPLAY_STYLE_T;",
          {
            "UNITY_DISPLAY_STYLE_INT": "",
            "UNITY_DISPLAY_STYLE_INT8": "",
            "UNITY_DISPLAY_STYLE_INT16": "",
            "UNITY_DISPLAY_STYLE_INT32": "",
            "UNITY_DISPLAY_STYLE_INT64": "",
            "UNITY_DISPLAY_STYLE_UINT": "",
            "UNITY_DISPLAY_STYLE_UINT8": "",
            "UNITY_DISPLAY_STYLE_UINT16": "",
            "UNITY_DISPLAY_STYLE_UINT32": "",
            "UNITY_DISPLAY_STYLE_UINT64": "",
            "UNITY_DISPLAY_STYLE_HEX8": "",
            "UNITY_DISPLAY_STYLE_HEX16": "",
            "UNITY_DISPLAY_STYLE_HEX32": "",
            "UNITY_DISPLAY_STYLE_HEX64": "",
            "UNITY_DISPLAY_STYLE_UNKNOWN": ""
          },
          "UNITY_DISPLAY_STYLE_T",
          [
            324,
            0
          ],
          [
            350,
            24
          ]
        ],
        [
          "typedef enum\n{\n    UNITY_EQUAL_TO         = 1,\n    UNITY_GREATER_THAN     = 2,\n    UNITY_GREATER_OR_EQUAL = 2 + UNITY_EQUAL_TO,\n    UNITY_SMALLER_THAN     = 4,\n    UNITY_SMALLER_OR_EQUAL = 4 + UNITY_EQUAL_TO\n} UNITY_COMPARISON_T;",
          {
            "UNITY_EQUAL_TO": "",
            "UNITY_GREATER_THAN": "",
            "UNITY_GREATER_OR_EQUAL": "",
            "UNITY_SMALLER_THAN": "",
            "UNITY_SMALLER_OR_EQUAL": ""
          },
          "UNITY_COMPARISON_T",
          [
            352,
            0
          ],
          [
            359,
            21
          ]
        ],
        [
          "typedef enum UNITY_FLOAT_TRAIT\n{\n    UNITY_FLOAT_IS_NOT_INF       = 0,\n    UNITY_FLOAT_IS_INF,\n    UNITY_FLOAT_IS_NOT_NEG_INF,\n    UNITY_FLOAT_IS_NEG_INF,\n    UNITY_FLOAT_IS_NOT_NAN,\n    UNITY_FLOAT_IS_NAN,\n    UNITY_FLOAT_IS_NOT_DET,\n    UNITY_FLOAT_IS_DET,\n    UNITY_FLOAT_INVALID_TRAIT\n} UNITY_FLOAT_TRAIT_T;",
          {
            "UNITY_FLOAT_IS_NOT_INF": "",
            "UNITY_FLOAT_IS_INF": "",
            "UNITY_FLOAT_IS_NOT_NEG_INF": "",
            "UNITY_FLOAT_IS_NEG_INF": "",
            "UNITY_FLOAT_IS_NOT_NAN": "",
            "UNITY_FLOAT_IS_NAN": "",
            "UNITY_FLOAT_IS_NOT_DET": "",
            "UNITY_FLOAT_IS_DET": "",
            "UNITY_FLOAT_INVALID_TRAIT": ""
          },
          "UNITY_FLOAT_TRAIT_T",
          [
            362,
            0
          ],
          [
            373,
            22
          ]
        ],
        [
          "typedef enum\n{\n    UNITY_ARRAY_TO_VAL = 0,\n    UNITY_ARRAY_TO_ARRAY\n} UNITY_FLAGS_T;",
          {
            "UNITY_ARRAY_TO_VAL": "",
            "UNITY_ARRAY_TO_ARRAY": ""
          },
          "UNITY_FLAGS_T",
          [
            376,
            0
          ],
          [
            380,
            16
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/examples/unity_config.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/examples/example_2/src/ProductionCode.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "FindFunction_WhichIsBroken(int NumberToFind)",
          "fn_dec_pos": [
            [
              1,
              4
            ],
            [
              1,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FindFunction_WhichIsBroken",
            "parameters": {
              "NumberToFind": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "FunctionWhichReturnsLocalVariable(void)",
          "fn_dec_pos": [
            [
              2,
              4
            ],
            [
              2,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FunctionWhichReturnsLocalVariable",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/examples/example_2/src/ProductionCode2.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ThisFunctionHasNotBeenTested(int Poor, char* LittleFunction)",
          "fn_dec_pos": [
            [
              1,
              6
            ],
            [
              1,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ThisFunctionHasNotBeenTested",
            "parameters": {
              "Poor": "int",
              "LittleFunction": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/examples/example_3/src/ProductionCode.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "FindFunction_WhichIsBroken(int NumberToFind)",
          "fn_dec_pos": [
            [
              1,
              4
            ],
            [
              1,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FindFunction_WhichIsBroken",
            "parameters": {
              "NumberToFind": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "FunctionWhichReturnsLocalVariable(void)",
          "fn_dec_pos": [
            [
              2,
              4
            ],
            [
              2,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FunctionWhichReturnsLocalVariable",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/examples/example_3/src/ProductionCode2.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ThisFunctionHasNotBeenTested(int Poor, char* LittleFunction)",
          "fn_dec_pos": [
            [
              1,
              6
            ],
            [
              1,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ThisFunctionHasNotBeenTested",
            "parameters": {
              "Poor": "int",
              "LittleFunction": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/examples/example_3/helper/UnityHelper.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "AssertEqualExampleStruct(const EXAMPLE_STRUCT_T expected, const EXAMPLE_STRUCT_T actual, const unsigned short line)",
          "fn_dec_pos": [
            [
              5,
              5
            ],
            [
              5,
              120
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "AssertEqualExampleStruct",
            "parameters": {
              "expected": "EXAMPLE_STRUCT_T",
              "actual": "EXAMPLE_STRUCT_T",
              "line": "unsigned short"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"Types.h\"\n",
          [
            3,
            0
          ],
          [
            4,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/examples/example_1/src/ProductionCode.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "FindFunction_WhichIsBroken(int NumberToFind)",
          "fn_dec_pos": [
            [
              1,
              4
            ],
            [
              1,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FindFunction_WhichIsBroken",
            "parameters": {
              "NumberToFind": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "FunctionWhichReturnsLocalVariable(void)",
          "fn_dec_pos": [
            [
              2,
              4
            ],
            [
              2,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FunctionWhichReturnsLocalVariable",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/examples/example_1/src/ProductionCode2.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ThisFunctionHasNotBeenTested(int Poor, char* LittleFunction)",
          "fn_dec_pos": [
            [
              1,
              6
            ],
            [
              1,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ThisFunctionHasNotBeenTested",
            "parameters": {
              "Poor": "int",
              "LittleFunction": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/extras/fixture/src/unity_fixture_internals.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "unityfunction(void)",
          "fn_dec_pos": [
            [
              24,
              13
            ],
            [
              24,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityTestRunner(unityfunction* setup,\n                     unityfunction* body,\n                     unityfunction* teardown,\n                     const char* printableName,\n                     const char* group,\n                     const char* name,\n                     const char* file, unsigned int line)",
          "fn_dec_pos": [
            [
              25,
              5
            ],
            [
              31,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityTestRunner",
            "parameters": {
              "setup": "unityfunction",
              "body": "unityfunction",
              "teardown": "unityfunction",
              "printableName": "char",
              "group": "char",
              "name": "char",
              "file": "char",
              "line": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityIgnoreTest(const char* printableName, const char* group, const char* name)",
          "fn_dec_pos": [
            [
              33,
              5
            ],
            [
              33,
              84
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityIgnoreTest",
            "parameters": {
              "printableName": "char",
              "group": "char",
              "name": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityMalloc_StartTest(void)",
          "fn_dec_pos": [
            [
              34,
              5
            ],
            [
              34,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityMalloc_StartTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityMalloc_EndTest(void)",
          "fn_dec_pos": [
            [
              35,
              5
            ],
            [
              35,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityMalloc_EndTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityGetCommandLineOptions(int argc, const char* argv[])",
          "fn_dec_pos": [
            [
              36,
              4
            ],
            [
              36,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityGetCommandLineOptions",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "UnityConcludeFixtureTest(void)",
          "fn_dec_pos": [
            [
              37,
              5
            ],
            [
              37,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityConcludeFixtureTest",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityPointer_Set(void** ptr, void* newValue, UNITY_LINE_TYPE line)",
          "fn_dec_pos": [
            [
              39,
              5
            ],
            [
              39,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPointer_Set",
            "parameters": {
              "ptr": "void",
              "newValue": "void",
              "line": "UNITY_LINE_TYPE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityPointer_UndoAllSets(void)",
          "fn_dec_pos": [
            [
              40,
              5
            ],
            [
              40,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPointer_UndoAllSets",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityPointer_Init(void)",
          "fn_dec_pos": [
            [
              41,
              5
            ],
            [
              41,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityPointer_Init",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct UNITY_FIXTURE_T\n{\n    int Verbose;\n    unsigned int RepeatCount;\n    const char* NameFilter;\n    const char* GroupFilter;\n}",
          {
            "Verbose": "int",
            "RepeatCount": "unsigned int",
            "char": "const"
          },
          "UNITY_FIXTURE_T",
          [
            15,
            0
          ],
          [
            21,
            1
          ]
        ],
        [
          "struct UNITY_FIXTURE_T\n{\n    int Verbose;\n    unsigned int RepeatCount;\n    const char* NameFilter;\n    const char* GroupFilter;\n}",
          {
            "Verbose": "int",
            "RepeatCount": "unsigned int",
            "char": "const"
          },
          "UNITY_FIXTURE_T",
          [
            15,
            0
          ],
          [
            21,
            1
          ]
        ],
        [
          "struct UNITY_FIXTURE_T",
          {},
          "",
          [
            22,
            7
          ],
          [
            22,
            29
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/extras/fixture/src/unity_fixture.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "UnityMain(int argc, const char* argv[], void (*runAllTests)(void))",
          "fn_dec_pos": [
            [
              15,
              4
            ],
            [
              15,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityMain",
            "parameters": {
              "argc": "int",
              "argv": "char",
              "runAllTests": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*runAllTests)(void)",
          "fn_dec_pos": [
            [
              15,
              49
            ],
            [
              15,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "UnityMalloc_MakeMallocFailAfterCount(int count)",
          "fn_dec_pos": [
            [
              80,
              5
            ],
            [
              80,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UnityMalloc_MakeMallocFailAfterCount",
            "parameters": {
              "count": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"unity.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"unity_internals.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"unity_fixture_malloc_overrides.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"unity_fixture_internals.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/cjson/tests/unity/extras/fixture/src/unity_fixture_malloc_overrides.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "UNITY_FIXTURE_MALLOC(size_t size)",
          "fn_dec_pos": [
            [
              32,
              17
            ],
            [
              32,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UNITY_FIXTURE_MALLOC",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "UNITY_FIXTURE_FREE(void* ptr)",
          "fn_dec_pos": [
            [
              33,
              16
            ],
            [
              33,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "UNITY_FIXTURE_FREE",
            "parameters": {
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "unity_malloc(size_t size)",
          "fn_dec_pos": [
            [
              41,
              6
            ],
            [
              41,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unity_malloc",
            "parameters": {
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unity_calloc(size_t num, size_t size)",
          "fn_dec_pos": [
            [
              42,
              6
            ],
            [
              42,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unity_calloc",
            "parameters": {
              "num": "size_t",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unity_realloc(void * oldMem, size_t size)",
          "fn_dec_pos": [
            [
              43,
              6
            ],
            [
              43,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unity_realloc",
            "parameters": {
              "oldMem": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unity_free(void * mem)",
          "fn_dec_pos": [
            [
              44,
              5
            ],
            [
              44,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unity_free",
            "parameters": {
              "mem": "void"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stddef.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            28,
            4
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    }
  }
}